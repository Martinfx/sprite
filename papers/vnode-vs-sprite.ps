%!
%%BoundingBox: (atend)
%%Pages: (atend)
%%DocumentFonts: (atend)
%%EndComments
%
% FrameMaker PostScript Prolog 3.0, for use with FrameMaker 3.0
% Copyright (c) 1986,87,89,90,91 by Frame Technology Corporation.
% All rights reserved.
%
% Known Problems:
%	Due to bugs in Transcript, the 'PS-Adobe-' is omitted from line 1
/FMversion (3.0) def 
% Set up Color vs. Black-and-White
	/FMPrintInColor systemdict /colorimage known
		systemdict /currentcolortransfer known or def
% Uncomment this line to force b&w on color printer
%   /FMPrintInColor false def
/FrameDict 195 dict def 
systemdict /errordict known not {/errordict 10 dict def
		errordict /rangecheck {stop} put} if
% The readline in 23.0 doesn't recognize cr's as nl's on AppleTalk
FrameDict /tmprangecheck errordict /rangecheck get put 
errordict /rangecheck {FrameDict /bug true put} put 
FrameDict /bug false put 
mark 
% Some PS machines read past the CR, so keep the following 3 lines together!
currentfile 5 string readline
00
0000000000
cleartomark 
errordict /rangecheck FrameDict /tmprangecheck get put 
FrameDict /bug get { 
	/readline {
		/gstring exch def
		/gfile exch def
		/gindex 0 def
		{
			gfile read pop 
			dup 10 eq {exit} if 
			dup 13 eq {exit} if 
			gstring exch gindex exch put 
			/gindex gindex 1 add def 
		} loop
		pop 
		gstring 0 gindex getinterval true 
		} def
	} if
/FMVERSION {
	FMversion ne {
		/Times-Roman findfont 18 scalefont setfont
		100 100 moveto
		(FrameMaker version does not match postscript_prolog!)
		dup =
		show showpage
		} if
	} def 
/FMLOCAL {
	FrameDict begin
	0 def 
	end 
	} def 
	/gstring FMLOCAL
	/gfile FMLOCAL
	/gindex FMLOCAL
	/orgxfer FMLOCAL
	/orgproc FMLOCAL
	/organgle FMLOCAL
	/orgfreq FMLOCAL
	/yscale FMLOCAL
	/xscale FMLOCAL
	/manualfeed FMLOCAL
	/paperheight FMLOCAL
	/paperwidth FMLOCAL
/FMDOCUMENT { 
	array /FMfonts exch def 
	/#copies exch def
	FrameDict begin
	0 ne dup {setmanualfeed} if
	/manualfeed exch def
	/paperheight exch def
	/paperwidth exch def
	/yscale exch def
	/xscale exch def
	currenttransfer cvlit /orgxfer exch def
	currentscreen cvlit /orgproc exch def
	/organgle exch def /orgfreq exch def
	setpapername 
	manualfeed {true} {papersize} ifelse 
	{manualpapersize} {false} ifelse 
	{desperatepapersize} if
	end 
	} def 
	/pagesave FMLOCAL
	/orgmatrix FMLOCAL
	/landscape FMLOCAL
/FMBEGINPAGE { 
	FrameDict begin 
	/pagesave save def
	3.86 setmiterlimit
	/landscape exch 0 ne def
	landscape { 
		90 rotate 0 exch neg translate pop 
		}
		{pop pop}
		ifelse
	xscale yscale scale
	/orgmatrix matrix def
	gsave 
	} def 
/FMENDPAGE {
	grestore 
	pagesave restore
	end 
	showpage
	} def 
/FMFONTDEFINE { 
	FrameDict begin
	findfont 
	ReEncode 
	1 index exch 
	definefont 
	FMfonts 3 1 roll 
	put
	end 
	} def 
/FMFILLS {
	FrameDict begin
	array /fillvals exch def
	end 
	} def 
/FMFILL {
	FrameDict begin
	 fillvals 3 1 roll put
	end 
	} def 
/FMNORMALIZEGRAPHICS { 
	newpath
	0.0 0.0 moveto
	1 setlinewidth
	0 setlinecap
	0 0 0 sethsbcolor
	0 setgray 
	} bind def
	/fx FMLOCAL
	/fy FMLOCAL
	/fh FMLOCAL
	/fw FMLOCAL
	/llx FMLOCAL
	/lly FMLOCAL
	/urx FMLOCAL
	/ury FMLOCAL
/FMBEGINEPSF { 
	end 
	/FMEPSF save def 
	/showpage {} def 
	FMNORMALIZEGRAPHICS 
	[/fy /fx /fh /fw /ury /urx /lly /llx] {exch def} forall 
	fx fy translate 
	rotate
	fw urx llx sub div fh ury lly sub div scale 
	llx neg lly neg translate 
	} bind def
/FMENDEPSF {
	FMEPSF restore
	FrameDict begin 
	} bind def
FrameDict begin 
/setmanualfeed {
%%BeginFeature *ManualFeed True
	 statusdict /manualfeed true put
%%EndFeature
	} def
/max {2 copy lt {exch} if pop} bind def
/min {2 copy gt {exch} if pop} bind def
/inch {72 mul} def
/pagedimen { 
	paperheight sub abs 16 lt exch 
	paperwidth sub abs 16 lt and
	{/papername exch def} {pop} ifelse
	} def
	/papersizedict FMLOCAL
/setpapername { 
	/papersizedict 14 dict def 
	papersizedict begin
	/papername /unknown def 
		/Letter 8.5 inch 11.0 inch pagedimen
		/LetterSmall 7.68 inch 10.16 inch pagedimen
		/Tabloid 11.0 inch 17.0 inch pagedimen
		/Ledger 17.0 inch 11.0 inch pagedimen
		/Legal 8.5 inch 14.0 inch pagedimen
		/Statement 5.5 inch 8.5 inch pagedimen
		/Executive 7.5 inch 10.0 inch pagedimen
		/A3 11.69 inch 16.5 inch pagedimen
		/A4 8.26 inch 11.69 inch pagedimen
		/A4Small 7.47 inch 10.85 inch pagedimen
		/B4 10.125 inch 14.33 inch pagedimen
		/B5 7.16 inch 10.125 inch pagedimen
	end
	} def
/papersize {
	papersizedict begin
		/Letter {lettertray letter} def
		/LetterSmall {lettertray lettersmall} def
		/Tabloid {11x17tray 11x17} def
		/Ledger {ledgertray ledger} def
		/Legal {legaltray legal} def
		/Statement {statementtray statement} def
		/Executive {executivetray executive} def
		/A3 {a3tray a3} def
		/A4 {a4tray a4} def
		/A4Small {a4tray a4small} def
		/B4 {b4tray b4} def
		/B5 {b5tray b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	/FMdicttop countdictstack 1 add def 
	statusdict begin stopped end 
	countdictstack -1 FMdicttop {pop end} for 
	} def
/manualpapersize {
	papersizedict begin
		/Letter {letter} def
		/LetterSmall {lettersmall} def
		/Tabloid {11x17} def
		/Ledger {ledger} def
		/Legal {legal} def
		/Statement {statement} def
		/Executive {executive} def
		/A3 {a3} def
		/A4 {a4} def
		/A4Small {a4small} def
		/B4 {b4} def
		/B5 {b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	stopped 
	} def
/desperatepapersize {
	statusdict /setpageparams known
		{
		paperwidth paperheight 0 1 
		statusdict begin
		{setpageparams} stopped pop 
		end
		} if
	} def
/savematrix {
	orgmatrix currentmatrix pop
	} bind def
/restorematrix {
	orgmatrix setmatrix
	} bind def
/dmatrix matrix def
/dpi    72 0 dmatrix defaultmatrix dtransform
    dup mul exch   dup mul add   sqrt def
/freq dpi 18.75 div 8 div round dup 0 eq {pop 1} if 8 mul dpi exch div def
/sangle 1 0 dmatrix defaultmatrix dtransform exch atan def
/DiacriticEncoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl
/numbersign /dollar /percent /ampersand /quotesingle /parenleft
/parenright /asterisk /plus /comma /hyphen /period /slash /zero /one
/two /three /four /five /six /seven /eight /nine /colon /semicolon
/less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K
/L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash
/bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h
/i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar
/braceright /asciitilde /.notdef /Adieresis /Aring /Ccedilla /Eacute
/Ntilde /Odieresis /Udieresis /aacute /agrave /acircumflex /adieresis
/atilde /aring /ccedilla /eacute /egrave /ecircumflex /edieresis
/iacute /igrave /icircumflex /idieresis /ntilde /oacute /ograve
/ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex
/udieresis /dagger /.notdef /cent /sterling /section /bullet
/paragraph /germandbls /registered /copyright /trademark /acute
/dieresis /.notdef /AE /Oslash /.notdef /.notdef /.notdef /.notdef
/yen /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/ordfeminine /ordmasculine /.notdef /ae /oslash /questiondown
/exclamdown /logicalnot /.notdef /florin /.notdef /.notdef
/guillemotleft /guillemotright /ellipsis /.notdef /Agrave /Atilde
/Otilde /OE /oe /endash /emdash /quotedblleft /quotedblright
/quoteleft /quoteright /.notdef /.notdef /ydieresis /Ydieresis
/fraction /currency /guilsinglleft /guilsinglright /fi /fl /daggerdbl
/periodcentered /quotesinglbase /quotedblbase /perthousand
/Acircumflex /Ecircumflex /Aacute /Edieresis /Egrave /Iacute
/Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex /.notdef /Ograve
/Uacute /Ucircumflex /Ugrave /dotlessi /circumflex /tilde /macron
/breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron
] def
/ReEncode { 
	dup 
	length 
	dict begin 
	{
	1 index /FID ne 
		{def} 
		{pop pop} ifelse 
	} forall 
	0 eq {/Encoding DiacriticEncoding def} if 
	currentdict 
	end 
	} bind def
/graymode true def
	/bwidth FMLOCAL
	/bpside FMLOCAL
	/bstring FMLOCAL
	/onbits FMLOCAL
	/offbits FMLOCAL
	/xindex FMLOCAL
	/yindex FMLOCAL
	/x FMLOCAL
	/y FMLOCAL
/setpattern {
	 /bwidth  exch def
	 /bpside  exch def
	 /bstring exch def
	 /onbits 0 def  /offbits 0 def
	 freq sangle landscape {90 add} if 
		{/y exch def
		 /x exch def
		 /xindex x 1 add 2 div bpside mul cvi def
		 /yindex y 1 add 2 div bpside mul cvi def
		 bstring yindex bwidth mul xindex 8 idiv add get
		 1 7 xindex 8 mod sub bitshift and 0 ne
		 {/onbits  onbits  1 add def 1}
		 {/offbits offbits 1 add def 0}
		 ifelse
		}
		setscreen
	 {} settransfer
	 offbits offbits onbits add div FMsetgray
	/graymode false def
	} bind def
/grayness {
	FMsetgray
	graymode not {
		/graymode true def
		orgxfer cvx settransfer
		orgfreq organgle orgproc cvx setscreen
		} if
	} bind def
	/HUE FMLOCAL
	/SAT FMLOCAL
	/BRIGHT FMLOCAL
	/Colors FMLOCAL
FMPrintInColor 
	
	{
	/HUE 0 def
	/SAT 0 def
	/BRIGHT 0 def
	% array of arrays Hue and Sat values for the separations [HUE BRIGHT]
	/Colors   
	[[0    0  ]    % black
	 [0    0  ]    % white
	 [0.00 1.0]    % red
	 [0.37 1.0]    % green
	 [0.67 1.0]    % blue
	 [0.50 1.0]    % cyan
	 [0.83 1.0]    % magenta
	 [0.16 1.0]    % comment / yellow
	 ] def
      
	/BEGINBITMAPCOLOR { 
		BITMAPCOLOR} def
	/BEGINBITMAPCOLORc { 
		BITMAPCOLORc} def
	/BEGINBITMAPTRUECOLOR { 
		BITMAPTRUECOLOR } def
	/BEGINBITMAPCOLORc { 
		BITMAPTRUECOLORc } def
	/K { 
		Colors exch get dup
		0 get /HUE exch store 
		1 get /BRIGHT exch store
		  HUE 0 eq BRIGHT 0 eq and
			{1.0 SAT sub setgray}
			{HUE SAT BRIGHT sethsbcolor} 
		  ifelse
		} def
	/FMsetgray { 
		/SAT exch 1.0 exch sub store 
		  HUE 0 eq BRIGHT 0 eq and
			{1.0 SAT sub setgray}
			{HUE SAT BRIGHT sethsbcolor} 
		  ifelse
		} bind def
	}
	
	{
	/BEGINBITMAPCOLOR { 
		BITMAPGRAY} def
	/BEGINBITMAPCOLORc { 
		BITMAPGRAYc} def
	/BEGINBITMAPTRUECOLOR { 
		BITMAPTRUEGRAY } def
	/BEGINBITMAPTRUECOLORc { 
		BITMAPTRUEGRAYc } def
	/FMsetgray {setgray} bind def
	/K { 
		pop
		} def
	}
ifelse
/normalize {
	transform round exch round exch itransform
	} bind def
/dnormalize {
	dtransform round exch round exch idtransform
	} bind def
/lnormalize { 
	0 dtransform exch cvi 2 idiv 2 mul 1 add exch idtransform pop
	} bind def
/H { 
	lnormalize setlinewidth
	} bind def
/Z {
	setlinecap
	} bind def
	/fillvals FMLOCAL
/X { 
	fillvals exch get
	dup type /stringtype eq
	{8 1 setpattern} 
	{grayness}
	ifelse
	} bind def
/V { 
	gsave eofill grestore
	} bind def
/N { 
	stroke
	} bind def
/M {newpath moveto} bind def
/E {lineto} bind def
/D {curveto} bind def
/O {closepath} bind def
	/n FMLOCAL
/L { 
 	/n exch def
	newpath
	normalize
	moveto 
	2 1 n {pop normalize lineto} for
	} bind def
/Y { 
	L 
	closepath
	} bind def
	/x1 FMLOCAL
	/x2 FMLOCAL
	/y1 FMLOCAL
	/y2 FMLOCAL
	/rad FMLOCAL
/R { 
	/y2 exch def
	/x2 exch def
	/y1 exch def
	/x1 exch def
	x1 y1
	x2 y1
	x2 y2
	x1 y2
	4 Y 
	} bind def
/RR { 
	/rad exch def
	normalize
	/y2 exch def
	/x2 exch def
	normalize
	/y1 exch def
	/x1 exch def
	newpath
	x1 y1 rad add moveto
	x1 y2 x2 y2 rad arcto
	x2 y2 x2 y1 rad arcto
	x2 y1 x1 y1 rad arcto
	x1 y1 x1 y2 rad arcto
	closepath
	16 {pop} repeat
	} bind def
/C { 
	grestore
	gsave
	R 
	clip
	} bind def
	/FMpointsize FMLOCAL
/F { 
	FMfonts exch get
	FMpointsize scalefont
	setfont
	} bind def
/Q { 
	/FMpointsize exch def
	F 
	} bind def
/T { 
	moveto show
	} bind def
/RF { 
	rotate
	0 ne {-1 1 scale} if
	} bind def
/TF { 
	gsave
	moveto 
	RF
	show
	grestore
	} bind def
/P { 
	moveto
	0 32 3 2 roll widthshow
	} bind def
/PF { 
	gsave
	moveto 
	RF
	0 32 3 2 roll widthshow
	grestore
	} bind def
/S { 
	moveto
	0 exch ashow
	} bind def
/SF { 
	gsave
	moveto
	RF
	0 exch ashow
	grestore
	} bind def
/B { 
	moveto
	0 32 4 2 roll 0 exch awidthshow
	} bind def
/BF { 
	gsave
	moveto
	RF
	0 32 4 2 roll 0 exch awidthshow
	grestore
	} bind def
/G { 
	gsave
	newpath
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath fill
	grestore
	} bind def
/A { 
	gsave
	savematrix
	newpath
	2 index 2 div add exch 3 index 2 div sub exch 
	normalize 2 index 2 div sub exch 3 index 2 div add exch 
	translate 
	scale 
	0.0 0.0 1.0 5 3 roll arc 
	restorematrix
	stroke
	grestore
	} bind def
	/x FMLOCAL
	/y FMLOCAL
	/w FMLOCAL
	/h FMLOCAL
	/xx FMLOCAL
	/yy FMLOCAL
	/ww FMLOCAL
	/hh FMLOCAL
	/FMsaveobject FMLOCAL
	/FMoptop FMLOCAL
	/FMdicttop FMLOCAL
/BEGINPRINTCODE { 
	/FMdicttop countdictstack 1 add def 
	/FMoptop count 4 sub def 
	/FMsaveobject save def
	userdict begin 
	/showpage {} def 
	FMNORMALIZEGRAPHICS 
	3 index neg 3 index neg translate
	} bind def
/ENDPRINTCODE {
	count -1 FMoptop {pop pop} for 
	countdictstack -1 FMdicttop {pop end} for 
	FMsaveobject restore 
	} bind def
/gn { 
	0 
	{	46 mul 
		cf read pop 
		32 sub 
		dup 46 lt {exit} if 
		46 sub add 
		} loop
	add 
	} bind def
	/str FMLOCAL
/cfs { 
	/str sl string def 
	0 1 sl 1 sub {str exch val put} for 
	str def 
	} bind def
/ic [ 
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0
	{0 hx} {1 hx} {2 hx} {3 hx} {4 hx} {5 hx} {6 hx} {7 hx} {8 hx} {9 hx}
	{10 hx} {11 hx} {12 hx} {13 hx} {14 hx} {15 hx} {16 hx} {17 hx} {18 hx}
	{19 hx} {gn hx} {0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12}
	{13} {14} {15} {16} {17} {18} {19} {gn} {0 wh} {1 wh} {2 wh} {3 wh}
	{4 wh} {5 wh} {6 wh} {7 wh} {8 wh} {9 wh} {10 wh} {11 wh} {12 wh}
	{13 wh} {14 wh} {gn wh} {0 bl} {1 bl} {2 bl} {3 bl} {4 bl} {5 bl} {6 bl}
	{7 bl} {8 bl} {9 bl} {10 bl} {11 bl} {12 bl} {13 bl} {14 bl} {gn bl}
	{0 fl} {1 fl} {2 fl} {3 fl} {4 fl} {5 fl} {6 fl} {7 fl} {8 fl} {9 fl}
	{10 fl} {11 fl} {12 fl} {13 fl} {14 fl} {gn fl}
	] def
	/sl FMLOCAL
	/val FMLOCAL
	/ws FMLOCAL
	/im FMLOCAL
	/bs FMLOCAL
	/cs FMLOCAL
	/len FMLOCAL
	/pos FMLOCAL
/ms { 
	/sl exch def 
	/val 255 def 
	/ws cfs 
	/im cfs 
	/val 0 def 
	/bs cfs 
	/cs cfs 
	} bind def
400 ms 
/ip { 
	is 
	0 
	cf cs readline pop 
	{	ic exch get exec 
		add 
		} forall 
	pop 
	
	} bind def
/wh { 
	/len exch def 
	/pos exch def 
	ws 0 len getinterval im pos len getinterval copy pop
	pos len 
	} bind def
/bl { 
	/len exch def 
	/pos exch def 
	bs 0 len getinterval im pos len getinterval copy pop
	pos len 
	} bind def
/s1 1 string def
/fl { 
	/len exch def 
	/pos exch def 
	/val cf s1 readhexstring pop 0 get def
	pos 1 pos len add 1 sub {im exch val put} for
	pos len 
	} bind def
/hx { 
	3 copy getinterval 
	cf exch readhexstring pop pop 
	} bind def
	/h FMLOCAL
	/w FMLOCAL
	/d FMLOCAL
	/lb FMLOCAL
	/bitmapsave FMLOCAL
	/is FMLOCAL
	/cf FMLOCAL
/wbytes { 
	dup 
	8 eq {pop} {1 eq {7 add 8 idiv} {3 add 4 idiv} ifelse} ifelse
	} bind def
/BEGINBITMAPBWc { 
	1 {} COMMONBITMAPc
	} bind def
/BEGINBITMAPGRAYc { 
	8 {} COMMONBITMAPc
	} bind def
/BEGINBITMAP2BITc { 
	2 {} COMMONBITMAPc
	} bind def
/COMMONBITMAPc { 
	/r exch def
	/d exch def
	gsave
	translate rotate scale /h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
	r                    
	/is im 0 lb getinterval def 
	ws 0 lb getinterval is copy pop 
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{ip} image 
	bitmapsave restore 
	grestore
	} bind def
/BEGINBITMAPBW { 
	1 {} COMMONBITMAP
	} bind def
/BEGINBITMAPGRAY { 
	8 {} COMMONBITMAP
	} bind def
/BEGINBITMAP2BIT { 
	2 {} COMMONBITMAP
	} bind def
/COMMONBITMAP { 
	/r exch def
	/d exch def
	gsave
	translate rotate scale /h exch def /w exch def
	/bitmapsave save def 
	r                    
	/is w d wbytes string def
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{cf is readhexstring pop} image
	bitmapsave restore 
	grestore
	} bind def
	/proc1 FMLOCAL
	/proc2 FMLOCAL
	/newproc FMLOCAL
/Fmcc {
    /proc2 exch cvlit def
    /proc1 exch cvlit def
    /newproc proc1 length proc2 length add array def
    newproc 0 proc1 putinterval
    newproc proc1 length proc2 putinterval
    newproc cvx
} bind def
/ngrayt 256 array def
/nredt 256 array def
/nbluet 256 array def
/ngreent 256 array def
	/gryt FMLOCAL
	/blut FMLOCAL
	/grnt FMLOCAL
	/redt FMLOCAL
	/indx FMLOCAL
	/cynu FMLOCAL
	/magu FMLOCAL
	/yelu FMLOCAL
	/k FMLOCAL
	/u FMLOCAL
/colorsetup {
	currentcolortransfer
	/gryt exch def
	/blut exch def
	/grnt exch def
	/redt exch def
	0 1 255 {
		/indx exch def
		/cynu 1 red indx get 255 div sub def
		/magu 1 green indx get 255 div sub def
		/yelu 1 blue indx get 255 div sub def
		/k cynu magu min yelu min def
		/u k currentundercolorremoval exec def
		nredt indx 1 0 cynu u sub max sub redt exec put
		ngreent indx 1 0 magu u sub max sub grnt exec put
		nbluet indx 1 0 yelu u sub max sub blut exec put
		ngrayt indx 1 k currentblackgeneration exec sub gryt exec put
	} for
	{255 mul cvi nredt exch get}
	{255 mul cvi ngreent exch get}
	{255 mul cvi nbluet exch get}
	{255 mul cvi ngrayt exch get}
	setcolortransfer
	{pop 0} setundercolorremoval
	{} setblackgeneration
	} bind def
	/tran FMLOCAL
/fakecolorsetup {
	/tran 256 string def
	0 1 255 {/indx exch def 
		tran indx
		red indx get 77 mul
		green indx get 151 mul
		blue indx get 28 mul
		add add 256 idiv put} for
	currenttransfer
	{255 mul cvi tran exch get 255.0 div}
	exch Fmcc settransfer
} bind def
/BITMAPCOLOR { 
	/d 8 def
	gsave
	translate rotate scale /h exch def /w exch def
	/bitmapsave save def 
	colorsetup
	/is w d wbytes string def
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{cf is readhexstring pop} {is} {is} true 3 colorimage 
	bitmapsave restore 
	grestore
	} bind def
/BITMAPCOLORc { 
	/d 8 def
	gsave
	translate rotate scale /h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
	colorsetup
	/is im 0 lb getinterval def 
	ws 0 lb getinterval is copy pop 
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{ip} {is} {is} true 3 colorimage
	bitmapsave restore 
	grestore
	} bind def
/BITMAPTRUECOLORc { 
        gsave
        translate rotate scale /h exch def /w exch def
        /bitmapsave save def 
        
        /is w string def
        
        ws 0 w getinterval is copy pop 
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        {ip} {gip} {bip} true 3 colorimage
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUECOLOR { 
        gsave
        translate rotate scale /h exch def /w exch def
        /bitmapsave save def 
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        { cf is readhexstring pop } 
        { cf gis readhexstring pop } 
        { cf bis readhexstring pop } 
        true 3 colorimage 
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUEGRAYc { 
        gsave
        translate rotate scale /h exch def /w exch def
        /bitmapsave save def 
        
        /is w string def
        
        ws 0 w getinterval is copy pop 
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        {ip gip bip w gray} image
        bitmapsave restore 
        grestore
        } bind def
/ww FMLOCAL
/r FMLOCAL
/g FMLOCAL
/b FMLOCAL
/i FMLOCAL
/gray { 
        /ww exch def
        /b exch def
        /g exch def
        /r exch def
        0 1 ww 1 sub { /i exch def r i get .299 mul g i get .587 mul
			b i get .114 mul add add r i 3 -1 roll floor cvi put } for
        r
        } bind def
/BITMAPTRUEGRAY { 
        gsave
        translate rotate scale /h exch def /w exch def
        /bitmapsave save def 
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        { cf is readhexstring pop 
          cf gis readhexstring pop 
          cf bis readhexstring pop w gray}  image
        bitmapsave restore 
        grestore
        } bind def
/BITMAPGRAY { 
	8 {fakecolorsetup} COMMONBITMAP
	} bind def
/BITMAPGRAYc { 
	8 {fakecolorsetup} COMMONBITMAPc
	} bind def
/ENDBITMAP {
	} bind def
end 
	/ALDsave FMLOCAL
	/ALDmatrix matrix def ALDmatrix currentmatrix pop
/StartALD {
	/ALDsave save def
	 savematrix
	 ALDmatrix setmatrix
	} bind def
/InALD {
	 restorematrix
	} bind def
/DoneALD {
	 ALDsave restore
	} bind def
%%EndProlog
%%BeginSetup
(3.0) FMVERSION
1 1 612 792 0 1 6 FMDOCUMENT
0 0 /Times-Bold FMFONTDEFINE
1 0 /Times-Italic FMFONTDEFINE
2 0 /Times-Roman FMFONTDEFINE
32 FMFILLS
0 0 FMFILL
1 .1 FMFILL
2 .3 FMFILL
3 .5 FMFILL
4 .7 FMFILL
5 .9 FMFILL
6 .97 FMFILL
7 1 FMFILL
8 <0f1e3c78f0e1c387> FMFILL
9 <0f87c3e1f0783c1e> FMFILL
10 <cccccccccccccccc> FMFILL
11 <ffff0000ffff0000> FMFILL
12 <8142241818244281> FMFILL
13 <03060c183060c081> FMFILL
14 <8040201008040201> FMFILL
16 1 FMFILL
17 .9 FMFILL
18 .7 FMFILL
19 .5 FMFILL
20 .3 FMFILL
21 .1 FMFILL
22 0.03 FMFILL
23 0 FMFILL
24 <f0e1c3870f1e3c78> FMFILL
25 <f0783c1e0f87c3e1> FMFILL
26 <3333333333333333> FMFILL
27 <0000ffff0000ffff> FMFILL
28 <7ebddbe7e7dbbd7e> FMFILL
29 <fcf9f3e7cf9f3f7e> FMFILL
30 <7fbfdfeff7fbfdfe> FMFILL
%%EndSetup
%%Page: "1" 1
%%BeginPaperSize: Letter
%%EndPaperSize
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
0 14 Q
0 X
(A Comparison of the Vnode and Sprite) 189.4 710.67 T
( File System Ar) 227.57 684.67 T
(chitectur) 319.41 684.67 T
(es) 372.78 684.67 T
1 12 Q
(Br) 276.96 660 T
(ent W) 288.51 660 T
(elch) 315.05 660 T
(welch@par) 249.64 646 T
(c.xer) 304.87 646 T
(ox.com) 328.06 646 T
(Xer) 276.18 632 T
(ox P) 293.06 632 T
(ARC) 313.16 632 T
(3333 Coyote Hill Road) 250.53 618 T
(Palo Alto, CA 94304) 256.02 604 T
0 F
(Abstract) 90 572 T
1 F
(This paper compar) 90 554 T
(es the vnode ar) 180.84 554 T
(chitectur) 253.34 554 T
(e found in SunOS with the internal \336le system) 295.53 554 T
(interfaces used in the Sprite distributed \336le system implementation. The emphasis of the) 90 540 T
(comparison is on generalized support for r) 90 526 T
(emote access to \336le system r) 295.45 526 T
(esour) 430.57 526 T
(ces, which) 456.77 526 T
(include peripheral devices and IPC communication channels as well as r) 90 512 T
(egular \336les. A) 440.66 512 T
-0.07 (str) 90 498 P
-0.07 (ong separation of the internal naming and I/O interfaces is exploited in Sprite to easily) 102.22 498 P
-0.38 (pr) 90 484 P
-0.38 (ovide r) 100.22 484 P
-0.38 (emote access to all of these r) 133.04 484 P
-0.38 (esour) 268.92 484 P
-0.38 (ces. In contrast, the vnode interface mixes nam-) 295.13 484 P
-0.01 (ing and I/O operations in a single interface, making generalized r) 90 470 P
-0.01 (emote access mor) 405.58 470 P
-0.01 (e awk-) 490.37 470 P
(war) 90 456 T
(d.) 108.22 456 T
-0.78 ([A version of this paper appear) 90 438 P
-0.78 (ed in the Pr) 236.56 438 P
-0.78 (oceedings of the USENIX File System W) 290.07 438 P
-0.78 (orkshop,) 478.14 438 P
(held in May) 90 424 T
(, 1992, pages 29-44. This version has been submitted to Computer Systems.]) 146.63 424 T
0 F
(1 Intr) 90 404 T
(oduction) 119.43 404 T
2 F
-0.72 (Kernel support for remote file systems is centered around internal file system interfaces that) 90 390 P
-0.6 (hide the details of accessing file systems whether they are local or remote. Perhaps the most) 90 376 P
1.73 (widely known of these interfaces is the SunOS vnode interface [Sandberg85][NFS85],) 90 362 P
0.11 (although Ultrix has a similar gnode interface[Rodrigeuz86], and ATT UNIX has a remote) 90 348 P
-0.44 (inode interface[Rifkin86]. These interfaces are all evolutions of the original UNIX file sys-) 90 334 P
1.1 (tem implementation in order to support remote file systems. The basic approach was to) 90 320 P
0.81 (abstract the file and directory access procedures so there could be different implementa-) 90 306 P
0.5 (tions corresponding to different sorts of file systems. Examples include the original ATT) 90 292 P
0.35 (UNIX local file system, the BSD fast file system format, and remote file systems such as) 90 278 P
1.07 (NFS, AFS, and RFS. As well as introducing a generic interface, the original inode data) 90 264 P
0.95 (structure was replaced with a more opaque object descriptor, which is called a) 90 250 P
1 F
0.95 (vnode) 480.08 250 P
2 F
0.95 ( in) 508.72 250 P
(SunOS, that represents objects implemented by different file systems.) 90 236 T
-0.02 (The main property of all these designs is that they are oriented mainly towards file access,) 90 218 P
2.05 (and this bias leads to a fundamental problem: naming and I/O operations are lumped) 90 204 P
0.31 (together into the same internal file system interface. For example, there are operations on) 90 190 P
0.33 (vnodes that locate their name in a directory, as well as operations that transfer data to the) 90 176 P
-0.28 (object represented by that name. By grouping these two different classes of operations into) 90 162 P
-0.59 (the same interface, the option of implementing pathnames by dedicated name servers is vir-) 90 148 P
1.07 (tually precluded. Instead, the server for an object must implement both naming and I/O) 90 134 P
0.43 (operations on its objects. For example, RFS provides remote device access, but you have) 90 120 P
-0.13 (to mount the /dev directory of the remote machine in order to access its devices. While the) 90 106 P
1.62 (grouping of naming and I/O is reasonable for files, it is less convenient for peripheral) 90 92 P
(devices and server processes, especially in an environment of diskless workstations.) 90 78 T
FMENDPAGE
%%EndPage: "1" 2
%%Page: "2" 2
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
2 12 Q
0 X
-0.24 (In contrast to the designs that evolved from a UNIX implementation, the Sprite file system) 90 712 P
0.06 (architecture provides generalized remote access to different kinds of file system resources) 90 698 P
0.19 (that include peripheral devices and IPC channels as well as files and directories. The goal) 90 684 P
0.44 (of the Sprite architecture is to use the distributed file system as a name server for objects) 90 670 P
-0.47 (other than files, and to do this is such a way that does not require a local file system on each) 90 656 P
-0.55 (workstation. The key to achieving this is to have two distinct internal file system interfaces,) 90 642 P
0.42 (one for pathname operations and one for I/O operations. This makes it possible to have a) 90 628 P
-0.33 (pathname implemented by Server A that corresponds to a peripheral device on Client X, or) 90 614 P
-0.28 (an IPC channel to a process on Client Y.) 90 600 P
2 10 Q
-0.23 (*) 282.65 604.8 P
2 12 Q
-0.28 ( The main point is that by properly separating the) 287.65 600 P
0.36 (naming and I/O interfaces it is quite feasible to reuse the file server\325s directory structures) 90 586 P
0.16 (as a global name space for any object accessed via the UNIX open-close-read-write inter-) 90 572 P
(face.) 90 558 T
1.15 (The remainder of the paper discusses the vnode and Sprite architectures in more detail.) 90 540 P
-0.36 (Notable features of the Sprite architecture include a prefix caching system that replaces the) 90 526 P
-0.36 (UNIX mount mechanism, support for process migration and crash recovery, and an object-) 90 512 P
(oriented design that has two base classes: pathnames and I/O objects.) 90 498 T
0 F
(2 The Vnode Ar) 90 478 T
(chitectur) 172.07 478 T
(e) 217.81 478 T
2 F
0.72 (The vnode architecture has two internal interfaces, the vnode and vfs interfaces. The vfs) 90 464 P
0.22 (interface is concerned with the mount mechanism, while the vnode interface is concerned) 90 450 P
(with access to objects within a file system.) 90 436 T
0.12 (The operations in the vnode interface are listed in Table 1. This is the interface as defined) 90 418 P
0.38 (for SunOS 4.1.1. The details of each operation are not crucial to the arguments presented) 90 404 P
0.26 (here, although some operations will be discussed in more detail below. The main thing to) 90 390 P
-0.3 (note that there is a rough classification of the operations into two sets. The first set of oper-) 90 376 P
3.91 (ations deal with pathnames: vn_access, vn_lookup, vn_create, vn_remove, vn_link,) 90 362 P
0.29 (vn_rename, vn_mkdir, vn_rmdir, vn_readdir, vn_symlink, and vn_readlink. The other set) 90 348 P
0.54 (of operations apply to the underlying object being named by a pathname \050e.g., a file or a) 90 334 P
3.95 (device\051. These operations include vn_open, vn_close, vn_rdwr, vn_ioctl, vn_select,) 90 320 P
0.16 (vn_getattr, vn_setattr, vn_fsync, vn_lockctl, vn_getpage, vn_putpage, and vn_map. There) 90 306 P
0.56 (is also a set of routines that deal more with the management of the vnode data structures) 90 292 P
(themselves: vn_inactive, vn_fid, vn_dump, vn_cmp, vn_realvp, vn_cntl.) 90 278 T
-0.62 (The vfs interface operations are given in Table 2. This interface is primarily concerned with) 90 260 P
-0.38 (the process of mounting a file system into the global directory hierarchy. The mount mech-) 90 246 P
-0.59 (anism assembles self-contained directory structures on different disks \050unfortunately called) 90 232 P
0.13 (\322file systems\323\051 into a single hierarchy. Each file system has a root directory. One file sys-) 90 218 P
0.38 (tem is the distinguished root of the overall hierarchy. The vfs_mount operation is used to) 90 204 P
-0.62 (mount the root directory of other file systems onto an existing directory. Ordinarily file sys-) 90 190 P
0.04 (tems are mounted onto top-level directories of the root file system \050e.g., /usr or /vol1\051, but) 90 176 P
0.19 (it is legal to mount file systems on any directory, even one in a mounted file system \050e.g.,) 90 162 P
(if disk 1 is mounted on /a, then disk 2 could be mounted on /a/b, or even /a/b/c\051.) 90 148 T
90 84 522 98.98 C
90 84 522 98.98 R
7 X
0 K
V
99 96.96 243 96.96 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
2 10 Q
0 X
0 K
(*. Generally) 108 77.33 T
(, the terms \322server\323 and \322client\323 refer to hosts and their operating system kernel.) 156.75 77.33 T
FMENDPAGE
%%EndPage: "2" 3
%%Page: "3" 3
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
2 12 Q
0 X
-0.45 (There are two problems with the vnode interface design that limit its ability to provide gen-) 90 282 P
0.54 (eralized remote access and to share the file system uniformly throughout a network. One) 90 268 P
0.46 (problem is that each host defines its own mount table. This stems from UNIX\325s past as a) 90 254 P
1.39 (single-host, timesharing system. The other problem is that the vnode interface includes) 90 240 P
-0.05 (both naming and I/O operations. This stems from the file-oriented bias of the vnode archi-) 90 226 P
2.22 (tecture. Both problems are related to the way the pathname resolution algorithm was) 90 212 P
(extended to a distributed environment.) 90 198 T
-0.03 (In a stand-alone system, pathname resolution involves processing a pathname one compo-) 90 180 P
0.67 (nent at a time by looking for that component in the current directory of the search. Each) 90 166 P
0.03 (directory is checked to see if it is a mount point for another file system. If it is, the current) 90 152 P
-0.38 (directory of the search shifts to the root of the mounted file system. Symbolic links are also) 90 138 P
-0.61 (expanded during this process. Thus, this basic algorithm is a component-by-component tra-) 90 124 P
1.49 (versal of a pathname, including expansion of symbolic links and indirections at mount) 90 110 P
(points used to glue together file systems on different disks.) 90 96 T
0.18 (In a distributed system there are a number of places to split the pathname resolution algo-) 90 78 P
2 10 Q
(Table 1. Vnode Operations <sys/vnode.h>) 90 713.33 T
(Operation) 90 699.33 T
(Description) 162 699.33 T
(vn_open) 90 689.33 T
(Initialize an object for future I/O operations.) 162 689.33 T
(vn_close) 90 679.33 T
(Tear down the state of the I/O stream to the object.) 162 679.33 T
(vn_rdwr) 90 669.33 T
(Read or write data to the object.) 162 669.33 T
(vn_ioctl) 90 659.33 T
(Perform an object-specific operation.) 162 659.33 T
(vn_select) 90 649.33 T
(Poll an object for I/O readiness.) 162 649.33 T
(vn_getattr) 90 639.33 T
(Get the attributes of the object.) 162 639.33 T
(vn_setattr) 90 629.33 T
(Change the attributes of the object.) 162 629.33 T
(vn_access) 90 619.33 T
(Check access permissions on the object.) 162 619.33 T
(vn_lookup) 90 609.33 T
(Look for a name in a directory.) 162 609.33 T
(vn_create) 90 599.33 T
(Create a directory entry that references an object.) 162 599.33 T
(vn_remove) 90 589.33 T
(Remove a directory entry for an object.) 162 589.33 T
(vn_link) 90 579.33 T
(Make another directory entry for an existing object.) 162 579.33 T
(vn_rename) 90 569.33 T
(Change the directory name for an object.) 162 569.33 T
(vn_mkdir) 90 559.33 T
(Create a directory.) 162 559.33 T
(vn_rmdir) 90 549.33 T
(Remove a directory.) 162 549.33 T
(vn_readdir) 90 539.33 T
(Read the contents of a directory.) 162 539.33 T
(vn_symlink) 90 529.33 T
(Create a symbolic link.) 162 529.33 T
(vn_readlink) 90 519.33 T
(Return the contents of a symbolic link.) 162 519.33 T
(vn_fsync) 90 509.33 T
(Force modified object data to disk.) 162 509.33 T
(vn_inactive) 90 499.33 T
(Mark a vnode descriptor as unused so it can be uncached.) 162 499.33 T
(vn_lockctl) 90 489.33 T
(Lock or unlock an object for user-level synchronization.) 162 489.33 T
(vn_fid) 90 479.33 T
(Return the handle, or file ID, associated with the object.) 162 479.33 T
(vn_getpage) 90 469.33 T
(Read a page from the object.) 162 469.33 T
(vn_putpage) 90 459.33 T
(Write a page to an object.) 162 459.33 T
(vn_map) 90 449.33 T
(Map an object into user memory.) 162 449.33 T
(vn_dump) 90 439.33 T
(Dump information about the object for debugging.) 162 439.33 T
(vn_cmp) 90 429.33 T
(Compare vnodes to see if they refer to the same object.) 162 429.33 T
(vn_realvp) 90 419.33 T
(Map to the real object descriptor.) 162 419.33 T
(vn_cntl) 90 409.33 T
(Query the capabilities of the object\325s supporting file system.) 162 409.33 T
(Table 2. Vfs Operations <sys/vfs.h>) 90 393.33 T
(Operation) 90 379.33 T
(Description) 162 379.33 T
(vfs_mount) 90 369.33 T
(Mount a file system onto a directory.) 162 369.33 T
(vfs_unmount) 90 359.33 T
(Unmount a file system.) 162 359.33 T
(vfs_root) 90 349.33 T
(Return the root vnode descriptor for a file system.) 162 349.33 T
(vfs_statfs) 90 339.33 T
(Get file system statistics.) 162 339.33 T
(vfs_sync) 90 329.33 T
(Flush modified file system buffers to safe storage.) 162 329.33 T
(vfs_vget) 90 319.33 T
(Map from a file ID to a vnode data structure.) 162 319.33 T
(vfs_mountroot) 90 309.33 T
(Special mount of the root file system.) 162 309.33 T
(vfs_swapvp) 90 299.33 T
(Return a vnode for a swap area.) 162 299.33 T
90 705.75 90 406.25 2 L
V
0.5 H
0 Z
N
522 705.75 522 406.25 2 L
V
N
89.75 706 522.25 706 2 L
V
N
89.75 696 522.25 696 2 L
V
N
89.75 406 522.25 406 2 L
V
N
90 385.75 90 296.25 2 L
V
N
522 385.75 522 296.25 2 L
V
N
89.75 386 522.25 386 2 L
V
N
89.75 376 522.25 376 2 L
V
N
89.75 296 522.25 296 2 L
V
N
FMENDPAGE
%%EndPage: "3" 4
%%Page: "4" 4
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
2 12 Q
0 X
0.86 (rithm between clients and servers. LOCUS put the split at the block access level so that) 90 712 P
1.76 (remote pathnames were resolved by reading remote directory blocks over the network) 90 698 P
2.14 ([Walker83]. The vnode architecture puts the split at the component access level. The) 90 684 P
0.24 (vn_lookup operation takes a directory handle and pathname component as arguments and) 90 670 P
-0.38 (returns the handle on the named file, if it is found. Similarly, the contents of symbolic links) 90 656 P
1.09 (are retrieved through the vn_readlink call. Sprite and RFS put the split at the pathname) 90 642 P
0.15 (access level so that component-by-component iteration happens on the server. The appeal) 90 628 P
-0.51 (of a lower-level split is that there is less effect on existing higher-level code. The advantage) 90 614 P
-0.27 (of a higher-level split is that more functionality can be moved to the server and the number) 90 600 P
0.28 (of client-server interactions can be reduced. Note that the vnode architecture tries to opti-) 90 586 P
-0.45 (mize by keeping a cache of recent name translations. However, an NFS server cannot guar-) 90 572 P
0.17 (antee the consistency of this cache, so each entry for remote files remains valid for only a) 90 558 P
0.36 (few seconds on the client. In general, a higher-level interface hides more details from the) 90 544 P
(client and gives more flexibility to the server.) 90 530 T
1.02 (The vnode design also requires that each client maintain its own mount table so that its) 90 512 P
-0.4 (lookup procedure can do the indirection at mount points. As a system gets larger, the job of) 90 498 P
0.22 (keeping all the clients\325 mount tables consistent becomes a problem. SunOS introduced an) 90 484 P
-0.61 (automounter mechanism to work around the problem of mount table consistency. The basic) 90 470 P
-0.51 (idea of an automounter is that a user process maintains a map from mount points to file sys-) 90 456 P
1.36 (tems. The automounter maps are kept in a distributed database service, NIS. The auto-) 90 442 P
0.2 (mounter process postpones the mounting of file systems by mounting itself onto top level) 90 428 P
-0.29 (mount points. When an access is made to a \322file system\323 mounted on the automounter pro-) 90 414 P
0.46 (cess, the automounter does the real mount and returns in such a way that the operation is) 90 400 P
-0.59 (retried. The point of delaying the kernel-level mounts is to increase availability. First, using) 90 386 P
-0.29 (a file system served by a crashed server can hang a process in many NFS implementations,) 90 372 P
-0.45 (so keeping as few NFS file systems mounted as possible reduces the chance of accidentally) 90 358 P
0.93 (hanging on a crashed server.) 90 344 P
2 10 Q
0.77 (*) 230.59 348.8 P
2 12 Q
0.93 ( Second, if a file system is replicated, then postponing the) 235.58 344 P
0.9 (mount increases the chance that the file system will be mounted from a working server.) 90 330 P
-0.11 (Thus, by retaining the mount mechanism, a new automounting mechanism has to be intro-) 90 316 P
(duced to keep mount tables consistent across clients.) 90 302 T
-0.15 (So far it seems like the problems in the vnode interface can be fixed up. However, perhaps) 90 284 P
-0.34 (the biggest problem is the mixing of naming and I/O operations in the vnode interface. The) 90 270 P
0.35 (mixture is easy to fall into from the viewpoint of a simple file system of regular files and) 90 256 P
-0.17 (directories. Directories are just special cases of files that name other files. Both objects are) 90 242 P
-0.43 (resident on the same disk, so the same host can be the server for both, and the same internal) 90 228 P
0.52 (data structure \050vnode\051 can be used for both. But consider a peripheral device. First, there) 90 214 P
-0.42 (are often many different names that map to the same device. With tape drives, for example,) 90 200 P
-0.36 (different names imply different tape densities and whether or not the tape is rewound when) 90 186 P
1.4 (it is closed. This creates the following problem. The result of pathname resolution is a) 90 172 P
-0.21 (vnode that corresponds to the special file that names the device. In order to perform I/O on) 90 158 P
90 132 522 146.98 C
90 132 522 146.98 R
7 X
0 K
V
99 144.96 243 144.96 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
2 10 Q
0 X
0 K
-0.41 (*. Computing the current working directory often results in accesses to other \336le systems, and many) 108 125.33 P
-0.03 (shells do this computation quite often. A recursive algorithm scans the contents of the parent direc-) 108 113.33 P
-0.22 (tory and makes a stat\050\051 call on every entry in order to \336gure out the name of the current directory) 108 101.33 P
-0.22 (. If) 490.3 101.33 P
-0.19 (there are any directories with mount points for multiple servers, then the crash of any of the servers) 108 89.33 P
(can hang the algorithm.) 108 77.33 T
FMENDPAGE
%%EndPage: "4" 5
%%Page: "5" 5
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
2 12 Q
0 X
0.44 (the device, another data structure, the) 90 712 P
1 F
0.44 (snode) 275.18 712 P
2 F
0.44 (that corresponds one-to-one with the device,) 306.61 712 P
-0.12 (is needed to serialize operations and maintain state about the device. Under the covers, the) 90 698 P
1.25 (special device file system implementation must maintain snodes and arrange for all the) 90 684 P
1.09 (vnodes associated with device names to have a pointer to the real object descriptor, the) 90 670 P
1.81 (snode. The vn_realvp operation in the vnode interface is used to map from vnodes to) 90 656 P
(snodes.) 90 642 T
-0.15 (Again, there seems to be a fix. But what about remote device access? The mixture of nam-) 90 624 P
-0.52 (ing and I/O operations implies that if you want to provide access to a peripheral device then) 90 610 P
0.28 (you also need to export its name. This distributes the responsibility for naming among all) 90 596 P
-0.51 (servers. In UNIX terms, it means that you have to mount the /dev directory of a remote host) 90 582 P
0.14 (into your file system in order to access its peripheral devices. Even a diskless workstation) 90 568 P
0.69 (needs its own file system that has a /dev directory with names for its peripheral devices.) 90 554 P
0.36 (This forces all clients to maintain a file system, which increases administrative overhead.) 90 540 P
(It can also increase cost and noise if it means adding local disks.) 90 526 T
-0.32 (Forcing each host to have its own file system may not seem like such a bad thing. After all,) 90 508 P
1.52 (a workstation might be able to function with its own file system if the file servers are) 90 494 P
1.03 (unavailable. However, in practice most workstations are configured so that they depend) 90 480 P
-0.12 (heavily on file servers, in spite of local storage. Only the bare minimum is on the local file) 90 466 P
-0.09 (systems, and most important files, including system programs, are on remote servers. This) 90 452 P
-0.07 (approach is taken to reduce administration effort. In such an environment, why is it neces-) 90 438 P
(sary to have a local file system at all?) 90 424 T
0.1 (What about extending the vnode architecture to a multicomputer where the hosts are even) 90 406 P
0.47 (more tightly bound than in workstation environments? Clearly it should not be necessary) 90 392 P
-0.26 (to maintain 1024 nearly identical private file systems just so each node can mount together) 90 378 P
-0.5 (file systems. On the other hand, if file system operations are forwarded to distinguished file) 90 364 P
0.78 (server nodes, then the lookup traffic in the root directory becomes a bottleneck. What is) 90 350 P
0.33 (needed is a system that efficiently partitions the name space among different servers, and) 90 336 P
-0.17 (then separates naming and I/O so that inter-node device access does not involve file server) 90 322 P
(nodes.) 90 308 T
-0.02 (In summary, the vnode and related architectures result in a world of many remote file sys-) 90 290 P
0.02 (tems that happen to be accessible. In contrast, the Sprite architecture provides a single file) 90 276 P
-0.61 (system view that transparently incorporates the resources available on all machines without) 90 262 P
(highlighting machine boundaries.) 90 248 T
0 F
(3 The Sprite Ar) 90 228 T
(chitectur) 170.07 228 T
(e) 215.81 228 T
2 F
0.58 (The Sprite file system architecture presented here is a second-generation design that was) 90 214 P
0.97 (implemented after initial experience with Sprite, which we began building in 1985. The) 90 200 P
-0.47 (current design has been operational since 1989. The goal of the architecture is to generalize) 90 186 P
0.03 (the remote access capabilities that support remote file access to also accommodate remote) 90 172 P
0.05 (device and remote IPC access. In Sprite, remote access also involves state management to) 90 158 P
1.64 (support process migration and failure recovery, not just I/O. The architecture starts by) 90 144 P
0.98 (cleanly separating naming and I/O operations so that file servers can easily act as name) 90 130 P
-0.09 (servers for devices and inter-process communication \050IPC\051 channels. It also eliminates the) 90 116 P
0.29 (need for private client file systems, and it makes a different cut between client and server) 90 102 P
0.51 (in pathname operations that is more efficient than the component-level split in the vnode) 90 88 P
FMENDPAGE
%%EndPage: "5" 6
%%Page: "6" 6
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
2 12 Q
0 X
(interface.) 90 712 T
0.16 (As with the vnode design, the Sprite design uses a generalized) 90 694 P
1 F
0.16 (object descriptor) 393.59 694 P
2 F
0.16 (, which is) 475.37 694 P
0.03 (a main-memory data structure maintained by the kernel, not a disk-resident representation) 90 680 P
-0.2 (of an object. A basic object descriptor has a type, uid, server ID \050a Sprite Host ID\051, a refer-) 90 666 P
0.62 (ence count, and a lock bit. Objects are specified internally by a tuple of <type, serverID,) 90 652 P
1.57 (uid>. This base data structure is subclassed) 90 638 P
2 10 Q
1.31 (*) 306.38 642.8 P
2 12 Q
1.57 ( for the implementations of various object) 311.38 638 P
0 (types. The object-oriented approach allows clean separation of different object implemen-) 90 624 P
-0.22 (tations, as well as sharing between similar objects like remote devices and remote pipes. A) 90 610 P
(diagram of the file system architecture is given in Figure 1.) 90 596 T
0.44 (The pathname interface illustrates the three basic cases handled by the Sprite kernel. The) 90 366 P
-0.64 (server for a pathname may be the local kernel, in which case the file system implementation) 90 352 P
1.71 (is accessed by an ordinary procedure call within the Sprite kernel. The server may be) 90 338 P
0.06 (remote, in which case a kernel-to-kernel RPC protocol is used to pass the pathname to the) 90 324 P
-0.42 (server [Welch 86a]. Finally, the server may be a user-level process, in which case an upcall) 90 310 P
-0.1 (mechanism, which was described in [Welch 88], is used to pass the operation up to a user-) 90 296 P
0.4 (level) 90 282 P
1 F
0.4 (pseudo-device) 116.72 282 P
2 F
0.4 ( or) 185.32 282 P
1 F
0.4 (pseudo-file-system) 202.11 282 P
2 F
0.4 ( server process. Thus there are three orthogonal) 291.38 282 P
-0.05 (cases that are supported by a Sprite kernel, a local, kernel-resident module, a remote mod-) 90 268 P
(ule, and a user-level module.) 90 254 T
0 F
(3.1 Separating Naming and I/O) 90 234 T
2 F
-0.61 (Consider the UNIX open system call that maps from a pathname to an I/O stream. In Sprite,) 90 220 P
-0.08 (this is broken into two operations, NameOpen and IoOopen, that involve both of the inter-) 90 206 P
-0.47 (nal file system interfaces. The NameOpen procedure returns attributes of the named object.) 90 192 P
0.28 (The IoOpen procedure uses these attributes to create an open I/O stream. The NameOpen) 90 178 P
1.67 (and IoOpen procedures may be implemented by different servers, and this is achieved) 90 164 P
(cleanly by branching through the object-oriented naming and I/O interfaces.) 90 150 T
0.4 (The clean separation of naming and I/O means that objects like devices can rely on a file) 90 132 P
-0.27 (server to implement the naming interface on their behalf. In Sprite, special files are used to) 90 118 P
90 96 522 110.98 C
90 96 522 110.98 R
7 X
0 K
V
99 108.96 243 108.96 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
2 10 Q
0 X
0 K
(*. The various kinds of object descriptors would be the result of subclassing if Sprite were written) 108 89.33 T
(in C++. However) 108 77.33 T
(, all the object-oriented features described here were hand crafted in C.) 177.44 77.33 T
90 72 522 720 C
90.65 380 521.35 592 C
90.65 380 521.35 592 R
7 X
0 K
V
99.89 385 516.89 420 R
V
2 10 Q
0 X
0.65 (Figure 1. An overview of the Sprite file system architecture. The two primary interfaces involve path-) 99.89 413.33 P
0.5 (names and I/O streams. The Upcall module forwards operations to user-level processes. RPC forwards) 99.89 401.33 P
(operations across the network to other Sprite kernels.) 99.89 389.33 T
122.39 549 275.39 576 R
7 X
V
1 H
2 Z
0 X
N
122.39 450 176.39 522 R
7 X
V
0 X
N
257.39 432 293.39 468 R
7 X
V
0 X
N
212.39 432 248.39 468 R
7 X
V
0 X
N
(Pathnames \050pre\336xes\051) 154.09 560.18 T
(Local) 131.39 486 T
(Disk) 131.39 476 T
(RPC) 265.39 441 T
(Upcall) 215.75 442.18 T
284.39 549 500.39 576 R
7 X
V
0 X
N
(I/O Streams \050of) 318.37 559 T
(fsets, blocking, errors\051) 380.36 559 T
456.39 476 492.39 512 R
7 X
V
0 X
N
410.39 476 446.39 512 R
7 X
V
0 X
N
360.39 430 396.39 484 R
7 X
V
0 X
N
(Devices) 459.39 487 T
(Pipes) 417.39 489 T
(Files) 369.39 450.17 T
315.39 448 351.39 484 R
7 X
V
0 X
N
(Remote) 320.3 468.17 T
(Files) 322.95 459.18 T
315.39 493 396.39 511 R
7 X
V
0 X
N
(Block Cache) 332.39 499 T
160.1 524.62 148.39 522 156.94 530.43 158.52 527.52 4 Y
V
158.52 527.52 198.39 549 2 L
N
229.46 479.97 230.39 468 223.26 477.66 226.36 478.81 4 Y
V
226.37 478.81 200.39 549 2 L
N
269.98 478.72 275.38 468.01 265.12 474.23 267.55 476.48 4 Y
V
267.56 476.47 200.39 549 2 L
N
284.57 475.73 275.38 468.01 279.08 479.42 281.83 477.57 4 Y
V
281.83 477.57 329.39 549 2 L
N
241.4 472.78 230.39 468 237.2 477.89 239.3 475.33 4 Y
V
239.3 475.33 329.39 549 2 L
N
332.03 523.43 328.39 512 325.42 523.63 328.73 523.53 4 Y
V
328.73 523.53 329.39 546 2 L
N
367.48 522.81 374.39 513 363.33 517.66 365.4 520.24 4 Y
V
365.41 520.23 329.39 549 2 L
N
418.68 520.07 428.38 513 416.41 513.86 417.54 516.96 4 Y
V
417.56 516.96 329.39 549 2 L
N
464.96 518.95 475.38 513 463.39 512.53 464.17 515.74 4 Y
V
464.19 515.74 329.39 548 2 L
N
305.75 451.15 294.39 455 306.07 457.76 305.91 454.45 4 Y
V
305.91 454.45 315.39 454 2 L
N
(\050namei\051) 131.39 466 T
373.65 493 373.65 484 2 L
0.5 H
N
329.65 493 329.65 484 2 L
N
90 72 522 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "6" 7
%%Page: "7" 7
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
2 12 Q
0 X
-0.57 (represent devices and pseudo-devices in the name space. Pseudo-devices can be considered) 90 712 P
0.49 (a kind of IPC channel [welch 88]. Furthermore, a Sprite file server can have special files) 90 698 P
1.05 (that represent devices and pseudo-devices on any machine in the network. Contrast this) 90 684 P
-0.03 (with NFS, which doesn\325t support remote device access, or even RFS, which only supports) 90 670 P
0.29 (accesses to devices on the file server. Those systems are limited by the vnode \050or equiva-) 90 656 P
(lent\051 interface that lumps naming and I/O together.) 90 642 T
0.22 (The vnode architecture has a \322cloning\323 mechanism that is used to achieve a similar effect) 90 624 P
2.88 (of having distinct NameOpen and IoOpen procedures. The vnode returned from the) 90 610 P
-0.22 (vn_open call can be cloned to get better handle on the underlying object. For example, this) 90 596 P
1.04 (is when the snode that corresponds to a device is located and linked back to the vnode.) 90 582 P
-0.45 (However, this is a client-side operation that is invoked after the server does the lookup, and) 90 568 P
(it is oriented towards the special case of special device files.) 90 554 T
(The Sprite naming and I/O interfaces are described in Tables 3 and 4.) 90 536 T
-0.38 (Most of the operations in the two interfaces are self explanatory. The Page and Block oper-) 90 176 P
-0.47 (ations are for use by the VM system when managing swapping files. The main reason these) 90 162 P
-0.07 (routines are distinct from the ordinary Read and Write routines is that the caching strategy) 90 148 P
0.24 (is different for swap files. Clients only cache pages for read-only segments \050code and ini-) 90 134 P
-0.67 (tialized data\051, while all swap pages are cached on the server. The BlockCopy routine is used) 90 120 P
(to duplicate swap files on the server during process creation.) 90 106 T
0.57 (Table 5 lists the different types of object descriptors. A comparison with Figure 1 shows) 90 88 P
2 10 Q
(Table 3. Sprite Naming Interface <fs/fsNameOps.h>) 90 519.33 T
(Operation) 90 505.33 T
(Description) 180 505.33 T
(NameOpen) 90 495.33 T
(Map from a pathname to attributes of an object, and prepare for I/O.) 180 495.33 T
(GetAttributes) 90 485.33 T
(Map from a pathname to attributes of an object.) 180 485.33 T
(SetAttributes) 90 475.33 T
(Update the attributes of an object.) 180 475.33 T
(MakeDevice) 90 465.33 T
(Create a special file that represents a device.) 180 465.33 T
(MakeDirectory) 90 455.33 T
(Create a directory.) 180 455.33 T
(Remove) 90 445.33 T
(Remove a named object.) 180 445.33 T
(RemoveDirectory) 90 435.33 T
(Remove an empty directory.) 180 435.33 T
(HardLink) 90 425.33 T
(Create another name for an existing object.) 180 425.33 T
(Rename) 90 415.33 T
(Change the pathname of an existing object.) 180 415.33 T
(SymLink) 90 405.33 T
(Create a symbolic link.) 180 405.33 T
(Table 4. Sprite I/O Interface <fsio/fsio.h>) 90 389.33 T
(Operation) 90 375.33 T
(Description) 180 375.33 T
(IoOpen) 90 365.33 T
(Complete the preparation for I/O to an object.) 180 365.33 T
(Read) 90 355.33 T
(Read data from the object.) 180 355.33 T
(Write) 90 345.33 T
(Write data to the object.) 180 345.33 T
(PageRead) 90 335.33 T
(Read a page from a swap file.) 180 335.33 T
(PageWrite) 90 325.33 T
(Write a page to a swap file.) 180 325.33 T
(BlockCopy) 90 315.33 T
(Copy a block of a swap file. Used during process creation.) 180 315.33 T
(IoControl) 90 305.33 T
(Perform an object-specific operation.) 180 305.33 T
(Select) 90 295.33 T
(Poll an object for readability, writability, or an exceptional condition.) 180 295.33 T
(IoGetAttributes) 90 285.33 T
(Fetch attributes that are maintained at the object.) 216 285.33 T
(IoSetAttributes) 90 275.33 T
(Change attributes that are maintained at the object.) 180 275.33 T
(ClientVerify) 90 265.33 T
(Verify a remote client\325s request and map to local object descriptor.) 180 265.33 T
(Release) 90 255.33 T
(Release references after an I/O stream migrates away.) 180 255.33 T
(MigEnd) 90 245.33 T
(Acquire new references as an I/O stream migrates to a host.) 180 245.33 T
(SrvMigrate) 90 235.33 T
(Update state on the I/O server to reflect an I/O stream migration.) 180 235.33 T
(Reopen) 90 225.33 T
(Recover state after a server crash.) 180 225.33 T
(Scavenge) 90 215.33 T
(Garbage collect object descriptors.) 180 215.33 T
(ClientKill) 90 205.33 T
(Clean up state associated with a client.) 180 205.33 T
(Close) 90 195.33 T
(Clean up state associated with I/O to an object.) 180 195.33 T
90 511.75 90 402.25 2 L
V
0.5 H
0 Z
N
522 511.75 522 402.25 2 L
V
N
89.75 512 522.25 512 2 L
V
N
89.75 502 522.25 502 2 L
V
N
89.75 402 522.25 402 2 L
V
N
90 381.75 90 192.25 2 L
V
N
522 381.75 522 192.25 2 L
V
N
89.75 382 522.25 382 2 L
V
N
89.75 372 522.25 372 2 L
V
N
89.75 192 522.25 192 2 L
V
N
FMENDPAGE
%%EndPage: "7" 8
%%Page: "8" 8
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
2 12 Q
0 X
1.71 (there are more kinds of descriptors than there are modules in the block diagram. This) 90 712 P
-0.69 (reflects sharing among the implementations of the various remote cases. Most of the remote) 90 698 P
0.58 (cases share their implementations of the Read, Write, Ioctl, and Select operations, which) 90 684 P
0.18 (are just RPC stubs. The RPC stubs rely on the host ID in the object descriptor ID in order) 90 670 P
0.21 (to direct their RPC requests. The state-related operations \050e.g., IoOpen, Release, MigEnd,) 90 656 P
0.51 (Close\051 differ among the various cases, although often not greatly. The remote file imple-) 90 642 P
-0.56 (mentation is the most specialized remote case because it is optimized to use the local cache.) 90 628 P
(In the case of a cache miss it uses the same RPC routines as the other cases.) 90 614 T
-0.44 (There are corresponding local and remote descriptors for various kinds of objects like files,) 90 596 P
-0.11 (pipes, devices, and pseudo-devices. This reflects the need to maintain different state infor-) 90 582 P
-0.62 (mation on clients and servers. There is, however, a well defined mapping between a client\325s) 90 568 P
0.21 (object descriptor ID and the corresponding descriptor on the server; the IDs differ only in) 90 554 P
-0.63 (the type field. The RPC stubs on the server use the ClientVerify routine to map the ID, fetch) 90 540 P
0.62 (the server\325s descriptor, and verify that the client is known to the server. The operation is) 90 526 P
1.69 (then passed through the I/O interface so that all object implementations are accessible) 90 512 P
1.15 (remotely. The importance of this approach is that it extends the general features imple-) 90 498 P
0.36 (mented in upper levels of the kernel to local, remote, and user-provided objects. Notable,) 90 484 P
1.31 (high-level features include the name space, error recovery, and blocking I/O. Thus, the) 90 470 P
-0.38 (focus of the file system architecture has relatively little to do with actual disk management.) 90 456 P
0.16 (The focus is on extending the high-level abstractions of pathnames and I/O streams to the) 90 442 P
(network environment.) 90 428 T
0 F
(3.2 Integrating User) 90 218 T
(-Level Servers) 192.48 218 T
2 F
1.53 (Pseudo-devices are user-level processes that implement the I/O interface by way of an) 90 204 P
-0.61 (upcall mechanism [welch88]. They are used to implement the X server, terminal emulators,) 90 190 P
-0.2 (and a TCP/IP server. Unlike UNIX ptys that use pairs of special device files, there is a sin-) 90 176 P
0.33 (gle pathname that represents a pseudo-device in Sprite. This pathname is implemented as) 90 162 P
-0.13 (a kind of special file in a directory on a Sprite file server. In this case, the user-level server) 90 148 P
-0.56 (only implements the I/O interface and the file server implements the pathname interface for) 90 134 P
0.34 (the pseudo-device. The user-level server process opens the file and can listen for connec-) 90 120 P
-0.31 (tions by client processes. When a client opens the pseudo-device file, a new upcall channel) 90 106 P
-0.33 (is created for communication, and the server process gets a new open file descriptor to rep-) 90 92 P
(resent it.) 90 78 T
2 10 Q
(Table 5. Sprite Object Descriptor Types <fsio/fsio.h>) 90 411.33 T
(Type) 90 397.33 T
(Description) 183.94 397.33 T
(LCL_FILE) 90 387.33 T
(A file, directory, or symbolic link stored locally.) 183.94 387.33 T
(RMT_FILE) 90 377.33 T
(For a remote file, directory, or link.) 183.94 377.33 T
(LCL_DEVICE) 90 367.33 T
(A device on this host.) 183.94 367.33 T
(RMT_DEVICE) 90 357.33 T
(A device on a remote host.) 183.94 357.33 T
(LCL_PIPE) 90 347.33 T
(An anonymous pipe buffered on this host.) 183.94 347.33 T
(RMT_PIPE) 90 337.33 T
(An anonymous pipe buffered on a remote host.) 183.94 337.33 T
(PDEV_CONTROL) 90 327.33 T
(Used by a pseudo-device server to listen for connection requests.) 183.94 327.33 T
(SERVER) 90 317.33 T
(The upcall channel to a pseudo-device server.) 183.94 317.33 T
(LCL_PSEUDO) 90 307.33 T
(Client\325s handle on a local upcall channel.) 183.94 307.33 T
(RMT_PSEUDO) 90 297.33 T
(Client\325s handle on a remote upcall channel.) 183.94 297.33 T
(PFS_CONTROL) 90 287.33 T
(Used by a pseudo-file-system server to listen for connections.) 183.94 287.33 T
(PFS_NAMING) 90 277.33 T
(Upcall channel used for naming operations in a pseudo-file-system.) 183.94 277.33 T
(LCL_PFS) 90 267.33 T
(Client\325s handle on local upcall channel to pfs server.) 183.94 267.33 T
(RMT_PFS) 90 257.33 T
(Client\325s handle on remote upcall channel to pfs server.) 183.94 257.33 T
(RMT_CONTROL) 90 247.33 T
(Used during get/set I/O attrs if pseudo-device server is remote.) 183.94 247.33 T
(PASSING) 90 237.33 T
(Used to pass existing I/O streams from a pdev server to a client.) 183.94 237.33 T
90 403.75 90 234.25 2 L
V
0.5 H
0 Z
N
522.34 403.75 522.34 234.25 2 L
V
N
89.75 404 522.59 404 2 L
V
N
89.75 394 522.59 394 2 L
V
N
89.75 234 522.59 234 2 L
V
N
FMENDPAGE
%%EndPage: "8" 9
%%Page: "9" 9
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
2 12 Q
0 X
0.4 (A pseudo-file-system is a whole subtree of the file system that is implemented by a user-) 90 712 P
-0.06 (level server process. This is used to implement a gateway to NFS file systems. In this case) 90 698 P
0.29 (a prefix is registered in the local prefix table, and pathname operations that match on that) 90 684 P
1.57 (prefix are forwarded up to the user-level server process over an upcall channel. Prefix) 90 670 P
1.16 (tables are described in more detail in Section 4. An open operation on a pathname in a) 90 656 P
-0.13 (pseudo-file-system results in a new upcall channel for I/O operations on the named object.) 90 642 P
1.55 (The upcall implementation has a number of object descriptor types, although there are) 90 624 P
-0.38 (really only 4 different kinds of object descriptors used. Extra types were introduced to han-) 90 610 P
1.19 (dle special cases, sort of a poor man\325s subclassing mechanism. For each pseudo-device) 90 596 P
0.03 (there is one control descriptor that keeps state about where the user-level server process is) 90 582 P
-0.12 (executing. The control descriptor is also used by the server to listen for client connections.) 90 568 P
-0.67 (2 descriptors are used to represent the client and server sides of an upcall channel. The pass-) 90 554 P
-0.49 (ing descriptor is used to return an open I/O stream in response to a pseudo-file-system open) 90 540 P
0.49 (request, which is an alternative to creating an upcall channel. This could be used to open) 90 526 P
0.69 (files or devices via a pseudo-file-system, although this is still not fully implemented and) 90 512 P
(debugged.) 90 498 T
0.59 (The Plan-9 system also integrates user-level server processes into its name space. It uses) 90 480 P
0.93 (the mount system call to attach a full-duplex pipe to a name. All client operations, both) 90 466 P
0.4 (naming and I/O, from all clients, are passed through this channel along with a unique tag) 90 452 P
1.28 (so the server can manage requests. The main difference from Sprite pseudo-device and) 90 438 P
0.1 (pseudo-file-systems is that the Sprite kernel maintains separate channels corresponding to) 90 424 P
0.38 (each client open system call, and in the case of pseudo-devices it implements the naming) 90 410 P
-0.23 (interface on behalf of the server. There are also optimizations in the Sprite implementation) 90 396 P
(to allow for asynchronous reads and writes between the client and server.) 90 382 T
0 F
(3.3 Handling Special Files) 90 362 T
2 F
0.51 (A final touch is required to implement support for special files cleanly on the file server.) 90 348 P
-0.42 (After a file server finds a file, it needs to take type-specific action to complete the servicing) 90 334 P
0.44 (of a NameOpen request. This special action is what distinguishes a NameOpen operation) 90 320 P
1.33 (from a GetAttributes operation. Another, single-procedure interface called the SrvOpen) 90 306 P
-0.06 (interface is used to abstract these type-specific actions. The implementation of SrvOpen is) 90 292 P
0.89 (selected based on a type field in the disk-resident descriptor for a file \050the disk inode in) 90 278 P
0.7 (UNIX terms\051. Currently there are three different implementations of the SrvOpen proce-) 90 264 P
(dure.) 90 250 T
-0.34 (The first implementation is used for regular files, directories, and symbolic links. This pro-) 90 232 P
-0.62 (cedure invokes the Sprite cache consistency algorithm [Nelson 88] and sets up enough state) 90 218 P
-0.52 (about the remote client so that the IoOpen procedure does not need to contact the file server) 90 204 P
(a second time. This is an important optimization for the common case of file access.) 90 190 T
1.17 (A second implementation is used for device files. In this case the procedure just has to) 90 172 P
2.03 (extract the relevant attributes from the disk-resident descriptor that are needed by the) 90 158 P
-0.62 (remote client. Sprite device files have a ServerID attribute in addition to the standard UNIX) 90 144 P
0.94 (major and minor device numbers. The ServerID identifies what host controls the device) 90 130 P
-0.14 (\050i.e., the I/O server\051. A simple trick is played here to allow sharing of the /dev directory. A) 90 116 P
-0.19 (special value of the ServerID is mapped to the host ID of the client making the NameOpen) 90 102 P
0.06 (RPC, thus mapping the special device file to the instance of the device on that client. This) 90 88 P
FMENDPAGE
%%EndPage: "9" 10
%%Page: "10" 10
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
2 12 Q
0 X
0.13 (trick makes it easy to have a single /dev directory that is shared among all the hosts in the) 90 712 P
1.13 (Sprite network. Most entries in /dev are these generic device files that map to the local) 90 698 P
0.1 (instance. Some entries have specific ServerID attributes so they map to devices \050e.g., tape) 90 684 P
1.12 (drives\051 on particular hosts. Finally, note that this arrangement results in a full many-to-) 90 670 P
-0.69 (many mapping from pathnames to objects that really requires a clean separation of the nam-) 90 656 P
(ing and I/O interfaces.) 90 642 T
-0.39 (The third implementation of SrvOpen is used for pseudo-devices. The file server maintains) 90 624 P
-0.33 (state about which host the pseudo-device server process is executing on, and it updates and) 90 610 P
-0.48 (verifies this state when a pseudo-device is opened. Server processes supply an extra flag on) 90 596 P
1.22 (the open call to distinguish themselves, and after that one or more clients can open the) 90 582 P
(pseudo-device and get a connection to the server.) 90 568 T
0 F
(4 The Sprite Pr) 90 548 T
(e\336x T) 168.74 548 T
(able Mechanism) 196.62 548 T
2 F
-0.39 (Sprite prefix tables were originally described in [Welch 86b], but the following description) 90 534 P
(is included for completeness.) 90 520 T
0.33 (Sprite uses a prefix table mechanism to implement a uniformly shared, hierarchical name) 90 502 P
-0.16 (space. Each Sprite kernel keeps a cache of pathname prefixes. The prefixes define the way) 90 488 P
-0.13 (server domains are coalesced into a single hierarchy, and their use completely replaces the) 90 474 P
1.54 (UNIX mount mechanism. The Sprite naming protocol ensures that servers export their) 90 460 P
1.23 (domains consistently so that all hosts, and therefore all processes, see exactly the same) 90 446 P
0.14 (name space. Users, administrators, and developers enjoy the simplicity of a single, shared) 90 432 P
-0.4 (name space. The fully shared file system supports cross-compilation and easy maintenance) 90 418 P
(for all architectures from any workstation.) 90 404 T
0.02 (In contrast, the V-system [Cheriton87] and Mach 3.0 use a prefix cache that is maintained) 90 386 P
0.2 (on a per-process basis by library routines. While this is advertised as a feature that allows) 90 372 P
-0.04 (custom name spaces, I believe this is a case where generality is not what you want. I think) 90 358 P
1.5 (that the real reason V and Mach provide per-process prefix caches is because they are) 90 344 P
-0.34 (implemented in the run-time library instead of the kernel. Plan-9 [Pike90] relies heavily on) 90 330 P
0.33 (per-process name spaces created by mounting various servers into the name space. Sprite) 90 316 P
-0.67 (also mounts services into the name space, even user-level processes as described below, but) 90 302 P
(again, the name space is global and shared by all processes.) 90 288 T
0.04 (The basic idea of prefix caching is simple. On a client, the longest matching prefix selects) 90 270 P
0.29 (the) 90 256 P
1 F
0.29 (domain) 107.94 256 P
2 F
0.29 ( for the pathname. An object ID is registered with the prefix that identifies the) 143.92 256 P
0.2 (server for the domain, the domain\325s type \050e.g., local, remote, or user-level\051, and a uid that) 90 242 P
-0.37 (identifies the domain to the server. The server is sent the part of the pathname after the pre-) 90 228 P
0.4 (fix, along with the object ID. Relative pathnames bypass the prefix match and are sent to) 90 214 P
0.2 (the server of the current working directory, along with the object ID for the current direc-) 90 200 P
0.96 (tory. Note that the interface to the server is the same in both cases. In summary, clients) 90 186 P
2.55 (match prefixes to choose servers. Servers process pathnames relative to one of their) 90 172 P
0.49 (domains. When servers completely resolve a pathname, they perform the requested path-) 90 158 P
(name operation \050NameOpen, Remove, Rename, MakeDirectory, etc.\051.) 90 144 T
0 F
(4.1 Pathnames that Involve Multiple Servers) 90 124 T
2 F
-0.05 (The main complication with prefix matching is that a pathname can wander through many) 90 110 P
0.53 (different server domains, so the initial prefix match may not lead to the right server. The) 90 96 P
-0.19 (solution to this problem is to return control to the client when a pathname leaves a server\325s) 90 82 P
FMENDPAGE
%%EndPage: "10" 11
%%Page: "11" 11
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
2 12 Q
0 X
0.87 (domain. This gives the client an opportunity to cache information about the next server,) 90 712 P
(including a prefix that may optimize future pathname operations.) 90 698 T
-0.34 (A pathname exits a domain when it encounters a symbolic link to an absolute pathname, or) 90 680 P
0.73 (if it specifies \322..\323 in the domain\325s root directory. In these cases, the server returns a new) 90 666 P
0.03 (pathname to the client. The returned pathname is either the new absolute pathname result-) 90 652 P
-0.18 (ing from the symbolic link expansion, or a pathname that begins with \322..\323. The client com-) 90 638 P
-0.06 (bines the latter form with the prefix used to select the server in order to get a new absolute) 90 624 P
-0.02 (pathname. The \322..\323 and the last component of the prefix are removed so the pathname will) 90 610 P
(match on a different prefix.) 90 596 T
0.8 (Mount points are handled by placing a special symbolic link at the mount point called a) 90 383 P
1 F
-0.69 (remote link) 90 369 P
2 F
-0.69 (. Mount points can occur in any directory, so it is possible to nest server domains) 143.6 369 P
0.06 (arbitrarily. The contents of a remote link is the prefix, or absolute pathname, of the mount) 90 355 P
1.44 (point. The link has a different file type than ordinary symbolic links so that the server) 90 341 P
-0 (knows when it hits a mount point. The server expands the remote link and returns the new) 90 327 P
0.09 (pathname to the client. In addition, the server indicates of how much of the returned path-) 90 313 P
-0.09 (name is the prefix of the mount point so that the client can add the prefix to its cache. This) 90 299 P
-0.36 (is illustrated in Figure 2b. Note that there is nothing in the remote link but its own name, so) 90 285 P
0.31 (some other mechanism is used to locate the server for that domain. Currently, Sprite uses) 90 271 P
0.02 (broadcast to locate the server. After locating the server and obtaining the object ID for the) 90 257 P
-0.74 (root directory of the domain, the client reiterates the lookup procedure. On the next iteration) 90 243 P
-0.09 (the returned pathname will match on the new prefix, and the lookup will be directed to the) 90 229 P
(next server.) 90 215 T
0.73 (The iteration over the prefix table is contained within two routines on the client, one for) 90 197 P
-0.27 (single pathname operations and one for two pathname operations. Higher-level procedures) 90 183 P
-0.41 (such as Fs_Open or Fs_Rename \050these implement the open and rename system calls\051 pack-) 90 169 P
-0.05 (age up their non-pathname parameters into a structure and call the appropriate prefix table) 90 155 P
1.21 (routine. The arguments to the call are the pathname\050s\051, an operation identifier \050e.g., for) 90 141 P
-0.43 (NameOpen or Rename\051, the structure that collects the remaining miscellaneous arguments,) 90 127 P
-0.37 (and a structure for the return values of the operation. The prefix table routines do the prefix) 90 113 P
-0.18 (match, branch through an operation table depending on the server\325s type and the requested) 90 99 P
-0.28 (operation, and handle the case where pathnames are returned from the server by reiterating) 90 85 P
90 72 522 720 C
90 397 522 592 C
99 394 279 425 R
7 X
0 K
V
2 10 Q
0 X
(Figure 2a: Prefix match on the client selects) 99 418.33 T
(longest prefix, \322/a/b\323.) 99 406.33 T
2 12 Q
(\322/a/b/c/e\323) 99 565 T
125.47 540.99 126 529 119.2 538.89 122.34 539.94 4 Y
V
117 556 122.34 539.94 2 L
1 H
2 Z
N
108 475 207 529 R
N
(\322/\323) 108 513.6 T
(\322/a\323) 108 501.6 T
(\322/a/b\323) 108 489.6 T
(\322/b\323) 108 477.6 T
(SrvX) 144 513.6 T
(SrvY) 144 501.6 T
(SrvW) 144 489.6 T
(SrvZ) 144 477.6 T
(2) 189 513.6 T
(42) 189 501.6 T
(37) 189 489.6 T
(19) 189 477.6 T
159.76 468.79 162 457 153.85 465.81 156.8 467.3 4 Y
V
153 475 156.8 467.3 2 L
N
(SrvW) 144 439 T
(, 37, \322c/e\323) 170.88 439 T
(Pre\336x match) 335.04 556.82 T
(Dispatch to server) 333 535 T
(Operation complete.) 333.07 445.6 T
311.94 553.84 323.99 556 314.92 547.78 313.43 550.81 4 Y
V
126 180 18 27 324 529 A
293 394 488 426 R
7 X
V
2 10 Q
0 X
-0.54 (Figure 2b. Lookup iteration on the client faults in) 293 419.33 P
(new prefix, \322/a/b/c\323.) 293 407.33 T
488.84 536.43 499.99 532 488.18 529.84 488.51 533.14 4 Y
V
429 539 488.52 533.14 2 L
N
434.96 501.32 422.98 502.01 433.51 507.77 434.23 504.55 4 Y
V
495 518 434.25 504.54 2 L
N
432.25 468.15 420.99 464.01 428.34 473.49 430.29 470.82 4 Y
V
494 517 430.3 470.82 2 L
N
2 12 Q
(Returned pathname) 334 507 T
(\322) 368 493 T
0 F
(/a/b/c) 373.33 493 T
2 F
(/e\323) 401.32 493 T
(Add pre\336x \322/a/b/c\323) 335 476 T
180 270 18 54 324 529 A
90 72 522 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "11" 12
%%Page: "12" 12
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
2 12 Q
0 X
0.05 (the procedure. In the call to the server, the pathname arguments are replaced by the object) 90 712 P
(ID and relative pathname that result from the prefix match.) 90 698 T
1.05 (Bootstrapping is achieved by broadcasting for the server of \322/\323. Initially all lookups are) 90 680 P
-0.15 (directed to the root server. Remote links will cause prefixes to be returned to the client. As) 90 666 P
0.57 (a client\325s prefix cache fills up, the prefix matches usually direct operations to the correct) 90 652 P
(server, bypassing the servers for higher levels of the directory hierarchy.) 90 638 T
0.25 (Measurements of the Berkeley Sprite network revealed that about 17% of pathnames suf-) 90 620 P
0.57 (fered redirections back from a server, but less than 1% of the pathnames were redirected) 90 606 P
2.78 (because they hit a remote link [Welch90]. Instead, ordinary symbolic links between) 90 592 P
1.57 (domains caused the bulk of the redirections. It should be possible to extend the prefix) 90 578 P
0.56 (caches to cache the results of absolute symbolic link expansion so that these redirections) 90 564 P
(are eliminated, but this has not been implemented.) 90 550 T
0 F
(4.2 Operations on T) 90 530 T
(wo Pathnames) 191.07 530 T
2 F
-0.11 (The Rename and HardLink operations involve two pathnames, and they are constrained to) 90 516 P
0.11 (operate on pathnames in the same domain. The problem is that the two pathnames may or) 90 502 P
-0.32 (may not start out in the same domain, and they may or may not end up in the same domain.) 90 488 P
-0.47 (The required iteration over the prefix matches is described below. Note that in the best case) 90 474 P
-0.19 (only a single server operation is required. By making Rename, and HardLink, into a single) 90 460 P
-0.28 (server operation, the server can easily implement these atomically without having to main-) 90 446 P
(tain state between multiple client operations.) 90 432 T
-0.03 (The client matches both pathnames against the prefix table and obtains object IDs and rel-) 90 414 P
-0.37 (ative pathnames for both. It sends these to the server identified by the object ID for the first) 90 400 P
1 (pathname. The server traverses the first pathname. If the pathname leaves its domain, it) 90 386 P
0.49 (returns a new pathname to the client as described above. In this case, the client reiterates) 90 372 P
-0.24 (the prefix matches and retries the operation. If the first pathname terminates in the server\325s) 90 358 P
-0.17 (domain, then it proceeds to traverse the second pathname. If the second pathname also ter-) 90 344 P
-0.44 (mintates in the same domain, the server performs the requested operation. Otherwise, if the) 90 330 P
1.55 (second pathname exits the domain, or does not even start in it, then the server returns) 90 316 P
0.77 (EXDEV to indicate a potential conflict. At this point the client has to verify the conflict) 90 302 P
0.39 (because it is still possible for the second pathname to end up back in the same domain as) 90 288 P
0.31 (the first one. To verify the conflict, the client does a GetAttributes of the parent directory) 90 274 P
-0.26 (of the second pathanme. The parent is checked to avoid file-not-found errors. If the GetAt-) 90 260 P
0.51 (tributes results in a returned pathanme, then the Rename or Hardlink operation is retried.) 90 246 P
0.03 (Eventually the iteration terminates with a successful server operation or a verification that) 90 232 P
(the two pathnames are in different domains.) 90 218 T
0 F
(4.3 Pr) 90 198 T
(os and Cons) 120.43 198 T
2 F
-0.03 (There are a number of good properties of the Sprite prefix mechanism, and one limitation.) 90 184 P
1.25 (First, clients are simplified. They do not iterate through directories or expand symbolic) 90 170 P
0.03 (links, in contrast to the vnode architecture. The prefix mechanism completely replaces the) 90 156 P
0.56 (UNIX mount mechanism, so servers are no more complex. The interface is optimized so) 90 142 P
0.28 (that system calls usually require only a single server operation. The most important prop-) 90 128 P
0.4 (erty is that the name space remains uniform across machines because it is the contents of) 90 114 P
-0.34 (the symbolic links at the mount points that defines how domains fit together, not a per-host) 90 100 P
-0.22 (or per-process configuration file. An final advantage with the prefix caching mechanism is) 90 86 P
FMENDPAGE
%%EndPage: "12" 13
%%Page: "13" 13
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
2 12 Q
0 X
1.95 (that the root server is usually bypassed because) 90 712 P
1.95 (clients quickly cache prefixes for the) 335.41 712 P
(domains they use.) 90 698 T
0.24 (The primary limitation of the Sprite scheme is the use of broadcast to locate servers. This) 90 680 P
-0.31 (choice was made for simplicity, but it obviously limits the range of the name space. A gen-) 90 666 P
-0.51 (eral solution would be make an upcall in the case that the broadcast fails so that a user-level) 90 652 P
-0.5 (process can take arbitrary action to locate the server. For example, the Domain name server) 90 638 P
-0.13 (or some other name service could be used. This solution has the nice property that the ker-) 90 624 P
-0 (nel implements a lightweight mechanism \050broadcast\051 that works for the common case, but) 90 610 P
(can rely on the escape hatch to user-level in the hard case.) 90 596 T
0 F
(5 Maintaining State in a Distributed System) 90 576 T
2 F
0.92 (Another way to view the differences between the vnode and Sprite architectures is their) 90 562 P
0.66 (support for maintaining distributed state. The Sprite architecture is inherently stateful, in) 90 548 P
-0.71 (contrast to the stateless file server model used in NFS, which was the main reason the vnode) 90 534 P
-0.58 (architecture was introduced. Sprite\325s stateful nature originally stemmed from its cache con-) 90 520 P
3.07 (sistency mechanism that supports data caching on diskless workstations [Nelson88].) 90 506 P
0.8 (Delayed writes are used to optimize performance, but stateful servers keep track of how) 90 492 P
-0.35 (files are cached so they can guarantee UNIX file access semantics even when files are con-) 90 478 P
-0.29 (currently write shared by processes on different hosts. It turns out that server state is useful) 90 464 P
1.35 (for a variety of other things. Examples include the record of which host is executing a) 90 450 P
-0.56 (pseudo-device server, what files are open for execution so they cannot be overwritten, what) 90 436 P
(devices are open in case they wish to enforce exclusive access, and file locking protocols.) 90 422 T
0.93 (The Sprite I/O interface has a number of entry points with no counterparts in the vnode) 90 404 P
0.36 (interface, and these are almost entirely devoted to maintaining distributed state. The state) 90 390 P
0.13 (does not have to be complex, it just has to be maintained carefully. It boils down to a per-) 90 376 P
-0.02 (object client list that records a few words of state about how that client is using the object.) 90 362 P
-0.13 (For most objects all that is required is the number open I/O streams to an object, expanded) 90 348 P
-0.05 (into counts for readers, writers, and executors. Shared and exclusive lock state is also kept) 90 334 P
0.31 (in the client list, as well as type-specific state such as the current version number of files,) 90 320 P
0.62 (or the ID of the host executing a pseudo-device server. For efficiency, a summary of the) 90 306 P
0.24 (client-list information \050e.g., the total number of readers\051 is also kept in the server\325s object) 90 292 P
(descriptor.) 90 278 T
1.22 (Maintaining state during normal operations is simple. State is initialized by the IoOpen) 90 260 P
0.63 (and/or SrvOpen procedures. When handling RPC requests, the ClientVerify procedure is) 90 246 P
0.29 (invoked to ensure that the server knows about the client. IoClose cleans up state about an) 90 232 P
0.21 (I/O stream. This approach implies that the I/O server is contacted as a result of each open) 90 218 P
-0.15 (and close system call. However, I/O stream sharing that results from process creation does) 90 204 P
0.87 (not require contact with the I/O server. This is an important optimization, and relatively) 90 190 P
1.08 (easy to achieve by keeping a reference count on steam descriptors \050\322file descriptors\323 in) 90 176 P
(UNIX terminology\051.) 90 162 T
0.76 (Life gets complicated by crash recovery and process migration [Douglis91]. A complete) 90 144 P
-0.02 (description of these mechanisms can be found in [Welch 90]. Only a few key points about) 90 130 P
(these mechanisms will be made here.) 90 116 T
0 F
(5.1 Pr) 90 96 T
(ocess Migration) 120.43 96 T
2 F
-0.13 (Process migration results in open I/O streams that move around the network. This requires) 90 82 P
FMENDPAGE
%%EndPage: "13" 14
%%Page: "14" 14
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
2 12 Q
0 X
0.29 (coordinated state updates on the original client, the new client, and the I/O server. This is) 90 712 P
0.39 (complicated by multiple references to I/O streams that operate independently, yet share a) 90 698 P
-0.19 (common stream access position, or offset. When a process migrates, state about each of its) 90 684 P
1.06 (I/O streams is packaged up and shipped to the process\325s new site as part of the process) 90 670 P
-0.1 (descriptor. However, no state changes are made when the process begins to leave. Instead,) 90 656 P
0.56 (after the process is reincarnated on the new site a set of coordinated state changes occur.) 90 642 P
0.07 (The new site notifies the I/O server for each stream, indicating that a stream reference has) 90 628 P
0.08 (migrated to it. The I/O server makes a callback to the original client that retrieves the cur-) 90 614 P
1.05 (rent stream offset and decrements the stream reference count there. The I/O server then) 90 600 P
-0.42 (updates its client list and replies to the new site. If there are no remaining stream references) 90 586 P
-0.23 (at the original site, then the new site can own the stream offset. Otherwise the server main-) 90 572 P
-0.29 (tains the stream offset on behalf of both sites. This algorithm is somewhat delicate because) 90 558 P
-0.42 (there are often Close operations that occur about the same time as migrations, and the lock-) 90 544 P
(ing order on data structures must be deadlock free.) 90 530 T
0 F
(5.2 Crash Recovery) 90 510 T
2 F
-0.6 (Crash recovery is based on the following observations. First, the I/O servers keep their state) 90 496 P
0.05 (organized on a per-client basis in order to support things like data cache consistency. This) 90 482 P
1.49 (also makes it easy to clean up state about clients that crash. Second, it turns out to be) 90 468 P
-0.1 (straight-forward for clients to mirror the state that the server keeps about them. Recall that) 90 454 P
-0.6 (the state information is just counts of open I/O streams, plus type-specific state like file ver-) 90 440 P
-0.08 (sion numbers. The observation that clients can duplicate their server\325s state means that the) 90 426 P
0.07 (system can recover from server crashes. The Reopen entry in the I/O interface is an idem-) 90 412 P
-0.14 (potent operation that attempts to reconcile the client\325s state with the state that exists on the) 90 398 P
-0.25 (server. The success or failure of the Reopen call is dependent on the type of the underlying) 90 384 P
-0.13 (object and the actions of other clients. For example, a client can recover if it is writing to a) 90 370 P
-0.06 (file and has dirty blocks in its main memory cache, unless for some reason \050i.e., a network) 90 356 P
-0.49 (partition\051 the server has allowed a different client to open the file and generate a conflicting) 90 342 P
1.15 (version. Two features of this recovery scheme are worth repeating. First, the Reopen is) 90 328 P
0.54 (idempotent so the client can invoke it whenever it thinks the server\325s state is out of date.) 90 314 P
0.09 (This happens when the client gets an ESTALE return code that implies the server has for-) 90 300 P
0.22 (gotten about the client, or when the client senses a server reboot as described below. Sec-) 90 286 P
(ond, the server has the final word, and can always deny a reopen request.) 90 272 T
0.59 (Crash detection is an important part of the recovery process. Sprite kernels monitor their) 90 254 P
-0.44 (RPC traffic to other hosts and keep a state variable for each other host. The state can be one) 90 240 P
0.64 (of Booting, Alive, or Dead. Transitions between these states are used to trigger recovery) 90 226 P
-0.28 (actions by clients and servers. When a server assumes a client is in the Dead state, it cleans) 90 212 P
1.1 (up state about that client. When a client assumes a server is newly Alive, it initiates its) 90 198 P
-0.02 (recovery protocol. Of course, crash detection is not fully reliable because a host can really) 90 184 P
-0.38 (only detect a communication failure. It is for this reason that the recovery protocol is idem-) 90 170 P
-0.14 (potent. A server might prematurely clean up state about a client, and a client might prema-) 90 156 P
(turely initiate the recovery protocol.) 90 142 T
-0.54 (The Sprite RPC protocol has two features that aid crash and reboot detection. First, a times-) 90 124 P
-0.45 (tamp is part of the RPC packet header, and this is set to the time the host booted up. All that) 90 110 P
0.2 (is important is that it is different on each boot so clients can detect a server reboot even if) 90 96 P
-0.32 (they didn\325t try to contact it while it was down. Second, an \322I\325m booting\323 flag is also part of) 90 82 P
FMENDPAGE
%%EndPage: "14" 15
%%Page: "15" 15
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
2 12 Q
0 X
0.28 (the RPC packet header. This flag is cleared after a server is fully up \050e.g., has checked its) 90 712 P
0.71 (disks\051 and is ready for service. Finally, idle clients ping their server every 30 seconds to) 90 698 P
0.78 (make sure they detect reboots in a timely way. A server could have thousands of clients) 90 684 P
(before the load from this would be a problem.) 90 670 T
0 F
(6 Other Related Ar) 90 650 T
(chitectur) 188.71 650 T
(es) 234.45 650 T
2 F
0.28 (The Ultrix gnode interface [Rodriguez86] is quite close to the vnode interface. The rnode) 90 636 P
-0.72 (interface used in ATT Unix, however, shares some similarities with the Sprite architecture.-) 90 622 P
-0.33 (The RFS architects classify it as a \322remote system call\323 interface [Rifkin86]. Remote oper-) 90 608 P
1.44 (ations are trapped out at a relatively high level and forwarded to the remote node. For) 90 594 P
0.17 (pathname operations in particular, this can result in fewer client-server interactions than a) 90 580 P
-0.09 (component-based interface. The implementation is a little gory, however. System calls are) 90 566 P
-0.33 (littered with checks against the remote case, and on the server side longjmp is used to warp) 90 552 P
-0.42 (execution back to the RPC stubs. This was done in order to avoid deeper structural changes) 90 538 P
-0.48 (required for a fully modular implementation. In contrast, the Sprite implementation is quite) 90 524 P
(clean, which made it easy to add in new cases such as the notion of user-level servers.) 90 510 T
0.98 (The UIO interface of the V system is a clean design introduced to support Uniform I/O) 90 492 P
-0.34 (access in distributed systems[Cheriton87]. It is also coupled with a prefix table mechanism) 90 478 P
1.02 (that is used to partition the name space among servers [Cheriton89]. However, the UIO) 90 464 P
-0.49 (interface also lumps naming and I/O operations together into one interface. The prefixes on) 90 450 P
0.12 (pathnames are used to partition the name space among different classes of servers such as) 90 436 P
-0.15 (print, file, display, and tape servers. A global name service is used to map from prefixes to) 90 422 P
-0.42 (server multicast addresses, but each class of service still has to implement a name space for) 90 408 P
-0.12 (its objects. In contrast, the Sprite prefix mechanism transparently distributes a hierarchical) 90 394 P
-0.2 (name space among file servers, and the file system interfaces are designed to allow the file) 90 380 P
(servers to function as more general name servers.) 90 366 T
0.21 (The Echo distributed file system developed at DEC SRC uses a more elaborate name ser-) 90 348 P
0.33 (vice to transparently distribute a file hierarchy among servers. The system is complicated) 90 334 P
0.67 (by support for replication, both at the name server level and at the file server level [His-) 90 320 P
0.24 (gen89]. In Echo, hosts still have local file systems, and the global file system name space) 90 306 P
(is not used for remote device or remote service access.) 90 292 T
-0.07 (The Plan-9 architecture [Pike 90], like Sprite, uses the file system name space to represent) 90 274 P
1.5 (services, both kernel-resident and user-level. The details of the communication mecha-) 90 260 P
0.56 (nisms are different, and the Sprite name space is fully shared via the prefix table mecha-) 90 246 P
-0.47 (nism, while the Plan-9 name space is per-process-group via the mount mechanism. Remote) 90 232 P
1.69 (access is possible in Plan-9 by means of a server-server that can make connections to) 90 218 P
-0.22 (remote services. Sprite has additional mechanisms to support process migration and server) 90 204 P
(crash recovery.) 90 190 T
0 F
(7 What I W) 90 170 T
(ould Do Differ) 149.64 170 T
(ently) 223.38 170 T
2 F
-0.53 (Perhaps the weakest point in the Sprite design is the handling of object attributes. Currently) 90 156 P
0.41 (this is distributed between the file server and the I/O server for the object. For files those) 90 142 P
-0.35 (servers are the same, but for devices and pseudo-devices they are different. Both the UNIX) 90 128 P
1.54 (stat\050\051 and fstat\050\051 system calls result in RPCs to both the file server, to get most of the) 90 114 P
0.82 (attributes, and the I/O server, to update attributes like the modify time. Of course this is) 90 100 P
1.55 (optimized for regular files so there is just one RPC. Also, the access and modify time) 90 86 P
FMENDPAGE
%%EndPage: "15" 16
%%Page: "16" 16
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
2 12 Q
0 X
-0.58 (stamps on the generic device files, the pathnames that map to local device instances, are not) 90 712 P
(that well defined.) 90 698 T
0.58 (There are some more minor things that could be cleaned up. It turns out that the Release) 90 680 P
0.77 (and Close operations are very similar, as are the IoOpen and MigEnd procedures. These) 90 666 P
0.69 (operations maintain usage counts that reflect the number of read and write streams to an) 90 652 P
-0.47 (object. These four procedures could probably be replaced by a pair of slightly more general) 90 638 P
(procedures, one to add a new stream, and one to remove state about a stream.) 90 624 T
0.43 (Finally, there are still some holes in the implementation that reflect lack of programming) 90 606 P
-0.38 (cycles. For example, while it is possible to migrate the client of a pseudo-device, migrating) 90 592 P
0.56 (the server is a lot harder because the state of all the clients also needs to be updated. For) 90 578 P
0.21 (some pseudo-device servers, like the X server, it doesn\325t really make sense to migrate the) 90 564 P
-0 (process to another host. With others, like the daemon that maintains state about idle hosts,) 90 550 P
(it might be useful.) 90 536 T
0.19 (A more interesting missing feature is the ability of a pseudo-device or pseudo-file-system) 90 518 P
-0.05 (server to return a previously existing I/O stream in response to the IoOpen operation. Cur-) 90 504 P
0.72 (rently the IoOpen procedure only creates an Upcall channel to the pseudo-device server.) 90 490 P
0.59 (However, the ability to pass back arbitrary streams would make it possible to implement) 90 476 P
0.11 (archive file systems and version control file systems. The infrastructure that supports pro-) 90 462 P
-0.33 (cess migration makes it feasible to pass an I/O stream between any two processes, but inte-) 90 448 P
1.54 (gration with the pseudo-device IoOpen procedure just wasn\325t on any critical path so it) 90 434 P
(didn\325t get fully implemented.) 90 420 T
-0.44 (Finally, the decision to have a private kernel-to-kernel RPC protocol is often questioned by) 90 402 P
-0.44 (others. The pat answer is that pseudo-devices and the associated upcall mechanism provide) 90 388 P
-0.12 (IPC, albeit with an open-close-read-write file system model. It can be argued that ioctl\050\051 is) 90 374 P
2.27 (a general transport mechanism, that hierarchical pathnames are well suited for server) 90 360 P
-0.41 (names, and the model benefits from being transparently distributed. In practice the file sys-) 90 346 P
-0.31 (tem model has worked fine for basic client-server relationships such as the X server and its) 90 332 P
0.23 (windowing clients. However, someone interested in more general protocols would proba-) 90 318 P
2.07 (bly prefer a pure message passing system. Our decision to hide the network protocol) 90 304 P
0.09 (reflects the goal of managing the network on behalf of users by providing a familiar time-) 90 290 P
(sharing-like environment centered around the file system.) 90 276 T
0 F
(8 Conclusions) 90 256 T
2 F
-0.4 (The main point that this paper makes is on the importance of cleanly separating the naming) 90 242 P
0.2 (and I/O interfaces of the file system. This split is taken for granted in classical distributed) 90 228 P
0.48 (systems literature that always includes a system wide name server [Wilkes80]. However,) 90 214 P
-0.25 (the distributed systems that evolved from UNIX implementations failed to incorporate this) 90 200 P
-0.45 (notion in the right way. SunOS, for example, uses a network database server to name hosts,) 90 186 P
-0.19 (password entries, and maps from file systems to file servers. However, once one enters the) 90 172 P
0.01 (domain of a file system all things are tied to one host. Even distributed systems like V use) 90 158 P
0.37 (a name service to partition servers at the top levels of the naming hierarchy. In Sprite the) 90 144 P
-0.19 (file servers generalize their directory structure mechanism to provide naming support for a) 90 130 P
0.73 (variety of objects. The only things not named by the file system are hosts, which can be) 90 116 P
0.43 (named via the Domain Name Service, users, and arbitrary processes \050only pseudo-device) 90 102 P
(servers have names in the file system name space\051.) 90 88 T
FMENDPAGE
%%EndPage: "16" 17
%%Page: "17" 17
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
0 12 Q
0 X
(9  Refer) 90 712 T
(ences) 130.41 712 T
2 10 Q
(Baker91.) 90 695.33 T
(M. Baker) 161 695.33 T
(, J. Hartman, M. Kupfer) 198.35 695.33 T
(, K. Shirrif) 293.99 695.33 T
(f and J. Ousterhout, \322Measurements of a) 337.11 695.33 T
(Distributed File System\323,) 162 683.33 T
1 F
(Pr) 266.39 683.33 T
(oc. of the 13th Symp. on Operating System Prin., Operating) 276.02 683.33 T
(Systems Review) 162 671.33 T
2 F
(, Oct. 1991, 198-212) 224.36 671.33 T
(Cheriton87) 90 655.33 T
(D. Cheriton, \322UIO: A Uniform I/O System Interface for Distributed Systems\323,) 161 655.33 T
1 F
(ACM) 477.45 655.33 T
(T) 162 643.33 T
(ransactions on Computer Systems) 167.01 643.33 T
2 F
( 5, 1 \050Feb. 1987\051, 12-46.) 302.76 643.33 T
(Cheriton89) 90 627.33 T
(D. Cheriton and T) 161 627.33 T
(. Mann, \322Decentralizing a Global Naming Service for Improved) 232.99 627.33 T
(Performance and Fault T) 162 615.33 T
(olerance\323,) 260.95 615.33 T
1 F
(ACM T) 304.23 615.33 T
(ransactions on Computer Systems) 332.84 615.33 T
2 F
( 7, 2 \050May) 468.59 615.33 T
(1989\051, 147-183.) 162 603.33 T
(Clark85.) 90 587.33 T
(D. Clark, \322The Structuring of Systems Using Upcalls\323,) 161 587.33 T
1 F
(Pr) 383.36 587.33 T
(oc. of the 10th Symp. on) 392.98 587.33 T
(Operating System Prin., Operating Systems Review) 162 575.33 T
2 F
(19, 5 \050Dec. 1985\051, 171-180.) 370.2 575.33 T
(Douglis90.) 90 559.33 T
-0.17 ( F) 161 559.33 P
-0.17 (. Douglis, \322T) 168.08 559.33 P
-0.17 (ransparent Process Migration for Personal W) 219.57 559.33 P
-0.17 (orkstations\323, PhD Thesis, Sep.) 398.05 559.33 P
(1990. University of California, Berkeley) 162 547.33 T
(.) 323.46 547.33 T
(Hisgen89) 90 531.33 T
-0.22 (A. Hisgen, A. Birrell, T) 161 531.33 P
-0.22 (. Mann, M. Schroeder and G. Swart, \322A) 254.31 531.33 P
-0.22 (vailability and Consistency) 411.34 531.33 P
(T) 162 519.33 T
(rade-of) 167.76 519.33 T
(fs in the Echo Distributed File System\323,) 196.43 519.33 T
1 F
(Pr) 358.56 519.33 T
(oc. Second W) 368.19 519.33 T
(orkshop on W) 421.39 519.33 T
(orkstation) 475.99 519.33 T
(Operating Systems,) 162 507.33 T
2 F
( Sep. 1989, 49-54) 239.73 507.33 T
(Nelson88.) 90 491.33 T
( M. Nelson, B. W) 161 491.33 T
(elch and J. Ousterhout, \322Caching in the Sprite Network File System\323,) 230.99 491.33 T
1 F
(ACM T) 162 479.33 T
(ransactions Computer Systems) 190.6 479.33 T
2 F
( 6, 1 \050Feb. 1988\051, 134-154.) 313.87 479.33 T
(Pike90) 90 463.33 T
(Rob Pike, Dave Presotto, Ken Thompson, and Howard T) 161 463.33 T
(ricky) 388.55 463.33 T
(, \322Plan 9 from Bell Labs\323,) 408.44 463.33 T
(Proc. of the Summer 1990 UKUUG Conf., London, July) 162 451.33 T
(, 1990, 1-9.) 387.88 451.33 T
(Rodriguez86) 90 435.33 T
-0.14 (R. Rodriguez, M. Koehler) 161 435.33 P
-0.14 (, and R. Hyde, \322The Generic File System\323,) 264.54 435.33 P
1 F
-0.14 (USENIX Confer) 437.16 435.33 P
-0.14 (ence) 501.33 435.33 P
(Pr) 162 423.33 T
(oceedings) 171.62 423.33 T
2 F
(, June 1986, 260-269) 211.59 423.33 T
(Sandber) 90 407.33 T
(g85) 122.57 407.33 T
(R. Sandber) 161 407.33 T
(g, D. Goldber) 205.24 407.33 T
(g, S. Kleiman, D. W) 260.02 407.33 T
(alsh, and B. L) 340.83 407.33 T
(yon, \322Design and) 396.08 407.33 T
-0.01 (Implementation of the Sun Network Filesystem\323,) 162 395.33 P
1 F
-0.01 (USENIX Confer) 361.52 395.33 P
-0.01 (ence Pr) 425.82 395.33 P
-0.01 (oceedings) 456.24 395.33 P
2 F
-0.01 (, June) 496.21 395.33 P
(1985, 1) 162 383.33 T
(19-130) 191.61 383.33 T
(W) 90 367.33 T
(alker83) 98.64 367.33 T
(B. W) 161 367.33 T
(alker) 181.3 367.33 T
(, \322The LOCUS Distributed Operating System\323,) 200.88 367.33 T
1 F
(Pr) 392.42 367.33 T
(oc. of the 9th Symp. on) 402.05 367.33 T
(Operating System Prin) 162 355.33 T
2 F
(., Operating Systems Review 17, 5 \050Nov) 253.61 355.33 T
(.1983\051, 49-70) 414.8 355.33 T
(W) 90 339.33 T
(elch86a.) 98.64 339.33 T
( B. B. W) 161 339.33 T
(elch, \322The Sprite Remote Procedure Call System\323, T) 195.46 339.33 T
(echnical Report) 406.01 339.33 T
(UCB/Computer Science Dpt. 86/302, University of California, Berkeley) 162 327.33 T
(, June 1986.) 450.61 327.33 T
(W) 90 311.33 T
(elch86b.) 98.64 311.33 T
-0.22 (B. B. W) 161 311.33 P
-0.22 (elch and J. K. Ousterhout, \322Pre\336x T) 192.51 311.33 P
-0.22 (ables: A Simple Mechanism for Locating Files) 333.97 311.33 P
(in a Distributed Filesystem\323,) 162 299.33 T
1 F
(Pr) 279.43 299.33 T
(oc. of the 6th ICDCS) 289.06 299.33 T
2 F
(, May 1986, 184-189.) 372.62 299.33 T
(W) 90 283.33 T
(elch88.) 98.64 283.33 T
(B. B. W) 161 283.33 T
(elch and J. K. Ousterhout, \322Pseudo-Devices: User) 192.96 283.33 T
(-Level Extensions to the Sprite) 392.33 283.33 T
(File System\323,) 162 271.33 T
1 F
(Pr) 218.92 271.33 T
(oc. of the 1988 Summer USENIX Conf) 228.54 271.33 T
2 F
(., June 1988, 184-189.) 382.06 271.33 T
(W) 90 255.33 T
(elch90.) 98.64 255.33 T
(B. B. W) 161 255.33 T
(elch, \322Naming, State Management, and User) 192.96 255.33 T
(-Level Extensions in the Sprite) 371.51 255.33 T
(Distributed File System\323, PhD Thesis, 1990. University of California, Berkeley) 162 243.33 T
(.) 479.22 243.33 T
(W) 90 227.33 T
(ilkes80) 99.04 227.33 T
-0.31 (M. W) 161 227.33 P
-0.31 (ilkes, R. Needham, \322The Cambridge Model Distributed System\323, Operating Systems) 183.61 227.33 P
(Review 14, 1 \050Jan. 1980\051.) 162 215.33 T
FMENDPAGE
%%EndPage: "17" 18
%%Page: "18" 18
612 792 0 FMBEGINPAGE
90 746 522 756 R
7 X
0 K
V
90 32.67 522 42.67 R
V
90 72 522 720 R
V
0 12 Q
0 X
(10 Appendix A - Summary of Remote Pr) 90 712 T
(ocedur) 297.98 712 T
(e Calls) 333.07 712 T
2 F
-0.73 (There are 40 RPCs defined in the Sprite implementation, of which 29 are for the file system,) 90 698 P
0.09 (4 are for process migration, 2 are for remote signals, 1 is to get the current time, and 4 are) 90 684 P
-0.73 (for testing the RPC system itself. 2 of the file system RPCs are directly in support of process) 90 670 P
0.06 (migration. Recall that the RPC mechanism is entirely kernel-to-kernel. The operating sys-) 90 656 P
0.28 (tem uses RPC for its own purposes in order to provide a transparently distributed system.) 90 642 P
0.1 (The large number of file system RPCs reflects the degree to which Sprite relies on its dis-) 90 628 P
(tributed file system to provide network transparency.) 90 614 T
(Table 6. Kernel-to-kernel RPCS used in Sprite.) 90 578 T
2 10 Q
(RPC) 90 563.33 T
(#) 243 563.33 T
(Description) 270 563.33 T
(ECHO_1) 90 553.33 T
(1) 243 553.33 T
(Echo. Performed by server\325s interrupt handler \050unused\051.) 270 553.33 T
(ECHO_2) 90 543.33 T
(2) 243 543.33 T
(Echo. Performed by Rpc_Server kernel thread.) 270 543.33 T
(SEND) 90 533.33 T
(3) 243 533.33 T
(Send. Like Echo, but data only transferred to server.) 270 533.33 T
(RECEIVE) 90 523.33 T
(4) 243 523.33 T
(Receive. Data only transferred back to client.) 270 523.33 T
(GETTIME) 90 513.33 T
(5) 243 513.33 T
(Broadcast RPC to get the current time.) 270 513.33 T
(FS_PREFIX) 90 503.33 T
(6) 243 503.33 T
(Broadcast RPC to find prefix server.) 270 503.33 T
(FS_OPEN) 90 493.33 T
(7) 243 493.33 T
(Open a file system object by name.) 270 493.33 T
(FS_READ) 90 483.33 T
(8) 243 483.33 T
(Read data from a file system object.) 270 483.33 T
(FS_WRITE) 90 473.33 T
(9) 243 473.33 T
(Write data to a file system object.) 270 473.33 T
(FS_CLOSE) 90 463.33 T
(10) 243 463.33 T
(Close an I/O stream to a file system object.) 270 463.33 T
(FS_UNLINK) 90 453.33 T
(11) 243 453.33 T
(Remove the name of an object.) 270 453.33 T
(FS_RENAME) 90 443.33 T
(12) 243 443.33 T
(Change the name of an object.) 270 443.33 T
(FS_MKDIR) 90 433.33 T
(13) 243 433.33 T
(Create a directory.) 270 433.33 T
(FS_RMDIR) 90 423.33 T
(14) 243 423.33 T
(Remove a directory.) 270 423.33 T
(FS_MKDEV) 90 413.33 T
(15) 243 413.33 T
(Make a special device file.) 270 413.33 T
(FS_LINK) 90 403.33 T
(16) 243 403.33 T
(Make a directory reference to an existing object.) 270 403.33 T
(FS_SYM_LINK) 90 393.33 T
(17) 243 393.33 T
(Make a symbolic link to an existing object.) 270 393.33 T
(FS_GET_ATTR) 90 383.33 T
(18) 243 383.33 T
(Get the attributes of the object behind an I/O stream.) 270 383.33 T
(FS_SET_ATTR) 90 373.33 T
(19) 243 373.33 T
(Set the attributes of the object behind an I/O stream.) 270 373.33 T
(FS_GET_ATTR_PATH) 90 363.33 T
(20) 243 363.33 T
(Get the attributes of a named object.) 270 363.33 T
(FS_SET_ATTR_PATH) 90 353.33 T
(21) 243 353.33 T
(Set the attributes of a named object.) 270 353.33 T
(FS_GET_IO_ATTR) 90 343.33 T
(22) 243 343.33 T
(Get the attributes kept by the I/O server.) 270 343.33 T
(FS_SET_IO_ATTR) 90 333.33 T
(23) 243 333.33 T
(Set the attributes kept by the I/O server.) 270 333.33 T
(FS_DEV_OPEN) 90 323.33 T
(24) 243 323.33 T
(Complete the open of a remote device or pseudo-device.) 270 323.33 T
(FS_SELECT) 90 313.33 T
(25) 243 313.33 T
(Query the status of a device or pseudo-device.) 270 313.33 T
(FS_IO_CONTROL) 90 303.33 T
(26) 243 303.33 T
(Perform an object-specific operation.) 270 303.33 T
(FS_CONSIST) 90 293.33 T
(27) 243 293.33 T
(Request that cache consistency action be performed.) 270 293.33 T
(FS_CONSIST_REPLY) 90 283.33 T
(28) 243 283.33 T
(Acknowledgment that consistency action completed.) 270 283.33 T
(FS_COPY_BLOCK) 90 273.33 T
(29) 243 273.33 T
(Copy a block of a swap file.) 270 273.33 T
(FS_MIGRATE) 90 263.33 T
(30) 243 263.33 T
(Tell I/O server that an I/O stream has migrated.) 270 263.33 T
(FS_RELEASE) 90 253.33 T
(31) 243 253.33 T
(Tell source of migration to release I/O stream.) 270 253.33 T
(FS_REOPEN) 90 243.33 T
(32) 243 243.33 T
(Recover the state about an I/O stream.) 270 243.33 T
(FS_RECOVERY) 90 233.33 T
(33) 243 233.33 T
(Signal that recovery actions have completed.) 270 233.33 T
(FS_DOMAIN_INFO) 90 223.33 T
(34) 243 223.33 T
(Return information about a file system domain.) 270 223.33 T
(PROC_MIG_COMMAND) 90 213.33 T
(35) 243 213.33 T
(Transfer process state during migration.) 270 213.33 T
(PROC_REMOTE_CALL) 90 203.33 T
(36) 243 203.33 T
(Forward system call to the home node.) 270 203.33 T
(PROC_REMOTE_WAIT) 90 193.33 T
(37) 243 193.33 T
(Synchronize exit of migrated process.) 270 193.33 T
(PROC_GETPCB) 90 183.33 T
(38) 243 183.33 T
(Return process table entry for migrated process.) 270 183.33 T
(REMOTE_WAKEUP) 90 173.33 T
(39) 243 173.33 T
(Wakeup a remote process.) 270 173.33 T
(SIG_SEND) 90 163.33 T
(40) 243 163.33 T
(Issue a signal to a remote process.) 270 163.33 T
FMENDPAGE
%%EndPage: "18" 19
%%Trailer
%%BoundingBox: 0 0 612 792
%%Pages: 18 1
%%DocumentFonts: Times-Bold
%%+ Times-Italic
%%+ Times-Roman
