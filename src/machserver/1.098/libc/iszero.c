/* 
 * iszero.c --
 *
 *	Procedure to determine whether a double is a zero, normal,
 *	subnormal, etc.  This requires the number to be in IEEE format,
 *	so this may end up being machine-dependent.  These routines
 *	could be more efficient, but they're hardly used anyways.
 *
 *
 * Copyright 1990 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/lib/c/etc/sun3.md/RCS/isnan.c,v 1.2 90/09/11 14:47:34 kupfer Exp $ SPRITE (Berkeley)";
#endif /* not lint */

#include <math.h>
#include <machparam.h>

#if BYTE_ORDER == LITTLE_ENDIAN
#define HIGH 1
#define LOW 0
#endif
#if BYTE_ORDER == BIG_ENDIAN
#define HIGH 0
#define LOW 1
#endif

#define SIGN 1
#define ZEROEXP 2
#define VALIDEXP 4
#define HIEXP 8
#define FRAC 16

#define SIGNBITS 0x80000000
#define EXPBITS 0x7ff00000
#define MANTBITS 0x000fffff

static int parts();

/*
 *----------------------------------------------------------------------
 *
 * issubnormal --
 *
 *      Return whether a double is subnormal.
 *
 * Results:
 *      1 if the number is subnormal, 0 otherwise.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
int issubnormal(value)
double value;
{
    int result;
    result = parts(value);
    return (result&ZEROEXP) && (result&FRAC);
}

/*
 *----------------------------------------------------------------------
 *
 * isnormal --
 *
 *      Return whether a double is normal.
 *
 * Results:
 *      1 if the number is normal, 0 otherwise.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
int isnormal(value)
double value;
{
    int result;
    result = parts(value);
    return (result&VALIDEXP)!=0;
}

/*
 *----------------------------------------------------------------------
 *
 * iszero --
 *
 *      Return whether a double is zero.
 *
 * Results:
 *      1 if the number is zero, 0 otherwise.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
int iszero(value)
double value;
{
    int result;
    result = parts(value);
    return (result&ZEROEXP) && !(result&FRAC);
}

/*
 *----------------------------------------------------------------------
 *
 * signbit --
 *
 *      Return whether a double has the sign set.
 *
 * Results:
 *      1 if the number has sign set, 0 otherwise.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
int signbit(value)
double value;
{
    int result;
    result = parts(value);
    return (result&SIGN)!=0;
}

/*
 *----------------------------------------------------------------------
 *
 * parts --
 *
 *	Sets bits according to the parts of the IEEE floating point number.
 *
 * Results:
 *	Sets SIGN if sign bit set.
 *	Sets ZEROEXP if exponent is zero.
 *	Sets VALIDEXP if exponent is not zero or max.
 *	Sets HIEXP if exponent is max.
 *	Sets FRAC if fraction is nonzero.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
parts(value)
double value;
{
    int result = 0;

    union {
	double d;
	long l[2];
    } u;

    /*
     * Put the value into a union so we can check out the bits.
     */
    u.d = value;


    /*
     * An IEEE Std 754 double precision floating point number
     * has the following format:
     *
     *      1  bit       -- sign of Mantissa
     *      11 bits      -- exponent
     *      52 bits      -- Mantissa
     *
     * If the exponent has all bits set, the value is not a 
     * real number.
     *
     * If the Mantissa is zero then the value is infinity, which
     * is the result of division by zero, or overflow.
     *
     * If the Mantissa is non-zero the value is not a number (NaN).
     * NaN can be generated by dividing zero by itself, taking the
     * logarithm of a negative number, etc.
     */

    /*
     * Check the sign.
     */
    if (u.l[HIGH] & SIGNBITS) {
	result |= SIGN;
    }
    /*
     * check the exponent
     */
    if ((u.l[HIGH] & 0x7ff00000) == 0x7ff00000) {
	result |= HIEXP;
    } else if ((u.l[HIGH] & 0x7ff00000) == 0) {
	result |= ZEROEXP;
    } else {
	result |= VALIDEXP;
    }

    if ((u.l[HIGH] & ~0xfff00000) != 0 || u.l[LOW] != 0) {
	result |= FRAC;
    }

    return result;
}


