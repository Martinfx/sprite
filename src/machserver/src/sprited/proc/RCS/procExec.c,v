head     1.23;
branch   ;
access   ;
symbols  srv030:1.23 srv028:1.22 srv027:1.22 srv026:1.22 srv024:1.21 srv022:1.20 srv021:1.20 srv019:1.20 srv018:1.20 srv016:1.20 srv015:1.20 srv014:1.20 srv012:1.19 srv011:1.19 srv010:1.19 srv008:1.18 srv007:1.18 srv006:1.18 srv005:1.18 srv004:1.18 srv003:1.17 srv002:1.16 srv001:1.15;
locks    ; strict;
comment  @ * @;


1.23
date     92.07.16.18.07.39;  author kupfer;  state Exp;
branches ;
next     1.22;

1.22
date     92.07.09.15.47.21;  author kupfer;  state Exp;
branches ;
next     1.21;

1.21
date     92.07.08.12.49.05;  author kupfer;  state Exp;
branches ;
next     1.20;

1.20
date     92.06.10.15.29.31;  author kupfer;  state Exp;
branches ;
next     1.19;

1.19
date     92.06.04.14.18.26;  author kupfer;  state Exp;
branches ;
next     1.18;

1.18
date     92.05.08.15.06.55;  author kupfer;  state Exp;
branches ;
next     1.17;

1.17
date     92.04.29.21.54.58;  author kupfer;  state Exp;
branches ;
next     1.16;

1.16
date     92.04.23.23.50.54;  author kupfer;  state Exp;
branches ;
next     1.15;

1.15
date     92.04.02.21.11.46;  author kupfer;  state Exp;
branches ;
next     1.14;

1.14
date     92.03.12.17.36.27;  author kupfer;  state Exp;
branches ;
next     1.13;

1.13
date     92.02.27.16.28.50;  author kupfer;  state Exp;
branches ;
next     1.12;

1.12
date     92.01.21.16.04.14;  author kupfer;  state Exp;
branches ;
next     1.11;

1.11
date     91.12.01.21.59.22;  author kupfer;  state Exp;
branches ;
next     1.10;

1.10
date     91.11.14.10.02.22;  author kupfer;  state Exp;
branches ;
next     1.9;

1.9
date     91.10.18.17.59.59;  author kupfer;  state Exp;
branches ;
next     1.8;

1.8
date     91.10.08.17.28.06;  author kupfer;  state Exp;
branches ;
next     1.7;

1.7
date     91.10.04.11.37.26;  author kupfer;  state Exp;
branches ;
next     1.6;

1.6
date     91.09.24.16.27.32;  author kupfer;  state Exp;
branches ;
next     1.5;

1.5
date     91.09.23.14.19.46;  author kupfer;  state Exp;
branches ;
next     1.4;

1.4
date     91.09.20.19.36.44;  author kupfer;  state Exp;
branches ;
next     1.3;

1.3
date     91.09.02.22.53.55;  author kupfer;  state Exp;
branches ;
next     1.2;

1.2
date     91.09.01.21.03.06;  author kupfer;  state Exp;
branches ;
next     1.1;

1.1
date     91.08.19.12.25.51;  author kupfer;  state Exp;
branches ;
next     ;


desc
@Stuff related to execing a user program.
@


1.23
log
@Split spriteSrv.h into user and server versions.  Fix bug that ate
parameters for shell scripts.
@
text
@/* procExec.c --
 *
 *	Routines to exec a program.  There is no monitor required in this
 *	file.  Access to the proc table is synchronized by locking the PCB
 *	when modifying the genFlags field.
 *
 * Copyright (C) 1985, 1988, 1991 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.22 92/07/09 15:47:21 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
#endif /* not lint */

#include <sprite.h>
#include <spriteTime.h>
#include <byte.h>
#include <ckalloc.h>
#include <ctype.h>
#include <list.h>
#include <mach.h>
#include <mach_error.h>
#include <mach/machine/vm_param.h>
#include <status.h>
#include <string.h>
#include <user/fs.h>

#include <fs.h>
#include <main.h>		/* main_DebugFlag */
#include <proc.h>
#include <procInt.h>
#include <procMach.h>
#include <procMachInt.h>
#include <rpc.h>
#include <sig.h>
#include <spriteSrvServer.h>
#include <sys.h>		/* sys_CallProfiling */
#include <timer.h>		/* Timer_GetTimeOfDay */
#include <utils.h>
#include <vm.h>
#include <user/vmStat.h>

/*
 * This will go away when libc is changed.
 */
#ifndef PROC_MAX_ENVIRON_LENGTH
#define PROC_MAX_ENVIRON_LENGTH (PROC_MAX_ENVIRON_NAME_LENGTH + \
				 PROC_MAX_ENVIRON_VALUE_LENGTH)
#endif /*  PROC_MAX_ENVIRON_LENGTH */

/* 
 * Maximum number of argument to an interpreter: script name, interpreter 
 * flags, script name (again), and nil pointer to end the array.
 */
#define MAX_INTERP_ARGS		4

/* 
 * When copying arguments and environment variables in from user space, we 
 * temporarily put them on a linked list.  Once we have the strings all on 
 * the list, we can figure out how much space they'll take, etc.
 */

typedef struct {
    List_Links	links;
    Address	stringPtr;
    int		stringLen;
} ArgListElement;

/*
 * Define the information needed to perform an exec: the user's stack,
 * where to put it, and whether to debug on startup.  We define a structure
 * containing the "meta-info" that isn't actually copied onto the user's
 * stack, and then another structure that also includes argc.  (By
 * separating the header into a separate structure, it's easier to take its
 * size.)
 * 
 * Note that the actual values for argv and envp passed to main() are
 * calculated by _start() based on the address of argc and are not actually
 * put on the stack given to the exec'ed process.  The size of the structure
 * to be copied onto the user's stack is the size in the 'size' field
 * minus the size of the header.
 *
 * The fileName and argString fields are used only when doing a remote exec.
 */
typedef struct {
    Address base;		/* base of the structure in user space */
    int size;			/* size of the entire structure */
    char *fileName;		/* pointer to buffer containing name of file
				 * to exec */
    int fileNameLength;		/* length of file name buffer */
    char *argString;		/* pointer to buffer containing full list of
				 * arguments, for ps listing */
    int argLength;		/* length of argString buffer */
} ExecEncapHeader;

typedef struct {
    ExecEncapHeader hdr;	/* meta-information; see above */
    /*
     * User stack data starts here.
     */
    int argc;			/* Number of arguments */
    /*
     * argv pointers go here
     * envp pointers go here
     * argv strings go here
     * envp strings go here
     */
} ExecEncapState;

/*
 * Define a structure to hold all the information about arguments
 * and environment variables (pointer and length).  This makes it easier
 * to pass a NIL pointer for the whole thing, and to keep them in one
 * place.  The number of arguments/environment pointers includes the 
 * nil pointer at the end of the array.
 */

typedef struct {
    Boolean	userMode;	/* TRUE if the arguments are in user space */
    char	**argPtrArray;	/* The array of argument pointers. */
    int		numArgs;	/* The number of arguments in the argArray. */
    int		argLength;	/* actual bytes in argArray */
    char	**envPtrArray;	/* The array of environment pointers. */
    int		numEnvs;	/* The number of arguments in the envArray. */
    int		envLength;	/* actual bytes in envArray */
} UserArgs;

/* 
 * This flag controls debug printf's for the argc, argv, and the 
 * environment strings.  Higher numbers yield more printfs.
 */
static int argDebug = 0;

/* 
 * When a user process starts, it has three regions of memory: code, 
 * heap, and stack.  The size and location of the code are specified 
 * by the object file.  The location of the heap is partially 
 * specified by the object file.  We will create large heap and stack 
 * segments, and then initially only map portions of them into the 
 * process address space.
 */

/* 
 * Instrumentation.
 */

static Time doExecTime;		/* time spent in DoExec */
static Time partATime;
static Time partBTime;		/* XXX actually partA + partB */
static Time setupCodeTime;	/* time spent in SetupCode */
static Time setupArgsTime;	/* time in SetupArgs */
static Time setupVmTime;	/* time spent in SetupVM */
static Time doCodeTime;
static Time doHeapTime;
static Time doStackTime;
static Time stackCopyOutTime;

/* GrabArgArray instrumentation */
static Time grabArgsTime;
static Time argsAccessTime;
static int numStrings;		/* number of strings copied in */
static unsigned long stringBytes; /* sum of string lengths */

/*
 * Forward declarations.
 */
static ReturnStatus DoCode _ARGS_((Proc_LockedPCB *procPtr,
		Proc_ObjInfo *execInfoPtr, Vm_Segment *codeSegPtr));
static ReturnStatus DoExec _ARGS_((Proc_ControlBlock *procPtr,
		char *execPath, UserArgs *userArgsPtr, Boolean kernExec,
		Boolean debugMe));
static ReturnStatus DoHeap _ARGS_((Proc_LockedPCB *procPtr,
		Proc_ObjInfo *execInfoPtr, Fs_Stream *objFilePtr,
		char *objFileName));
static ReturnStatus DoStack _ARGS_((Proc_LockedPCB *procPtr,
		Proc_ObjInfo *execInfoPtr, ExecEncapState *encapPtr));
static ReturnStatus GrabArgArray _ARGS_((int maxLength, Boolean userProc,
		char **extraArgArray, char **argPtrArray, int *numArgsPtr,
		List_Links *argList, int *realLengthPtr,
		int *paddedLengthPtr));
static Address HeapStart _ARGS_((Proc_ObjInfo *execInfoPtr));
static void InstrumentSwapSegments _ARGS_((Proc_LockedPCB *procPtr,
		Proc_ObjInfo *execInfoPtr));
static ReturnStatus SetupCode _ARGS_((char *execName, UserArgs *userArgsPtr,
		Fs_Stream **filePtrPtr, Vm_Segment **codeSegPtrPtr,
		Proc_ObjInfo *execInfoPtr, ExecEncapState **encapPtrPtr,
		char **argStringPtr));
static ReturnStatus SetupInterpret _ARGS_((char *buffer, int sizeRead,
		Fs_Stream **interpPtrPtr, char *interpName,
		char **argStringPtr, Proc_ObjInfo *objInfoPtr));
static ReturnStatus SetupVM _ARGS_((Proc_LockedPCB *procPtr,
		Vm_Segment *codeSegPtr, Proc_ObjInfo *execInfoPtr,
		ExecEncapState *encapPtr));
static Address StackStart _ARGS_((Proc_ObjInfo *execInfoPtr));


/*
 *----------------------------------------------------------------------
 *
 * Proc_OldExecEnvStub --
 *
 *	Do an exec on the local host.
 *	Note: this function is deprecated.  Remove it when you no longer 
 *	wish to support binaries that use the old exec call.
 *
 * Results:
 *	MIG_NO_REPLY: the exec was successful, so no reply message should 
 *	be sent.
 *	KERN_SUCCESS: there was an error; the Sprite code for the error is 
 *	returned in *statusPtr, and the "pending signals" flag is filled 
 *	in.
 *
 * Side effects:
 *	The process's PROC_NEEDS_WAKEUP flag is set if successful.
 *
 *----------------------------------------------------------------------
 */
    
kern_return_t
Proc_OldExecEnvStub(serverPort, fileName, nameLength, argPtrArray,
		 envPtrArray, debugMe, statusPtr, sigPendingPtr)
    mach_port_t	serverPort;	/* the server request port */
    Fs_PathName fileName;	/* The name of the file to exec. */
    mach_msg_type_number_t nameLength; /* extra parameter to appease MIG */
    vm_address_t argPtrArray;	/* The array of arguments to the exec'd 
				 * program. (user address) */
    vm_address_t envPtrArray;	/* The array of environment variables
				 * of the form NAME=VALUE. (user address) */ 
    Boolean	debugMe;	/* TRUE means that the process is 
				 * to be sent a SIG_DEBUG signal before
    				 * executing its first instruction. */
    ReturnStatus *statusPtr;	/* OUT: Sprite status code */
    boolean_t *sigPendingPtr;	/* OUT: is there a signal pending */
{
#ifdef lint
    serverPort = serverPort;
    nameLength = nameLength;
#endif

    *statusPtr = Proc_Exec(fileName, (char **)argPtrArray,
			   (char **)envPtrArray, debugMe, 0);
    if (*statusPtr != SUCCESS) {
	*sigPendingPtr = Sig_Pending(Proc_GetCurrentProc());
	return KERN_SUCCESS;
    } else {
	return MIG_NO_REPLY;
    }
}


/*
 *----------------------------------------------------------------------
 *
 * Proc_ExecEnvStub --
 *
 *	Do an exec on the local host.
 *	Note: this function is deprecated.  It can be ifdef'd out when you
 *	no longer wish to support binaries that use the old exec call.
 *	However, you should hold onto the migration-related code.
 *
 * Results:
 *	MIG_NO_REPLY: the exec was successful, so no reply message should 
 *	be sent.
 *	KERN_SUCCESS: there was an error; the Sprite code for the error is 
 *	returned in *statusPtr, and the "pending signals" flag is filled 
 *	in.
 *
 * Side effects:
 *	The process's PROC_NEEDS_WAKEUP flag is set if successful.
 *
 *----------------------------------------------------------------------
 */

kern_return_t
Proc_ExecEnvStub(serverPort, fileName, nameLength, argOffsetArray, numArgs,
		    argStrings, argStringsSize, envOffsetArray, numEnvs,
		    envStrings, envStringsSize, debugMe, statusPtr,
		    sigPendingPtr)
    mach_port_t		serverPort;	/* the server request port */
    Fs_PathName		fileName;	/* The name of the file to exec. */
    mach_msg_type_number_t nameLength;	/* extra parameter to appease MIG */
    Proc_OffsetTable	argOffsetArray;	/* offsets into argument strings */
    mach_msg_type_number_t numArgs;	/* number of argument strings */
    Proc_Strings 	argStrings;	/* argument strings */
    mach_msg_type_number_t argStringsSize; /* number of bytes in arg strings */
    Proc_OffsetTable	envOffsetArray;	/* offsets into environment strings */
    mach_msg_type_number_t numEnvs;	/* number of environment strings */
    Proc_Strings	envStrings;	/* environment strings */
    mach_msg_type_number_t envStringsSize; /* number of bytes in env strings */
    Boolean		debugMe;	/* TRUE means that the process is 
					 * to be sent a SIG_DEBUG signal before
					 * executing its first instruction. */
    ReturnStatus	*statusPtr;	/* OUT: Sprite status code */
    boolean_t		*sigPendingPtr;	/* OUT: is there a signal pending */
{
    char **argPtrArray;			/* pointers into arg strings */
    char **envPtrArray;			/* pointers into env strings */
    UserArgs userArgs;
    Proc_ControlBlock *procPtr = Proc_GetCurrentProc();
    int i;

#ifdef lint
    serverPort = serverPort;
    nameLength = nameLength;
    argStringsSize = argStringsSize;
    envStringsSize = envStringsSize;
#endif

    /* 
     * Convert the string offsets into actual string pointers.  Allow room 
     * for a null pointer at the end.
     */
    argPtrArray = (char **)ckalloc((numArgs + 1) * sizeof(char *));
    envPtrArray = (char **)ckalloc((numEnvs + 1) * sizeof(char *));
    for (i = 0; i < numArgs; i++) {
	argPtrArray[i] = argStrings + argOffsetArray[i];
    }
    argPtrArray[numArgs] = (char *)NIL;
    for (i = 0; i < numEnvs; i++) {
	envPtrArray[i] = envStrings + envOffsetArray[i];
    }
    envPtrArray[numEnvs] = (char *)NIL;

    userArgs.userMode = FALSE;
    userArgs.argPtrArray = argPtrArray;
    userArgs.numArgs = numArgs;
    userArgs.argLength = (numArgs+1) * sizeof(char *);
    userArgs.envPtrArray = envPtrArray;
    userArgs.numEnvs = numEnvs;
    userArgs.envLength = (numEnvs+1) * sizeof(char *);

    *statusPtr = DoExec(procPtr, fileName, &userArgs, FALSE, debugMe);

    if (*statusPtr != SUCCESS) {
	*sigPendingPtr = Sig_Pending(Proc_GetCurrentProc());
	return KERN_SUCCESS;
    } else {
	return MIG_NO_REPLY;
    }
}


/*
 *----------------------------------------------------------------------
 *
 * Proc_Exec --
 *
 *	The ultimate entry point for the Exec system call.  This
 * 	handles both local and remote exec's.  It calls SetupExec to
 * 	initialize the file pointer, a.out info, user's stack image, etc.
 *	The a.out information is used if the exec is
 * 	performed on this machine, but for a remote exec, the file
 *	is reopened in case of different machine types.  The stack is
 * 	used locally or copied to the remote host.
 *
 * Results:
 *	For local exec's, returns the usual Sprite status code.
 *	For remote exec's, SUCCESS is returned, and the calling routine
 *	arranges for the process to hit a migration signal before
 *	continuing.
 *
 * Side effects:
 *	The argument & environment arrays are made accessible.
 *	The DoExec routine makes the arrays unaccessible again.  The 
 *	process's PROC_NEEDS_WAKEUP flag is set if successful.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Proc_Exec(fileName, argPtrArray, envPtrArray, debugMe, host)
    char	*fileName;	/* The name of the file to exec. */
    char	**argPtrArray;	/* The array of arguments to the exec'd 
				 * program. (user address) */
    char	**envPtrArray;	/* The array of environment variables
				 * of the form NAME=VALUE. (user addr.) */ 
    Boolean	debugMe;	/* TRUE means that the process is 
				 * to be sent a SIG_DEBUG signal before
    				 * executing its first instruction. */
    int		host;		/* Host to which to do remote exec, or 0
				 * for local host. */
{
    char		**newArgPtrArray;
    int			newArgPtrArrayLength;
    char		**newEnvPtrArray;
    int			newEnvPtrArrayLength;
    UserArgs		userArgs;
    ReturnStatus	status;
    ExecEncapState	**encapPtrPtr;
    Proc_ControlBlock 	*procPtr;
    
    /*
     * Make the arguments array accessible.
     */

    if (argPtrArray != (char **) USER_NIL) {
	Vm_MakeAccessible(VM_READONLY_ACCESS,
			  (PROC_MAX_EXEC_ARGS + 1) * sizeof(Address),
			  (Address) argPtrArray, 
		          &newArgPtrArrayLength, (Address *) &newArgPtrArray);
	if (newArgPtrArrayLength == 0) {
	    return(SYS_ARG_NOACCESS);
	}
    } else {
	newArgPtrArray = (char **) NIL;
	newArgPtrArrayLength = 0;
    }

    /*
     * Make the environments array accessible.
     */

    if (envPtrArray != (char **) USER_NIL) {
	Vm_MakeAccessible(VM_READONLY_ACCESS,
			  (PROC_MAX_ENVIRON_SIZE + 1) * sizeof(Address),
			  (Address) envPtrArray, 
		          &newEnvPtrArrayLength, (Address *) &newEnvPtrArray);
	if (newEnvPtrArrayLength == 0) {
	    return(SYS_ARG_NOACCESS);
	}
    } else {
	newEnvPtrArray = (char **) NIL;
	newEnvPtrArrayLength = 0;
    }
    /*
     * Perform the exec, if local, or setup the user's stack if remote.
     */
    userArgs.userMode = TRUE;
    userArgs.argPtrArray = newArgPtrArray;
    userArgs.numArgs = newArgPtrArrayLength / sizeof(Address);
    userArgs.argLength = newArgPtrArrayLength;
    userArgs.envPtrArray = newEnvPtrArray;
    userArgs.numEnvs = newEnvPtrArrayLength / sizeof(Address);
    userArgs.envLength = newEnvPtrArrayLength;

    /*
     * Check for explicit remote exec onto this host, in which case it's
     * a local exec.
     */
    if (host == rpc_SpriteID) {
	host = 0;
    }

    if (host != 0) {
#ifdef SPRITED_MIGRATION	
	encapPtrPtr = &encapPtr;
#else
	return PROC_MIGRATION_REFUSED;
#endif
    } else {
	encapPtrPtr = (ExecEncapState **) NIL;
    }
    procPtr = Proc_GetCurrentProc();
    status = DoExec(procPtr, fileName, &userArgs, FALSE, debugMe);
#ifdef SPRITED_MIGRATION
    if (status == SUCCESS && host != 0) {
	/*
	 * Set up the process to migrate.
	 */
	Proc_Lock(procPtr);
	status = ProcInitiateMigration(procPtr, host);
	if (status == SUCCESS) {
	    procPtr->remoteExecBuffer = (Address) encapPtr;
	    Proc_FlagMigration(procPtr, host, TRUE);
	} else {
	    ckfree((Address) encapPtr);
	}
	Proc_Unlock(procPtr);
    }
#endif /* SPRITED_MIGRATION */

#ifdef lint
#ifndef SPRITED_MIGRATION
    encapPtrPtr = encapPtrPtr;
#endif
#endif
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * Proc_KernExec --
 *
 *	Facade over DoExec for exec'ing the first user process.
 *
 * Results:
 *	Return status.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Proc_KernExec(procPtr, execPath, argPtrArray)
    Proc_ControlBlock *procPtr;	/* process to set up */
    char *execPath;		/* name of program to exec */
    char **argPtrArray;		/* argv argument array to pass to process */
{
    UserArgs userArgs;

    /* 
     * Set up the argument/environment arrays.  We don't have to be 
     * accurate about the argument count or space, because the end of the 
     * argument array is marked with a NIL pointer.  There are no 
     * environment variables to set.
     */
    userArgs.userMode = FALSE;
    userArgs.argPtrArray = argPtrArray;
    userArgs.numArgs = PROC_MAX_EXEC_ARGS;
    userArgs.argLength = PROC_MAX_EXEC_ARGS * sizeof(Address);
    userArgs.envPtrArray = (char **) NIL;
    userArgs.numEnvs = 0;
    userArgs.envLength = 0;

    return DoExec(procPtr, execPath, &userArgs, TRUE, FALSE);
}


/*
 *----------------------------------------------------------------------
 *
 * SetupArgs --
 *
 *	Chase through arrays of character strings (usually in user space)
 *	and copy them into a contiguous array.  This array is later copied
 *	onto the stack of the exec'd program, and it may be used to
 *	pass the arguments to another host for a remote exec.  It
 *	contains argc, argv, envp, and the strings referenced by argv and
 *	envp.  All values in argv and envp are relative to the presumed
 *	start of the data in user space, which is normally set up to end at
 *	procMach_MaxUserStackAddr - 1.  If the exec is performed on a 
 *	different machine, the pointers in argv and envp must be adjusted
 *	by the relative values of procMach_MaxUserStackAddr.
 *
 *	The format of the structure is defined by ExecEncapState above.
 *		
 *
 * Results:
 *	A ReturnStatus is returned.  Any non-SUCCESS result indicates a failure
 *	that should be returned to the user.
 *	In addition, a pointer to the encapsulated stack is returned,
 *	as well as its size.  The caller is responsible for freeing the 
 *	encapsulated stack and the "ps" argument string.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
SetupArgs(userArgsPtr, extraArgArray, encapPtrPtr, argStringPtr)
    UserArgs *userArgsPtr;	/* Information for taking args
				 * and environment. */ 
    char     **extraArgArray;	/* Any arguments that should be
	     		 	 * inserted prior to argv[1] */
    ExecEncapState  **encapPtrPtr; /* OUT: the encapsulated stack. */
    char     **argStringPtr;	/* OUT: argument list as string (for ps) */
{
    int	     numArgs;		/* The number of arguments in the argArray. */
    int	     numEnvs;		/* The number of arguments in the envArray. */
    register	ArgListElement		*argListPtr;
    register	int			argNumber;
    char				**newArgPtrArray;
    char				**newEnvPtrArray;
    List_Links				argList;
    List_Links				envList;
    char				*argBuffer;
    char				*envBuffer;
    register	char			*argString;
    int					argStringLength;
    ReturnStatus			status;
    int		usp;		/* simulated user stack ptr; for copying 
				 * strings  */
    int					paddedArgLength;
    int					paddedEnvLength;
    int					bufSize;
    Address				buffer;
    int					stackSize;
    ExecEncapHeader			*hdrPtr;
    ExecEncapState			*encapPtr;
    Proc_ControlBlock			*procPtr; /* for debugging */
    Time startTime, endTime;	/* instrumentation */

    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }

    procPtr = (argDebug > 0 ? Proc_GetCurrentProc() : NULL);

    /*
     * Initialize variables so when if we abort we know what to clean up.
     */
    *argStringPtr = (char *) NIL;
    
    List_Init(&argList);
    List_Init(&envList);

    /*
     * Copy in the arguments.  argStringLength is an upper bound on
     * the total length permitted.
     */
    numArgs = userArgsPtr->numArgs;
    argStringLength = PROC_MAX_EXEC_ARG_LENGTH;
    status = GrabArgArray(PROC_MAX_EXEC_ARG_LENGTH + 1,
			  userArgsPtr->userMode, extraArgArray,
			  userArgsPtr->argPtrArray, &numArgs,
			  &argList, &argStringLength,
			  &paddedArgLength);

    if (status != SUCCESS) {
	goto execError;
    }

    /*
     * Copy in the environment.
     */
    numEnvs = userArgsPtr->numEnvs;
    status = GrabArgArray(PROC_MAX_ENVIRON_LENGTH + 1,
			  userArgsPtr->userMode, (char **) NIL,
			  userArgsPtr->envPtrArray, &numEnvs,
			  &envList, (int *) NIL,
			  &paddedEnvLength);

    if (status != SUCCESS) {
	goto execError;
    }

    /*
     * Now copy all of the arguments and environment variables into a buffer.
     * Allocate the buffer and initialize pointers into it.
     * The stack ends up in the following state:  the top word is argc.
     * Right below this is the array of pointers to arguments (argv).  Right
     * below this is the array of pointers to environment stuff (envp).  So,
     * to figure out the address of argv, one simply adds a word to the address
     * of the top of the stack.  To figure out the address of envp, one
     * looks at argc and skips over the appropriate amount of space to jump
     * over argc and argv = (1 + (argc + 1)) * sizeof(Address).  The extra
     * "1" is for the null argument at the end of argv.  Below all that
     * stuff on the stack come the environment and argument strings
     * themselves.
     */
    bufSize = sizeof(ExecEncapState)
	+ (numArgs + numEnvs + 2) * sizeof(Address)
	+ paddedArgLength + paddedEnvLength;
    buffer = ckalloc((unsigned)bufSize);
    encapPtr = (ExecEncapState *) buffer;
    *encapPtrPtr = encapPtr;
    hdrPtr = &encapPtr->hdr;
    hdrPtr->size = bufSize;
    hdrPtr->fileName = NULL;
    hdrPtr->fileNameLength = 0;
    hdrPtr->argString = NULL;
    hdrPtr->argLength = 0;
    stackSize = Byte_AlignAddr((bufSize - sizeof(ExecEncapHeader)));
    hdrPtr->base = procMach_MaxUserStackAddr - stackSize;
    if (argDebug > 0) {
	printf("pid %x: argc @@ 0x%x = %d\n", procPtr->processID,
	       hdrPtr->base, numArgs);
    }
    encapPtr->argc = numArgs;
    newArgPtrArray = (char **) (buffer + sizeof(ExecEncapState));
    newEnvPtrArray = (char **) ((int) newArgPtrArray +
				(numArgs + 1) * sizeof(Address));
    argBuffer = (Address) ((int) newEnvPtrArray +
			   (numEnvs + 1) * sizeof(Address));
    envBuffer =  (argBuffer + paddedArgLength);
				
    argNumber = 0;

    /* 
     * Make usp contain the user address of a string on the stack.
     */
    usp = (int)hdrPtr->base + (int) argBuffer - (int) &encapPtr->argc;

    /*
     * Create the buffer for the "ps" argument string. 
     */
    argString = ckalloc((unsigned)argStringLength + 1);
    *argStringPtr = argString;

    while (!List_IsEmpty(&argList)) {
	argListPtr = (ArgListElement *) List_First(&argList);
	/*
	 * Copy the argument to the stack and set the argv pointer.
	 */
	bcopy((Address) argListPtr->stringPtr, (Address) argBuffer,
		    argListPtr->stringLen);
	newArgPtrArray[argNumber] = (char *) usp;
	if (argDebug > 0) {
	    printf("pid %x: argv[%d] = 0x%x", procPtr->processID,
		   argNumber, usp);
	    if (argDebug > 1) {
		printf(" (%s)", argListPtr->stringPtr);
	    }
	    printf("\n");
	}
	argBuffer += Byte_AlignAddr(argListPtr->stringLen);
	usp += Byte_AlignAddr(argListPtr->stringLen);
	/* 
	 * Copy the argument to the "ps" argument string.
	 */
	bcopy((Address) argListPtr->stringPtr, argString,
		    argListPtr->stringLen - 1);
	argString[argListPtr->stringLen - 1] = ' ';
	argString += argListPtr->stringLen;
	/*
	 * Clean up
	 */
	List_Remove((List_Links *) argListPtr);
	ckfree((Address) argListPtr->stringPtr);
	ckfree((Address) argListPtr);
	argNumber++;
    }
    argString[0] = '\0';
    newArgPtrArray[argNumber] = (char *) USER_NIL;
    
    argNumber = 0;
    while (!List_IsEmpty(&envList)) {
	argListPtr = (ArgListElement *) List_First(&envList);
	/*
	 * Copy the environment variable.
	 */
	bcopy((Address) argListPtr->stringPtr, (Address) envBuffer,
		    argListPtr->stringLen);
	newEnvPtrArray[argNumber] = (char *) usp;
	if (argDebug > 0) {
	    printf("pid %x: envp[%d] = 0x%x", procPtr->processID,
		   argNumber, usp);
	    if (argDebug > 1) {
		printf(" (%s)", argListPtr->stringPtr);
	    }
	    printf("\n");
	}
	envBuffer += Byte_AlignAddr(argListPtr->stringLen);
	usp += Byte_AlignAddr(argListPtr->stringLen);
	/*
	 * Clean up
	 */
	List_Remove((List_Links *) argListPtr);
	ckfree((Address) argListPtr->stringPtr);
	ckfree((Address) argListPtr);
	argNumber++;
    }
    newEnvPtrArray[argNumber] = (char *) USER_NIL;

    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(endTime, setupArgsTime, &setupArgsTime);
    }

    /*
     * We're done here.  Leave it to the caller to free the copy of the
     * stack after copying it to user space.
     */
    return(SUCCESS);
    
execError:
    printf("SetupArgs failed: %s\n", Stat_GetMsg(status)); /* DEBUG */
    /*
     * The exec failed while copying in the arguments.  Free any
     * arguments or environment variables that were copied in.
     */
    while (!List_IsEmpty(&argList)) {
	argListPtr = (ArgListElement *) List_First(&argList);
	List_Remove((List_Links *) argListPtr);
	ckfree((Address) argListPtr->stringPtr);
	ckfree((Address) argListPtr);
    }
    while (!List_IsEmpty(&envList)) {
	argListPtr = (ArgListElement *) List_First(&envList);
	List_Remove((List_Links *) argListPtr);
	ckfree((Address) argListPtr->stringPtr);
	ckfree((Address) argListPtr);
    }
    return(status);

}


/*
 *----------------------------------------------------------------------
 *
 * GrabArgArray --
 *
 *	Copy a an array of strings from user space and put it in a
 *	linked list of strings.  The terminology for "args" refers
 *	to argv, but the same routine is used for environment variables
 *	as well.
 *
 * Results:
 *	A ReturnStatus indicates any sort of error, indicating immediate
 *	failure that should be reported to the user.  Otherwise, the
 *	arguments and their lengths are returned in the linked list
 *	referred to by argListPtr, and the total length is returned
 *	in *totalLengthPtr.
 *
 * Side effects:
 *	Memory is allocated to hold the strings and the structures
 *	pointing to them.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
GrabArgArray(maxLength, userProc, extraArgArray, argPtrArray, numArgsPtr,
	     argList, realLengthPtr, paddedLengthPtr)
    int	     maxLength;		/* The maximum length of one argument */
    Boolean  userProc;		/* Set if the calling process is a user 
	     			 * process. */
    char     **extraArgArray;	/* Any arguments that should be
	     		 	 * inserted prior to argv[1] */
    char     **argPtrArray;	/* The array of argument pointers. */
    int	     *numArgsPtr;	/* Pointer to the number of arguments in the
				 * argArray. This is updated with the
				 * actual number of arguments. */
    List_Links *argList;	/* Pointer to header of list containing
				 * copied data. Assumed to be initialized by
				 * caller. */
    int      *realLengthPtr; 	/* Pointer to contain combined size, without
				 * padding.   Value passed in contains
				 * maximum. */
    int      *paddedLengthPtr; 	/* Pointer to contain combined size, including
				 * padding. */
{
    int 				totalLength = 0;
    int 				paddedTotalLength = 0;
    int 				extraArgs;
    register	ArgListElement		*argListPtr;
    register	char	**argPtr; /* element of argPtrArray */
    register	int	argNumber;
    ReturnStatus	status = SUCCESS;
    char		*stringPtr = NULL; /* single string when building 
					    * array */
    int			stringLength; /* length of string that stringPtr
				       * refers to, including trailing null */
    int			mappedLength = 0; /* length of region returned by 
					   * Vm_MakeAccessible */ 
    Time startTime, endTime;	/* instrumentation */
    Time startAccessTime, endAccessTime; /* instrumentation */
    
    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }

    /* 
     * Count up the number of extra arguments to stick at the front of the 
     * list. 
     */
    if (extraArgArray != (char **) NIL) {
	for (extraArgs = 0; extraArgArray[extraArgs] != (char *)NIL;
	     extraArgs++) {
	}
    } else {
	extraArgs = 0;
    }
    *numArgsPtr += extraArgs;

    for (argNumber = 0, argPtr = argPtrArray; 
	 argNumber < *numArgsPtr;
	 argNumber++) {

	/* 
	 * Make stringPtr and stringLength refer to the next string to put 
	 * into the array.
	 */
	
	if ((argNumber > 0 || argPtrArray == (char **) NIL) && extraArgs > 0) {
	    stringPtr = extraArgArray[0];
	    stringLength = strlen(stringPtr) + 1;
	    extraArgArray++;
	    extraArgs--;
	} else {
	    if (!userProc) {
		if (*argPtr == (char *) NIL) {
		    break;
		}
		stringPtr = *argPtr;
		stringLength = strlen(stringPtr) + 1;
	    } else {
		if (*argPtr == (char *) USER_NIL) {
		    break;
		}

		if (sys_CallProfiling) {
		    Timer_GetTimeOfDay(&startAccessTime, (int *)NULL,
				       (Boolean *)NULL);
		} else {
		    startAccessTime = time_ZeroSeconds;
		}
		Vm_MakeAccessible(VM_READONLY_ACCESS, maxLength, *argPtr,
				  &mappedLength, &stringPtr);
		if (sys_CallProfiling && !Time_EQ(startAccessTime,
						  time_ZeroSeconds)) {
		    Timer_GetTimeOfDay(&endAccessTime, (int *)NULL,
				       (Boolean *)NULL);
		    Time_Subtract(endAccessTime, startAccessTime,
				  &endAccessTime);
		    Time_Add(endAccessTime, argsAccessTime, &argsAccessTime);
		}

		if (stringPtr == NULL) {
		    if (argDebug > 1) {
			printf("GrabArgArray: couldn't map string at 0x%x\n",
			       *argPtr);
		    }
		    status = SYS_ARG_NOACCESS;
		    goto bailOut;
		}
		stringLength = strlen(stringPtr) + 1;
		numStrings++;	/* DEBUG */
		if (stringBytes + stringLength < stringBytes) {
		    printf("GrabArgArray: string length overflow.\n");
		}
		stringBytes += stringLength; /* DEBUG */
	    }
	    /*
	     * Move to the next argument.
	     */
	    argPtr++;
	}
	
	/*
	 * Put this string onto the argument list.
	 */
	argListPtr = (ArgListElement *)ckalloc(sizeof(ArgListElement));
	argListPtr->stringPtr = ckalloc((unsigned)stringLength);
	argListPtr->stringLen = stringLength;
	List_InitElement((List_Links *) argListPtr);
	List_Insert((List_Links *) argListPtr, LIST_ATREAR(argList));

	/*
	 * Calculate the room on the stack needed for this string.
	 * Make it double-word aligned to make access efficient on
	 * all machines.  Increment the amount needed to save the argument
	 * list (the same total length, but without the padding).
	 */
	paddedTotalLength += Byte_AlignAddr(stringLength);
	totalLength += stringLength;
	bcopy((Address) stringPtr, (Address) argListPtr->stringPtr,
	      stringLength);

	/* 
	 * Deallocate the original string if we had to get it from user 
	 * space. 
	 */
	if (mappedLength != 0) {
	    Vm_MakeUnaccessible(stringPtr, mappedLength);
	    mappedLength = 0;
	}
    }
    
    
    if (realLengthPtr != (int *) NIL) {
	if (totalLength > *realLengthPtr) {
	    /*
	     * Would really like to flag "argument too long" here.
	     * Also, should we check after every argument?
	     */
	    status = GEN_INVALID_ARG;
	    goto bailOut;
	}
	*realLengthPtr = totalLength;
    }
    if (paddedLengthPtr != (int *) NIL) {
	*paddedLengthPtr = paddedTotalLength;
    }
    *numArgsPtr = argNumber;
    
 bailOut:
    if (status != SUCCESS) {
	/*
	 * We hit an error while copying in the arguments.  Free any
	 * arguments that were copied in.
	 */
	while (!List_IsEmpty(argList)) {
	    argListPtr = (ArgListElement *) List_First(argList);
	    List_Remove((List_Links *) argListPtr);
	    ckfree((Address) argListPtr->stringPtr);
	    ckfree((Address) argListPtr);
	}
    }

    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(endTime, grabArgsTime, &grabArgsTime);
    }

    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * DoExec --
 *
 *	Set up a user process with a binary.  Flushes the old VM for the
 *	process, copies in the executable, and sets the thread state.
 *
 * Results:
 *	status code.
 *
 * Side effects:
 *	The UserArgs arrays are freed if the flag is set saying that they
 *	were copied in from user space.  If successful and the exec was for 
 *	a user request, sets the PROC_NEEDS_WAKEUP flag.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
DoExec(procPtr, execPath, userArgsPtr, kernExec, debugMe)
    Proc_ControlBlock *procPtr;	/* process to set up */
    char *execPath;		/* path to program to run */
    UserArgs *userArgsPtr;	/* Information for taking args
				 * and environment, or NIL. */
    Boolean kernExec;		/* doing (initial) exec on behalf of 
				 * "kernel" process */
    Boolean	debugMe;	/* TRUE means that the process is to be 
				 * sent a SIG_DEBUG signal before
    				 * executing its first instruction. */
{
    Fs_Stream *filePtr = NULL;		/* the program to run */
    Proc_ObjInfo execInfo;		/* a.out header information */
    char *argStringSave = NULL;		/* the process's current arg string */
    char *argString = NULL;		/* the process's new arg string */
    Vm_Segment *codeSegPtr = NULL;	/* new code segment */
    ExecEncapState *encapPtr = NULL;	/* stack information & contents */
    int uid = -1;			/* user ID to use; -1 if not setuid */
    int gid = -1;			/* group ID to use; -1 if not setgid */
    Boolean noReturn = FALSE;		/* can't do an error return 'cuz the 
					 * process has been trashed */
    Time startTime, endTime;		/* instrumentation */
    Time pointATime, pointBTime; /* and more */
    ReturnStatus status = SUCCESS;
    kern_return_t kernStatus;

    /* Return through "execError", so that cleanup happens. */

#ifdef SPRITED_PROFILING
    /* Turn off profiling */
    if (procPtr->Prof_Scale != 0) {
	Prof_Disable(procPtr);
    }
#endif

    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, NULL, NULL);
    } else {
	startTime = time_ZeroSeconds;
    }

    /*
     * Save the argString away, because if we hit an error we always
     * set procPtr->argString back to this value.  We could nil out the 
     * string pointer in the PCB, which would simplify management of the 
     * strings.  However, this would reduce the amount of information 
     * available via ps or (in case of trouble) the debugger.
     */
    argStringSave = procPtr->argString;

    /*
     * Open the file that is to be exec'd.  Check for setuid or setgid.
     */
    status = Fs_Open(execPath, FS_EXECUTE | FS_FOLLOW, FS_FILE, 0,
		     &filePtr);
    if (status != SUCCESS) {
	goto execError;
    }
    Fs_CheckSetID(filePtr, &uid, &gid);

    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&pointATime, (int *)NULL, (Boolean *)NULL);
    }

    /* 
     * Get the right code segment to exec, possibly an interpreter (if the 
     * named file was a script).
     */
    status = SetupCode(execPath, userArgsPtr, &filePtr, &codeSegPtr,
		       &execInfo, &encapPtr, &argString);
    if (status != SUCCESS) {
	goto execError;
    }

    /* 
     * The initial user process doesn't have an FS state yet, so don't 
     * bother trying to close "close-on-exec" files.
     */
    if (!kernExec) {
	Fs_CloseOnExec((Proc_ControlBlock *)procPtr);
    }

    /*
     * Change the argument string and pass ownership off to the PCB.
     */
    procPtr->argString = argString;
    argString = NULL;
    /*
     * Do set uid here.  This way, the uid will be set before a remote
     * exec.
     */
    if (uid != -1) {
	procPtr->effectiveUserID = uid;
    }

    /* 
     * This is the point of no return.  Start doing operations that can't 
     * be backed out.  Note: we also use noReturn as a flag that the 
     * process is locked (XXX).
     */
    
    noReturn = TRUE;
    Proc_Lock(procPtr);

    /* 
     * In the normal case the user process is sitting in mach_msg, waiting
     * for a reply.  Freeze it and abort the RPC.  When the exec has
     * completed and we've reset the process's state, we can unfreeze the 
     * process.  
     * 
     * Note that this needs to be done before calling SetupVM.  When we did 
     * it after SetupVM, we were getting on sun3's an EXC_EMULATION message
     * before we could resume the user process.
     */
    if (!kernExec) {
	kernStatus = thread_suspend(procPtr->thread);
	if (kernStatus != KERN_SUCCESS) {
	    printf("DoExec: couldn't suspend thread: %s\n",
		   mach_error_string(kernStatus));
	    goto execError;
	}
	kernStatus = thread_abort(procPtr->thread);
	if (kernStatus != KERN_SUCCESS) {
	    printf("DoExec: couldn't abort thread: %s\n",
		   mach_error_string(kernStatus));
	    goto execError;
	}
    }

    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&pointBTime, (int *)NULL, (Boolean *)NULL);
    }

    /* 
     * Set up virtual memory and machine registers.  If there are any 
     * problems in this section the user process is trashed badly enough 
     * that there's nothing left to return to.
     */
    status = SetupVM(Proc_AssertLocked(procPtr), codeSegPtr, &execInfo,
		     encapPtr);
    if (status != SUCCESS) {
	goto execError;
    }
    status = ProcMachSetRegisters(procPtr, encapPtr->hdr.base,
				  execInfo.entry);
    if (status != SUCCESS) {
	goto execError;
    }
    if (!kernExec) {
	procPtr->genFlags |= PROC_NEEDS_WAKEUP;
    }

    /* 
     * This is now past the point of no return, but we still need the pcb 
     * locked.  Fortunately, there are no error exits in the next set of 
     * calls, so it's okay to leave noReturn TRUE until we unlock the pcb.
     */

    /*
     * Set-gid only needs to be done on the host running the process.
     */
    if (gid != -1) {
	ProcAddToGroupList(Proc_AssertLocked(procPtr), gid);
    }

    /*
     * Take signal actions for execed process.
     */
    Sig_Exec(Proc_AssertLocked(procPtr));
    if (debugMe) {
	/*
	 * Debugged processes get a SIG_DEBUG at start up.
	 */
	(void)Sig_SendProc(Proc_AssertLocked(procPtr), SIG_DEBUG, FALSE,
			   SIG_NO_CODE, (Address)0);
    }

    noReturn = FALSE;
    Proc_Unlock(Proc_AssertLocked(procPtr));

 execError:
    /* 
     * If there's an error starting up a user process from a kernel thread,
     * let the caller take care of cleaning up.  We might be able to do the
     * kill here, but only if we turn off the paranoia check in
     * Proc_SetState.
     * 
     * Note that we don't just exit right here, because we need to free up 
     * the request/reply buffers from the MIG request (not to mention all 
     * the other resources obtained in this function).
     */
    if (status != SUCCESS && noReturn && !kernExec) {
	printf("DoExec killing process %x: failed exec: %s\n",
	       procPtr->processID, Stat_GetMsg(status));
	(void)Sig_SendProc(Proc_AssertLocked(procPtr), SIG_KILL, TRUE,
			   PROC_EXEC_FAILED, (Address)0);
    }
    if (noReturn) {
	Proc_Unlock(Proc_AssertLocked(procPtr));
	noReturn = FALSE;
    }
    if (filePtr != NULL) {
	(void)Fs_Close(filePtr);
    }
    if (codeSegPtr != NULL) {
	Vm_SegmentRelease(codeSegPtr);
    }
    if (encapPtr != NULL) {
	ckfree(encapPtr);
    }
    if (status == SUCCESS) {
	if (argStringSave != NULL) {
	    ckfree(argStringSave);
	    argStringSave = NULL;
	}
    } else {
	if (argString != NULL) {
	    ckfree(argString);
	    argString = NULL;
	}
	/* 
	 * Back out the arg string, being careful that the pcb's copy is 
	 * never garbage.
	 */
	if (procPtr->argString != argStringSave) {
	    char *newString = procPtr->argString;
	    procPtr->argString = argStringSave;
	    ckfree(newString);
	}
	argStringSave = NULL;
    }
    if (userArgsPtr != (UserArgs *) NIL && userArgsPtr->userMode) {
	if (userArgsPtr->argPtrArray != (char **) NIL) {
	    Vm_MakeUnaccessible((Address) userArgsPtr->argPtrArray,
				userArgsPtr->argLength);
	    userArgsPtr->argPtrArray = (char **)NIL;
	    userArgsPtr->argLength = 0;
	}
	if (userArgsPtr->envPtrArray != (char **) NIL) {
	    Vm_MakeUnaccessible((Address) userArgsPtr->envPtrArray,
				userArgsPtr->envLength);
	    userArgsPtr->envPtrArray = (char **)NIL;
	    userArgsPtr->envLength = 0;
	}
    }

    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, NULL, NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(doExecTime, endTime, &doExecTime);
	Time_Subtract(pointATime, startTime, &pointATime);
	Time_Add(partATime, pointATime, &partATime);
	Time_Subtract(pointBTime, startTime, &pointBTime);
	Time_Add(partBTime, pointBTime, &partBTime);
    }

    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * SetupCode --
 *
 *	Get a code segment to exec.  Do whatever changes are necessary if 
 *	the program is an interpreted script.
 *
 * Results:
 *	Returns a status code.  If the named program is a script, the file
 *	pointer is changed to refer to the interpreter.  If the return
 *	status is SUCCESS, fills in the code segment, the object file
 *	information for the actual program to execute, the strings to put
 *	on the stack for the program (arguments and environment), and
 *	creates a string suitable for storing in the PCB (e.g., for the ps
 *	command).  The caller is responsible for freeing the string array
 *	(one big buffer) and the "ps" string.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
SetupCode(execName, userArgsPtr, filePtrPtr, codeSegPtrPtr, execInfoPtr,
	  encapPtrPtr, argStringPtr)
    char *execName;		/* name of the file given to Exec */
    UserArgs *userArgsPtr;	/* user arguments & env., possibly NIL */
    Fs_Stream **filePtrPtr;	/* IN: stream for execName; OUT: either the 
				 * same stream, or a stream for an 
				 * interpreter */
    Vm_Segment **codeSegPtrPtr;	/* OUT: code segment for final stream */
    Proc_ObjInfo *execInfoPtr;	/* OUT: a.out info for final stream */
    ExecEncapState **encapPtrPtr; /* OUT: stuff to copy to process's stack,
				   * including the program's argument  */
    char **argStringPtr;	/* OUT: argument string for ps */
{
    ReturnStatus status;
    Fs_Stream *filePtr;		/* local copy of file handle; this is the
				 * file that actually gets loaded */
    int sizeRead;		/* bytes to read from file */
    char *buffer = NULL;	/* buffer to hold first bit of file */
    Boolean interpreted = FALSE; /* is the program actually a script */
    char interpName[FS_MAX_PATH_NAME_LENGTH]; /* name of interpreter, if any */
    char *interpFlags;		/* if a script, arguments (usually flags) to
				 * pass to the interpreter */ 
    char *interpArgs[MAX_INTERP_ARGS]; /* actual arguments to pass to 
					* interpreter  */
    Time startTime, endTime;	/* instrumentation */

    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }

    filePtr = *filePtrPtr;
    status = Vm_GetCodeSegment(filePtr, execName, (Proc_ObjInfo *)NULL,
			       TRUE, codeSegPtrPtr);
    if (status == SUCCESS) {
	bcopy((Address)((*codeSegPtrPtr)->typeInfo.codeInfo.execInfoPtr),
	      (Address)execInfoPtr, sizeof(Proc_ObjInfo));
    } else if (status == VM_SEG_NOT_FOUND) {
	/*
	 * We don't already have a segment for the given file.  Read the 
	 * file header, to see if it's an interpreter script.
	 */
	sizeRead = PROC_MAX_INTERPRET_SIZE;
	if (sizeRead < sizeof(ProcExecHeader)) {
	    sizeRead = sizeof(ProcExecHeader);
	}
	buffer = ckalloc((unsigned)sizeRead);
	if (buffer == NULL) {
	    panic("SetupCode: out of memory.\n");
	}
	status = Fs_Read(filePtr, buffer, 0, &sizeRead);
	if (status != SUCCESS) {
	    goto execError;
	}
	if (sizeRead >= 2 && buffer[0] == '#' && buffer[1] == '!') {
	    /* 
	     * It's definitely not a regular object file, so get rid of it 
	     * right now.
	     */
	    (void)Fs_Close(filePtr);
	    filePtr = NULL;
	    /*
	     * See if this is an interpreter script.
	     */
	    status = SetupInterpret(buffer, sizeRead, &filePtr, interpName,
				    &interpFlags, execInfoPtr); 
	    if (status != SUCCESS) {
		goto execError;
	    }
	    interpreted = TRUE;
	    status = Vm_GetCodeSegment(filePtr, interpName, execInfoPtr,
				       FALSE, codeSegPtrPtr);
	} else if (sizeRead < sizeof(ProcExecHeader)) {
	    status = PROC_BAD_AOUT_FORMAT;
	} else {
	    status = ProcGetObjInfo(filePtr, (ProcExecHeader *)buffer,
				    execInfoPtr);
	    if (status != SUCCESS) {
		/*
		 * XXX Native Sprite tries to give a useful diagnostic in
		 * case the object file has a recognizable but wrong object
		 * format.  We should do the same.
		 */
		goto execError;
	    }
	    status = Vm_GetCodeSegment(filePtr, execName, execInfoPtr,
				       FALSE, codeSegPtrPtr);
	}
    }
    if (status != SUCCESS) {
	goto execError;
    }

    /*
     * Set up whatever special arguments we might have due to an
     * interpreter file.
     */
    if (interpreted) {
	int index = 0;		/* index into array of interpreter args */
	
	if (userArgsPtr->argPtrArray == (char **) NIL) {
	    interpArgs[index] = execName;
	    ++index;
	}
	if (interpFlags != NULL) {
	    interpArgs[index] = interpFlags;
	    ++index;
	}
	interpArgs[index] = execName;
	++index;
	interpArgs[index] = (char *) NIL;
	if (index >= MAX_INTERP_ARGS) {
	    panic("SetupCode: need bigger array for interpreter arguments.\n");
	}
    }
    /*
     * Copy in the argument list and environment into a single contiguous
     * buffer.
     */
    status = SetupArgs(userArgsPtr, (interpreted ? interpArgs : (char **)NIL),
		       encapPtrPtr, argStringPtr);
    if (status != SUCCESS) {
	goto execError;
    }

    /*
     * We no longer need access to the old arguments or the environment. 
     */
    if (userArgsPtr->userMode) {
	if (userArgsPtr->argPtrArray != (char **) NIL) {
	    Vm_MakeUnaccessible((Address) userArgsPtr->argPtrArray,
				userArgsPtr->argLength);
	    userArgsPtr->argPtrArray = (char **)NIL;
	    userArgsPtr->argLength = 0;
	}
	if (userArgsPtr->envPtrArray != (char **) NIL) {
	    Vm_MakeUnaccessible((Address) userArgsPtr->envPtrArray,
				userArgsPtr->envLength);
	    userArgsPtr->envPtrArray = (char **)NIL;
	    userArgsPtr->envLength = 0;
	}
    }

 execError:
    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(endTime, setupCodeTime, &setupCodeTime);
    }

    *filePtrPtr = filePtr;
    if (buffer != NULL) {
	ckfree(buffer);
    }
    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * SetupVM --
 *
 *	Set up the virtual memory for the process.  The process's VM is 
 *	cleared, and new mappings are made for code, heap, stack, etc.
 *
 * Results:
 *	Returns a status code.
 *
 * Side effects:
 *	Make additional private references to the code segment, as necessary.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
SetupVM(procPtr, codeSegPtr, execInfoPtr, encapPtr)
    Proc_LockedPCB *procPtr;
    Vm_Segment *codeSegPtr;	/* the code segment to use */
    Proc_ObjInfo *execInfoPtr;	/* layout of the program */
    ExecEncapState *encapPtr;	/* encapsulated exec info with initial stack 
				 * contents */
{
    ReturnStatus status;
    Time startTime, endTime;	/* instrumentation */

    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }

    /* 
     * Do some instrumentation on the heap and stack, then clear out the 
     * user process's address space.
     */
    InstrumentSwapSegments(procPtr, execInfoPtr);
    Vm_ReleaseMappedSegments(procPtr);
    (void)vm_deallocate(procPtr->pcb.taskInfoPtr->task, VM_MIN_ADDRESS,
			(vm_size_t)(VM_MAX_ADDRESS - VM_MIN_ADDRESS));

    status = DoCode(procPtr, execInfoPtr, codeSegPtr);
    if (status != SUCCESS) {
	printf("SetupVM: Can't set up text: %s\n", Stat_GetMsg(status));
	goto done;
    }
    status = DoHeap(procPtr, execInfoPtr, codeSegPtr->swapFilePtr,
		    codeSegPtr->swapFileName);
    if (status != SUCCESS) {
	printf("SetupVM: Can't set up heap: %s\n", Stat_GetMsg(status));
	status = VM_SWAP_ERROR;
	goto done;
    }
    status = DoStack(procPtr, execInfoPtr, encapPtr);
    if (status != SUCCESS) {
	printf("SetupVM: Can't set up stack: %s\n", Stat_GetMsg(status));
	status = VM_SWAP_ERROR;
	goto done;
    }

    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(endTime, setupVmTime, &setupVmTime);
    }

 done:
    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * DoCode --
 *
 *	Set up the text part of the child process, by mapping the code 
 *	segment into the process's address space.
 *
 * Results:
 *	Sprite status code.  
 *
 * Side effects:
 *	Creates a private reference to the code segment if successful.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
DoCode(procPtr, execInfoPtr, codeSegPtr)
    Proc_LockedPCB *procPtr;	/* the locked process to set up */
    Proc_ObjInfo *execInfoPtr;	/* where to find things in the file */
    Vm_Segment *codeSegPtr;	/* the code segment to use */
{
    kern_return_t kernStatus;
    Address textStart;		/* start of text region in user VM */
    ReturnStatus status = SUCCESS;
    Time startTime, endTime;	/* instrumentation */

    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }

    textStart = execInfoPtr->codeLoadAddr;
    Vm_SegmentAddRef(codeSegPtr);

    /* 
     * XXX Should allow for object files that don't have page-aligned 
     * sections. 
     */
    if (textStart != Vm_TruncPage(textStart)) {
	status = PROC_BAD_AOUT_FORMAT;
	goto done;
    }
    kernStatus = Vm_MapSegment(procPtr, codeSegPtr, TRUE, FALSE,
			       (vm_offset_t)execInfoPtr->codeFileOffset,
			       (vm_size_t)execInfoPtr->codeSize,
			       &textStart, &status);
    if (kernStatus != KERN_SUCCESS) {
	status = Utils_MapMachStatus(kernStatus);
    }
    if (textStart != execInfoPtr->codeLoadAddr) {
	/* 
	 * XXX Really should set an error status and deallocate the 
	 * region. 
	 */
	panic("DoCode: Didn't get requested text address.\n");
    }

 done:
    if (status != SUCCESS) {
	Vm_SegmentRelease(codeSegPtr);
    }
    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(endTime, doCodeTime, &doCodeTime);
    }
    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * DoHeap --
 *
 *	Set up the heap part of the child process.
 *
 * Results:
 *	status code.
 *
 * Side effects:
 * 	Creates a swap segment for the heap.  Maps the segment into 
 * 	the process's address space.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
DoHeap(procPtr, execInfoPtr, objFilePtr, objFileName)
    Proc_LockedPCB *procPtr;	/* the locked process to set up */
    Proc_ObjInfo *execInfoPtr;	/* where to find things in the file */
    Fs_Stream *objFilePtr;	/* the object file */
    char *objFileName;		/* and its name */
{
    kern_return_t kernStatus;
    Address heapStart;		/* start of heap region in user VM */
    vm_size_t heapSize;		/* bytes in heap segment */
    vm_size_t heapMappedSize;	/* initial number of bytes actually mapped */
    ReturnStatus status = SUCCESS;
    Vm_Segment *segPtr = NULL;	/* the heap segment */
    Time startTime, endTime;	/* instrumentation */

    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }

    /* 
     * Verify that the program is laid out like we expect, with 
     * initialized data coming before uninitialized data.
     */
    if (execInfoPtr->heapLoadAddr > execInfoPtr->bssLoadAddr) {
	printf("Can't deal with heap (0x%x) above bss (0x%x)\n",
	       execInfoPtr->heapLoadAddr, execInfoPtr->bssLoadAddr);
	return PROC_BAD_AOUT_FORMAT;
    }

    /* 
     * Make the swap file big enough to consume all of the remaining 
     * memory.  Of course, most of the segment will never get mapped.
     */
    heapStart = HeapStart(execInfoPtr);
    if (heapStart != Vm_TruncPage(heapStart)) {
	printf("DoHeap: heap segment isn't page aligned.\n");
	return PROC_BAD_AOUT_FORMAT;
    }
    /* 
     * The paging code assumes that each page resides entirely in the 
     * object file or in the swap file.  If we want to remove this 
     * restriction, we have to fix the paging code to zero-fill the 
     * portion of the last page that's not in the object file.
     */
    if (execInfoPtr->heapSize != trunc_page(execInfoPtr->heapSize)) {
	printf("DoHeap: heap segment contains fraction of page.\n");
	return PROC_BAD_AOUT_FORMAT;
    }

    /* 
     * From here on, return through "bailOut", so that the segment 
     * gets cleaned up correctly.
     */

    heapSize = procMach_MaxUserStackAddr - heapStart;
    status = Vm_GetSwapSegment(VM_HEAP, heapSize, &segPtr);
    if (status != SUCCESS) {
	goto bailOut;
    }
    Vm_AddHeapInfo(segPtr, objFilePtr, objFileName, execInfoPtr);

    heapMappedSize = (int)Vm_RoundPage(execInfoPtr->bssLoadAddr -
				       execInfoPtr->heapLoadAddr +
				       execInfoPtr->bssSize);
    kernStatus = Vm_MapSegment(procPtr, segPtr, FALSE, FALSE, (vm_offset_t)0,
			       heapMappedSize, &heapStart, &status);
    if (kernStatus != KERN_SUCCESS) {
	printf("DoHeap: couldn't map heap segment: %s\n",
	       mach_error_string(kernStatus));
	status = Utils_MapMachStatus(kernStatus);
    }
    if (heapStart != execInfoPtr->heapLoadAddr) {
	/* 
	 * XXX Really should set an error status and deallocate the 
	 * region. 
	 */
	panic("DoHeap: Didn't get requested start address.\n");
    }

 bailOut:
    if (status != SUCCESS && segPtr != NULL) {
	Vm_SegmentRelease(segPtr);
    }
    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(endTime, doHeapTime, &doHeapTime);
    }
    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * DoStack --
 *
 *	Set up the stack part of the child process.  Creates a segment for
 *	the stack and maps it into the process's address space.
 *
 * Results:
 *	Returns a status code.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
DoStack(procPtr, execInfoPtr, encapPtr)
    Proc_LockedPCB *procPtr;	/* the locked process to set up */
    Proc_ObjInfo *execInfoPtr;	/* info about how to lay out the binary */
    ExecEncapState *encapPtr;	/* arguments to put on stack & other info */
{
    kern_return_t kernStatus;
    ReturnStatus status = SUCCESS;
    vm_size_t stackSize;	/* number of bytes allowed for stack */
    Address firstPageToMap;	/* address of first stack page to map */
    Address firstPageMapped;	/* address of page actually mapped */
    vm_size_t bytesToMap;	/* number of stack bytes to map initially */
    Address stackStart = 0;	/* where stack would start in memory, if 
				 * we let it get that big */
    Vm_Segment *segPtr = NULL;	/* the stack segment */
    Time startTime, endTime;	/* instrumentation */
    Time startCopyTime, endCopyTime; /* more instrumentation */

    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }

    if (!PROCMACH_STACK_GROWS_DOWN) {
	/* 
	 * Need to fix the low-end address for the stack, rather than 
	 * letting it grown down.
	 */
	panic("DoStack: can't handle stacks that grow up.\n");
    }

    /* 
     * Verify that the program is laid out like we expect it, 
     * with uninitialized data coming after code and initialized data.
     */
    if (execInfoPtr->codeLoadAddr > execInfoPtr->bssLoadAddr ||
		execInfoPtr->heapLoadAddr > execInfoPtr->bssLoadAddr) {
	printf("DoStack: unexpected program layout.\n");
	status = PROC_BAD_AOUT_FORMAT;
	goto done;
    }

    stackStart = StackStart(execInfoPtr);
    stackSize = procMach_MaxUserStackAddr - stackStart;
    status = Vm_GetSwapSegment(VM_STACK, stackSize, &segPtr);
    if (status != SUCCESS) {
	goto done;
    }
    segPtr->typeInfo.stackInfo.baseAddr = stackStart;

    /* 
     * Map as many pages as are needed for the initial stack Setup 
     * (arguments, environment).
     */
    bytesToMap = round_page(encapPtr->hdr.size - sizeof(ExecEncapHeader));
    firstPageToMap = procMach_MaxUserStackAddr - bytesToMap;
    firstPageMapped = firstPageToMap;
    kernStatus = Vm_MapSegment(procPtr, segPtr, FALSE, FALSE,
			       (vm_offset_t)(firstPageToMap - stackStart),
			       bytesToMap, &firstPageMapped, &status);
    if (kernStatus != KERN_SUCCESS) {
	status = Utils_MapMachStatus(kernStatus);
    }
    if (status == SUCCESS && firstPageMapped != firstPageToMap) {
	panic("DoStack: didn't get requested stack address.\n");
    }
    if (status != SUCCESS) {
	goto done;
    }

    /* 
     * Copy the arguments and environment to the stack.
     */
    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startCopyTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startCopyTime = time_ZeroSeconds;
    }
    status = Vm_CopyOutProc(encapPtr->hdr.size - sizeof(ExecEncapHeader),
			    (Address)&encapPtr->argc, TRUE, procPtr,
			    (Address)encapPtr->hdr.base);
    if (status != SUCCESS) {
	panic("DoStack: couldn't copy arguments to user process: %s\n",
	      Stat_GetMsg(status));
    }
    if (sys_CallProfiling && !Time_EQ(startCopyTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endCopyTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endCopyTime, startCopyTime, &endCopyTime);
	Time_Add(endCopyTime, stackCopyOutTime, &stackCopyOutTime);
    }

 done:
    if (status != SUCCESS && segPtr != NULL) {
	Vm_SegmentRelease(segPtr);
	segPtr = NULL;
    }
    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(endTime, doStackTime, &doStackTime);
    }
    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * SetupInterpret --
 *
 *	Read in the interpreter name, arguments and object file header.
 *
 * Results:
 *	Error if for some reason could not parse the interpreter name and
 *	arguments, or could not open the interpreter object file.  If
 *	successful, fills in the stream for the interpreter object file 
 *	(which the caller is responsible for closing); fills in the name of 
 *	the interpreter; fills in the argument string to pass to the
 *	interpreter; fills in object file information for the interpreter.
 *	Non-NULL string pointers point into the given buffer.
 *
 * Side effects:
 *	Puts some nulls into the given buffer to separate out strings. 
 *
 *----------------------------------------------------------------------
 */ 

static ReturnStatus
SetupInterpret(buffer, sizeRead, interpPtrPtr, interpName, argStringPtr, 
	       objInfoPtr)
    register char *buffer;	/* Bytes read in from start of file */
    int sizeRead;		/* Number of bytes in buffer. */
    register Fs_Stream **interpPtrPtr; /* OUT: interpreter file */
    char *interpName;		/* MAXPATHLEN buffer to hold the name of 
				 * the interpreter file */
    char **argStringPtr;	/* OUT: single argument string to pass to 
				 * interpreter, possibly NULL */
    Proc_ObjInfo *objInfoPtr;	/* OUT: a.out info for the interpreter */
{
    register	char	*strPtr;
    int			i;
    ReturnStatus	status;
    ProcExecHeader	execHeader;
    char *		givenInterpName; /* interpreter name from script */

    /*
     * Make sure the interpreter name and arguments are terminated by a 
     * carriage return, and make sure there's no garbage in the file.
     */

    for (i = 2, strPtr = &(buffer[2]);
	     i < sizeRead && *strPtr != '\n';
	     i++, strPtr++) {
	if (!isascii(*strPtr)) {
	    return PROC_BAD_FILE_NAME;
	}
    }
    if (i == sizeRead) {
	return(PROC_BAD_FILE_NAME);
    }
    *strPtr = '\0';

    /*
     * Get the name of the interpreter from the script.  
     */
    
    for (strPtr = &(buffer[2]); isspace(*strPtr); strPtr++) {
    }
    if (*strPtr == '\0') {
	return(PROC_BAD_FILE_NAME);
    }
    givenInterpName = strPtr;
    while (!isspace(*strPtr) && *strPtr != '\0') {
	strPtr++;
    }

    /*
     * Terminate the interpreter name, and get a pointer to the arguments 
     * if there are any. 
     */
    
    *argStringPtr = NULL;

    if (*strPtr != '\0') {
	*strPtr = '\0';
	strPtr++;
	while (isspace(*strPtr)) {
	    strPtr++;
	}
	if (*strPtr != '\0') {
	    *argStringPtr = strPtr;
	}
    }

    strcpy(interpName, givenInterpName);

    /*
     * Open the interpreter to exec and read the a.out header.
     */

    status = Fs_Open(interpName, FS_EXECUTE | FS_FOLLOW, FS_FILE, 0,
		     interpPtrPtr);
    if (status != SUCCESS) {
	return(status);
    }

    sizeRead = sizeof(ProcExecHeader);
    status = Fs_Read(*interpPtrPtr, (Address)&execHeader, 0, &sizeRead);
    if (status == SUCCESS && sizeRead != sizeof(ProcExecHeader)) {
	status = PROC_BAD_AOUT_FORMAT;
    } else {
	status = ProcGetObjInfo(*interpPtrPtr, &execHeader, objInfoPtr);
    }
    if (status != SUCCESS) {
	/*
	 * XXX Native Sprite tries to give a useful diagnostic in
	 * case the object file has a recognizable but wrong object
	 * format.  We should do the same.
	 */
	(void)Fs_Close(*interpPtrPtr);
	*interpPtrPtr = NULL;
    }

    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * InstrumentSwapSegments --
 *
 *	Check whether the process's current heap and stack could simply be 
 *	reused in an exec().  Also, record the current heap and stack 
 *	sizes.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Increments the vmStat counter for each segment that could be 
 *	reused.  Updates the heap and stack sizes in the PCB.
 *
 *----------------------------------------------------------------------
 */

static void
InstrumentSwapSegments(procPtr, execInfoPtr)
    Proc_LockedPCB *procPtr;	/* the process to look at */
    Proc_ObjInfo *execInfoPtr;	/* info about the new object file */
{
    Address newStackStart;
    Address newHeapStart;
    ProcTaskInfo *taskInfoPtr;
    vm_size_t currHeapSize;	/* current heap size  */
    vm_size_t currStackSize;	/* current stack size */

    taskInfoPtr = procPtr->pcb.taskInfoPtr;

    if (taskInfoPtr != NULL) {

	/*
	 * Record the number of pages currently mapped by the heap and
	 * stack.
	 */
	currHeapSize = (taskInfoPtr->vmInfo.heapInfoPtr == NULL
			? 0
			: taskInfoPtr->vmInfo.heapInfoPtr->length);
	currStackSize = (taskInfoPtr->vmInfo.stackInfoPtr == NULL
			 ? 0
			 : taskInfoPtr->vmInfo.stackInfoPtr->length);
	taskInfoPtr->vmInfo.execHeapPages = Vm_ByteToPage(currHeapSize);
	taskInfoPtr->vmInfo.execStackPages = Vm_ByteToPage(currStackSize);

	/* 
	 * If the heap starts at the same location, then it could
	 * theoretically be reused.  For the stack to be reused, the BSS
	 * must end at the same place.  In either case, it might first be
	 * necessary to bzero the currently mapped pages, then deallocate
	 * pages that aren't initially allocated by the new object file.
	 * On the other hand, it might not be worth reusing any segments
	 * that have pages out on the swap server.
	 */
	newHeapStart = HeapStart(execInfoPtr);
	if (taskInfoPtr->vmInfo.heapInfoPtr != NULL
	    && (newHeapStart ==
		procPtr->pcb.taskInfoPtr->vmInfo.heapInfoPtr->mappedAddr)) {
	    vmStat.segmentsNeedlesslyDestroyed++;
	}
	newStackStart = StackStart(execInfoPtr);
	if (taskInfoPtr->vmInfo.stackInfoPtr != NULL
	    && (newStackStart ==
		(procPtr->pcb.taskInfoPtr->vmInfo.stackInfoPtr->
		 segPtr->typeInfo.stackInfo.baseAddr))) {
	    vmStat.segmentsNeedlesslyDestroyed++;
	}
    }
}


/*
 *----------------------------------------------------------------------
 *
 * StackStart --
 *
 *	Calculate the stack start address for the given object file.
 *
 * Results:
 *	Returns the stack start address.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Address
StackStart(execInfoPtr)
    Proc_ObjInfo *execInfoPtr;	/* info about the new object file */
{
    return Vm_RoundPage(execInfoPtr->bssLoadAddr + execInfoPtr->bssSize);
}


/*
 *----------------------------------------------------------------------
 *
 * HeapStart --
 *
 *	Return the starting heap address for the given object file.
 *
 * Results:
 *	Returns the heap start address.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Address
HeapStart(execInfoPtr)
    Proc_ObjInfo *execInfoPtr;	/* info about the new object file */
{
    return execInfoPtr->heapLoadAddr;
}
@


1.22
log
@Add execHeapPages and execStackPages to Vm_TaskInfo (instrumentation).
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.21 92/07/08 12:49:05 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d42 1
a42 1
#include <spriteSrv.h>
d872 1
@


1.21
log
@Maintain vmStat.segmentsNeedlesslyDestroyed.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.20 92/06/10 15:29:31 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
a172 2
static void CheckSwapSegments _ARGS_((Proc_LockedPCB *procPtr,
		Proc_ObjInfo *execInfoPtr));
d188 2
d1507 2
a1508 3
     * Clear out the user process's address space.  For instrumentation, 
     * first check whether the current heap and stack segments could be 
     * used as is, rather than remapping them or creating new ones.
d1510 1
a1510 1
    CheckSwapSegments(procPtr, execInfoPtr);
d1977 1
a1977 1
 * CheckSwapSegments --
d1980 2
a1981 1
 *	reused in an exec().
d1988 1
a1988 1
 *	reused.
d1994 1
a1994 1
CheckSwapSegments(procPtr, execInfoPtr)
d2001 4
d2006 25
a2030 12
    /* 
     * If the heap starts at the same location, then it could theoretically
     * be reused.  For the stack to be reused, the BSS must end at the same 
     * place.  In either case, it might first be necessary to bzero the 
     * currently mapped pages, then deallocate pages that aren't initially
     * allocated by the new object file.  On the other hand, it might not 
     * be worth reusing any segments that have pages out on the swap 
     * server.
     */
    newHeapStart = HeapStart(execInfoPtr);
    if (procPtr->pcb.taskInfoPtr != NULL) {
	taskInfoPtr = procPtr->pcb.taskInfoPtr;
@


1.20
log
@Get rid of the exec pathname redirection hack.  New Proc_ExecEnv stub
(with the argument and environment strings passed in the MIG RPC).
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.19 92/06/04 14:18:26 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d47 1
d173 2
d189 1
d200 1
d1507 3
a1509 1
     * Clear out the user process's address space.
d1511 1
d1671 1
a1671 1
    heapStart = execInfoPtr->heapLoadAddr;
d1790 1
a1790 2
    stackStart = Vm_RoundPage(execInfoPtr->bssLoadAddr +
			      execInfoPtr->bssSize);
d1974 102
@


1.19
log
@(Hacky) instrumentation to see exec() is so slow.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.18 92/05/08 15:06:55 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
a62 10
 * Standard directory for user binaries.  If REDIRECT_EXEC is defined, then 
 * exec's using an absolute path name are redirected to use this directory. 
 * This was particularly useful when the Sprite server used the same
 * $MACHINE type as native Sprite, even though the binaries weren't
 * compatible.
 */
#define STANDARD_EXEC_DIR	"/users/kupfer/cmds.sprited"
/* #define REDIRECT_EXEC */

/* 
d120 1
a120 1
 * null pointer at the end of the array.
d127 1
a127 1
    int		argLength;	/* actual size of argArray */
d130 1
a130 1
    int		envLength;	/* actual size of envArray */
a157 2
static Time grabArgsTime;
static Time argsAccessTime;
d163 6
a185 1
static void RedirectExec _ARGS_((char *givenName, char *newName));
d201 1
a201 1
 * Proc_ExecEnvStub --
d204 2
d221 1
a221 1
Proc_ExecEnvStub(serverPort, fileName, nameLength, argPtrArray,
d236 66
a301 1
    char realFileName[FS_MAX_PATH_NAME_LENGTH]; /* actual file name to use */
d306 2
d310 25
a334 4
    RedirectExec(fileName, realFileName);
    
    *statusPtr = Proc_Exec(realFileName, (char **)argPtrArray,
			   (char **)envPtrArray, debugMe, 0);
d920 5
d1935 1
a1935 4
    /* 
     * Make sure that the interpreter comes from the right directory 
     */
    RedirectExec(givenInterpName, interpName);
a1966 64

/*
 *----------------------------------------------------------------------
 *
 * RedirectExec --
 *
 *	Redirect an absolute path name to come from the standard directory 
 *	for binaries.  This is a hack to deal with the fact that sprited 
 *	user binaries aren't compatible with native Sprite user binaries.
 *
 * Results:
 *	Fills in the newName buffer with the correct name of the file to 
 *	exec.  
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
RedirectExec(givenName, newName)
    char *givenName;		/* the requested file to exec */
    char *newName;		/* MAXPATHLEN buffer to hold correct name */
{
#ifndef REDIRECT_EXEC
    strcpy(newName, givenName);
#else
    char *progName;		/* last component of givenName */

    /* 
     * If the given name isn't an absolute path, or if it already uses the 
     * standard binaries directory, just use it.
     */
    
    if (givenName[0] != '/' || (strncmp(givenName, STANDARD_EXEC_DIR,
					strlen(STANDARD_EXEC_DIR)) 
				== 0)) {
	if (strlen(givenName) >= FS_MAX_PATH_NAME_LENGTH) {
	    panic("RedirectExec: original file name was bogus.\n");
	}
	strcpy(newName, givenName);
	return;
    }

    /* 
     * Find the last component of the name, then append it to the standard 
     * directory name.
     */

    progName = strrchr(givenName, '/');
    strcpy(newName, STANDARD_EXEC_DIR);
    if (strlen(newName) + strlen(progName) < FS_MAX_PATH_NAME_LENGTH) {
	strcat(newName, progName);
    } else {
	printf("RedirectExec: %s won't fit.\n", givenName);
	strcat(newName, "/GiveMeABreak");
    }

    if (main_DebugFlag) {
	printf("RedirectExec: %s => %s\n", givenName, newName);
    }
#endif /* REDIRECT_EXEC */
}
@


1.18
log
@Don't keep PCB locked so long during Proc_NewProc.  Add a debugging
flag for the code that sets up the arguments to main().  Use
Vm_MakeAccessible instead of Vm_CopyIn to get argv and env strings.
(The copyin-based code was broken.  It assumed that if the first
copyin failed, then the string must fit within the current page.  This
is false if the request size for the first copyin spans 3 or more
pages.)
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.17 92/04/29 21:54:58 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d22 1
d43 2
d158 17
d505 7
d671 6
d684 1
d764 2
d767 6
d810 7
d819 9
d904 7
d956 2
d970 6
d995 4
d1063 5
d1180 11
d1244 7
d1365 6
d1405 1
d1407 6
d1439 6
d1476 7
d1514 5
d1553 7
d1625 5
d1666 8
d1726 5
d1738 5
d1748 5
@


1.17
log
@Disable exec redirection.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.16 92/04/23 23:50:54 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d141 6
d160 1
a160 1
static ReturnStatus DoExec _ARGS_((Proc_LockedPCB *procPtr,
a167 2
static void GetString _ARGS_((int bufferLength, char *buffer,
		Address userAddr));
d352 1
a352 4
    Proc_Lock(procPtr);
    status = DoExec(Proc_AssertLocked(procPtr), fileName, &userArgs,
		    FALSE, debugMe);
    Proc_Unlock(Proc_AssertLocked(procPtr));
d397 1
a397 1
    Proc_LockedPCB *procPtr;	/* process to set up */
d484 3
a507 1

d511 1
a514 1

d554 4
d587 8
d624 8
d721 2
a722 2
    register	char			**argPtr;
    register	int			argNumber;
d728 2
a729 2
    char		*stringBuffer; /* copy of string from user space, 
					* if needed */
d731 4
a734 5
    stringBuffer = ckalloc((unsigned)maxLength);
    if (stringBuffer == NULL) {
	panic("GrabArgArray: out of memory.\n");
    }
    
d742 1
a742 1
    
d746 1
a746 1
	
d768 7
a774 4
		GetString(maxLength, stringBuffer, *argPtr);
		stringPtr = stringBuffer;
		stringLength = strlen(stringBuffer) + 1;
		if (stringBuffer[0] == '\0') {
d778 1
d794 1
d805 9
a845 1
    ckfree(stringBuffer);
a852 54
 * GetString --
 *
 *	Copy a single string of unknown length from user space into the 
 *	given buffer.
 *
 * Results:
 *	Fills in as many characters as possible of the given buffer.  If no 
 *	characters could be read, an initial null is put in the buffer.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
GetString(bufferLength, buffer, userAddr)
    int bufferLength;		/* number of bytes in buffer */
    char *buffer;		/* buffer to fill in */
    Address userAddr;		/* address that string starts at */
{
    ReturnStatus status;
    Address nextPage;		/* page that follows start of user string */
    int bytesOnPage;		/* number of bytes that string might take 
				 * on its first page */

    /* 
     * Initially nil out the result buffer, so that if the CopyIn fails, a 
     * zero-length string is returned.
     */
    buffer[0] = '\0';

    status = Vm_CopyIn(bufferLength, userAddr, buffer);
    if (status == SUCCESS) {
	return;
    }

    /* 
     * Maybe the string is near the end of a page and the CopyIn failed 
     * because the next page doesn't exist.  Try only copying in up to the 
     * end of the page.
     */
    nextPage = Vm_RoundPage(userAddr);
    bytesOnPage = nextPage - userAddr;
    if (bytesOnPage < bufferLength) {
	(void)Vm_CopyIn(bytesOnPage, userAddr, buffer);
	buffer[bytesOnPage] = '\0';
    }
}


/*
 *----------------------------------------------------------------------
 *
d855 2
a856 2
 *	Set up a locked user process with a binary.  Flushes the old VM for
 *	the process, copies in the executable, and sets the thread state.
d871 1
a871 1
    Proc_LockedPCB *procPtr;	/* process to set up */
d910 1
a910 1
    argStringSave = procPtr->pcb.argString;
d943 1
a943 1
    procPtr->pcb.argString = argString;
d950 1
a950 1
	procPtr->pcb.effectiveUserID = uid;
d955 2
a956 1
     * be backed out.
d958 3
d968 3
a970 3
     * Note that this needs to be done before calling SetupVM.  If it's
     * done after SetupVM, we get an EXC_EMULATION message before we can
     * resume the user process.
a971 1
    noReturn = TRUE;
d973 1
a973 1
	kernStatus = thread_suspend(procPtr->pcb.thread);
d979 1
a979 1
	kernStatus = thread_abort(procPtr->pcb.thread);
d991 2
a992 1
    status = SetupVM(procPtr, codeSegPtr, &execInfo, encapPtr);
d1002 1
a1002 1
	procPtr->pcb.genFlags |= PROC_NEEDS_WAKEUP;
d1004 6
a1009 1
    noReturn = FALSE;
d1015 1
a1015 1
	ProcAddToGroupList(procPtr, gid);
d1021 1
a1021 1
    Sig_Exec(procPtr);
d1026 2
a1027 1
	(void)Sig_SendProc(procPtr, SIG_DEBUG, FALSE, SIG_NO_CODE, (Address)0);
d1030 3
d1046 7
a1052 3
	       procPtr->pcb.processID, Stat_GetMsg(status));
	(void)Sig_SendProc(procPtr, SIG_KILL, TRUE, PROC_EXEC_FAILED,
			   (Address)0);
d1073 8
a1080 3
	if (procPtr->pcb.argString != argStringSave) {
	    ckfree(procPtr->pcb.argString);
	    procPtr->pcb.argString = argStringSave;
d1112 4
a1115 4
 *	pointer is changed to refer to the interpreter.  If
 *	the return status is SUCCESS, fills in the code segment, the object
 *	file information for the actual program to execute, the strings to 
 *	put on the stack for the program (arguments and environment), and
d1117 1
a1117 1
 *	command).  The caller is responsible for freeing the string array 
@


1.16
log
@Use Vm_TruncPage and Vm_RoundPage for addresses, instead of using
trunc_page and round_page (for MK73 upgrade).
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.15 92/04/02 21:11:46 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d60 5
a64 1
 * Standard directory for user binaries.  See Proc_ExecEnvStub.
d67 1
a223 8
    /* 
     * XXX Major hack here. XXX
     * Because sprited user binaries aren't compatible with native Sprite 
     * binaries, they live in a different directory.  Rather than fix 
     * hordes of user programs and scripts to point at them, we hack 
     * absolute path names to point at the special sprited directory.  Note 
     * that we have to do this again for shell scripts.
     */
d1679 1
a1679 2
     * XXX Make sure that the interpreter comes from the right directory 
     * (see Proc_ExecEnvStub).
a1680 1

d1738 3
d1775 1
@


1.15
log
@Intercept attempts to exec native Sprite binaries and redirect them to use sprited binaries (ugly hack).
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.14 92/03/12 17:36:27 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d863 1
a863 1
    nextPage = (Address)round_page(userAddr);
@


1.14
log
@Include a useful code when doing a SIG_KILL.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.13 92/02/27 16:28:50 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d34 1
d60 5
d163 1
d169 1
a169 1
		Fs_Stream **interpPtrPtr, char **interpNamePtr,
d212 2
d219 11
a229 1
    *statusPtr = Proc_Exec(fileName, (char **)argPtrArray,
d1146 1
a1146 1
    char *interpName;		/* name of interpreter, if any */
d1185 1
a1185 1
	    status = SetupInterpret(buffer, sizeRead, &filePtr, &interpName,
d1615 1
a1615 1
SetupInterpret(buffer, sizeRead, interpPtrPtr, interpNamePtr, argStringPtr, 
d1620 2
a1621 1
    char **interpNamePtr;	/* OUT: name of the interpreter file */
a1626 1
    char		*interpName; /* name of the interpreter */
d1630 1
d1636 1
d1638 2
a1639 2
	 i < sizeRead && *strPtr != '\n';
	 i++, strPtr++) {
d1650 1
a1650 1
     * Get a pointer to the name of the file to exec.
d1652 1
a1652 1

d1658 1
a1658 2
    interpName = strPtr;
    *interpNamePtr = interpName;
d1664 2
a1665 1
     * Get a pointer to the arguments if there are any.
d1667 1
a1667 1

d1681 7
d1718 60
@


1.13
log
@Snapshot.  Can kill, suspend, and resume processes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.12 92/01/21 16:04:14 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d1037 2
a1038 1
	(void)Sig_SendProc(procPtr, SIG_KILL, TRUE, 0, (Address)0);
@


1.12
log
@Change VM code to use Sprite FS instead of UNIX.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.11 91/12/01 21:59:22 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d39 1
d144 2
a145 1
		char *execPath, UserArgs *userArgsPtr, Boolean kernExec));
d180 2
a181 1
 *	returned in *statusPtr.
d191 1
a191 1
		 envPtrArray, debugMe, statusPtr)
d203 1
d213 1
d334 1
a334 1
		    FALSE);
a356 2
#ifndef SPRITED_USERDEBUG
    debugMe = debugMe;
a357 1
#endif
d400 1
a400 1
    return DoExec(procPtr, execPath, &userArgs, TRUE);
d873 1
a873 1
DoExec(procPtr, execPath, userArgsPtr, kernExec)
d880 3
a898 4
    if (procPtr->pcb.genFlags & PROC_NO_MORE_REQUESTS) {
	status = GEN_ABORTED_BY_SIGNAL;
	goto execError;
    }
a1014 1
#ifdef SPRITED_SIGNALS
d1020 1
a1020 1
	Sig_SendProc(procPtr, SIG_DEBUG, SIG_NO_CODE, (Address)0);
a1021 1
#endif
d1029 4
d1035 1
a1035 1
	printf("Killing process %x: failed exec: %s\n",
d1037 1
a1037 1
	Proc_Kill(procPtr);
@


1.11
log
@Snapshot.  FS appears to work.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.10 91/11/14 10:02:22 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d33 1
a39 1
#include <tempFs.h>
d145 1
a145 1
		Proc_ObjInfo *execInfoPtr, TempFs_Stream *objFilePtr,
d156 1
a156 1
		TempFs_Stream **filePtrPtr, Vm_Segment **codeSegPtrPtr,
d160 1
a160 1
		TempFs_Stream **interpPtrPtr, char **interpNamePtr,
d879 1
a879 1
    TempFs_Stream *filePtr = NULL;	/* the program to run */
d885 2
a886 2
    uid_t uid = -1;			/* user ID to use; -1 if not setuid */
    gid_t gid = -1;			/* group ID to use; -1 if not setgid */
d917 2
a918 2
    status = TempFs_Open(execPath, FS_EXECUTE | FS_FOLLOW, FS_FILE, 0,
			 &filePtr);
a921 1
#ifdef SPRITED_REALFS
a922 1
#endif
d1037 1
a1037 1
	TempFs_Close(filePtr);
d1108 1
a1108 1
    TempFs_Stream **filePtrPtr;	/* IN: stream for execName; OUT: either the 
d1118 1
a1118 1
    TempFs_Stream *filePtr;	/* local copy of file handle; this is the
d1148 1
a1148 1
	status = TempFs_Read(filePtr, buffer, 0, &sizeRead);
d1157 1
a1157 1
	    TempFs_Close(filePtr);
d1390 1
a1390 1
    TempFs_Stream *objFilePtr;	/* the object file */
d1596 1
a1596 1
    register TempFs_Stream **interpPtrPtr; /* OUT: interpreter file */
d1660 1
a1660 1
    status = TempFs_Open(interpName, FS_EXECUTE | FS_FOLLOW, FS_FILE, 0,
d1667 1
a1667 1
    status = TempFs_Read(*interpPtrPtr, (Address)&execHeader, 0, &sizeRead);
d1679 1
a1679 1
	(void)TempFs_Close(*interpPtrPtr);
@


1.10
log
@Snapshot. net, rpc, recov modules added.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.9 91/10/18 17:59:59 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
a38 1
#include <spriteTypesTemp.h>
d840 1
a840 1
     * end of the page.  XXX untested.
d936 7
a942 3
#ifdef SPRITED_REALFS
    Fs_CloseOnExec(procPtr);
#endif
@


1.9
log
@Use ckalloc/ckfree rather than malloc/free.  Fix random bugs.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.8 91/10/08 17:28:06 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
a24 1
#include <libc.h>
d30 1
d192 2
a193 2
    int nameLength;		/* extra parameter to appease MIG */
    char	**argPtrArray;	/* The array of arguments to the exec'd 
d195 1
a195 1
    char	**envPtrArray;	/* The array of environment variables
d202 7
a208 1
    *statusPtr = Proc_Exec(fileName, argPtrArray, envPtrArray, debugMe, 0);
d349 8
d415 3
a417 3
 *	procMach_HighestStackAddr.  If the exec is performed on a different
 *	machine, the pointers in argv and envp must be adjusted by the
 *	relative values of procMach_HighestStackAddr.
d523 1
a523 1
    buffer = ckalloc(bufSize);
d533 1
a533 1
    hdrPtr->base = procMach_HighestStackAddr - stackSize;
d552 1
a552 1
    argString = ckalloc(argStringLength + 1);
d691 1
a691 1
    stringBuffer = ckalloc(maxLength);
d747 1
a747 1
	argListPtr->stringPtr = ckalloc(stringLength);
d1132 2
a1133 2
	bcopy((*codeSegPtrPtr)->typeInfo.codeInfo.execInfoPtr,
	      execInfoPtr, sizeof(Proc_ObjInfo));
d1143 1
a1143 1
	buffer = ckalloc(sizeRead);
d1347 1
a1347 1
			       (int)execInfoPtr->codeSize,
d1394 2
a1395 2
    int heapSize;		/* bytes in heap segment */
    int heapMappedSize;		/* initial number of bytes actually mapped */
d1434 1
a1434 1
    heapSize = procMach_HighestStackAddr + 1 - heapStart;
d1444 1
a1444 1
    kernStatus = Vm_MapSegment(procPtr, segPtr, FALSE, FALSE, 0,
d1492 1
a1492 1
    int stackSize;		/* number of bytes allowed for stack */
d1495 1
a1495 1
    int bytesToMap;		/* number of stack bytes to map initially */
d1521 1
a1521 1
    stackSize = procMach_HighestStackAddr + 1 - stackStart;
d1533 1
a1533 1
    firstPageToMap = procMach_HighestStackAddr + 1 - bytesToMap;
d1536 1
a1536 1
			       firstPageToMap - stackStart,
@


1.8
log
@Don't assume PROC_MAX_INTERPRET_SIZE >= sizeof(ProcExecHeader).
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.7 91/10/04 11:37:26 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d23 1
d337 1
a337 1
	    free((Address) encapPtr);
d509 1
a509 1
    buffer = malloc(bufSize);
d538 1
a538 1
    argString = malloc(argStringLength + 1);
d562 2
a563 2
	free((Address) argListPtr->stringPtr);
	free((Address) argListPtr);
d584 2
a585 2
	free((Address) argListPtr->stringPtr);
	free((Address) argListPtr);
d604 2
a605 2
	free((Address) argListPtr->stringPtr);
	free((Address) argListPtr);
d610 2
a611 2
	free((Address) argListPtr->stringPtr);
	free((Address) argListPtr);
d677 1
a677 1
    stringBuffer = malloc(maxLength);
d732 2
a733 2
	argListPtr = (ArgListElement *)malloc(sizeof(ArgListElement));
	argListPtr->stringPtr = malloc(stringLength);
d775 2
a776 2
	    free((Address) argListPtr->stringPtr);
	    free((Address) argListPtr);
d779 1
a779 1
    free(stringBuffer);
d1028 1
a1028 1
	free(encapPtr);
d1032 2
a1033 1
	    free(argStringSave);
d1036 4
d1041 1
a1041 1
	    free(procPtr->pcb.argString);
d1044 1
d1117 4
a1120 1
    if (status == VM_SEG_NOT_FOUND) {
d1129 1
a1129 1
	buffer = malloc(sizeRead);
d1213 2
a1214 1
	    free(userArgsPtr->argPtrArray);
d1219 2
a1220 1
	    free(userArgsPtr->envPtrArray);
d1229 1
a1229 1
	free(buffer);
@


1.7
log
@Snapshot.  fork/exec work.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.6 91/09/24 16:27:32 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d1099 1
a1099 2
    char buffer[PROC_MAX_INTERPRET_SIZE]; /* buffer to hold first bit of 
					   * file */
d1117 1
a1117 1
	    panic("SetupCode: need bigger buffer.\n"); /* XXX */
d1119 4
d1216 3
a1251 3
     * XXX May need to be more careful for all processes except the first 
     * (don't want to wipe out the shared emulation library, if there is 
     * one).
@


1.6
log
@Note that GetString isn't fully tested.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.5 91/09/23 14:19:46 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d34 1
d36 3
d143 1
a143 1
		char *execPath, UserArgs *userArgsPtr));
d170 179
d384 1
a384 1
    return DoExec(procPtr, execPath, &userArgs);
d400 1
a400 1
 *	procMachHighestStackAddr.  If the exec is performed on a different
d402 1
a402 1
 *	relative values of procMachHighestStackAddr.
d518 1
a518 1
    hdrPtr->base = procMachHighestStackAddr - stackSize;
d715 1
d850 2
a851 1
 *	were copied in from user space.
d855 1
a855 1
    
d857 1
a857 1
DoExec(procPtr, execPath, userArgsPtr)
d862 2
d865 10
d876 1
a876 8
    TempFs_Stream *filePtr = NULL; /* the program to run */
    Proc_ObjInfo execInfo;	/* a.out header information */
    char *argStringSave = NULL;	/* the process's current arg string */
    char *argString = NULL;	/* the process's new arg string */
    Vm_Segment *codeSegPtr = NULL; /* new code segment */
    ExecEncapState *encapPtr;	/* stack information & contents */
    uid_t uid = -1;		/* user ID to use; -1 if not setuid */
    gid_t gid = -1;		/* group ID to use; -1 if not setgid */
d940 33
a972 1
     * Set up virtual memory and processor registers.
d978 1
a978 2
    status = ProcMachSetRegisters(procPtr, execInfo.codeLoadAddr,
				  execInfo.heapLoadAddr, encapPtr->hdr.base,
d983 4
d1009 11
d1041 2
a1042 1
	    free(userArgsPtr->argPtrArray);
d1047 2
a1048 1
	    free(userArgsPtr->envPtrArray);
d1250 1
d1405 1
a1405 1
    heapSize = procMachHighestStackAddr + 1 - heapStart;
d1492 1
a1492 1
    stackSize = procMachHighestStackAddr + 1 - stackStart;
d1504 1
a1504 1
    firstPageToMap = procMachHighestStackAddr + 1 - bytesToMap;
@


1.5
log
@Snapshot.  Server is multithreaded internally.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.4 91/09/20 19:36:44 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d642 1
a642 1
     * end of the page.
@


1.4
log
@Snapshot before putting in native Sprite code.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.3 91/09/02 22:53:55 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d23 1
d25 1
d47 12
d65 59
d137 3
a139 2
		Proc_ObjInfo *execInfoPtr, TempFs_Stream *filePtr,
		char *fileName));
a142 1
static ReturnStatus DoSharedRegion _ARGS_((Proc_LockedPCB *procPtr));
d144 513
a656 12
		Proc_ObjInfo *execInfoPtr, char **argsArray,
		Address *stackTopPtr));
static ReturnStatus GetExecInfo _ARGS_((TempFs_Stream *filePtr,
		Proc_ObjInfo *execInfoPtr));
static ReturnStatus MakeArgsBuffer _ARGS_((char **argsArray,
		Address *argsPagePtrPtr, Address *stackTopPtr));


/*
 *----------------------------------------------------------------------
 *
 * Proc_Load --
d658 2
a659 1
 *	Set up a locked user process with a binary.
d665 2
a666 2
 *	Creates the VM for the process, copies in the executable, sets 
 *	and thread state.
d670 3
a672 3

ReturnStatus
Proc_Load(procPtr, execPath, argsArray)
d675 2
a676 1
    char **argsArray;		/* arguments to pass to program */
d679 1
a679 1
    TempFs_Stream *filePtr;	/* the program to run */
d681 6
a686 1
    Address initialSp;		/* value to initialize stack pointer to */
d688 2
d691 2
a692 1
	return GEN_ABORTED_BY_SIGNAL;
d694 19
d716 1
a716 9
	return status;
    }

    /* From here on, return through "done", so that cleanup happens. */

    status = GetExecInfo(filePtr, &execInfo);
    if (status != SUCCESS) {
	printf("Proc_Load: Can't get exec info\n");
	goto done;
d718 33
a750 6

    /* 
     * Clear out the user process's address space.
     * XXX May need to be more careful for all processes except the first 
     * (don't want to wipe out the shared emulation library, if there is 
     * one).
d752 1
a752 4
    (void)vm_deallocate(procPtr->pcb.taskInfoPtr->task, VM_MIN_ADDRESS,
			(vm_size_t)(VM_MAX_ADDRESS - VM_MIN_ADDRESS));

    status = DoCode(procPtr, &execInfo, filePtr, execPath);
d754 1
a754 2
	printf("Proc_Load: Can't set up text.\n");
	goto done;
d756 3
a758 1
    status = DoHeap(procPtr, &execInfo, filePtr, execPath);
d760 1
a760 3
	printf("Proc_Load: Can't set up heap.\n");
	status = VM_SWAP_ERROR;
	goto done;
d762 18
a779 5
    status = DoStack(procPtr, &execInfo, argsArray, &initialSp);
    if (status != SUCCESS) {
	printf("Proc_Load: Can't set up stack.\n");
	status = VM_SWAP_ERROR;
	goto done;
d781 1
d783 31
a813 5
    /* XXX - debug, only for first process */
    status = DoSharedRegion(procPtr);
    if (status != SUCCESS) {
	printf("Can't set up shared region.\n");
	return status;
d815 156
a970 7
  
    status = ProcMachSetRegisters(procPtr, execInfo.codeLoadAddr,
				  execInfo.heapLoadAddr, initialSp,
				  execInfo.entry);
    if (status != SUCCESS) {
	printf("Proc_Load: Can't set up registers\n");
	goto done;
d973 2
a974 2
 done:
    TempFs_Close(filePtr);
d982 1
a982 1
 * GetExecInfo --
d984 2
a985 2
 *	Get the information about the different segments of the object 
 *	file.
d988 1
a988 2
 *	Returns a status code.  Fills in the structure with offsets 
 *	and sizes.
d991 1
a991 1
 *	Moves the offset in the object file.
d996 7
a1002 4
static ReturnStatus
GetExecInfo(filePtr, execInfoPtr)
    TempFs_Stream *filePtr;		/* the object file */
    Proc_ObjInfo *execInfoPtr;	/* structure to fill in */
a1003 2
    ProcExecHeader execHeader;	/* header from object file */
    int bytesRead;
d1006 22
a1027 2
    bytesRead = sizeof(execHeader);
    status = TempFs_Read(filePtr, (Address)&execHeader, 0, &bytesRead);
d1029 8
a1036 10
	printf("Can't read exec header: %s\n", Stat_GetMsg(status));
	return status;
    }
    if (bytesRead != sizeof(execHeader)) {
	printf("Couldn't read all of exec header\n");
	return FAILURE;		/* XXX be more specific */
    }

    return ProcGetObjInfo(filePtr, &execHeader, execInfoPtr);
}
d1044 2
a1045 1
 *	Set up the text part of the child process.
d1048 1
a1048 1
 *	Sprite status code.
d1051 1
a1051 2
 *	Maps the code portion of the object file into the process's 
 *	address space.
d1057 1
a1057 1
DoCode(procPtr, execInfoPtr, filePtr, fileName)
d1060 1
a1060 2
    TempFs_Stream *filePtr;	/* the object file */
    char *fileName;		/* name of the object file */
a1064 1
    Vm_Segment *segPtr;		/* handle for the text segment */
d1066 2
a1067 10
    status = Vm_GetCodeSegment(filePtr, fileName, execInfoPtr,
			       &segPtr);
    if (status != SUCCESS) {
	return status;
    }

    /* 
     * From here on, return through bailOut, so that the segment is 
     * managed correctly.
     */
a1068 1
    textStart = execInfoPtr->codeLoadAddr;
d1070 2
a1071 1
     * XXX Allow for object files that don't have page-aligned sections.
d1075 1
a1075 1
	goto bailOut;
d1077 2
a1078 2
    kernStatus = Vm_MapSegment(procPtr, segPtr, TRUE, FALSE,
			       (int)execInfoPtr->codeFileOffset,
d1092 1
a1092 1
 bailOut:
d1094 1
a1094 1
	Vm_SegmentRelease(segPtr);
d1204 2
a1205 1
 *	Set up the stack part of the child process.
d1208 1
a1208 2
 *	Returns a status code.  Tells what the initial stack pointer 
 *	should be.
d1211 1
a1211 2
 *	Creates a segment for the stack and maps it into the process's 
 *	address space.
d1217 1
a1217 1
DoStack(procPtr, execInfoPtr, argsArray, stackTopPtr)
d1220 1
a1220 2
    char **argsArray;		/* arguments to put on stack */
    Address *stackTopPtr;	/* OUT: address to set stack ptr to */
d1225 3
a1227 3
    char *argsPagePtr = NULL;	/* buffer to hold args */
    Address pageToMap;		/* address of first page to map */
    Address pageMapped;		/* address of page actually mapped */
d1261 2
a1262 2
     * Map one page of the stack.  If the process needs additional 
     * pages, let the exception handler worry about it.
d1264 3
a1266 2
    pageToMap = Vm_TruncPage(procMachHighestStackAddr);
    pageMapped = pageToMap;
d1268 2
a1269 2
			       pageToMap - stackStart,
			       vm_page_size, &pageMapped, &status);
d1273 1
a1273 1
    if (pageMapped != pageToMap) {
d1281 1
a1281 2
     * Set up a dummy page that has the arguments and such in the 
     * right format.  Then copy the page into the user process.
d1283 3
a1285 1
    status = MakeArgsBuffer(argsArray, &argsPagePtr, stackTopPtr);
a1286 7
	printf("Couldn't create arguments buffer\n");
	goto done;
    }
    kernStatus = vm_write(procPtr->pcb.taskInfoPtr->task,
			  (vm_address_t)pageToMap,
			  (pointer_t)argsPagePtr, vm_page_size);
    if (kernStatus != KERN_SUCCESS) {
d1288 1
a1288 1
	       mach_error_string(kernStatus));
a1290 6
    /* 
     * Convert the initial stack pointer from an address in the dummy 
     * stack page to an address in the actual stack page.
     */
    *stackTopPtr = (*stackTopPtr - argsPagePtr) + pageToMap;

a1291 3
    if (argsPagePtr != NULL) {
	free(argsPagePtr);
    }
d1303 1
a1303 1
 * DoSharedRegion --
d1305 1
a1305 2
 *	Set up the region in the initial process that is shared with 
 *	the server.
d1308 87
a1394 23
 *	Returns a status code.
 *
 * Side effects:
 *	Allocates VM for the shared region.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
DoSharedRegion(procPtr)
    Proc_LockedPCB *procPtr;	/* the locked process to set up */
{
    kern_return_t kernStatus;
    Address regionStart;	/* first address of shared page */

    regionStart = (Address)PROC_SHARED_REGION_START;
    kernStatus = vm_allocate(procPtr->pcb.taskInfoPtr->task,
			     (vm_address_t *)&regionStart,
			     vm_page_size, FALSE);
    if (kernStatus != KERN_SUCCESS) {
	printf("Couldn't allocate shared region in process: %s\n",
	       mach_error_string(kernStatus));
	return Utils_MapMachStatus(kernStatus);
d1397 6
a1402 52
    return SUCCESS;
}
  

/*
 *----------------------------------------------------------------------
 *
 * MakeArgsBuffer --
 *
 *	Make a buffer containing the arguments as they'll go on the 
 *	stack.  Also figure out where the top of the stack will go.
 *	XXX - eventually replace with the Sprite code, which is more 
 *	      comprehensive and explains the stack layout...
 *
 * Results:
 *	Returns a status code.  Fills in the pointer to the 
 *	(filled-in) buffer and the top of stack.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
MakeArgsBuffer(argsArray, argsPagePtrPtr, stackTopPtr)
    char **argsArray;		/* array of arguments */
    Address *argsPagePtrPtr;	/* OUT: start of buffer */
    Address *stackTopPtr;	/* OUT: top of stack */
{
    int argBytes = 0;		/* number of bytes for arguments & such */
    int argIndex;
    int numArgs = 0;		/* number of arguments */
    Address stackPtr;		/* pointer into stack buffer */
    kern_return_t kernStatus;

    /* 
     * Figure out how much space the arguments take up (make sure 
     * everything will fit in one page).  Also allow space for argc,
     * the null pointer to end the argument list, and another null
     * pointer for the non-existent environment list.  Allocate the
     * page.
     */
    for (argIndex = 0; argsArray[argIndex] != (char *)NIL; argIndex++) {
	argBytes += strlen(argsArray[argIndex]) + 1;
	++numArgs;
    }
    argBytes += 3*sizeof(int);
    argBytes = Byte_AlignAddr(argBytes);
    if (argBytes > vm_page_size) {
	printf("Can't make stack: too many arguments\n"); /* XXX lazy */
	return FAILURE;
d1404 8
a1411 19
    kernStatus = vm_allocate(mach_task_self(), (vm_address_t *)argsPagePtrPtr,
			     vm_page_size, TRUE);
    if (kernStatus != KERN_SUCCESS) {
	printf("can't make stack: %s\n",
	       mach_error_string(kernStatus));
	return Utils_MapMachStatus(kernStatus);
    }
    *stackTopPtr = *argsPagePtrPtr + vm_page_size - argBytes;
    /* 
     * XXX need to do something about machines where the stack pointer 
     * points to the first free location, rather than the top of stack
     */

    stackPtr = *stackTopPtr;
    *(int *)stackPtr = numArgs;
    stackPtr += sizeof(int);
    for (argIndex = 0; argsArray[argIndex] != (char *)NIL; argIndex++) {
	strcpy((char *)stackPtr, argsArray[argIndex]);
	stackPtr += strlen(argsArray[argIndex]) + 1;
a1412 1
    bzero(stackPtr, 2 * sizeof(int));
d1414 1
a1414 1
    return SUCCESS;
@


1.3
log
@Changes for module-based source organization.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /user6/kupfer/spriteserver/src/sprited/proc/RCS/procExec.c,v 1.2 91/09/01 21:03:06 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d37 14
d63 1
a63 1
static ReturnStatus DoCode _ARGS_((Proc_ControlBlock *procPtr,
d66 1
a66 1
static ReturnStatus DoHeap _ARGS_((Proc_ControlBlock *procPtr,
d69 2
a70 2
static ReturnStatus DoSharedRegion _ARGS_((Proc_ControlBlock *procPtr));
static ReturnStatus DoStack _ARGS_((Proc_ControlBlock *procPtr,
d98 1
a98 1
    Proc_ControlBlock *procPtr;	/* process to set up */
d107 3
d126 3
a128 1
     * XXX - only want to do this for initial process.
d130 1
a130 1
    (void)vm_deallocate(procPtr->taskInfoPtr->task, VM_MIN_ADDRESS,
d233 1
a233 1
    Proc_ControlBlock *procPtr;	/* the locked process to set up */
d274 1
a274 1
	panic("DoCode: Didn't get requested text address.");
d304 1
a304 1
    Proc_ControlBlock *procPtr;	/* the locked process to set up */
d373 1
a373 1
	panic("DoHeap: Didn't get requested start address.");
d404 1
a404 1
    Proc_ControlBlock *procPtr;	/* the locked process to set up */
d424 1
a424 1
	panic("DoStack: can't handle stacks that grow up.");
d460 1
a460 1
	panic("DoStack: didn't get requested stack address.");
d475 1
a475 3
#if 0
    /* This causes a deadlock if the server is single-threaded. */
    kernStatus = vm_write(procPtr->taskInfoPtr->task,
d479 1
a479 1
	printf("Couldn't copy arguments to user process: %s\n",
a480 15
	panic("DoStack");
    }
#else
    {
	int bytesToWrite = vm_page_size;
	status = TempFs_Write(segPtr->swapFilePtr, argsPagePtr, 0,
			      &bytesToWrite);
	if (bytesToWrite != vm_page_size) {
	    status = VM_SHORT_WRITE;
	}
	if (status != SUCCESS) {
	    printf("Couldn't initialize stack segment: %s.\n",
		   Stat_GetMsg(status));
	    goto done;
	}
a481 1
#endif
d520 1
a520 1
    Proc_ControlBlock *procPtr;	/* the locked process to set up */
d526 1
a526 1
    kernStatus = vm_allocate(procPtr->taskInfoPtr->task,
@


1.2
log
@Snapshot.  Full VM support.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /user6/kupfer/spriteserver/src/printfd/RCS/procExec.c,v 1.1 91/08/19 12:25:51 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
a28 6
#include "md.h"
#include "proc.h"
#include "procInt.h"
#include "tempFs.h"
#include "util.h"
#include "vm.h"
d30 7
d139 3
a141 3
    status = Mach_SetRegisters(procPtr, execInfo.codeLoadAddr,
			       execInfo.heapLoadAddr, initialSp,
			       execInfo.entry);
d248 1
a248 1
	status = Util_MapMachStatus(kernStatus);
d332 1
a332 1
    heapSize = mach_HighestStackAddr + 1 - heapStart;
d347 1
a347 1
	status = Util_MapMachStatus(kernStatus);
d400 1
a400 1
    if (!MACH_STACK_GROWS_DOWN) {
d421 1
a421 1
    stackSize = mach_HighestStackAddr + 1 - stackStart;
d432 1
a432 1
    pageToMap = Vm_TruncPage(mach_HighestStackAddr);
d438 1
a438 1
	status = Util_MapMachStatus(kernStatus);
d531 1
a531 1
	return Util_MapMachStatus(kernStatus);
d592 1
a592 1
	return Util_MapMachStatus(kernStatus);
@


1.1
log
@Snapshot: Code reorg. and locking for processes & segments.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.29 91/07/26 16:59:33 shirriff Exp $ SPRITE (Berkeley)";
d34 1
d36 9
d48 3
d52 2
a53 2
				   ProcObjInfo *execInfoPtr, 
				   TempFs_Stream *filePtr));
d56 2
a57 4
				    char **argsArray, Address *stackTopPtr));
static ReturnStatus DoText _ARGS_((Proc_ControlBlock *procPtr,
				   ProcObjInfo *execInfoPtr, 
				   TempFs_Stream *filePtr));
d59 1
a59 1
					ProcObjInfo *execInfoPtr));
d61 1
a61 2
					   Address *argsPagePtrPtr,
					   Address *stackTopPtr));
d87 3
a89 3
    ReturnStatus status;
    TempFs_Stream *filePtr;		/* the program to run */
    ProcObjInfo execInfo;
d92 2
a93 1
    status = TempFs_Open(execPath, FS_READ, FS_FILE, 0, &filePtr);
d97 3
d102 2
a103 2
	printf("Can't get exec info\n");
	return status;
d113 1
a113 1
    status = DoText(procPtr, &execInfo, filePtr);
d115 2
a116 2
	printf("Can't set up text.\n");
	return status;
d118 1
a118 1
    status = DoHeap(procPtr, &execInfo, filePtr);
d120 3
a122 2
	printf("Can't set up heap.\n");
	return status;
d124 1
a124 1
    status = DoStack(procPtr, argsArray, &initialSp);
d126 3
a128 2
	printf("Can't set up stack.\n");
	return status;
d131 1
a131 1
    /* XXX - only for first process */
d137 1
a137 1

d142 2
a143 2
	printf("Can't set up registers\n");
	return status;
d146 3
a148 1
    return SUCCESS;
d173 1
a173 1
    ProcObjInfo *execInfoPtr;	/* structure to fill in */
d197 1
a197 1
 * DoText --
d202 1
a202 1
 *	status code.
d205 2
a206 1
 *	Allocates VM for text, copies the text in from the object file.
d212 1
a212 1
DoText(procPtr, execInfoPtr, filePtr)
d214 3
a216 2
    ProcObjInfo *execInfoPtr;	/* where to find things in the file */
    TempFs_Stream *filePtr;		/* the object file */
a219 4
    int textRegionBytes;	/* number of bytes in text region */
    Address buffer;		/* in server VM */
    int textBytes;		/* number of bytes of text */
    Address localTextStart;	/* where text starts in local buffer */
d221 1
d223 4
a226 11
    textStart = (Address)trunc_page(execInfoPtr->codeLoadAddr);
    textRegionBytes = (Address)round_page(execInfoPtr->codeLoadAddr +
				 execInfoPtr->codeSize)
		      - textStart;
    kernStatus = vm_allocate(procPtr->taskInfoPtr->task,
			     (vm_address_t *)&textStart,
			     textRegionBytes, FALSE);
    if (kernStatus != KERN_SUCCESS) {
	printf("Couldn't allocate text region in user process: %s\n",
	       mach_error_string(kernStatus));
	return Util_MapMachStatus(kernStatus);
d230 2
a231 2
     * Allocate a buffer in our address space.  Read the text into the 
     * buffer, then copy it to the user's text region.
d234 6
a239 15
    buffer = 0;
    kernStatus = vm_allocate(mach_task_self(), (vm_address_t *)&buffer,
			     textRegionBytes, TRUE);
    if (kernStatus != KERN_SUCCESS) {
	printf("Can't allocate buffer for text: %s\n",
	       mach_error_string(kernStatus));
	return Util_MapMachStatus(kernStatus);
    }
    localTextStart = buffer +
	((vm_address_t)execInfoPtr->codeLoadAddr % vm_page_size);
    textBytes = execInfoPtr->codeSize;
    status = TempFs_Read(filePtr, localTextStart, execInfoPtr->codeFileOffset,
		     &textBytes);
    if (status != SUCCESS || textBytes != execInfoPtr->codeSize) {
	printf("Can't read text from object file\n");
d242 4
a245 2
    kernStatus = vm_write(procPtr->taskInfoPtr->task, (vm_address_t)textStart,
			  (pointer_t)buffer, textRegionBytes);
a246 2
	printf("Couldn't copy text to user process: %s\n",
	       mach_error_string(kernStatus));
a247 1
	goto bailOut;
d249 6
a254 9

    kernStatus = vm_protect(procPtr->taskInfoPtr->task, (vm_address_t)textStart,
			    textRegionBytes, FALSE,
			    VM_PROT_READ | VM_PROT_EXECUTE);
    if (kernStatus != KERN_SUCCESS) {
	printf("Couldn't set protection for text region: %s\n",
	       mach_error_string(kernStatus));
	status = Util_MapMachStatus(kernStatus);
	goto bailOut;
d258 3
a260 3
    (void)vm_deallocate(mach_task_self(), (vm_address_t)buffer,
			textRegionBytes);

d276 2
a277 2
 *	Allocates VM for initialized and uninitialized data.  Copies 
 *	the initialized data in from the object file.
d283 1
a283 1
DoHeap(procPtr, execInfoPtr, filePtr)
d285 3
a287 2
    ProcObjInfo *execInfoPtr;	/* where to find things in the file */
    TempFs_Stream *filePtr;		/* the object file */
d291 2
a292 4
    int heapRegionBytes;	/* number of bytes in heap region */
    Address buffer;		/* in server VM */
    int heapBytes;		/* number of bytes of init'd. data */
    Address localHeapStart;	/* where heap starts in local buffer */
d294 1
d296 4
d303 1
a303 1
	return FAILURE;		/* XXX be more specific */
d306 18
a323 11
    heapStart = (Address)trunc_page(execInfoPtr->heapLoadAddr);
    heapRegionBytes = (Address)round_page(execInfoPtr->bssLoadAddr +
				 execInfoPtr->bssSize)
		      - heapStart;
    kernStatus = vm_allocate(procPtr->taskInfoPtr->task,
			     (vm_address_t *)&heapStart,
			     heapRegionBytes, FALSE);
    if (kernStatus != KERN_SUCCESS) {
	printf("Couldn't allocate heap region in user process: %s\n",
	       mach_error_string(kernStatus));
	return Util_MapMachStatus(kernStatus);
d327 2
a328 4
     * Allocate a buffer in our address space, big enough for both 
     * initialized and unitialized data.  Read the initialized 
     * data into the buffer, then copy it all to the user's heap region.
     * XXX - excessive copying.
d330 4
a333 16
    
    buffer = 0;
    kernStatus = vm_allocate(mach_task_self(), (vm_address_t *)&buffer,
			     heapRegionBytes, TRUE);
    if (kernStatus != KERN_SUCCESS) {
	printf("Can't allocate buffer for heap: %s\n",
	       mach_error_string(kernStatus));
	return Util_MapMachStatus(kernStatus);
    }
    localHeapStart = buffer +
	((vm_address_t)execInfoPtr->heapLoadAddr % vm_page_size);
    heapBytes = execInfoPtr->heapSize;
    status = TempFs_Read(filePtr, localHeapStart, execInfoPtr->heapFileOffset,
		     &heapBytes);
    if (status != SUCCESS || heapBytes != execInfoPtr->heapSize) {
	printf("Can't read heap from object file\n");
d336 7
a342 2
    kernStatus = vm_write(procPtr->taskInfoPtr->task, (vm_address_t)heapStart,
			  (pointer_t)buffer, heapRegionBytes);
d344 1
a344 1
	printf("Couldn't copy heap to user process: %s\n",
d347 7
a353 1
	goto bailOut;
d357 3
a359 3
    (void)vm_deallocate(mach_task_self(), (vm_address_t)buffer,
			heapRegionBytes);

d376 2
a377 1
 *	Allocates VM for the stack, copies.
d383 1
a383 1
DoStack(procPtr, argsArray, stackTopPtr)
d385 1
d391 1
a391 1
    Address stackStart;		/* first address of stack page */
d393 13
d408 2
a409 1
     * Allocate one page for the stack, to start.
d411 25
a435 5
    
    stackStart = mach_InitialUserStackPage;
    kernStatus = vm_allocate(procPtr->taskInfoPtr->task,
			     (vm_address_t *)&stackStart,
			     vm_page_size, FALSE);
a436 2
	printf("Couldn't allocate initial stack in user process: %s\n",
	       mach_error_string(kernStatus));
d438 5
d455 4
a458 1
    kernStatus = vm_write(procPtr->taskInfoPtr->task, (vm_address_t)stackStart,
d463 15
a477 2
	status = Util_MapMachStatus(kernStatus);
	goto done;
d479 1
d481 5
a485 1
    *stackTopPtr = (*stackTopPtr - argsPagePtr) + stackStart;
d491 4
d535 1
a535 1

@
