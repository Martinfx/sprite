head     1.26;
branch   ;
access   ;
symbols  srv030:1.26 srv029:1.25.1 srv028:1.25 srv027:1.25 srv026:1.25 srv024:1.24 srv022:1.24 srv021:1.24 srv020e:1.23.1 srv019:1.23 srv018:1.22 srv016:1.22 srv015:1.22 srv014:1.21 srv012:1.21 srv011:1.20 srv010:1.20 srv008:1.20 srv007:1.20 srv006:1.19 srv005:1.19 srv004:1.19 srv003:1.18 srv002:1.17 srv001:1.16;
locks    ; strict;
comment  @ * @;


1.26
date     92.07.16.18.05.07;  author kupfer;  state Exp;
branches ;
next     1.25;

1.25
date     92.07.09.15.45.18;  author kupfer;  state Exp;
branches 1.25.1.1;
next     1.24;

1.24
date     92.07.02.16.46.24;  author kupfer;  state Exp;
branches ;
next     1.23;

1.23
date     92.06.29.16.13.54;  author kupfer;  state Exp;
branches 1.23.1.1;
next     1.22;

1.22
date     92.06.12.12.33.26;  author kupfer;  state Exp;
branches ;
next     1.21;

1.21
date     92.06.07.23.29.41;  author kupfer;  state Exp;
branches ;
next     1.20;

1.20
date     92.05.27.21.24.03;  author kupfer;  state Exp;
branches ;
next     1.19;

1.19
date     92.05.08.12.54.20;  author kupfer;  state Exp;
branches 1.19.1.1;
next     1.18;

1.18
date     92.04.29.21.40.18;  author kupfer;  state Exp;
branches ;
next     1.17;

1.17
date     92.04.23.23.37.01;  author kupfer;  state Exp;
branches ;
next     1.16;

1.16
date     92.04.16.11.21.22;  author kupfer;  state Exp;
branches ;
next     1.15;

1.15
date     92.02.27.15.53.22;  author kupfer;  state Exp;
branches ;
next     1.14;

1.14
date     92.01.21.17.07.43;  author kupfer;  state Exp;
branches ;
next     1.13;

1.13
date     91.12.12.20.56.33;  author kupfer;  state Exp;
branches ;
next     1.12;

1.12
date     91.12.01.22.00.36;  author kupfer;  state Exp;
branches ;
next     1.11;

1.11
date     91.11.14.10.03.18;  author kupfer;  state Exp;
branches ;
next     1.10;

1.10
date     91.10.18.18.27.47;  author kupfer;  state Exp;
branches ;
next     1.9;

1.9
date     91.10.08.17.31.07;  author kupfer;  state Exp;
branches ;
next     1.8;

1.8
date     91.10.04.11.37.54;  author kupfer;  state Exp;
branches ;
next     1.7;

1.7
date     91.09.24.16.34.56;  author kupfer;  state Exp;
branches ;
next     1.6;

1.6
date     91.09.23.14.20.10;  author kupfer;  state Exp;
branches ;
next     1.5;

1.5
date     91.09.04.15.23.47;  author kupfer;  state Exp;
branches ;
next     1.4;

1.4
date     91.09.02.22.56.11;  author kupfer;  state Exp;
branches ;
next     1.3;

1.3
date     91.09.01.21.02.52;  author kupfer;  state Exp;
branches ;
next     1.2;

1.2
date     91.08.19.12.17.24;  author kupfer;  state Exp;
branches ;
next     1.1;

1.1
date     91.08.15.15.51.26;  author kupfer;  state Exp;
branches ;
next     ;

1.19.1.1
date     92.05.27.20.40.34;  author kupfer;  state Exp;
branches ;
next     ;

1.23.1.1
date     92.07.02.14.54.18;  author kupfer;  state Exp;
branches ;
next     ;

1.25.1.1
date     92.07.14.17.41.38;  author kupfer;  state Exp;
branches ;
next     ;


desc
@Sprite virtual memory support.
@


1.26
log
@Add support for VM_DO_COPY_IN_INBAND and VM_DO_COPY_OUT_INBAND VM
commands.  Lint.
@
text
@/* 
 * vmOps.c --
 *
 *	Random Sprite virtual memory operations.
 *	XXX Maybe some of these routines should go in VmSubr.c.  The 
 *	routines for MIG calls should probably stay here.
 *
 * Copyright 1991 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that this copyright
 * notice appears in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.25 92/07/09 15:45:18 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
#endif /* not lint */

#include <sprite.h>
#include <bstring.h>
#include <ckalloc.h>
#include <mach.h>
#include <mach_error.h>
#include <mach/mach_host.h>
#include <status.h>
#include <string.h>

#include <fs.h>
#include <fsutil.h>
#include <machCalls.h>
#include <proc.h>
#include <procMach.h>
#include <timer.h>
#include <utils.h>
#include <vm.h>
#include <vmInt.h>
#include <vmStat.h>
#include <user/vmTypes.h>

/* 
 * We currently require that a stack fault be within a certain 
 * distance of the existing stack.  We might want to relax this 
 * restriction later.  This is the number of bytes in the current 
 * limit. 
 */
#define VM_STACK_MAX_DISTANCE	(10 * 1024 * 1024) /* 10 MB */

Vm_Stat vmStat;			/* VM instrumentation */

#ifndef CLEAN
static vm_address_t copyBuffer; /* dummy char array for copyin/copyout
				 * performance testing  */
#endif

/* Forward references: */

static void AddMappedRange _ARGS_((Address startAddr, vm_size_t length,
		VmMappedSegment *mappedSegPtr));
static ReturnStatus CopyInInbandTest _ARGS_((int copyLength, 
		int inBufLength, Address inBuf));
static ReturnStatus CopyInOutTest _ARGS_((int command, int length,
		Address userBuffer));
static ReturnStatus CopyOutInbandTest _ARGS_((int copyLength, 
		int *outBufLengthPtr, Address *outBufPtr, 
		Boolean *outBufDeallocPtr));
static ReturnStatus CopyRegion _ARGS_((Proc_LockedPCB *fromProcPtr,
		Proc_LockedPCB *toProcPtr, vm_size_t regionSize,
		Address regionAddr)); 
static void GetMemorySize _ARGS_((void));
static vm_offset_t GetStackOffset _ARGS_((VmMappedSegment *stackInfoPtr,
		Address address));
static VmMappedSegment *FindMappedSegment _ARGS_((List_Links *segmentList,
		Vm_Segment *segPtr));
static ReturnStatus MakeAccessibleTest _ARGS_((int command, int length,
		Address userBuffer));
static void MakeCopyTestBuffer _ARGS_((void));
static ReturnStatus MapHeapPage _ARGS_((Proc_ControlBlock *procPtr,
		Address address, VmMappedSegment *heapInfoPtr));
static ReturnStatus MapIntoProcess _ARGS_((Proc_LockedPCB *procPtr,
		Vm_Segment *segPtr, vm_offset_t offset, vm_size_t numBytes,
		Address mapAddr, vm_prot_t protection));
static void NoteMappedSegment _ARGS_((Proc_LockedPCB *procPtr,
		Vm_Segment *segPtr, Address startAddress, vm_size_t length));
static Boolean OkayToExtendStack _ARGS_((Proc_LockedPCB *procPtr,
		Address address));
static void RememberSpecialSegment _ARGS_((Proc_LockedPCB *procPtr,
		VmMappedSegment *mapSegPtr));
static void UnmapPages _ARGS_((Proc_LockedPCB *procPtr, 
		VmMappedSegment *mappedSegPtr));
static ReturnStatus VmAddrRegion _ARGS_((Proc_LockedPCB *procPtr,
		Address startAddr, int *numBytesPtr,
		Vm_Segment **segPtrPtr, vm_offset_t *offsetPtr));


/*
 *----------------------------------------------------------------------
 *
 * Vm_Init --
 *
 *	Initialization for the VM module.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Varied.
 *
 *----------------------------------------------------------------------
 */

void
Vm_Init()
{
    VmSegmentInit();
    VmPagerInit();
    GetMemorySize();
}


/*
 *----------------------------------------------------------------------
 *
 * GetMemorySize --
 *
 *	Record in vmStat how much physical memory is in the system.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
GetMemorySize()
{
    kern_return_t kernStatus;
    mach_msg_type_number_t infoCount;
    struct host_basic_info hostInfo;

    infoCount = HOST_BASIC_INFO_COUNT;
    kernStatus = host_info(mach_host_self(), HOST_BASIC_INFO,
			   (host_info_t)&hostInfo, &infoCount);
    if (kernStatus != KERN_SUCCESS) {
	panic("GetMemorySize failed: %s\n",
	      mach_error_string(kernStatus));
    }
    if (infoCount != HOST_BASIC_INFO_COUNT) {
	panic("GetMemorySize: expected %d words, got %d.\n",
	      HOST_BASIC_INFO_COUNT, infoCount);
    }

    vmStat.numPhysPages = hostInfo.memory_size / vm_page_size;
}


/*
 *----------------------------------------------------------------------
 *
 * Vm_MapFile --
 *
 *	Map the named file into the given process's address space.
 *	The user can grow the file by mapping it read-write and 
 *	specifying an offset+length that go beyond the current length 
 *	of the file.
 *
 * Results:
 *	Returns a Mach status code.  Fills in a Sprite status code and 
 *	the address that the file was mapped into if successful.
 *	Returns a Sprite status code of FS_NO_ACCESS if the file is to 
 *	be mapped read-only and the given offset plus length run off
 *	the end of the file.
 *
 * Side effects:
 *	Maps the requested portion of the file into the user's address 
 *	space.
 *
 *----------------------------------------------------------------------
 */

kern_return_t
Vm_MapFile(procPtr, fileName, readOnly, offset, length, statusPtr,
	   startAddrPtr)
    Proc_ControlBlock *procPtr;	/* the user process to map the file into */
    char *fileName;		/* name of file to map */
    boolean_t readOnly;		/* map the file read-only or read-write? */
    off_t offset;		/* where in the file to start mapping. 
				 * NB: not necessarily page-aligned */
    vm_size_t length;		/* how much of the file to map */
    ReturnStatus *statusPtr;	/* OUT: Sprite return status */
    Address *startAddrPtr;	/* OUT: where file was mapped to */
{
    Vm_Segment *segmentPtr;	/* segment for the file */
    kern_return_t kernStatus = KERN_SUCCESS;
    Fs_Stream *filePtr;		/* for creating the file, if need be */

    length = round_page(length);

    /* 
     * Verify that the user has adequate access to the file.  If the 
     * file doesn't exist and the user is requesting read-write 
     * access, try to create it.
     * XXX Should be smarter about the permissions on the newly 
     * created file.
     * XXX Do we have to create the new file here, or can we let
     * Vm_GetSharedSegment do that?  (Do we care?  Maybe this call should
     * just go away.)
     */
    *statusPtr = Fs_CheckAccess(fileName,
				(readOnly ? FS_READ : FS_READ | FS_WRITE),
				TRUE);
    if ((*statusPtr == GEN_ENOENT
	 || *statusPtr == FS_FILE_NOT_FOUND)
	&& !readOnly) {
	*statusPtr = Fs_Open(fileName, FS_READ | FS_WRITE | FS_CREATE,
			     FS_FILE, 0644, &filePtr);
	if (*statusPtr == SUCCESS) {
	    (void)Fs_Close(filePtr);
	}
    }
    if (*statusPtr != SUCCESS) {
	return KERN_SUCCESS;
    }

    /* 
     * Get a segment for the file and map it into the process address 
     * space. 
     */
    *statusPtr = Vm_GetSharedSegment(fileName, &segmentPtr);
    if (*statusPtr != SUCCESS) {
	return KERN_SUCCESS;
    }
    
    *startAddrPtr = 0;
    Proc_Lock(procPtr);
    kernStatus = Vm_MapSegment(Proc_AssertLocked(procPtr), segmentPtr,
			       readOnly, TRUE, (vm_offset_t)offset, length, 
			       startAddrPtr, statusPtr);
    Proc_Unlock(Proc_AssertLocked(procPtr));
    if (kernStatus != KERN_SUCCESS || *statusPtr != SUCCESS) {
	Vm_SegmentRelease(segmentPtr);
    }

    return kernStatus;
}


/*
 *----------------------------------------------------------------------
 *
 * Vm_MapSegment --
 *
 *	Map a segment into a user process's address space.
 *
 * Results:
 *	Returns a Mach status code.  Fills in a Sprite status code and 
 *	the address that the file was mapped into if successful.
 *
 * Side effects:
 *	If successful, the requested portion of the file is mapped
 *	into the process's address space, and the reference for the
 *	segment is consumed.
 *
 *----------------------------------------------------------------------
 */

kern_return_t
Vm_MapSegment(lockedProcPtr, segPtr, readOnly, anywhere, offset, length,
	     startAddrPtr, statusPtr)
    Proc_LockedPCB *lockedProcPtr; /* the user process to map the file into */
    Vm_Segment *segPtr;		/* the segment to map */
    boolean_t readOnly;		/* map the file read-only or read-write? */
    boolean_t anywhere;		/* map the file anywhere, or at a 
				 * specific address? */
    vm_offset_t offset;		/* where in the segment to start mapping. 
				 * NB: not necessarily page-aligned */
    vm_size_t length;		/* how much of the segment to map */
    Address *startAddrPtr;	/* IN: where file should be mapped to
				 * OUT: where it was mapped to */
    ReturnStatus *statusPtr;	/* OUT: Sprite return status */
{
    vm_prot_t protectCode;	/* Mach protection code for the segment */
    kern_return_t kernStatus = KERN_SUCCESS;
    Proc_ControlBlock *procPtr = (Proc_ControlBlock *)lockedProcPtr;

    /* 
     * Set the Sprite status flag to success now, so that we don't have to 
     * remember to do it later.
     */
    *statusPtr = SUCCESS;

    protectCode = (readOnly ? VM_PROT_READ : VM_PROT_READ |
		   VM_PROT_WRITE);
    if (segPtr->type == VM_CODE) {
	protectCode |= VM_PROT_EXECUTE;
    }

    VmSegmentLock(segPtr);

    /* 
     * Check whether the segment is long enough.  If not and the mapping 
     * is read-only, return an error.  If the mapping is read-write, 
     * expand the segment. 
     */
    if (offset + length > segPtr->size) {
	if (readOnly) {
	    *statusPtr = FS_NO_ACCESS;
	    goto mapError;
	} else {
	    segPtr->size = offset + length;
	}
    }

    /* 
     * Try to map the segment into the process.
     */
    kernStatus = vm_map(procPtr->taskInfoPtr->task,
			(vm_address_t *)startAddrPtr, length, 0, anywhere,
			segPtr->requestPort, offset, FALSE, protectCode,
			protectCode, VM_INHERIT_NONE);
    if (kernStatus != KERN_SUCCESS) {
	printf("Vm_MapSegment: can't map file ``%s'' into user space: %s\n",
	       segPtr->swapFileName,
	       mach_error_string(kernStatus));
	goto mapError;
    }
    /* 
     * If this is the first usage of the segment, mark its control 
     * port so that we know the kernel has been told about it.
     */
    if (segPtr->controlPort == MACH_PORT_NULL) {
	segPtr->controlPort = MACH_PORT_DEAD;
    }


    /* 
     * Remember that the segment is used by the process.
     */
    VmSegmentUnlock(segPtr);
    NoteMappedSegment(Proc_AssertLocked(procPtr), segPtr,
		      (Address)*startAddrPtr, length);
    return KERN_SUCCESS;

 mapError:
    VmSegmentUnlock(segPtr);
    return kernStatus;
}


/*
 *----------------------------------------------------------------------
 *
 * Vm_CleanupTask --
 *
 *	Clean up VM information for a dead, locked process.  Should 
 *	only be called if the process's task is about to be nuked.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Frees the segments belonging to the process.
 *
 *----------------------------------------------------------------------
 */

void
Vm_CleanupTask(procPtr)
    Proc_LockedPCB *procPtr;	/* the dead process */
{
    Vm_ReleaseMappedSegments(procPtr);
}


/*
 *----------------------------------------------------------------------
 *
 * Vm_NewProcess --
 *
 *	Set up VM information for a new, locked process.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Initializes the list of VM segments that are mapped into the 
 *	process. 
 *
 *----------------------------------------------------------------------
 */

void
Vm_NewProcess(vmInfoPtr)
    Vm_TaskInfo *vmInfoPtr;
{
    List_Init(&vmInfoPtr->mappedListHdr);
    vmInfoPtr->execHeapPages = 0;
    vmInfoPtr->execStackPages = 0;
    vmInfoPtr->codeInfoPtr = NULL;
    vmInfoPtr->heapInfoPtr = NULL;
    vmInfoPtr->stackInfoPtr = NULL;
}


/*
 *----------------------------------------------------------------------
 *
 * Vm_ReleaseMappedSegments --
 *
 *	Release all the segments in a process's mapped segment list.  
 *	The process should already be locked.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The segments in the list are released, and memory for the list 
 *	is freed.  The memory potentially mapped by the segment is 
 *	deallocated from the process's address space (if the task isn't
 *	already gone).  The pointers to special segments for the process
 *	are cleared.
 *
 *----------------------------------------------------------------------
 */

void
Vm_ReleaseMappedSegments(procPtr)
    Proc_LockedPCB *procPtr;	/* the process that is losing the segments */
{
    List_Links *mappedSegList;
    List_Links *itemPtr;
    VmMappedSegment *mappedSegPtr;
    mach_port_t task;		/* the Mach task for the process */

    if (procPtr->pcb.taskInfoPtr == NULL) {
	printf("ReleaseMappedSegments: no task information.\n");
	return;
    }

    mappedSegList = &procPtr->pcb.taskInfoPtr->vmInfo.mappedListHdr;
    while (!List_IsEmpty(mappedSegList)) {
	itemPtr = List_First(mappedSegList);
	mappedSegPtr = (VmMappedSegment *)itemPtr;
	List_Remove(itemPtr);
	task = procPtr->pcb.taskInfoPtr->task;
	if (task != MACH_PORT_NULL) {
	    (void)vm_deallocate(task, (vm_address_t)mappedSegPtr->mappedAddr,
				mappedSegPtr->length);
	}
	Vm_SegmentRelease(mappedSegPtr->segPtr);
	ckfree(mappedSegPtr);
    }

    procPtr->pcb.taskInfoPtr->vmInfo.codeInfoPtr = NULL;
    procPtr->pcb.taskInfoPtr->vmInfo.heapInfoPtr = NULL;
    procPtr->pcb.taskInfoPtr->vmInfo.stackInfoPtr = NULL;
}


/*
 *----------------------------------------------------------------------
 *
 * Vm_CleanupSharedFile --
 *
 *	Unmap any VM_SHARED segments backed by the given file.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The segment is removed from the process's list of mapped segments.  
 *	Any memory backed by the file is unmapped from the process.
 *
 *----------------------------------------------------------------------
 */

void
Vm_CleanupSharedFile(procPtr, streamPtr)
    Proc_ControlBlock *procPtr;	/* the process to check */
    Fs_Stream *streamPtr;	/* the file to look for */
{
    List_Links *mappedSegList;
    List_Links *itemPtr;
    VmMappedSegment *mappedSegPtr;
    Vm_Segment *segPtr;
    ReturnStatus status;
    Fs_Attributes fileAttributes; /* the attributes for streamPtr */

    status = VmGetAttrStream(streamPtr, &fileAttributes);
    if (status != SUCCESS) {
	printf("Vm_CleanupSharedFile: couldn't get attributes for %s: %s\n",
	       Fsutil_GetFileName(streamPtr), Stat_GetMsg(status));
	return;
    }

    Proc_Lock(procPtr);
    if (procPtr->taskInfoPtr == NULL) {
	printf("Vm_CleanupSharedFile: no task information for process %x.\n",
	       procPtr->processID);
	goto done;
    }

    mappedSegList = &procPtr->taskInfoPtr->vmInfo.mappedListHdr;
    LIST_FORALL(mappedSegList, itemPtr) {
	mappedSegPtr = (VmMappedSegment *)itemPtr;
	segPtr = mappedSegPtr->segPtr;
	if (segPtr->swapFileNumber != fileAttributes.fileNumber
		|| segPtr->swapFileDomain != fileAttributes.domain
		|| segPtr->swapFileServer != fileAttributes.serverID) {
	    continue;
	}
	/* 
	 * Don't unmap, say, the text segment just because somebody does 
	 * "cp /sprite/cmds/cp foo".
	 */
	if (mappedSegPtr->segPtr->type != VM_SHARED) {
	    continue;
	}
	List_Remove(itemPtr);
	UnmapPages(Proc_AssertLocked(procPtr), mappedSegPtr);
	Vm_SegmentRelease(mappedSegPtr->segPtr);
	ckfree(mappedSegPtr);
    }

 done:
    Proc_Unlock(Proc_AssertLocked(procPtr));
}


/*
 *----------------------------------------------------------------------
 *
 * UnmapPages --
 *
 *	Unmap pages belonging to the given mapped segment.  This function 
 *	is needed because the address range in Vm_MappedSegment assumes 
 *	that the entire range is mapped by that segment, which is a bogus 
 *	assumption.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
UnmapPages(procPtr, mappedSegPtr)
    Proc_LockedPCB *procPtr;	/* the process to unmap from */
    VmMappedSegment *mappedSegPtr; /* the segment to unmap pages from */
{
    mach_port_t task;		/* the Mach task for the process */
    Address startAddr;		/* first potential address to unmap */
    Address endAddr;		/* last address + 1 (page) */
    vm_size_t pageSize;
    Vm_Segment *testSegPtr;	/* segment that backs a given page */
    vm_offset_t dummyOffset;	/* offset into testSegPtr; unused */
    ReturnStatus status;
    
    task = procPtr->pcb.taskInfoPtr->task;
    if (task == MACH_PORT_NULL) {
	return;
    }
    startAddr = mappedSegPtr->mappedAddr;
    endAddr = startAddr + mappedSegPtr->length;

    /* 
     * Check each page in the region to verify that it belongs to the given 
     * segment.  Probably slow, but avoids duplication of tedious code.
     */

    for (; startAddr < endAddr; startAddr += vm_page_size) {
	pageSize = vm_page_size;
	status = VmAddrRegion(procPtr, startAddr, (int *)&pageSize,
			      &testSegPtr, &dummyOffset);
	if (status != SUCCESS || testSegPtr != mappedSegPtr->segPtr) {
	    continue;
	}
	(void)vm_deallocate(task, (vm_address_t)startAddr, vm_page_size);
    }
}


/*
 *----------------------------------------------------------------------
 *
 * NoteMappedSegment --
 *
 *	Record a segment mapping for a process.  The process should be 
 *	locked. 
 *
 * Results:
 *	None.
 *
 * Side effects:
 * 	If the segment isn't already mapped into the process, adds an 
 * 	element to the per-process list of mapped segments.  Either 
 * 	way, the reference to the segment is consumed.
 *
 *----------------------------------------------------------------------
 */

static void
NoteMappedSegment(procPtr, segPtr, startAddress, length)
    Proc_LockedPCB *procPtr;	/* the process affected */
    Vm_Segment *segPtr;		/* the segment being added */
    Address startAddress;	/* where the mapping starts */
    vm_size_t length;		/* how many bytes in the mapping */
{
    VmMappedSegment *mapSegPtr;
    List_Links *segmentList = &procPtr->pcb.taskInfoPtr->vmInfo.mappedListHdr;

    /* 
     * If the segment is already mapped into the process, then we 
     * free up the given reference to the segment.  If the segment 
     * isn't already mapped, the reference goes into the 
     * VmMappedSegment structure.
     */

    mapSegPtr = FindMappedSegment(segmentList, segPtr);
    if (mapSegPtr != NULL) {
	AddMappedRange(startAddress, length, mapSegPtr);
	Vm_SegmentRelease(mapSegPtr->segPtr);
    } else {
	mapSegPtr = (VmMappedSegment *)ckalloc(sizeof(VmMappedSegment));
	if (mapSegPtr == NULL) {
	    panic("NoteMappedSegment: out of memory.\n");
	}

	List_InitElement((List_Links *)mapSegPtr);
	mapSegPtr->segPtr = segPtr;
	mapSegPtr->mappedAddr = startAddress;
	mapSegPtr->length = length;

	List_Insert((List_Links *)mapSegPtr,
		    LIST_ATREAR(segmentList));

	RememberSpecialSegment(procPtr, mapSegPtr);
    }
}


/*
 *----------------------------------------------------------------------
 *
 * FindMappedSegment --
 *
 *	Find the mapped segment structure in the given list that 
 *	refers to the given segment.
 *
 * Results:
 *	Returns a pointer to the mapped segment structure if found, 
 *	NULL if not.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static VmMappedSegment *
FindMappedSegment(segmentList, segPtr)
    List_Links *segmentList;	/* list to look in */
    Vm_Segment *segPtr;		/* the segment to find */
{
    List_Links *itemPtr;
    VmMappedSegment *mappedSegPtr;

    LIST_FORALL(segmentList, itemPtr) {
	mappedSegPtr = (VmMappedSegment *)itemPtr;
	if (mappedSegPtr->segPtr == segPtr) {
	    return mappedSegPtr;
	}
    }

    return NULL;
}


/*
 *----------------------------------------------------------------------
 *
 * AddMappedRange --
 *
 *	Update the information about how much memory is mapped by a 
 *	particular segment.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If the given range extends the range recorded for the segment, 
 *	the record range is updated.
 *
 *----------------------------------------------------------------------
 */

static void
AddMappedRange(startAddr, length, mappedSegPtr)
    Address startAddr;		/* start of new range */
    vm_size_t length;		/* number of bytes in the new range */
    VmMappedSegment *mappedSegPtr; /* structure to update (in/out) */
{
    Address oldNextAddr;	/* next address after the segment 
				 * (last address plus one) */
    Address newNextAddr;	/* new next address after the segment */

    oldNextAddr = mappedSegPtr->mappedAddr + mappedSegPtr->length;
    if (startAddr + length > oldNextAddr) {
	newNextAddr = startAddr + length;
    } else {
	newNextAddr = oldNextAddr;
    }

    if (startAddr < mappedSegPtr->mappedAddr) {
	mappedSegPtr->mappedAddr = startAddr;
    }

    mappedSegPtr->length = newNextAddr - mappedSegPtr->mappedAddr;
}


/*
 *----------------------------------------------------------------------
 *
 * RememberSpecialSegment --
 *
 *	Remember in the pcb the handle for a new code, heap, or stack 
 *	segment.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If the given segment is code, heap, or stack, sets the 
 *	corresponding pointer in the pcb.
 *
 *----------------------------------------------------------------------
 */

static void
RememberSpecialSegment(procPtr, mapSegPtr)
    Proc_LockedPCB *procPtr;	/* the process that's getting the segment */
    VmMappedSegment *mapSegPtr;	/* the segment being added to the process */
{
    switch (mapSegPtr->segPtr->type) {
    case VM_HEAP:
	if (procPtr->pcb.taskInfoPtr->vmInfo.heapInfoPtr != NULL) {
	    panic("RememberSpecialSegment: multiple heaps.\n");
	}
	procPtr->pcb.taskInfoPtr->vmInfo.heapInfoPtr = mapSegPtr;
	break;
    case VM_CODE:
	if (procPtr->pcb.taskInfoPtr->vmInfo.codeInfoPtr != NULL) {
	    panic("RememberSpecialSegment: multiple code segments.\n");
	}
	procPtr->pcb.taskInfoPtr->vmInfo.codeInfoPtr = mapSegPtr;
	break;
    case VM_STACK:
	if (procPtr->pcb.taskInfoPtr->vmInfo.stackInfoPtr != NULL) {
	    panic("RememberSpecialSegment: multiple stacks.\n");
	}
	procPtr->pcb.taskInfoPtr->vmInfo.stackInfoPtr = mapSegPtr;
	break;
    }
}


/*
 *----------------------------------------------------------------------
 *
 * Vm_ExtendStack --
 *
 * 	Try to extend the process's stack to include the given address.
 *
 * Results:
 * 	Returns SUCCESS if we were able to extend the stack.
 *
 * Side effects:
 *	If successful, the process's stack segment is mapped to cover 
 *	all pages between the current stack and the page containing 
 *	"address". 
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Vm_ExtendStack(lockedProcPtr, address)
    Proc_LockedPCB *lockedProcPtr; /* the process to look at */
    Address address;		/* the address to include */
{
    Proc_ControlBlock *procPtr = (Proc_ControlBlock *)lockedProcPtr;
    Address mapAddr;		/* where to start the new mapping */
    vm_offset_t segOffset;	/* offset for mapAddr */
    vm_size_t newMapLength;	/* bytes in new mapping */
    VmMappedSegment *stackInfoPtr; /* handle on the stack segment */
    kern_return_t kernStatus;
    ReturnStatus status = SUCCESS;
    
    stackInfoPtr = procPtr->taskInfoPtr->vmInfo.stackInfoPtr;
    if (stackInfoPtr == NULL) {
	panic("Vm_ExtendStack: no stack.\n");
    }
    if (!OkayToExtendStack(Proc_AssertLocked(procPtr), address)) {
	return FAILURE;
    }

    /* 
     * Vm_MapSegment consumes a reference to the segment if it 
     * succeeds, so get an additional reference to the segment.
     */
    Vm_SegmentAddRef(stackInfoPtr->segPtr);

    mapAddr = Vm_TruncPage(address);
    segOffset = GetStackOffset(stackInfoPtr, mapAddr);
    newMapLength = stackInfoPtr->mappedAddr - mapAddr;
    kernStatus = Vm_MapSegment(Proc_AssertLocked(procPtr),
			       stackInfoPtr->segPtr, FALSE, FALSE,
			       segOffset, newMapLength, &mapAddr, &status);
    if (kernStatus != KERN_SUCCESS) {
	printf("Vm_ExtendStack: couldn't map new region: %s\n",
	       mach_error_string(kernStatus));
	status = Utils_MapMachStatus(kernStatus);
    }
    if (status != SUCCESS) {
	Vm_SegmentRelease(stackInfoPtr->segPtr);
    }

    /* 
     * If the kernel successfully mapped the range, but not where we 
     * asked it to, it means either that (1) we screwed up or (2) the 
     * process has been talking to non-Sprite external pagers.  So 
     * complain, but don't panic.
     */
    if (status == SUCCESS && mapAddr != Vm_TruncPage(address)) {
	printf("Vm_ExtendStack: kernel mapped at 0x%x",
	       mapAddr);
	printf(", we wanted 0x%x\n", Vm_TruncPage(address));
	kernStatus = vm_deallocate(procPtr->taskInfoPtr->task,
				   (vm_address_t)mapAddr, newMapLength);
	if (kernStatus != KERN_SUCCESS) {
	    panic("Vm_ExtendStack: couldn't deallocate region: %s\n",
		   mach_error_string(kernStatus));
	}
	status = FAILURE;
    }

    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * OkayToExtendStack --
 *
 *	Check whether it's okay to extend the stack segment of the 
 *	given process to include the given address.
 *
 * Results:
 *	TRUE if it's okay, FALSE if not.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Boolean
OkayToExtendStack(lockedProcPtr, address)
    Proc_LockedPCB *lockedProcPtr; /* the process to check */
    Address address;		/* the address we'd like to put into 
				 * the stack */
{
    Proc_ControlBlock *procPtr = (Proc_ControlBlock *)lockedProcPtr;
    VmMappedSegment *stackInfoPtr; /* info about the process's stack */
    Address stackBottom;	/* current boundary address for the stack */
    Address pastStack;		/* last addr. plus one for stack */
    List_Links *itemPtr;
    VmMappedSegment *mappedSegPtr;
    Address segTop;		/* last address mapped in a segment */

    stackInfoPtr = procPtr->taskInfoPtr->vmInfo.stackInfoPtr;
    stackBottom = stackInfoPtr->mappedAddr;
    pastStack = stackInfoPtr->mappedAddr + stackInfoPtr->length;

    /* 
     * We shouldn't get an exception for addresses that are already 
     * mapped by the stack.
     */
    if (stackBottom <= address && address <= pastStack - sizeof(long)) {
	panic("OkayToExtendStack: the address is already in the stack.\n");
    }

    /*
     * We can't (or won't) extend the stack if 
     * - the faulting address runs past the high end of the stack.  (We 
     *   verified above that the address isn't in the stack.  If it's 
     *   not below the stack, it must be above the stack).
     * - the faulting address is too far below the stack.
     * - the faulting address can't possibly be in the stack because 
     *   it's lower than the lowest possible stack address.
     */
    if (stackBottom <= address) {
	return FALSE;
    }
    if (stackBottom - address > VM_STACK_MAX_DISTANCE) {
	return FALSE;
    }
    if (address < stackInfoPtr->segPtr->typeInfo.stackInfo.baseAddr) {
	return FALSE;
    }

    /* 
     * Walk through the list of mapped segments.  If there are any 
     * segments between "address" and the current stack, the stack 
     * can't be extended.  I suppose we could assume that no segments 
     * appear at addresses above the stack, but it's cheap to not make 
     * that assumption.
     */
    
    LIST_FORALL(&procPtr->taskInfoPtr->vmInfo.mappedListHdr, itemPtr) {
	mappedSegPtr = (VmMappedSegment *)itemPtr;
	segTop = mappedSegPtr->mappedAddr + mappedSegPtr->length - 1;
	if (address <= segTop && segTop < stackBottom) {
	    return FALSE;
	}
    }

    return TRUE;
}


/*
 *----------------------------------------------------------------------
 *
 * GetStackOffset --
 *
 *	Convert an address in a process to the offset in the process's 
 *	stack segment.  The process should be locked.
 *
 * Results:
 *	Returns the offset for the page containing the address.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static vm_offset_t
GetStackOffset(stackInfoPtr, address)
    VmMappedSegment *stackInfoPtr; /* handle on the stack */
    Address address;		/* the address in memory; should be in 
				 * range of the stack */
{
    Address stackBase;		/* lowest possible address for the stack */

    /* 
     * The address should be page-aligned already, but in case it 
     * isn't... 
     */
    address = Vm_TruncPage(address);

    stackBase = stackInfoPtr->segPtr->typeInfo.stackInfo.baseAddr;
    if (address < stackBase) {
	panic("GetStackOffset: address not in stack.\n");
    }
    
    return address - stackBase;
}


/*
 *----------------------------------------------------------------------
 *
 * VmAddrParse --
 *
 *	"parse" an address into a segment and an offset in the segment.  
 *	The name derives from the routine VmVirtAddrParse in native Sprite, 
 *	which performs a similar function.
 *
 * Results:
 *	Returns a status code.  If successful, segment pointer and offset 
 *	are filled in.  If the given range falls off the end of the 
 *	segment, the byte count is truncated to give the actual number of 
 *	bytes available.  VM_NO_SEGMENTS means that the given address 
 *	isn't mapped (XXX maybe a new VM_NOT_MAPPED status code would be 
 *	better?).  VM_SEG_NOT_FOUND means that the address is mapped,
 *	but the memory object for it isn't a Sprite VM segment.
 *	Note: this is the same as VmAddrRegion.
 *
 * Side effects:
 *	If successful, the reference count on the segment pointer is 
 *	incremented (the caller is responsible for freeing it).
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
VmAddrParse(procPtr, startAddr, numBytesPtr, segPtrPtr, offsetPtr)
    Proc_ControlBlock *procPtr;	/* the process to do the lookup for */
    Address startAddr;		/* the address to check */
    int *numBytesPtr;		/* IN: the number of bytes to check.
				 * OUT: the number of bytes available */
    Vm_Segment **segPtrPtr;	/* OUT: the segment that startAddr falls in */
    vm_offset_t *offsetPtr;	/* OUT: the segment offset for startAddr */
{
    int currBytes;		/* number of bytes in current region */
    vm_offset_t currOffset;	/* offset for current region */
    vm_offset_t expectedOffset = 0; /* expected offset for current region */
    Vm_Segment *segPtr;		/* segment for the current region */
    int totalBytes;		/* total number of bytes found */
    ReturnStatus status;

    /* 
     * Map the given address to a segment, if possible.  Mach may have 
     * broken the requested memory range into multiple regions, all 
     * referring to successive portions of the same segment.  So if our 
     * first attempt doesn't map the entire requested range, try again.
     */

    *segPtrPtr = segPtr = NULL;
    totalBytes = 0;
    Proc_Lock(procPtr);

    while (totalBytes < *numBytesPtr) {
	/* 
	 * Compute the number of bytes we're still trying to map.
	 */
	currBytes = *numBytesPtr - totalBytes;
	status = VmAddrRegion(Proc_AssertLocked(procPtr), startAddr,
			      &currBytes, &segPtr, &currOffset);
	/* 
	 * If we didn't find anything, punt.
	 */
	if (status != SUCCESS && *segPtrPtr == NULL) {
	    Proc_Unlock(Proc_AssertLocked(procPtr));
	    return status;
	}
	/* 
	 * If this is the first time through the loop, record the starting 
	 * offset, the winning segment, and the size of the region.
	 * 
	 * Otherwise, see if we've reached unmapped memory or have bumped
	 * into a different segment (or a non-contiguous range of the
	 * current segment).  In these cases, return what we've got.
	 * 
	 * Otherwise, we've found a continuation of the current segment:
	 * update the number of bytes found and repeat.
	 */
	if (*segPtrPtr == NULL) {
	    *offsetPtr = currOffset;
	    expectedOffset = currOffset + currBytes;
	    *segPtrPtr = segPtr;
	    Vm_SegmentAddRef(segPtr);
	    totalBytes = currBytes;
	} else if (status != SUCCESS) {
	    break;
	} else if (segPtr != *segPtrPtr || currOffset != expectedOffset) {
	    break;
	} else {
	    expectedOffset += currBytes;
	    totalBytes += currBytes;
	}

	startAddr += currBytes;
    }

    Proc_Unlock(Proc_AssertLocked(procPtr));
    if (totalBytes < *numBytesPtr) {
	*numBytesPtr = totalBytes;
    }
    return SUCCESS;
}


/*
 *----------------------------------------------------------------------
 *
 * VmAddrRegion --
 *
 * 	Helper routine for VmAddrParse.  Find the segment and offset for 
 * 	the given user address, but don't worry about whether there are 
 * 	multiple regions.
 *
 * Results:
 *	Same as VmAddrParse.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
VmAddrRegion(procPtr, startAddr, numBytesPtr, segPtrPtr, offsetPtr)
    Proc_LockedPCB *procPtr;	/* the process to do the lookup for */
    Address startAddr;		/* the address to check */
    int *numBytesPtr;		/* IN: the number of bytes to check.
				 * OUT: the number of bytes available */
    Vm_Segment **segPtrPtr;	/* OUT: the segment that startAddr falls in */
    vm_offset_t *offsetPtr;	/* OUT: the segment offset for startAddr */
{
    VmMappedSegment *mappedSegPtr = NULL; /* mapped segment in the process */
    vm_size_t regionSize;	/* number of bytes in region */
    memory_object_name_t segmentName; /* name port for the region's segment */
    Address regionStartAddr;	/* where the region actually starts */
    vm_offset_t regionOffset;	/* offset in segment for start of region */
    vm_prot_t protection;	/* ignored */
    vm_prot_t maxProtection;	/* ignored */
    vm_inherit_t inheritance;	/* ignored */
    Boolean shared;		/* ignored */
    kern_return_t kernStatus;
    ReturnStatus status = SUCCESS;
    Address touchPage;		/* if we force the segment to be
				 * initialized, this is what vm_read gives */  
    vm_size_t touchPageSize;	/* number of bytes in touchPage */
    int junk;

    /* 
     * Ask Mach what segment the address is in.  Then check whether any of 
     * the process's mapped segments match the one Mach returned to us.  
     */
    
    regionStartAddr = startAddr;
    kernStatus = vm_region(procPtr->pcb.taskInfoPtr->task,
			   (vm_address_t *)&regionStartAddr, &regionSize,
			   &protection, &maxProtection, &inheritance, &shared, 
			   &segmentName, &regionOffset);
    if (kernStatus == KERN_NO_SPACE) {
	status = VM_NO_SEGMENTS;
	goto done;
    }
    /* 
     * Check whether the region found is the region we actually asked for.
     */
    if (regionStartAddr > startAddr) {
	status = VM_NO_SEGMENTS;
	goto done;
    }

    mappedSegPtr = VmSegByName((List_Links *)&procPtr->pcb.taskInfoPtr->
				         vmInfo.mappedListHdr,
			       segmentName);
    if (mappedSegPtr == NULL) {
	/* 
	 * We couldn't find a matching segment, but maybe that's because
	 * the segment hasn't been fully initialized.  Try reading from the
	 * requested address, to force the segment to be initialized.
	 */
	(void)vm_read(procPtr->pcb.taskInfoPtr->task,
		      (vm_address_t)regionStartAddr, vm_page_size,
		      (pointer_t *)&touchPage,
		      (mach_msg_type_number_t *)&touchPageSize);
	junk = *(int *)touchPage;
#ifdef lint
	junk = junk;
#endif
	vm_deallocate(mach_task_self(), (vm_address_t)touchPage,
		      touchPageSize);
	mappedSegPtr = VmSegByName((List_Links *)&procPtr->pcb.taskInfoPtr->
				         vmInfo.mappedListHdr,
				   segmentName);
	if (mappedSegPtr != NULL) {
	    vmStat.forcedInits++;
	} else {
	    status = VM_SEG_NOT_FOUND;
	    goto done;
	}
    }

    *segPtrPtr = mappedSegPtr->segPtr;

    if (startAddr + *numBytesPtr > regionStartAddr + regionSize) {
	*numBytesPtr = regionStartAddr + regionSize - startAddr;
    }

    *offsetPtr = (vm_offset_t)(startAddr - regionStartAddr) + regionOffset;

 done:
    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * Vm_Fork --
 *
 *	Copy the VM of the parent process to the child.
 *
 * Results:
 *	Returns a status code.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Vm_Fork(procPtr, parentProcPtr)
    Proc_ControlBlock *procPtr;	/* the process to get the new VM */
    Proc_ControlBlock *parentProcPtr; /* the process to copy it from */
{
    ReturnStatus status = SUCCESS;
    kern_return_t kernStatus;
    Address addr;		/* address used to walk through the parent */
    Address regionAddr;		/* starting address of a region */
    mach_port_t segmentName;	/* name port for a region's segment */
    vm_prot_t protection;	/* protection on the region */
    vm_prot_t maxProtection;	/* maximum protection on the region */
    vm_size_t regionSize;	/* number of bytes in the region */
    vm_inherit_t inheritance;	/* inheritance code for the region */
    boolean_t shared;		/* is the region shared? */
    vm_offset_t offset;		/* region's starting offset in its segment */
    VmMappedSegment *parentHeapPtr; /* parent process's heap */
    Vm_Segment *childHeapPtr;	/* child process's heap */
    VmMappedSegment *parentStackPtr; /* parent process's stack segment */
    Vm_Segment *childStackPtr;	/* child process's stack segment */
    VmMappedSegment *mappedSegPtr; /* mapped segment in the parent */
    Vm_Segment *segPtr;		/* segment to map into the child */
    Boolean suspended = FALSE;	/* did we suspend the parent's task? */
    Time startTime, endTime, totalTime;	/* instrumentation */
    Time startSubstep, endSubstep;

    parentHeapPtr = NULL;	/* lint */
    parentStackPtr = NULL;

    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }

    Proc_Lock(parentProcPtr);
    Proc_Lock(procPtr);

    if (parentProcPtr->taskInfoPtr == NULL) {
	status = VM_CORRUPTED;
	goto bailOut;
    }
    parentHeapPtr = parentProcPtr->taskInfoPtr->vmInfo.heapInfoPtr;
    parentStackPtr = parentProcPtr->taskInfoPtr->vmInfo.stackInfoPtr;
    if (parentHeapPtr == NULL) {
	printf("Vm_Fork: process %x doesn't have a heap.\n",
	       parentProcPtr->processID);
	status = VM_CORRUPTED;
	goto bailOut;
    }
    if (parentStackPtr == NULL) {
	printf("Vm_Fork: process %x doesn't have a stack.\n",
	       parentProcPtr->processID);
	status = VM_CORRUPTED;
	goto bailOut;
    }
    childHeapPtr = NULL;
    childStackPtr = NULL;

    /* 
     * Suspend the parent's task, so that other threads in it don't make 
     * any changes while we're working.
     */
    kernStatus = task_suspend(parentProcPtr->taskInfoPtr->task);
    if (kernStatus != KERN_SUCCESS) {
	status = Utils_MapMachStatus(kernStatus);
	goto bailOut;
    }
    suspended = TRUE;

    /* 
     * Walk through the parent process's VM.  For every region, find the 
     * mapped Sprite segment and set up a corresponding region in the
     * child.
     */
    
    addr = 0;
    while (addr < procMach_MaxUserAddr) {
	regionAddr = addr;
	if (sys_CallProfiling) {
	    Timer_GetTimeOfDay(&startSubstep, (int *)NULL, (Boolean *)NULL);
	} else {
	    startSubstep = time_ZeroSeconds;
	}
	kernStatus = vm_region(parentProcPtr->taskInfoPtr->task,
			       (vm_address_t *)&regionAddr, &regionSize,
			       &protection, &maxProtection, &inheritance,
			       &shared, &segmentName, &offset);
	if (sys_CallProfiling && !Time_EQ(startSubstep, time_ZeroSeconds)) {
	    Timer_GetTimeOfDay(&endSubstep, (int *)NULL, (Boolean *)NULL);
	    Time_Subtract(endSubstep, startSubstep, &endSubstep);
	    Time_Add(endSubstep, vmStat.findRegionTime,
		     &vmStat.findRegionTime);
	}
	/* 
	 * If there aren't any more mapped regions, we're done.
	 */
	if (kernStatus == KERN_NO_SPACE) {
	    break;
	}
	if (sys_CallProfiling) {
	    Timer_GetTimeOfDay(&startSubstep, (int *)NULL, (Boolean *)NULL);
	} else {
	    startSubstep = time_ZeroSeconds;
	}
	mappedSegPtr = VmSegByName((List_Links *)&parentProcPtr->
				       taskInfoPtr->vmInfo.mappedListHdr,
				   segmentName);
	if (sys_CallProfiling && !Time_EQ(startSubstep, time_ZeroSeconds)) {
	    Timer_GetTimeOfDay(&endSubstep, (int *)NULL, (Boolean *)NULL);
	    Time_Subtract(endSubstep, startSubstep, &endSubstep);
	    Time_Add(endSubstep, vmStat.segLookupTime,
		     &vmStat.segLookupTime);
	}
	/* 
	 * If the region isn't mapped by a Sprite segment, complain and let 
	 * the user program deal with it.  Otherwise, map the segment into 
	 * the child process.  If it's a heap or stack segment, map a new 
	 * segment rather than the parent's segment, and copy the bits from
	 * the parent to the child.
	 */
	if (mappedSegPtr == NULL) {
	    printf("Vm_Fork: unrecognized segment in process %x, ",
		   parentProcPtr->processID);
	    printf("addresses [0x%x..0x%x)\n", regionAddr,
		   regionAddr + regionSize);
	} else {
	    segPtr = mappedSegPtr->segPtr;
	    if (sys_CallProfiling) {
		Timer_GetTimeOfDay(&startSubstep, (int *)NULL,
				   (Boolean *)NULL); 
	    } else {
		startSubstep = time_ZeroSeconds;
	    }
	    if (segPtr == parentHeapPtr->segPtr) {
		if (childHeapPtr == NULL) {
		    status = VmSegmentCopy(parentHeapPtr, &childHeapPtr);
		}
		segPtr = childHeapPtr;
	    } else if (segPtr == parentStackPtr->segPtr) {
		if (childStackPtr == NULL) {
		    status = VmSegmentCopy(parentStackPtr, &childStackPtr);
		}
		segPtr = childStackPtr;
	    }
	    if (sys_CallProfiling &&
		!Time_EQ(startSubstep, time_ZeroSeconds)) {
		Timer_GetTimeOfDay(&endSubstep, (int *)NULL, (Boolean *)NULL);
		Time_Subtract(endSubstep, startSubstep, &endSubstep);
		Time_Add(endSubstep, vmStat.segCopyTime,
			 &vmStat.segCopyTime);
	    }
	    if (status == SUCCESS) {
		status = MapIntoProcess(Proc_AssertLocked(procPtr), segPtr,
					offset, regionSize, regionAddr,
					protection);
		if (status != SUCCESS) {
		    printf("%s: couldn't map region [0x%x..0x%x) into pid %x:",
			   "Vm_Fork", regionAddr, regionAddr+regionSize, 
			   procPtr->processID);
		    printf(" %s\n", Stat_GetMsg(status));
		}
	    }
	    if (status == SUCCESS &&
		(segPtr->type == VM_HEAP || segPtr->type == VM_STACK)) {
		if (sys_CallProfiling) {
		    Timer_GetTimeOfDay(&startSubstep, (int *)NULL,
				       (Boolean *)NULL);
		} else {
		    startSubstep = time_ZeroSeconds;
		}
		status = CopyRegion(Proc_AssertLocked(parentProcPtr),
				    Proc_AssertLocked(procPtr), regionSize,
				    regionAddr);
		if (sys_CallProfiling &&
		    !Time_EQ(startSubstep, time_ZeroSeconds)) {
		    Timer_GetTimeOfDay(&endSubstep, (int *)NULL,
				       (Boolean *)NULL);
		    Time_Subtract(endSubstep, startSubstep, &endSubstep);
		    Time_Add(endSubstep, vmStat.regionCopyTime,
			     &vmStat.regionCopyTime);
		}
		if (status == SUCCESS) {
		    vmStat.pagesCopied += regionSize / vm_page_size;
		} else {
		    printf("Vm_Fork: couldn't copy region [0x%x..0x%x) from ",
			   regionAddr, regionAddr+regionSize);
		    printf("parent %x to child %x: %s\n",
			   parentProcPtr->processID, procPtr->processID,
			   Stat_GetMsg(status));
		}
	    }
	}

	if (status != SUCCESS) {
	    break;
	}
	addr = regionAddr + regionSize;
    }

    /* 
     * When we created the child's heap and stack segments, we were given 
     * references that we now need to free (MapIntoProcess made its own 
     * reference). 
     */
    if (childHeapPtr != NULL) {
	VmSegmentLock(childHeapPtr);
	childHeapPtr->flags &= ~VM_COPY_TARGET;
	VmSegmentUnlock(childHeapPtr);
	Vm_SegmentRelease(childHeapPtr);
	childHeapPtr = NULL;
    }
    if (childStackPtr != NULL) {
	VmSegmentLock(childStackPtr);
	childStackPtr->flags &= ~VM_COPY_TARGET;
	VmSegmentUnlock(childStackPtr);
	Vm_SegmentRelease(childStackPtr);
	childStackPtr = NULL;
    }
    VmSegmentLock(parentHeapPtr->segPtr);
    parentHeapPtr->segPtr->flags &= ~VM_COPY_SOURCE;
    VmSegmentUnlock(parentHeapPtr->segPtr);
    VmSegmentLock(parentStackPtr->segPtr);
    parentStackPtr->segPtr->flags &= ~VM_COPY_SOURCE;
    VmSegmentUnlock(parentStackPtr->segPtr);

    /* 
     * Verify that we were able to set up the minimum VM information.
     */
    if (status == SUCCESS &&
	    (procPtr->taskInfoPtr->vmInfo.codeInfoPtr == NULL ||
	     procPtr->taskInfoPtr->vmInfo.heapInfoPtr == NULL ||
	     procPtr->taskInfoPtr->vmInfo.stackInfoPtr == NULL)) {
	printf("Vm_Fork: missing segment(s) from pid %x.\n",
	       parentProcPtr->processID);
	status = VM_CORRUPTED;
	goto bailOut;
    }

    if (status == SUCCESS && sys_CallProfiling &&
	!Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &totalTime);
	Time_Add(vmStat.forkTime, totalTime, &vmStat.forkTime);
    }

 bailOut:
    if (suspended) {
	(void)task_resume(parentProcPtr->taskInfoPtr->task);
    }
    Proc_Unlock(Proc_AssertLocked(parentProcPtr));
    Proc_Unlock(Proc_AssertLocked(procPtr));
    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * MapIntoProcess --
 *
 *	Map the given segment into the given process.
 *
 * Results:
 *	Returns a status code.  Note that the segment may be mapped into 
 *	the process even if the return status isn't SUCCESS.
 *
 * Side effects:
 *	If the segment is mapped, its reference count is increased.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
MapIntoProcess(procPtr, segPtr, offset, numBytes, mapAddr, protection)
    Proc_LockedPCB *procPtr;	/* the process to get the new mapping */
    Vm_Segment *segPtr;		/* the segment to map in */ 
    vm_offset_t offset;		/* the segment offset to start mapping at */
    vm_size_t numBytes;		/* the number of bytes to map */
    Address mapAddr;		/* the address to start mapping at */
    vm_prot_t protection;	/* the desired protection level */
{
    Address resultAddr;		/* the address actually mapped at */
    ReturnStatus status;
    kern_return_t kernStatus;

    Vm_SegmentAddRef(segPtr);
    resultAddr = mapAddr;
    kernStatus = Vm_MapSegment(procPtr, segPtr, !(protection & VM_PROT_WRITE),
			       FALSE, offset, numBytes, &resultAddr, &status);
    if (kernStatus != KERN_SUCCESS) {
	status = Utils_MapMachStatus(kernStatus);
    }
    if (status != SUCCESS) {
	Vm_SegmentRelease(segPtr);
	return status;
    }
    if (resultAddr != mapAddr) {
	printf("%s: didn't get requested address for pid %x.\n",
	       "MapIntoProcess", procPtr->pcb.processID);
	return VM_CORRUPTED;
    }

    return SUCCESS;
}


/*
 *----------------------------------------------------------------------
 *
 * CopyRegion --
 *
 *	Copy the given region from one user process to another.
 *
 * Results:
 *	Returns a Sprite status code.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
CopyRegion(fromProcPtr, toProcPtr, regionSize, regionAddr)
    Proc_LockedPCB *fromProcPtr; /* the process to copy from */
    Proc_LockedPCB *toProcPtr;	/* the process to copy to */
    vm_size_t regionSize;	/* the number of bytes to copy */
    Address regionAddr;		/* where to start copying */
{
    kern_return_t kernStatus;
    vm_address_t copyBuffer;
    mach_msg_type_number_t copyCount;
    ReturnStatus status = SUCCESS;

    if (regionAddr != Vm_TruncPage(regionAddr)) {
	panic("CopyRegion: address 0x%x not page-aligned.\n",
	      regionAddr);
    }
    if (regionSize != trunc_page(regionSize)) {
	panic("CopyRegion: copy size 0x%x not page-aligned.\n",
	      regionSize);
    }

    kernStatus = vm_read(fromProcPtr->pcb.taskInfoPtr->task,
			 (vm_address_t)regionAddr, regionSize, &copyBuffer,
			 &copyCount);
    if (kernStatus != KERN_SUCCESS) {
	printf("CopyRegion: couldn't read region at 0x%x: %s\n",
	       regionAddr, mach_error_string(kernStatus));
	return Utils_MapMachStatus(kernStatus);
    }
    if (copyCount != regionSize) {
	panic("CopyRegion: expected 0x%x bytes, got 0x%x.\n",
	      regionSize, copyCount);
    }

    kernStatus = vm_write(toProcPtr->pcb.taskInfoPtr->task,
			  (vm_address_t)regionAddr, copyBuffer, copyCount);
    if (kernStatus != KERN_SUCCESS) {
	printf("CopyRegion: couldn't write region at 0x%x: %s\n",
	       regionAddr, mach_error_string(kernStatus));
	status = Utils_MapMachStatus(kernStatus);
    }
    (void)vm_deallocate(mach_task_self(), copyBuffer, copyCount);

    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * VmSegByName --
 *
 *	Look in a list of mapped segments for the one with the given Mach
 *	name port.  The process that owns this list should be locked.
 *
 * Results:
 *	Returns a mapped segment handle from the given list, or NULL if the 
 *	segment couldn't be found.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

VmMappedSegment *
VmSegByName(segmentList, segmentName)
    List_Links *segmentList;	/* list to look in */
    mach_port_t segmentName;	/* name of desired segment */
{
    List_Links *itemPtr;
    VmMappedSegment *mappedSegPtr;

    LIST_FORALL(segmentList, itemPtr) {
	mappedSegPtr = (VmMappedSegment *)itemPtr;
	if (mappedSegPtr->segPtr->namePort == segmentName) {
	    return mappedSegPtr;
	}
    }

    return NULL;
}


/*
 *----------------------------------------------------------------------
 *
 * Vm_CreateVA --
 *
 *	Validate a range of user addresses.  If necessary, map in the heap 
 *	segment at those addresses.
 *
 * Results:
 *	Returns VM_WRONG_SEG_TYPE if some part of the address range belongs
 *	to some segment other than the heap (or a non-Sprite memory
 *	object).  Otherwise returns SUCCESS.
 *
 * Side effects:
 *	Might allocate some memory even if a failure code is returned.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Vm_CreateVA(startAddr, requestedBytes)
    Address startAddr;		/* Address to validate from. */
    vm_size_t requestedBytes;	/* Number of bytes to validate. */
{
    Address currAddr;		/* start of current region */
    vm_size_t numBytes;		/* number of bytes in current region */
    vm_size_t bytesLeft;	/* number of bytes left to check */
    Vm_Segment *segPtr;		/* segment for current region */
    Vm_Segment *heapPtr;	/* the process's heap segment */
    VmMappedSegment *heapInfoPtr;
    vm_offset_t offset;		/* offset into heap for current address */
    ReturnStatus status = SUCCESS;
    Proc_ControlBlock *procPtr;

    procPtr = Proc_GetCurrentProc();
    heapInfoPtr = procPtr->taskInfoPtr->vmInfo.heapInfoPtr;
    heapPtr = heapInfoPtr->segPtr;

    /* 
     * Verify that the requested range of addresses is at least potentially 
     * in the heap.
     */
    if (startAddr < heapInfoPtr->mappedAddr ||
	startAddr + requestedBytes > (heapInfoPtr->mappedAddr +
				      heapPtr->size)) {
	return VM_WRONG_SEG_TYPE;
    }

    currAddr = Vm_TruncPage(startAddr);
    bytesLeft = Vm_RoundPage(startAddr + requestedBytes) - currAddr;

    /* 
     * Portions of the requested region might already be mapped, with other 
     * portions unmapped.  So do this in a loop.  We'll go region-by-region
     * through the requested address range, with currAddr pointing to the
     * start of the region.
     */
    
    do {
	numBytes = bytesLeft;
	status = VmAddrParse(procPtr, currAddr, (int *)&numBytes, &segPtr,
			     &offset);
	switch (status) {
	case SUCCESS:
	    /* 
	     * The region is already mapped.  Verify that it's mapped by 
	     * the heap, and move on to the next region.
	     */
	    Vm_SegmentRelease(segPtr);
	    if (segPtr == heapPtr) {
		bytesLeft -= numBytes;
		currAddr += numBytes;
	    } else {
		status = VM_WRONG_SEG_TYPE;
		printf("Vm_CreateVA: wrong segment at address 0x%x: %s\n",
		       currAddr, Vm_SegmentName(segPtr)); /* DEBUG */
		printf("Segment type is %d\n", segPtr->type); /* DEBUG */
	    }
	    break;
	case VM_SEG_NOT_FOUND:
	    /* 
	     * The region is mapped, but not by a Sprite segment.
	     */
	    printf("Vm_CreateVA: address 0x%x is mapped by non-Sprite seg.\n",
		   currAddr);	/* DEBUG */
	    status = VM_WRONG_SEG_TYPE;
	    break;
	case VM_NO_SEGMENTS:
	    /* 
	     * The region is unmapped.  Map in one page of the heap and 
	     * move along.
	     */
	    status = MapHeapPage(procPtr, currAddr, heapInfoPtr);
	    if (status == SUCCESS) {
		currAddr += vm_page_size;
		bytesLeft -= vm_page_size;
	    }
	    if (status != SUCCESS) {
		printf("Vm_CreateVA: couldn't map heap page at 0x%x\n",
		       currAddr); /* DEBUG */
	    }
	    break;
	}
    } while (status == SUCCESS && currAddr < startAddr + requestedBytes);

    if (status != SUCCESS) {
	printf("Vm_CreateVA(0x%x, 0x%x) failed: %s\n",
	       startAddr, requestedBytes, Stat_GetMsg(status)); /* DEBUG */
    }
    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * MapHeapPage --
 *
 *	Map one page from the heap starting at the given user address.
 *
 * Results:
 *	Returns SUCCESS if it worked, some failure code if it didn't.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
MapHeapPage(procPtr, address, heapInfoPtr)
    Proc_ControlBlock *procPtr;	/* user process to get the new mapping */
    Address address;		/* where to map it */
    VmMappedSegment *heapInfoPtr; /* the user process's heap */
{
    Address resultAddr;		/* where the page actually got mapped to */
    vm_offset_t offset;		/* offset into the heap */
    kern_return_t kernStatus;
    ReturnStatus status = SUCCESS;

    /* 
     * Vm_MapSegment consumes a reference to the segment if it 
     * succeeds, so get an additional reference to the segment.
     */
    Vm_SegmentAddRef(heapInfoPtr->segPtr);

    resultAddr = address;
    offset = address - heapInfoPtr->mappedAddr;

    Proc_Lock(procPtr);
    kernStatus = Vm_MapSegment(Proc_AssertLocked(procPtr),
			       heapInfoPtr->segPtr, FALSE, FALSE,
			       offset, vm_page_size, &resultAddr, &status);
    Proc_Unlock(Proc_AssertLocked(procPtr));
    if (kernStatus != KERN_SUCCESS) {
	printf("MapHeap: couldn't map new page: %s\n",
	       mach_error_string(kernStatus)); /* DEBUG */
	status = Utils_MapMachStatus(kernStatus);
    }
    if (status != SUCCESS) {
	Vm_SegmentRelease(heapInfoPtr->segPtr);
    }
    if (status == SUCCESS && resultAddr != address) {
	panic("MapHeap: Vm_MapSegment lied when it said it had succeeded.\n");
    }

    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * VmGetAttrStream --
 *
 *	Like Fs_GetAttrStream, but retries in case of RPC errors.
 *
 * Results:
 *	See Fs_GetAttrStream.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
VmGetAttrStream(streamPtr, attrPtr)
    Fs_Stream *streamPtr;	/* the stream we want attributes for */
    Fs_Attributes *attrPtr;	/* OUT: the stream's attributes */
{
    Boolean retry;
    ReturnStatus status;

    do {
	retry = FALSE;
	status = Fs_GetAttrStream(streamPtr, attrPtr);
	if (status != SUCCESS && !sys_ShuttingDown
		&& Fsutil_RecoverableError(status)) {
	    status = Fsutil_WaitForHost(streamPtr, 0, status);
	    if (status == SUCCESS) {
		retry = TRUE;
	    } else {
		printf("VmGetAttrStream: recovery failed for %s: %s\n",
		       Fsutil_GetFileName(streamPtr),
		       Stat_GetMsg(status));   
	    }
	}
    } while (retry);

    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * Vm_Cmd --
 *
 *	Random VM-related operations made available to user programs.
 *
 * Results:
 *	SYS_ARG_NOACCESS: the given argument refers to inaccessible user 
 *	    memory.
 *	GEN_INVALID_ARG: the given command was unrecognized.
 *
 * Side effects:
 *	Depends on the command.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Vm_Cmd(command, length, arg)
    int command;		/* what command */
    vm_size_t length;		/* buffer size, if needed */
    Address arg;		/* additional information for the command */
{
    ReturnStatus status = SUCCESS;
    int numPhysPages;

    switch (command) {
    case VM_GET_STATS: {
	if (length > sizeof(vmStat)) {
	    length = sizeof(vmStat);
	}
	status = Vm_CopyOut(length, (Address)&vmStat, arg);
	break;
    }
    case VM_CLEAR_COUNTERS:
	numPhysPages = vmStat.numPhysPages;
	bzero(&vmStat, sizeof(vmStat));
	vmStat.numPhysPages = numPhysPages;
	break;
#ifndef CLEAN
    case VM_DO_COPY_IN:
    case VM_DO_COPY_OUT:
	status = CopyInOutTest(command, length, arg);
	break;
    case VM_DO_MAKE_ACCESS_IN:
    case VM_DO_MAKE_ACCESS_OUT:
	status = MakeAccessibleTest(command, length, arg);
	break;
#endif /* CLEAN */
    default:
	status = GEN_INVALID_ARG;
	break;
    }

    return status;
}


#ifndef CLEAN
/*
 *----------------------------------------------------------------------
 *
 * CopyInOutTest --
 *
 *	Invoke Vm_CopyIn or Vm_CopyOut on a dummy array (for performance 
 *	tuning).
 *
 * Results:
 *	Returns GEN_INVALID_ARG if the given length is greater than the 
 *	maximum.  Otherwise returns the error code from the copy routine.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
CopyInOutTest(command, length, userBuffer)
    int command;		/* copy in or out */
    int length;			/* number of bytes to copy */
    Address userBuffer;		/* address of user's buffer */
{
    ReturnStatus status;

    MakeCopyTestBuffer();

    if (length > VM_DO_COPY_MAX_SIZE) {
	status = GEN_INVALID_ARG;
    } else {
	if (command == VM_DO_COPY_IN) {
	    status = Vm_CopyIn(length, userBuffer, (Address)copyBuffer);
	} else {
	    status = Vm_CopyOut(length, (Address)copyBuffer, userBuffer);
	}
    }

    return status;
}
#endif /* CLEAN */


#ifndef CLEAN
/*
 *----------------------------------------------------------------------
 *
 * MakeAccessibleTest --
 *
 *	Invoke Vm_MakeAccessible and bcopy on a dummy array (for
 *	performance tuning).
 *
 * Results:
 *	GEN_INVALID_ARG: the given length is greater than the 
 *	  maximum.
 *	GEN_FAILURE: Vm_MakeAccessible wouldn't map the user's buffer.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
MakeAccessibleTest(command, length, userBuffer)
    int command;		/* copy in or out */
    int length;			/* number of bytes to copy */
    Address userBuffer;		/* address of user's buffer */
{
    ReturnStatus status = SUCCESS;
    int numBytes;		/* number of bytes actually mapped */

    MakeCopyTestBuffer();

    if (length > VM_DO_COPY_MAX_SIZE) {
	status = GEN_INVALID_ARG;
    } else {
	if (command == VM_DO_MAKE_ACCESS_IN) {
	    Vm_MakeAccessible(VM_READONLY_ACCESS, length, userBuffer,
			      &numBytes, &userBuffer);
	    if (userBuffer == (Address)NIL) {
		status = GEN_FAILURE;
		goto done;
	    }
	    bcopy(userBuffer, (Address)copyBuffer, length);
	    Vm_MakeUnaccessible(userBuffer, numBytes);
	} else {
	    Vm_MakeAccessible(VM_READWRITE_ACCESS, length, userBuffer,
			      &numBytes, &userBuffer);
	    if (userBuffer == (Address)NIL) {
		status = GEN_FAILURE;
		goto done;
	    }
	    bcopy((Address)copyBuffer, userBuffer, length);
	    Vm_MakeUnaccessible(userBuffer, numBytes);
	}
    }

 done:
    return status;
}
#endif /* CLEAN */


/*
 *----------------------------------------------------------------------
 *
 * MakeCopyTestBuffer --
 *
 *	Allocate the local buffer for copy tests, if it doesn't already 
 *	exist.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
MakeCopyTestBuffer()
{
    kern_return_t kernStatus;

    if (copyBuffer == 0) {
	printf("Vm_Cmd: allocating buffer for perf test.  Please rerun.\n");
	kernStatus = vm_allocate(mach_task_self(), &copyBuffer,
				 round_page(VM_DO_COPY_MAX_SIZE),
				 TRUE);
	if (kernStatus != KERN_SUCCESS) {
	    panic("%s: couldn't allocate dummy buffer for copy test: %s\n",
		  "MakeCopyTestBuffer", mach_error_string(kernStatus));
	}
    }
}


/*
 *----------------------------------------------------------------------
 *
 * VmCmdInband --
 *
 *	Like Vm_Cmd, but supports calls that pass arguments directly, 
 *	rather than using copyin/copyout.
 *
 * Results:
 *	Returns the usual Sprite status code.  Fills in the return buffer
 *	pointer and byte count.
 *
 * Side effects:
 *	Depends on the command.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
VmCmdInband(command, option, inBufLength, inBuf, outBufLengthPtr, outBufPtr,
	    outBufDeallocPtr)
    int command;		/* the command to execute */
    int option;			/* user-specified option (e.g., buffer 
				 * length) */ 
    int inBufLength;		/* bytes in inBuf */
    Address inBuf;		/* input buffer */
    int *outBufLengthPtr;	/* OUT: number of result bytes */
    Address *outBufPtr;		/* OUT: the results */
    Boolean *outBufDeallocPtr;	/* OUT: dealloc outBuf after send */
{
    ReturnStatus status = SUCCESS;

    *outBufLengthPtr = 0;
    *outBufPtr = NULL;
    *outBufDeallocPtr = FALSE;

    switch (command) {
    case VM_DO_COPY_IN_INBAND:
	status = CopyInInbandTest(option, inBufLength, inBuf);
	break;
    case VM_DO_COPY_OUT_INBAND:
	status = CopyOutInbandTest(option, outBufLengthPtr, outBufPtr,
				   outBufDeallocPtr);
	break;
    default:
	status = GEN_INVALID_ARG;
	break;
    }

    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * CopyInInbandTest --
 *
 *	Copy from the given buffer to the copy buffer.
 *
 * Results:
 *	Returns a Sprite status code.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
CopyInInbandTest(copyLength, inBufLength, inBuf)
    int copyLength;
    int inBufLength;		/* number of bytes to copy */
    Address inBuf;		/* buffer to copy from */
{
    ReturnStatus status = SUCCESS;

    MakeCopyTestBuffer();

    if (copyLength > VM_DO_COPY_MAX_SIZE || copyLength > inBufLength) {
	status = GEN_INVALID_ARG;
    } else {
	bcopy(inBuf, (_VoidPtr)copyBuffer, copyLength);
    }

    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * CopyOutInbandTest --
 *
 *	Make a copy of the copy buffer and give a pointer to it.
 *
 * Results:
 *	Returns a Sprite status code.  Fills in a pointer to a buffer, the 
 *	allocated size of the buffer, and a flag telling MIG whether to 
 *	deallocate the buffer when the reply message has been sent.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
CopyOutInbandTest(copyLength, outBufLengthPtr, outBufPtr, outBufDeallocPtr)
    int copyLength;		/* number of bytes to copy out */
    int *outBufLengthPtr;	/* OUT: number of bytes allocated to outBuf */
    Address *outBufPtr;		/* OUT: result buffer */
    Boolean *outBufDeallocPtr;	/* OUT: whether to deallocate outBuf */
{
    vm_address_t outBuf;	/* temporary output buffer */
    vm_size_t bufSize;		/* number of bytes in output buffer */
    kern_return_t kernStatus;
    ReturnStatus status = SUCCESS;

    *outBufPtr = 0;
    *outBufLengthPtr = bufSize = 0;
    *outBufDeallocPtr = FALSE;

    if (copyLength > VM_DO_COPY_MAX_SIZE) {
	status = GEN_INVALID_ARG;
    } else {
	/* 
	 * Allocate a temporary buffer and copy the copy buffer into it.  
	 * Pass the temporary buffer back to the caller, and tell MIG to 
	 * deallocate the buffer when it's no longer needed.
	 */
	bufSize = round_page(copyLength);
	outBuf = 0;
	kernStatus = vm_allocate(mach_task_self(), &outBuf, bufSize, TRUE);
	if (kernStatus != KERN_SUCCESS) {
	    printf("CopyOutInbandTest: can't allocate temp buffer: %s\n",
		   mach_error_string(kernStatus));
	    status = Utils_MapMachStatus(kernStatus);
	} else {
	    bcopy((_VoidPtr)copyBuffer, (_VoidPtr)outBuf, copyLength);
	    *outBufPtr = (Address)outBuf;
	    *outBufLengthPtr = bufSize;
	    *outBufDeallocPtr = TRUE;
	}
    }

    return status;
}
@


1.25
log
@Add execHeapPages and execStackPages to Vm_TaskInfo (instrumentation).
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.24 92/07/02 16:46:24 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d62 2
d66 3
d1239 1
a1239 1
	Timer_GetTimeOfDay(&startTime, NULL, NULL);
d1289 1
a1289 1
	    Timer_GetTimeOfDay(&startSubstep, NULL, NULL);
d1298 1
a1298 1
	    Timer_GetTimeOfDay(&endSubstep, NULL, NULL);
d1310 1
a1310 1
	    Timer_GetTimeOfDay(&startSubstep, NULL, NULL);
d1318 1
a1318 1
	    Timer_GetTimeOfDay(&endSubstep, NULL, NULL);
d1338 2
a1339 1
		Timer_GetTimeOfDay(&startSubstep, NULL, NULL);
d1356 1
a1356 1
		Timer_GetTimeOfDay(&endSubstep, NULL, NULL);
d1375 2
a1376 1
		    Timer_GetTimeOfDay(&startSubstep, NULL, NULL);
d1385 2
a1386 1
		    Timer_GetTimeOfDay(&endSubstep, NULL, NULL);
d1450 1
a1450 1
	Timer_GetTimeOfDay(&endTime, NULL, NULL);
d2026 150
@


1.25.1.1
log
@Hack instrumentation to get time spent in VmAddrParse.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.25 92/07/09 15:45:18 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
a57 2
Time vmAddrParseTime;		/* temp */

d1016 1
a1016 8
    ReturnStatus status = SUCCESS;
    Time startTime, endTime;	/* temp */

    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }
d1041 1
a1041 1
	    goto done;
a1071 1
    status = SUCCESS;
d1076 1
a1076 8

 done:
    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(endTime, vmAddrParseTime, &vmAddrParseTime);
    }
    return status;
@


1.24
log
@Maintain forcedInits stat.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.23 92/06/29 16:13:54 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d397 2
@


1.23
log
@More instrumentation for Vm_Fork.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.22 92/06/12 12:33:26 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d1165 3
a1167 1
	if (mappedSegPtr == NULL) {
@


1.23.1.1
log
@Hack instrumentation to find where the time is going in Vm_CreateVA().
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.23 92/06/29 16:13:54 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
a42 4
Time createVATime;		/* temp */
Time addrParseTime;		/* temp */
Time mapPageTime;		/* temp */

a1636 2
    Time startTime, endTime;	/* temp */
    Time startSubTime, endSubTime; /* temp */
a1637 5
    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }
a1663 5
	if (sys_CallProfiling) {
	    Timer_GetTimeOfDay(&startSubTime, (int *)NULL, (Boolean *)NULL);
	} else {
	    startSubTime = time_ZeroSeconds;
	}
a1665 5
	if (sys_CallProfiling && !Time_EQ(startSubTime, time_ZeroSeconds)) {
	    Timer_GetTimeOfDay(&endSubTime, (int *)NULL, (Boolean *)NULL);
	    Time_Subtract(endSubTime, startSubTime, &endSubTime);
	    Time_Add(endSubTime, addrParseTime, &addrParseTime);
	}
a1695 5
	    if (sys_CallProfiling) {
		Timer_GetTimeOfDay(&startSubTime, (int *)NULL, (Boolean *)NULL);
	    } else {
		startSubTime = time_ZeroSeconds;
	    }
a1696 5
	    if (sys_CallProfiling && !Time_EQ(startSubTime, time_ZeroSeconds)) {
		Timer_GetTimeOfDay(&endSubTime, (int *)NULL, (Boolean *)NULL);
		Time_Subtract(endSubTime, startSubTime, &endSubTime);
		Time_Add(endSubTime, mapPageTime, &mapPageTime);
	    }
a1711 5
    }
    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(endTime, createVATime, &createVATime);
@


1.22
log
@Fix an error message to name the procedure it's coming from.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.21 92/06/07 23:29:41 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
a52 1

d1224 1
d1279 5
d1288 6
d1300 5
d1308 6
d1328 5
d1344 7
d1364 5
d1372 7
@


1.21
log
@Add MakeAccessibleTest.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.20 92/05/27 21:24:03 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d323 1
a323 1
	printf("Can't map file ``%s'' into user space: %s\n",
@


1.20
log
@In CopyRegion, avoid a memory leak if the read succeeds but the write
fails.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.19 92/05/08 12:54:20 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d73 3
d1817 4
a1856 1
    kern_return_t kernStatus;
d1858 1
a1858 13
    /*
     * Make sure we have a buffer on our side.
     */
    if (copyBuffer == 0) {
	printf("Vm_Cmd: allocating buffer for perf test.  Please rerun.\n");
	kernStatus = vm_allocate(mach_task_self(), &copyBuffer,
				 round_page(VM_DO_COPY_MAX_SIZE),
				 TRUE);
	if (kernStatus != KERN_SUCCESS) {
	    panic("Vm_Cmd: couldn't allocate dummy buffer for copy test: %s\n",
		  mach_error_string(kernStatus));
	}
    }
d1873 96
@


1.19
log
@Use vm_read and vm_write to copy heap/stack segments, rather than
using the memory_object interface.  Don't keep the PCB locked so long
in Proc_NewProc.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.18 92/04/29 21:40:18 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d1481 1
d1504 1
d1510 1
a1510 1
	return Utils_MapMachStatus(kernStatus);
d1514 1
a1514 1
    return SUCCESS;
@


1.19.1.1
log
@Try to avoid copy heap pages that are backed by the initialization file.
The code as written doesn't work, because it doesn't know about pages
that have been dirtied but not written out (which are therefore no longer
backed by the initialization file).
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.19 92/05/08 12:54:20 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d67 1
a67 2
		Address regionAddr, Vm_Segment *toSegPtr, 
		vm_offset_t segOffset)); 
d1328 2
a1329 3
				    Proc_AssertLocked(procPtr),
				    regionSize, regionAddr,
				    segPtr, offset);
d1460 1
a1460 2
 *	Copy the given region from one user process to another.  The region 
 *	must be backed by a single segment.
d1472 1
a1472 2
CopyRegion(fromProcPtr, toProcPtr, regionSize, regionAddr, toSegPtr,
	   segOffset)
a1476 2
    Vm_Segment *toSegPtr;	/* the segment being copied into */
    vm_offset_t segOffset;	/* the starting offset in toSegPtr */
a1477 5
    vm_address_t copyBuffer;	/* buffer read from fromProcPtr */
    mach_msg_type_number_t copyCount; /* size of copyBuffer */
    Address pageAddr;		/* addr of one page in region */
    VmFileMap *mapPtr;		/* init/swap map for heap segments */
    int pageNum;		/* corresponds to segOffset */
d1479 2
a1480 1
    ReturnStatus status = SUCCESS;
d1491 18
a1508 41
    /* 
     * Break down the region into individual pages, taking care not to copy 
     * heap pages that are still backed by the heap's initialization file.
     * XXX There are some other optimizations we could do here (e.g., do 
     * stack segments in one shot, rather than a page at a time).
     */

    for (pageAddr = regionAddr; pageAddr < regionAddr + regionSize;
	 pageAddr += vm_page_size, segOffset += vm_page_size) {
	if (toSegPtr->type == VM_HEAP) {
	    pageNum = Vm_ByteToPage(segOffset);
	    mapPtr = toSegPtr->typeInfo.heapInfo.mapPtr;
	    if (pageNum < mapPtr->arraySize && mapPtr->useInitPtr[pageNum]) {
		continue;
	    }
	}
	kernStatus = vm_read(fromProcPtr->pcb.taskInfoPtr->task,
			     (vm_address_t)pageAddr, vm_page_size, &copyBuffer,
			     &copyCount);
	if (kernStatus != KERN_SUCCESS) {
	    printf("CopyRegion: couldn't read region at 0x%x: %s\n",
		   pageAddr, mach_error_string(kernStatus));
	    status = Utils_MapMachStatus(kernStatus);
	    break;
	}
	if (copyCount != vm_page_size) {
	    panic("CopyRegion: expected 0x%x bytes, got 0x%x.\n",
		  vm_page_size, copyCount);
	}

	kernStatus = vm_write(toProcPtr->pcb.taskInfoPtr->task,
			      (vm_address_t)pageAddr, copyBuffer, copyCount);
	if (kernStatus != KERN_SUCCESS) {
	    printf("CopyRegion: couldn't write region at 0x%x: %s\n",
		   pageAddr, mach_error_string(kernStatus));
	    status = Utils_MapMachStatus(kernStatus);
	}
	(void)vm_deallocate(mach_task_self(), copyBuffer, copyCount);
	if (status != SUCCESS) {
	    break;
	}
d1510 1
d1512 1
a1512 1
    return status;
@


1.18
log
@Move mach_host_self() prototype into a header file.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.17 92/04/23 23:37:01 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d36 1
d65 3
d1200 2
a1201 2
    Proc_LockedPCB *procPtr;	/* the process to get the new VM */
    Proc_LockedPCB *parentProcPtr; /* the process to copy it from */
d1221 1
d1226 12
a1237 2
    if (parentProcPtr->pcb.taskInfoPtr == NULL) {
	return VM_CORRUPTED;
d1239 2
a1240 2
    parentHeapPtr = parentProcPtr->pcb.taskInfoPtr->vmInfo.heapInfoPtr;
    parentStackPtr = parentProcPtr->pcb.taskInfoPtr->vmInfo.stackInfoPtr;
d1243 3
a1245 2
	       parentProcPtr->pcb.processID);
	return VM_CORRUPTED;
d1249 3
a1251 2
	       parentProcPtr->pcb.processID);
	return VM_CORRUPTED;
d1260 1
a1260 1
    kernStatus = task_suspend(parentProcPtr->pcb.taskInfoPtr->task);
d1276 1
a1276 1
	kernStatus = vm_region(parentProcPtr->pcb.taskInfoPtr->task,
d1286 1
a1286 1
	mappedSegPtr = VmSegByName((List_Links *)&parentProcPtr->pcb.
d1292 3
a1294 2
	 * the child process.  If it's a heap or stack segment, map a copy 
	 * rather than the parent's segment.
d1298 1
a1298 1
		   parentProcPtr->pcb.processID);
d1315 24
a1338 2
		status = MapIntoProcess(procPtr, segPtr, offset, regionSize,
					regionAddr, protection);
d1354 3
d1361 3
d1367 7
d1378 3
a1380 3
	    (procPtr->pcb.taskInfoPtr->vmInfo.codeInfoPtr == NULL ||
	     procPtr->pcb.taskInfoPtr->vmInfo.heapInfoPtr == NULL ||
	     procPtr->pcb.taskInfoPtr->vmInfo.stackInfoPtr == NULL)) {
d1382 1
a1382 1
	       parentProcPtr->pcb.processID);
d1387 7
d1396 1
a1396 1
	(void)task_resume(parentProcPtr->pcb.taskInfoPtr->task);
d1398 2
d1450 61
@


1.17
log
@Add copyin/copyout tests to Vm_Cmd.  Track changes from MK63 to MK73.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.16 92/04/16 11:21:22 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d33 1
a40 6

/* 
 * XXX - this is in mach_traps.h, but there's a cpp problem including both 
 * mach.h and mach_traps.h. 2-Oct-91.
 */
extern mach_port_t mach_host_self _ARGS_((void));
@


1.16
log
@Add instrumentation, GetMemorySize.  Add a length parameter to Vm_Cmd.  Add
VM_CLEAR_COUNTERS command.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.15 92/02/27 15:53:22 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d58 5
d67 2
d1483 2
a1484 2
    currAddr = (Address)trunc_page(startAddr);
    bytesLeft = (Address)round_page(startAddr + requestedBytes) - currAddr;
d1689 6
d1702 57
@


1.15
log
@Move MIG stub routines into vmSysCall.c.  Add support for getting VM
stats.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.14 92/01/21 17:07:43 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d27 1
a29 2
#include <vmStat.h>
#include <user/vmTypes.h>
d38 8
d55 3
d62 1
d106 40
d1661 1
a1661 1
Vm_Cmd(command, arg)
d1663 1
d1667 1
d1671 8
a1678 2
	Vm_Stat vmStat;

d1680 1
a1680 1
	status = Vm_CopyOut(sizeof(vmStat), (Address)&vmStat, arg);
a1681 1
    }
@


1.14
log
@Change VM code to use Sprite FS instead of UNIX.  
@
text
@d5 2
a6 1
 *	XXX Merge with vmSubr.c?
d19 1
a19 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.13 91/12/12 20:56:33 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d23 1
d29 2
a35 1
#include <spriteSrv.h>
a100 55
 * Vm_MapFileStub --
 *
 *	System call stub to map a file into the user's address space.  
 *	See Vm_MapFile.
 *
 * Results:
 *	Returns a Mach status code, usually KERN_SUCCESS.  Fills in 
 *	the Sprite status code and the address that the file was
 *	mapped into.
 *	Returns a Sprite status of FS_NO_ACCESS if the file is
 *	to be mapped read-only and the given offset plus length run
 *	off the end of the file.
 *
 * Side effects:
 *	Maps the requested portion of the file into the user's address 
 *	space.
 *
 *----------------------------------------------------------------------
 */

kern_return_t
Vm_MapFileStub(serverPort, fileName, fileNameLength, readOnly, offset,
	       length, statusPtr, startAddrPtr)
    mach_port_t serverPort;	/* request port */
    Fs_PathName fileName;	/* name of file to map */
    mach_msg_type_number_t fileNameLength; /* extra parameter to appease MIG */
    boolean_t readOnly;		/* map the file read-only or read-write? */
    off_t offset;		/* where in the file to start mapping. 
				 * NB: not necessarily page-aligned */
    vm_size_t length;		/* how much of the file to map */
    ReturnStatus *statusPtr;	/* OUT: Sprite return status */
    vm_address_t *startAddrPtr;	/* OUT: where file was mapped to */
{
    Proc_ControlBlock *procPtr;
    kern_return_t kernStatus = KERN_SUCCESS;

#ifdef lint
    fileNameLength = fileNameLength;
#endif

    procPtr = Proc_SyscallToPCB(serverPort);
    if (procPtr == NULL) {
	kernStatus = KERN_INVALID_CAPABILITY;
    } else {
	kernStatus = Vm_MapFile(procPtr, fileName, readOnly, offset, length,
				statusPtr, (Address *)startAddrPtr);
    }

    return kernStatus;
}


/*
 *----------------------------------------------------------------------
 *
a232 5
    if (procPtr->genFlags & PROC_NO_MORE_REQUESTS) {
	*statusPtr = GEN_ABORTED_BY_SIGNAL;
	return KERN_SUCCESS;
    }

a1379 33
 * Vm_CreateVAStub --
 *
 *	System call stub to validate (and create, if necessary) a given 
 *	range of addresses.  See Vm_CreateVA.
 *
 * Results:
 *	Returns KERN_SUCCESS.  Fills in the Sprite status code.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

kern_return_t
Vm_CreateVAStub(serverPort, address, bytes, statusPtr)
    mach_port_t serverPort;	/* server request port */
    vm_address_t address;	/* starting address to validate */
    vm_size_t bytes;		/* number of bytes to validate */
    ReturnStatus *statusPtr;	/* OUT: Sprite return code */
{
#ifdef lint
    serverPort = serverPort;
#endif

    *statusPtr = Vm_CreateVA((Address)address, bytes);
    return KERN_SUCCESS;
}


/*
 *----------------------------------------------------------------------
 *
d1586 42
@


1.13
log
@VmParseAddr would lie if the given address was unmapped but there were
mapped regions at higher addresses.  Add Vm_CreateVA & stub.

@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.12 91/12/01 22:00:36 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d28 2
d64 3
a66 1
static ReturnStatus VmAddrRegion _ARGS_((Proc_ControlBlock *procPtr,
d188 1
a188 1
    TempFs_Stream *filePtr;	/* for creating the file, if need be */
d198 3
a200 2
     * XXX Once we have the real Sprite FS, do we have to create the 
     * new file here, or can we let Vm_GetSharedSegment do that?
d202 8
a209 6
    *statusPtr = TempFs_CheckAccess(fileName,
				    (readOnly ? FS_READ : FS_READ | FS_WRITE),
				    TRUE);
    if (*statusPtr == GEN_ENOENT && !readOnly) {
	*statusPtr = TempFs_Open(fileName, FS_READ | FS_WRITE | FS_CREATE,
				 FS_FILE, 0644, &filePtr);
d211 1
a211 1
	    TempFs_Close(filePtr);
d459 126
d1023 2
d1030 2
a1031 2
	status = VmAddrRegion(procPtr, startAddr, &currBytes, &segPtr,
			     &currOffset);
d1036 1
d1068 1
d1096 1
a1096 1
    Proc_ControlBlock *procPtr;	/* the process to do the lookup for */
a1107 1
    Boolean locked = FALSE;	/* did we lock the PCB? */
d1125 1
a1125 1
    kernStatus = vm_region(procPtr->taskInfoPtr->task,
d1141 1
a1141 3
    Proc_Lock(procPtr);
    locked = TRUE;
    mappedSegPtr = VmSegByName((List_Links *)&procPtr->taskInfoPtr->
d1150 1
a1150 1
	(void)vm_read(procPtr->taskInfoPtr->task,
d1160 1
a1160 1
	mappedSegPtr = VmSegByName((List_Links *)&procPtr->taskInfoPtr->
a1177 3
    if (locked) {
	Proc_Unlock(Proc_AssertLocked(procPtr));
    }
d1632 44
@


1.12
log
@Snapshot.  FS appears to work.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.11 91/11/14 10:03:18 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d51 2
d997 7
d1188 1
d1300 203
@


1.11
log
@Snapshot. net, rpc, recov modules added.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.10 91/10/18 18:27:47 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
a22 1
#include <libc.h>
d60 3
d311 2
a312 1
	printf("Can't map file %s into user space: %s\n", segPtr->swapFileName,
d324 1
d854 1
d872 92
d983 1
a983 1
     * the process's mapped segments match the one Mach returned to us.
d985 1
a985 1

a1026 1
    Vm_SegmentAddRef(mappedSegPtr->segPtr);
@


1.10
log
@Use ckalloc package for memory allocation.  Fix VmAddrParse to handle
the case where the kernel hasn't revealed the segment's name port to
the VM module yet.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.9 91/10/08 17:31:07 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d46 1
a46 1
static void AddMappedRange _ARGS_((Address startAddr, int length,
d56 1
a56 1
		Vm_Segment *segPtr, Address startAddress, int length));
d115 1
a115 1
    int fileNameLength;		/* extra parameter to appease MIG */
d117 1
a117 1
    int offset;			/* where in the file to start mapping. 
d119 1
a119 1
    int length;			/* how much of the file to map */
d126 4
d172 1
a172 1
    int offset;			/* where in the file to start mapping. 
d174 1
a174 1
    int length;			/* how much of the file to map */
d219 2
a220 2
			       readOnly, TRUE, offset, length, startAddrPtr,
			       statusPtr);
d259 1
a259 1
    int length;			/* how much of the segment to map */
d467 1
a467 1
    int length;			/* how many bytes in the mapping */
d484 1
a484 1
	mapSegPtr = ckalloc(sizeof(VmMappedSegment));
d560 1
a560 1
    int length;			/* number of bytes in the new range */
d654 1
a654 1
    int newMapLength;		/* bytes in new mapping */
d881 1
a881 1
    mach_msg_type_number_t touchPageSize; /* number of bytes in touchPage */
d912 2
a913 1
		      (pointer_t *)&touchPage, &touchPageSize);
d915 3
d1025 1
a1025 1
    while (addr < procMach_HighestUserAddr) {
@


1.9
log
@Export Vm_MapFile.  Commenting fix.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.8 91/10/04 11:37:54 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d22 1
d430 1
a430 1
	free(mappedSegPtr);
d480 1
a480 1
	mapSegPtr = malloc(sizeof(VmMappedSegment));
d875 4
d901 18
a918 2
	status = VM_SEG_NOT_FOUND;
	goto done;
@


1.8
log
@Snapshot.  fork/exec work.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.7 91/09/24 16:34:56 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
a44 6
/* XXX should this be exported to other modules? */
extern kern_return_t Vm_MapFile _ARGS_((Proc_ControlBlock *procPtr,
		char *fileName, boolean_t readOnly, int offset,
		int length, ReturnStatus *statusPtr,
		Address *startAddrPtr));

a310 2
     * XXX are there error returns from vm_map where we should mark 
     * the control port?
@


1.7
log
@Add VmAddrParse.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.6 91/09/23 14:20:10 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d29 1
d57 3
a63 1
static void ReleaseMappedSegments _ARGS_((List_Links *mappedSegList));
d269 6
d296 1
a296 1
	    goto cleanUp;
d308 1
a308 1
			protectCode, VM_INHERIT_SHARE);
d312 1
a312 1
	goto cleanUp;
d332 1
a332 1
 cleanUp:
d356 2
a357 2
Vm_CleanupTask(vmInfoPtr)
    Vm_TaskInfo *vmInfoPtr;
d359 1
a359 1
    ReleaseMappedSegments(&vmInfoPtr->mappedListHdr);
d394 1
a394 1
 * ReleaseMappedSegments --
d404 4
a407 5
 *	is freed.  The segments aren't deallocated from the process 
 *	because the process is dead, so its VM will be cleaned up when 
 *	the task is destroyed.
 *	XXX may want to deallocate the segment so that this routine 
 *	can be used with exec().
d412 3
a414 3
static void
ReleaseMappedSegments(mappedSegList)
    List_Links *mappedSegList;	/* header of list of mapped segments */
d416 1
d419 6
d426 1
d431 5
d439 4
a870 2
    List_Links *itemPtr;
    Boolean found = FALSE;	/* found a segment? */
d900 4
a903 8
    LIST_FORALL(&procPtr->taskInfoPtr->vmInfo.mappedListHdr, itemPtr) {
	mappedSegPtr = (VmMappedSegment *)itemPtr;
	if (mappedSegPtr->segPtr->namePort == segmentName) {
	    found = TRUE;
	    break;
	}
    }
    if (!found) {
d922 251
@


1.6
log
@Snapshot.  Server is multithreaded internally.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.5 91/09/04 15:23:47 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d810 94
@


1.5
log
@Not all address faults are below the stack.
@
text
@d5 1
d18 1
a18 1
static char rcsid[] = "$Header: /user6/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.4 91/09/02 22:56:11 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
a27 1
#include <main.h>
d56 1
a56 1
static void NoteMappedSegment _ARGS_((Proc_ControlBlock *procPtr,
d58 1
a58 1
static Boolean OkayToExtendStack _ARGS_((Proc_ControlBlock *procPtr,
d61 1
a61 1
static void RememberSpecialSegment _ARGS_((Proc_ControlBlock *procPtr,
d216 4
a219 3
    kernStatus = Vm_MapSegment(procPtr, segmentPtr, readOnly, TRUE,
			      offset, length, startAddrPtr, statusPtr);
    Proc_Unlock(procPtr);
d248 1
a248 1
Vm_MapSegment(procPtr, segPtr, readOnly, anywhere, offset, length,
d250 1
a250 2
    Proc_ControlBlock *procPtr;	/* the user process to map the file 
				 * into; should be locked */
d264 1
d266 5
d319 2
a320 1
    NoteMappedSegment(procPtr, segPtr, (Address)*startAddrPtr, length);
d442 1
a442 1
    Proc_ControlBlock *procPtr;	/* the process affected */
d448 1
a448 1
    List_Links *segmentList = &procPtr->taskInfoPtr->vmInfo.mappedListHdr;
d464 1
a464 1
	    panic("NoteMappedSegment: out of memory.");
d580 1
a580 2
    Proc_ControlBlock *procPtr;	/* the process that's getting the 
				 * segment, already locked */
d585 2
a586 2
	if (procPtr->taskInfoPtr->vmInfo.heapInfoPtr != NULL) {
	    panic("RememberSpecialSegment: multiple heaps.");
d588 1
a588 1
	procPtr->taskInfoPtr->vmInfo.heapInfoPtr = mapSegPtr;
d591 2
a592 2
	if (procPtr->taskInfoPtr->vmInfo.codeInfoPtr != NULL) {
	    panic("RememberSpecialSegment: multiple code segments.");
d594 1
a594 1
	procPtr->taskInfoPtr->vmInfo.codeInfoPtr = mapSegPtr;
d597 2
a598 2
	if (procPtr->taskInfoPtr->vmInfo.stackInfoPtr != NULL) {
	    panic("RememberSpecialSegment: multiple stacks.");
d600 1
a600 1
	procPtr->taskInfoPtr->vmInfo.stackInfoPtr = mapSegPtr;
d625 2
a626 2
Vm_ExtendStack(procPtr, address)
    Proc_ControlBlock *procPtr;	/* the process to look at, already locked */
d629 1
d639 1
a639 1
	panic("Vm_ExtendStack: no stack.");
d641 1
a641 1
    if (!OkayToExtendStack(procPtr, address)) {
d654 2
a655 1
    kernStatus = Vm_MapSegment(procPtr, stackInfoPtr->segPtr, FALSE, FALSE,
d679 1
a679 1
	    printf("Vm_ExtendStack: couldn't deallocate region: %s\n",
a680 1
	    panic("Vm_ExtendStack");
d707 2
a708 2
OkayToExtendStack(procPtr, address)
    Proc_ControlBlock *procPtr;	/* the process to check, already locked */
d712 1
d729 1
a729 1
	panic("OkayToExtendStack: the address is already in the stack.");
d804 1
a804 1
	panic("GetStackOffset: address not in stack.");
d809 1
@


1.4
log
@Changes for module-based source organization.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user6/kupfer/spriteserver/src/sprited/vm/RCS/vmOps.c,v 1.3 91/09/01 21:02:52 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d707 1
d714 1
d717 15
a731 2
     * Refuse to extend the stack by excessive amounts.  Also fail if 
     * the address can't possibly be in the stack.
d733 2
a734 3

    if (address >= stackBottom) {
	panic("OkayToExtendStack: why did we get an exception?");
@


1.3
log
@Snapshot.  Full VM support.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user6/kupfer/spriteserver/src/printfd/RCS/vm.c,v 1.2 91/08/19 12:17:24 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
a25 6
#include "main.h"
#include "proc.h"
#include "spriteSrv.h"
#include "util.h"
#include "vm.h"
#include "vmInt.h"
d27 7
d652 1
a652 1
	status = Util_MapMachStatus(kernStatus);
@


1.2
log
@Snapshot: Code reorg. and locking for processes & segments.
@
text
@d2 1
a2 1
 * vm.c --
d4 1
a4 1
 *	Sprite virtual memory support.
d17 1
a17 1
static char rcsid[] = "$Header: /user6/kupfer/spriteserver/src/printfd/RCS/vm.c,v 1.1 91/08/15 15:51:26 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d29 1
d33 8
d47 1
a47 1
		vm_address_t *startAddrPtr));
d49 10
a58 2
static void AddMappedSegment _ARGS_((Proc_ControlBlock *procPtr,
		Vm_Segment *segPtr, Address startAddr, int length));
d60 2
d132 1
a132 1
				statusPtr, startAddrPtr);
d173 1
a173 1
    vm_address_t *startAddrPtr;	/* OUT: where file was mapped to */
d177 1
a177 3
    vm_prot_t protectCode;	/* Mach protection code for the segment */
    TempFs_Stream *filePtr;	/* in case we want to create the file */
    Boolean procLocked = FALSE;	/* did we lock the pcb? */
a178 2
    protectCode = (readOnly ? VM_PROT_READ : VM_PROT_READ |
		   VM_PROT_WRITE);
d187 2
d190 3
a192 1
    *statusPtr = TempFs_CheckAccess(fileName, protectCode, TRUE);
d203 1
a203 1
    
d205 2
a206 1
     * Get the segment for the file. 
d208 1
a208 1
    *statusPtr = VmSegmentFromFile(fileName, &segmentPtr);
d212 32
d245 18
a262 5
    /* 
     * From this point on, exit via "cleanUp", so that locks and whatnot 
     * are returned correctly.
     */
    VmSegmentLock(segmentPtr);
d264 4
a267 10
    /* 
     * If the segment is marked dead, punt.
     * XXX Maybe the problem that caused the fatal error has gone 
     * away.  Unfortunately, we don't have a way to reclaim the 
     * current segment, and we don't support having multiple segments 
     * for the same file.
     */
    if (segmentPtr->state != VM_SEGMENT_OK) {
	*statusPtr = VM_SWAP_ERROR;
	goto cleanUp;
d270 2
d277 1
a277 1
    if (offset + length > segmentPtr->size) {
d282 1
a282 1
	    segmentPtr->size = offset + length;
d289 4
a292 6
    *startAddrPtr = 0;
    Proc_Lock(procPtr);
    procLocked = TRUE;
    kernStatus = vm_map(procPtr->taskInfoPtr->task, startAddrPtr,
			length, 0, TRUE, segmentPtr->requestPort, offset,
			FALSE, protectCode, protectCode, VM_INHERIT_SHARE);
d294 1
a294 1
	printf("Can't map file %s into user space: %s\n", fileName,
a295 1
	*statusPtr = FAILURE;
d299 2
d304 3
a306 1
    segmentPtr->controlPort = MACH_PORT_DEAD;
d311 3
a313 2
    AddMappedSegment(procPtr, segmentPtr, (Address)*startAddrPtr,
		     length);
d316 1
a316 7
    if (procLocked) {
	Proc_Unlock(procPtr);
    }
    VmSegmentUnlock(segmentPtr);
    if (*statusPtr != SUCCESS) {
	Vm_SegmentRelease(segmentPtr);
    }
d368 3
d416 1
a416 1
 * AddMappedSegment --
d418 2
a419 2
 *	Record a newly mapped file for a process.  The process should 
 *	be locked.
d425 3
a427 2
 *	Creates an object to describe the mapping and adds it to the 
 *	process's list of mapped segments.
d433 1
a433 1
AddMappedSegment(procPtr, segPtr, startAddr, length)
d436 2
a437 2
    Address startAddr;		/* where the segment is mapped */
    int length;			/* how much of the segment is mapped */
d440 236
d677 65
a741 3
    mapSegPtr = malloc(sizeof(VmMappedSegment));
    if (mapSegPtr == NULL) {
	panic("AddMappedSegment: out of memory.");
d744 34
a777 4
    List_InitElement((List_Links *)mapSegPtr);
    mapSegPtr->segPtr = segPtr;
    mapSegPtr->startAddress = startAddr;
    mapSegPtr->length = length;
d779 6
a784 2
    List_Insert((List_Links *)mapSegPtr,
		LIST_ATREAR(&procPtr->taskInfoPtr->vmInfo.mappedListHdr));
@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/lib/forms/RCS/proto.c,v 1.5 91/02/09 13:24:44 ouster Exp $ SPRITE (Berkeley)";
d34 6
d41 1
a41 2
				     Vm_Segment *segPtr,
				     Address startAddr, int length));
d65 1
d74 2
a75 5
 *	System call to map a file into the user's address space.
 *	The user can grow the file by mapping it read-write and 
 *	specifying an offset+length that go beyond the current length 
 *	of the file.
 *	XXX locking of pcb.
d79 1
a79 2
 *	the Sprite status code.  If successful (both the Mach and 
 *	Sprite codes are okay), fills in the address that the file was
d105 51
d158 1
a158 1
    vm_prot_t protectCode;
d160 1
d194 1
a194 1
     * From this point on, exit via "done", so that locks and whatnot 
d197 1
a197 1
    VmLockSegment(segmentPtr);
d208 1
a208 1
	goto done;
d219 1
a219 1
	    goto done;
d229 3
a231 3

    /* XXX won't always be the initial proc */
    kernStatus = vm_map(initialProc.taskInfoPtr->task, startAddrPtr,
d238 1
a238 1
	goto done;
d240 5
d249 1
a249 2
    /* XXX won't always be initialProc. */
    AddMappedSegment(&initialProc, segmentPtr, (Address)*startAddrPtr,
d252 5
a256 2
 done:
    VmUnlockSegment(segmentPtr);
d258 1
a258 1
	VmSegmentRelease(segmentPtr);
d347 1
a347 1
	VmSegmentRelease(mappedSegPtr->segPtr);
@
