head     1.27;
branch   ;
access   ;
symbols  srv030:1.27 srv028:1.26 srv027:1.26 srv026:1.26 srv025:1.26.1 srv024:1.26 srv022:1.25 srv021:1.25 srv019:1.25 srv018:1.24 srv016:1.22 srv015:1.22 srv014:1.21 srv012:1.21 srv011:1.21 srv010:1.21 srv008:1.20 srv007:1.19 srv006:1.19 srv005:1.19 srv004:1.19 srv003:1.18 srv002:1.17 srv001:1.16;
locks    ; strict;
comment  @ * @;


1.27
date     92.07.16.18.05.21;  author kupfer;  state Exp;
branches ;
next     1.26;

1.26
date     92.07.08.12.47.46;  author kupfer;  state Exp;
branches 1.26.1.1;
next     1.25;

1.25
date     92.06.29.16.13.40;  author kupfer;  state Exp;
branches ;
next     1.24;

1.24
date     92.06.25.15.54.56;  author kupfer;  state Exp;
branches ;
next     1.23;

1.23
date     92.06.25.15.54.03;  author kupfer;  state Exp;
branches ;
next     1.22;

1.22
date     92.06.12.14.15.22;  author kupfer;  state Exp;
branches ;
next     1.21;

1.21
date     92.06.04.14.11.03;  author kupfer;  state Exp;
branches ;
next     1.20;

1.20
date     92.06.02.14.59.04;  author kupfer;  state Exp;
branches ;
next     1.19;

1.19
date     92.05.08.12.54.35;  author kupfer;  state Exp;
branches ;
next     1.18;

1.18
date     92.04.29.21.43.58;  author kupfer;  state Exp;
branches ;
next     1.17;

1.17
date     92.04.23.23.41.46;  author kupfer;  state Exp;
branches ;
next     1.16;

1.16
date     92.04.16.11.21.42;  author kupfer;  state Exp;
branches ;
next     1.15;

1.15
date     92.03.12.17.23.32;  author kupfer;  state Exp;
branches ;
next     1.14;

1.14
date     92.01.21.17.08.11;  author kupfer;  state Exp;
branches ;
next     1.13;

1.13
date     91.12.12.21.01.38;  author kupfer;  state Exp;
branches ;
next     1.12;

1.12
date     91.12.01.22.00.37;  author kupfer;  state Exp;
branches ;
next     1.11;

1.11
date     91.11.14.10.03.20;  author kupfer;  state Exp;
branches ;
next     1.10;

1.10
date     91.10.18.18.28.07;  author kupfer;  state Exp;
branches ;
next     1.9;

1.9
date     91.10.08.17.31.53;  author kupfer;  state Exp;
branches ;
next     1.8;

1.8
date     91.10.04.11.37.55;  author kupfer;  state Exp;
branches ;
next     1.7;

1.7
date     91.09.24.16.35.06;  author kupfer;  state Exp;
branches ;
next     1.6;

1.6
date     91.09.23.14.20.11;  author kupfer;  state Exp;
branches ;
next     1.5;

1.5
date     91.09.04.15.24.55;  author kupfer;  state Exp;
branches ;
next     1.4;

1.4
date     91.09.02.22.56.12;  author kupfer;  state Exp;
branches ;
next     1.3;

1.3
date     91.09.01.21.02.59;  author kupfer;  state Exp;
branches ;
next     1.2;

1.2
date     91.08.19.12.17.28;  author kupfer;  state Exp;
branches ;
next     1.1;

1.1
date     91.08.15.15.52.54;  author kupfer;  state Exp;
branches ;
next     ;

1.26.1.1
date     92.07.08.15.17.41;  author kupfer;  state Exp;
branches ;
next     ;


desc
@External pager routines for Sprite.
@


1.27
log
@Lint.
@
text
@/* 
 * vmPager.c --
 *
 *	External pager interface routines for Sprite.
 *
 * Copyright 1991, 1992 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that this copyright
 * notice appears in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.26 92/07/08 12:47:46 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
#endif /* not lint */

#include <sprite.h>
#include <bstring.h>
#include <status.h>
#include <stdlib.h>
#include <mach.h>
#include <mach_error.h>

#include <main.h>		/* for debug flag */
#include <user/fs.h>
#include <fs.h>
#include <fsutil.h>
#include <procMach.h>
#include <sync.h>
#include <sys.h>
#include <timer.h>
#include <utils.h>
#include <vm.h>
#include <vmInt.h>
#include <user/vmStat.h>

/* 
 * When the kernel asks for data, we read it into this buffer and 
 * pass the buffer to the kernel.
 * XXX Assume that the buffer is at most 1 page long.
 */
static Address pagingBuffer = NULL;

static Sync_Lock bufferLock = Sync_LockInitStatic("vmPager:bufferLock");

/* 
 * Some write errors may be temporary.  This is how long we wait 
 * before trying again.
 */
static Time retryTime = {30, 0}; /* thirty seconds */


/* forward references: */

static Boolean ControlPortOkay _ARGS_((Vm_Segment *segPtr,
		mach_port_t controlPort, char *functionName));
static ReturnStatus FillBuffer _ARGS_((Fs_Stream *filePtr, off_t fileSize,
		off_t offset, vm_size_t bytesWanted,
		Fs_PageType pageType, Vm_Segment *segPtr, Address buffer));
static Boolean IsFatalError _ARGS_((int errorCode));
static ReturnStatus WhichFile _ARGS_((Vm_Segment *segPtr,
		vm_offset_t segOffset, int readWrite,
		Fs_Stream **filePtrPtr, off_t *fileOffsetPtr,
		Fs_PageType *pageTypePtr, off_t *fileSizePtr));
static ReturnStatus WhichHeapFile _ARGS_((Vm_Segment *segPtr,
		vm_offset_t segOffset, int readWrite,
		Fs_Stream **filePtrPtr, off_t *fileOffsetPtr,
		Fs_PageType *pageTypePtr, off_t *fileSizePtr));
static ReturnStatus WhichStackFile _ARGS_((Vm_Segment *segPtr,
		vm_offset_t segOffset, int readWrite,
		Fs_Stream **filePtrPtr, off_t *fileOffsetPtr,
		Fs_PageType *pageTypePtr, off_t *fileSizePtr));
static ReturnStatus WriteBack _ARGS_((Vm_Segment *segPtr,
		Fs_Stream *filePtr, off_t fileOffset, Address buffer));


/*
 *----------------------------------------------------------------------
 *
 * memory_object_init --
 *
 *	Finish initialization for a segment (memory object) and tell 
 *	the kernel it's ready.
 *
 * Results:
 *	Mach status code.
 *
 * Side effects:
 *	Remembers the control port for the segment.  Allocates the 
 *	paging buffer if it doesn't already exist.
 *
 *----------------------------------------------------------------------
 */
    
kern_return_t
memory_object_init(objectPort, controlPort, namePort, size)
    mach_port_t objectPort;	/* request port for the segment */
    mach_port_t controlPort;	/* (new) control port for the segment */
    mach_port_t namePort;	/* (new) name for the segment that 
				 * vm_region will return */
    vm_size_t size;		/* page size associated with the segment */
{
    Vm_Segment *segPtr;
    kern_return_t kernStatus = KERN_SUCCESS;
    Time startTime, endTime;	/* instrumentation */

    vmStat.initCalls++;
    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }

    /* 
     * We don't hand out ports for the memory objects, so only the local 
     * kernel should make memory_object_init requests.  Hence the page size 
     * should be constant.
     */
    if (size != vm_page_size) {
	panic("memory_object_init: different page size.\n");
    }

    segPtr = Vm_PortToSegment(objectPort);
    /* 
     * XXX If the port is bogus, how do we tell the kernel that?
     */
    if (segPtr == NULL) {
	printf("memory_object_init: bogus segment.\n");
	return KERN_INVALID_CAPABILITY;
    }

    VmSegmentLock(segPtr);

    /* 
     * If the segment is dead, record the control port anyway, so that when 
     * the object is destroyed we have our bookkeeping straight.
     */
    if (segPtr->state == VM_SEGMENT_DYING ||
		segPtr->state == VM_SEGMENT_DEAD ) {
	printf("%s: warning: trying to resurrect a dead segment (%s).\n",
	       "memory_object_init", Vm_SegmentName(segPtr));
    }

    /* 
     * XXX It appears that even if a vm_map call fails, the kernel might 
     * still issue memory object requests on that memory object.  For the 
     * time being, just kill the memory object.  We need a better long-term 
     * solution, though.
     */
    if (segPtr->controlPort == MACH_PORT_NULL) {
	printf("memory_object_init: segment ``%s'' has a null control port.\n",
	      Vm_SegmentName(segPtr));
	(void)memory_object_destroy(controlPort, 0);
    } else if (segPtr->controlPort != MACH_PORT_DEAD) {
	printf("%s: warning: overwriting control port for segment ``%s''.\n",
	       "memory_object_init", Vm_SegmentName(segPtr));
    }

    segPtr->controlPort = controlPort;
    segPtr->namePort = namePort;
    if (segPtr->state == VM_SEGMENT_OK) {
	kernStatus = memory_object_ready(controlPort, TRUE, 
					 MEMORY_OBJECT_COPY_DELAY);
	if (kernStatus != KERN_SUCCESS) {
	    printf("Can't enable segment: %s\n",
		   mach_error_string(kernStatus));
	}
    }

    VmSegmentUnlock(segPtr);
    Vm_SegmentRelease(segPtr);

    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(endTime, vmStat.initTime, &vmStat.initTime);
    }

    return kernStatus;
}


/*
 *----------------------------------------------------------------------
 *
 * memory_object_data_write --
 *
 *	Take dirty data back from the kernel (obsolete).
 *
 * Results:
 *	Mach status code.
 *
 * Side effects:
 *	none.
 *
 *----------------------------------------------------------------------
 */

kern_return_t
memory_object_data_write(objectPort, controlPort, segStart, data, dataCount)
    mach_port_t objectPort;	/* the object being cleaned */
    mach_port_t controlPort;	/* its control port */
    vm_offset_t segStart;	/* where in segment to start writing back */
    pointer_t data;		/* the bytes */
    mach_msg_type_number_t dataCount; /* number of bytes to write back */
{
#ifdef lint
    objectPort = objectPort;
    controlPort = controlPort;
    segStart = segStart;
    data = data;
    dataCount = dataCount;
#endif

    panic("memory_object_data_write called.\n");
    return KERN_SUCCESS;	/* lint */
}


/*
 *----------------------------------------------------------------------
 *
 * WriteBack --
 *
 *	Write a page of memory to the given file at the given offset.  
 *	Retries if there is a non-fatal error.
 *
 * Results:
 *	Returns a Sprite status code.
 *
 * Side effects:
 *	Updates the swap file size for the segment.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
WriteBack(segPtr, filePtr, fileOffset, buffer)
    Vm_Segment *segPtr;		/* segment being cleaned */
    Fs_Stream *filePtr;		/* file to write back */
    off_t fileOffset;		/* where in the file */
    Address buffer;		/* page of data to write back */
{
    ReturnStatus status;
    Boolean retry;

    /* 
     * If there is a fatal I/O error, bail out.  If the server seems to be 
     * dead, wait for it to come back.  If there is some non-fatal I/O
     * error, complain, sleep for an interval, and try again.
     * XXX Should probably check whether some other process has marked the 
     * segment as dead (or dying).  Need to lock the segment to do that, of 
     * course. 
     */
    do {
	retry = FALSE;
	status = Fs_PageWrite(filePtr, (Address)buffer, (int)fileOffset,
			      (int)vm_page_size, FALSE);
	if (status == SUCCESS) {
	    vmStat.pagesWritten[segPtr->type]++;
	    if (segPtr->flags & VM_CLEANING_SEGMENT) {
		vmStat.pagesCleaned[segPtr->type]++;
	    }
	} else {
	    printf("WriteBack: can't write back %s: %s\n",
		   Fsutil_GetFileName(filePtr),
		   Stat_GetMsg(status));
	    if (!sys_ShuttingDown && !IsFatalError(status)) {
		if (Fsutil_RecoverableError(status)) {
		    status = Fsutil_WaitForHost(filePtr, 0, status);
		    if (status == SUCCESS) {
			retry = TRUE;
		    } else {
			printf("WriteBack: recovery failed for %s: %s\n",
			       Fsutil_GetFileName(filePtr),
			       Stat_GetMsg(status));
		    }
		} else {
		    retry = TRUE;
		    (void)Sync_WaitTime(retryTime);
		}
	    }
	}
    } while (retry);

#if VM_KNOWS_SWAP_FILE_SIZE
    if (status == SUCCESS) {
	if (segPtr->swapFileSize < fileOffset + vm_page_size) {
	    segPtr->swapFileSize = fileOffset + vm_page_size;
	}
    }
#endif

    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * memory_object_data_request --
 *
 *	Supply bytes to the kernel.
 *	
 *	All pages given to the kernel are marked precious.  Code pages must 
 *	be precious so that we can clean up sticky segments after they've 
 *	been paged out.  Heap and stack pages must be precious so that our 
 *	copy-on-write scheme will work.  Might as well make shared (mapped 
 *	file) pages precious, too, especially since they're not used much 
 *	in Sprite.
 *
 * Results:
 *	Returns KERN_SUCCESS.  (See memory_object_data_provided.)
 *
 * Side effects:
 *	Overwrites the paging buffer.
 *
 *----------------------------------------------------------------------
 */

/* ARGSUSED */
kern_return_t
memory_object_data_request(objectPort, controlPort, segOffset, bytesWanted,
			   desiredAccess)
    mach_port_t objectPort;	/* the segment to read from */
    mach_port_t controlPort;	/* its control port */
    vm_offset_t segOffset;	/* where in the segment to start reading */
    vm_size_t bytesWanted;	/* number of bytes to read */
    vm_prot_t desiredAccess;	/* requested permissions for the data; 
				 * unused */
{
    Vm_Segment *segPtr;
    ReturnStatus status = SUCCESS;
    Fs_Stream *filePtr;		/* file to actually read from */
    off_t fileOffset;		/* where in the file to read from */
    off_t fileSize;		/* size of the file */
    Fs_PageType pageType;	/* heap, swap, etc. */
    Time startTime;		/* instrumentation */
    Time endTime;		/* ditto */
    Boolean isCopy = FALSE;	/* is this for a segment copy operation? 
				 * (instrumentation) */

    if (bytesWanted > vm_page_size) {
	panic("memory_object_data_request: kernel wants more than a page\n");
    }

    /* 
     * Get the segment that's to be read from and do some sanity checks. 
     */
    segPtr = Vm_PortToSegment(objectPort);
    if (segPtr == NULL) {
	status = FAILURE;	/* XXX - be more specific? */
    } else {
	VmSegmentLock(segPtr);
	if (!ControlPortOkay(segPtr, controlPort,
			     "memory_object_data_request")) {
	    status = FAILURE;	/* XXX - be more specific? */
	}
	if (segPtr->state == VM_SEGMENT_DYING ||
	    	segPtr->state == VM_SEGMENT_DEAD) {
	    printf("memory_object_data_request: dead segment.\n");
	    status = VM_SWAP_ERROR;
	}
    }

    if (status == SUCCESS && segOffset + bytesWanted > segPtr->size) {
	printf("memory_object_data_read: kernel requested 0x%x bytes",
	       bytesWanted);
	printf(" starting at 0x%x\n", segOffset);
	printf("(segment size is 0x%x\n", segPtr->size);
	status = FS_INVALID_ARG; /* XXX be more specific */
    }
    isCopy = (segPtr->flags & (VM_COPY_SOURCE | VM_COPY_TARGET));
    if (segPtr != NULL) {
	VmSegmentUnlock(segPtr);
    }

    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }

    /* 
     * Figure out which file to read from and read in the bytes.
     */

    Sync_GetLock(&bufferLock);
    if (status == SUCCESS) {
	status = WhichFile(segPtr, segOffset, FS_READ, &filePtr, &fileOffset,
			   &pageType, &fileSize);
	if (status == SUCCESS) {
	    status = FillBuffer(filePtr, fileSize, fileOffset, bytesWanted,
				pageType, segPtr, pagingBuffer);
	}
    }

    if (status != SUCCESS) {
	printf("Can't satisfy page-in request for segment %s ",
	       Vm_SegmentName(segPtr));
	printf("(0x%x bytes starting at segment offset 0x%x):\n", 
	       bytesWanted, segOffset);
	printf("%s\n", Stat_GetMsg(status));
	(void)memory_object_data_error(controlPort, segOffset, bytesWanted,
				       status);
    } else {
	/* 
	 * Give the bytes to the kernel.  Write-protect code pages.
	 * Provide no special protection for other pages.
	 */
	(void)memory_object_data_supply(controlPort, segOffset,
					(pointer_t)pagingBuffer,
					bytesWanted, FALSE,
					(segPtr->type == VM_CODE
					 ? VM_PROT_WRITE
					 : VM_PROT_NONE),
					TRUE, MACH_PORT_NULL);
	VmSegmentLock(segPtr);
	segPtr->residentPages++;
	VmSegmentUnlock(segPtr);
    }

    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(vmStat.readTime[segPtr->type], endTime,
		 &vmStat.readTime[segPtr->type]);
	if (isCopy) {
	    Time_Add(vmStat.readCopyTime[segPtr->type], endTime,
		     &vmStat.readCopyTime[segPtr->type]);
	}
    }

    Sync_Unlock(&bufferLock);

    if (segPtr != NULL) {
	Vm_SegmentRelease(segPtr);
    } 
    (void)mach_port_deallocate(mach_task_self(), controlPort);

    return KERN_SUCCESS;
}


/*
 *----------------------------------------------------------------------
 *
 * memory_object_terminate --
 *
 *	Clean up for an unused segment.
 *
 * Results:
 *	Returns KERN_SUCCESS.
 *
 * Side effects:
 *	Destroys the control and name ports.  If there are no references 
 *	left, the segment is destroyed.
 *
 *----------------------------------------------------------------------
 */

kern_return_t
memory_object_terminate(objectPort, controlPort, namePort)
    memory_object_t	objectPort; /* the memory object */
    memory_object_control_t	controlPort;
    memory_object_name_t	namePort;
{
    kern_return_t kernStatus;
    Vm_Segment *segPtr;
    Time startTime, endTime;	/* instrumentation */

    vmStat.terminateCalls++;
    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }

    /* 
     * Figure out which segment is supposed to go away and do some sanity 
     * checks. 
     */
    segPtr = Vm_PortToSegment(objectPort);
    if (segPtr == NULL) {
	printf("memory_object_terminate: unknown segment.\n");
	(void)mach_port_destroy(mach_task_self(), controlPort);
	(void)mach_port_destroy(mach_task_self(), namePort);
	return KERN_INVALID_CAPABILITY;
    }

    VmSegmentLock(segPtr);
    (void)ControlPortOkay(segPtr, controlPort,
			  "memory_object_terminate");

    if (segPtr->flags & VM_CLEANING_SEGMENT) {
	/* 
	 * Panic, so that we can poke around and see what's happening.
	 */
	panic("memory_object_terminate: segment %s is still being cleaned?\n",
	      Vm_SegmentName(segPtr));
	segPtr->flags &= ~VM_CLEANING_SEGMENT;
	/* 
	 * XXX Should we just always do this broadcast, whether or not the
	 * "cleaning" flag is set?
	 */
	Sync_Broadcast(&segPtr->condition);
    }

    /* 
     * Check for a possible race condition where a new init request 
     * arrived before the terminate request.  If that happened, the 
     * control port will be different.  If there was a new init request but 
     * the segment is being shut down, complain, but wait for a second 
     * terminate request before nulling out the control port.
     */
    if (segPtr->controlPort == controlPort) {
	segPtr->controlPort = MACH_PORT_NULL;
    } else {
	if (segPtr->state != VM_SEGMENT_OK) {
	    printf("%s: re-initialized a dead segment (%s).\n",
		   "memory_object_terminate", Vm_SegmentName(segPtr));
	}
    }

    /* 
     * If the segment is dying, the "terminate" request means that 
     * there are no dirty pages to write back, so mark the segment as 
     * really dead. 
     */
    if (segPtr->state != VM_SEGMENT_DEAD) {
	segPtr->state = VM_SEGMENT_DEAD;
	Sync_Broadcast(&segPtr->condition);
    }

    /* 
     * The other routines (data_request, etc.) should have been 
     * freeing their references to the control port as the references
     * were obtained.  So we could theoretically get rid of the
     * control and name ports by deallocating the one or two remaining
     * send references and the receive reference.  But rather than
     * fiddling around with trying to get the reference counts right,
     * let's just blow the ports out of the water and be done with it.
     */

    kernStatus = mach_port_destroy(mach_task_self(), controlPort);
    if (kernStatus != KERN_SUCCESS) {
	printf("Can't destroy control port for segment %s: %s\n",
	       Vm_SegmentName(segPtr), mach_error_string(kernStatus));
    }
    kernStatus = mach_port_destroy(mach_task_self(), namePort);
    if (kernStatus != KERN_SUCCESS) {
	printf("Can't destroy name port for segment %s: %s\n",
	       Vm_SegmentName(segPtr), mach_error_string(kernStatus));
    }

    VmSegmentUnlock(segPtr);
    Vm_SegmentRelease(segPtr);

    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(endTime, vmStat.terminateTime, &vmStat.terminateTime);
    }

    return KERN_SUCCESS;
}


/*
 *----------------------------------------------------------------------
 *
 * memory_object_copy --
 *
 *	Handle notification that an object has been copied.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	panics--shouldn't ever get called.
 *
 *----------------------------------------------------------------------
 */

/* ARGSUSED */
kern_return_t
memory_object_copy(oldObjectPort, controlPort, offset, length,
		   newObjectPort)
    memory_object_t	oldObjectPort;
    memory_object_control_t	controlPort;
    vm_offset_t		offset;
    vm_size_t		length;
    memory_object_t	newObjectPort;
{
    panic("memory_object_copy called.\n");
    return KERN_SUCCESS;
}


/*
 *----------------------------------------------------------------------
 *
 * memory_object_data_unlock --
 *
 *	Handle a request from the kernel to change the protection of some
 *	memory.  We normally use permissions at the level of vm_map and
 *	vm_protect to control access to memory.  The only exception so far
 *	is when we're flushing a dirty segment, in which case we wait for 
 *	the flush operation to complete before re-enabling permissions.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

/* ARGSUSED */
kern_return_t
memory_object_data_unlock(objectPort, controlPort, offset, length,
			  desiredAccess)
    memory_object_t	objectPort;
    memory_object_control_t	controlPort;
    vm_offset_t		offset;
    vm_size_t		length;
    vm_prot_t		desiredAccess;
{
    Vm_Segment *segPtr;
    char *segName;

    /* 
     * Print a debugging message with the name of the segment.
     */
    segPtr = Vm_PortToSegment(objectPort);
    segName = (segPtr == NULL) ? "<bogus segment>" : Vm_SegmentName(segPtr);
    printf("memory_object_data_unlock request for %s.\n", segName);

    /* 
     * Drop the request on the floor.
     */
    return KERN_SUCCESS;
}


/*
 *----------------------------------------------------------------------
 *
 * memory_object_lock_completed --
 *
 *	Handle notification from the server that a 
 *	memory_object_lock_request call has been completed.  Currently 
 *	this is used only to indicate that a segment's dirty pages 
 *	have all been flushed to disk.  (Because the operation is on the 
 *	entire segment, the "offset" and "length" parameters are ignored.)
 *
 * Results:
 *	Returns KERN_SUCCESS, which is ignored.
 *
 * Side effects:
 *	Clears the flag telling that the segment is being cleaned.  If 
 *	the segment is being destroyed, tell the kernel to kill it.
 *	Does NOT unprotect the segment--that's up to the code that 
 *	originally invoked the cleaning operation.
 *
 *----------------------------------------------------------------------
 */

/* ARGSUSED */
kern_return_t
memory_object_lock_completed(objectPort, controlPort, offset, length)
    memory_object_t	objectPort;
    memory_object_control_t	controlPort;
    vm_offset_t		offset;
    vm_size_t		length;
{
    Vm_Segment *segPtr;
    Time startTime, endTime;	/* instrumentation */

    vmStat.lockCompletedCalls++;
    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }

    /* 
     * Figure out which segment is referred to, and do some sanity checks. 
     */
    segPtr = Vm_PortToSegment(objectPort);
    if (segPtr == NULL) {
	printf("memory_object_lock_completed: bogus segment.\n");
	goto punt;
    }
    VmSegmentLock(segPtr);
    if (!ControlPortOkay(segPtr, controlPort,
			 "memory_object_lock_completed")) {
	goto punt;
    }

    /* 
     * If there was an I/O error flushing the segment, its "cleaning" flag 
     * might have gotten turned off.
     */
    if (!(segPtr->flags & VM_CLEANING_SEGMENT)
	    && segPtr->state == VM_SEGMENT_OK) {
	printf("memory_object_lock_completed: wasn't cleaning %s?",
	       Vm_SegmentName(segPtr));
    }
    segPtr->flags &= ~VM_CLEANING_SEGMENT;
    Sync_Broadcast(&segPtr->condition);

    /* 
     * If the segment is being destroyed and all the dirty pages have 
     * been flushed to disk, then it's time to kill the memory object.  
     * Final cleanup will be done when the kernel notifies us that 
     * it's done with the memory object.
     */
    if (segPtr->state == VM_SEGMENT_DYING) {
	segPtr->state = VM_SEGMENT_DEAD;
    }
    if (segPtr->state == VM_SEGMENT_DEAD) {
	(void)memory_object_destroy(segPtr->controlPort, 0);
    } 

 punt:
    if (segPtr != NULL) {
	VmSegmentUnlock(segPtr);
	Vm_SegmentRelease(segPtr);
    }
    (void)mach_port_deallocate(mach_task_self(), controlPort);

    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(endTime, vmStat.lockCompletedTime,
		 &vmStat.lockCompletedTime);
    }

    return KERN_SUCCESS;
}


/*
 *----------------------------------------------------------------------
 *
 * FillBuffer --
 *
 *	Set up a page to pass to the kernel.
 *
 * Results:
 *	Returns a Sprite status code and fills in the given buffer (usually 
 *	zero-fill or read a page from the backing stream).
 *
 * Side effects:
 *	Might reposition the backing stream.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
FillBuffer(filePtr, fileLength, offset, bytesToRead, pageType, segPtr,
	   buffer)
    Fs_Stream *filePtr;		/* the file to read from; possibly nil */
    off_t fileLength;		/* number of bytes in the file */
    off_t offset;		/* where in the file to start reading */
    vm_size_t bytesToRead;	/* number of bytes to read */
    Fs_PageType pageType;	/* CODE, HEAP, or SWAP */
    Vm_Segment *segPtr;		/* the segment that needs bytes */
    Address buffer;		/* where to put the characters; should 
				 * be protected against concurrent access */
{
    ReturnStatus status;
    int bufferLength;		/* number of bytes in the buffer */
#if !VM_KNOWS_SWAP_FILE_SIZE
    Fs_Attributes fileAttributes;
#endif
    
    bufferLength = bytesToRead;

#if VM_KNOWS_SWAP_FILE_SIZE
    if (fileLength == -1) {
	panic("FillBuffer: file size was never initialized.\n");
    }
#else
    if (filePtr != NULL) {
	status = VmGetAttrStream(filePtr, &fileAttributes);
	if (status != SUCCESS) {
	    return status;
	}
	fileLength = fileAttributes.size;
    }
#endif

    /* 
     * There are generally three possibilities: (a) the requested page does
     * not intersect the backing file, so no read is necessary; (b) the
     * requested page is the last page of the file, but the file is not an 
     * integral number of pages, so a partial read is necessary; (c) the
     * requested page can be satisfied completely from the backing file, so
     * a whole-page read is necessary.
     * 
     * The exception to the above rule is a performance hack.  When a swap
     * segment is being copied, there's no need to get the correct page for 
     * the target (new) segment, as it will be overwritten via vm_write.  
     * Unfortunately, it's not clear whether this hack is actually a win.
     */
    if (offset >= fileLength || (segPtr->flags & VM_COPY_TARGET)) {
	bytesToRead = 0;				/* (a) */
	vmStat.pagesZeroed[segPtr->type]++;
    } else if (offset + bytesToRead > fileLength) {
	bytesToRead = fileLength - offset;		/* (b) */
	vmStat.partialPagesRead[segPtr->type]++;
    } else {
	vmStat.pagesRead[segPtr->type]++;		/* (c) */
    }

    if (bytesToRead == 0) {
	if (segPtr->flags & VM_COPY_SOURCE) {
	    vmStat.sourceCopyZeroed++;
	} else if (segPtr->flags & VM_COPY_TARGET) {
	    vmStat.targetCopyZeroed++;
	}
    } else {
	if (segPtr->flags & VM_COPY_SOURCE) {
	    vmStat.sourceCopyRead++;
	} else if (segPtr->flags & VM_COPY_TARGET) {
	    vmStat.targetCopyRead++;
	}
    }

    if (bytesToRead != 0) {
	if (filePtr == NULL) {
	    panic("FillBuffer: nil file handle.\n");
	}
	status = Fs_PageRead(filePtr, buffer, (int)offset,
			     (int)bytesToRead, pageType);
	if (status != SUCCESS) {
	    return status;
	}
    }

    if (bytesToRead < bufferLength) {
	bzero(buffer+bytesToRead, (size_t)(bufferLength - bytesToRead));
    }

    return SUCCESS;
}


/*
 *----------------------------------------------------------------------
 *
 * VmCleanSegPages --
 *
 *	Ask the kernel to clean any dirty pages belonging to the given 
 *	locked segment.  
 *
 * Results:
 *	None.  If the caller needs to wait for the writebacks, it should
 *	wait until the VM_CLEANING_SEGMENT flag is clear.
 *
 * Side effects:
 *	Can start write operations on the dirty pages.  Write-protects the 
 *	segment if requested.
 *
 *----------------------------------------------------------------------
 */

void
VmCleanSegPages(segPtr, writeProtect, numBytes, fromFront)
    Vm_Segment *segPtr;
    Boolean writeProtect;	/* prevent user processes from dirtying the 
				 * segment */
    vm_size_t numBytes;		/* number of bytes to clean; 0 means entire
				 * segment */
    Boolean fromFront;		/* clean bytes at front of segment or at 
				 * end? */ 
{
    kern_return_t kernStatus;
    vm_offset_t firstClean;	/* first byte in segment to clean */
    vm_size_t bytesClean;	/* bytes to clean */

    /* 
     * If we've already decided that writebacks won't work, don't bother.
     */
    if (segPtr->state == VM_SEGMENT_DEAD) {
	return;
    }

    /* 
     * If the segment's control port is "dead", it means the segment 
     * has been registered with the kernel, but the kernel hasn't done 
     * anything with it.  Thus there can't be any pages to flush, so 
     * we can quit now.
     */
    if (segPtr->controlPort == MACH_PORT_DEAD) {
	return;
    }

    /* 
     * If the control port is null, it means the segment hasn't been 
     * registered yet.  This is a bad sign and deserves investigation. 
     */
    if (segPtr->controlPort == MACH_PORT_NULL) {
	panic("VmCleanSegPages: unregistered segment.\n");
    }

    segPtr->flags |= VM_CLEANING_SEGMENT;

    if (numBytes == 0) {
	firstClean = 0;
	bytesClean = segPtr->size;
    } else {
	firstClean = (fromFront ? 0 : segPtr->size - numBytes);
	bytesClean = numBytes;
    }
    kernStatus = memory_object_lock_request(segPtr->controlPort,
					    trunc_page(firstClean),
					    round_page(bytesClean), TRUE,
					    FALSE,
					    (writeProtect
					     ? VM_PROT_WRITE
					     : VM_PROT_NO_CHANGE),
					    segPtr->requestPort);
    if (kernStatus != KERN_SUCCESS) {
	printf("VmCleanSegPages: lock request failed: %s\n",
	       mach_error_string(kernStatus));
    }
}


/*
 *----------------------------------------------------------------------
 *
 * IsFatalError --
 *
 *	Decide whether an operation should be retried, given an error 
 *	code.
 *
 * Results:
 *	TRUE if the error is fatal (don't retry); FALSE otherwise.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Boolean
IsFatalError(errorCode)
    int errorCode;		/* Sprite error code */
{
    /* 
     * XXX there are probably a bunch more recoverable errors; talk to 
     * the other Spriters to find out which ones.
     */
    return (errorCode != FS_NO_DISK_SPACE && errorCode != SUCCESS &&
	    !Fsutil_RecoverableError(errorCode));
}


/*
 *----------------------------------------------------------------------
 *
 * VmPagerInit --
 *
 *	Initialization for the pager routines.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Allocates the page-in buffer.
 *
 *----------------------------------------------------------------------
 */

void
VmPagerInit()
{
    vm_allocate(mach_task_self(), (vm_address_t *)&pagingBuffer,
		vm_page_size, TRUE);
    if (pagingBuffer == NULL) {
	panic("Can't create paging buffer.\n");
    }
}


/*
 *----------------------------------------------------------------------
 *
 * ControlPortOkay --
 *
 *	Paranoia checks on a segment's control ports.
 *
 * Results:
 *	Returns TRUE if everything looks good.  Returns FALSE if the 
 *	segment's control port doesn't match the given control port.
 *
 * Side effects:
 *	Panics if the segment's control port don't indicate an 
 *	initialized memory object.
 *
 *----------------------------------------------------------------------
 */

static Boolean
ControlPortOkay(segPtr, givenControlPort, functionName)
    Vm_Segment *segPtr;		/* the segment to check, locked */
    mach_port_t givenControlPort;
    char *functionName;		/* name of the calling function */
{
    /* 
     * The check against MACH_PORT_NULL is especially important, 
     * because if the registered control port is null, that increases 
     * the likelihood that the segment will get incorrectly freed.  
     * The check against MACH_PORT_DEAD is just extra paranoia.
     */
    if (segPtr->controlPort == MACH_PORT_NULL
		|| segPtr->controlPort == MACH_PORT_DEAD) {
	panic("ControlPortOkay: %s got bogus control port.\n", functionName);
    }
    if (segPtr->controlPort != givenControlPort) {
	printf("%s: control port mismatch.\n", functionName);
	return FALSE;
    }

    return TRUE;
}


/*
 *----------------------------------------------------------------------
 *
 * WhichFile --
 *
 *	Given a segment and an offset, figure out which backing file 
 *	to use and where in the file to go.
 *
 * Results:
 *	Returns a Sprite status code.  If successful, fills in the file 
 *	pointer, file offset, FS page type, and file size.  If the file 
 *	doesn't exist, the pointer is set to nil and the size is set to 0.
 *
 * Side effects:
 *	Opens the swap file if writing to a heap or stack segment for the 
 *	first time. 
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
WhichFile(segPtr, segOffset, readWrite, filePtrPtr, fileOffsetPtr,
	  pageTypePtr, fileSizePtr)
    Vm_Segment *segPtr;		/* the segment we're doing I/O for; 
				 * should be locked */
    vm_offset_t segOffset;	/* where in the segment */
    int readWrite;		/* FS_READ or FS_WRITE */
    Fs_Stream **filePtrPtr;	/* OUT: which backing file to use */
    off_t *fileOffsetPtr;	/* OUT: where in the file to go */
    Fs_PageType *pageTypePtr;	/* OUT: FS type for the page */
    off_t *fileSizePtr;		/* OUT: size of the backing file */
{
    ReturnStatus status = SUCCESS;

    switch (segPtr->type) {
    case VM_CODE:
	*filePtrPtr = segPtr->swapFilePtr;
	*fileOffsetPtr = segOffset;
	*pageTypePtr = FS_CODE_PAGE;
	*fileSizePtr = segPtr->swapFileSize;
	break;
    case VM_HEAP:
	if (segOffset != trunc_page(segOffset)) {
	    panic("WhichFile: heap segment offset not page-aligned.\n");
	}
	status = WhichHeapFile(segPtr, segOffset, readWrite, filePtrPtr,
			       fileOffsetPtr, pageTypePtr, fileSizePtr);
	break;
    case VM_STACK:
	if (segOffset != trunc_page(segOffset)) {
	    panic("WhichFile: stack segment offset not page-aligned.\n");
	}
	status = WhichStackFile(segPtr, segOffset, readWrite, filePtrPtr,
			       fileOffsetPtr, pageTypePtr, fileSizePtr);
	break;
    case VM_SHARED:
	*filePtrPtr = segPtr->swapFilePtr;
	*fileOffsetPtr = segOffset;
	*pageTypePtr = FS_SHARED_PAGE;
	*fileSizePtr = segPtr->swapFileSize;
	break;
    default:
	panic("WhichFile: bogus segment type.\n");
	break;
    }

    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * WhichHeapFile --
 * 
 *	Given a heap segment and an offset, figure out which backing 
 *	file to use and where in the file to go.
 *
 * Results:
 *	Returns a Sprite status code.  If successful, fills in the file 
 *	pointer (possibly nil), file offset, FS page type, and file size.
 *
 * Side effects:
 *	For write operations, might update the mapping telling whether 
 *	to use the initialization file, and might open the swap file.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
WhichHeapFile(segPtr, segOffset, readWrite, filePtrPtr, fileOffsetPtr,
	      pageTypePtr, fileSizePtr)
    Vm_Segment *segPtr;		/* the heap segment we're doing I/O for; 
				 * should be locked */
    vm_offset_t segOffset;	/* where in the segment */
    int readWrite;		/* FS_READ or FS_WRITE */
    Fs_Stream **filePtrPtr;	/* OUT: which backing file to use */
    off_t *fileOffsetPtr;	/* OUT: where in the file to go */
    Fs_PageType *pageTypePtr;	/* OUT: HEAP or SWAP */
    off_t *fileSizePtr;		/* OUT: size of the backing file */
{
    VmFileMap *mapPtr;		/* the map for the segment, telling 
				 * which file to use */
    char *useInitFilePtr;	/* ptr to the entry for the given offset */
    int pageNum;		/* page number for segment offset */
    Boolean useInitFile = FALSE;
    ReturnStatus status = SUCCESS;
#if !VM_KNOWS_SWAP_FILE_SIZE
    Fs_Attributes fileAttributes;
#endif

    /* 
     * Figure out whether to use the initialization (object) file or the 
     * swap file.
     */
    mapPtr = segPtr->typeInfo.heapInfo.mapPtr;
    pageNum = Vm_ByteToPage(segOffset);
    if (pageNum >= mapPtr->arraySize) {
	useInitFile = FALSE;
    } else {
	useInitFilePtr = mapPtr->useInitPtr + pageNum;
	if (readWrite == FS_WRITE) {
	    *useInitFilePtr = FALSE;
	}
	useInitFile = *useInitFilePtr;
    }

    /* 
     * Open the swap file if necessary.
     */
    if (readWrite == FS_WRITE && segPtr->swapFilePtr == NULL) {
	status = VmOpenSwapFile(segPtr);
	if (status != SUCCESS) {
	    return status;
	}
    }

    /*
     * Get the results for whichever file we decided to use.
     */
    if (useInitFile) {
	*filePtrPtr = segPtr->typeInfo.heapInfo.initFilePtr;
	*fileOffsetPtr = segPtr->typeInfo.heapInfo.initStart + segOffset;
	*pageTypePtr = FS_HEAP_PAGE;
	*fileSizePtr = segPtr->typeInfo.heapInfo.initStart +
	    		segPtr->typeInfo.heapInfo.initLength;
    } else {
	*filePtrPtr = segPtr->swapFilePtr;
	*pageTypePtr = FS_SWAP_PAGE;
	if (segPtr->swapFilePtr == NULL) {
	    *fileOffsetPtr = 0;
	    *fileSizePtr = 0;
	} else {
	    *fileOffsetPtr = (off_t)segOffset;
#if VM_KNOWS_SWAP_FILE_SIZE
	    *fileSizePtr = segPtr->swapFileSize;
#else
	    status = VmGetAttrStream(segPtr->swapFilePtr, &fileAttributes);
	    if (status != SUCCESS) {
		return status;
	    }
	    *fileSizePtr = fileAttributes.size;
#endif
	}
    }

    return SUCCESS;
}


/*
 *----------------------------------------------------------------------
 *
 * WhichStackFile --
 *
 *	Given a stack segment and an offset, get the backing file and the 
 *	corresponding offset in it.
 *
 * Results:
 *	Returns a Sprite status code.  If successful, fills in the file 
 *	pointer (possibly nil), file offset, FS page type, and file size.
 *
 * Side effects:
 *	Opens the swap file if writing to it for the first time.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
WhichStackFile(segPtr, segOffset, readWrite, filePtrPtr, fileOffsetPtr,
	      pageTypePtr, fileSizePtr)
    Vm_Segment *segPtr;		/* the heap segment we're doing I/O for; 
				 * should be locked */
    vm_offset_t segOffset;	/* where in the segment */
    int readWrite;		/* FS_READ or FS_WRITE */
    Fs_Stream **filePtrPtr;	/* OUT: which backing file to use */
    off_t *fileOffsetPtr;	/* OUT: where in the file to go */
    Fs_PageType *pageTypePtr;	/* OUT: SWAP */
    off_t *fileSizePtr;		/* OUT: size of the backing file */
{
    ReturnStatus status = SUCCESS;
#if !VM_KNOWS_SWAP_FILE_SIZE
    Fs_Attributes fileAttributes;
#endif

    /* 
     * Open the swap file if necessary.  If there's an error, the 
     * segment's swap file pointer will remain nil, so there's no need 
     * for an explicit error check here.
     */
    if (readWrite == FS_WRITE && segPtr->swapFilePtr == NULL) {
	status = VmOpenSwapFile(segPtr);
    }
    *filePtrPtr = segPtr->swapFilePtr;
    *pageTypePtr = FS_SWAP_PAGE;
    if (segPtr->swapFilePtr == NULL) {
	*fileOffsetPtr = 0;
	*fileSizePtr = 0;
    } else {
	*fileOffsetPtr = (PROCMACH_STACK_GROWS_DOWN
			  ? segPtr->size - vm_page_size - segOffset
			  : segOffset);
#if VM_KNOWS_SWAP_FILE_SIZE
	*fileSizePtr = segPtr->swapFileSize;
#else
	status = VmGetAttrStream(segPtr->swapFilePtr, &fileAttributes);
	if (status != SUCCESS) {
	    return status;
	}
	*fileSizePtr = fileAttributes.size;
#endif
    }

    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * memory_object_supply_completed --
 *
 *	Called by kernel to indicate that a previous 
 *	memory_object_data_supply call has completed.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

kern_return_t
memory_object_supply_completed(objectPort, controlPort, offset, length,
			       result, error_offset)
    memory_object_t	objectPort;
    memory_object_control_t controlPort;
    vm_offset_t		offset;
    vm_size_t		length;
    kern_return_t	result;
    vm_offset_t		error_offset;
{
#ifdef	lint
    objectPort++; controlPort++; offset++;
    length++; result++; error_offset++;
#endif	lint
    panic("memory_object_supply_completed called.\n");
    return KERN_SUCCESS;	/* lint */
}


/*
 *----------------------------------------------------------------------
 *
 * memory_object_data_return --
 *
 *	Take back or clean pages from the kernel.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Dirty pages are cleaned.  The resident page count for the segment 
 *	is updated.
 *
 *----------------------------------------------------------------------
 */

kern_return_t
memory_object_data_return(objectPort, controlPort, segStart, data, dataCount,
			  dirty, kernelCopy)
    mach_port_t objectPort;	/* the object being cleaned */
    mach_port_t controlPort;	/* its control port */
    vm_offset_t segStart;	/* where in segment to start writing back */
    pointer_t data;		/* the bytes to write or deallocate */
    vm_size_t dataCount;	/* how many bytes */
    boolean_t dirty;		/* is write-back needed? */
    boolean_t kernelCopy;	/* did the kernel keep a copy? */
{
    Vm_Segment *segPtr;
    int bytesLeft;		/* number of bytes left to write */
    vm_offset_t segOffset;	/* current offset in the segment */
    ReturnStatus status = FAILURE;
    Fs_Stream *filePtr;		/* backing file to write to */
    off_t fileOffset;		/* where in the file to write to */
    off_t fileSize;		/* dummy size for WhichFile */
    Fs_PageType pageType;	/* type of page to write (ignored) */
    Time startTime;		/* instrumentation */
    Time endTime;		/* ditto */

    vmStat.returnCalls++;
    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }

    segPtr = Vm_PortToSegment(objectPort);
    if (segPtr == NULL) {
	printf("memory_object_data_return: bogus segment.\n");
	goto punt;
    }
    VmSegmentLock(segPtr);

    /* 
     * Sanity checks.
     */
    if (!ControlPortOkay(segPtr, controlPort, "memory_object_data_return")) {
	goto punt;
    }
    if (dirty && segPtr->state == VM_SEGMENT_DEAD) {
	printf("%s: trying to write back dead segment %s.\n",
	       "memory_object_data_return", Vm_SegmentName(segPtr));
	goto punt;
    }
    if (segStart + dataCount > segPtr->size) {
	panic("memory_object_data_return: writing off end of segment.\n");
    }
    if (dirty && segPtr->type == VM_CODE) {
	panic("memory_object_data_return: dirty code pages.\n");
    }
    if (dataCount != trunc_page(dataCount)) {
	panic("memory_object_data_return: writing partial page.\n");
    }
    if (!dirty && kernelCopy) {
	printf("memory_object_data_return: pointless call for %s\n",
	       Vm_SegmentName(segPtr));
    }

    status = SUCCESS;

    /* 
     * Write back each dirty page that was given to us.  To do this, 
     * first figure out which backing file to use and where in the file to
     * go.
     */
    for (segOffset = segStart, bytesLeft = dataCount;
		bytesLeft > 0;
		segOffset += vm_page_size, bytesLeft -= vm_page_size) {
	if (!kernelCopy) {
	    segPtr->residentPages--;
	    if (segPtr->residentPages < 0) {
		panic("memory_object_data_return: page count botch.\n");
	    }
	}
	if (!dirty) {
	    continue;
	}
	status = WhichFile(segPtr, segOffset, FS_WRITE, &filePtr, &fileOffset,
			   &pageType, &fileSize);
	if (status == SUCCESS) {
	    /* 
	     * Don't keep the segment locked while doing I/O.
	     */
	    VmSegmentUnlock(segPtr);
	    status = WriteBack(segPtr, filePtr, fileOffset,
			       (Address)(data + segOffset - segStart));
	    VmSegmentLock(segPtr);
	}
	if (status != SUCCESS) {
	    printf("memory_object_data_return: segment %s marked dead: %s\n",
		   Vm_SegmentName(segPtr), Stat_GetMsg(status));
	    segPtr->state = VM_SEGMENT_DEAD;
	    Sync_Broadcast(&segPtr->condition);
	    memory_object_destroy(controlPort, status);
	    break;
	}
    }
    
 punt:
    if (segPtr != NULL) {
	VmSegmentUnlock(segPtr);
	Vm_SegmentRelease(segPtr);
    }
    (void)vm_deallocate(mach_task_self(), data, (vm_size_t)dataCount);
    (void)mach_port_deallocate(mach_task_self(), controlPort);

    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(endTime, vmStat.writeTime[segPtr->type],
		 &vmStat.writeTime[segPtr->type]);
    }

    return KERN_SUCCESS;
}


/*
 *----------------------------------------------------------------------
 *
 * memory_object_change_completed --
 *
 *	yet another unused routine we have to provide a stub for.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

kern_return_t
memory_object_change_completed(objectPort, machCache, copyStrategy)
    memory_object_t	objectPort;
    boolean_t		machCache;
    int			copyStrategy;
{
#ifdef	lint
    objectPort++; machCache++; copyStrategy++;
#endif	lint
    panic("(inode_pager)change_completed: called");
    return KERN_SUCCESS;	/* lint */
}


/*
 *----------------------------------------------------------------------
 *
 * Vm_Recovery --
 *
 *	The swap area has just come back up.  Wake up anyone waiting for it to
 *	come back and start up page cleaners if there are dirty pages to be
 *	written out.
 *	
 *	Currently a no-op.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
Vm_Recovery()
{
}
@


1.26
log
@Change page read/write instrumentation to be per segment type.  Update
the read instrumentation time while protected by the read buffer lock.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.25 92/06/29 16:13:40 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d112 1
a112 1
	Timer_GetTimeOfDay(&startTime, NULL, NULL);
d177 1
a177 1
	Timer_GetTimeOfDay(&endTime, NULL, NULL);
d210 8
d477 1
a477 1
	Timer_GetTimeOfDay(&startTime, NULL, NULL);
d563 1
a563 1
	Timer_GetTimeOfDay(&endTime, NULL, NULL);
d686 1
a686 1
	Timer_GetTimeOfDay(&startTime, NULL, NULL);
d738 1
a738 1
	Timer_GetTimeOfDay(&endTime, NULL, NULL);
@


1.26.1.1
log
@Hack instrumentation to get contention for data_request buffer.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.26 92/07/08 12:47:46 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
a54 1
Time bufferLockTime;		/* temp */
a55 1

a336 1
    Time startSubTime, endSubTime; /* temp */
a382 5
    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startSubTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startSubTime = time_ZeroSeconds;
    }
a383 6
    if (sys_CallProfiling && !Time_EQ(startSubTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endSubTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endSubTime, startSubTime, &endSubTime);
	Time_Add(endSubTime, bufferLockTime, &bufferLockTime);
    }

@


1.25
log
@Instrument all of the pager calls.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.24 92/06/25 15:54:56 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d62 1
a62 1
		Fs_PageType pageType, int segFlags, Address buffer));
d255 1
a255 1
	    vmStat.pagesWritten++;
d257 1
a257 1
		vmStat.pagesCleaned++;
d389 1
a389 1
				pageType, segPtr->flags, pagingBuffer);
a416 6
    Sync_Unlock(&bufferLock);

    if (segPtr != NULL) {
	Vm_SegmentRelease(segPtr);
    } 
    (void)mach_port_deallocate(mach_task_self(), controlPort);
d421 2
a422 1
	Time_Add(vmStat.readTime, endTime, &vmStat.readTime);
d424 2
a425 1
	    Time_Add(vmStat.readCopyTime, endTime, &vmStat.readCopyTime);
d429 7
d758 1
a758 1
FillBuffer(filePtr, fileLength, offset, bytesToRead, pageType, segFlags,
d765 1
a765 1
    int segFlags;		/* flags from the segment that needs bytes */
d804 1
a804 1
    if (offset >= fileLength || (segFlags & VM_COPY_TARGET)) {
d806 1
a806 1
	vmStat.pagesZeroed++;
d809 1
a809 1
	vmStat.partialPagesRead++;
d811 1
a811 1
	vmStat.pagesRead++;				/* (c) */
d815 1
a815 1
	if (segFlags & VM_COPY_SOURCE) {
d817 1
a817 1
	} else if (segFlags & VM_COPY_TARGET) {
d821 1
a821 1
	if (segFlags & VM_COPY_SOURCE) {
d823 1
a823 1
	} else if (segFlags & VM_COPY_TARGET) {
d1430 2
a1431 1
	Time_Add(endTime, vmStat.writeTime, &vmStat.writeTime);
@


1.24
log
@Forgot to fix a comment before checking in the previous changes.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.23 92/06/25 15:54:03 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d108 1
d110 7
d175 7
d335 2
d367 2
a368 1
    } 
d422 2
d428 3
a432 1
    (void)mach_port_deallocate(mach_task_self(), controlPort);
d462 8
d551 6
d671 8
d725 8
d1337 7
a1376 5
    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }
a1415 6
    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(endTime, vmStat.writeTime, &vmStat.writeTime);
    }

d1423 7
@


1.23
log
@Don't bother going to the file server for a data request for the
target of a segment copy.  Panic if terminating a segment that is
still being cleaned.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.22 92/06/12 14:15:22 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d746 2
a747 1
     * the target (new) segment, as it will be overwritten via vm_write.
@


1.22
log
@Fix for sticky segments: use precious pages and keep track of how many
pages are resident.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.21 92/06/04 14:11:03 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d458 5
a462 1
	printf("memory_object_terminate: segment is still being cleaned?\n");
d693 2
a694 4
 *	Returns a Sprite status code and fills in the given buffer.  
 *	If the request runs beyond the end of the backing file, a 
 *	zero-filled page is returned.  Otherwise, the buffer is filled 
 *	in from the stream.
d710 1
a710 2
    int segFlags;		/* flags from the segment that needs bytes 
				 * (instrumentation)  */
d737 10
a746 6
     * There are three possibilities: (a) the requested page does not
     * intersect the backing file, so no read is necessary; (b) the
     * requested page is the last page of the file, so a partial read
     * is necessary; (c) the requested page can be satisfied
     * completely from the backing file, so a whole-page read is
     * necessary.
d748 1
a748 1
    if (offset >= fileLength) {
d757 1
@


1.21
log
@Support for sticky segments.  Tweaks.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.20 92/06/02 14:59:04 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d157 2
a158 2
	kernStatus = memory_object_set_attributes(controlPort, TRUE, TRUE,
						  MEMORY_OBJECT_COPY_DELAY);
d176 1
a176 1
 *	Take dirty data back from the kernel.
d182 1
a182 1
 *	Flushes the dirty data back to the backing file.
d195 2
a196 93
    Vm_Segment *segPtr;
    int bytesLeft;		/* number of bytes left to write */
    vm_offset_t segOffset;	/* current offset in the segment */
    ReturnStatus status = FAILURE;
    Fs_Stream *filePtr;		/* backing file to write to */
    off_t fileOffset;		/* where in the file to write to */
    off_t fileSize;		/* dummy size for WhichFile */
    Fs_PageType pageType;	/* type of page to write (ignored) */
    Time startTime;		/* instrumentation */
    Time endTime;		/* ditto */

    segPtr = Vm_PortToSegment(objectPort);
    if (segPtr == NULL) {
	printf("memory_object_data_write: bogus segment.\n");
	goto punt;
    }
    VmSegmentLock(segPtr);
    /* 
     * Sanity checks.
     */
    if (!ControlPortOkay(segPtr, controlPort, "memory_object_data_write")) {
	goto punt;
    }
    if (segPtr->state == VM_SEGMENT_DEAD) {
	printf("%s: trying to write back dead segment %s.\n",
	       "memory_object_data_write", Vm_SegmentName(segPtr));
	goto punt;
    }
    if (segStart + dataCount > segPtr->size) {
	panic("memory_object_data_write: writing off end of segment.\n");
    }
    if (segPtr->type == VM_CODE) {
	panic("memory_object_data_write: dirty code pages.\n");
    }

    /* 
     * Assume that the kernel is giving us an integral number of pages 
     * to write back.
     */
    if (dataCount != trunc_page(dataCount)) {
	panic("memory_object_data_write: writing partial page.\n");
    }

    status = SUCCESS;
    if (sys_CallProfiling) {
	Timer_GetTimeOfDay(&startTime, (int *)NULL, (Boolean *)NULL);
    } else {
	startTime = time_ZeroSeconds;
    }

    /* 
     * Write back each page that was given to us.  For each page, 
     * figure out which backing file to use and where in the file to 
     * go. 
     */
    for (segOffset = segStart, bytesLeft = dataCount;
		bytesLeft > 0;
		segOffset += vm_page_size, bytesLeft -= vm_page_size) {
	status = WhichFile(segPtr, segOffset, FS_WRITE, &filePtr, &fileOffset,
			   &pageType, &fileSize);
	if (status == SUCCESS) {
	    /* 
	     * Don't keep the segment locked while doing I/O.
	     */
	    VmSegmentUnlock(segPtr);
	    status = WriteBack(segPtr, filePtr, fileOffset,
			       (Address)(data + segOffset - segStart));
	    VmSegmentLock(segPtr);
	}
	if (status != SUCCESS) {
	    printf("memory_object_data_write: segment %s marked dead: %s\n",
		   Vm_SegmentName(segPtr), Stat_GetMsg(status));
	    segPtr->state = VM_SEGMENT_DEAD;
	    Sync_Broadcast(&segPtr->condition);
	    memory_object_destroy(controlPort, status);
	    break;
	}
    }
    
    if (sys_CallProfiling && !Time_EQ(startTime, time_ZeroSeconds)) {
	Timer_GetTimeOfDay(&endTime, (int *)NULL, (Boolean *)NULL);
	Time_Subtract(endTime, startTime, &endTime);
	Time_Add(endTime, vmStat.writeTime, &vmStat.writeTime);
    }

 punt:
    if (segPtr != NULL) {
	VmSegmentUnlock(segPtr);
	Vm_SegmentRelease(segPtr);
    }
    (void)vm_deallocate(mach_task_self(), data, (vm_size_t)dataCount);
    (void)mach_port_deallocate(mach_task_self(), controlPort);
    return KERN_SUCCESS;
d284 7
d362 1
a362 2
     * Figure out which file to read from, read in the bytes, and pass them 
     * off to the caller.
d384 14
a397 3
	(void)memory_object_data_provided(controlPort, segOffset,
					  (pointer_t)pagingBuffer,
					  bytesWanted, VM_PROT_NONE);
d767 3
d1244 1
a1244 2
 *	Used instead of memory_object_data_write for objects initialized by 
 *	object_ready (support for precious pages).
d1250 2
a1251 1
 *	None.
d1257 1
a1257 1
memory_object_data_return(objectPort, controlPort, offset, data, length,
d1259 7
a1265 7
    memory_object_t	objectPort;
    memory_object_control_t controlPort;
    vm_offset_t		offset;
    vm_offset_t		data;
    vm_size_t		length;
    boolean_t		dirty;
    boolean_t		kernelCopy;
d1267 102
a1368 6
#ifdef	lint
    objectPort++; controlPort++; offset++;
    data++; length++; dirty++; kernelCopy++;
#endif	lint
    panic("memory_object_data_return called");
    return KERN_SUCCESS;	/* lint */
@


1.20
log
@Instrument memory_object_data{request,write}.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.19 92/05/08 12:54:35 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d500 2
a501 2
 *	Destroys the control and name ports.  If the segment is being 
 *	destroyed and there are no references left, nuke it.
d505 1
a505 1
	
d552 2
a553 2
	    printf("%s: re-initialized a dead segment.\n",
		   "memory_object_terminate");
d562 1
a562 1
    if (segPtr->state == VM_SEGMENT_DYING) {
d579 2
a580 2
	printf("Can't destroy control port: %s\n",
	       mach_error_string(kernStatus));
d584 2
a585 2
	printf("Can't destroy name port: %s\n",
	       mach_error_string(kernStatus));
@


1.19
log
@Use vm_read and vm_write to copy heap/stack segments, rather than
using the memory_object interface.  Don't assume that the swap file is
open.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.18 92/04/29 21:43:58 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d203 2
d239 5
d274 6
d402 2
d439 6
d478 5
@


1.18
log
@Fix writeback instrumentation to be more accurate.  Performance
improvements for cleaning dirty segments: (a) allow for cleaning of
only part of a segment; (b) specify VM_PROT_NO_CHANGE if not
write-protecting a segment.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.17 92/04/23 23:41:46 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d62 1
a62 1
		Fs_PageType pageType, Address buffer));
d64 1
a64 1
static void WhichFile _ARGS_((Vm_Segment *segPtr,
d68 1
a68 1
static void WhichHeapFile _ARGS_((Vm_Segment *segPtr,
d72 4
a202 1
    Time startTime, endTime, totalTime;	/* instrumentation */
a203 2
    endTime = startTime = time_ZeroSeconds;

a208 10
    /* 
     * Get the start time if we are profiling.  We should be able to check 
     * the flags before locking the segment, and it's useful to include the 
     * time needed to lock the segment in the profiling time.
     */
    if (sys_CallProfiling &&
	(segPtr->flags & VM_COPYING_SEGMENT) &&
	(segPtr->flags & VM_CLEANING_SEGMENT)) {
	Timer_GetTimeOfDay(&startTime, NULL, NULL);
    }
d246 11
a256 9
	WhichFile(segPtr, segOffset, FS_WRITE, &filePtr, &fileOffset,
		  &pageType, &fileSize);
	/* 
	 * Don't keep the segment locked while doing I/O.
	 */
	VmSegmentUnlock(segPtr);
	status = WriteBack(segPtr, filePtr, fileOffset,
			   (Address)(data + segOffset - segStart));
	VmSegmentLock(segPtr);
a265 3
    if (sys_CallProfiling && status == SUCCESS) {
	Timer_GetTimeOfDay(&endTime, NULL, NULL);
    }
a267 5
    if (!Time_EQ(startTime, time_ZeroSeconds) &&
	!Time_EQ(endTime, time_ZeroSeconds)) {
	Time_Subtract(endTime, startTime, &totalTime);
	Time_Add(vmStat.writeBackTime, totalTime, &vmStat.writeBackTime);
    }
d431 6
a436 4
	WhichFile(segPtr, segOffset, FS_READ, &filePtr, &fileOffset,
		  &pageType, &fileSize);
	status = FillBuffer(filePtr, fileSize, fileOffset, bytesWanted,
			    pageType, pagingBuffer);
d456 1
a456 1
    }
d749 3
a751 2
FillBuffer(filePtr, fileLength, offset, bytesToRead, pageType, buffer)
    Fs_Stream *filePtr;		/* the file to read from */
d756 2
d774 6
a779 3
    status = VmGetAttrStream(filePtr, &fileAttributes);
    if (status != SUCCESS) {
	return status;
a780 1
    fileLength = fileAttributes.size;
d800 13
d1021 3
a1023 1
 *	Fills in the file pointer, file offset, FS page type, and file size.
d1026 2
a1027 1
 *	None.
d1031 1
a1031 2

static void
d1043 2
d1056 2
a1057 2
	WhichHeapFile(segPtr, segOffset, readWrite, filePtrPtr,
		      fileOffsetPtr, pageTypePtr, fileSizePtr);
d1063 2
a1064 8
	*filePtrPtr = segPtr->swapFilePtr;
	if (PROCMACH_STACK_GROWS_DOWN) {
	    *fileOffsetPtr = segPtr->size - vm_page_size - segOffset;
	} else {
	    *fileOffsetPtr = segOffset;
	}
	*pageTypePtr = FS_SWAP_PAGE;
	*fileSizePtr = segPtr->swapFileSize;
d1076 2
d1090 2
a1091 1
 *	Fills in the file pointer, file offset, FS page type, and file size.
d1095 1
a1095 1
 *	to use the initialization file.
d1100 1
a1100 1
static void
d1117 4
d1122 4
d1138 13
a1158 1
	*fileOffsetPtr = (off_t)segOffset;
d1160 15
a1174 1
	*fileSizePtr = segPtr->swapFileSize;
d1176 2
d1184 1
a1184 1
 * VmCopySwapFile --
d1186 2
a1187 1
 *	Copy the used portions of a swap file from one segment to another.
d1190 21
a1210 19
 *	Returns a status code.
 *
 * Side effects:
 *	Fills in the swap file size of the copied-to segment.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
VmCopySwapFile(fromSegPtr, toSegPtr)
    VmMappedSegment *fromSegPtr; /* the segment to copy from, either heap 
				  * or stack; locked */
    Vm_Segment *toSegPtr;	/* the segment to copy to; locked */
{
    off_t fileOffset;		/* offset in the swap file */
    off_t fileSize;		/* size of the swap file */
    Vm_SegmentType segType;	/* heap or stack */
    Fs_Stream *fromFilePtr;	/* swap file for fromSegPtr */
    Fs_Stream *toFilePtr;	/* swap file for toSegPtr */
d1213 1
a1213 1
    Fs_Attributes attributes;
d1216 17
a1232 9
    fromFilePtr = NULL;
    segType = fromSegPtr->segPtr->type;
    if (segType != VM_STACK && segType != VM_HEAP) {
	panic("VmCopySwapFile: bogus segment type.\n");
    }

    fromFilePtr = fromSegPtr->segPtr->swapFilePtr;
    toFilePtr = toSegPtr->swapFilePtr;

d1234 1
a1234 5
    fileSize = fromSegPtr->segPtr->swapFileSize;
    if (fileSize == -1) {
	panic("VmCopySwapFile: file size was never initialized.\n");
    }
    toSegPtr->swapFileSize = fileSize;
d1236 1
a1236 10
    status = VmGetAttrStream(fromFilePtr, &attributes);
    if (status != SUCCESS) {
	return status;
    }
    fileSize = attributes.size;
#endif

    for (fileOffset = 0; fileOffset < fileSize; fileOffset += vm_page_size) {
	status = Fs_PageCopy(fromFilePtr, toFilePtr, (int)fileOffset,
			     (int)vm_page_size);
d1238 1
a1238 1
	    break;
d1240 2
@


1.17
log
@Add some profiling and comments.  Don't write-enable the segment when
done cleaning it.  Add writeProtect argument to VmFlushSegPages.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.16 92/04/16 11:21:42 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d194 1
a194 1
    ReturnStatus status = SUCCESS;
a202 3
    /* 
     * Get the segment that's to be written to and do some sanity checks. 
     */
d208 10
d219 3
d245 2
a251 5
    if (sys_CallProfiling &&
	(segPtr->flags & VM_COPYING_SEGMENT) &&
	(segPtr->flags & VM_CLEANING_SEGMENT)) {
	Timer_GetTimeOfDay(&startTime, NULL, NULL);
    }
d828 1
a828 1
 * VmFlushSegPages --
d845 1
a845 1
VmFlushSegPages(segPtr, writeProtect)
d849 4
d855 2
d880 1
a880 1
	panic("VmFlushSegPages: unregistered segment.\n");
d885 10
a894 2
    kernStatus = memory_object_lock_request(segPtr->controlPort, 0,
					    round_page(segPtr->size), TRUE,
d898 1
a898 1
					     : VM_PROT_NONE),
d901 1
a901 1
	printf("VmFlushSegPages: lock request failed: %s\n",
@


1.16
log
@Add instrumentation.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.15 92/03/12 17:23:32 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d34 1
d194 1
a194 1
    ReturnStatus status;
d199 3
d203 3
d240 5
d266 3
d271 5
d402 3
d432 5
d495 4
d670 2
d686 3
d723 1
a723 6
    } else {
	(void)memory_object_lock_request(segPtr->controlPort, 0,
					 round_page(segPtr->size),
					 FALSE, FALSE, VM_PROT_NONE,
					 MACH_PORT_NULL);
    }
d831 2
a832 1
 *	Can start write operations on the dirty pages.
d838 1
a838 1
VmFlushSegPages(segPtr)
d840 2
d874 4
a877 1
					    FALSE, VM_PROT_WRITE,
@


1.15
log
@Fix copyright date.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user5/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.14 92/01/21 17:08:11 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d37 1
d305 6
a310 1
	if (status != SUCCESS) {
d762 1
d765 4
a768 1
    }							/* else (c) */
@


1.14
log
@Change VM code to use Sprite FS instead of UNIX.  Better error
messages.  Notify potential waiters if a segment gets killed.  Fix
various bugs provoked by "sync" command.
@
text
@d6 1
a6 1
 * Copyright 1991 Regents of the University of California
d17 1
a17 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.13 91/12/12 21:01:38 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
@


1.13
log
@Fix off-by-one bug in WhichHeapFile.  Fix VmCopySwapFile to do the
Right Thing when the swap file is smaller than the segment size (the
usual case).
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.12 91/12/01 22:00:37 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d29 2
a33 1
#include <tempFs.h>
d51 1
a51 1
static Time retryTime = {1, 0};	/* one second */
d58 3
a60 2
static ReturnStatus FillBuffer _ARGS_((TempFs_Stream *streamPtr,
		Address buffer, off_t offset, vm_size_t bytesWanted));
d64 2
a65 1
		TempFs_Stream **filePtrPtr, off_t *fileOffsetPtr));
d68 2
a69 1
		TempFs_Stream **filePtrPtr, off_t *fileOffsetPtr));
d71 1
a71 1
		TempFs_Stream *filePtr, off_t fileOffset, Address buffer));
d193 1
a193 1
    TempFs_Stream *filePtr;	/* backing file to write to */
d195 2
d208 2
a209 1
	printf("memory_object_data_write: trying to write back dead segment.\n");
d235 2
a236 1
	WhichFile(segPtr, segOffset, FS_WRITE, &filePtr, &fileOffset);
d248 1
d270 2
a271 1
 *	Write a page of memory to the given file at the given offset.
d277 1
a277 1
 *	None.
d285 1
a285 1
    TempFs_Stream *filePtr;	/* file to write back */
d290 1
a290 1
    int bytesWritten;		/* number of bytes actually written */
d293 3
a295 3
     * If there is a fatal I/O error, bail out.  If there is a
     * non-fatal I/O error, complain, sleep for an interval, and try
     * again.
d301 3
a303 10
	/* 
	 * XXX Should we try to flush the stream after it's been 
	 * written? 
	 */
	bytesWritten = vm_page_size;
	status = TempFs_Write(filePtr, (Address)buffer, (int)fileOffset,
			      &bytesWritten);
	if (status == SUCCESS && bytesWritten != vm_page_size) {
	    status = VM_SHORT_WRITE;
	}
d305 2
a306 1
	    printf("Can't write back %s: %s\n", Vm_SegmentName(segPtr),
d308 15
d324 6
a329 4
	if (IsFatalError(status) || sys_ShuttingDown) {
	    return status;
	} else {
	    (void)Sync_WaitTime(retryTime);
d331 2
a332 1
    } while (status != SUCCESS);
d334 1
a334 1
    return SUCCESS;
d367 1
a367 1
    TempFs_Stream *filePtr;	/* file to actually read from */
d369 2
d405 4
a408 6
	/* 
	 * XXX Should do this in a loop, so can recover from stale handles?
	 */
	WhichFile(segPtr, segOffset, FS_READ, &filePtr, &fileOffset);
	status = FillBuffer(filePtr, pagingBuffer, fileOffset,
			    bytesWanted);
d410 1
d451 1
a451 1

d506 1
d576 2
a577 3
 *	is when we're flushing a dirty segment, in which case further
 *	attempts to use the memory before we've unlocked it are probably
 *	bogus.
d598 14
a611 2
    panic("memory_object_data_unlock called.\n");
    return KERN_SUCCESS;	/* lint */
d657 8
a664 2
    if (!(segPtr->flags & VM_CLEANING_SEGMENT)) {
	printf("memory_object_lock_completed: wasn't cleaning?");
d680 5
d717 6
a722 2
FillBuffer(streamPtr, buffer, offset, bytesToRead)
    TempFs_Stream *streamPtr;	/* the stream to read into the buffer */
a724 2
    off_t offset;		/* where in the file to start reading */
    vm_size_t bytesToRead;	/* number of bytes to read */
a725 2
    int bytesRead;		/* number of bytes actually read */
    off_t fileLength = TempFs_Length(streamPtr);
d728 3
d734 12
d757 1
a757 1
	bytesToRead = fileLength - offset; 		/* (b) */
d761 2
a762 2
	bytesRead = bytesToRead;
	status = TempFs_Read(streamPtr, buffer, (int)offset, &bytesRead);
a765 3
	if (bytesRead != bytesToRead) {
	    return VM_SHORT_READ;
	}
d863 2
a864 6
#ifdef SPRITED_REALFS
    return (errorCode != FS_NO_DISK_SPACE && errorCode != SUCCESS);
#else
    errorCode = errorCode;	/* lint */
    return TRUE;
#endif
d947 1
a947 1
 *	Fills in the file pointer and file offset.
d956 2
a957 1
WhichFile(segPtr, segOffset, readWrite, filePtrPtr, fileOffsetPtr)
d962 1
a962 1
    TempFs_Stream **filePtrPtr;	/* OUT: which backing file to use */
d964 2
d971 2
d979 1
a979 1
		      fileOffsetPtr);
d991 2
d997 2
d1016 1
a1016 1
 *	Fills in the file pointer and file offset.
d1026 2
a1027 1
WhichHeapFile(segPtr, segOffset, readWrite, filePtrPtr, fileOffsetPtr)
d1032 1
a1032 1
    TempFs_Stream **filePtrPtr;	/* OUT: which backing file to use */
d1034 2
d1058 3
d1064 2
a1075 2
 *	Note: if you use Fs_PageCopy, make sure that 
 *	memory_object_data_{request,write} use the right FS routines.
d1081 1
a1081 1
 *	None.
a1091 2
    Address userAddr;		/* address in user process */
    vm_offset_t offset;		/* offset in the segment */
d1093 1
d1095 2
a1096 5
    Address buffer;		/* one-page I/O buffer */
    int bytesXfered;		/* number of bytes transferred */
    TempFs_Stream *fromFilePtr;	/* swap file for fromSegPtr */
    TempFs_Stream *toFilePtr;	/* swap file for toSegPtr */
    TempFs_Stream *filePtr;
d1098 3
a1100 1
    kern_return_t kernStatus;
a1107 12
    /* 
     * Make a buffer to copy with.
     */
    buffer = 0;
    kernStatus = vm_allocate(mach_task_self(), (vm_address_t *)&buffer,
			     vm_page_size, TRUE);
    if (kernStatus != KERN_SUCCESS) {
	panic("VmCopySwapFile: can't allocate copy buffer: %s\n",
	      mach_error_string(kernStatus));
    }

    bytesXfered = vm_page_size;
d1111 19
a1129 36
    /* 
     * Write back a page at a time.  Avoid writing back heap pages if they
     * come from the initialization file.  Remember that (especially for 
     * the heap), the backing file might not actually be as large at the 
     * segment. 
     */
    for (userAddr = fromSegPtr->mappedAddr;
	     userAddr < fromSegPtr->mappedAddr + fromSegPtr->length;
	     userAddr += vm_page_size) {
	if (segType == VM_HEAP) {
	    offset = userAddr - fromSegPtr->mappedAddr;
	} else {
	    offset = userAddr - (fromSegPtr->segPtr->
				 typeInfo.stackInfo.baseAddr);
	}
	WhichFile(fromSegPtr->segPtr, offset, FS_READ, &filePtr, &fileOffset);
	if (TempFs_SameFile(filePtr, fromFilePtr)) {
	    status = TempFs_Read(fromFilePtr, buffer, (int)fileOffset,
				 &bytesXfered);
	    if (status == SUCCESS && bytesXfered == 0) {
		break;
	    }
	    if (status == SUCCESS && bytesXfered != vm_page_size) {
		status = VM_SHORT_READ;
	    }
	    if (status != SUCCESS) {
		break;
	    }
	    status = TempFs_Write(toFilePtr, buffer, (int)fileOffset, 
				  &bytesXfered);
	    if (status == SUCCESS && bytesXfered != vm_page_size) {
		status = VM_SHORT_WRITE;
	    }
	    if (status != SUCCESS) {
		break;
	    }
a1132 1
    (void)vm_deallocate(mach_task_self(), (vm_address_t)buffer, vm_page_size);
@


1.12
log
@Snapshot.  FS appears to work.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.11 91/11/14 10:03:20 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d979 1
a979 1
    if (pageNum > mapPtr->arraySize) {
d1040 4
d1058 3
a1060 1
     * come from the initialization file.
d1075 3
@


1.11
log
@Snapshot. net, rpc, recov modules added.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.10 91/10/18 18:28:07 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d28 1
d129 6
d136 1
a136 1
	panic("memory_object_init: segment %s has a null control port.\n",
d138 3
a140 3
    }
    if (segPtr->controlPort != MACH_PORT_DEAD) {
	printf("%s: warning: overwriting old control port for segment %s.\n",
d1193 25
@


1.10
log
@Add the segment handle to WriteBack's argument list.  Provide better
messages in case of errors.  Don't use valloc.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.9 91/10/08 17:31:53 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d57 1
a57 1
		Address buffer, off_t offset, int bytesWanted));
d98 9
d117 5
d124 2
a125 1
	panic("memory_object_init: trying to resurrect a dead segment.\n");
d127 1
d129 2
a130 1
	panic("memory_object_init: segment's control port is null.\n");
d133 2
a134 1
	printf("memory_object_init: overwriting old control port.\n");
d136 1
d139 7
a145 5
    kernStatus = memory_object_set_attributes(controlPort, TRUE, TRUE,
					      MEMORY_OBJECT_COPY_DELAY);
    if (kernStatus != KERN_SUCCESS) {
	printf("Can't enable segment: %s\n",
	       mach_error_string(kernStatus));
d243 1
a243 1
    (void)vm_deallocate(mach_task_self(), data, dataCount);
d289 1
a289 1
	status = TempFs_Write(filePtr, (Address)buffer, fileOffset,
d325 1
d333 2
a334 1
    vm_prot_t desiredAccess;	/* requested permissions for the data */
d522 1
d558 1
d581 2
a582 1
 *	have all been flushed to disk.
d594 1
d669 1
a669 1
    int bytesToRead;		/* number of bytes to read */
d692 1
a692 1
    if (bytesToRead > 0) {
d694 1
a694 1
	status = TempFs_Read(streamPtr, buffer, offset, &bytesRead);
d704 1
a704 1
	bzero(buffer+bytesToRead, bufferLength - bytesToRead);
d801 1
d1060 1
a1060 1
	    status = TempFs_Read(fromFilePtr, buffer, fileOffset,
d1068 2
a1069 1
	    status = TempFs_Write(toFilePtr, buffer, fileOffset, &bytesXfered);
d1082 104
@


1.9
log
@In memory_object_terminate, try to destroy the given control and name
ports, even if the given memory object port is bogus.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.8 91/10/04 11:37:55 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d23 1
d65 2
a66 2
static ReturnStatus WriteBack _ARGS_((TempFs_Stream *filePtr,
		off_t fileOffset, Address buffer));
d205 1
a205 1
	status = WriteBack(filePtr, fileOffset,
d209 2
a210 2
	    printf("memory_object_data_write: writeback failed: %s\n",
		   Stat_GetMsg(status));
d245 2
a246 1
WriteBack(filePtr, fileOffset, buffer)
d258 3
a260 3
     * XXX It might be better for this routine to take the segment 
     * handle, so that we can check in the loop whether some other 
     * process has marked the segment as dead.
d273 4
d359 4
a362 3
	printf("Can't satisfy paging request for 0x%x bytes starting at",
	       bytesWanted);
	printf(" segment offset 0x%x:\n", segOffset);
d431 1
a431 1
     * Check for a possible race condition where the init request 
d433 3
a435 1
     * control port will be different.
d441 2
a442 1
	    panic("memory_object_terminate: re-initialized a dead segment?\n");
d998 1
d1005 6
a1010 3
    buffer = valloc(vm_page_size);
    if (buffer == NULL) {
	panic("VmCopySwapFile: out of memory.\n");
d1050 1
@


1.8
log
@Snapshot.  fork/exec work.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.7 91/09/24 16:35:06 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d404 2
a405 1
	/* Don't bother freeing the given control or name ports (XXX). */
@


1.7
log
@Record the segment's name port.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.6 91/09/23 14:20:11 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d31 1
d414 6
d507 6
a512 6
 *	Handle a request from the kernel to change the protection of 
 *	some memory.  We normally use permissions at the level of 
 *	vm_map and vm_protect to control access to memory.  The only 
 *	exception so far is when we're flushing a dirty segment, in 
 *	which case further attempts to use the memory are probably 
 *	bogus. 
d581 1
d679 1
a679 1
 *	locked segment. 
d682 2
a683 1
 *	None.
d714 8
a723 7
    /* 
     * The VM_PROT_ALL is a paranoia check.  Currently the only 
     * reasons for flushing a segment all involve cases where the 
     * segment is about to go away, so nobody should want to use it. 
     * XXX this needs to be fixed if we decide to flush pages as part 
     * of process migration.
     */
d726 1
a726 1
					    FALSE, VM_PROT_ALL,
d952 85
@


1.6
log
@Snapshot.  Server is multithreaded internally.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /r3/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.5 91/09/04 15:24:55 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d117 1
@


1.5
log
@Better management of IPC ports.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user6/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.4 91/09/02 22:56:12 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d26 1
a26 2
    /* main.h for main_DebugFlag. */
#include <main.h>
d29 1
a30 1
#include <utils.h>
d108 1
a108 1
	panic("memory_object_init: trying to resurrect a dead segment.");
d111 1
a111 1
	panic("memory_object_init: segment's control port is null.");
d175 1
a175 1
	panic("memory_object_data_write: writing off end of segment.");
d177 3
d186 1
a186 1
	panic("memory_object_data_write: writing partial page.");
a197 4
	if (main_DebugFlag && segPtr->type == VM_HEAP) {
	    printf("data_write: segment ``%s'' at 0x%x\n",
		   segPtr->swapFileName, segOffset);
	}
d269 1
a269 1
	if (IsFatalError(status)) {
a346 4
	if (main_DebugFlag && segPtr->type == VM_HEAP) {
	    printf("data_request: segment ``%s'' at 0x%x\n",
		   segPtr->swapFileName, segOffset);
	}
d423 1
a423 1
	    panic("memory_object_terminate: re-initialized a dead segment?");
a436 18
     * If there are other references to the segment, just unlock it.  
     * If we hold the last reference and the segment is dead, get rid 
     * of it.
     */
    if (segPtr->refCount > 1) {
	VmSegmentUnlock(segPtr);
    } else {
	if (segPtr->state == VM_SEGMENT_DEAD) {
	    segPtr->refCount--;
	    VmSegmentCleanup(segPtr);
	    segPtr = NULL;
	} else {
	    printf("memory_object_terminate: no references to alive segment?\n");
	    VmSegmentUnlock(segPtr);
	}
    }

    /* 
d456 4
a459 4
    if (segPtr != NULL) {
	segPtr->controlPort = MACH_PORT_NULL;
    }
    
d489 1
a489 1
    panic("memory_object_copy called.");
d749 1
a749 1
#if 0
d779 1
a779 1
	panic("Can't create paging buffer.");
d806 1
a806 1
    char *functionName;
d816 1
a816 2
	printf("%s: bogus control port.\n", functionName);
	panic("ControlPortOkay");
d860 1
a860 1
	    panic("WhichFile: heap segment offset not page-aligned.");
d867 1
a867 1
	    panic("WhichFile: stack segment offset not page-aligned.");
d881 1
a881 1
	panic("WhichFile: bogus segment type.");
@


1.4
log
@Changes for module-based source organization.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user6/kupfer/spriteserver/src/sprited/vm/RCS/vmPager.c,v 1.3 91/09/01 21:02:59 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d222 1
d373 2
d460 11
a470 1
    kernStatus = mach_port_deallocate(mach_task_self(), controlPort);
d472 1
a472 1
	printf("Can't deallocate control port: %s\n",
d475 1
a475 1
    kernStatus = mach_port_deallocate(mach_task_self(), namePort);
d477 1
a477 1
	printf("Can't deallocate name port: %s\n",
d480 3
d616 1
@


1.3
log
@Snapshot.  Full VM support.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user6/kupfer/spriteserver/src/printfd/RCS/vmPager.c,v 1.2 91/08/19 12:17:28 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d25 1
d27 7
a33 7
#include "main.h"
#include "md.h"
#include "sync.h"
#include "tempFs.h"
#include "util.h"
#include "vm.h"
#include "vmInt.h"
d878 1
a878 1
	if (MACH_STACK_GROWS_DOWN) {
@


1.2
log
@Snapshot: Code reorg. and locking for processes & segments.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /user6/kupfer/spriteserver/src/printfd/RCS/vmPager.c,v 1.1 91/08/15 15:52:54 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d25 3
d39 1
a39 1
static char *pagingBuffer = NULL;
d53 12
a64 5
				       mach_port_t controlPort,
				       char *functionName));
static Boolean FatalError _ARGS_((int errorCode));
static ReturnStatus FillBuffer _ARGS_((TempFs_Stream *streamPtr, char *buffer,
				       int offset, int bytesWanted));
d102 1
a102 1
	return KERN_FAILURE;
d147 1
a147 1
memory_object_data_write(objectPort, controlPort, offset, data, dataCount)
d150 1
a150 1
    vm_offset_t offset;		/* where in segment to start writing back */
d155 2
a156 1
    int bytesWritten = dataCount; /* number of bytes actually written */
d158 2
d170 5
a174 1
    if (offset + dataCount > segPtr->size) {
d177 1
a177 1
    
d179 2
a180 5
     * If there is a fatal I/O error, mark the segment as dead so that
     * no more operations are attempted for it.  (Note that the
     * segment might also get marked as dead while the segment is
     * unlocked.)  If there is a non-fatal I/O error, complain, sleep
     * for an interval, and try again.
d182 16
a197 6
    do {
	if (segPtr->state == VM_SEGMENT_DEAD) {
	    printf("memory_object_data_write:\n");
	    printf("Can't write back %s: dead segment.\n",
		   segPtr->fileName);
	    goto punt;
a198 1

d200 1
a200 2
	 * XXX Should we try to flush the stream after it's been 
	 * written? 
d203 2
a204 2
	status = TempFs_Write(segPtr->filePtr, (Address)data, offset,
			      &bytesWritten);
d206 6
a211 9
	if (status != SUCCESS || bytesWritten != dataCount) {
	    printf("memory_object_data_write: can't write data: %s\n",
		   Stat_GetMsg(status)); /* XXX provide additional info */
	    if (FatalError(status)) {
		segPtr->state = VM_SEGMENT_DEAD;
		memory_object_destroy(controlPort, status);
	    } else {
		(void)Sync_WaitTime(retryTime);
	    }
d213 2
a214 2
    } while (status != SUCCESS);

d228 55
d288 1
a288 1
 *	Returns KERN_SUCESS.  (See memory_object_data_provided.)
d297 1
a297 1
memory_object_data_request(objectPort, controlPort, offset, bytesWanted,
d301 1
a301 1
    vm_offset_t offset;		/* where in the segment to start reading */
d307 2
d330 1
a330 1
    if (status == SUCCESS && offset + bytesWanted > segPtr->size) {
d333 1
a333 1
	printf(" starting at 0x%x\n", offset);
d346 6
a351 1
	status = FillBuffer(segPtr->filePtr, pagingBuffer, offset,
d357 1
a357 1
	printf(" 0x%x:\n", offset);
d359 1
a359 1
	(void)memory_object_data_error(controlPort, offset, bytesWanted,
d362 1
a362 1
	(void)memory_object_data_provided(controlPort, offset,
d404 2
a405 2
	/* Don't bother freeing the given control or name ports. */
	return KERN_FAILURE;
d409 6
a414 1
    (void)ControlPortOkay(segPtr, controlPort, "memory_object_terminate");
d625 1
a625 1
    char *buffer;		/* where to put the characters; should 
d627 1
a627 1
    int offset;			/* where in the file to start reading */
d631 1
a631 1
    int fileLength = TempFs_Length(streamPtr);
d642 1
a642 1
     * completely from the backing file, so an whole-page read is
d646 1
a646 1
	bytesToRead = 0;	/* (a) */
d648 2
a649 2
	bytesToRead = fileLength - offset; /* (b) */
    }				/* else (c) */
d700 10
d733 1
a733 1
 * FatalError --
d748 1
a748 1
FatalError(errorCode)
d832 116
@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/lib/forms/RCS/proto.c,v 1.5 91/02/09 13:24:44 ouster Exp $ SPRITE (Berkeley)";
d27 1
d49 3
d83 1
a83 1
    Vm_Segment *segPtr = VmSegmentFromPort(objectPort);
d86 10
d100 4
a103 1
    if (segPtr->controlPort != MACH_PORT_NULL) {
a111 1
	goto done;
d114 2
a115 10
    if (pagingBuffer == NULL) {
	vm_allocate(mach_task_self(), (vm_address_t *)&pagingBuffer,
		    vm_page_size, TRUE);
	if (pagingBuffer == NULL) {
	    panic("Can't create paging buffer.");
	}
    }

 done:
    VmUnlockSegment(segPtr);
d144 1
a144 1
    Vm_Segment *segPtr = VmSegmentFromPort(objectPort);
d148 7
a154 4
    if (segPtr->state == VM_SEGMENT_DEAD) {
	printf("memory_object_data_write:\n");
	printf("Can't write back %s: dead segment.\n",
	       segPtr->fileName);
d163 4
a166 2
     * no more operations are attempted for it.  Otherwise, complain,
     * sleep for an interval, and try again.
d169 7
a178 2
	 * XXX Error handling is not tested, because the UX code doesn't 
	 * handle full filesystems well, either.
d180 1
d183 1
a189 1
		break;
d197 4
a200 1
    VmUnlockSegment(segPtr);
d231 2
a232 3
    Vm_Segment *segPtr = VmSegmentFromPort(objectPort);
    ReturnStatus status;
    kern_return_t kernStatus;
d238 15
a252 13
    Sync_GetLock(&bufferLock);

    if (segPtr->state == VM_SEGMENT_DYING ||
		segPtr->state == VM_SEGMENT_DEAD) {
	printf("memory_object_data_request: dead segment.\n");
	kernStatus = memory_object_data_error(controlPort, offset,
					      bytesWanted, VM_SWAP_ERROR);
	if (kernStatus != KERN_SUCCESS) {
	    printf("Can't signal dead segment: %s\n",
		   mach_error_string(kernStatus));
	}
	goto done;
    }
d254 1
a254 4
    /* 
     * XXX Should do this in a loop, so can recover from stale handles?
     */
    if (offset + bytesWanted > segPtr->size) {
d260 10
a269 1
    } else {
d278 2
a279 6
	kernStatus = memory_object_data_error(controlPort, offset,
					      bytesWanted, status);
	if (kernStatus != KERN_SUCCESS) {
	    printf("Can't signal page-in failure: %s\n",
		   mach_error_string(kernStatus));
	}	
d281 3
a283 9
	kernStatus = memory_object_data_provided(controlPort, offset,
						 (pointer_t)pagingBuffer,
						 bytesWanted, VM_PROT_NONE);
	if (kernStatus != KERN_SUCCESS) {
	    printf("Can't provide memory starting at 0x%x, length 0x%x", 
		   offset, bytesWanted);
	    printf(" to kernel: %s\n", mach_error_string(kernStatus));
	    panic("memory_object_data_provided failed");
	}
d285 1
d287 3
a289 3
 done:
    Sync_Unlock(&bufferLock);
    VmUnlockSegment(segPtr);
d299 1
a299 1
 *	Partially clean up for a dead segment.
d305 2
a306 2
 *	Destroys the control and name ports.  If the given control 
 *	port is still the control port for the segment, nil it out.
d318 11
a328 1
    Vm_Segment *segPtr = VmSegmentFromPort(objectPort);
d353 3
a355 2
     * If we're through with the segment, get rid of it.  Otherwise, 
     * just unlock it, and we'll deal with it later.
d357 2
a358 2
    if (segPtr->state == VM_SEGMENT_DEAD && segPtr->refCount == 0) {
	VmSegmentCleanup(segPtr);
d360 8
a367 1
	VmUnlockSegment(segPtr);
d445 2
a446 8
    printf("memory_object_data_unlock: segment 0x%x.", objectPort);
    /* 
     * Tell the kernel "no, you really can't have access".  I wonder 
     * what the kernel will do in response. (XXX)
     */
    memory_object_lock_request(controlPort, offset, length, TRUE,
			       FALSE, VM_PROT_ALL, MACH_PORT_NULL);
    return KERN_SUCCESS;
d477 12
a488 1
    Vm_Segment *segPtr = VmSegmentFromPort(objectPort);
d490 3
d508 5
a512 1
    VmUnlockSegment(segPtr);
d664 71
@
