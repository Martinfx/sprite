head     1.25;
branch   ;
access   ;
symbols  ds3100:1.25 sun3:1.25 sun4nw:1.18 symm:1.18 spur:1.18;
locks    ; strict;
comment  @ * @;


1.25
date     92.08.11.16.37.27;  author mgbaker;  state Exp;
branches ;
next     1.24;

1.24
date     92.08.04.17.45.52;  author mgbaker;  state Exp;
branches ;
next     1.23;

1.23
date     92.04.10.16.38.41;  author kupfer;  state Exp;
branches ;
next     1.22;

1.22
date     92.04.06.13.46.50;  author mgbaker;  state Exp;
branches ;
next     1.21;

1.21
date     92.04.06.13.40.14;  author mgbaker;  state Exp;
branches ;
next     1.20;

1.20
date     92.03.12.15.27.36;  author jhh;  state Exp;
branches ;
next     1.19;

1.19
date     92.03.06.11.56.55;  author mgbaker;  state Exp;
branches ;
next     1.18;

1.18
date     91.08.22.13.15.25;  author mendel;  state Exp;
branches ;
next     1.17;

1.17
date     91.08.08.17.48.29;  author mendel;  state Exp;
branches ;
next     1.16;

1.16
date     91.07.03.09.55.17;  author mendel;  state Exp;
branches ;
next     1.15;

1.15
date     91.07.03.09.43.44;  author mendel;  state Exp;
branches ;
next     1.14;

1.14
date     91.07.01.14.42.24;  author mendel;  state Exp;
branches ;
next     1.13;

1.13
date     91.06.29.17.07.22;  author mendel;  state Exp;
branches ;
next     1.12;

1.12
date     91.05.29.14.08.49;  author mendel;  state Exp;
branches ;
next     1.11;

1.11
date     91.02.01.16.29.58;  author mendel;  state Exp;
branches ;
next     1.10;

1.10
date     91.01.09.12.17.21;  author mendel;  state Exp;
branches ;
next     1.9;

1.9
date     91.01.04.15.47.12;  author mendel;  state Exp;
branches ;
next     1.8;

1.8
date     90.12.07.10.07.44;  author mendel;  state Exp;
branches ;
next     1.7;

1.7
date     90.11.09.15.58.36;  author mendel;  state Exp;
branches ;
next     1.6;

1.6
date     90.10.30.09.58.37;  author mendel;  state Exp;
branches ;
next     1.5;

1.5
date     90.10.19.17.22.57;  author mendel;  state Exp;
branches ;
next     1.4;

1.4
date     90.08.02.16.19.36;  author mendel;  state Exp;
branches ;
next     1.3;

1.3
date     90.05.30.10.30.59;  author mendel;  state Exp;
branches ;
next     1.2;

1.2
date     90.05.25.15.33.09;  author mendel;  state Exp;
branches ;
next     1.1;

1.1
date     90.01.16.17.12.27;  author mendel;  state Exp;
branches ;
next     ;


desc
@@


1.25
log
@Fixed glitch.

@
text
@/* 
 * lfsSeg.c --
 *
 *	Handles the manipulation of LFS segments.
 *
 * Copyright 1989 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/lfs/lfsSeg.c,v 1.24 92/08/04 17:45:52 mgbaker Exp $ SPRITE (Berkeley)";
#endif /* not lint */

#include <lfsInt.h>
#include <lfsSeg.h>
#include <stdlib.h>
#include <sync.h>
#include <fsStat.h>
#include <fsrecov.h>
#include <recov.h>

#define	LOCKPTR	&lfsPtr->lock

int	lfsMinNumberToClean = 10;

Boolean	lfsSegWriteDebug = FALSE;

#define	MIN_SUMMARY_REGION_SIZE	16

#ifndef VERIFY_CLEAN
enum CallBackType { SEG_LAYOUT, SEG_CLEAN_IN, SEG_CLEAN_OUT, SEG_CHECKPOINT, 
		   SEG_WRITEDONE};
#else
enum CallBackType { SEG_LAYOUT, SEG_CLEAN_IN, SEG_CLEAN_OUT, SEG_CHECKPOINT, 
		   SEG_WRITEDONE, SEG_CLEAN_VERIFY};
#endif

LfsSegIoInterface *lfsSegIoInterfacePtrs[LFS_MAX_NUM_MODS];


static void SegmentCleanProc _ARGS_((ClientData clientData, 
				     Proc_CallInfo *callInfoPtr));
static LfsSeg *CreateSegmentToClean _ARGS_((Lfs *lfsPtr, int segNumber, 
			char *cleaningMemPtr));
static LfsSeg *CreateSegmentToWrite _ARGS_((Lfs *lfsPtr, Boolean dontBlock));
static LfsSeg *GetSegStruct _ARGS_((Lfs *lfsPtr, LfsSegLogRange 
			*segLogRangePtr, int startBlockOffset, char *memPtr));
static void AddNewSummaryBlock _ARGS_((LfsSeg *segPtr));
static Boolean DoOutCallBacks _ARGS_((enum CallBackType type, LfsSeg *segPtr, int flags, char *checkPointPtr, int *sizePtr, ClientData *clientDataPtr));
static ReturnStatus WriteSegmentStart _ARGS_((LfsSeg *segPtr));
static ReturnStatus WriteSegmentFinish _ARGS_((LfsSeg *segPtr));
static void WriteDoneNotify _ARGS_((Lfs *lfsPtr));
static void RewindCurPtrs _ARGS_((LfsSeg *segPtr));
static Boolean DoInCallBacks _ARGS_((enum CallBackType type, LfsSeg *segPtr, int flags, int *sizePtr, int *numCacheBlocksPtr, ClientData *clientDataPtr));
static void DestorySegStruct _ARGS_((LfsSeg *segPtr));

/*
 * Macro returning TRUE if segment is completely empty.
 */
#define SegIsEmpty(segPtr) (((segPtr)->numBlocks == 1) && 		\
	    ((segPtr)->curSegSummaryPtr->size == sizeof(LfsSegSummary)))

/*
 *----------------------------------------------------------------------
 *
 * -- LfsSegIoRegister
 *
 *	Register with the segment module an interface to objects in the log.   
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
LfsSegIoRegister(moduleType, ioInterfacePtr)
    int			moduleType; /* Module type registering. Type defined in
				     * lfsSegWrite.h */
    LfsSegIoInterface	*ioInterfacePtr;  /* Interface to use. */

{
    lfsSegIoInterfacePtrs[moduleType] = ioInterfacePtr;
}

/*
 *----------------------------------------------------------------------
 *
 * LfsSegmentWriteProc --
 *
 *	Proc_CallFunc procedure for performing a segment writes.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
 void
LfsSegmentWriteProc(clientData, callInfoPtr)
    ClientData	   clientData;
    Proc_CallInfo *callInfoPtr;         /* Not used. */
{
    register Lfs *lfsPtr;            /* File system with dirty blocks. */
    Boolean	full;
    LfsSeg	*segPtr;
    ClientData		clientDataArray[LFS_MAX_NUM_MODS];
    int			i;
    ReturnStatus	status;
    Boolean		moreWork;


    lfsPtr = (Lfs *) clientData;
    /*
     * All the stuff with these FSYNC flags is for the ASPLOS measurements
     * only.  It can all be removed after that's all over.  Mary  2/14/92.
     */
    lfsPtr->controlFlags &= ~LFS_FSYNC_IN_PROGRESS;
    moreWork = TRUE;
    if (lfsPtr->controlFlags & LFS_FILE_FSYNCED) {
	lfsPtr->controlFlags &= ~LFS_FILE_FSYNCED;
	lfsPtr->controlFlags |= LFS_FSYNC_IN_PROGRESS;
    }
    while (moreWork) { 
	full = TRUE;
	for (i = 0; i < LFS_MAX_NUM_MODS; i++) {
	    clientDataArray[i] = (ClientData) NIL;
	}
	while (full) {
	    segPtr = CreateSegmentToWrite(lfsPtr, FALSE);
	    full = DoOutCallBacks(SEG_LAYOUT, segPtr, 0, (char *) NIL,
				    (int *) NIL, clientDataArray);
	    status = WriteSegmentStart(segPtr);
	    if (status == SUCCESS) {
		status = WriteSegmentFinish(segPtr);
	    }
	    if (status != SUCCESS) {
		LfsError(lfsPtr, status, "Can't write segment to log\n");
	    }
	    RewindCurPtrs(segPtr);
	    (void) DoInCallBacks(SEG_WRITEDONE, segPtr, 0,
				    (int *) NIL, (int *) NIL, clientDataArray);
	    WriteDoneNotify(lfsPtr);
	    DestorySegStruct(segPtr);
	}
	moreWork = LfsMoreToWriteBack(lfsPtr);
	if (lfsPtr->controlFlags & LFS_FILE_FSYNCED) {
	    lfsPtr->controlFlags &= ~LFS_FILE_FSYNCED;
	    lfsPtr->controlFlags |= LFS_FSYNC_IN_PROGRESS;
	} else {
	    lfsPtr->controlFlags &= ~LFS_FSYNC_IN_PROGRESS;
	}
    }
    return;
}


/*
 *----------------------------------------------------------------------
 *
 * LfsSegCleanStart --
 *
 *	Request that the segment manager start cleaning segments
 *	for the specified file system.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A segment cleaning process may be started.
 *
 *----------------------------------------------------------------------
 */

void
LfsSegCleanStart(lfsPtr)
    Lfs	 *lfsPtr;	/* File system needing segments cleaned. */
{
    LFS_STATS_INC(lfsPtr->stats.cleaning.startRequests);
    if (lfsPtr->activeFlags & LFS_CLEANER_ACTIVE) {
	LFS_STATS_INC(lfsPtr->stats.cleaning.alreadyActive);
	return;
    }
    lfsPtr->activeFlags |= LFS_CLEANER_ACTIVE;
    Proc_CallFunc(SegmentCleanProc, (ClientData) lfsPtr, 0);
}

/*
 *----------------------------------------------------------------------
 *
 * LfsSegSlowGrowSummary --
 *
 *	Insure that there is enought room for an object with the 
 *	specified number of blocks and summary bytes. Possibly add a
 *	new summary block if needed.
 *
 * Results:
 *	A pointer to the summary bytes for this region or NIL if
 *	there is not enought room.
 *
 * Side effects:
 *
 *----------------------------------------------------------------------
 */

char *
LfsSegSlowGrowSummary(segPtr, dataBlocksNeeded, sumBytesNeeded, addNewBlock)
    register LfsSeg	*segPtr;	/* Segment of interest. */
    int	 dataBlocksNeeded;		/* Number of data blocks needed. */
    int	sumBytesNeeded;			/* Number of summary bytes needed. */
    Boolean addNewBlock;		/* Added a new block if necessary. */
{
    int	 sumBytesLeft, blocksLeft, sumBlocks;

    /*
     * Test the most common case first. Do the data and summary fit
     * in the current configuration. 
     */
    sumBytesLeft = LfsSegSummaryBytesLeft(segPtr);
    blocksLeft = LfsSegBlocksLeft(segPtr);
    if ((blocksLeft >= dataBlocksNeeded) && (sumBytesLeft >= sumBytesNeeded)) {
       return segPtr->curSummaryPtr;
    }
    /*
     * Need to add a summary block. Bail if the user doesn't what it 
     * or there is not enought room.
     */
    sumBlocks = 1;
    if (!addNewBlock || (dataBlocksNeeded + sumBlocks > blocksLeft)) { 
	return (char *) NIL;
    }
    /*
     * Malloc a new summary buffer and add it to the segment.
     */
    AddNewSummaryBlock(segPtr);
    return segPtr->curSummaryPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * LfsSegSlowDiskAddress --
 *
 *	Compute the disk address of a LfsSegElement.
 *
 * Results:
 *	The disk address of the element.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

LfsDiskAddr
LfsSegSlowDiskAddress(segPtr, segElementPtr)
    register LfsSeg	*segPtr; 	/* Segment of interest. */
    LfsSegElement *segElementPtr; /* Segment element of interest. */
{
    int	elementNumber, blockOffset;
    LfsDiskAddr diskAddress, newDiskAddr;
    /*
     * Check the common case that we are asking about the "current"
     * element. 
     */
    elementNumber = segElementPtr - segPtr->segElementPtr;

    if (elementNumber == segPtr->curElement) {
	blockOffset = segPtr->curBlockOffset;
    } else {
	int	i;
	blockOffset = segPtr->startBlockOffset;
	for (i = 0; i <= elementNumber; i++) {
	    blockOffset += segPtr->segElementPtr[i].lengthInBlocks;
	}
    }
    LfsSegNumToDiskAddress(segPtr->lfsPtr, segPtr->logRange.current, 
		&diskAddress);
    blockOffset = LfsSegSizeInBlocks(segPtr->lfsPtr) - blockOffset;
    LfsDiskAddrPlusOffset(diskAddress, blockOffset, &newDiskAddr);
    return newDiskAddr;
}

/*
 *----------------------------------------------------------------------
 *
 * LfsSegSlowAddDataBuffer --
 *
 *	Add a LfsSegElement to a segment.
 *
 * Results:
 *	A pointer to the LfsSegElement added. NIL if the object would not
 *	fit.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

LfsSegElement *
LfsSegSlowAddDataBuffer(segPtr, blocks, bufferPtr, clientData)
    register LfsSeg	*segPtr;  /* Segment to add to. */ 
    int	        blocks;	  /* Size of buffer to add in blocks */
    char   *bufferPtr;	  /* Buffer to add. */
    ClientData clientData; /* ClientData associated with this field. */
{
    LfsSegElement *elementPtr;

    if (segPtr->curBlockOffset + blocks > segPtr->curDataBlockLimit) {
	return (LfsSegElement *) NIL;
    }
    segPtr->curElement++;
    segPtr->curBlockOffset += blocks;

    elementPtr = segPtr->segElementPtr + segPtr->curElement;
    elementPtr->lengthInBlocks = blocks;
    elementPtr->clientData = clientData;
    elementPtr->address	= bufferPtr;
    segPtr->numElements = segPtr->curElement+1;
    segPtr->numBlocks += blocks;
    return elementPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * InitSegmentMem --
 *
 *	Initialize the memory used by a file systems segment code.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	LfsSeg memories allocated.
 *
 *----------------------------------------------------------------------
 */
void
InitSegmentMem(lfsPtr)
    Lfs	*lfsPtr;
{
    LfsSeg	*segPtr;
    int		maxSegElementSize;
    int		i;
    DevBlockDeviceHandle *handlePtr;

    /*
     * Compute the maximum size of the seg element array. It can't be
     * bigger than one element per block in segment.
     */

    maxSegElementSize = LfsBytesToBlocks(lfsPtr,LfsSegSize(lfsPtr)) * 
				    sizeof(LfsSegElement);
    /*
     * Fill in the fixed fields of the preallocated segments.
     */
    lfsPtr->segsInUse = 0;
    lfsPtr->segs = (LfsSeg *) malloc(LFS_NUM_PREALLOC_SEGS *sizeof(LfsSeg));
    for (i = 0; i < LFS_NUM_PREALLOC_SEGS; i++) { 
	segPtr = lfsPtr->segs + i;
	segPtr->lfsPtr = lfsPtr;
	segPtr->segElementPtr = (LfsSegElement *) malloc(maxSegElementSize);
    }
    handlePtr = (DevBlockDeviceHandle *) lfsPtr->devicePtr->data;
    if (handlePtr->maxTransferSize < LfsSegSize(lfsPtr)) { 
	lfsPtr->writeBuffers[0] = malloc(handlePtr->maxTransferSize*2);
	lfsPtr->writeBuffers[1] = lfsPtr->writeBuffers[0] + 
				    handlePtr->maxTransferSize;
    } else {
	lfsPtr->writeBuffers[0] = malloc(LfsSegSize(lfsPtr));
	lfsPtr->writeBuffers[1] = (char *) NIL;
    }

}

/*
 *----------------------------------------------------------------------
 *
 * FreeSegmentMem --
 *
 *	Free the memory used by a file systems segment code.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	LfsSeg structures freed.
 *
 *----------------------------------------------------------------------
 */
void
FreeSegmentMem(lfsPtr)
    Lfs	*lfsPtr;
{
    int i;
    free(lfsPtr->writeBuffers[0]);
    lfsPtr->segsInUse = 0;
    for (i = 0; i < LFS_NUM_PREALLOC_SEGS; i++) { 
	free((char *)(lfsPtr->segs[i].segElementPtr));
    }
    free((char *) (lfsPtr->segs));

}

/*
 *----------------------------------------------------------------------
 *
 * AddNewSummaryBlock --
 *
 *  Add a summary block to a segment.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A new summary block is malloc() and initialized.
 *
 *----------------------------------------------------------------------
 */
static void
AddNewSummaryBlock(segPtr)
    LfsSeg	*segPtr;	/* Seg to add block to. */
{
    LfsSegElement *sumBufferPtr;
    LfsSegSummary *newSummaryPtr;
    int		  sumBytes;

    sumBytes = LfsBlockSize(segPtr->lfsPtr);
    sumBufferPtr = LfsSegAddDataBuffer(segPtr, 1, malloc(sumBytes),
					(ClientData) NIL);
    newSummaryPtr =  (LfsSegSummary *) sumBufferPtr->address;
    newSummaryPtr->magic = LFS_SEG_SUMMARY_MAGIC;
    newSummaryPtr->timestamp = LfsGetCurrentTimestamp(segPtr->lfsPtr);
    newSummaryPtr->prevSeg = segPtr->logRange.prevSeg;
    newSummaryPtr->nextSeg = segPtr->logRange.nextSeg;
    newSummaryPtr->size = sizeof(LfsSegSummary);
    newSummaryPtr->nextSummaryBlock = -1;

    if (segPtr->curSegSummaryPtr != (LfsSegSummary *) NIL) { 
	/*
	 * This is not the first summary block in the segment.  Fixup the
	 * size of the last summary block and point it at the new one. 
	 */
	segPtr->curSegSummaryPtr->size = segPtr->curSummaryPtr - 
				    (char *) (segPtr->curSegSummaryPtr);
	segPtr->curSegSummaryPtr->nextSummaryBlock = segPtr->curBlockOffset;
    } 
    segPtr->curSegSummaryPtr = newSummaryPtr;

    segPtr->curSummaryPtr = sumBufferPtr->address + sizeof(LfsSegSummary);
    segPtr->curSummaryLimitPtr = sumBufferPtr->address + sumBytes;
}

void
CopySegToBuffer( segPtr, maxSize, bufferPtr, lenPtr)
    LfsSeg	*segPtr;
    int		maxSize;
    char	*bufferPtr;
    int		*lenPtr;
{
    int bytes, offset;
    LfsSegElement *elementPtr;
    Boolean full;

    *lenPtr = 0;
    offset = 0;
    full = FALSE;
    while ((segPtr->curElement >= 0) && !full) {
	elementPtr = segPtr->segElementPtr + segPtr->curElement;
	bytes = LfsBlocksToBytes(segPtr->lfsPtr, 
		elementPtr->lengthInBlocks - segPtr->curBlockOffset);
	if (*lenPtr + bytes > maxSize) {
	    /*
	     * Element doesn't fit in this buffer. 
	     */
	    if (*lenPtr == maxSize) {
		offset = 0;
	    } else { 
		offset = LfsBytesToBlocks(segPtr->lfsPtr,(maxSize - *lenPtr));
	    }
	    bytes = LfsBlocksToBytes(segPtr->lfsPtr, offset);
	    full = TRUE;
	} 
	if (segPtr->curBlockOffset == 0) { 
	    bcopy(elementPtr->address, bufferPtr + *lenPtr, bytes);
	} else {
	    bcopy(elementPtr->address + 
		   LfsBlocksToBytes(segPtr->lfsPtr,segPtr->curBlockOffset),
		  bufferPtr + *lenPtr, bytes);
	}
	*lenPtr += bytes;
	if (full) {
	    segPtr->curBlockOffset += offset;
	} else {
	    segPtr->curElement--;
	    segPtr->curBlockOffset = 0;
	}
    }
}


/*
 *----------------------------------------------------------------------
 *
 * SegIoDoneProc --
 *
 *	This procedure is called when a sync block command started by 
 *	WriteSegmentStart finished. It's calling sequence is 
 *	defined by the call back caused by the Dev_BlockDeviceIO routine.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *
 *----------------------------------------------------------------------
 */

static void
SegIoDoneProc(requestPtr, status, amountTransferred)
    DevBlockDeviceRequest	*requestPtr;
    ReturnStatus status;
    int	amountTransferred;
{
    LfsSeg	*segPtr = (LfsSeg *) (requestPtr->clientData);
    DevBlockDeviceHandle *handlePtr;

    handlePtr = (DevBlockDeviceHandle *) segPtr->lfsPtr->devicePtr->data;
    /*
     * A pointer to the LfsSeg is passed as the clientData to this call.
     * Start the new request if one is available. If this is the last
     * request note the I/O as done.
     */
    MASTER_LOCK(&segPtr->ioMutex);
    if (amountTransferred != requestPtr->bufferLen) {
	status = VM_SHORT_WRITE;
    }
    if (status != SUCCESS) {
	segPtr->ioReturnStatus = status;
    }
    requestPtr->startAddress = DEV_BYTES_PER_SECTOR * 
				LfsDiskAddrToOffset(segPtr->nextDiskAddress);
    requestPtr->bufferLen = 0;
    CopySegToBuffer(segPtr, handlePtr->maxTransferSize, requestPtr->buffer, 
			&requestPtr->bufferLen);
    segPtr->nextDiskAddress += requestPtr->bufferLen/DEV_BYTES_PER_SECTOR;
    if (requestPtr->bufferLen == 0) { 
	segPtr->requestActive--;
	if (segPtr->requestActive == 0) {
	    segPtr->ioDone = TRUE;
	    Sync_MasterBroadcast(&segPtr->ioDoneWait);
	}
    } 
    MASTER_UNLOCK(&segPtr->ioMutex);
    if (requestPtr->bufferLen > 0) {
	status = Dev_BlockDeviceIO(handlePtr, requestPtr);
	if (status != SUCCESS) {
	    LfsError(segPtr->lfsPtr, status, "Can't start log write.\n");
	}
    }
    return;
}


/*
 *----------------------------------------------------------------------
 *
 * WriteSegmentStart --
 *
 *	Start a segment write to the log.
 *
 * Results:
 *	SUCCESS if write complete. The ReturnStatus otherwise.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
WriteSegmentStart(segPtr) 
    LfsSeg	*segPtr;	/* Segment to write. */
{
    Lfs	*lfsPtr = segPtr->lfsPtr;
    int offset;
    LfsDiskAddr  diskAddress;
    ReturnStatus status = SUCCESS;
    DevBlockDeviceHandle *handlePtr;
    DevBlockDeviceRequest *requestPtr;

    Sync_SemInitDynamic(&(segPtr->ioMutex),"LfsSegIoMutex");
    segPtr->ioDone = FALSE;
    segPtr->ioReturnStatus = SUCCESS;

    if (SegIsEmpty(segPtr)) { 
	/*
	 * The segment being written is empty so we don't have
	 * to write anytime. Just mark the I/O as done.
	 */
	segPtr->ioDone = TRUE;
	return SUCCESS;
    }

    handlePtr = (DevBlockDeviceHandle *) lfsPtr->devicePtr->data;

    /*
     * Writing to a segment nukes the segment cache.
     */
    if (lfsPtr->segCache.valid && 
	 (lfsPtr->segCache.segNum == segPtr->logRange.current)) {
	lfsPtr->segCache.valid = FALSE;
    }
    LFS_STATS_INC(lfsPtr->stats.log.segWrites);
    /*
     * This flag is for the ASPLOS paper.  Remove when that's all over.
     * 			Mary 2/15/92.
     */
    if ((lfsPtr->controlFlags & LFS_FSYNC_IN_PROGRESS) && Lfs_DoASPLOSStats) {
	LFS_STATS_INC(lfsPtr->stats.log.fsyncWrites);
    }

    LFS_STATS_ADD(lfsPtr->stats.log.wasteBlocks,
			    segPtr->curDataBlockLimit - segPtr->curBlockOffset);
    /*
     * Compute the starting disk address of this I/O.
     */
    LfsSegNumToDiskAddress(lfsPtr, segPtr->logRange.current, &diskAddress);
    offset = LfsSegSizeInBlocks(lfsPtr)	- segPtr->curBlockOffset;
    LfsDiskAddrPlusOffset(diskAddress,offset, &segPtr->nextDiskAddress);


    /*
     * Fill in the request block fields that don't change between 
     * requests.
     */

    segPtr->bioreq[0].operation = segPtr->bioreq[1].operation = FS_WRITE;
    segPtr->bioreq[0].startAddrHigh = segPtr->bioreq[1].startAddrHigh = 0;
    segPtr->bioreq[0].doneProc = segPtr->bioreq[1].doneProc = SegIoDoneProc;
    segPtr->bioreq[0].clientData = segPtr->bioreq[1].clientData = 
				(ClientData) segPtr;

    segPtr->curElement = segPtr->numElements-1;
    segPtr->curBlockOffset = 0;
    /*
     * Start up the first two disk I/Os. 
     */
    requestPtr = segPtr->bioreq+0;
    requestPtr->startAddress = DEV_BYTES_PER_SECTOR * 
				LfsDiskAddrToOffset(segPtr->nextDiskAddress);
    requestPtr->buffer = lfsPtr->writeBuffers[0];
    requestPtr->bufferLen = 0;
    CopySegToBuffer(segPtr, handlePtr->maxTransferSize, requestPtr->buffer,
		&requestPtr->bufferLen);
    segPtr->nextDiskAddress += requestPtr->bufferLen/DEV_BYTES_PER_SECTOR;
    segPtr->requestActive = 1;

    /*
     * Disk request number 2.
     */
    requestPtr = segPtr->bioreq+1;
    requestPtr->startAddress = DEV_BYTES_PER_SECTOR * 
				LfsDiskAddrToOffset(segPtr->nextDiskAddress);
    requestPtr->buffer = lfsPtr->writeBuffers[1];
    requestPtr->bufferLen = 0;
    CopySegToBuffer(segPtr, handlePtr->maxTransferSize, requestPtr->buffer,
			&requestPtr->bufferLen);
    segPtr->nextDiskAddress += requestPtr->bufferLen/DEV_BYTES_PER_SECTOR;
    if (requestPtr->bufferLen > 0) { 
	segPtr->requestActive = 2;
    } else {
	segPtr->requestActive = 1;
    }
    status = Dev_BlockDeviceIO(handlePtr, segPtr->bioreq);
    if (status != SUCCESS) {
	LfsError(lfsPtr, status, "Can't start disk log write.\n");
    }
    if (requestPtr->bufferLen > 0) {
	status = Dev_BlockDeviceIO(handlePtr, segPtr->bioreq+1);
	if (status != SUCCESS) {
	    LfsError(lfsPtr, status, "Can't start disk log write.\n");
	}
    }


    LFS_STATS_ADD(lfsPtr->stats.log.blocksWritten, segPtr->numBlocks);
    LFS_STATS_ADD(lfsPtr->stats.log.bytesWritten, segPtr->activeBytes);
    /*
     * This flag is for the ASPLOS paper.  Remove when that's all over.
     * 			Mary 2/15/92.
     */
    if ((lfsPtr->controlFlags & LFS_FSYNC_IN_PROGRESS) && Lfs_DoASPLOSStats) {
	LFS_STATS_ADD(lfsPtr->stats.log.fsyncBytes, segPtr->activeBytes);
    }
    return status;
}

/*
 *----------------------------------------------------------------------
 *
 * WriteSegmentFinish --
 *
 *	Wait for a segment write to finish.
 *
 * Results:
 *	SUCCESS if write complete. The ReturnStatus otherwise.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
WriteSegmentFinish(segPtr) 
    LfsSeg	*segPtr;	/* Segment to wait for. */
{
    ReturnStatus status;
    MASTER_LOCK((&segPtr->ioMutex));
    while (segPtr->ioDone == FALSE) { 
	Sync_MasterWait((&segPtr->ioDoneWait),(&segPtr->ioMutex),FALSE);
    }
    status = segPtr->ioReturnStatus;
    MASTER_UNLOCK((&segPtr->ioMutex));

    return status;
}


/*
 *----------------------------------------------------------------------
 *
 * WriteDoneNotify --
 *
 *	Notify others that a log write has finished and another may be
 *	started.
 *
 * Results:
 *	None
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
WriteDoneNotify(lfsPtr)
	Lfs	*lfsPtr;
{
    LOCK_MONITOR;
    lfsPtr->activeFlags &= ~LFS_WRITE_ACTIVE;
    Sync_Broadcast(&lfsPtr->writeWait);
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * CreateSegmentToWrite --
 *
 *	Create an LfsSeg structure describing an empty segment to be 
 *	filled in by the callback routines.
 *
 * Results:
 *	A pointer to a lfsSeg.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static LfsSeg *
CreateSegmentToWrite(lfsPtr, dontBlock) 
    Lfs	*lfsPtr;		/* For which file system. */
    Boolean	    dontBlock;	/* Don't wait for segment. */
{
    LfsSeg	*segPtr;
    LfsSegLogRange	segLogRange;
    int		startBlock;
    ReturnStatus status;

    LOCK_MONITOR;

    /*
     * Wait for previous writes to finish.
     */
    while (lfsPtr->activeFlags & LFS_WRITE_ACTIVE) {
	Sync_Wait(&lfsPtr->writeWait, FALSE);
    }

    do { 
	status = LfsGetLogTail(lfsPtr, dontBlock, &segLogRange, &startBlock);
	if ((status == FS_WOULD_BLOCK) && !dontBlock) {
	    LFS_STATS_INC(lfsPtr->stats.log.cleanSegWait);
	    lfsPtr->activeFlags |= LFS_CLEANSEGWAIT_ACTIVE;
	    Sync_Wait(&lfsPtr->cleanSegmentsWait, FALSE);
	} 
    } while ((status == FS_WOULD_BLOCK) && !dontBlock);

    if (status == SUCCESS) { 
	lfsPtr->activeFlags |= LFS_WRITE_ACTIVE;
	segPtr = GetSegStruct(lfsPtr, &segLogRange, startBlock, (char *) NIL);
    } else {
	segPtr = (LfsSeg *) NIL;
    }
    UNLOCK_MONITOR;
    return segPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * RewindCurPtrs --
 *
 *	Rewind the current pointers of a segment to the start of the first
 *	segment.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static void
RewindCurPtrs(segPtr)
    LfsSeg	*segPtr;
{
    segPtr->curSegSummaryPtr = (LfsSegSummary *) 
				(segPtr->segElementPtr[0].address);
    segPtr->curSummaryHdrPtr = (LfsSegSummaryHdr *) 
				(segPtr->curSegSummaryPtr + 1);
    segPtr->curElement = 1;

    segPtr->curBlockOffset = segPtr->startBlockOffset+1;
    segPtr->curDataBlockLimit = segPtr->curSummaryHdrPtr->numDataBlocks;
    segPtr->curSummaryPtr = (char *) (segPtr->curSummaryHdrPtr + 1);
    segPtr->curSummaryLimitPtr = (char *) (segPtr->curSummaryHdrPtr) +
			segPtr->curSummaryHdrPtr->lengthInBytes;

}

/*
 *----------------------------------------------------------------------
 *
 * DestorySegStruct --
 *
 *	Destory an LfsSeg structure.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
DestorySegStruct(segPtr)
    LfsSeg	*segPtr;	/* Segment to Destory. */
{

    int num;

    num = segPtr - segPtr->lfsPtr->segs;
    segPtr->lfsPtr->segsInUse  &= ~(1 << num);
}


/*
 *----------------------------------------------------------------------
 *
 * GetSegStruct --
 *
 *	Allocate an LfsSeg structure.
 *
 * Results:
 *	A lfsSeg structure
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static LfsSeg *
GetSegStruct(lfsPtr, segLogRangePtr, startBlockOffset, memPtr)
    Lfs	*lfsPtr;	/* File system. */
    LfsSegLogRange *segLogRangePtr; /* Log range of segment. */
    int		   startBlockOffset; /* Starting block offset into segment */
    char	   *memPtr;	     /* Memory allocated for segment. */
{
    int		i;
    LfsSeg	*segPtr;

    segPtr = (LfsSeg *) NIL;
    for (i = 0; i < LFS_NUM_PREALLOC_SEGS; i++) { 
	if (!(lfsPtr->segsInUse & (1 << i))) {
	    lfsPtr->segsInUse |= (1 << i);
	    segPtr = lfsPtr->segs + i;
	    break;
	}
    }
    if (segPtr == (LfsSeg *) NIL) {
	panic("GetSegStruct out of segment structures.\n");
    }
    segPtr->memPtr = memPtr;
    segPtr->logRange = *segLogRangePtr;
    segPtr->numElements = 0;
    segPtr->numBlocks = 0;
    segPtr->startBlockOffset = startBlockOffset;
    segPtr->activeBytes = 0;
    segPtr->timeOfLastWrite = 0;
    segPtr->curSegSummaryPtr = (LfsSegSummary *) NIL;
    segPtr->curSummaryHdrPtr = (LfsSegSummaryHdr *) NIL;
    segPtr->curElement = -1;
    segPtr->curBlockOffset = segPtr->startBlockOffset;
    segPtr->curDataBlockLimit = LfsSegSizeInBlocks(lfsPtr);
    segPtr->curSummaryPtr = (char *) NIL;
    segPtr->curSummaryLimitPtr = (char *) NIL;

    return segPtr;
}


/*
 *----------------------------------------------------------------------
 *
 * DoInCallBacks --
 *
 *	Perform the call backs that take segments as input.
 *
 * Results:
 *	TRUE if the segment is full. False otherwise.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static Boolean
DoInCallBacks(type, segPtr, flags, sizePtr, numCacheBlocksPtr, clientDataPtr) 
    enum CallBackType type;	/* Type of segment operation. */
    LfsSeg	*segPtr;	/* Segment to fill in or out. */
    int		flags;		/* Flags used during checkpoint. */
    int	        *sizePtr; /* Size of checkpoint buffer or segment cleaned. */
    int *numCacheBlocksPtr;
    ClientData *clientDataPtr;

{
    int	moduleType, size, numCacheBlocks, next;
    Boolean error = FALSE;
    char	 *endSummaryBlockPtr;
    LfsSegElement *bufferPtr;

    /*
     * We're doing a pass over an existing segment such as during a
     * cleaning IN phase or a WRITE_DONE callback. Initialize the 
     * moduleType from the summary region. 
     */
    endSummaryBlockPtr = (char *)segPtr->curSegSummaryPtr + 
			segPtr->curSegSummaryPtr->size;
    while(!error) { 
	while (((char *)segPtr->curSummaryHdrPtr < endSummaryBlockPtr) &&
	        (segPtr->curSummaryHdrPtr->lengthInBytes > 0))  {
	    LfsSegIoInterface *intPtr;
    
	    moduleType = segPtr->curSummaryHdrPtr->moduleType;
	    segPtr->curSummaryLimitPtr = ((char *)(segPtr->curSummaryHdrPtr) + 
				segPtr->curSummaryHdrPtr->lengthInBytes);
	    segPtr->curSummaryPtr = (char *) (segPtr->curSummaryHdrPtr + 1);
	    intPtr = lfsSegIoInterfacePtrs[moduleType];
	    switch (type) {
	    case SEG_CLEAN_IN:
		size = 0;
		numCacheBlocks = 0;
		error = intPtr->clean(segPtr, &size, &numCacheBlocks, 
			    clientDataPtr + moduleType);
#ifdef lint
		error = LfsDescMapClean(segPtr, &size, &numCacheBlocks, 
			    clientDataPtr + moduleType);
		error = LfsSegUsageClean(segPtr, &size, &numCacheBlocks, 
			    clientDataPtr + moduleType);
		error = LfsFileLayoutClean(segPtr, &size, &numCacheBlocks, 
			    clientDataPtr + moduleType);
#endif /* lint */
		*sizePtr += size;
		*numCacheBlocksPtr += numCacheBlocks;
		break;
	    case SEG_WRITEDONE: {
		intPtr->writeDone(segPtr, flags, clientDataPtr + moduleType);
#ifdef lint
		LfsDescMapWriteDone(segPtr, flags,  clientDataPtr + moduleType);
		LfsSegUsageWriteDone(segPtr, flags, clientDataPtr + moduleType);
		LfsFileLayoutWriteDone(segPtr, flags, clientDataPtr + moduleType);
#endif /* lint */
		break;
	     }
#ifdef VERIFY_CLEAN
	     case SEG_CLEAN_VERIFY: {
		 extern Boolean LfsFileLayoutCleanVerify 
		     _ARGS_((LfsSeg *segPtr));
		 if (moduleType == LFS_FILE_LAYOUT_MOD) {
		     (void) LfsFileLayoutCleanVerify(segPtr);
		 }
		 break;
	     }
#endif
	     default:
		 panic("lfsSeg.c: Bad case statement\n");
	     }
	     if (error) {
		    break;
	     }
	     segPtr->curBlockOffset += segPtr->curSummaryHdrPtr->numDataBlocks;
	     /*
	      * Skip to the next summary header. 
	      */
	     segPtr->curSummaryHdrPtr = 
			(LfsSegSummaryHdr *) segPtr->curSummaryLimitPtr;
	 }
	 if (error) {
		break;
	 }
	 /*
	  * If we ran over the end of current summary block move on to 
	  * the next.
	  */
	  next = segPtr->curSegSummaryPtr->nextSummaryBlock;
	  if (type == SEG_WRITEDONE) {
		/*
		 * Free up any memory we allocated during the layout
		 */
		LFS_STATS_ADD(segPtr->lfsPtr->stats.log.summaryBytesWritten,
				segPtr->curSegSummaryPtr->size);
		LFS_STATS_INC(segPtr->lfsPtr->stats.log.summaryBlocksWritten);
		free((char *) segPtr->curSegSummaryPtr);
	  }
          if (next == -1) {
		/*
		 * No more summary bytes for this segment.
		 */
		break;
	   }
	   bufferPtr = LfsSegGetBufferPtr(segPtr);
	   segPtr->curSegSummaryPtr = (LfsSegSummary *) bufferPtr->address;
	   segPtr->curSummaryHdrPtr = (LfsSegSummaryHdr *)
					    (segPtr->curSegSummaryPtr + 1);
	   endSummaryBlockPtr = (char *)segPtr->curSegSummaryPtr + 
			segPtr->curSegSummaryPtr->size;
	   bufferPtr++;
	   LfsSegSetBufferPtr(segPtr, bufferPtr);
	   segPtr->curBlockOffset = next;
    }
   return error;
}


/*
 *----------------------------------------------------------------------
 *
 * DoOutCallBacks --
 *
 *	Perform the call backs for output to segments.
 *
 * Results:
 *	TRUE if the segment is full. False otherwise.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static Boolean
DoOutCallBacks(type, segPtr, flags, checkPointPtr, sizePtr, clientDataPtr) 
    enum CallBackType type;	/* Type of segment operation. */
    LfsSeg	*segPtr;	/* Segment to fill in or out. */
    int		flags;		/* Flags used during checkpoint. */
    char	*checkPointPtr; /* Checkpoint buffer. */
    int	        *sizePtr; /* Size of checkpoint buffer or segment cleaned. */
    ClientData *clientDataPtr;

{
    int	moduleType, startOffset;
    Boolean full;
    char	*summaryPtr, *endSummaryPtr;
    int		newStartBlockOffset;
    LfsCheckPointRegion	*segUsageCheckpointRegionPtr;
    unsigned int         firstActiveBytesLow;               /* For ASPLOS. */
    unsigned int         firstActiveBytesHigh;              /* For ASPLOS. */


    full = FALSE;

    /* Next stats for ASPLOS only.  Remove when done.  -Mary 2/15/92. */
    firstActiveBytesLow = segPtr->lfsPtr->stats.log.fileBytesWritten.low;
    firstActiveBytesHigh = segPtr->lfsPtr->stats.log.fileBytesWritten.high;

    segUsageCheckpointRegionPtr = (LfsCheckPointRegion *) NIL;
    for(moduleType = 0; moduleType < LFS_MAX_NUM_MODS; ) {
	LfsSegIoInterface *intPtr = lfsSegIoInterfacePtrs[moduleType];
	/*
	 * Filling in a segment, be sure that there is enought
	 * room for the LfsSegSummaryHdr.
	 */
	summaryPtr = LfsSegSlowGrowSummary(segPtr, 1,
		sizeof(LfsSegSummaryHdr) + MIN_SUMMARY_REGION_SIZE, TRUE);
	if (summaryPtr == (char *) NIL) {
	    full = TRUE;
	    break;
	}
	segPtr->curSummaryHdrPtr = (LfsSegSummaryHdr *)  summaryPtr;
	LfsSegSetSummaryPtr(segPtr, summaryPtr + sizeof(LfsSegSummaryHdr));
	startOffset = segPtr->curBlockOffset;
	switch (type) {
	case SEG_CLEAN_OUT:
	case SEG_LAYOUT: 
	    full = intPtr->layout(segPtr, flags, clientDataPtr + moduleType);
#ifdef lint
	    full = LfsSegUsageLayout(segPtr, flags, clientDataPtr + moduleType);
	    full = LfsDescMapLayout(segPtr, flags, clientDataPtr + moduleType);
	    full = LfsFileLayoutProc(segPtr, flags, clientDataPtr + moduleType);
#endif /* lint */
	    break;
	case SEG_CHECKPOINT: {
	    int	size;
	    LfsCheckPointRegion	*regionPtr;
	    regionPtr = (LfsCheckPointRegion *) checkPointPtr;
	    size = 0;
	    full = intPtr->checkpoint(segPtr, flags, (char *)(regionPtr + 1),
				     &size, clientDataPtr + moduleType);
#ifdef lint
	    full = LfsDescMapCheckpoint(segPtr, flags, (char *)(regionPtr + 1),
				     &size, clientDataPtr + moduleType);
	    full = LfsSegUsageCheckpoint(segPtr, flags, (char *)(regionPtr + 1),
				     &size, clientDataPtr + moduleType);
	    full = LfsFileLayoutCheckpoint(segPtr, flags,
				(char *)(regionPtr + 1), &size,
				clientDataPtr + moduleType);
#endif /* lint */
	    if (size > 0) {
		if (moduleType == LFS_SEG_USAGE_MOD) {
			segUsageCheckpointRegionPtr = regionPtr;
		}
		regionPtr->type = moduleType;
		regionPtr->size = size + sizeof(LfsCheckPointRegion);
		*sizePtr += regionPtr->size;
		checkPointPtr += regionPtr->size;
	    }
	    break;
	 }
	 default:
	     panic("lfsSeg.c: Bad case statement\n");
	 }
	 /*
	  * If the callback added data to the segment, fill in the summary 
	  * header. 
	  */
	 endSummaryPtr = LfsSegGetSummaryPtr(segPtr); 
	 if ((startOffset != segPtr->curBlockOffset) ||
	     ((summaryPtr + sizeof(LfsSegSummaryHdr)) != endSummaryPtr)) {
	    segPtr->curSummaryHdrPtr->moduleType = moduleType;
	    segPtr->curSummaryHdrPtr->lengthInBytes = endSummaryPtr - 
			    (char *) summaryPtr;
	    segPtr->curSummaryHdrPtr->numDataBlocks =  
			    segPtr->curBlockOffset - startOffset;
	 } else {
	     LfsSegSetSummaryPtr(segPtr, summaryPtr);
	 }
	 /*
	  * If we didn't fill the segment in skip to the next module.
	  */
	 if (full) { 
	    if (LfsSegSummaryBytesLeft(segPtr) > MIN_SUMMARY_REGION_SIZE) {
		break;
	    }
	 } else {
	    moduleType++;
	 }
   }
   /*
    * Update the size of the last summary block and cap off this segment. 
    */
   segPtr->curSegSummaryPtr->size = segPtr->curSummaryPtr - 
					(char *) segPtr->curSegSummaryPtr;

   newStartBlockOffset = -1;
   if (!full) {
	if (SegIsEmpty(segPtr)) { 
	    /*
	     * The segment is totally empty.  We don't need to write
	     * this one yet.
	     */
	    LFS_STATS_INC(segPtr->lfsPtr->stats.log.emptyWrites);
	    newStartBlockOffset = segPtr->startBlockOffset;
	} else if ((segPtr->curDataBlockLimit -  segPtr->curBlockOffset) > 
		       segPtr->lfsPtr->superBlock.usageArray.wasteBlocks) { 
	    /*
	     * If this is considered to be a partial segment write add the
	     * summary block we needed.
	     */
	    AddNewSummaryBlock(segPtr);
	    newStartBlockOffset = segPtr->curBlockOffset-1;
	    LFS_STATS_INC(segPtr->lfsPtr->stats.log.partialWrites);
	    /*
	     * These stats are for the ASPLOS paper.  Remove when that's all
	     * over.   			Mary 2/15/92.
	     */
	    if ((segPtr->lfsPtr->controlFlags & LFS_FSYNC_IN_PROGRESS) &&
		    Lfs_DoASPLOSStats) {
		LFS_STATS_INC(segPtr->lfsPtr->stats.log.fsyncPartialWrites);
		LFS_STATS_ADD(segPtr->lfsPtr->stats.log.fsyncPartialBytes,
			segPtr->activeBytes);
	    }
	    if (Lfs_DoASPLOSStats) {
		LFS_STATS_ADD(segPtr->lfsPtr->stats.log.partialWriteBytes,
			segPtr->activeBytes);
		if (type == SEG_CLEAN_OUT) {
		    LFS_STATS_ADD(
			    segPtr->lfsPtr->stats.log.cleanPartialWriteBytes,
			    segPtr->activeBytes);
		}
		if (segPtr->lfsPtr->stats.log.fileBytesWritten.low -
			firstActiveBytesLow < firstActiveBytesLow) {
		    int	addit;

		    addit = segPtr->lfsPtr->stats.log.fileBytesWritten.low -
			    firstActiveBytesLow;
		    /* This is bogus.  Fix it. */
		    addit = ((unsigned int) ~0) - addit;
		    LFS_STATS_ADD(segPtr->lfsPtr->stats.log.partialFileBytes,
			    addit);
		} else {
		    LFS_STATS_ADD(segPtr->lfsPtr->stats.log.partialFileBytes,
			    segPtr->lfsPtr->stats.log.fileBytesWritten.low -
			    firstActiveBytesLow);
		}
	    }
	}
   }

   LfsSetLogTail(segPtr->lfsPtr, &segPtr->logRange, newStartBlockOffset, 
				segPtr->activeBytes, segPtr->timeOfLastWrite);  
   if (segUsageCheckpointRegionPtr != (LfsCheckPointRegion *) NIL) {
       LfsSegUsageCheckpointUpdate(segPtr->lfsPtr, 
			(char *) (segUsageCheckpointRegionPtr + 1),
			segUsageCheckpointRegionPtr->size - 
					sizeof(LfsCheckPointRegion));
    }

    if (recov_Transparent) {
	Fsrecov_UpdateLog((int) NIL);
    }
    return full;
}




/*
 *----------------------------------------------------------------------
 *
 * SegmentCleanProc --
 *
 *	Proc_CallFunc procedure for cleaning segments. The routine
 *	reads the segments into memory by calling the "Clean IN"
 *	routines and writes the data out by callin the "Clean OUT"
 *	routines.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Segments are mark as clean.	
 *
 *----------------------------------------------------------------------
 */

/* ARGSUSED */
static void
SegmentCleanProc(clientData, callInfoPtr)
    ClientData	  clientData;	/* File system to clean blocks in */
    Proc_CallInfo *callInfoPtr;         /* Not used. */

{
    register Lfs *lfsPtr = (Lfs *) clientData;       
    int		numSegsToClean, maxNumSegsToClean;
    LfsSegList	*segs;
    int		cacheBlocksInUse, segNo, numSegsCleaned, segsGen;
    LfsSeg	 *segPtr;
    Boolean	full;
    ReturnStatus	status;
    ClientData		clientDataArray[LFS_MAX_NUM_MODS];
    int			numWritten, numCleaned, totalSize, cacheBlocksReserved;
    int			minNeededToClean, totalNumWritten, maxAvailToWrite;
    int			totalNumCleaned;
    Boolean		error;
    Boolean		checkPoint;
    char		*memPtr;

#define	MAX_CLEANING_PASSES	5
#define	MAX_NUM_SEGS_TO_CLEAN	2048



    lfsPtr->cleanerProcPtr = Proc_GetCurrentProc();
    maxNumSegsToClean = lfsPtr->usageArray.checkPoint.numDirty;
    if (maxNumSegsToClean > MAX_NUM_SEGS_TO_CLEAN) {
	maxNumSegsToClean = MAX_NUM_SEGS_TO_CLEAN;
    }
    segs = (LfsSegList *) malloc(sizeof(LfsSegList) * maxNumSegsToClean);
    /*
     * Reserve the memory and cache blocks needed for cleaning.
     */
    LfsMemReserve(lfsPtr, &cacheBlocksReserved, &memPtr);
    numSegsToClean = LfsGetSegsToClean(lfsPtr, maxNumSegsToClean, segs,
				&minNeededToClean, &maxAvailToWrite);
    /*
     * Loop until the there are less than two segments to clean.
     */
    numSegsCleaned = 0;
    totalNumWritten = totalNumCleaned = 0;
    while (numSegsToClean > 1) {
	LFS_STATS_INC(lfsPtr->stats.cleaning.getSegsRequests);
	LFS_STATS_ADD(lfsPtr->stats.cleaning.segsToClean, numSegsToClean);
	    printf("%s: Cleaning started - deficit %d segs\n", lfsPtr->name,
			minNeededToClean);
	if (minNeededToClean < lfsMinNumberToClean) {
	    minNeededToClean = lfsMinNumberToClean;
	}
	segNo = 0;
	segsGen = 0;
	do {
	    int j;
	    /*
	     * Reading in segments to clean.
	     */
	    for (j = 0; j < LFS_MAX_NUM_MODS; j++) {
		clientDataArray[j] = (ClientData) NIL;
	    }
	    totalSize = 0;	  /* Total size in bytes of data cleaned. */
	    cacheBlocksInUse = 0; /* Number of cache blocks in use. */
	    numCleaned = 0;
	    for (; segNo < numSegsToClean; segNo++) {
		int size, numCacheBlocksUsed, bytesGenerated;
		/*
		 * If this segment will no fit in the space reserved in the
		 * cache then end cleaning. Also end cleaning if we 
		 * used up all the segments that we can write. Also end
		 * cleaning if we have someone waiting for us and 
		 * we have generated enough to let them proceed.
		 */
		bytesGenerated = numCleaned * LfsSegSize(lfsPtr) - totalSize;
		if ((cacheBlocksInUse + segs[segNo].activeBytes/FS_BLOCK_SIZE >
						    cacheBlocksReserved) ||
		   ((totalSize + segs[segNo].activeBytes) > 
				LfsSegSize(lfsPtr)*maxAvailToWrite) ||
		   (((lfsPtr->activeFlags & LFS_CHECKPOINTWAIT_ACTIVE) ||
		     lfsPtr->writeBackActive) &&
		    (bytesGenerated > LfsSegSize(lfsPtr)*minNeededToClean))
		      ) {
		    break;
		}
		size = 0;
		numCacheBlocksUsed = 0;
#ifdef ERROR_CHECK
		if (TRUE) {
#else
		if (segs[segNo].activeBytes > 0) { 
#endif /* ERROR_CHECK */
		    segPtr = CreateSegmentToClean(lfsPtr, segs[segNo].segNumber,
				memPtr);
		    error = DoInCallBacks(SEG_CLEAN_IN, segPtr, 0, &size,
				    &numCacheBlocksUsed, clientDataArray);
		    if (!error && (segs[segNo].activeBytes == 0) && (size != 0)) {
			printf("Warning: Segment %d cleaned found wrong active bytes %d != %d\n", segs[segNo].segNumber, size, segs[segNo].activeBytes);
		    }
		    DestorySegStruct(segPtr);
		} else {
		    error = FALSE;
		    size = 0;
		}
		if (error) {
		    LFS_STATS_ADD(lfsPtr->stats.cleaning.readErrors, 1);
		    segs[segNo].segNumber = -1;
		} else { 
		    if (size == 0) {
			LFS_STATS_INC(lfsPtr->stats.cleaning.readEmpty);
		    } else {
			int bucket = (size*LFS_STATS_CDIST_BUCKETS)
					    / LfsSegSize(lfsPtr);
			if (bucket >= LFS_STATS_CDIST_BUCKETS) {
			    bucket = (LFS_STATS_CDIST_BUCKETS - 1);
			}
			lfsPtr->stats.cleaningDist[bucket]++;
		    }
		    numCleaned++;
		}
		totalSize += size;
		cacheBlocksInUse += numCacheBlocksUsed;
	    }
	    numSegsCleaned = segNo;
	    LFS_STATS_ADD(lfsPtr->stats.cleaning.segReads,numCleaned);
	    LFS_STATS_ADD(lfsPtr->stats.cleaning.bytesCleaned,totalSize);
	    LFS_STATS_ADD(lfsPtr->stats.cleaning.cacheBlocksUsed, cacheBlocksInUse);
	    /*
	     * Write out segments cleaned.
	     */
	    numWritten = 0;
	    if (totalSize > 0) { 
		full = TRUE;
		while (full) {
		    segPtr = CreateSegmentToWrite(lfsPtr, TRUE);
		    if (segPtr == (LfsSeg *) NIL) {
			LfsError(lfsPtr, FAILURE, "Ran out of clean segments during cleaning.\n");
		    }
		    full = DoOutCallBacks(SEG_CLEAN_OUT, segPtr, 
				    LFS_CLEANING_LAYOUT, (char *) NIL,
				    (int *) NIL, clientDataArray);
    
		    status = WriteSegmentStart(segPtr);
		    if (status == SUCCESS) {
			status = WriteSegmentFinish(segPtr);
		    }
		    if (status != SUCCESS) {
			LfsError(lfsPtr, status, "Can't write segment to log\n");
		    }
		    RewindCurPtrs(segPtr);
		    (void) DoInCallBacks(SEG_WRITEDONE, segPtr, LFS_CLEANING_LAYOUT,
				    (int *) NIL, (int *) NIL,  clientDataArray);
		    WriteDoneNotify(lfsPtr);
		    numWritten++;
		    LFS_STATS_ADD(lfsPtr->stats.cleaning.blocksWritten, 
				    segPtr->numBlocks);
		    LFS_STATS_ADD(lfsPtr->stats.cleaning.bytesWritten, 
				    segPtr->activeBytes);
		    LFS_STATS_ADD(lfsPtr->stats.cleaning.segWrites, numWritten);
		    DestorySegStruct(segPtr);
		}
	    }
	    /*
	     * We keep cleaning segments until we have generated
	     * enough segments to get us above a certain threashold.
	     * Becareful not to use all available segments. In more
	     * detail, loop while:
	     * 1) We haven't generated enough segments already.
	     * 2) We haven't cleaned all the segments we are given.
	     * 3) We haven't written out as many segments as possible.
	     * 4) If someone is waiting for us we have cleaned the 
	     *    minimum possible to allow them to proceed.
	     */
	    segsGen += (numCleaned - numWritten);
	    totalNumWritten += numWritten;
	    totalNumCleaned += numCleaned;
	} while ((segsGen <= minNeededToClean) && (segNo < numSegsToClean) &&
		 (totalNumWritten < maxAvailToWrite) &&
		  !((lfsPtr->activeFlags & LFS_CHECKPOINTWAIT_ACTIVE) &&
		    (segsGen >= lfsMinNumberToClean)));

	status = LfsCheckPointFileSystem(lfsPtr, 
			LFS_CHECKPOINT_NOSEG_WAIT|LFS_CHECKPOINT_CLEANER);
	if (status != SUCCESS) {
		LfsError(lfsPtr, status, "Can't checkpoint after cleaning.\n");
	}
	if (numSegsCleaned > 0) { 
	    lfsPtr->segCache.valid = FALSE;
#ifdef VERIFY_CLEAN
	    { 
		int i;

 		for (i = 0; i < numSegsCleaned; i++) {
		    int size, numCacheBlocksUsed;
		    /*
		     * If a segment couldn't be cleaned then its segment
		     * number is set to -1. Just skip these.
		     */
		    if (segs[i].segNumber == -1) {
			continue;
		    }
		    segPtr = CreateSegmentToClean(lfsPtr, segs[i].segNumber,
				memPtr);
		    error = DoInCallBacks(SEG_CLEAN_VERIFY, segPtr, 0, &size,
				    &numCacheBlocksUsed, clientDataArray);
		    DestorySegStruct(segPtr);
		}
	    }
#endif
	    LfsMarkSegsClean(lfsPtr, numSegsCleaned, segs);
	    LOCK_MONITOR;
	    lfsPtr->activeFlags &= ~LFS_CLEANSEGWAIT_ACTIVE;
	    Sync_Broadcast(&lfsPtr->cleanSegmentsWait);
	    UNLOCK_MONITOR;
	}
	printf("%s: Cleaned %d segments in %d segments\n", 
		    lfsPtr->name, totalNumCleaned, totalNumWritten);
	numSegsToClean = LfsGetSegsToClean(lfsPtr, maxNumSegsToClean, segs,
			 &minNeededToClean, &maxAvailToWrite);
	if (minNeededToClean == 0) {
		break;
	}
    }
    free((char *)segs);
    lfsPtr->segCache.valid = FALSE;
    LfsMemRelease(lfsPtr, cacheBlocksReserved, memPtr);

    LOCK_MONITOR;
    /*  
     * Release the flags that mark us as an active cleaner process for
     * this file system.
     * If someone is waiting for us to checkpoint.
     */
    lfsPtr->activeFlags &= ~LFS_CLEANER_ACTIVE;
    lfsPtr->cleanerProcPtr = (Proc_ControlBlock *) NIL;
    checkPoint = (lfsPtr->activeFlags & LFS_CHECKPOINTWAIT_ACTIVE);
    UNLOCK_MONITOR;

    if (checkPoint) { 
	(void) LfsCheckPointFileSystem(lfsPtr, 0);
    }

}


static LfsSeg *
CreateSegmentToClean(lfsPtr, segNumber, cleaningMemPtr)
    Lfs	*lfsPtr;	/* File system of segment. */
    int	segNumber;	/* Segment number to clean. */
    char *cleaningMemPtr; /* Memory to use for cleaning. */
{
    LfsSeg		*segPtr;
    int			segSize;
    ReturnStatus	status;
    LfsSegLogRange	logRange;
    LfsSegSummary	*segSumPtr;
    LfsSegSummary	*prevSegSumPtr;
    LfsDiskAddr		diskAddress;
    int			blocksPerSeg;

    logRange.prevSeg = -1;
    logRange.current = segNumber;
    logRange.nextSeg = -1;

    /*
     * Get a LfsSeg structure.
     */
    lfsPtr->segCache.valid = FALSE;
    segPtr = GetSegStruct(lfsPtr, &logRange, 0, cleaningMemPtr);

    /*
     * Read in the segment in memory.
     */
    segSize = LfsSegSize(lfsPtr);
    blocksPerSeg = LfsBytesToBlocks(lfsPtr,segSize);
    LfsSegNumToDiskAddress(lfsPtr, segNumber, &diskAddress);
    status = LfsReadBytes(lfsPtr, diskAddress, segSize, cleaningMemPtr);
    if (status != SUCCESS) {
	LfsError(lfsPtr, status, "Can't read segment to clean.\n");
	return (LfsSeg *) NIL;
    }
    lfsPtr->segCache.segNum = segNumber;
    LfsSegNumToDiskAddress(lfsPtr, segNumber, 
		&lfsPtr->segCache.startDiskAddress);
    LfsSegNumToDiskAddress(lfsPtr, segNumber+1, 
		&lfsPtr->segCache.endDiskAddress);
    lfsPtr->segCache.memPtr = cleaningMemPtr;
    lfsPtr->segCache.valid = TRUE;

    segSumPtr = (LfsSegSummary *)
		(cleaningMemPtr + segSize - LfsBlockSize(lfsPtr));
    prevSegSumPtr = segSumPtr;
    while (1) { 
	if (segSumPtr->magic != LFS_SEG_SUMMARY_MAGIC) {
	    printf("Bad segment summary magic in segment %d\n", segNumber);
	    if (segSumPtr == prevSegSumPtr) {
		LfsError(lfsPtr, FAILURE,
			 "Corrupted summary block at start of segment\n");
		panic("Previous error not continuable.\n");
	    } else {
		LfsError(lfsPtr, FAILURE,
			 "Corrupted segment summary block (continuable)\n");
		prevSegSumPtr->nextSummaryBlock = -1;
		break;
	    }
	}
	segPtr->segElementPtr[segPtr->numElements].lengthInBlocks = 0;
	segPtr->segElementPtr[segPtr->numElements].address = (char *) segSumPtr;
	segPtr->segElementPtr[segPtr->numElements].clientData = 
				(ClientData) NIL;
	segPtr->numElements++;

	LFS_STATS_INC(lfsPtr->stats.cleaning.summaryBlocksRead);
	if (segSumPtr->nextSummaryBlock == -1) {
		break;
	}
	if (segPtr->numElements > blocksPerSeg) {
	    printf("Lfs: Bad segment %d\n", segNumber);
	    LfsError(lfsPtr, FAILURE, "Corrupted segment\n");
	}
	if ((segSumPtr->nextSummaryBlock < 0) || 
	    (segSumPtr->nextSummaryBlock > blocksPerSeg)) {
	    printf("Bogus next pointer in segment summary block %d\n",
		   segNumber);
	    LfsError(lfsPtr, FAILURE,
		     "Corrupted segment summary block (continuable)\n");
	    segSumPtr->nextSummaryBlock = -1;
	    break;
	}
	prevSegSumPtr = segSumPtr;
	segSumPtr = (LfsSegSummary *) 
			LfsSegFetchBytes(segPtr, segSumPtr->nextSummaryBlock,
				LfsBlockSize(lfsPtr));
    }
    RewindCurPtrs(segPtr);
    return segPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * LfsSegAttach --
 *
 *	Call the attach routines all the segment I/O modules.
 *
 * Results:
 *	SUCCESS if everything when well.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
LfsSegAttach(lfsPtr, checkPointPtr, checkPointSize)
    Lfs		*lfsPtr;	/* File system being attached. */
    char        *checkPointPtr; /* Latest checkpoint header. */
    int		checkPointSize; /* Size of the checkpoint buffer. */
{
    int		moduleType;
    char	*limitPtr;
    LfsCheckPointRegion *regionPtr;
    ReturnStatus	status;
    LfsSegIoInterface	*segIoPtr;

    lfsPtr->segCache.valid = FALSE;

    limitPtr = checkPointPtr + checkPointSize;
    for (moduleType = 0; moduleType < LFS_MAX_NUM_MODS; moduleType++) {
	regionPtr = (LfsCheckPointRegion *) checkPointPtr;
	segIoPtr = lfsSegIoInterfacePtrs[moduleType];
	if ((checkPointPtr < limitPtr) && (regionPtr->type == moduleType)) { 
	    checkPointPtr += regionPtr->size;
	    status = segIoPtr->attach(lfsPtr, 
				(int)(regionPtr->size - sizeof(*regionPtr)),
				(char *) (regionPtr+1));
#ifdef lint
	    status = LfsDescMapAttach(lfsPtr, 
				(int)(regionPtr->size - sizeof(*regionPtr)),
				(char *) (regionPtr+1));
	    status = LfsFileLayoutAttach(lfsPtr, 
				(int)(regionPtr->size - sizeof(*regionPtr)),
				(char *) (regionPtr+1));
	    status = LfsSegUsageAttach(lfsPtr, 
				(int)(regionPtr->size - sizeof(*regionPtr)),
				(char *) (regionPtr+1));

#endif /* lint */
	} else {
	    status = segIoPtr->attach(lfsPtr, 0, (char *)NIL);
#ifdef lint
	    status = LfsDescMapAttach(lfsPtr, 0, (char *)NIL);
	    status = LfsFileLayoutAttach(lfsPtr, 0, (char *)NIL);
	    status = LfsSegUsageAttach(lfsPtr, 0, (char *)NIL);
#endif /* lint */
	}
	if (status != SUCCESS) {
	    LfsError(lfsPtr, status, "Can't attach module");
	    break;
	}
    }
    if (status == SUCCESS) {
	InitSegmentMem(lfsPtr);
	return status;
    }
    /*
     * XXX - Back out of error here by shutting down all module.
     */
    return status;
}

/*
 *----------------------------------------------------------------------
 *
 * LfsSegCheckPoint --
 *
 *	Call the checkpoint routines all the segment I/O modules.
 *
 * Results:
 *	SUCCESS if everything when well.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
LfsSegCheckPoint(lfsPtr, flags, checkPointPtr, checkPointSizePtr)
    Lfs	  	    *lfsPtr;		/* File system to checkpoint. */
    int		    flags;		/* Flags to checkpoint operation. */
    char	    *checkPointPtr;	/* Checkpoint area to be filled in.*/
    int		    *checkPointSizePtr; /* Size of checkpoint buffer. */
{
    Boolean	full = TRUE;
    LfsSeg	*segPtr;
    ClientData		clientDataArray[LFS_MAX_NUM_MODS];
    int			i;
    ReturnStatus	status= SUCCESS;

    LOCK_MONITOR;

    /*
     * Wait for the cleaner not to be active unless we are called from the 
     * cleaner, the detach code, or the timer callback.
     */
    if (lfsPtr->activeFlags & LFS_CLEANER_ACTIVE) {
	if (flags & LFS_CHECKPOINT_TIMER) {
	    /*
	     * Since the cleaner does checkpoints frequently, we can safely
	     * ignore TIMER checkpoints.
	     */
	    (*checkPointSizePtr) = -1;
	    UNLOCK_MONITOR;
	    return SUCCESS;
        }
	if (!(flags & (LFS_CHECKPOINT_DETACH|LFS_CHECKPOINT_CLEANER))) {
	    /*
	     * Unless the checkpoint is from the cleaner or the detach 
	     * code we simply wait for a checkpoint to complete and 
	     * return.
	     */
	    if (!(lfsPtr->activeFlags & LFS_CHECKPOINTWAIT_ACTIVE)) {
		lfsPtr->activeFlags |= LFS_CHECKPOINTWAIT_ACTIVE;
	    }
	    while (lfsPtr->activeFlags & LFS_CHECKPOINTWAIT_ACTIVE) { 
		Sync_Wait(&lfsPtr->checkPointWait, FALSE);
	    }
	    (*checkPointSizePtr) = -1;
	    UNLOCK_MONITOR;
	    return SUCCESS;
	} 
    }
    /*
     * Wait for any currently running checkpoint to finish.
     * TIMER checkpoints again can be ignored and cleaner checkpoint can
     * run in parallel.
     */
    if (!(flags & LFS_CHECKPOINT_CLEANER)) { 
	while (lfsPtr->activeFlags & LFS_CHECKPOINT_ACTIVE) {
	    if (flags & LFS_CHECKPOINT_TIMER) {
		(*checkPointSizePtr) = -1;
		UNLOCK_MONITOR;
		return SUCCESS;
	    }
	    Sync_Wait(&lfsPtr->checkPointWait, FALSE);
	}
	lfsPtr->activeFlags |= LFS_SYNC_CHECKPOINT_ACTIVE;
    } else {
	lfsPtr->activeFlags |= LFS_CLEANER_CHECKPOINT_ACTIVE;
    }

    /*
     * Wait for any directory log operations to finish.
     */
    while (lfsPtr->dirModsActive > 0) {
	Sync_Wait(&lfsPtr->checkPointWait, FALSE);
    }
    /*
     * If we a detatching the file system wait for any cleaners to exit.
     */
    if (flags & LFS_CHECKPOINT_DETACH) {
	lfsPtr->activeFlags |= LFS_SHUTDOWN_ACTIVE;
	while (lfsPtr->activeFlags & LFS_CLEANER_ACTIVE) {
	    Time time;
	    time.seconds = 1;
	    time.microseconds = 0;
	    Sync_WaitTime(time);
	}
    }
    LFS_STATS_INC(lfsPtr->stats.checkpoint.count);
    UNLOCK_MONITOR;

    if (flags & LFS_CHECKPOINT_DETACH) {
	LfsStopWriteBack(lfsPtr);
    }

    for (i = 0; i < LFS_MAX_NUM_MODS; i++) {
	clientDataArray[i] = (ClientData) NIL;
    }
    while (full) {
	segPtr = CreateSegmentToWrite(lfsPtr, 
			((flags & LFS_CHECKPOINT_NOSEG_WAIT) != 0));
	if (segPtr == (LfsSeg *) NIL) {
	    LfsError(lfsPtr, FAILURE, "Ran out of clean segments during cleaner checkpoint.\n");
	}
	*checkPointSizePtr = 0;
	full = DoOutCallBacks(SEG_CHECKPOINT, segPtr, flags,
			    checkPointPtr, checkPointSizePtr, clientDataArray);
	LFS_STATS_INC(lfsPtr->stats.checkpoint.segWrites);
	LFS_STATS_ADD(lfsPtr->stats.checkpoint.blocksWritten,
					segPtr->numBlocks);
	LFS_STATS_ADD(lfsPtr->stats.checkpoint.bytesWritten,
				segPtr->activeBytes);
	status = WriteSegmentStart(segPtr);
	if (status == SUCCESS) {
	    status = WriteSegmentFinish(segPtr);
	}
	if (status != SUCCESS) {
	    LfsError(lfsPtr, status, "Can't write segment to log\n");
	}
	RewindCurPtrs(segPtr);
	(void) DoInCallBacks(SEG_WRITEDONE, segPtr, flags, (int *) NIL, (int *) NIL,
				clientDataArray);
	WriteDoneNotify(lfsPtr);
        DestorySegStruct(segPtr);
    }
    return status;

}

/*
 *----------------------------------------------------------------------
 *
 * LfsSegCheckPointDone --
 *
 *	Mark a checkpoint as done.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
LfsSegCheckPointDone(lfsPtr, flags)
    Lfs	*lfsPtr;
    int	flags;
{
    LOCK_MONITOR;
    lfsPtr->numDirtyBlocks = 0;
#ifdef notdef
    { 
	int numBlocks, numDirty;
	Fscache_CountBlocks(rpc_SpriteID, lfsPtr->domainPtr->domainNumber,
				&numBlocks, &numDirty);
	if (((flags & LFS_CHECKPOINT_DETACH) && numDirty) || (numDirty > 1)) {
		printf("DirtyBlocks (%d) after a checkpoint\n", numDirty);
	}
    }
#endif
    if (flags & LFS_CHECKPOINT_CLEANER) {
	lfsPtr->activeFlags &= 
		~(LFS_CLEANER_CHECKPOINT_ACTIVE|LFS_CHECKPOINTWAIT_ACTIVE|
		  LFS_CLEANSEGWAIT_ACTIVE);
	Sync_Broadcast(&lfsPtr->cleanSegmentsWait)
    } else { 
	lfsPtr->activeFlags &= 
		~(LFS_SYNC_CHECKPOINT_ACTIVE|LFS_CHECKPOINTWAIT_ACTIVE);
    }
    Sync_Broadcast(&lfsPtr->checkPointWait);
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * LfsSegDetach --
 *
 *	Call a shutdown time on an LFS file system.
 *
 * Results:
 *	SUCCESS if everything when well.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
LfsSegDetach(lfsPtr)
    Lfs	  	    *lfsPtr;		/* File system to checkpoint. */
{

    int	moduleType;
    LfsSegIoInterface	*segIoPtr;
    ReturnStatus status = SUCCESS;

    for (moduleType = 0; moduleType < LFS_MAX_NUM_MODS; moduleType++) {
	segIoPtr = lfsSegIoInterfacePtrs[moduleType];
	status = segIoPtr->detach(lfsPtr);
#ifdef lint
	status = LfsDescMapDetach(lfsPtr);
	status = LfsFileLayoutDetach(lfsPtr);
	status = LfsSegUsageDetach(lfsPtr);
#endif 
    }
    FreeSegmentMem(lfsPtr);
    return status;

}

/*
 *----------------------------------------------------------------------
 *
 * LfsWaitForCheckPoint --
 *
 *	Wait for a checkpoint to complete on a file system.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
LfsWaitForCheckPoint(lfsPtr) 
    Lfs	*lfsPtr;
{
    LOCK_MONITOR;
    while (lfsPtr->activeFlags & LFS_CHECKPOINT_ACTIVE) {
	Sync_Wait(&lfsPtr->checkPointWait, FALSE);
    }
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * LfsWaitForCleanSegments --
 *
 *	Ensure that there is enough clean segments to write a
 *	dirty cache block being added to the system. Also
 *	besure that a checkpoint is not active.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */


void
LfsWaitForCleanSegments(lfsPtr)
    Lfs	*lfsPtr;
{
    LOCK_MONITOR;
    lfsPtr->numDirtyBlocks++;
    while ((lfsPtr->activeFlags & LFS_CHECKPOINT_ACTIVE) ||
		!LfsSegUsageEnoughClean(lfsPtr, 
			lfsPtr->numDirtyBlocks * FS_BLOCK_SIZE)) {
	if (!(lfsPtr->activeFlags & LFS_CHECKPOINTWAIT_ACTIVE)) {
	    lfsPtr->activeFlags |= LFS_CHECKPOINTWAIT_ACTIVE;
	}
	Sync_Wait(&lfsPtr->checkPointWait, FALSE);
    }
    UNLOCK_MONITOR;
}

@


1.24
log
@Included call to clear dir log ops if transparent recovery is being used.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/lfs/lfsSeg.c,v 1.23 92/04/10 16:38:41 kupfer Exp $ SPRITE (Berkeley)";
d26 1
@


1.23
log
@Make some "corrupted summary block" panics continuable.  Lint.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/lfs/lfsSeg.c,v 1.22 92/04/06 13:46:50 mgbaker Exp $ SPRITE (Berkeley)";
d25 1
d1267 3
@


1.22
log
@Took out a silly comment.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/lfs/lfsSeg.c,v 1.21 92/04/06 13:40:14 mgbaker Exp $ SPRITE (Berkeley)";
a223 1
    Lfs	*lfsPtr;
a242 1
    lfsPtr = segPtr->lfsPtr;
d1291 1
a1291 1

d1547 1
d1582 1
d1586 10
a1595 1
	    LfsError(lfsPtr, FAILURE, "Corrupted segment summary block\n");
d1613 6
a1618 2
	    printf("Bad segment summary magic in segment %d\n", segNumber);
	    LfsError(lfsPtr, FAILURE, "Corrupted segment summary block\n");
d1620 1
@


1.21
log
@Verify code fixed so that it doesn't test uncleaned segments for whether
they are clean.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/lfs/lfsSeg.c,v 1.20 92/03/12 15:27:36 jhh Exp $ SPRITE (Berkeley)";
d1484 1
a1484 4
/*
 * This is what it was.  I think it's bogus.  -Mary.
 *		for (i = 0; i < numSegsToClean; i++) {
 */
@


1.20
log
@Added sanity checking that verifies that a segment really is clean after
it has been cleaned.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/lfs/lfsSeg.c,v 1.19 92/03/06 11:56:55 mgbaker Exp $ SPRITE (Berkeley)";
d1484 5
a1488 1
		for (i = 0; i < numSegsToClean; i++) {
@


1.19
log
@Added temporary measurements for ASPLOS paper.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/lfs/lfsSeg.c,v 1.18 91/08/22 13:15:25 mendel Exp $ SPRITE (Berkeley)";
d34 1
a34 1

d37 4
d1016 10
d1318 2
a1391 1
	
d1481 20
@


1.18
log
@Added checking of bounds when reading a segment in.
Removed error checking.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/lfs/RCS/lfsSeg.c,v 1.17 91/08/08 17:48:29 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d119 1
d121 5
d127 4
d154 6
d625 7
d699 7
d1092 3
d1097 5
d1208 34
@


1.17
log
@Added Detach interface routine and calls to it.
Removed used #ifdefs.
Added code to end cleaning early when someone is waiting on the cleaner.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/lfs/RCS/lfsSeg.c,v 1.16 91/07/03 09:55:17 mendel Exp $ SPRITE (Berkeley)";
d1442 1
d1458 1
a1458 1

d1476 4
d1490 9
d1744 1
a1744 1
#ifdef ERROR_CHECK
@


1.16
log
@Oops.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/lfs/RCS/lfsSeg.c,v 1.15 91/07/03 09:43:44 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d28 2
a495 8
/*
 * By defining SUN4DMAHACK, LFS copies data to block already allocated
 * in DMA space.  This saves DMA allocation and free in the device
 * driver.
 */
#ifdef notdef
#define	SUN4DMAHACK
#endif
a543 5
#ifdef SUN4DMAHACK
	    if (segPtr->numElements >= 8) {
		VmMach_DMAFree(handlePtr->maxTransferSize, requestPtr->buffer);
	    }
#endif
a638 8
#ifdef SUN4DMAHACK
    if (segPtr->numElements >= 8) {
	requestPtr->buffer = VmMach_DMAAlloc(handlePtr->maxTransferSize,
					     lfsPtr->writeBuffers[0]);
    } else {
	requestPtr->buffer = lfsPtr->writeBuffers[0];
    }
#else
a639 1
#endif
a651 8
#ifdef SUN4DMAHACK
    if (segPtr->numElements >= 8) {
	requestPtr->buffer = VmMach_DMAAlloc(handlePtr->maxTransferSize,
					     lfsPtr->writeBuffers[1]);
    } else {
	requestPtr->buffer = lfsPtr->writeBuffers[1];
    }
#else
a652 1
#endif 
d776 1
d1226 1
d1254 3
d1271 1
a1271 1
		int size, numCacheBlocksUsed;
d1275 3
a1277 1
		 * used up all the segments that we can write.
d1279 1
d1283 5
a1287 1
				LfsSegSize(lfsPtr)*maxAvailToWrite)) {
d1371 7
a1377 1
	     * Becareful not to use all available segments.
d1383 3
a1385 1
		 (totalNumWritten < maxAvailToWrite));
d1396 1
d1411 1
d1413 5
d1420 5
a1424 10
    /* 
     * If someone is waiting for us to checkpoint or
     * we didn't do anywork, do a checkpoint.
     */
    if ((lfsPtr->activeFlags & LFS_CHECKPOINTWAIT_ACTIVE) ||
	(totalNumCleaned == 0)) {
	UNLOCK_MONITOR;
	status = LfsCheckPointFileSystem(lfsPtr, 0);
    } else {
	UNLOCK_MONITOR;
a1426 1

d1742 2
a1743 1
		~(LFS_CLEANER_CHECKPOINT_ACTIVE|LFS_CHECKPOINTWAIT_ACTIVE);
d1774 13
d1788 1
a1788 1
    return SUCCESS;
d1846 3
@


1.15
log
@Added back check for empty segment before marking clean.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/lfs/RCS/lfsSeg.c,v 1.14 91/07/01 14:42:24 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d1303 1
a1303 1
		   ((size + segs[segNo].activeBytes) > 
@


1.14
log
@Made wait for Clean segments wake on checkpoint.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/lfs/RCS/lfsSeg.c,v 1.13 91/06/29 17:07:22 mendel Exp $ SPRITE (Berkeley)";
d1309 3
d1313 1
@


1.13
log
@Added new interface between SegUsage and Seg to handle sorting of 
segments to clean.  Added code to wait for enough clean segments 
before allocate. 
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/lfs/RCS/lfsSeg.c,v 1.12 91/05/29 14:08:49 mendel Exp $ SPRITE (Berkeley)";
d1418 6
a1423 1
    if (lfsPtr->activeFlags & LFS_CHECKPOINTWAIT_ACTIVE) {
d1833 3
a1835 5
    while (!LfsSegUsageEnoughClean(lfsPtr, 
		lfsPtr->numDirtyBlocks * FS_BLOCK_SIZE)) {
	Sync_Wait(&lfsPtr->cleanSegmentsWait, FALSE);
    }
    while (lfsPtr->activeFlags & LFS_CHECKPOINT_ACTIVE) {
@


1.12
log
@1) Modified SegCheckPoint to return a size of -1 if checkpoint not done.
2) Modified cleaning code to keep reading segments until reserved 
portion of the cache is filled.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/lfs/RCS/lfsSeg.c,v 1.11 91/02/01 16:29:58 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d24 1
d924 1
d1200 1
d1202 1
a1202 1
					segPtr->activeBytes);  
d1243 3
a1245 4
#define	MAX_NUM_TO_CLEAN 25
    int		numSegsToClean;
    LfsSegList	segs[MAX_NUM_TO_CLEAN];
    int		i, cacheBlocksInUse;
d1251 2
d1256 3
d1260 5
d1269 2
a1270 1
    numSegsToClean = LfsGetSegsToClean(lfsPtr, MAX_NUM_TO_CLEAN, segs);
d1274 2
d1279 40
a1318 37
	    printf("%s: Cleaning started - %d segs\n", lfsPtr->name,
			numSegsToClean);
	/*
	 * Reading in segments to clean.
	 */
	for (i = 0; i < LFS_MAX_NUM_MODS; i++) {
	    clientDataArray[i] = (ClientData) NIL;
	}
	totalSize = 0;		  /* Total size in bytes of data cleaned. */
	cacheBlocksInUse = 0; /* Number of cache blocks in use. */
	numCleaned = 0;
	for (i = 0; i < numSegsToClean; i++) {
	    int size, numCacheBlocksUsed;
	    /*
	     * If this segment will no fit in the space reserved in the
	     * cache then end cleaning.
	     */
	    if (cacheBlocksInUse + segs[i].activeBytes/FS_BLOCK_SIZE >
						cacheBlocksReserved) {
		break;
	    }
	    segPtr = CreateSegmentToClean(lfsPtr, segs[i].segNumber, memPtr);
	    size = 0;
	    numCacheBlocksUsed = 0;
	    error = DoInCallBacks(SEG_CLEAN_IN, segPtr, 0, &size,
			    &numCacheBlocksUsed, clientDataArray);
	    if (!error && (segs[i].activeBytes == 0) && (size != 0)) {
		printf("Warning: Segment %d cleaned found wrong active bytes %d != %d\n", segs[i].segNumber, size, segs[i].activeBytes);
	    }

	    DestorySegStruct(segPtr);
	    if (error) {
		LFS_STATS_ADD(lfsPtr->stats.cleaning.readErrors, 1);
		segs[i].segNumber = -1;
	    } else { 
		if (size == 0) {
		    LFS_STATS_INC(lfsPtr->stats.cleaning.readEmpty);
d1320 16
a1335 4
		    int bucket = (size*LFS_STATS_CDIST_BUCKETS)
					/ LfsSegSize(lfsPtr);
		    if (bucket >= LFS_STATS_CDIST_BUCKETS) {
			bucket = (LFS_STATS_CDIST_BUCKETS - 1);
d1337 1
a1337 1
		    lfsPtr->stats.cleaningDist[bucket]++;
d1339 2
a1340 1
		numCleaned++;
d1342 37
a1378 17
	    totalSize += size;
	    cacheBlocksInUse += numCacheBlocksUsed;
	}
	numSegsToClean = i;
	LFS_STATS_ADD(lfsPtr->stats.cleaning.segReads,numCleaned);
	LFS_STATS_ADD(lfsPtr->stats.cleaning.bytesCleaned,totalSize);
	LFS_STATS_ADD(lfsPtr->stats.cleaning.cacheBlocksUsed, cacheBlocksInUse);
	/*
	 * Write out segments cleaned.
	 */
	numWritten = 0;
	if (totalSize > 0) { 
	    full = TRUE;
	    while (full) {
		segPtr = CreateSegmentToWrite(lfsPtr, TRUE);
		if (segPtr == (LfsSeg *) NIL) {
		    LfsError(lfsPtr, FAILURE, "Ran out of clean segments during cleaning.\n");
d1380 11
a1390 3
		full = DoOutCallBacks(SEG_CLEAN_OUT, segPtr, 
				LFS_CLEANING_LAYOUT, (char *) NIL,
				(int *) NIL, clientDataArray);
a1391 20
		status = WriteSegmentStart(segPtr);
		if (status == SUCCESS) {
		    status = WriteSegmentFinish(segPtr);
		}
		if (status != SUCCESS) {
		    LfsError(lfsPtr, status, "Can't write segment to log\n");
		}
		RewindCurPtrs(segPtr);
		(void) DoInCallBacks(SEG_WRITEDONE, segPtr, LFS_CLEANING_LAYOUT,
				(int *) NIL, (int *) NIL,  clientDataArray);
		WriteDoneNotify(lfsPtr);
		numWritten++;
		LFS_STATS_ADD(lfsPtr->stats.cleaning.blocksWritten, 
				segPtr->numBlocks);
		LFS_STATS_ADD(lfsPtr->stats.cleaning.bytesWritten, 
				segPtr->activeBytes);
		LFS_STATS_ADD(lfsPtr->stats.cleaning.segWrites, numWritten);
		DestorySegStruct(segPtr);
	    }
	}
d1397 3
a1399 6
	for (i = 0; i < numSegsToClean; i++) { 
	    if (segs[i].segNumber != -1) { 
		LfsMarkSegClean(lfsPtr, segs[i].segNumber);
	    }
	}
	if (numCleaned > 0) { 
d1405 6
a1410 2
		    lfsPtr->name, numCleaned, numWritten);
	numSegsToClean = LfsGetSegsToClean(lfsPtr, MAX_NUM_TO_CLEAN, segs);
d1412 1
d1728 1
d1742 1
d1776 45
d1823 1
a1823 1
LfsWaitForCheckPoint(lfsPtr) 
d1827 5
@


1.11
log
@Fixed typo.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/lfs/RCS/lfsSeg.c,v 1.10 91/01/09 12:17:21 mendel Exp $ SPRITE (Berkeley)";
d1011 3
d1218 4
a1221 1
 *	Proc_CallFunc procedure for cleaning segments write.
d1227 1
a1227 1
 *	None.	
d1240 1
a1240 1
#define	MAX_NUM_TO_CLEAN 100
d1243 1
a1243 1
    int		i, numCacheBlocksUsed, totalCacheBlocksUsed;
d1252 4
d1257 5
a1261 11
    do { 
	for (i = 0; i < LFS_MAX_NUM_MODS; i++) {
	    clientDataArray[i] = (ClientData) NIL;
	}
	numSegsToClean = MAX_NUM_TO_CLEAN;
	numSegsToClean = LfsGetSegsToClean(lfsPtr, 
			 cacheBlocksReserved, numSegsToClean, segs);

	if (numSegsToClean < 2) {
	    break;
	}
d1264 2
a1265 2
	printf("%s: Cleaning started - %d segs\n", lfsPtr->name, 
				numSegsToClean);
d1269 5
a1273 2
	totalSize = 0;
	totalCacheBlocksUsed = 0;
d1275 10
a1284 3
	for (i = 0; (i < numSegsToClean) && 
		    (totalCacheBlocksUsed < cacheBlocksReserved); i++) { 
	    int size;
d1312 1
a1312 1
	    totalCacheBlocksUsed += numCacheBlocksUsed;
d1314 1
d1317 1
a1317 2
	LFS_STATS_ADD(lfsPtr->stats.cleaning.cacheBlocksUsed,
			totalCacheBlocksUsed);
d1370 2
a1371 1
    } while (numSegsToClean > 2);
d1376 1
d1566 1
d1568 1
a1568 1
	    return GEN_EINTR;
d1582 1
d1595 1
d1597 1
a1597 1
		return GEN_EINTR;
@


1.10
log
@Changed to so only clean a few segments rather than the entire disk 
each time.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/lfs/RCS/lfsSeg.c,v 1.9 91/01/04 15:47:12 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d1288 6
a1293 1
		    lfsPtr->stats.cleaningDist[size/LFS_STATS_CDIST_BUCKETS]++;
@


1.9
log
@Fixed problem dealing with devices with max transfer size too large to 
malloc.   
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/lfs/RCS/lfsSeg.c,v 1.8 90/12/07 10:07:44 mendel Exp $ SPRITE (Berkeley)";
d1251 1
a1251 4
	numSegsToClean = lfsPtr->superBlock.usageArray.numSegsToClean;
	if (numSegsToClean > MAX_NUM_TO_CLEAN) {
	    numSegsToClean = MAX_NUM_TO_CLEAN;
	}
d1260 2
a1261 3
	if (lfsSegWriteDebug || TRUE) { 
	    printf("Cleaning started - %d segs\n", numSegsToClean);
	}
d1287 2
a1301 1

d1349 3
a1351 5
	if (lfsSegWriteDebug || TRUE) { 
	    printf("Cleaned %d segments in %d segments\n", numCleaned, 
			numWritten);
	}
    } while (numCleaned > 2);
@


1.8
log
@Redid checkpoint sync to remove races.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/lfs/RCS/lfsSeg.c,v 1.7 90/11/09 15:58:36 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d357 8
a364 3
    lfsPtr->writeBuffers[0] = malloc(handlePtr->maxTransferSize*2);
    lfsPtr->writeBuffers[1] = lfsPtr->writeBuffers[0] + 
				handlePtr->maxTransferSize;
d1201 1
a1201 1
					sizeof(segUsageCheckpointRegionPtr));
@


1.7
log
@Fixed problem with reporting errors on segment writes.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/lfs/RCS/lfsSeg.c,v 1.6 90/10/30 09:58:37 mendel Exp $ SPRITE (Berkeley)";
d49 1
d137 1
a721 1
    Lfs	*lfsPtr = segPtr->lfsPtr;
d729 25
a757 1
    return status;
a758 1

d1079 1
d1082 1
d1125 3
d1192 8
a1199 1
   return full;
d1276 1
a1276 1
		panic("Warning: Segment %d cleaned found wrong active bytes %d != %d\n", segs[i].segNumber, size, segs[i].activeBytes);
d1305 3
d1322 1
d1332 2
a1333 1
	status = LfsCheckPointFileSystem(lfsPtr, LFS_CHECKPOINT_NOSEG_WAIT);
d1536 2
a1537 3
     * If a checkpoint is already active (or cleaner active) and its a 
     * writeback or timer checkpoint we exit with GEN_EINTR. For 
     * writeback checkpoints we wait for them to finish.
d1539 19
a1557 5
    if ((lfsPtr->activeFlags & (LFS_CLEANER_ACTIVE|LFS_CHECKPOINT_ACTIVE)) &&
        (flags & (LFS_CHECKPOINT_WRITEBACK|LFS_CHECKPOINT_TIMER))) {
	if (flags & LFS_CHECKPOINT_WRITEBACK) {
	    lfsPtr->activeFlags |= LFS_CHECKPOINTWAIT_ACTIVE;
	    while (lfsPtr->activeFlags & LFS_CHECKPOINTWAIT_ACTIVE) {
d1560 20
a1579 3
	}
	UNLOCK_MONITOR;
	return GEN_EINTR;
a1581 1
    lfsPtr->activeFlags |= LFS_CHECKPOINT_ACTIVE;
d1613 3
d1634 1
d1637 25
d1673 7
a1679 1
    lfsPtr->activeFlags &= ~(LFS_CHECKPOINT_ACTIVE|LFS_CHECKPOINTWAIT_ACTIVE);
a1681 2
    return status;

@


1.6
log
@Made if following changes to segment writing:
1) Modified to use BlockDevice interface and fire off two request at a time.
2) Modified to use two buffers the size of the device's MTU rather than 
   one segment size buffer.
3) Changed segment writing to use a Start/WaitForCompletion interface to
   allow for future segment layout/write pipeline.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/lfs/RCS/lfsSeg.c,v 1.5 90/10/19 17:22:57 mendel Exp $ SPRITE (Berkeley)";
d719 1
d725 1
d732 1
a732 1
    return SUCCESS;
@


1.5
log
@Many bug fixed. First installed LFS.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/lfs/RCS/lfsSeg.c,v 1.4 90/08/02 16:19:36 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d47 2
a48 1
static ReturnStatus WriteSegment _ARGS_((LfsSeg *segPtr, Boolean full));
d53 5
d126 4
a129 1
	    status = WriteSegment(segPtr, full);
d335 1
d354 4
a358 1

d381 1
d438 123
a560 1
#define SUN4HACK
d566 3
a568 2
 * WriteSegment --
 *	Write a segment to the log.
d571 1
d579 1
a579 1
WriteSegment(segPtr, full) 
a580 1
    Boolean	full;		/* TRUE if the segment is full. */
d583 2
a584 2
    int element, offset;
    LfsDiskAddr newDiskAddr, diskAddress;
d586 14
a599 7
    Boolean	segEmpty;
    int		newStartBlockOffset;
#ifdef SUN4HACK
    char	*buffer;
    static char	*dmaBuffer = (char *) NIL; 
    if (dmaBuffer == (char *) NIL) {
	dmaBuffer = malloc((int)LfsSegSize(lfsPtr));
d601 2
a602 1
#endif
d604 3
d612 3
d616 1
a616 1
     * Update the size of the last summary block.
d618 52
a669 25
    segPtr->curSegSummaryPtr->size = segPtr->curSummaryPtr - 
					(char *) segPtr->curSegSummaryPtr;

    newStartBlockOffset = -1;
    segEmpty = FALSE;
    if (!full) {
	if ((segPtr->numBlocks == 1) && 
	    (segPtr->curSegSummaryPtr->size == sizeof(LfsSegSummary))) {
	    /*
	     * The segment is totally empty.  We don't need to write
	     * this one yet.
	     */
	    LFS_STATS_INC(lfsPtr->stats.log.emptyWrites);
	    newStartBlockOffset = segPtr->startBlockOffset;
	    segEmpty = TRUE;
	} else if ((segPtr->curDataBlockLimit -  segPtr->curBlockOffset) > 
			       lfsPtr->superBlock.usageArray.wasteBlocks) { 
	    /*
	     * If this is considered to be a partial segment write add the
	     * summary block we needed.
	     */
	    AddNewSummaryBlock(segPtr);
	    newStartBlockOffset = segPtr->curBlockOffset-1;
	    LFS_STATS_INC(lfsPtr->stats.log.partialWrites);
	}
a670 21
    if (!segEmpty) { 
	LFS_STATS_ADD(lfsPtr->stats.log.wasteBlocks,
			    segPtr->curDataBlockLimit -  segPtr->curBlockOffset);
	LfsSegNumToDiskAddress(lfsPtr, segPtr->logRange.current, &diskAddress);
	offset = LfsSegSizeInBlocks(lfsPtr)	- segPtr->curBlockOffset;
#ifdef SUN4HACK
	buffer = dmaBuffer;
	for (element = segPtr->numElements-1; element >= 0; element--) {
	    int	bytes = 
		LfsBlocksToBytes(lfsPtr, 
			    segPtr->segElementPtr[element].lengthInBlocks);
	    bcopy(segPtr->segElementPtr[element].address, buffer, bytes);
	    buffer += bytes;
	}
	LfsDiskAddrPlusOffset(diskAddress,offset, &newDiskAddr);
	status = LfsWriteBytes(lfsPtr, newDiskAddr, buffer - dmaBuffer, dmaBuffer);
	if (lfsSegWriteDebug) { 
	    printf("LfsSeg wrote segment %d at %d - %d bytes.\n",
		    segPtr->logRange.current, LfsDiskAddrToOffset(newDiskAddr),
				    buffer - dmaBuffer);
	}
d672 19
a690 10
	for (element = segPtr->numElements-1; element >= 0; element--) {
	    LfsSegElement *elPtr = segPtr->segElementPtr[element];
	    LfsDiskAddrPlusOffset(diskAddress,offset, &newDiskAddr);
	    status = LfsWriteBytes(lfsPtr, diskAddress,
			    LfsBlocksToBytes(lfsPtr, elPtr->lengthInBlocks), 
				    elPtr->address);
	    if (status != SUCCESS) {
		break;
	    }
	    offset += elPtr->lengthInBlocks;
d692 34
a725 6
#endif
	LFS_STATS_ADD(lfsPtr->stats.log.blocksWritten, segPtr->numBlocks);
	LFS_STATS_ADD(lfsPtr->stats.log.bytesWritten, segPtr->activeBytes);
    } 
    LfsSetLogTail(lfsPtr, &segPtr->logRange, newStartBlockOffset, 
					segPtr->activeBytes);  
d730 1
a730 1
    return status;
d732 1
d1052 1
d1133 28
d1271 4
a1274 1
		status = WriteSegment(segPtr, full);
d1309 1
d1344 1
d1549 4
a1552 1
	status = WriteSegment(segPtr, full);
@


1.4
log
@Checkin before adding recovery
./
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/lfs/RCS/lfsSeg.c,v 1.3 90/05/30 10:30:59 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d20 4
a23 4
#include "lfs.h"
#include "lfsSeg.h"
#include "stdlib.h"
#include "sync.h"
d25 1
a25 3
/*
 * For lint.
 */
a26 4
#include "lfsFileLayout.h"
#include "lfsSegUsageInt.h"
#include "lfsDescMap.h"

a30 1
#define	LOCKPTR	&lfsPtr->lfsLock
d37 15
a51 5
static void SegmentWriteProc();
static void SegmentCleanProc();
static LfsSeg	*CreateSegmentToClean();
static LfsSeg   *GetSegStruct();
static void  AddSummaryBlock();
d58 1
a58 1
 *	Register with the segment module an interface to objects to the log.   
d82 1
a82 1
 * Lfs_StartWriteBack --
d84 1
a84 2
 *	Request that the segment manager start the segment write sequence
 *	for the specified file system.
d87 1
a87 1
 *	True is a backend backend was started.
d92 38
a129 19
 *----------------------------------------------------------------------
 */

Boolean
Lfs_StartWriteBack(cacheInfoPtr)
    Fscache_FileInfo *cacheInfoPtr;
{
    Lfs	 *lfsPtr;	/* File system with data to write. */
    Boolean	retVal;

    lfsPtr = (Lfs *) (cacheInfoPtr->backendPtr->clientData);

    LFS_STATS_INC(lfsPtr->stats.backend.startRequests);
    LOCK_MONITOR;
    if (lfsPtr->writeBackActive) {
	LFS_STATS_INC(lfsPtr->stats.backend.alreadyActive);
	lfsPtr->checkForMoreWork = TRUE;
	UNLOCK_MONITOR;
	return FALSE;
d131 2
a132 4
    lfsPtr->writeBackActive = TRUE;
    Proc_CallFunc(SegmentWriteProc, (ClientData) lfsPtr, 0);
    UNLOCK_MONITOR;
    return TRUE;
a133 1
}
d147 1
a147 1
 *	None.
a155 1
    LOCK_MONITOR;
d157 1
a157 1
    if (lfsPtr->cleanActive) {
a158 1
	UNLOCK_MONITOR;
d161 1
a161 1
    lfsPtr->cleanActive = TRUE;
a162 1
    UNLOCK_MONITOR;
d191 1
a191 2
    LfsSegElement *sumBufferPtr;
    int	 sumBytesLeft, blocksLeft, sumBlocks, sumBytes;
d214 1
a214 1
    AddSummaryBlock(segPtr);
d234 1
a234 1
int
d239 2
a240 1
    int	elementNumber, blockOffset, diskAddress;
d256 5
a260 3
    diskAddress = LfsSegNumToDiskAddress(segPtr->lfsPtr, 
				segPtr->logRange.current);
    return diskAddress + LfsSegSizeInBlocks(segPtr->lfsPtr) - blockOffset;
d315 1
a315 1
 *	None.
d323 8
a330 1
    int	memSize;
d332 1
a332 1
    memSize = LfsBytesToBlocks(lfsPtr,LfsSegSize(lfsPtr)) * 
d334 40
a373 3
    lfsPtr->segMemoryPtr = malloc(memSize + sizeof(LfsSeg) +LfsSegSize(lfsPtr));
    lfsPtr->segMemInUse = FALSE;
    lfsPtr->cleaningMemPtr = lfsPtr->segMemoryPtr + memSize + sizeof(LfsSeg);
d379 1
a379 1
 * AddSummaryBlock --
d387 1
a387 1
 *	None.
d392 1
a392 1
AddSummaryBlock(segPtr)
d411 4
d431 1
d446 5
a450 2
    int element, offset, diskAddress;
    ReturnStatus status;
d470 2
a471 1
    lfsPtr->activeBlockOffset = -1;
d480 2
a481 3
	    lfsPtr->activeLogRange = segPtr->logRange;
	    lfsPtr->activeBlockOffset = segPtr->startBlockOffset;
	    return SUCCESS;
d488 2
a489 3
	    AddSummaryBlock(segPtr);
	    lfsPtr->activeLogRange = segPtr->logRange;
	    lfsPtr->activeBlockOffset = segPtr->curBlockOffset-1;
d493 5
a497 4
    LFS_STATS_ADD(lfsPtr->stats.log.wasteBlocks,
			segPtr->curDataBlockLimit -  segPtr->curBlockOffset);
    diskAddress = LfsSegNumToDiskAddress(lfsPtr, segPtr->logRange.current);
    offset = LfsSegSizeInBlocks(lfsPtr)	- segPtr->curBlockOffset;
d499 15
a513 15
    buffer = dmaBuffer;
    for (element = segPtr->numElements-1; element >= 0; element--) {
	int	bytes = 
	    LfsBlocksToBytes(lfsPtr, 
			segPtr->segElementPtr[element].lengthInBlocks);
	bcopy(segPtr->segElementPtr[element].address, buffer, bytes);
	buffer += bytes;
    }
    status = LfsWriteBytes(lfsPtr,  diskAddress + offset,
			buffer - dmaBuffer, dmaBuffer);
    if (lfsSegWriteDebug) { 
	printf("LfsSeg wrote segment %d at %d - %d bytes.\n",
		segPtr->logRange.current, diskAddress + offset,
				buffer - dmaBuffer);
    }
d515 10
a524 7
    for (element = segPtr->numElements-1; element >= 0; element--) {
	LfsSegElement *elPtr = segPtr->segElementPtr[element];
	status = LfsWriteBytes(lfsPtr, diskAddress + offset, 
			LfsBlocksToBytes(lfsPtr, elPtr->lengthInBlocks), 
				elPtr->address);
	if (status != SUCCESS) {
	    break;
a525 2
	offset += elPtr->lengthInBlocks;
    }
d527 9
a535 3
    LFS_STATS_ADD(lfsPtr->stats.log.blocksWritten, segPtr->numBlocks);
    LFS_STATS_ADD(lfsPtr->stats.log.bytesWritten, segPtr->activeBytes);
    LfsSetSegUsage(lfsPtr, segPtr->logRange.current, segPtr->activeBytes);
d565 2
d568 1
a568 2
     * See if we current have a current segment that is not full that we 
     * can use. Otherwise we get a clean segment.
d570 15
a584 15
    if (lfsPtr->activeBlockOffset == -1) { 
	startBlock = 0;
	do { 
	    LFS_STATS_INC(lfsPtr->stats.log.newSegments);
	    status = LfsGetCleanSeg(lfsPtr, &segLogRange, dontBlock);
	    if ((status == FS_WOULD_BLOCK) && !dontBlock) {
		LFS_STATS_INC(lfsPtr->stats.log.cleanSegWait);
		LfsWaitDomain(lfsPtr, &lfsPtr->cleanSegments);
		continue;
	    }
	    if (status != SUCCESS) {
		LfsError(lfsPtr, status, 
		   "Can't get clean segments to write for cleaning.\n");
	    }
	} while (status != SUCCESS);
d586 1
a586 3
	LFS_STATS_INC(lfsPtr->stats.log.useOldSegment);
	segLogRange = lfsPtr->activeLogRange;
	startBlock = lfsPtr->activeBlockOffset;
d588 1
a588 1
    segPtr = GetSegStruct(lfsPtr, &segLogRange, startBlock);
d647 4
a650 5
    if ((char *) segPtr == segPtr->lfsPtr->segMemoryPtr) {
	segPtr->lfsPtr->segMemInUse = FALSE;
	return;
    }
    free((char *) segPtr);
d671 1
a671 1
GetSegStruct(lfsPtr, segLogRangePtr, startBlockOffset)
d675 1
d677 1
a677 1
    char	*memPtr;
a678 6
    /*
     * Alloc an LfsSeg structure. Be sure to leave enought room for default 
     * size LfsSegElement.
     */
    if (lfsPtr->segMemInUse) {
	 int	 memSize;
d680 10
a689 6
	 memSize = LfsSegSizeInBlocks(lfsPtr) * 
					sizeof(LfsSegElement);
	 memPtr = malloc(memSize + sizeof(LfsSeg));
    } else {
	 lfsPtr->segMemInUse = TRUE;
	 memPtr = lfsPtr->segMemoryPtr;
d691 1
a691 4
    segPtr = (LfsSeg *) memPtr;
    segPtr->lfsPtr = lfsPtr;
    segPtr->segMemPtr = memPtr;
    segPtr->segElementPtr = (LfsSegElement *) (memPtr + sizeof(LfsSeg));
d734 3
a736 3
    int	moduleType, startOffset, size, numCacheBlocks, next;
    Boolean full = FALSE;
    char	*summaryPtr, *endSummaryBlockPtr;
d746 1
a746 1
    while(1) { 
d760 1
a760 1
		full = intPtr->clean(segPtr, &size, &numCacheBlocks, 
d763 1
a763 1
		full = LfsDescMapClean(segPtr, &size, &numCacheBlocks, 
d765 1
a765 1
		full = LfsSegUsageClean(segPtr, &size, &numCacheBlocks, 
d767 1
a767 1
		full = LfsFileLayoutClean(segPtr, &size, &numCacheBlocks, 
d792 3
d825 1
a825 1
   return full;
d854 1
a854 1
    int	moduleType, startOffset, size, numCacheBlocks;
d877 1
a877 2
	    full = intPtr->layout(segPtr, (type == SEG_CLEAN_OUT),
			clientDataPtr + moduleType);
d879 3
a881 6
	    full = LfsSegUsageLayout(segPtr, (type == SEG_CLEAN_OUT),
				clientDataPtr + moduleType);
	    full = LfsDescMapLayout(segPtr, (type == SEG_CLEAN_OUT),
				clientDataPtr + moduleType);
	    full = LfsFileLayoutProc(segPtr, (type == SEG_CLEAN_OUT),
				clientDataPtr + moduleType);
d927 1
a927 1
	  * If we didn't fill the segment in skip do the next module.
a940 16

/*
 *----------------------------------------------------------------------
 *
 * SegmentWriteProc --
 *
 *	Proc_CallFunc procedure for performing a segment writes.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
a941 41
/*ARGSUSED*/
static void
SegmentWriteProc(lfsPtr, callInfoPtr)
    register Lfs *lfsPtr;            /* File system with dirty blocks. */
    Proc_CallInfo *callInfoPtr;         /* Not used. */
{
    Boolean	full;
    LfsSeg	*segPtr;
    ClientData		clientDataArray[LFS_MAX_NUM_MODS];
    int			i;
    ReturnStatus	status;
again:
    full = TRUE;
    for (i = 0; i < LFS_MAX_NUM_MODS; i++) {
	clientDataArray[i] = (ClientData) NIL;
    }
    LfsLockDomain(lfsPtr);
    while (full) {
	segPtr = CreateSegmentToWrite(lfsPtr, FALSE);
	full = DoOutCallBacks(SEG_LAYOUT, segPtr, 0, (char *) NIL,
				(int *) NIL, clientDataArray);
	status = WriteSegment(segPtr, full);
	if (status != SUCCESS) {
	    LfsError(lfsPtr, status, "Can't write segment to log\n");
	}
	RewindCurPtrs(segPtr);
	(void) DoInCallBacks(SEG_WRITEDONE, segPtr, 0,
				(char *) NIL, (int *) NIL, clientDataArray);
	DestorySegStruct(segPtr);
    }
    LfsUnLockDomain(lfsPtr, (Sync_Condition *) NIL);
    LOCK_MONITOR;
    if (lfsPtr->checkForMoreWork) {
	lfsPtr->checkForMoreWork = FALSE;
	UNLOCK_MONITOR;
	goto again;
    }
    lfsPtr->writeBackActive = FALSE;
    UNLOCK_MONITOR;
    FscacheBackendIdle(lfsPtr->domainPtr->backendPtr);
}
d961 2
a962 2
SegmentCleanProc(lfsPtr, callInfoPtr)
    register Lfs *lfsPtr;            /* File system to clean blocks in */
d966 1
d969 1
a969 1
    int		segNums[MAX_NUM_TO_CLEAN];
a972 1
    LfsSegLogRange	segLogRange;
d975 1
a975 1
    int			numWritten, numCleaned, totalSize, cleanBlocks;
d977 1
a977 1
    Time      		startTime, endTime;
d979 1
d984 4
a987 1
	Timer_GetTimeOfDay(&startTime, (int *) NIL, (Boolean *) NIL);
d989 1
a989 1
			    lfsPtr->cleanBlocks, MAX_NUM_TO_CLEAN, segNums);
d996 2
a997 2
	if (lfsSegWriteDebug) { 
	    printf("Cleaning started\n", numSegsToClean);
d1004 1
d1006 1
a1006 1
		    (totalCacheBlocksUsed < lfsPtr->cleanBlocks);i++) { 
d1008 1
a1008 1
	    segPtr = CreateSegmentToClean(lfsPtr, segNums[i]);
d1013 4
d1020 6
a1025 6
		segNums[i] = -1;
	    } else if (size == 0) {
		LFS_STATS_INC(lfsPtr->stats.cleaning.readEmpty);
		LfsMarkSegClean(lfsPtr, segNums[i]);
		segNums[i] = -1;
		LfsNotify(lfsPtr, &lfsPtr->cleanSegments);
a1029 1
	numCleaned = i;
d1037 1
a1038 1
	LfsLockDomain(lfsPtr);
d1043 2
a1044 1
		full = DoOutCallBacks(SEG_CLEAN_OUT, segPtr, 0, (char *) NIL,
d1052 1
a1052 1
		(void) DoInCallBacks(SEG_WRITEDONE, segPtr, 0,
d1063 28
d1092 1
a1092 14
	for (i = 0; i < numCleaned; i++) { 
	    if (segNums[i] != -1) { 
		LfsMarkSegClean(lfsPtr, segNums[i]);
	    }
	}
	LfsUnLockDomain(lfsPtr, &lfsPtr->cleanSegments);
	Timer_GetTimeOfDay(&endTime, (int *) NIL, (Boolean *) NIL);
	if (lfsSegWriteDebug) { 
	printf("Cleaned %d segments in %d segments- time (%d,%d) -  (%d,%d)\n",
	    numCleaned, numWritten, startTime.seconds, startTime.microseconds,
	    endTime.seconds, endTime.microseconds);
	}
    } while (numSegsToClean > 2);
    lfsPtr->cleanActive = FALSE;
d1097 1
a1097 1
CreateSegmentToClean(lfsPtr, segNumber)
d1100 1
a1102 1
    LfsSegElement *segElementPtr;
d1107 1
d1112 1
d1116 1
a1116 2

    segPtr = GetSegStruct(lfsPtr, &logRange, 0);
d1123 2
a1124 3
    status = LfsReadBytes(lfsPtr,
			(int)LfsSegNumToDiskAddress(lfsPtr, segNumber), 
				segSize, lfsPtr->cleaningMemPtr);
d1130 5
a1134 5
    lfsPtr->segCache.startDiskAddress = 
			LfsSegNumToDiskAddress(lfsPtr, segNumber);
    lfsPtr->segCache.endDiskAddress = 
			LfsSegNumToDiskAddress(lfsPtr, segNumber+1);
    lfsPtr->segCache.memPtr = lfsPtr->cleaningMemPtr;
d1138 1
a1138 1
		(lfsPtr->cleaningMemPtr + segSize - LfsBlockSize(lfsPtr));
d1227 1
a1227 1
     * XXX - Back out of error here but shutting down all module.
a1256 1
    LfsSegLogRange	segLogRange;
d1261 45
a1305 1
    *checkPointSizePtr = 0;
a1308 2
    LFS_STATS_INC(lfsPtr->stats.checkpoint.count);
    LfsLockDomain(lfsPtr);
d1310 3
a1312 1
	segPtr = CreateSegmentToWrite(lfsPtr, FALSE);
d1325 1
a1325 1
	(void) DoInCallBacks(SEG_WRITEDONE, segPtr, 0, (int *) NIL, (int *) NIL,
d1329 14
a1342 2
    lfsPtr->dirty = FALSE;
    LfsUnLockDomain(lfsPtr, (Sync_Condition *) NIL);
d1367 2
a1368 1
    free(lfsPtr->segMemoryPtr);
d1373 2
a1374 44
/*ARGSUSED*/
Boolean
LfsSegNullLayout(segPtr, cleaning)
    LfsSeg	*segPtr;
    Boolean 	cleaning;
{
	return FALSE;
}

LfsLockDomain(lfsPtr)
    Lfs	*lfsPtr;
{
    LOCK_MONITOR;
    LFS_STATS_INC(lfsPtr->stats.log.locks);
    while (lfsPtr->locked) {
	LFS_STATS_INC(lfsPtr->stats.log.lockWaits);
	Sync_Wait(&lfsPtr->lfsUnlock, FALSE);
    }
    lfsPtr->locked = TRUE;
    UNLOCK_MONITOR;
}
LfsUnLockDomain(lfsPtr, condPtr)
    Lfs	*lfsPtr;
	    Sync_Condition *condPtr;
{
    LOCK_MONITOR;
    lfsPtr->locked = FALSE;
    Sync_Broadcast(&lfsPtr->lfsUnlock);
    if (condPtr != (Sync_Condition *) NIL) {
	Sync_Broadcast(condPtr);
    }
    UNLOCK_MONITOR;
}

LfsNotify(lfsPtr, condPtr)
    Lfs	*lfsPtr;
	    Sync_Condition *condPtr;
{
    LOCK_MONITOR;
    Sync_Broadcast(condPtr);
    UNLOCK_MONITOR;
}

LfsWaitDomain(lfsPtr, condPtr)
a1375 1
    Sync_Condition *condPtr;
d1378 2
a1379 5
    lfsPtr->locked = FALSE;
    Sync_Broadcast(&lfsPtr->lfsUnlock);
    Sync_Wait(condPtr, FALSE);
    while (lfsPtr->locked) {
	Sync_Wait(&lfsPtr->lfsUnlock, FALSE);
a1380 1
    lfsPtr->locked = TRUE;
@


1.3
log
@Check in with no small writes.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/lfs/RCS/lfsSeg.c,v 1.2 90/05/25 15:33:09 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d35 1
a45 1
static ReturnStatus PushSegmentToLog();
d47 2
a48 1

d101 2
d105 1
d139 1
d141 1
d156 2
a157 1
 *	specified number of blocks and summary bytes.
a163 1
 *	May allocate more space for the summary bytes.
d169 1
a169 1
LfsSegSlowGrowSummary(segPtr, dataBlocksNeeded, sumBytesNeeded)
d173 1
a173 1

d176 2
a177 1
    int	 sumBytesLeft, blocksLeft, sumBlocks, sumBytesGrow;
a187 1
    lfsPtr = segPtr->lfsPtr;
d189 2
a190 1
     * Check to see if there is enought room to grow summary.
d192 2
a193 4
    sumBytesGrow = sumBytesNeeded - sumBytesLeft;
    sumBlocks = (sumBytesGrow <= 0) ? 0 : 
			LfsBytesToBlocks(lfsPtr, sumBytesGrow);
    if ((blocksLeft - sumBlocks) < dataBlocksNeeded) {
d196 1
d198 1
a198 1
     * Grow summary region.
d200 1
a200 4
    segPtr->curDataBlockLimit -= sumBlocks;
    segPtr->curSummaryLimitPtr += LfsBlocksToBytes(lfsPtr, sumBlocks);
    segPtr->summaryLimitPtr += LfsBlocksToBytes(lfsPtr, sumBlocks);

d225 1
a225 2
    int	elementNumber;
     int blockOffset;
d233 1
a233 1
	blockOffset = segPtr->curBlockOffset - segElementPtr->lengthInBlocks;
d236 2
a237 2
	blockOffset = 0;
	for (i = 0; i < elementNumber; i++) {
d241 3
a243 2
    return LfsSegNumToDiskAddress(segPtr->lfsPtr, segPtr->logRange.current) +
				blockOffset;
d267 1
a267 2
    char   *bufferPtr;	  /* Buffer to add. May be NIL if memory is to be
			   * allocated. */
a281 6

    if (bufferPtr == (char *)NIL) {
	elementPtr->address = segPtr->segMemPtr + 
		(segPtr->lfsPtr->usageArray.params.segmentSize 
		 - LfsBlocksToBytes(segPtr->lfsPtr, segPtr->curBlockOffset));
    }
d283 1
a283 1
    segPtr->numDataBlocks += blocks;
d286 17
a302 1

d306 1
a306 1
    int	elementSize, segmentSize;
d308 1
a308 2
    segmentSize = lfsPtr->usageArray.params.segmentSize;
    elementSize = LfsBytesToBlocks(lfsPtr,segmentSize) * 
d310 1
a310 2
    lfsPtr->segMemoryPtr = 
	    malloc(sizeof(LfsSeg) + elementSize + segmentSize);
d312 149
d466 1
a466 1
 * CreateEmptySegment --
d472 1
a472 1
 *	A pointer to a lfsPtr.
a478 1

d480 1
a480 1
CreateEmptySegment(lfsPtr, logRangePtr) 
d482 1
a482 1
    LfsSegLogRange *logRangePtr;/* Segments describing this range of the log. */
d485 3
a487 4
    int		segmentSize;
     char	*memPtr;

     segmentSize = lfsPtr->usageArray.params.segmentSize;
d490 2
a491 2
     * Alloc an LfsSeg structure. Be sure to leave enought room for default 
     * size LfsSegElement.
d493 15
a507 6
    if (lfsPtr->segMemInUse) {
	 int	 elementSize;

	 elementSize = LfsBytesToBlocks(lfsPtr,segmentSize) * 
					sizeof(LfsSegElement);
	 memPtr = malloc(sizeof(LfsSeg) + elementSize + segmentSize);
d509 3
a511 2
	 lfsPtr->segMemInUse = TRUE;
	 memPtr = lfsPtr->segMemoryPtr;
d513 1
a513 24
     segPtr = (LfsSeg *) memPtr;
     segPtr->lfsPtr = lfsPtr;
     segPtr->segMemPtr = memPtr + sizeof(LfsSeg);
     segPtr->segElementPtr = (LfsSegElement *)  
			    (memPtr + sizeof(LfsSeg) + segmentSize);
     segPtr->summaryPtr = segPtr->segMemPtr;
    /*
     * Fill in the segment descriptor used during the write. The segment
     * starts with the one summary block and the data section empty.
     */
    segPtr->logRange = *logRangePtr;
    segPtr->numElements = 0;
    segPtr->numDataBlocks = 0;
    segPtr->summaryLimitPtr = segPtr->summaryPtr + LfsBlocksToBytes(lfsPtr, 1);

    segPtr->activeBytes = 0;
    segPtr->curSummaryHdrPtr = (LfsSegSummaryHdr *) NIL;
    segPtr->curElement = -1;
    segPtr->curBlockOffset = 0;
    segPtr->curDataBlockLimit = LfsBytesToBlocks(lfsPtr,segmentSize)-1;
    segPtr->curSummaryPtr = segPtr->summaryPtr;
    segPtr->curSummaryLimitPtr = segPtr->summaryLimitPtr - 
					sizeof(LfsSegSummary);

d516 19
a534 2

InitFullSegment(segPtr)
d537 7
a543 3
    segPtr->curSummaryHdrPtr = (LfsSegSummaryHdr *) segPtr->summaryPtr;
    segPtr->curElement = 0;
    segPtr->curBlockOffset = 0;
d554 1
a554 1
 * DestorySegment --
d568 1
a568 1
DestorySegment(segPtr)
d583 60
a642 1
 * DoWriteCallBacks --
d644 1
a644 1
 *	Perform the call backs done to the segment modules.
d655 1
a655 2
DoWriteCallBacks(type, segPtr, flags, checkPointPtr, sizePtr,
		numCacheBlocksPtr, clientDataPtr) 
a658 1
    char	*checkPointPtr; /* Checkpoint buffer. */
d664 1
a664 1
    int	moduleType, startOffset, size, numCacheBlocks;
d666 2
a667 2
    Boolean segIn;
    char	*summaryPtr, *endSummaryPtr;
d670 114
a783 6
     * If we're doing a pass over an existing segment such as during a
     * cleaning IN phase or a WRITE_DONE callback we initialize the 
     * moduleType from the summary region. Otherwise start at module zero.
     */
    segIn = ((type == SEG_CLEAN_IN) || (type == SEG_WRITEDONE));
    moduleType = segIn ? segPtr->curSummaryHdrPtr->moduleType : 0;
d785 2
a786 1
    while(moduleType < LFS_MAX_NUM_MODS) {
d788 9
a796 13
	if (!segIn) { 
	    /*
	     * If we filling in a segment be sure that there is an enought
	     * room for the LfsSegSummaryHdr.
	     */
	    summaryPtr = LfsSegGrowSummary(segPtr, 1,sizeof(LfsSegSummaryHdr));
	    if (summaryPtr == (char *) NIL) {
		full = TRUE;
		break;
	    }
	    segPtr->curSummaryHdrPtr = (LfsSegSummaryHdr *)  summaryPtr;
	    LfsSegSetSummaryPtr(segPtr, summaryPtr + sizeof(LfsSegSummaryHdr));
	    startOffset = segPtr->curBlockOffset;
d798 3
a814 16
	case SEG_CLEAN_IN:
	    size = 0;
	    numCacheBlocks = 0;
	    full = intPtr->clean(segPtr, &size, &numCacheBlocks, 
			clientDataPtr + moduleType);
#ifdef lint
	    full = LfsDescMapClean(segPtr, &size, &numCacheBlocks, 
			clientDataPtr + moduleType);
	    full = LfsSegUsageClean(segPtr, &size, &numCacheBlocks, 
			clientDataPtr + moduleType);
	    full = LfsFileLayoutClean(segPtr, &size, &numCacheBlocks, 
			clientDataPtr + moduleType);
#endif /* lint */
	    *sizePtr += size;
	    *numCacheBlocksPtr += numCacheBlocks;
	    break;
a838 9
	case SEG_WRITEDONE: {
	    intPtr->writeDone(segPtr, flags, clientDataPtr + moduleType);
#ifdef lint
	    LfsDescMapWriteDone(segPtr, flags,  clientDataPtr + moduleType);
	    LfsSegUsageWriteDone(segPtr, flags, clientDataPtr + moduleType);
	    LfsFileLayoutWriteDone(segPtr, flags, clientDataPtr + moduleType);
#endif /* lint */
	    break;
	 }
d846 16
a861 26
	 if (!segIn) { 
	     endSummaryPtr = LfsSegGetSummaryPtr(segPtr); 
	     if ((startOffset != segPtr->curBlockOffset) ||
		 ((summaryPtr + sizeof(LfsSegSummaryHdr)) != endSummaryPtr)) {
		segPtr->curSummaryHdrPtr->moduleType = moduleType;
		segPtr->curSummaryHdrPtr->lengthInBytes = endSummaryPtr - 
				(char *) summaryPtr;
		segPtr->curSummaryHdrPtr->numDataBlocks =  
				segPtr->curBlockOffset - startOffset;
	     } else {
		 LfsSegSetSummaryPtr(segPtr, summaryPtr);
	     }
	}
	if (full) {
	    break;
	}
	/*
	 * Step to the next moduleType.
	 */
	if (segIn) { 
	    segPtr->curSummaryHdrPtr = (LfsSegSummaryHdr *)
				((char *)(segPtr->curSummaryHdrPtr) + 
				segPtr->curSummaryHdrPtr->lengthInBytes);
	    if (((char *)segPtr->curSummaryHdrPtr >= 
			segPtr->summaryLimitPtr) ||
		(segPtr->curSummaryHdrPtr->lengthInBytes == 0)) {
d864 1
a864 6
	    moduleType = segPtr->curSummaryHdrPtr->moduleType;
	    segPtr->curSummaryLimitPtr = 
				((char *)(segPtr->curSummaryHdrPtr) + 
				segPtr->curSummaryHdrPtr->lengthInBytes);
	    segPtr->curSummaryPtr = (char *) (segPtr->curSummaryHdrPtr + 1);
	} else {
d866 2
a867 2
	}
    }
a870 24
FillInSummaryHdr(segPtr)
    LfsSeg	*segPtr;
{
    int	extraBytes;
    LfsSegSummary  *segSummaryPtr;
    char	    *endSummaryPtr;
    /*
     * Tack on the LfsSegSummary structure at the end of the last summary
     * block.
     */
    segSummaryPtr = (LfsSegSummary *) (segPtr->curSummaryLimitPtr);
    endSummaryPtr = LfsSegGetSummaryPtr(segPtr); 
    extraBytes = ((char *) segSummaryPtr) - endSummaryPtr;
    if (extraBytes < 0) {
	panic("Bad LfsSeg in DoWriteCallBacks\n");
    }
    bzero(endSummaryPtr, extraBytes);
    segSummaryPtr->magic = LFS_SEG_SUMMARY_MAGIC;
    segSummaryPtr->timestamp = LfsGetCurrentTimestamp(segPtr->lfsPtr);
    segSummaryPtr->prevSeg = segPtr->logRange.prevSeg;
    segSummaryPtr->nextSeg = segPtr->logRange.nextSeg;
    segSummaryPtr->size = ((char *) (segSummaryPtr+1)) -  segPtr->summaryPtr;

}
a896 1
    LfsSegLogRange	segLogRange;
d907 4
a910 5
	status = LfsGetCleanSeg(lfsPtr, &segLogRange, FALSE);
	if (status == FS_WOULD_BLOCK) {
	    LfsWaitDomain(lfsPtr, &lfsPtr->cleanSegments);
	    continue;
	}
d912 1
a912 17
	    LfsError(lfsPtr, status, "Can't get clean segments to write\n");
	}
	segPtr = CreateEmptySegment(lfsPtr, &segLogRange);
	full = DoWriteCallBacks(SEG_LAYOUT, segPtr, 0, (char *) NIL,
				(int *) NIL, (int *) NIL, clientDataArray);
	if ((segPtr->numDataBlocks > 0) ||
	    (segPtr->curSummaryPtr != segPtr->summaryPtr)) { 
	    status = PushSegmentToLog(segPtr);
	    if (status != SUCCESS) {
		LfsError(lfsPtr, status, "Can't write segment to log\n");
	    }
	    InitFullSegment(segPtr);
	    (void) DoWriteCallBacks(SEG_WRITEDONE, segPtr, 0,
				(char *) NIL, (int *) NIL,  (int *) NIL,
				clientDataArray);
	} else {
	    LfsReturnUnusedSeg(lfsPtr, &segLogRange);
d914 4
a917 1
	DestorySegment(segPtr);
d957 1
a957 1
    int		i, numCacheBlocksUsed;
d974 1
a974 1
    
d978 5
a982 1
	printf("Cleaning started\n", numSegsToClean);
d987 1
a987 1
	numCacheBlocksUsed = 0;
d989 1
a989 1
		    (numCacheBlocksUsed < lfsPtr->cleanBlocks);i++) { 
d993 2
a994 2
	    error = DoWriteCallBacks(SEG_CLEAN_IN, segPtr, 0, (char *) NIL, 
				&size,
d996 1
a996 1
	    DestorySegment(segPtr);
d998 5
d1004 1
d1007 1
d1010 4
d1022 5
a1026 1
		status = LfsGetCleanSeg(lfsPtr, &segLogRange, TRUE);
d1028 1
a1028 1
		    LfsError(lfsPtr, status, "Can't get clean segments to write\n");
d1030 3
a1032 4
		segPtr = CreateEmptySegment(lfsPtr, &segLogRange);
		full = DoWriteCallBacks(SEG_CLEAN_OUT, segPtr, 0, (char *) NIL,
				(int *) NIL, (int *) NIL, clientDataArray);
    
d1034 6
a1039 10
		status = PushSegmentToLog(segPtr);
		if (status != SUCCESS) {
		    LfsError(lfsPtr, status, "Can't write segment to log\n");
		}
		InitFullSegment(segPtr);
		(void) DoWriteCallBacks(SEG_WRITEDONE, segPtr, 0,
					(char *) NIL, 
					(int *) NIL, (int *) NIL, clientDataArray);
    
		DestorySegment(segPtr);
d1042 1
a1042 2
    
    
d1045 1
a1045 1
		LfsSetSegUsage(lfsPtr, segNums[i], 0);
d1050 1
d1054 1
a1058 62
#define	SUN4HACK
static ReturnStatus
PushSegmentToLog(segPtr)
    LfsSeg	*segPtr;	/* Segment to write to log. */
{
    Lfs	*lfsPtr = segPtr->lfsPtr;
    int	 diskAddress, offset;
    int	 sumBlocks, blockPerSeg, element, sumBytes;
    ReturnStatus status;
#ifdef SUN4HACK
    char	*buffer;
    static char	*dmaBuffer = (char *) NIL; 
    if (dmaBuffer == (char *) NIL) {
	dmaBuffer = malloc((int)lfsPtr->usageArray.params.segmentSize);
    }
#endif
    FillInSummaryHdr(segPtr);
    diskAddress = LfsSegNumToDiskAddress(lfsPtr, segPtr->logRange.current);
    blockPerSeg = LfsBytesToBlocks(lfsPtr, 
			lfsPtr->usageArray.params.segmentSize);
    sumBytes = segPtr->summaryLimitPtr - segPtr->summaryPtr;
    sumBlocks = LfsBytesToBlocks(lfsPtr,sumBytes);


#ifdef SUN4HACK
    offset = 0;
    buffer = dmaBuffer;
    for (element = 0; element < segPtr->numElements; element++) {
	int	bytes = 
	LfsBlocksToBytes(lfsPtr, 
			segPtr->segElementPtr[element].lengthInBlocks);
	bcopy(segPtr->segElementPtr[element].address, buffer, bytes);
	buffer += bytes;
	offset += bytes;
    }
    buffer = dmaBuffer + lfsPtr->usageArray.params.segmentSize - sumBytes;
    bcopy(segPtr->summaryPtr, buffer, sumBytes);
    status = LfsWriteBytes(lfsPtr,  diskAddress, 
			(int)lfsPtr->usageArray.params.segmentSize,
			dmaBuffer);
#else
    offset = 0;
    for (element = 0; element < segPtr->numElements; element++) {
	status = LfsWriteBytes(lfsPtr, diskAddress + offset, 
		LfsBlocksToBytes(lfsPtr, 
			segPtr->segElementPtr[element].lengthInBlocks),
		segPtr->segElementPtr[element].address);
	offset += segPtr->segElementPtr[element].lengthInBlocks;
    }

    status = LfsWriteBytes(lfsPtr, diskAddress + blockPerSeg - sumBlocks,
			LfsBlocksToBytes(lfsPtr, sumBlocks), 
			segPtr->summaryPtr);
#endif
    if (lfsSegWriteDebug) { 
    printf("LfsSeg wrote segment %d - %d data blocks %d summary blocks\n",
		segPtr->logRange.current, offset, sumBlocks);
    }
    LfsSetSegUsage(lfsPtr, segPtr->logRange.current, segPtr->activeBytes);
    return status;

}
a1064 1
    LfsSegLogRange	segLogRange;
d1066 1
a1066 1
    LfsSegSummary	*segSummaryPtr;
d1069 16
d1086 3
a1088 7
    segLogRange.prevSeg = -1;
    segLogRange.current = segNumber;
    segLogRange.nextSeg = -1;
    segSize = lfsPtr->usageArray.params.segmentSize;
    segPtr = CreateEmptySegment(lfsPtr, &segLogRange);
    status = LfsReadBytes(lfsPtr, LfsSegNumToDiskAddress(lfsPtr, segNumber), 
				segSize, segPtr->segMemPtr);
d1090 2
a1091 2
	LfsError(lfsPtr, status, 
			"CreateSegmentToClean: can't read segment to clean.\n");
d1093 16
a1108 10
    segSummaryPtr = (LfsSegSummary *)
			(segPtr->segMemPtr + segSize - sizeof(LfsSegSummary));
    segPtr->summaryPtr = (segPtr->segMemPtr + segSize - segSummaryPtr->size);
    segPtr->summaryLimitPtr = (segPtr->segMemPtr + segSize);
    segPtr->numDataBlocks = LfsBytesToBlocks(lfsPtr, segSize) -
				LfsBytesToBlocks(lfsPtr, segSummaryPtr->size);

    segPtr->segElementPtr[0].lengthInBlocks = 0;
    segPtr->segElementPtr[0].address = segPtr->segMemPtr;
    segPtr->segElementPtr[0].clientData = (ClientData) NIL;
d1110 9
a1118 1
    InitFullSegment(segPtr);
d1150 2
d1230 1
d1233 9
a1241 5
	status = LfsGetCleanSeg(lfsPtr, &segLogRange, FALSE);
	if (status == FS_WOULD_BLOCK) {
	    LfsWaitDomain(lfsPtr, &lfsPtr->cleanSegments);
	    continue;
	}
d1243 1
a1243 1
	    LfsError(lfsPtr, status, "Can't get clean segments to write\n");
d1245 2
a1246 13
	segPtr = CreateEmptySegment(lfsPtr, &segLogRange);
	full = DoWriteCallBacks(SEG_CHECKPOINT, segPtr, flags,
			    checkPointPtr, checkPointSizePtr, (int *) NIL,
			    clientDataArray);
	if ((segPtr->numDataBlocks > 0) ||
	    (segPtr->curSummaryPtr != segPtr->summaryPtr)) { 
	    status = PushSegmentToLog(segPtr);
	    if (status != SUCCESS) {
		LfsError(lfsPtr, status, "Can't write segment to log\n");
	    }
	    InitFullSegment(segPtr);
	    (void) DoWriteCallBacks(SEG_WRITEDONE,  segPtr, flags,
				    (char *) NIL, (int *) NIL, (int *) NIL,
d1248 1
a1248 4
	} else {
	    LfsReturnUnusedSeg(lfsPtr, &segLogRange);
	}
	DestorySegment(segPtr);
d1255 26
d1294 1
d1296 1
d1312 9
@


1.2
log
@*** empty log message ***
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs.mendel/RCS/lfsSeg.c,v 1.1 90/01/16 17:12:27 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d187 1
a187 2
		 LfsBytesToBlocks(lfsPtr, 
			(sumBytesGrow + (lfsPtr->superBlock.hdr.blockSize-1)));
d361 1
a361 1

d713 1
d716 28
a743 45

    for (i = 0; i < LFS_MAX_NUM_MODS; i++) {
	clientDataArray[i] = (ClientData) NIL;
    }
    Timer_GetTimeOfDay(&startTime, (int *) NIL, (Boolean *) NIL);
    numSegsToClean = LfsGetSegsToClean(lfsPtr, 
			lfsPtr->cleanBlocks, MAX_NUM_TO_CLEAN, segNums);

    printf("Cleaning started\n", numSegsToClean);
    /*
     * Reading in segments to clean.
     */
    totalSize = 0;
    numCacheBlocksUsed = 0;
    for (i = 0; (i < numSegsToClean) && 
		(numCacheBlocksUsed < lfsPtr->cleanBlocks);i++) { 
	int size;
	segPtr = CreateSegmentToClean(lfsPtr, segNums[i]);
	size = 0;
	(void) DoWriteCallBacks(SEG_CLEAN_IN, segPtr, 0, (char *) NIL, &size,
			&numCacheBlocksUsed, clientDataArray);
	DestorySegment(segPtr);
	totalSize += size;
    }
    numCleaned = i;
    /*
     * Write out segments cleaned.
     */
    numWritten = 0;
    LfsLockDomain(lfsPtr);
    if (totalSize > 0) { 
	full = TRUE;
	while (full) {
	    status = LfsGetCleanSeg(lfsPtr, &segLogRange, TRUE);
	    if (status != SUCCESS) {
		LfsError(lfsPtr, status, "Can't get clean segments to write\n");
	    }
	    segPtr = CreateEmptySegment(lfsPtr, &segLogRange);
	    full = DoWriteCallBacks(SEG_CLEAN_OUT, segPtr, 0, (char *) NIL,
			    (int *) NIL, (int *) NIL, clientDataArray);

	    numWritten++;
	    status = PushSegmentToLog(segPtr);
	    if (status != SUCCESS) {
		LfsError(lfsPtr, status, "Can't write segment to log\n");
d745 1
a745 6
	    InitFullSegment(segPtr);
	    (void) DoWriteCallBacks(SEG_WRITEDONE, segPtr, 0,
				    (char *) NIL, 
				    (int *) NIL, (int *) NIL, clientDataArray);

	    DestorySegment(segPtr);
d747 43
a789 6
    }


    for (i = 0; i < numCleaned; i++) { 
	LfsSetSegUsage(lfsPtr, segNums[i], 0);
    }
a790 5
    LfsUnLockDomain(lfsPtr, &lfsPtr->cleanSegments);
    Timer_GetTimeOfDay(&endTime, (int *) NIL, (Boolean *) NIL);
    printf("Cleaned %d segments in %d segments- time (%d,%d) -  (%d,%d)\n",
	numCleaned, numWritten, startTime.seconds, startTime.microseconds,
	endTime.seconds, endTime.microseconds);
d851 1
a851 2
    LfsSetSegUsage(lfsPtr, segPtr->logRange.current, 
		    LfsBlocksToBytes(lfsPtr, segPtr->numDataBlocks) + sumBytes);
@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/lib/forms/RCS/proto.c,v 1.2 89/01/07 04:12:18 rab Exp $ SPRITE (Berkeley)";
d25 8
d35 2
a36 1
enum CallBackType { SEG_LAYOUT, SEG_CLEAN, SEG_CHECKPOINT, SEG_WRITEDONE};
d38 3
d78 1
a78 1
 * LfsSegWriteStart --
d84 1
a84 1
 *	None.
d92 4
a95 2
void
LfsSegWriteStart(lfsPtr)
d97 8
a104 3
{
    if (!lfsPtr->writeActive) {
	Proc_CallFunc(SegmentWriteProc, (ClientData) lfsPtr, 0);
d106 5
d134 4
a137 2
    if (!lfsPtr->writeActive) {
	Proc_CallFunc(SegmentCleanProc, (ClientData) lfsPtr, 0);
d139 3
d218 1
a218 1
unsigned int
d224 1
a224 1
    unsigned int blockOffset;
a269 1
    unsigned int startOffset;
a274 1
    startOffset = segPtr->curBlockOffset;
d432 4
a435 6
DoWriteCallBacks(type, outSegPtr, inSegPtr, flags, checkPointPtr,
					checkPointSizePtr) 

    enum CallBackType type;	/* Type of segment write. */
    LfsSeg	*outSegPtr;	/* Segment to fill in. */
    LfsSeg	*inSegPtr; 	/* Segment to clean for cleaning operations. */
d438 3
a440 2
    int	    *checkPointSizePtr; /* Size of checkpoint buffer for checkpoint 
				 * operations. */
d443 1
a443 2
    LfsSegSummary  *segSummaryPtr;
    int	moduleType, startOffset;
d445 1
d449 3
a451 2
     * If we're doing a cleaning pass initialize the moduleType from the
     * summary region. Otherwise start at module zero.
d453 3
a455 5
    if (inSegPtr != (LfsSeg *) NIL) {
	moduleType = inSegPtr->curSummaryHdrPtr->moduleType;
    } else {
	moduleType = 0;
    }
d457 2
a458 1
	if (outSegPtr != (LfsSeg *) NIL) { 
d463 1
a463 1
	    summaryPtr = LfsSegGrowSummary(outSegPtr, 1,sizeof(LfsSegSummaryHdr));
d468 3
a470 4
	    outSegPtr->curSummaryHdrPtr = (LfsSegSummaryHdr *)  summaryPtr;
	    LfsSegSetSummaryPtr(outSegPtr,
					summaryPtr + sizeof(LfsSegSummaryHdr));
	    startOffset = outSegPtr->curBlockOffset;
d473 1
d475 10
a484 1
	    full = lfsSegIoInterfacePtrs[moduleType]->layout(outSegPtr);
d486 15
a500 2
	case SEG_CLEAN:
	    full = lfsSegIoInterfacePtrs[moduleType]->clean(inSegPtr,outSegPtr);
d507 11
a517 2
	    full = lfsSegIoInterfacePtrs[moduleType]->
		checkpoint(outSegPtr, flags, (char *) (regionPtr + 1), &size);
d521 1
a521 1
		*checkPointSizePtr += regionPtr->size;
d527 6
a532 1
	    lfsSegIoInterfacePtrs[moduleType]->writeDone(inSegPtr, flags);
d539 1
a539 1
	  * If the callback added data to the outSeg fill in the summary 
d542 3
a544 3
	 if (outSegPtr != (LfsSeg *) NIL) { 
	     endSummaryPtr = LfsSegGetSummaryPtr(outSegPtr); 
	     if ((startOffset != outSegPtr->curBlockOffset) ||
d546 2
a547 2
		outSegPtr->curSummaryHdrPtr->moduleType = moduleType;
		outSegPtr->curSummaryHdrPtr->lengthInBytes = endSummaryPtr - 
d549 2
a550 2
		outSegPtr->curSummaryHdrPtr->numDataBlocks =  
				outSegPtr->curBlockOffset - startOffset;
d552 1
a552 1
		 LfsSegSetSummaryPtr(outSegPtr, summaryPtr);
d561 7
a567 7
	if (inSegPtr != (LfsSeg *) NIL) { 
	    inSegPtr->curSummaryHdrPtr = (LfsSegSummaryHdr *)
				((char *)(inSegPtr->curSummaryHdrPtr) + 
				inSegPtr->curSummaryHdrPtr->lengthInBytes);
	    if (((char *)inSegPtr->curSummaryHdrPtr >= 
			inSegPtr->summaryLimitPtr) ||
		(inSegPtr->curSummaryHdrPtr->lengthInBytes == 0)) {
d570 5
a574 6
	    moduleType = inSegPtr->curSummaryHdrPtr->moduleType;
	    inSegPtr->curSummaryLimitPtr = 
				((char *)(inSegPtr->curSummaryHdrPtr) + 
				inSegPtr->curSummaryHdrPtr->lengthInBytes);
	    inSegPtr->curSummaryPtr = (char *) 
				(inSegPtr->curSummaryHdrPtr + 1);
d582 2
a583 2
FillInSummaryHdr(outSegPtr)
    LfsSeg	*outSegPtr;
a587 1
    Lfs	*lfsPtr = outSegPtr->lfsPtr;
d592 2
a593 2
    segSummaryPtr = (LfsSegSummary *) (outSegPtr->curSummaryLimitPtr);
    endSummaryPtr = LfsSegGetSummaryPtr(outSegPtr); 
d596 1
a596 1
	panic("Bad outSeg in DoWriteCallBacks\n");
d600 6
a605 7
    segSummaryPtr->timestamp = LfsGetCurrentTimestamp(outSegPtr->lfsPtr);
    segSummaryPtr->prevSeg = outSegPtr->logRange.prevSeg;
    segSummaryPtr->nextSeg = outSegPtr->logRange.nextSeg;
    segSummaryPtr->size = ((char *) (segSummaryPtr+1)) - 
				    outSegPtr->summaryPtr;

}
d624 1
a624 1
/* ARGSUSED */
d630 1
a630 1
    Boolean	full = TRUE;
d633 2
d636 5
a640 1

a641 1
    lfsPtr->writeActive = TRUE;
d643 5
a647 1
	status = LfsGetCleanSeg(lfsPtr, &segLogRange);
d652 14
a665 5
	full = DoWriteCallBacks(SEG_LAYOUT, segPtr, (LfsSeg *) NIL, 0,
			   (char *) NIL, (int *) NIL);
	status = PushSegmentToLog(segPtr);
	if (status != SUCCESS) {
	    LfsError(lfsPtr, status, "Can't write segment to log\n");
a666 3
	InitFullSegment(segPtr);
	(void) DoWriteCallBacks(SEG_WRITEDONE, (LfsSeg *) NIL, segPtr, 0,
				(char *) NIL, (int *) NIL);
d669 10
a678 2
    lfsPtr->writeActive = FALSE;
    LfsUnLockDomain(lfsPtr);
d707 2
a708 2
    int		segNumber, i;
    LfsSeg	*segToCleanPtr, *segPtr;
d712 2
a713 1
    int			numWritten = 0;
d717 3
a719 2
    LfsLockDomain(lfsPtr);

d721 2
a722 3
#define TE
    lfsPtr->writeActive = TRUE;
    numSegsToClean = LfsGetSegsToClean(lfsPtr, MAX_NUM_TO_CLEAN, segNums);
d724 15
a738 4
    if (numSegsToClean == 0) {
	lfsPtr->writeActive = FALSE;
	LfsUnLockDomain(lfsPtr);
	return;
d740 16
a755 6
    status = LfsGetCleanSeg(lfsPtr, &segLogRange);
    if (status != SUCCESS) {
	LfsError(lfsPtr, status, 
		    "Can't get clean segments to write\n");
    }
    segPtr = CreateEmptySegment(lfsPtr, &segLogRange);
d757 9
a765 2
    for (i = 0; i < numSegsToClean; i++) { 
	segNumber = segNums[i];
d767 2
a768 23
	segToCleanPtr = CreateSegmentToClean(lfsPtr, segNumber);
	do {
	    full = DoWriteCallBacks(SEG_CLEAN, segPtr, segToCleanPtr, 0,
			   (char *) NIL, (int *) NIL);
	    if (full) {
		numWritten++;
		status = PushSegmentToLog(segPtr);
		if (status != SUCCESS) {
		    LfsError(lfsPtr, status, "Can't write segment to log\n");
		}
		InitFullSegment(segPtr);
		(void) DoWriteCallBacks(SEG_WRITEDONE, (LfsSeg *) NIL, segPtr,
					0, (char *) NIL, (int *) NIL);
		DestorySegment(segPtr);
		status = LfsGetCleanSeg(lfsPtr, &segLogRange);
		if (status != SUCCESS) {
		    LfsError(lfsPtr, status, 
				"Can't get clean segments to write\n");
		}
		segPtr = CreateEmptySegment(lfsPtr, &segLogRange);
	    }
	} while (full);
	DestorySegment(segToCleanPtr);
d770 1
a770 9
    numWritten++;
    status = PushSegmentToLog(segPtr);
    if (status != SUCCESS) {
	LfsError(lfsPtr, status, "Can't write segment to log\n");
    }
    InitFullSegment(segPtr);
    (void) DoWriteCallBacks(SEG_WRITEDONE, (LfsSeg *) NIL, segPtr,
			    0, (char *) NIL, (int *) NIL);
    DestorySegment(segPtr);
d772 1
a772 1
    for (i = 0; i < numSegsToClean; i++) { 
d775 2
d779 1
a779 1
	numSegsToClean, numWritten, startTime.seconds, startTime.microseconds,
a780 3

    lfsPtr->writeActive = FALSE;
    LfsUnLockDomain(lfsPtr);
d796 1
a796 1
	dmaBuffer = malloc(lfsPtr->usageArray.params.segmentSize);
d820 2
a821 2
    status = LfsWriteBytes(lfsPtr, diskAddress, 
			lfsPtr->usageArray.params.segmentSize,
d919 1
a919 1
				regionPtr->size - sizeof(*regionPtr),
d921 12
d935 5
d942 1
a942 1
	    LfsError(lfsPtr, status, "Can't attach module %d", moduleType);
d982 2
d987 3
a990 1
    lfsPtr->writeActive = TRUE;
d992 5
a996 1
	status = LfsGetCleanSeg(lfsPtr, &segLogRange);
d1001 15
a1015 5
	full = DoWriteCallBacks(SEG_CHECKPOINT, segPtr, (LfsSeg *) NIL, flags,
			    checkPointPtr, checkPointSizePtr);
	status = PushSegmentToLog(segPtr);
	if (status != SUCCESS) {
	    LfsError(lfsPtr, status, "Can't write segment to log\n");
a1016 3
	InitFullSegment(segPtr);
	(void) DoWriteCallBacks(SEG_WRITEDONE, (LfsSeg *) NIL, segPtr, flags,
				(char *) NIL, (int *) NIL);
a1018 1
    lfsPtr->writeActive = FALSE;
d1020 1
a1020 2

    LfsUnLockDomain(lfsPtr);
d1024 1
a1024 1

d1026 1
a1026 1
LfsSegNullLayout(segPtr)
d1028 1
a1032 5
static Sync_Condition lfsUnlock;
static Sync_Lock      lfsLock =   Sync_LockInitStatic("LfsLock");
#define	LOCKPTR	&lfsLock
static Boolean	locked = FALSE;

d1037 2
a1038 2
    while (locked) {
	Sync_Wait(&lfsUnlock, FALSE);
d1040 1
a1040 1
    locked = TRUE;
d1043 1
a1043 1
LfsUnLockDomain(lfsPtr)
d1045 1
d1048 5
a1052 2
    locked = FALSE;
    Sync_Broadcast(&lfsUnlock);
d1056 14
@
