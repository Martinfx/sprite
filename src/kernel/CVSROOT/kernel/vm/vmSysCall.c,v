head     9.23;
branch   ;
access   ;
symbols  ds3100:9.23 sun3:9.23 sun4nw:9.22 symm:9.22 spur:9.22 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.23
date     92.08.20.21.57.59;  author shirriff;  state Exp;
branches ;
next     9.22;

9.22
date     91.10.08.13.54.11;  author shirriff;  state Exp;
branches ;
next     9.21;

9.21
date     91.09.10.18.29.50;  author rab;  state Exp;
branches ;
next     9.20;

9.20
date     91.08.13.12.44.22;  author shirriff;  state Exp;
branches ;
next     9.19;

9.19
date     91.08.09.15.13.31;  author shirriff;  state Exp;
branches ;
next     9.18;

9.18
date     91.07.26.17.05.18;  author shirriff;  state Exp;
branches ;
next     9.17;

9.17
date     91.06.27.12.11.43;  author jhh;  state Exp;
branches ;
next     9.16;

9.16
date     91.04.09.18.40.23;  author mgbaker;  state Exp;
branches ;
next     9.15;

9.15
date     91.04.08.13.02.29;  author shirriff;  state Exp;
branches ;
next     9.14;

9.14
date     90.10.19.15.40.54;  author shirriff;  state Exp;
branches ;
next     9.13;

9.13
date     90.09.12.13.36.45;  author shirriff;  state Exp;
branches ;
next     9.12;

9.12
date     90.09.11.10.45.07;  author shirriff;  state Exp;
branches ;
next     9.11;

9.11
date     90.08.14.18.53.05;  author mgbaker;  state Exp;
branches ;
next     9.10;

9.10
date     90.07.30.11.44.03;  author shirriff;  state Exp;
branches ;
next     9.9;

9.9
date     90.06.27.11.14.48;  author shirriff;  state Exp;
branches ;
next     9.8;

9.8
date     90.05.13.23.25.51;  author shirriff;  state Exp;
branches ;
next     9.7;

9.7
date     90.03.01.12.34.03;  author brent;  state Exp;
branches ;
next     9.6;

9.6
date     89.11.27.14.42.27;  author shirriff;  state Exp;
branches ;
next     9.5;

9.5
date     89.11.07.14.46.06;  author shirriff;  state Exp;
branches ;
next     9.4;

9.4
date     89.10.30.18.01.35;  author shirriff;  state Exp;
branches ;
next     9.3;

9.3
date     89.10.23.09.11.23;  author brent;  state Exp;
branches ;
next     9.2;

9.2
date     89.10.22.23.22.55;  author shirriff;  state Exp;
branches ;
next     9.1;

9.1
date     89.09.18.17.31.06;  author shirriff;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.23.35;  author douglis;  state Stable;
branches ;
next     8.8;

8.8
date     89.09.07.14.25.22;  author shirriff;  state Exp;
branches ;
next     8.7;

8.7
date     89.07.14.13.02.58;  author nelson;  state Exp;
branches ;
next     8.6;

8.6
date     89.07.10.19.46.50;  author nelson;  state Exp;
branches ;
next     8.5;

8.5
date     89.05.23.11.28.36;  author douglis;  state Exp;
branches ;
next     8.4;

8.4
date     89.05.21.18.25.35;  author mgbaker;  state Exp;
branches ;
next     8.3;

8.3
date     89.05.18.16.48.10;  author brent;  state Exp;
branches ;
next     8.2;

8.2
date     88.12.29.14.58.49;  author mendel;  state Exp;
branches ;
next     8.1;

8.1
date     88.12.04.15.51.38;  author ouster;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.43.44;  author douglis;  state Stable;
branches ;
next     6.8;

6.8
date     88.10.28.18.20.19;  author mlgray;  state Exp;
branches ;
next     6.7;

6.7
date     88.09.26.12.02.53;  author nelson;  state Exp;
branches ;
next     6.6;

6.6
date     88.09.14.16.48.18;  author nelson;  state Exp;
branches ;
next     6.5;

6.5
date     88.08.30.22.22.17;  author nelson;  state Exp;
branches ;
next     6.4;

6.4
date     88.08.27.19.44.13;  author nelson;  state Exp;
branches ;
next     6.3;

6.3
date     88.08.24.19.38.51;  author nelson;  state Exp;
branches ;
next     6.2;

6.2
date     88.08.15.18.16.34;  author nelson;  state Exp;
branches ;
next     6.1;

6.1
date     88.08.11.19.28.48;  author nelson;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.30.41;  author brent;  state Stable;
branches ;
next     5.19;

5.19
date     88.07.29.11.28.57;  author nelson;  state Exp;
branches ;
next     5.18;

5.18
date     88.07.12.19.54.43;  author nelson;  state Exp;
branches ;
next     5.17;

5.17
date     88.06.22.16.12.36;  author nelson;  state Exp;
branches ;
next     5.16;

5.16
date     88.06.20.17.55.45;  author nelson;  state Exp;
branches ;
next     5.15;

5.15
date     88.05.05.18.03.28;  author nelson;  state Exp;
branches ;
next     5.14;

5.14
date     88.05.04.17.27.02;  author nelson;  state Exp;
branches ;
next     5.13;

5.13
date     88.03.08.14.25.26;  author douglis;  state Exp;
branches ;
next     5.12;

5.12
date     88.02.02.18.27.16;  author nelson;  state Exp;
branches ;
next     5.11;

5.11
date     88.01.08.15.54.26;  author nelson;  state Exp;
branches ;
next     5.10;

5.10
date     88.01.04.14.00.53;  author nelson;  state Exp;
branches ;
next     5.9;

5.9
date     87.12.31.11.09.46;  author nelson;  state Exp;
branches ;
next     5.8;

5.8
date     87.12.18.15.17.11;  author nelson;  state Exp;
branches ;
next     5.7;

5.7
date     87.12.17.18.46.41;  author nelson;  state Exp;
branches ;
next     5.6;

5.6
date     87.12.15.19.17.31;  author nelson;  state Exp;
branches ;
next     5.5;

5.5
date     87.12.15.18.24.46;  author nelson;  state Exp;
branches ;
next     5.4;

5.4
date     87.12.15.15.22.10;  author nelson;  state Exp;
branches ;
next     5.3;

5.3
date     87.12.11.13.30.01;  author nelson;  state Exp;
branches ;
next     5.2;

5.2
date     87.11.20.18.29.23;  author nelson;  state Exp;
branches ;
next     5.1;

5.1
date     87.10.22.14.51.25;  author nelson;  state Exp;
branches ;
next     5.0;

5.0
date     87.08.11.10.53.39;  author sprite;  state Exp;
branches ;
next     ;


desc
@@


9.23
log
@Changed Mprotect so if the specified region is too large, it will change
permissions on the valid subregion.  This change is so idraw will work in
compatibility mode.
@
text
@/*
 * vmSysCall.c -
 *
 * 	This file contains routines that handle virtual memory system
 *	calls.
 *
 * Copyright (C) 1985 Regents of the University of California
 * All rights reserved.
 */


#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/vm/vmSysCall.c,v 9.22 91/10/08 13:54:11 shirriff Exp $ SPRITE (Berkeley)";
#endif not lint

#include <sprite.h>
#include <vm.h>
#include <vmInt.h>
#include <lock.h>
#include <user/vm.h>
#include <sync.h>
#include <sys.h>
#include <stdlib.h>
#include <string.h>
#include <fs.h>
#include <fsio.h>
#include <sys/mman.h>
#include <stdio.h>
#include <bstring.h>

extern Vm_SharedSegTable sharedSegTable;
char	 *sprintf();

int vmShmDebug = 0;	/* Shared memory debugging flag. */

extern int   debugFsStubs; /* Unix compatibility debug flags. */
extern int   debugProcStubs;
extern int   debugSigStubs;
extern int   debugSysStubs;
extern int   debugTimerStubs;
extern int   debugVmStubs;

/*
 * Forward declaration.
 */
static ReturnStatus VmMunmapInt _ARGS_((Address startAddr, int length,
	int noError));

/*
 * VmVirtAddrParseUnlock calls VmVirtAddrParse and then unlocks
 * the heap page table if necessary, since VmVirtAddrParse may
 * lock it.
 */
#define VmVirtAddrParseUnlock(procPtr, startAddr, virtAddrPtr) \
    {VmVirtAddrParse(procPtr,startAddr, virtAddrPtr); \
    if ((virtAddrPtr)->flags & VM_HEAP_PT_IN_USE) \
	    { VmDecPTUserCount(procPtr->vmPtr->segPtrArray[VM_HEAP]); } }

/*
 * Test if an address is not page aligned.
 */
#define BADALIGN(addr) (((int)(addr))&(vm_PageSize-1))


/*
 *----------------------------------------------------------------------
 *
 * Vm_PageSize --
 *
 *	Return the hardware page size.
 *
 * Results:
 *	Status from copying the page size out to user space.
 *
 * Side effects:
 *	Copy page size out to user address space.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
Vm_PageSize(pageSizePtr)
    int	*pageSizePtr;
{
    int			pageSize = vm_PageSize;

    return(Vm_CopyOut(4, (Address) &pageSize, (Address) pageSizePtr));
}


/***************************************************************************
 *
 *	The following two routines, Vm_CreateVA and Vm_DestroyVA, are used
 *	to allow users to add or delete ranges of valid virtual addresses
 *	from their virtual address space.  Since neither of these routiens
 *	are monitored (although they call monitored routines), there are 
 *	potential synchronization problems for users sharing memory who
 *	expand their heap segment.  The problems are caused if two or more
 *	users attempt to simultaneously change the size of the heap segment 
 *	to different sizes. The virtual memory system will not have any 
 *	problems handling the conflicting requests, however the actual range 
 *	of valid virtual addresses is unpredictable.  It is up to the user
 *	to synchronize when expanding the HEAP segment.
 */


/*
 *----------------------------------------------------------------------
 *
 * Vm_CreateVA --
 *
 *	Validate the given range of addresses.  If necessary the segment
 *	is expanded to make room.
 *
 * Results:
 *	VM_WRONG_SEG_TYPE if tried to validate addresses for a stack or
 *	code segment and VM_SEG_TOO_LARGE if the segment cannot be
 *	expanded to fill the size.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Vm_CreateVA(address, size)
    Address address;	/* Address to validate from. */
    int	    size;	/* Number of bytes to validate. */
{
    register Vm_Segment *segPtr;
    int			firstPage, lastPage;
    Proc_ControlBlock	*procPtr;

    procPtr = Proc_GetCurrentProc();
    firstPage = (unsigned) (address) >> vmPageShift;
    lastPage = (unsigned) ((int) address + size - 1) >> vmPageShift;

    segPtr = (Vm_Segment *) procPtr->vmPtr->segPtrArray[VM_HEAP];

    /*
     * Make sure that the beginning address falls into the heap segment and
     * not the code segment.
     */
    if (firstPage < segPtr->offset) {
	return(VM_WRONG_SEG_TYPE);
    }

    /*
     * Make sure that the ending page is not greater than the highest
     * possible page.  Since there must be one stack page and one page
     * between the stack and the heap, the highest possible heap page is
     * mach_LastUserStackPage - 2 or segPtr->maxAddr, whichever is lower.
     */
    if (lastPage > mach_LastUserStackPage - 2 ||
        address + size - 1 > segPtr->maxAddr) {
	return(VM_SEG_TOO_LARGE);
    }

    /*
     * Make pages between firstPage and lastPage part of the heap segment's
     * virtual address space.
     */
    return(VmAddToSeg(segPtr, firstPage, lastPage));
}


/*
 *----------------------------------------------------------------------
 *
 * Vm_DestroyVA --
 *
 *	Invalidate the given range of addresses.  If the starting address
 *	is too low then an error message is returned.
 *
 * Results:
 *	VM_WRONG_SEG_TYPE if tried to invalidate addresses for a code.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Vm_DestroyVA(address, size)
    Address address;	/* Address to validate from. */
    int	    size;	/* Number of bytes to validate. */
{
    register Vm_Segment *segPtr;
    int			firstPage, lastPage;
    Proc_ControlBlock	*procPtr;

    procPtr = Proc_GetCurrentProc();
    firstPage = (unsigned) (address) >> vmPageShift;
    lastPage = (unsigned) ((int) address + size - 1) >> vmPageShift;

    segPtr = (Vm_Segment *) procPtr->vmPtr->segPtrArray[VM_HEAP];

    /*
     * Make sure that the beginning address falls into the 
     * heap segment.
     */
    if (firstPage < segPtr->offset) {
	return(VM_WRONG_SEG_TYPE);
    }

    /*
     * Make pages between firstPage and lastPage not members of the segment's
     * virtual address space.
     */
    return(Vm_DeleteFromSeg(segPtr, firstPage, lastPage));
}

static int	copySize = 4096;

#ifndef CLEAN
static char	buffer[8192];
#endif CLEAN

void	SetVal();

/*
 * The # construct to turn a variable into a string is not handled correctly
 * on the current ds3100 (non-ansi) compiler/preprocessor set up.
 * This will change when it's handled correctly.
 */
#if defined(__STDC__)
#define SETVAR(var, val) SetVal(#var, val, (int *)&(var))
#else
#define	SETVAR(var, val) SetVal("var", val, (int *)&(var))
#endif /* sun4 */


/*
 *----------------------------------------------------------------------
 *
 * Vm_Cmd --
 *
 *      This routine allows a user level program to give commands to
 *      the virtual memory system.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Some parameter of the virtual memory system will be modified.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
Vm_Cmd(command, arg)
    int		command;
    int         arg;
{
    int			numBytes;
    ReturnStatus	status = SUCCESS;
    int			numModifiedPages;
 
    switch (command) {
	case VM_COUNT_DIRTY_PAGES:
	    numModifiedPages = VmCountDirtyPages();
	    if (Vm_CopyOut(sizeof(int), (Address) &numModifiedPages,
			   (Address) arg) != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    }
	    break;
	case VM_FLUSH_SEGMENT: {
	    extern int	vmNumSegments;
	    int		intArr[3];
	    Vm_Segment	*segPtr;
	    int		lowPage;
	    int		highPage;
	    Vm_VirtAddr	virtAddr;

	    status = Vm_CopyIn(3 * sizeof(int), (Address)arg, 
				(Address)intArr);
	    if (status != SUCCESS) {
		break;
	    }
	    if (intArr[0] <= 0 || intArr[0] >= vmNumSegments) {
		status = SYS_INVALID_ARG;
		break;
	    }
	    segPtr = VmGetSegPtr(intArr[0]);
	    if (segPtr->type == VM_STACK) {
		lowPage = mach_LastUserStackPage - segPtr->numPages + 1;
		highPage = mach_LastUserStackPage;
	    } else {
		lowPage = segPtr->offset;
		highPage = segPtr->offset + segPtr->numPages - 1;
	    }
	    if (intArr[1] >= lowPage && intArr[1] <= highPage) {
		lowPage = intArr[1];
	    }
	    if (intArr[2] >= lowPage && intArr[2] <= highPage) {
		highPage = intArr[2];
	    }
	    virtAddr.sharedPtr = (Vm_SegProcList *)NIL;
	    virtAddr.segPtr = segPtr;
	    virtAddr.page = lowPage;
	    VmFlushSegment(&virtAddr, highPage);
	    break;
	}
	case VM_SET_FREE_WHEN_CLEAN:
	    SETVAR(vmFreeWhenClean, arg);
	    break;
	case VM_SET_MAX_DIRTY_PAGES:
	    SETVAR(vmMaxDirtyPages, arg);
	    break;
	case VM_SET_PAGEOUT_PROCS:
	    SETVAR(vmMaxPageOutProcs, arg);
	    break;
        case VM_SET_CLOCK_PAGES:
            SETVAR(vmPagesToCheck, arg);
            break;
        case VM_SET_CLOCK_INTERVAL: {
	    SETVAR(vmClockSleep, (int) (arg * timer_IntOneSecond));
            break;
	}
	case VM_SET_COPY_SIZE:
	    SETVAR(copySize, arg);
	    break;
#ifndef CLEAN
	case VM_DO_COPY_IN:
	    (void)Vm_CopyIn(copySize, (Address) arg, buffer);
	    break;
	case VM_DO_COPY_OUT:
	    (void)Vm_CopyOut(copySize, buffer, (Address) arg);
	    break;
	case VM_DO_MAKE_ACCESS_IN:
	    Vm_MakeAccessible(0, copySize, (Address) arg, &numBytes,
			      (Address *) &arg);
	    bcopy((Address) arg, buffer, copySize);
	    Vm_MakeUnaccessible((Address) arg, numBytes);
	    break;
	case VM_DO_MAKE_ACCESS_OUT:
	    Vm_MakeAccessible(0, copySize, (Address) arg, &numBytes,
			      (Address *) &arg);
	    bcopy(buffer, (Address) arg, copySize);
	    Vm_MakeUnaccessible((Address) arg, numBytes);
	    break;
#endif CLEAN
	case VM_GET_STATS: {
#if defined(ds3100) || defined(ds5000)
	    extern unsigned int end;
	    /*
	     * The decstations have a big hole between the initialized data
	     * and the heap, so we can't just subtract the kernel beginning
	     * from the end.
	     */
	    vmStat.kernMemPages = (unsigned int) 
		(vmMemEnd - VMMACH_VIRT_CACHED_START + (unsigned int) &end
		 - mach_KernStart) / vm_PageSize;
#else
	    vmStat.kernMemPages = 
		    (unsigned int)(vmMemEnd - mach_KernStart) / vm_PageSize;
#endif
	    if (Vm_CopyOut(sizeof(Vm_Stat), (Address) &vmStat, 
			   (Address) arg) != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    }
	    break;
	}
	case VM_SET_COW:
	    /*
	     * It's okay to turn on COW when it's off, but not the other
	     * way around.
	     */
	    if (arg || !vm_CanCOW) {
		SETVAR(vm_CanCOW, arg);
	    } else {
		status = GEN_INVALID_ARG;
	    }
	    break;
	case VM_SET_FS_PENALTY:
	    if (arg <= 0) {
		/*
		 * Caller is setting an absolute penalty.
		 */
		SETVAR(vmCurPenalty, -arg);
	    } else {
		SETVAR(vmFSPenalty, arg);
		SETVAR(vmCurPenalty, (vmStat.fsMap - vmStat.fsUnmap) / 
					vmPagesPerGroup * vmFSPenalty);
	    }
	    break;
	case VM_SET_NUM_PAGE_GROUPS: {
	    int	numPages;
	    int curGroup;
	    numPages = vmPagesPerGroup * vmNumPageGroups;
	    if (arg <= 0) {
		status = GEN_INVALID_ARG;
		break;
	    }
	    SETVAR(vmNumPageGroups, arg);
	    SETVAR(vmPagesPerGroup, numPages / vmNumPageGroups);
	    curGroup = (vmStat.fsMap - vmStat.fsUnmap) / vmPagesPerGroup;
	    SETVAR(vmCurPenalty, curGroup * vmFSPenalty);
	    SETVAR(vmBoundary, (curGroup + 1) * vmPagesPerGroup);
	    break;
	}
	case VM_SET_ALWAYS_REFUSE:
	    SETVAR(vmAlwaysRefuse, arg);
	    break;
	case VM_SET_ALWAYS_SAY_YES:
	    SETVAR(vmAlwaysSayYes, arg);
	    break;
	case VM_RESET_FS_STATS:
	    vmStat.maxFSPages = vmStat.fsMap - vmStat.fsUnmap;
	    vmStat.minFSPages = vmStat.fsMap - vmStat.fsUnmap;
	    break;
	case VM_SET_COR_READ_ONLY:
	    SETVAR(vmCORReadOnly, arg);
	    break;
	case VM_SET_PREFETCH:
	    SETVAR(vmPrefetch, arg);
	    break;
	case VM_SET_USE_FS_READ_AHEAD:
	    SETVAR(vmUseFSReadAhead, arg);
	    break;
	case VM_SET_WRITEABLE_PAGEOUT:
	    SETVAR(vmWriteablePageout, arg);
	    break;
	case VM_SET_WRITEABLE_REF_PAGEOUT:
	    SETVAR(vmWriteableRefPageout, arg);
	    break;
	case 1999:
	    SETVAR(vmShmDebug, arg);
	    break;
	case 1234: /* Temporary unix compatibility hook. */
	    SETVAR(debugFsStubs, arg);
	    SETVAR(debugProcStubs, arg);
	    SETVAR(debugSigStubs, arg);
	    SETVAR(debugSysStubs, arg);
	    SETVAR(debugTimerStubs, arg);
	    SETVAR(debugVmStubs, arg);
        default:
	    status = VmMach_Cmd(command, arg);
            break;
    }
 
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * SetVal --
 *
 *      Set a given VM variable.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      The given variable is set.
 *
 *----------------------------------------------------------------------
 */
void
SetVal(descript, newVal, valPtr)
    char	*descript;
    int		newVal;
    int		*valPtr;
{
    printf("%s val was %d, is %d\n", descript, *valPtr, newVal);
    *valPtr = newVal;
}

/*
 *----------------------------------------------------------------------
 *
 * Vm_Mmap --
 *
 *	Map a page.
 *
 * Results:
 *	Status from the map.
 *
 * Side effects:
 *	Maps the page.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ENTRY ReturnStatus
Vm_Mmap(startAddr, length, prot, share, streamID, fileAddr, mappedAddr)
    Address	startAddr;	/* Requested starting virt-addr. */
    int		length;		/* Length of mapped segment. */
    int		prot;		/* Protection for mapped segment. */
    int		share;		/* Private/shared flag. */
    int		streamID;	/* Open file to be mapped. */
    int		fileAddr;	/* Offset into mapped file. */
    Address	*mappedAddr;	/* Mapped address (user space). */
{
    Address mappedAddrInt;
    ReturnStatus status;

    status = Vm_MmapInt(startAddr, length, prot, share, streamID, fileAddr,
	    &mappedAddrInt);
    if (status==SUCCESS) {
	status = Vm_CopyOut(sizeof(int), (Address)&mappedAddrInt,
		(Address)mappedAddr);
    }
    return status;
    
}

/*
 *----------------------------------------------------------------------
 *
 * Vm_MmapInt --
 *
 *	Internal routine for Vm_Mmap.
 *
 * Results:
 *	Status from the map.
 *
 * Side effects:
 *	Maps the page.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ENTRY ReturnStatus
Vm_MmapInt(startAddr, length, prot, share, streamID, fileAddr, mappedAddr)
    Address	startAddr;	/* Requested starting virt-addr. */
    int		length;		/* Length of mapped segment. */
    int		prot;		/* Protection for mapped segment. */
    int		share;		/* Private/shared flag. */
    int		streamID;	/* Open file to be mapped. */
    int		fileAddr;	/* Offset into mapped file. */
    Address	*mappedAddr;	/* Mapped address. */
{
    Proc_ControlBlock	*procPtr;
    Fs_Stream 		*streamPtr;
    int			pnum;
    ReturnStatus	status = SUCCESS;
    Fs_Attributes	attr;
    Vm_SharedSegTable	*segTabPtr;
    Vm_Segment		*segPtr;
    Vm_SegProcList	*sharedSeg;
    Fs_Stream 		*filePtr;

    length = (length+vm_PageSize-1)&~(vm_PageSize-1);
    dprintf("mmap( %x, %d, %d, %d, %d, %d)\n", startAddr, length,
	    prot, share, streamID, fileAddr);

    if ((share&MAP_TYPE)!=MAP_SHARED && (share&MAP_TYPE)!=MAP_PRIVATE) {
	printf("Vm_Mmap: Invalid share flag %x\n", share);
        return VM_WRONG_SEG_TYPE;
    }

    procPtr = Proc_GetCurrentProc();
    status = Fs_GetStreamPtr(procPtr,streamID,&streamPtr);
    dprintf("Vm_Mmap: procPtr: %x  streamID: %d streamPtr: %x\n",
	    procPtr,streamID,(int)streamPtr);
    if (status != SUCCESS) {
	printf("Vm_Mmap: Fs_GetStreamPtr failure\n");
	return status;
    }
    if (debugVmStubs) {
	printf("mmap: refCount = %d for stream %x ",
		((Fs_HandleHeader *)streamPtr)->refCount, streamPtr);
    }
    Fsio_StreamCopy(streamPtr,&filePtr);
    if (debugVmStubs) {
	printf(", after copy refCount = %d\n", ((Fs_HandleHeader *)streamPtr)->refCount);
    }

    status = Fs_GetAttrStream(filePtr,&attr);
    if (status != SUCCESS) {
	printf("Vm_Mmap: Fs_GetAttrStream failure\n");
	(void)Fs_Close(filePtr);
	return status;
    }
    dprintf("file: fileNumber %d size %d\n",attr.fileNumber, attr.size);

    if (!(attr.type == FS_DEVICE) &&
            (BADALIGN(startAddr) || BADALIGN(fileAddr))) {
        printf("Vm_Mmap: Invalid start or offset\n");
        return VM_WRONG_SEG_TYPE;
    }
    /*
     * Do a device-specific mmap.
     */
    if (attr.type == FS_DEVICE) {
        extern  ReturnStatus    Fsio_DeviceMmap();

        (void) Fs_Close(filePtr);               /* Don't need this filePtr. */
        /*
         * Should I really indirect through the file system here?  But that
         * requires adding an mmap switch to all the file system crud.  I'll
         * test it this way first by going straight to Fs_Device stuff.
         */
        status = Fsio_DeviceMmap(streamPtr, startAddr, length, fileAddr,
                &startAddr);
        if (status == SUCCESS) {
	    *mappedAddr = startAddr;
        }
	return status;
    }


    /* 
     * Check permissions.
     * The rules:
     * The file must have read permissions.
     * We must request read and/or write permissions.
     * If we take a private copy, we can do whatever we want.
     * Otherwise we must have the requested permissions.
     */
    if (attr.type != FS_FILE) {
	printf("Vm_Mmap: not a file\n");
	(void)Fs_Close(filePtr);
	return VM_WRONG_SEG_TYPE;
    }
    if (!(filePtr->flags & FS_READ) || !(prot & (PROT_READ | PROT_WRITE)) ||
	    ((share&MAP_TYPE)!=MAP_PRIVATE &&
	    (((prot & PROT_WRITE) && !(filePtr->flags & FS_WRITE)) ||
	    ((prot & PROT_EXEC) && !(filePtr->flags & FS_EXECUTE))))) {
	printf("Vm_Mmap: protection failure\n");
	printf("flags = %x, prot = %x\n", filePtr->flags, prot);
	(void)Fs_Close(filePtr);
	return VM_WRONG_SEG_TYPE;
    }

    LOCK_SHM_MONITOR;
    if (procPtr->vmPtr->sharedSegs == (List_Links *)NIL) {
	dprintf("Vm_Mmap: New proc list\n");
	procPtr->vmPtr->sharedSegs = (List_Links *)
		malloc(sizeof(Vm_SegProcList));
	VmMach_SharedProcStart(procPtr);
	dprintf("Vm_Mmap: sharedStart: %x\n",procPtr->vmPtr->sharedStart);
	List_Init((List_Links *)procPtr->vmPtr->sharedSegs);
	Proc_NeverMigrate(procPtr);
    }
    if (!(share&MAP_FIXED) || startAddr==0) {
	status = VmMach_SharedStartAddr(procPtr, length, &startAddr, 0);
    } else {
	status = VmMach_SharedStartAddr(procPtr, length, &startAddr, 1);
    }
    if (status != SUCCESS) {
	printf("Vm_Mmap: VmMach_SharedStart failure\n");
	UNLOCK_SHM_MONITOR;
	(void)Fs_Close(filePtr);
	return status;
    }

    /*
     * See if a shared segment is already using the specified file.
     * If we're making a private copy, we probably need a new segment.
     * (We should probably do something more intelligent about mapping
     * multiple copies of a file into memory.)
     */
    segPtr = (Vm_Segment *) NIL;
    segTabPtr = (Vm_SharedSegTable *) NIL;
    if ((share&MAP_TYPE)!=MAP_PRIVATE) {
	LIST_FORALL((List_Links *)&sharedSegTable, (List_Links *)segTabPtr) {
	    if (segTabPtr->serverID == attr.serverID && segTabPtr->domain ==
		    attr.domain && segTabPtr->fileNumber == attr.fileNumber) {
		segPtr = segTabPtr->segPtr;
		break;
	    }
	}
    }

#if 0
    pnum = 10288;	/* Random number, since shared memory shouldn't
				be using this value */
#else
    pnum = (int)startAddr>>vmPageShift;
#endif

    if (segPtr == (Vm_Segment *)NIL) {
	dprintf("Vm_Mmap: New segment\n");
	/*
	 * Create a new segment and add to the shared segment list.
	 */
	
	segTabPtr = (Vm_SharedSegTable*) malloc(sizeof(Vm_SharedSegTable));
	dprintf("Vm_Mmap: creating new segment\n");
	segTabPtr->segPtr = Vm_SegmentNew(VM_SHARED,(Fs_Stream *)NIL,
		0,length>>vmPageShift,pnum,procPtr);
	if ((share&MAP_TYPE)==MAP_PRIVATE) {
	    segTabPtr->segPtr->filePtr = filePtr;
	} else {
	    segTabPtr->segPtr->filePtr = (Fs_Stream *)NIL;
	    segTabPtr->segPtr->swapFilePtr = filePtr;
	    segTabPtr->segPtr->flags |= VM_SWAP_FILE_OPENED;
	}
	segTabPtr->serverID = attr.serverID;
	segTabPtr->domain = attr.domain;
	segTabPtr->fileNumber = attr.fileNumber;
	segTabPtr->refCount = 0;
	dprintf("Vm_Mmap: Validating pages %x to %x\n",
		pnum,pnum+(length>>vmPageShift)-1);
	Vm_ValidatePages(segTabPtr->segPtr,pnum,pnum+(length>>vmPageShift)-1,
		FALSE,TRUE);
	List_Insert((List_Links *)segTabPtr,
		LIST_ATFRONT((List_Links *)&sharedSegTable));
	dprintf("Calling Fs_FileBeingMapped(1)\n");
	Fs_FileBeingMapped(filePtr,1);
	dprintf("Done Fs_FileBeingMapped(1)\n");
    } else {
	int i;
	/*
	startAddr = (Address)(segPtr->offset<<vmPageShift);
	*/
	if (length > (segPtr->numPages<<vmPageShift)) {
	    dprintf("Vm_Mmap: Enlarging segment: 0 to %d\n",
		    ((int)length-1)>>vmPageShift);
	    status = VmAddToSeg(segPtr,segPtr->offset,segPtr->offset+
		    (length>>vmPageShift)-1);
	    if (status != SUCCESS) {
		printf("VmAddToSeg failure\n");
		UNLOCK_SHM_MONITOR;
		(void)Fs_Close(filePtr);
		return status;
	    }
	}
	for (i=0;i<32;i++) {
	    if (segPtr->ptPtr[i] & VM_VIRT_RES_BIT) {
		dprintf("1");
	    } else {
		dprintf("0");
	    }
	}
	dprintf("\n");
	if (procPtr->vmPtr->sharedSegs == (List_Links *)NIL ||
	    !VmCheckSharedSegment(procPtr,segPtr)) {
	    /*
	     * Process is not using segment.
	     */
	    dprintf("Vm_Mmap: Adding reference to proc to segment\n");
	    Vm_SegmentIncRef(segPtr,procPtr);
	} else {
	    /*
	     * Process is already using segment.
	     */
	    dprintf("Vm_Mmap: Process is using segment.\n");
	}
	/*
	 * We don't want to keep the file pointer around, since the
	 * shared memory segment already exists.
	 */
	if (debugVmStubs) {
	    printf("Closing filePtr, refCount = %d\n", 
		((Fs_HandleHeader *)streamPtr)->refCount);
	}
	(void)Fs_Close(filePtr);
    }

    /*
     * Unmap any current mapping at the address range.
     */
    status=VmMunmapInt(startAddr,length,1);
    if (status == SUCCESS) {
	/*
	 * Force the mach module to allocate the segment again.
	 * (The allocation of shared segments in memory needs to be fixed up.
	 * The problem is that we may have multiple segments mapped into
	 * the same memory, and thus it is hard to keep track of what's
	 * in use).  This should force the segment to be marked as in use.
	 * There still may be a problem if part of a segment is unmapped.
	 */
	status = VmMach_SharedStartAddr(procPtr, length, &startAddr, 1);
    }
    if (status != SUCCESS) {
	printf("Vm_Mmap: Vm_Munmap failure\n");
	UNLOCK_SHM_MONITOR;
	(void)Fs_Close(filePtr);
	return status;
    }

    /*
     * Add the segment to the process's list of shared segments.
     */
    dprintf("Vm_Mmap: Adding segment to list\n");
    sharedSeg = (Vm_SegProcList *)malloc(sizeof(Vm_SegProcList));
    sharedSeg->fd = streamID;
    sharedSeg->stream = filePtr;
    sharedSeg->segTabPtr = segTabPtr;
    segTabPtr->refCount++;
    sharedSeg->addr = startAddr;
    sharedSeg->mappedStart = startAddr;
    dprintf("fileAddr: %x\n",fileAddr);
    sharedSeg->fileAddr = fileAddr;
    sharedSeg->offset = (int)startAddr>>vmPageShift;
    sharedSeg->mappedEnd = startAddr+length-1;
    sharedSeg->prot = (prot&PROT_WRITE) ? 0 : VM_READONLY_SEG;
    dprintf("Set prot to %d\n",sharedSeg->prot);
    if ((int)sharedSeg->segTabPtr == -1) {
	dprintf("Vm_Mmap: Danger: sharedSeg->segTabPtr is -1!\n");
    }
    List_Insert((List_Links *)sharedSeg,
	    LIST_ATFRONT((List_Links *)procPtr->vmPtr->sharedSegs));
    

    VmPrintSharedSegs(procPtr);
    UNLOCK_SHM_MONITOR;
    dprintf("Vm_Mmap: Completed page mapping\n");
    *mappedAddr = startAddr;
    if (debugVmStubs) {
	printf("end of mmap: refCount = %d\n",
		((Fs_HandleHeader *)streamPtr)->refCount);
    }
    return SUCCESS;
}

/*
 *----------------------------------------------------------------------
 *
 * Vm_Munmap --
 *
 *	Unmaps the process's pages in a specified address range.
 *	Gets the lock and then calls VmMunmapInt.
 *
 * Results:
 *	Status from the unmap operation.
 *
 * Side effects:
 *	Unmaps the pages.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
Vm_Munmap(startAddr, length, noError)
    Address	startAddr;	/* Starting virt-addr. */
    int		length;		/* Length of mapped segment. */
    int		noError;	/* Ignore errors. */
{
    ReturnStatus status;

    dprintf("munmap(%x, %d, %d)\n", startAddr, length, noError);
    if (BADALIGN(startAddr) || BADALIGN(length)) {
	printf("Vm_Munmap: Invalid start or offset\n");
	return VM_WRONG_SEG_TYPE;
    }
    LOCK_SHM_MONITOR;
    status = VmMunmapInt(startAddr,length, noError);
    UNLOCK_SHM_MONITOR;
    return status;
}

/*
 *----------------------------------------------------------------------
 *
 * VmMunmapInt --
 *
 *	Unmaps the process's pages in a specified address range.
 *
 * Results:
 *	Status from the unmap operation.
 *
 * Side effects:
 *	Unmaps the pages.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
VmMunmapInt(startAddr, length, noError)
    Address	startAddr;	/* Starting virt-addr. */
    int		length;		/* Length of mapped segment. */
    int		noError;	/* 1 if don't care about errors
				   from absent segments. */
{

    ReturnStatus	status = SUCCESS;
    Proc_ControlBlock	*procPtr;
    Vm_SegProcList		*segProcPtr;
    Vm_SegProcList		*newSegProcPtr;
    Address		addr;
    Address		addr1;
    Address		endAddr;
    Vm_VirtAddr		virtAddr;

    virtAddr.flags = 0;
    virtAddr.offset = 0;

    dprintf("Vm_Munmap: Unmapping shared pages\n");

    procPtr = Proc_GetCurrentProc();
    endAddr = startAddr+length;
    for (addr=startAddr; addr<endAddr; ) {

	dprintf("Vm_Munmap: trying to eliminate %x to %x\n",
		(int)addr,(int)endAddr-1);
	/* Find the segment corresponding to this address. */
	if (procPtr->vmPtr->sharedSegs != (List_Links *)NIL) {
	    segProcPtr = VmFindSharedSegment(procPtr->vmPtr->sharedSegs,addr);
	} else if (noError) {
	    return SUCCESS;
	} else {
	    dprintf("Vm_Munmap: Process has no shared segments\n");
	    return VM_WRONG_SEG_TYPE;
	}

	/* There are three possibilities:
	   1. The unmap can remove a mapping.
	   2. The unmap can shrink a mapping.
	   3. The unmap can split a mapping.
	*/

	if (segProcPtr == (Vm_SegProcList *)NIL) {
	    if (!noError) {
		dprintf("Vm_Munmap: Page to unmap not in valid range\n");
		status = VM_WRONG_SEG_TYPE;
	    }
	    /*
	     * Move to next mapped segment, so we can keep unmapping.
	     */
	    addr1 = endAddr;
	    LIST_FORALL(procPtr->vmPtr->sharedSegs,
		    (List_Links *)segProcPtr) {
		if (segProcPtr->mappedStart > addr && 
		    segProcPtr->mappedStart < addr1) {
		    addr1 = segProcPtr->mappedStart;
		}
	    }
	} else {
	    addr1 = segProcPtr->mappedEnd+1;

	    /*
	     * Invalidate the pages to be mapped out.
	     */
	    virtAddr.page = max((int)segProcPtr->mappedStart,(int)addr)
		    >> vmPageShift;
	    virtAddr.segPtr = segProcPtr->segTabPtr->segPtr;
	    virtAddr.sharedPtr = segProcPtr;
	    dprintf("Vm_Munmap: invalidating: %x to %x\n",
		    (int)virtAddr.page<<vmPageShift,
		    min((int)segProcPtr->mappedEnd+1, (int)endAddr));
	    VmFlushSegment(&virtAddr,min((int)segProcPtr->mappedEnd+1,
		    (int)endAddr)>>vmPageShift);

	    if (segProcPtr->mappedStart < addr) {
		dprintf("Vm_Munmap: Shortening mapped region (1)\n");
		if (segProcPtr->mappedEnd >= endAddr) {
		    dprintf("Vm_Munmap: Splitting mapped region\n");
		    /*
		     * Split the mapped region.
		     */
		    newSegProcPtr = (Vm_SegProcList *)
			    malloc(sizeof(Vm_SegProcList));
		    if (debugVmStubs) {
			printf("Malloc'd %x\n", newSegProcPtr);
		    }
		    *newSegProcPtr = *segProcPtr;
		    newSegProcPtr->mappedStart = endAddr;
		    newSegProcPtr->mappedEnd = segProcPtr->mappedEnd;
		    segProcPtr->segTabPtr->refCount++;
		    List_Insert((List_Links *)newSegProcPtr, LIST_AFTER(
			    (List_Links *)segProcPtr));
		}
		/*
		 * Shrink the first mapping.
		 */
		segProcPtr->mappedEnd = addr-1;
	    } else if (segProcPtr->mappedEnd >= endAddr) {
		/*
		 * Shrink the mapped region.
		 */
		dprintf("Vm_Munmap: Shortening mapped region (2)\n");
		segProcPtr->mappedStart = endAddr;
	    } else {
		dprintf("Vm_Munmap: Removing mapped region\n");
		/*
		 * Remove the entire mapped region.
		 */
		Vm_DeleteSharedSegment(procPtr,segProcPtr);
	    }
	}
	if (addr == addr1) {
	    panic("Vm_Munmap loop\n");
	}
	addr = addr1;
    }

    VmPrintSharedSegs(procPtr);
    dprintf("Vm_Munmap: done\n");
    return status ;
}

/* 
 * Check if an address range is valid for the segment.
 */
#define CheckBounds(virtAddrPtr,startAddr,length) \
	((unsigned)(((int)(startAddr)>>vmPageShift) - segOffset(virtAddrPtr)) \
	< (virtAddrPtr)->segPtr->ptSize && \
	((unsigned)((((int)(startAddr)+(length)-1)>>vmPageShift) - \
	segOffset(virtAddrPtr)) < (virtAddrPtr)->segPtr->ptSize))
/*
 *----------------------------------------------------------------------
 *
 * Vm_Msync --
 *
 *	Sync pages to disk.
 *	startAddr and length must be divisible by the page size.
 *
 * Results:
 *	Status from the sync.
 *
 * Side effects:
 *	Page goes to disk.
 *
 *----------------------------------------------------------------------
 */
ENTRY ReturnStatus
Vm_Msync(startAddr, length)
    Address	startAddr;	/* Requested starting virt-addr. */
    int		length;		/* Length of region to page out. */
{
    Vm_VirtAddr		virtAddr;
    ReturnStatus	status;
    Proc_ControlBlock	*procPtr;

    dprintf("msync( %x, %d)\n", startAddr, length);
    if (BADALIGN(startAddr) || BADALIGN(length)) {
	printf("Vm_Msync: Invalid start or offset\n");
	return VM_WRONG_SEG_TYPE;
    }
    LOCK_SHM_MONITOR;
    procPtr = Proc_GetCurrentProc();
    VmVirtAddrParseUnlock(procPtr, startAddr, &virtAddr);
    if (virtAddr.segPtr == (Vm_Segment *)NIL || !CheckBounds(&virtAddr,
	    startAddr, length)) {
	UNLOCK_SHM_MONITOR;
	return SYS_INVALID_ARG;
    }
    status = VmPageFlush(&virtAddr, length, TRUE, TRUE);
    UNLOCK_SHM_MONITOR;
    return status;
}

/*
 *----------------------------------------------------------------------
 *
 * Vm_Mlock --
 *
 *	Locks a page into memory.  Page is paged in if necessary.
 *
 * Results:
 *	Fails if unable to lock page.
 *
 * Side effects:
 *	Locks the page.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ENTRY ReturnStatus
Vm_Mlock(startAddr, length)
    Address	startAddr;	/* Requested starting virt-addr. */
    int		length;		/* Length of region to lock. */
{
    Vm_VirtAddr		virtAddr;
    Proc_ControlBlock	*procPtr;
    int			maptype = VM_READWRITE_ACCESS;

    dprintf("mlock( %x, %d)\n", startAddr, length);
    if (BADALIGN(startAddr) || BADALIGN(length)) {
	printf("Vm_Mlock: Invalid start or offset\n");
	return VM_WRONG_SEG_TYPE;
    }
    procPtr = Proc_GetCurrentProc();
    VmVirtAddrParseUnlock(procPtr, startAddr, &virtAddr);
    if (virtAddr.segPtr == (Vm_Segment *)NIL || !CheckBounds(&virtAddr,
	    startAddr, length)) {
	return SYS_INVALID_ARG;
    } else if (virtAddr.sharedPtr != (Vm_SegProcList *)NIL) {
	maptype = virtAddr.sharedPtr->prot == VM_READONLY_SEG ?
		VM_READONLY_ACCESS : VM_READWRITE_ACCESS;
    } else {
	maptype = virtAddr.segPtr->type == VM_CODE ? VM_READONLY_ACCESS :
		VM_READWRITE_ACCESS;
    }
    return Vm_PinUserMem(maptype,length,startAddr);
}

/*
 *----------------------------------------------------------------------
 *
 * Vm_Munlock --
 *
 *	Unlocks a page.
 *
 * Results:
 *	Status from the unlock.
 *
 * Side effects:
 *	Unlocks the page.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ENTRY ReturnStatus
Vm_Munlock(startAddr, length)
    Address	startAddr;	/* Requested starting virt-addr. */
    int		length;		/* Length of region to unlock. */
{
    Vm_VirtAddr	virtAddr;
    Proc_ControlBlock	*procPtr;

    dprintf("munlock( %x, %d)\n", startAddr, length);
    if (BADALIGN(startAddr) || BADALIGN(length)) {
	printf("Vm_Munlock: Invalid start or offset\n");
	return VM_WRONG_SEG_TYPE;
    }
    procPtr = Proc_GetCurrentProc();
    VmVirtAddrParseUnlock(procPtr, startAddr, &virtAddr);
    if (virtAddr.segPtr == (Vm_Segment *)NIL || !CheckBounds(&virtAddr,
	    startAddr, length)) {
	return SYS_INVALID_ARG;
    }
    Vm_UnpinUserMem(length,startAddr);
    return SUCCESS;
}

/*
 *----------------------------------------------------------------------
 *
 * Vm_Mincore --
 *
 *	Returns residency vector.
 *
 * Results:
 *	The values of vec are 0 if the page is not virtually resident,
 *	1 if the page is paged out, 2 if the page is clean and
 *	untouched, 3 if the page is referenced, and 4 if the page is dirty.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/

ENTRY ReturnStatus
Vm_Mincore(startAddr, length, retVec)
    Address	startAddr;	/* Requested starting virt-addr. */
    int		length;		/* Length of region. */
    char *	retVec;		/* Return vector. */
{
    char		*vec;
    Address		checkAddr;
    Vm_VirtAddr		virtAddr;
    Proc_ControlBlock	*procPtr;
    ReturnStatus	status;
    int			len;
    int			i;
    Vm_PTE		*ptePtr;
    Boolean		referenced;
    Boolean		modified;

    dprintf("mincore( %x, %d, %x)\n", startAddr, length, retVec);
    if (BADALIGN(startAddr) || BADALIGN(length)) {
	printf("Vm_Mincore: Invalid start or offset\n");
	return VM_WRONG_SEG_TYPE;
    }
    procPtr = Proc_GetCurrentProc();
    len = length>>vmPageShift;
    vec = (char *)malloc(len);
    checkAddr = startAddr;
    for (i=0;i<len;i++) {
	VmVirtAddrParseUnlock(procPtr, checkAddr, &virtAddr);
	if (virtAddr.segPtr == (Vm_Segment *)NIL) {
	    vec[i] = 0;
	    dprintf("Vm_Mincore: no segment at address %x\n", checkAddr);
	} else {
	    ptePtr = VmGetAddrPTEPtr(&virtAddr, virtAddr.page);
	    if (*ptePtr & VM_VIRT_RES_BIT) {
		if (*ptePtr & VM_PHYS_RES_BIT) {
		    VmMach_GetRefModBits(&virtAddr, Vm_GetPageFrame(*ptePtr),
			    &referenced, &modified);
		    if (modified || (*ptePtr & VM_MODIFIED_BIT)) {
			vec[i] = 4;
			dprintf("Vm_Mincore: modified at %x\n", checkAddr);
		    } else if (referenced || (*ptePtr & VM_REFERENCED_BIT)) {
			vec[i] = 3;
			dprintf("Vm_Mincore: referenced at %x\n", checkAddr);
		    } else {
			vec[i] = 2;
			dprintf("Vm_Mincore: present at %x\n", checkAddr);
		    }
		} else {
		    vec[i] = 1;
		    dprintf("Vm_Mincore: absent at %x\n", checkAddr);
		}
	    } else {
		vec[i] = 0;
		dprintf("Vm_Mincore: gone at %x\n", checkAddr);
	    }
	}
	checkAddr += vm_PageSize;
	dprintf("Vm_Mincore: i=%d v[i]=%d\n",i,vec[i]);
    }
    status = Vm_CopyOut( len, (Address) vec, (Address) retVec);
    free((char *)vec);
    return status;
}

/*
 *----------------------------------------------------------------------
 *
 * Vm_Mprotect --
 *
 *	Change protection of pages.
 *
 * Results:
 *	SUCCESS or error condition.
 *
 * Side effects:
 *	Changes protection.
 *
 *----------------------------------------------------------------------
 */

ENTRY ReturnStatus
Vm_Mprotect(startAddr, length, prot)
    Address	startAddr;	/* Requested starting virt-addr. */
    int		length;		/* Length of region. */
    int		prot;		/* Protection for region. */
{
    Vm_VirtAddr virtAddr;
    Vm_PTE          *ptePtr;
    Proc_ControlBlock       *procPtr;
    int i;
    int firstPage, lastPage;

    if (BADALIGN(startAddr) || BADALIGN(length)) {
	printf("Vm_Mprotect: Invalid start or offset\n");
	return VM_WRONG_SEG_TYPE;
    }
#if 0
    if (prot & ~(PROT_READ|PROT_WRITE)) {
	printf("Vm_Mprotect: Only read/write permissions allowed\n");
	return SYS_INVALID_ARG;
    }
#endif
    if (!(prot & PROT_READ)) {
	printf("Vm_Mprotect: can't remove read perms in this implementation\n");
	return SYS_INVALID_ARG;
    }
    procPtr = Proc_GetCurrentProc();
    VmVirtAddrParseUnlock(procPtr, startAddr, &virtAddr);
    firstPage = (unsigned int) startAddr >> vmPageShift;
    lastPage = ((unsigned int)(startAddr+length-1)) >> vmPageShift;
    if (firstPage < segOffset(&virtAddr)) {
	printf("First page is out of range\n");
	return SYS_INVALID_ARG; /* ENOMEM */
    }
    for (i=lastPage-firstPage, ptePtr =
	    VmGetAddrPTEPtr(&virtAddr, virtAddr.page);i>=0;
	    i--, VmIncPTEPtr(ptePtr,1), virtAddr.page++) {
	if (virtAddr.page >= segOffset(&virtAddr) + virtAddr.segPtr->ptSize) {
	    printf("Page %d out of range\n",virtAddr.page);
	    printf("Addr = %x, segOffset=%d, ptSize=%d, segType %d\n", startAddr,
		    segOffset(&virtAddr), virtAddr.segPtr->ptSize,
		    virtAddr.segPtr->type);
	    break;
	}
	if (prot & PROT_WRITE) {
	    *ptePtr &= ~VM_READ_ONLY_PROT;
	} else {
	    *ptePtr |= VM_READ_ONLY_PROT;
	}
	VmMach_SetPageProt(&virtAddr, *ptePtr);
    }
    return SUCCESS;
}
@


9.22
log
@Added a close to make sure the mapped file doesn't get extra opens.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.21 91/09/10 18:29:50 rab Exp $ SPRITE (Berkeley)";
d1257 6
a1262 3
	if (lastPage >= segOffset(&virtAddr) + virtAddr.segPtr->ptSize) {
	    printf("Page out of range\n");
	    return SYS_INVALID_ARG; /* ENOMEM */
@


9.21
log
@Fixed lint errors and removed tracing.
@
text
@d1 2
a2 1
/* vmSysCall.c -
d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.20 91/08/13 12:44:22 shirriff Exp Locker: rab $ SPRITE (Berkeley)";
d564 2
a565 2
	printf("mmap: refCount = %d  ",
		((Fs_HandleHeader *)streamPtr)->refCount);
d569 1
a569 1
	printf(", refCount = %d\n", ((Fs_HandleHeader *)streamPtr)->refCount);
a633 3
	if (debugVmStubs) {
	    printf("Malloc'd segProcList: %x\n", procPtr->vmPtr->sharedSegs);
	}
a692 3
	if (debugVmStubs) {
	    printf("Created new segment %x\n", segTabPtr->segPtr->segNum);
	}
d744 9
a781 3
    if (debugVmStubs) {
	printf("Malloc'd segProcList: %x\n", sharedSeg);
    }
d805 4
@


9.20
log
@A fix to shared memory allocation so a segment in use won't get freed
by munmap.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.19 91/08/09 15:13:31 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
a17 1
#include <vmTrace.h>
d56 1
a56 1
	    VmDecPTUserCount(procPtr->vmPtr->segPtrArray[VM_HEAP]);}
a419 75
	case VM_START_TRACING: {
	    ReturnStatus	status;
	    void		VmTraceDaemon();
	    Vm_TraceStart	*traceStartPtr;
	    extern int		etext;
	    char		fileName[100];
	    char		hostNum[34];

	    if (vmTraceFilePtr != (Fs_Stream *)NIL) {
		printf("VmCmd: Tracing already running.\n");
		break;
	    }
	    vmTracesPerClock = arg;
	    printf("Vm_Cmd: Tracing started at %d times per second\n",
			arg);

	    if (vmTraceBuffer == (char *)NIL) {
		vmTraceBuffer = (char *)malloc(VM_TRACE_BUFFER_SIZE);
	    }
	    bzero((Address)&vmTraceStats, sizeof(vmTraceStats));

	    traceStartPtr = (Vm_TraceStart  *)vmTraceBuffer;
	    traceStartPtr->recType = VM_TRACE_START_REC;
	    traceStartPtr->hostID = Sys_GetHostId();
	    traceStartPtr->pageSize = vm_PageSize;
	    traceStartPtr->numPages = vmStat.numPhysPages;
	    traceStartPtr->codeStartAddr = mach_KernStart;
	    traceStartPtr->dataStartAddr = (Address)&etext;
	    traceStartPtr->stackStartAddr = vmStackBaseAddr;
	    traceStartPtr->mapStartAddr = vmMapBaseAddr;
	    traceStartPtr->cacheStartAddr = vmBlockCacheBaseAddr;
	    traceStartPtr->cacheEndAddr = vmBlockCacheEndAddr;
	    bcopy((Address)&vmStat, (Address)&traceStartPtr->startStats,
		    sizeof(Vm_Stat));
	    traceStartPtr->tracesPerSecond = vmTracesPerClock;
	    vmTraceFirstByte = 0;
	    vmTraceNextByte = sizeof(Vm_TraceStart);

	    (void)strcpy(fileName, VM_TRACE_FILE_NAME);
	    (void)sprintf(hostNum, "%u", (unsigned) Sys_GetHostId());
	    (void)strcat(fileName, hostNum);

	    status = Fs_Open(fileName, FS_WRITE | FS_CREATE,
			     FS_FILE, 0660, &vmTraceFilePtr);
	    if (status != SUCCESS) {
		printf("Warning: Vm_Cmd: Couldn't open trace file, reason %x\n",
		    status);
	    } else {
		vmTraceNeedsInit = TRUE;
	    }
	    break;
	}
	case VM_END_TRACING: {
	    Vm_TraceEnd		traceEnd;

	    bcopy((Address)&vmStat, (Address)&traceEnd.endStats,
		    sizeof(Vm_TraceEnd));
	    bcopy((Address)&vmTraceStats, (Address)&traceEnd.traceStats,
		    sizeof(Vm_TraceStats));
	    VmStoreTraceRec(VM_TRACE_END_REC, sizeof(Vm_TraceEnd),
			    (Address)&traceEnd, FALSE);

	    vm_Tracing = FALSE;
	    vmClockSleep = timer_IntOneSecond;
	    if (vmTraceFilePtr != (Fs_Stream *)NIL) {
		VmTraceDump((ClientData)0, (Proc_CallInfo *)NIL);
		(void)Fs_Close(vmTraceFilePtr);
		vmTraceFilePtr = (Fs_Stream *)NIL;
	    }
	    printf("Vm_Cmd: Tracing ended: Traces=%d Drops=%d\n",
			vmTraceTime, vmTraceStats.traceDrops);
	    printf("		       Dumps=%d Bytes=%d.\n",
			vmTraceStats.traceDumps, vmTraceNextByte);
	    break;
	}
@


9.19
log
@Modified allocation of shared memory.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.18 91/07/26 17:05:18 shirriff Exp $ SPRITE (Berkeley)";
d831 11
d844 2
@


9.18
log
@Large install for unix compatibility
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm.ken/RCS/vmSysCall.c,v 1.2 91/07/22 22:44:53 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
a716 3
/*
 * TEMPORARY!!!!
 */
d718 9
a726 14
#if 1
	/*
	 * Pick an address for the mapping.
	 */
	status = VmMach_SharedStartAddr(procPtr, length, &startAddr);
	if (status != SUCCESS) {
	    printf("Vm_Mmap: VmMach_SharedStart failure\n");
	    UNLOCK_SHM_MONITOR;
	    (void)Fs_Close(filePtr);
	    return status;
	}
#else
        startAddr = 0x0dddc000;
#endif
@


9.17
log
@tried to fix it so that the hole in the ds vm wasn't included in the
count of kernel pages
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.16 91/04/09 18:40:23 mgbaker Exp $ SPRITE (Berkeley)";
d36 7
d505 7
d618 1
a618 1
    Vm_SegProcList		*sharedSeg;
d621 1
d625 5
d638 4
d643 3
d683 5
d695 3
a697 2
	    ((prot & PROT_WRITE) && !(filePtr->flags & FS_WRITE)) ||
	    ((prot & PROT_EXEC) && !(filePtr->flags & FS_EXECUTE))) {
d699 1
d709 3
d717 18
a734 6
    status = VmMach_SharedStartAddr(procPtr, length, &startAddr);
    if (status != SUCCESS) {
	printf("Vm_Mmap: VmMach_SharedStart failure\n");
	UNLOCK_SHM_MONITOR;
	(void)Fs_Close(filePtr);
	return status;
d739 3
d744 4
a747 2
    LIST_FORALL((List_Links *)&sharedSegTable, (List_Links *)segTabPtr) {
	if (segTabPtr->serverID == attr.serverID && segTabPtr->domain ==
d749 3
a751 2
	    segPtr = segTabPtr->segPtr;
	    break;
d755 1
a755 1
    pnum = (int)startAddr>>vmPageShift;
d758 3
d772 10
a781 2
	segTabPtr->segPtr->swapFilePtr = filePtr;
	segTabPtr->segPtr->flags |= VM_SWAP_FILE_OPENED;
d849 3
d1013 3
d1302 1
d1307 1
@


9.16
log
@Fixed a bug in VmMmapInt that caused a kernel address to be returned,
instead of a user address.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.15 91/04/08 13:02:29 shirriff Exp Locker: mgbaker $ SPRITE (Berkeley)";
d336 12
a347 1
	case VM_GET_STATS:
d350 1
d356 1
@


9.15
log
@Split Vm_Mmap into Vm_MmapInt.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.14 90/10/19 15:40:54 shirriff Exp $ SPRITE (Berkeley)";
d634 1
a634 1
        if (status != SUCCESS) {
@


9.14
log
@Added error checking.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.13 90/09/12 13:36:45 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d543 39
d635 1
a635 1
            return status;
d637 1
a637 2
        return(Vm_CopyOut(sizeof(Address), (Address) &startAddr,
            (Address) mappedAddr));
d792 2
a793 3
    return(Vm_CopyOut(sizeof(Address), (Address) &startAddr,
	    (Address) mappedAddr));

@


9.13
log
@Changed includes from quotes to angles.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.12 90/09/11 10:45:07 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d371 4
@


9.12
log
@Added function prototyping.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm.ken/RCS/vmSysCall.c,v 9.12 90/08/31 16:00:30 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d15 15
a29 15
#include "sprite.h"
#include "vm.h"
#include "vmInt.h"
#include "vmTrace.h"
#include "lock.h"
#include "user/vm.h"
#include "sync.h"
#include "sys.h"
#include "stdlib.h"
#include "string.h"
#include "fs.h"
#include "fsio.h"
#include "sys/mman.h"
#include "stdio.h"
#include "bstring.h"
@


9.11
log
@Added /dev/fb support.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm.mgb/RCS/vmSysCall.c,v 1.1 90/08/02 14:44:26 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
a17 1
#include "vmMachInt.h"
d28 2
d39 2
a40 1
static ReturnStatus VmMunmapInt();
d747 1
a747 1
    PrintSharedSegs(procPtr);
d921 1
a921 1
    PrintSharedSegs(procPtr);
a956 2
    Vm_PTE		*ptePtr;
    int			lastPage;
a1000 1
    int			page;
@


9.10
log
@Added Vm_Mprotect.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.9 90/06/27 11:14:48 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
a550 4
    if (BADALIGN(startAddr) || BADALIGN(fileAddr)) {
	printf("Vm_Mmap: Invalid start or offset\n");
	return VM_WRONG_SEG_TYPE;
    }
d569 27
@


9.9
log
@Fixed error messages.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.8 90/05/13 23:25:51 shirriff Exp $ SPRITE (Berkeley)";
d1120 65
@


9.8
log
@Added code for msync, mlock, muncore, etc.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.7 90/03/01 12:34:03 brent Exp Locker: shirriff $ SPRITE (Berkeley)";
d938 1
a938 1
	printf("Vm_Munmap: Invalid start or offset\n");
d982 1
a982 1
	printf("Vm_Munmap: Invalid start or offset\n");
d1026 1
a1026 1
	printf("Vm_Munmap: Invalid start or offset\n");
d1077 1
a1077 1
	printf("Vm_Munmap: Invalid start or offset\n");
@


9.7
log
@Fixed "var val val" print statement
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.6 89/11/27 14:42:27 shirriff Exp $ SPRITE (Berkeley)";
d40 15
d200 1
a200 1
     * virtual address spac.e
d549 3
a551 3
    dprintf("Vm_Mmap: Entering\n");
    if ( ((int)startAddr & (vm_PageSize-1)) ||
	    ((int)fileAddr & (vm_PageSize-1))) {
d598 1
d754 5
d885 1
a885 1
		 * Remove the mapped region.
d901 8
a924 1
/*ARGSUSED*/
d930 22
a951 1
    return SUCCESS;
d975 23
a997 1
    return SUCCESS;
a1005 1
 *	startAddr and length must be divisible by the page size.
d1021 15
a1044 1
 *	startAddr and length must be divisible by the page size.
d1048 2
a1049 2
 *	1 if the page is paged out, 2 if the page is clean, and
 *	3 if the page is dirty.
d1057 1
d1064 25
a1088 23
    return SUCCESS;
}

/*
 * Expansion of the segOffset and VmGetAddrPTEPtr macros for easier
 * debugging.
 */
#ifdef NOTDEF
segOffset(virtAddrPtr)
Vm_VirtAddr *virtAddrPtr;
{
    Vm_Segment *segPr;
    int off;
    struct Vm_SegProcList *sharedPr;

    segPr = virtAddrPtr->segPtr;
    off = segPr->offset;
    sharedPr = virtAddrPtr->sharedPtr;
    if (!vmShmDebug || virtAddrPtr->sharedPtr == (Vm_SegProcList *)NIL) {
	return off;
    } else {
	if (sharedPr == NULL) {
	    panic("null sharedPtr\n");
d1090 23
a1112 2
	    off = sharedPr->offset;
	    return off;
d1114 2
d1117 3
a1119 19
}

Vm_PTE * VmGetAddrPTEPtr(virtAddrPtr, page)
Vm_VirtAddr	*virtAddrPtr;
int		page;
{
    int segoff;
    Vm_PTE *res;
    int num;
    segoff = segOffset(virtAddrPtr);
    if (page-segoff < 0) {
	panic("page # too small: %d %d\n",page,segoff);
    } else if (page-segoff > virtAddrPtr->segPtr->ptSize) {
	panic("page # too large: %d %d %d\n",page,segoff,
		virtAddrPtr->segPtr->ptSize);
    }
    num = page-segoff;
    res = &virtAddrPtr->segPtr->ptPtr[num];
    return res;
a1120 1
#endif SEGOFFSETCODE
@


9.6
log
@Fixed typo VmMunmapInt -> vmMunmapInt.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.5 89/11/07 14:46:06 shirriff Exp $ SPRITE (Berkeley)";
d200 2
a201 2
 * on the current sun4 compiler/preprocessor set up.  This will change when
 * it's handled correctly.
d203 1
a203 1
#if !defined(sun4) && !defined(mips)
d206 1
a206 1
#define	SETVAR(var, val) SetVal("var val", val, (int *)&(var))
@


9.5
log
@Added stubs for Vm_Mlock, unlock, sync, incore.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.4 89/10/30 18:01:35 shirriff Exp $ SPRITE (Berkeley)";
d38 1
a38 1
static ReturnStatus vmMunmapInt();
@


9.4
log
@Lint changes.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.3 89/10/23 09:11:23 brent Exp Locker: shirriff $ SPRITE (Berkeley)";
d630 3
d878 102
@


9.3
log
@Updated calls to new FS modules
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 9.2 89/10/22 23:22:55 shirriff Exp $ SPRITE (Berkeley)";
d27 1
a29 1
static ReturnStatus	VmMunmapInt();
d31 1
a31 1
void		Fsio_StreamCopy();
d35 5
d554 1
a554 1
	Fs_Close(filePtr);
d564 1
a564 1
	Fs_Close(filePtr);
d571 1
a571 1
	Fs_Close(filePtr);
d588 1
a588 1
	Fs_Close(filePtr);
d643 1
a643 1
		Fs_Close(filePtr);
d863 1
a863 1
		VmDeleteSharedSegment(procPtr,segProcPtr);
d876 1
a876 1

@


9.2
log
@Added shared memory locks.
Added VmMunmapInt
Changed page invalidation from VmPageInvalidate to vmFlushSegment.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /c/src/kernel/vm.ken/RCS/vmSysCall.c,v 1.12 89/10/10 21:27:16 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d31 1
a31 1
void		Fs_StreamCopy();
d544 1
a544 1
    Fs_StreamCopy(streamPtr,&filePtr);
@


9.1
log
@Bunch of changes for shared memory.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /c/src/kernel/vm.ken/RCS/vmSysCall.c,v 1.7 89/09/12 17:02:07 shirriff Exp $ SPRITE (Berkeley)";
d20 1
d29 1
d244 1
d269 4
a272 1
	    VmFlushSegment(segPtr, lowPage, highPage);
a458 1

d508 2
a509 1
ReturnStatus
a528 1
    vmShmDebug = 1;
d535 1
a536 12
    if (procPtr->vmPtr->sharedSegs == (List_Links *)NIL) {
	dprintf("Vm_Mmap: New proc list\n");
	procPtr->vmPtr->sharedSegs = (List_Links *)
		malloc(sizeof(Vm_SegProcList));
	VmMach_SharedProcStart(procPtr);
	List_Init((List_Links *)procPtr->vmPtr->sharedSegs);
    }
    status = VmMach_SharedStartAddr(procPtr, length, &startAddr);
    if (status != SUCCESS) {
	printf("Vm_Mmap: VmMach_SharedStart failure\n");
	return status;
    }
d549 1
d552 1
a552 1
    printf("file: fileNumber %d size %d\n",attr.fileNumber, attr.size);
d559 1
d566 1
d570 17
a622 1
	dprintf("Vm_Mmap: Finished validating pages\n");
d637 2
d668 1
a668 1
    status=Vm_Munmap(startAddr,length,1);
d690 1
d696 1
d699 1
a700 4
    dprintf("HEAP->ptSize: %x HEAP->offset: %x STACK->offset %x\n",
	    procPtr->vmPtr->segPtrArray[VM_HEAP]->ptSize,
	    procPtr->vmPtr->segPtrArray[VM_HEAP]->offset,
	    procPtr->vmPtr->segPtrArray[VM_STACK]->offset);
d712 1
d726 29
d758 1
d777 2
a778 1
	dprintf("Vm_Munmap: eliminating %x to %x\n",(int)addr,(int)endAddr-1);
d796 1
a796 13
	    if (noError) {
		/*
		 * Move to next mapped segment, so we can keep unmapping.
		 */
		addr1 = endAddr;
		LIST_FORALL(procPtr->vmPtr->sharedSegs,
			(List_Links *)segProcPtr) {
		    if (segProcPtr->mappedStart > addr && 
			segProcPtr->mappedStart < addr1) {
			addr1 = segProcPtr->mappedStart;
		    }
		}
	    } else {
d800 11
d824 2
a825 3
		    
	    VmPageInvalidateRange(&virtAddr,min((int)segProcPtr->mappedEnd+1,
		    (int)endAddr)-(((int)virtAddr.page)<<vmPageShift));
d834 2
a835 1
		    newSegProcPtr = (Vm_SegProcList *)malloc(sizeof(Vm_SegProcList));
d861 3
d872 5
a876 1
#ifdef SEGOFFSETCODE
d897 19
@


9.0
log
@Changing version numbers.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 8.8 89/09/07 14:25:22 shirriff Exp Locker: douglis $ SPRITE (Berkeley)";
d29 1
d504 1
a504 1
Vm_Mmap(startAddr, length, prot, share, streamID, offset, mappedAddr)
d510 1
a510 1
    int		offset;		/* Offset into mapped file. */
a520 2
    Vm_VirtAddr		virtAddr;
    Fs_UserIDs		ids;
d523 1
d526 1
a526 1
	    ((int)offset & (vm_PageSize-1))) {
a529 1
    startAddr = VmMach_SharedStart(startAddr,length);
d531 12
d576 1
a576 1
    segPtr = (Vm_Segment *) NULL;
d586 2
a587 1
    pnum = 10288;
d589 1
a589 1
    if (segPtr == (Vm_Segment *)NULL) {
a594 8
	/*
	status = Fs_Open("/sprite/users/shirriff/tmp", FS_READ |
		FS_WRITE, FS_FILE, 0660, &filePtr);
	segTabPtr->sharedSegment = Vm_SegmentNew(VM_SHARED,filePtr,0,
		1,pnum,procPtr);
	Vm_ValidatePages(sharedSegment,pnum,pnum+(length>>vmPageShift)-1,
		FALSE,TRUE);
	*/
a598 3
		/*
		offset,length>>vmPageShift,pnum,procPtr);
		*/
d635 1
a635 1
	if (procPtr->vmPtr->sharedSegs == (List_Links *)NULL ||
a650 7
    VmVirtAddrParse(procPtr,startAddr, &virtAddr);
    if (virtAddr.segPtr != (Vm_Segment *)NULL) {
	dprintf("Vm_Mmap: Page already in use\n");
    }
    */

    /*
a662 6
    if (procPtr->vmPtr->sharedSegs == (List_Links *)NULL) {
	dprintf("Vm_Mmap: New proc list\n");
	procPtr->vmPtr->sharedSegs = (List_Links *)
		malloc(sizeof(Vm_SegProcList));
	List_Init((List_Links *)procPtr->vmPtr->sharedSegs);
    }
d670 2
d687 2
a688 2
    *mappedAddr = startAddr;
    return status ;
d734 1
a734 1
	if (procPtr->vmPtr->sharedSegs != (List_Links *)NULL) {
d749 1
a749 1
	if (segProcPtr == (Vm_SegProcList *)NULL) {
d823 24
@


8.8
log
@Changes for shared memory.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /c/src/kernel/vm.ken/RCS/vmSysCall.c,v 1.5 89/08/15 12:01:37 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
@


8.7
log
@Don't do weird macro if on mips.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 8.6 89/07/10 19:46:50 nelson Exp $ SPRITE (Berkeley)";
d18 1
d25 2
d28 4
d70 1
a70 1
 *	to synchronize when he is expanding his HEAP segment.
d449 3
d485 347
@


8.6
log
@Incorporated changes from DECWRL.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 8.5 89/05/23 11:28:36 douglis Exp $ SPRITE (Berkeley)";
d188 1
a188 1
#ifndef sun4
@


8.5
log
@don't allow vm_CanCOW to be turned off once it's on.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 8.4 89/05/21 18:25:35 mgbaker Exp Locker: douglis $ SPRITE (Berkeley)";
a433 2
	    printf("		       PMEGs=%d\n",
			vmTraceStats.machStats.pmegsChecked);
@


8.4
log
@checkin before spring cleaning
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 8.3 89/05/18 16:48:10 brent Exp Locker: mgbaker $ SPRITE (Berkeley)";
d309 9
a317 1
	    SETVAR(vm_CanCOW, arg);
@


8.3
log
@Fixed "var val" bug
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 8.2 88/12/29 14:58:49 mendel Exp $ SPRITE (Berkeley)";
d183 6
d190 3
@


8.2
log
@Eliminated use of CVT_ constants.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 8.1 88/12/04 15:51:38 ouster Exp Locker: mendel $ SPRITE (Berkeley)";
d183 1
a183 1
#define SETVAR(var, val) SetVal("var", val, (int *)&(var))
@


8.1
log
@Stop using obsolete header files.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 8.0 88/11/11 18:43:44 douglis Stable Locker: ouster $ SPRITE (Berkeley)";
d350 1
a350 1
	    char		hostNum[CVT_INT_BUF_SIZE];
@


8.0
log
@Changing version numbers.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 6.8 88/10/28 18:20:19 mlgray Exp Locker: douglis $ SPRITE (Berkeley)";
d22 1
a22 3
#include "byte.h"
#include "cvt.h"
#include "mem.h"
@


6.8
log
@Converted to new C library.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmSysCall.c,v 6.7 88/09/26 12:02:53 nelson Exp Locker: mlgray $ SPRITE (Berkeley)";
@


6.7
log
@Added ability to force all modified pages to be written out when
recycled.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 6.6 88/09/14 16:48:18 nelson Exp $ SPRITE (Berkeley)";
d283 1
a283 1
	    Byte_Copy(copySize, (Address) arg, buffer);
d289 1
a289 1
	    Byte_Copy(copySize, buffer, (Address) arg);
d355 1
a355 1
		Sys_Printf("VmCmd: Tracing already running.\n");
d359 1
a359 1
	    Sys_Printf("Vm_Cmd: Tracing started at %d times per second\n",
d363 1
a363 1
		vmTraceBuffer = (char *)Mem_Alloc(VM_TRACE_BUFFER_SIZE);
d365 1
a365 1
	    Byte_Zero(sizeof(vmTraceStats), (Address)&vmTraceStats);
d378 2
a379 2
	    Byte_Copy(sizeof(Vm_Stat), (Address)&vmStat, 
		      (Address)&traceStartPtr->startStats);
d384 3
a386 3
	    (void)String_Copy(VM_TRACE_FILE_NAME, fileName);
	    (void)Cvt_UtoA((unsigned) Sys_GetHostId(), 10, hostNum);
	    (void)String_Cat(hostNum, fileName);
d391 1
a391 2
		Sys_Panic(SYS_WARNING, 
		    "Vm_Cmd: Couldn't open trace file, reason %x\n", 
d401 4
a404 4
	    Byte_Copy(sizeof(Vm_TraceEnd), (Address)&vmStat,
		      (Address)&traceEnd.endStats);
	    Byte_Copy(sizeof(Vm_TraceStats), (Address)&vmTraceStats,
		      (Address)&traceEnd.traceStats);
d415 1
a415 1
	    Sys_Printf("Vm_Cmd: Tracing ended: Traces=%d Drops=%d\n",
d417 1
a417 1
	    Sys_Printf("		       Dumps=%d Bytes=%d.\n",
d419 1
a419 1
	    Sys_Printf("		       PMEGs=%d\n",
d460 1
a460 1
    Sys_Printf("%s val was %d, is %d\n", descript, *valPtr, newVal);
@


6.6
log
@Made it do the right thing when setting the penalty.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 6.5 88/08/30 22:22:17 nelson Exp $ SPRITE (Berkeley)";
d206 1
a206 1
    Vm_Command  command;
d424 6
d432 1
a432 2
            Sys_Panic(SYS_WARNING, "Vm_Cmd: Unknown command.\n");
	    status = GEN_INVALID_ARG;
@


6.5
log
@Cleaned up page pinning.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 6.4 88/08/27 19:44:13 nelson Exp $ SPRITE (Berkeley)";
d305 1
a305 1
	    if (arg < 0) {
@


6.4
log
@Fixed lint errors.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 6.3 88/08/24 19:38:51 nelson Exp $ SPRITE (Berkeley)";
d174 1
a174 3
    Vm_DeleteFromSeg(segPtr, firstPage, lastPage);

    return(SUCCESS);
@


6.3
log
@Bounded maximum growth of stack and allow the machine dependent side to
limit the number of segments.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 6.2 88/08/15 18:16:34 nelson Exp $ SPRITE (Berkeley)";
d386 3
a388 3
	    String_Copy(VM_TRACE_FILE_NAME, fileName);
	    Cvt_UtoA((unsigned) Sys_GetHostId(), 10, hostNum);
	    String_Cat(hostNum, fileName);
@


6.2
log
@Fixed lint errors and added some more tracing stuff for David Wood.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 6.1 88/08/11 19:28:48 nelson Exp $ SPRITE (Berkeley)";
d115 1
a115 1
     * mach_LastUserStackPage - 2.
d117 2
a118 1
    if (lastPage > mach_LastUserStackPage - 2) {
@


6.1
log
@Added more tracing info.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.19 88/07/29 11:28:57 nelson Exp $ SPRITE (Berkeley)";
d186 1
a186 1
#define SETVAR(var, val) SetVal("var", val, &(var))
d267 1
a267 1
        case VM_SET_CLOCK_INTERVAL:
d270 1
a348 1
	    int			tracesPerSecond;
d359 1
a359 1
	    tracesPerSecond = arg;
d380 2
a381 7
		      &traceStartPtr->startStats);
	    traceStartPtr->tracesPerSecond = tracesPerSecond;

	    vm_Tracing = TRUE;
	    vmTracesPerClock = tracesPerSecond;
	    vmTracesToGo = vmTracesPerClock;
	    vmClockSleep = timer_IntOneSecond / tracesPerSecond;
a383 2
	    vmTraceTime = 0;
	    VmClearSegTraceTimes();
d389 1
a389 2
	    status = Fs_Open(fileName,
			     FS_WRITE | FS_CREATE | FS_APPEND,
d395 2
a396 3
		vm_Tracing = FALSE;
		vmClockSleep = timer_IntOneSecond;
		vmTraceFilePtr = (Fs_Stream *)NIL;
@


6.0
log
@Changing version numbers.
@
text
@d381 1
@


5.19
log
@Remove references to symbols in end.o.  Use the normal loader symbols
instead.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.18 88/07/12 19:54:43 nelson Exp $ SPRITE (Berkeley)";
@


5.18
log
@Lint error fixes and more tracing.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.17 88/06/22 16:12:36 nelson Exp $ SPRITE (Berkeley)";
d351 1
a351 1
	    extern int		endText;
d374 1
a374 1
	    traceStartPtr->dataStartAddr = (Address)&endText;
@


5.17
log
@Added trace start rec.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.16 88/06/20 17:55:45 nelson Exp $ SPRITE (Berkeley)";
d24 2
d268 1
a268 1
	    SETVAR(vmClockSleep, arg * timer_IntOneSecond);
d366 1
a366 1
	    Byte_Zero(sizeof(vmTraceStats), &vmTraceStats);
d379 2
d382 1
a382 1
	    vmTracing = TRUE;
d402 1
a402 1
		vmTracing = FALSE;
d408 11
a418 2
	case VM_END_TRACING:
	    vmTracing = FALSE;
d432 1
@


5.16
log
@Added tracing stuff.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.15 88/05/05 18:03:28 nelson Exp $ SPRITE (Berkeley)";
d23 1
d348 4
d353 4
d359 1
a359 1
	    		arg);
d366 12
d383 1
a383 1
	    vmTraceNextByte = 0;
d386 15
a400 13
	    if (vmTraceFilePtr == (Fs_Stream *)NIL) {
		status = Fs_Open(vmTraceFileName, 
				 FS_WRITE | FS_CREATE | FS_APPEND,
				 FS_FILE, 0660, &vmTraceFilePtr);
		if (status != SUCCESS) {
		    Sys_Panic(SYS_WARNING, 
			"Vm_Cmd: Couldn't open trace file, reason %x\n", 
			status);
		    vmTracing = FALSE;
		    vmClockSleep = timer_IntOneSecond;
		    vmTraceFilePtr = (Fs_Stream *)NIL;
		    break;
		}
@


5.15
log
@Handles move of stuff from sys to mach.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.14 88/05/04 17:27:02 nelson Exp $ SPRITE (Berkeley)";
d18 1
d343 54
@


5.14
log
@Removed calls to old machine header files.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.13 88/03/08 14:25:26 douglis Exp $ SPRITE (Berkeley)";
d93 1
a93 1
    procPtr = Proc_GetCurrentProc(Sys_GetProcessorNumber());
d151 1
a151 1
    procPtr = Proc_GetCurrentProc(Sys_GetProcessorNumber());
@


5.13
log
@don't allocate & use the 8K buffer for Vm_Cmd if CLEAN is defined.
Also, return GEN_INVALID_ARG as well as panicking if the argument is
bad.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.12 88/02/02 18:27:16 nelson Exp $ SPRITE (Berkeley)";
a21 1
#include "machine.h"
@


5.12
log
@It now says what it is doing when a Vm_Cmd is executed.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.11 88/01/08 15:54:26 nelson Exp $ SPRITE (Berkeley)";
d176 2
d179 1
d270 1
d289 1
d345 1
@


5.11
log
@Added prefetch.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.10 88/01/04 14:00:53 nelson Exp $ SPRITE (Berkeley)";
d178 4
d250 1
a250 1
	    vmFreeWhenClean = (Boolean)arg;
d253 1
a253 1
	    vmMaxDirtyPages = arg;
d256 1
a256 1
	    vmMaxPageOutProcs = arg;
d259 1
a259 1
            vmPagesToCheck = arg;
d262 1
a262 1
	    vmClockSleep = arg * timer_IntOneSecond;
d265 1
a265 1
	    copySize = arg;
d294 1
a294 1
	    vm_CanCOW = arg;
d301 1
a301 1
		vmCurPenalty = -arg;
d303 3
a305 3
		vmFSPenalty = arg;
		vmCurPenalty = (vmStat.fsMap - vmStat.fsUnmap) / 
					vmPagesPerGroup * vmFSPenalty;
d312 2
a313 2
	    vmNumPageGroups = arg;
	    vmPagesPerGroup = numPages / vmNumPageGroups;
d315 2
a316 2
	    vmCurPenalty = curGroup * vmFSPenalty;
	    vmBoundary = (curGroup + 1) * vmPagesPerGroup;
d320 1
a320 1
	    vmAlwaysRefuse = arg;
d323 1
a323 1
	    vmAlwaysSayYes = arg;
d330 1
a330 1
	    vmCORReadOnly = arg;
d333 1
a333 1
	    vmPrefetch = arg;
d336 1
a336 1
	    vmUseFSReadAhead = arg;
d344 26
@


5.10
log
@Added ability to measure the number of copy-on-ref pages that eventually
got modified.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.9 87/12/31 11:09:46 nelson Exp $ SPRITE (Berkeley)";
d327 6
@


5.9
log
@Added ability to set the FS penalty variables.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.8 87/12/18 15:17:11 nelson Exp $ SPRITE (Berkeley)";
d324 3
@


5.8
log
@Added a flush segment feature.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.7 87/12/17 18:46:41 nelson Exp $ SPRITE (Berkeley)";
a177 8
extern	int		vmMaxPageOutProcs;
extern	int		vmPagesToCheck;
extern	unsigned int	vmClockSleep;
extern	Boolean		vmForceRef;
extern	Boolean		vmForceSwap;
extern	int		vmMaxDirtyPages;
extern	Boolean		vmFreeWhenClean;

d243 1
a259 6
        case VM_FORCE_REF:
            vmForceRef = arg;
            break;
	case VM_FORCE_SWAP:
	    vmForceSwap = arg;
	    break;
d291 33
@


5.7
log
@Added a command to change whether should free dirty pages after cleaning
them or not.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.6 87/12/15 19:17:31 nelson Exp $ SPRITE (Berkeley)";
d220 32
@


5.6
log
@Changed the way return the count of dirty pages.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.5 87/12/15 18:24:46 nelson Exp $ SPRITE (Berkeley)";
d184 1
d219 3
@


5.5
log
@Added ability to determine the number of dirty pages.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.4 87/12/15 15:22:10 nelson Exp $ SPRITE (Berkeley)";
d209 1
d213 5
a217 1
	    vmStat.numModifiedPages = VmCountDirtyPages();
@


5.4
log
@Comments.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.3 87/12/11 13:30:01 nelson Exp $ SPRITE (Berkeley)";
d211 3
@


5.3
log
@New VM system where put machine dependent VM stuff into the SUN module.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.2 87/11/20 18:29:23 nelson Exp $ SPRITE (Berkeley)";
d46 1
a46 4
    if (Vm_CopyOut(4, (Address) &pageSize, (Address) pageSizePtr) != SUCCESS) {
	return(SYS_ARG_NOACCESS);
    }
    return(SUCCESS);
d80 1
a80 1
 *	The page tables are modified.
d138 1
a138 1
 *	The page tables are modified.
d183 1
d211 3
@


5.2
log
@More copy-on-write stuff
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.1 87/10/22 14:51:25 nelson Exp $ SPRITE (Berkeley)";
d21 2
a22 1
#include "machineConst.h"
d44 1
a44 1
    int			pageSize = VM_PAGE_SIZE;
d98 2
a99 2
    firstPage = (unsigned) (address) >> VM_PAGE_SHIFT;
    lastPage = (unsigned) ((int) address + size - 1) >> VM_PAGE_SHIFT;
d115 1
a115 1
     * MACH_LAST_USER_STACK_PAGE - 2.
d117 1
a117 1
    if (lastPage > MACH_LAST_USER_STACK_PAGE - 2) {
d156 2
a157 2
    firstPage = (unsigned) (address) >> VM_PAGE_SHIFT;
    lastPage = (unsigned) ((int) address + size - 1) >> VM_PAGE_SHIFT;
d173 1
a173 1
    VmDeleteFromSeg(segPtr, firstPage, lastPage);
d232 1
a232 1
	    Vm_CopyIn(copySize, (Address) arg, buffer);
d235 1
a235 1
	    Vm_CopyOut(copySize, buffer, (Address) arg);
d251 1
a251 1
	    		((int) vmMemEnd - MACH_KERNEL_START) / VM_PAGE_SIZE;
@


5.1
log
@Changed proc table so that it points to VM stuff that is defined here.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 5.0 87/08/11 10:53:39 sprite Exp $ SPRITE (Berkeley)";
d32 1
a32 1
 *	The size of a hardware page.
d35 1
a35 1
 *	None.
a38 1

d175 90
@


5.0
log
@First Sprite native copy
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: vmSysCall.c,v 4.1 87/02/26 12:26:35 nelson Exp $ SPRITE (Berkeley)";
d101 1
a101 1
    segPtr = (Vm_Segment *) procPtr->segPtrArray[VM_HEAP];
d159 1
a159 1
    segPtr = (Vm_Segment *) procPtr->segPtrArray[VM_HEAP];
@
