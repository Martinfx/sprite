head     9.12;
branch   ;
access   ;
symbols  ds3100:9.12 sun3:9.12 sprited:9.11.1 sun4nw:9.11 symm:9.11 spur:9.11 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.12
date     92.05.07.17.06.57;  author kupfer;  state Exp;
branches ;
next     9.11;

9.11
date     91.07.02.10.51.44;  author mendel;  state Exp;
branches 9.11.1.1;
next     9.10;

9.10
date     90.10.19.15.43.35;  author mendel;  state Exp;
branches ;
next     9.9;

9.9
date     90.10.10.11.04.43;  author mendel;  state Exp;
branches ;
next     9.8;

9.8
date     90.10.08.16.05.18;  author mendel;  state Exp;
branches ;
next     9.7;

9.7
date     90.06.28.14.13.24;  author jhh;  state Exp;
branches ;
next     9.6;

9.6
date     90.02.16.16.52.28;  author brent;  state Exp;
branches ;
next     9.5;

9.5
date     90.02.13.16.06.41;  author shirriff;  state Exp;
branches ;
next     9.4;

9.4
date     89.12.14.13.10.22;  author brent;  state Exp;
branches ;
next     9.3;

9.3
date     89.11.27.13.18.35;  author jhh;  state Exp;
branches ;
next     9.2;

9.2
date     89.10.23.12.32.27;  author brent;  state Exp;
branches ;
next     9.1;

9.1
date     89.10.02.23.17.08;  author jhh;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.05.11;  author douglis;  state Stable;
branches ;
next     8.6;

8.6
date     89.08.21.15.25.20;  author mendel;  state Exp;
branches ;
next     8.5;

8.5
date     89.08.15.18.42.37;  author rab;  state Exp;
branches ;
next     8.4;

8.4
date     89.07.18.13.11.35;  author jhh;  state Exp;
branches ;
next     8.3;

8.3
date     89.03.08.12.48.15;  author jhh;  state Exp;
branches ;
next     8.2;

8.2
date     89.02.01.12.50.34;  author brent;  state Exp;
branches ;
next     8.1;

8.1
date     89.01.05.15.20.48;  author brent;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.19.15;  author douglis;  state Stable;
branches ;
next     7.0;

7.0
date     88.11.07.14.47.19;  author brent;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.15.38;  author brent;  state Stable;
branches ;
next     1.2;

1.2
date     88.08.05.14.14.53;  author douglis;  state Exp;
branches ;
next     1.1;

1.1
date     88.04.04.10.31.54;  author brent;  state Exp;
branches ;
next     ;

9.11.1.1
date     91.11.15.15.42.12;  author kupfer;  state Exp;
branches ;
next     ;


desc
@Definitions for the disk module
@


9.12
log
@Fix comment for Fsdm_FileDescriptor.fileType.
@
text
@/* 
 * fsdm.h --
 *
 *	Disk management module -- Definitions related to the storage of 
 *	filesystems on a disk.
 *
 * Copyright 1990 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 *
 * $Header: /sprite/src/kernel/Cvsroot/kernel/fsdm/fsdm.h,v 9.11 91/07/02 10:51:44 mendel Exp $ SPRITE (Berkeley)
 */

#ifndef _FSDM
#define _FSDM

#ifdef KERNEL
#include <dev.h>
#include <fslcl.h>
#include <fsioFile.h>
#include <fscache.h>
#else
#include <kernel/dev.h>
#endif

/*
 * A disk is partitioned into domains that are managed separately.
 * Each domain takes up an even number of cylinders.
 * An array of Fsdm_DiskPartition's is kept on the disk to define how the
 * disk is divided into domains.
 *
 * FSDM_NUM_DISK_PARTS defines how many different domains there could be
 *	on a disk.  Generally, not all the domains are defined.  
 */
#define FSDM_NUM_DISK_PARTS	8

typedef struct Fsdm_DiskPartition {
    int firstCylinder;	/* The first cylinder in the partition. */
    int numCylinders;	/* The number of cylinders in the partition.  Set
			 * this to zero for unused partitions. */
} Fsdm_DiskPartition;

/*
 * The first few blocks of each domain are reserved.  They contain a copy
 * of the Disk Header, a copy of the boot program, and finally Domain
 * Header information.  The Disk Header defines the division of the disk's
 * cylinders into domains,  and the layout of the rest of the reserved
 * blocks.  The Disk Header is replicated on the zero'th sector of each
 * domain. For the Sun implementation, the boot program is expected to
 * start in sector #1. The boot program on
 * the zero'th cylinder of the disk is used automatically, although other
 * boot program locations can be specified manually.
 *
 */

#define FSDM_MAX_BOOT_SECTORS	128
#define FSDM_BOOT_SECTOR_INC	16

typedef struct Fsdm_DiskHeader {
    char asciiLabel[128];	/* Human readable string used for manufacturer's
				 * model number and redudant geometry info */
    /*
     * Padding is used to shove the following data down so the check sum
     * occurs at the end of the sector.  The 10 in the declaration indicates
     * how may integer fields there are in this struct.
     */
    char pad[DEV_BYTES_PER_SECTOR - 128 -
	     (12 + FSDM_NUM_DISK_PARTS * 2) * sizeof(int)];
    unsigned int magic;		/* Magic number used for consistency check */
    int numCylinders;		/* The number of cylinders on the disk */
    int numAltCylinders;	/* # of alternates used for bad blocks */
    int numHeads;		/* # of surfaces on the disk */
    int numSectors;		/* # of sectors per track */
    int bootSector;		/* The starting sector of the boot program.
				 * This is usually 1. */
    int numBootSectors;		/* The number of sectors in the boot program.
				 * This is usually 15. */
    int summarySector;		/* Index of sector used for summary info */
    int domainSector;		/* The sector where the domain header starts.*/
    int numDomainSectors;	/* The number of sectors taken up by the
				 * domain header */
    int partition;		/* Index of the partition that this copy of
				 * the Disk Header is on.  Each partition has
				 * a copy of the Disk Header */
    Fsdm_DiskPartition map[FSDM_NUM_DISK_PARTS];	/* Partition map */
    int checkSum;		/* Checksum such that an XOR of all the ints
				 * in the sector results in the same thing
				 * as the magic number */
} Fsdm_DiskHeader;

#define FSDM_DISK_MAGIC	(unsigned int)0xD15CFEBA	/* 'disk fever' */




/*
 * A File Descriptor is kept on disk for every file in a domain.  It
 * contains administrative information and also the indexing structure
 * used to access the file's data blocks.
 */

#define FSDM_NUM_DIRECT_BLOCKS	10
#define FSDM_NUM_INDIRECT_BLOCKS	3
#define	FSDM_INDICES_PER_BLOCK	1024

#define FSDM_MAX_FILE_DESC_SIZE	128
#define FSDM_FILE_DESC_PER_BLOCK	(FS_BLOCK_SIZE / FSDM_MAX_FILE_DESC_SIZE)

typedef struct Fsdm_FileDescriptor {
    unsigned short magic;/* FSDM_FD_MAGIC, for disk consistency check */
    short flags;	/* FSDM_FD_FREE, FSDM_FD_ALLOC, FSDM_FD_RESERVED */
    short fileType;	/* FS_FILE, FS_DIRECTORY, FS_PIPE, FS_DEVICE,
			 * FS_SYMLINK, FS_RMTLINK */
    short permissions;	/* 9 permission bits plus flags for set user ID
			 * upon execution */
    int uid;		/* ID of owner */
    int gid;		/* Group ID of owner */
    int lastByte;	/* The number of bytes in the file */
    int lastByteXtra;	/* (Some day we may have 64 bit sizes?) */
    int firstByte;	/* For named pipes, offset of the first valid byte */
    int userType;	/* Information about what sort of user file it is. */
    int numLinks;	/* Number of directory references to the file */
    int devServerID;	/* ID of the host that controls the device */
    short devType;	/* For devices, their type.  For others this is the
			 * type of disk the file is stored on */
    unsigned short devUnit;	/* For devices, their unit number.  For others,
			 * the unit indicates the disk partition */
    /*
     * All times in seconds since Jan 1 1970, Greenwich time.
     */

    int createTime;	/* Time the file was created. */
    int accessTime;	/* Time of last access.  This is not updated by
			 * directory traversals. */
    int descModifyTime;	/* Time of last modification to the file descriptor */
    int dataModifyTime;	/* Time of last modification to the file data */

    /*
     * Pointers to the data blocks of the file.   The pointers are really
     * indexes into the array of blocks stored in the data block section
     * of a partition.  The direct array contains the indexes of the first
     * several blocks of the files.  The indirect indexes are interpreted
     * as follows.  The first indirect index is the index of a block that
     * contains 1 K indexes of data blocks.  This is called a singly-indirect
     * block.  The second indirect index is the index of a block that
     * contains 1 K indexes of singly-indirect blocks.  This is called
     * a doubly-indirect block.  Finally, the third indirect index is the index
     * of a block that contains 1 K indexes of doubly-indirect blocks.
     * Each data block contains 4Kbytes, so this indexing scheme supports
     * files up to 40K + 4Meg + 4Gig + 4Pig bytes.
     *
     * The values of the direct and indirect indexes are indexes of
     * fragments, ie. 1k pieces.  All the but the last index point to the
     * beginning of a filesystem block, ie. 4K.  The last valid direct
     * block may point to a fragment, and fragments can start on 1K
     * boundaries.
     */

    int direct[FSDM_NUM_DIRECT_BLOCKS];
    int indirect[FSDM_NUM_INDIRECT_BLOCKS];
    int numKbytes;	/* The number of KiloBytes acutally allocated towards
			 * the file on disk.  This accounts for fragments
			 * and indirect blocks. */
    int version;	/* Version number of the handle for the file.  Needed
			 * on disk for recovery purposes (client re-open */
} Fsdm_FileDescriptor;

/*
 * Magic number and flag definitions for file descriptors.
 *	FSDM_FD_FREE	The file descriptor is unused
 *	FSDM_FD_ALLOC	The file descriptor is used for a file.
 *	FSDM_FD_RESERVED The file descriptor is reserved and not for use.
 *	FSDM_FD_DIRTY	The file descriptor has been modified since the
 *			last time that it was written to disk.
 *  	FSDM_FD_PERMISSIONS_DIRTY  Premissions field (permissions) have be
 *				    changed since the descriptor last written.
 *  	FSDM_FD_SIZE_DIRTY         Size fields (lastByte lastByteXtra,
 *				   firstByte, numBlocks) have been changed
 *				   size the descriptor was last written.
 *  	FSDM_FD_USERTYPE_DIRTY     The user type field has changed since the
 *				   descriptor was last written.
 *  	FSDM_FD_LINKS_DIRTY  	   The number of links has changed since the
 *				   descriptor was written.
 *	FSDM_FD_ACCESSTIME_DIRTY   The access time has changed since the
 *				   descriptor was written.
 *	FSDM_FD_MODTIME_DIRTY	   The modify time has changed since the
 *				   descriptor was written.
 *	FSDM_FD_INDEX_DIRTY	   The file index fields (direct, indirect) 
 *				   have changed since the descriptor was
 *				   written.
 *	FSDM_FD_VERSION_DIRTY	   The file version number changed since the
 *				   descriptor was written.
 *	FSDM_FD_OTHERS_DIRTY	   Some other (not listed above) field has
 *				   changed since the descriptor was written.
 *
 */

#define FSDM_FD_MAGIC	(unsigned short)0xF1D0
#define FSDM_FD_FREE	0x1
#define FSDM_FD_ALLOC	0x2
#define FSDM_FD_RESERVED	0x4
#define FSDM_FD_DIRTY		    0xFF8
#define	FSDM_FD_PERMISSIONS_DIRTY   0x010	
#define	FSDM_FD_SIZE_DIRTY	    0x020
#define	FSDM_FD_USERTYPE_DIRTY	    0x040
#define	FSDM_FD_LINKS_DIRTY	    0x080
#define	FSDM_FD_ACCESSTIME_DIRTY    0x100
#define	FSDM_FD_MODTIME_DIRTY	    0x200
#define	FSDM_FD_INDEX_DIRTY	    0x400
#define	FSDM_FD_VERSION_DIRTY	    0x800
#define	FSDM_FD_OTHERS_DIRTY	    0x008

/*
 * The special index value FSDM_NIL_INDEX for direct[] and indirect[]
 * means there is no block allocated for that index.
 */ 
#define FSDM_NIL_INDEX	-1

/*
 * Types of indexing.  Order is important here because the indirect and
 * double indirect types can be used to index into the indirect block 
 * pointers in the file descriptor.
 */

#define	FSDM_INDIRECT		0 
#define	FSDM_DBL_INDIRECT		1
#define	FSDM_DIRECT		2

/*
 * The bad block file, the root directory of a domain and the lost and found 
 * directory have well known file numbers.
 */
#define FSDM_BAD_BLOCK_FILE_NUMBER	1
#define FSDM_ROOT_FILE_NUMBER		2
#define FSDM_LOST_FOUND_FILE_NUMBER	3

/*
 * Directry change log operations and flags.
 *	Operations:
 * FSDM_LOG_CREATE		Creating a new object in a directory.	
 * FSDM_LOG_UNLINK		Unlinking an object from a directory.	
 * FSDM_LOG_LINK		Linking to an existing object.	
 * FSDM_LOG_RENAME_DELETE	Deleting an object as part of a rename.	
 * FSDM_LOG_RENAME_LINK		Linking to an object as part of a rename.
 * FSDM_LOG_RENAME_UNLINK	Unlinking an object as part of a rename.
 * FSDM_LOG_OP_MASK		Mask out the log operation.
 * 
 * Flags:
 *
 * FSDM_LOG_START_ENTRY		Start of change entry
 * FSDM_LOG_END_ENTRY		End of change entry
 * FSDM_LOG_STILL_OPEN		File is still open after last unlink.
 * FSDM_LOG_IS_DIRECTORY	File is a directory.
 */

#define	FSDM_LOG_CREATE		1
#define	FSDM_LOG_UNLINK		2
#define	FSDM_LOG_LINK		3
#define	FSDM_LOG_RENAME_DELETE	4
#define	FSDM_LOG_RENAME_LINK	5
#define	FSDM_LOG_RENAME_UNLINK	6
#define	FSDM_LOG_OP_MASK	0xff

#define	FSDM_LOG_START_ENTRY	0x100
#define	FSDM_LOG_END_ENTRY	0x200
#define	FSDM_LOG_STILL_OPEN	0x1000
#define FSDM_LOG_IS_DIRECTORY	0x2000

#ifdef KERNEL
/*
 * Structure for each domain.
 */

typedef struct Fsdm_Domain {
    char	*domainPrefix;	  /* Prefix of this domain. */
    int		domainNumber;	   /* Number of this domain. */
    int		flags;		  /* Flags defined below. */		
    int		refCount;	  /* Number of active users of the domain. */
    Sync_Condition condition;	  /* Condition to wait on. */
    Fscache_Backend *backendPtr;  /* Cache backend for this domain. */
    struct Fsdm_DomainOps *domainOpsPtr;
				  /* Domain specific data and routines. */
    ClientData	clientData;	  /* Domain specific info. */
} Fsdm_Domain;
/*
 * Structure defining the domain specific routines and data.
 */
typedef struct Fsdm_DomainOps {
    ReturnStatus (*attachDisk) _ARGS_((Fs_Device *devicePtr, 
					char *localName, int flags, 
					int *domainNumPtr));
				     /* Attach and install the domain from 
				      * the specified disk partition. */
    ReturnStatus (*detachDisk) _ARGS_((Fsdm_Domain *domainPtr));
				     /* Detach  the domain from 
				      * the specified disk partition. */
    ReturnStatus (*writeBack) _ARGS_((Fsdm_Domain *domainPtr, 
				      Boolean shutdown));   
				     /* Writeback the internal data structures
				      * for the specified domain. */
    ReturnStatus (*rereadSummary) _ARGS_((Fsdm_Domain *domainPtr));
				    /* Reread the domain info from disk. */

    ReturnStatus (*domainInfo) _ARGS_ ((Fsdm_Domain *domainPtr, 
				Fs_DomainInfo *domainInfoPtr));
				     /* Return a Fs_DomainInfo for the 
				      * specified domain.  */
    ReturnStatus (*blockAlloc) _ARGS_((Fsdm_Domain *domainPtr, 
				      Fsio_FileIOHandle *handlePtr, int offset,
				      int numBytes, int flags, 
				      int *blockAddrPtr, Boolean *newBlockPtr));
					/* Allocate a block for a file. */
    ReturnStatus (*getNewFileNumber) _ARGS_((Fsdm_Domain *domainPtr, 
					    int dirFileNum, 
					    int *fileNumberPtr));

					/* Allocate a file number of a new
					 * file.  */
    ReturnStatus (*freeFileNumber)  _ARGS_((Fsdm_Domain *domainPtr, 
					    int fileNumber));
					/* Deallocate a file number. */

    ReturnStatus (*fileDescInit) _ARGS_((Fsdm_Domain *domainPtr, 
					int fileNumber, int type, 
					int permissions, int uid, int gid, 
					Fsdm_FileDescriptor *fileDescPtr));
				     /* Initialize a new file descriptor. */

    ReturnStatus (*fileDescFetch)  _ARGS_((Fsdm_Domain *domainPtr, 
					   int fileNumber, 
					   Fsdm_FileDescriptor *fileDescPtr));
				     /* Fetch a file descriptor from disk. */

    ReturnStatus (*fileDescStore)  _ARGS_((Fsdm_Domain *domainPtr, 
					   Fsio_FileIOHandle *handlePtr, 
					   int fileNumber, 
					   Fsdm_FileDescriptor *fileDescPtr,
					   Boolean forceOut));
				     /* Store a file descriptor back into it's
				      * disk block. */
    ReturnStatus (*fileBlockRead) _ARGS_((Fsdm_Domain *domainPtr, 
					 Fsio_FileIOHandle *handlePtr, 
					 Fscache_Block *blockPtr));

    ReturnStatus (*fileBlockWrite) _ARGS_((Fsdm_Domain *domainPtr, 
					   Fsio_FileIOHandle *handlePtr,
					   Fscache_Block *blockPtr));

    ReturnStatus (*fileTrunc)  _ARGS_((Fsdm_Domain *domainPtr, 
					Fsio_FileIOHandle *handlePtr, 
					int size, Boolean delete));
				     /* Truncate the file to the specifed 
				      * length. */
    ClientData	(*dirOpStart) _ARGS_((Fsdm_Domain *domainPtr, int opFlags,
				char *name, int nameLen, int fileNumber, 
				Fsdm_FileDescriptor *fileDescPtr, 
				int dirFileNumber, int dirOffset, 
				Fsdm_FileDescriptor *dirFileDescPtr));
				     /* Directory operation start. */	

    void	(*dirOpEnd) _ARGS_((Fsdm_Domain *domainPtr,
				    ClientData clientData, ReturnStatus status,
				    int opFlags, char *name, int nameLen,
				    int fileNumber, 
				    Fsdm_FileDescriptor *fileDescPtr, 
				    int dirFileNumber,	int dirOffset, 
				    Fsdm_FileDescriptor *dirFileDescPtr));   
				     /* Directory operation end. */	

} Fsdm_DomainOps;



/*
 * Domain flags used for two stage process of detaching a domain:
 *
 *    FSDM_DOMAIN_GOING_DOWN	This domain is being detached.
 *    FSDM_DOMAIN_DOWN		The domain is detached.
 *    FSDM_DOMAIN_ATTACH_BOOT   The domain was attached by the kernel
 *				during boot.
 */
#define	FSDM_DOMAIN_GOING_DOWN	0x1
#define	FSDM_DOMAIN_DOWN 		0x2
#define FSDM_DOMAIN_ATTACH_BOOT		0x4


/*
 * Whether or not to keep information about file I/O by user file type.
 */
extern Boolean fsdmKeepTypeInfo;




/*
 * Declarations for the file descriptor allocation routines.
 */
extern ReturnStatus Fsdm_FileDescInit _ARGS_((Fsdm_Domain *domainPtr, 
		int fileNumber, int type, int permissions, int uid, int gid, 
		Fsdm_FileDescriptor *fileDescPtr));
extern ReturnStatus Fsdm_FileDescFetch _ARGS_((Fsdm_Domain *domainPtr, 
		int fileNumber, Fsdm_FileDescriptor *fileDescPtr));
extern ReturnStatus Fsdm_FileDescStore _ARGS_((Fsio_FileIOHandle *handlePtr,
		Boolean forceOut));

extern ReturnStatus Fsdm_GetNewFileNumber _ARGS_((Fsdm_Domain *domainPtr, 
		int dirFileNum, int *fileNumberPtr));
extern ReturnStatus Fsdm_FreeFileNumber _ARGS_((Fsdm_Domain *domainPtr, 
		int fileNumber));
extern ReturnStatus Fsdm_FileDescWriteBack _ARGS_((Fsio_FileIOHandle *handlePtr,		Boolean doWriteBack));
extern ReturnStatus Fsdm_FileTrunc _ARGS_((Fs_HandleHeader *hdrPtr, 
		int size, Boolean delete));
extern ReturnStatus Fsdm_BlockAllocate _ARGS_((Fs_HandleHeader *hdrPtr, 
		int offset, int numBytes, int flags, int *blockAddrPtr, 
		Boolean *newBlockPtr));


extern ReturnStatus Fsdm_UpdateDescAttr _ARGS_((Fsio_FileIOHandle *handlePtr, 
		Fscache_Attributes *attrPtr, int dirtyFlags));

/*
 * Routines for attaching/detaching disk.
 */
extern ReturnStatus Fsdm_AttachDiskByHandle _ARGS_((
		Fs_HandleHeader *ioHandlePtr, char *localName, int flags));
extern ReturnStatus Fsdm_AttachDisk _ARGS_((Fs_Device *devicePtr, 
		char *localName, int flags));
extern ReturnStatus Fsdm_DetachDisk _ARGS_((char *prefixName));

/*
 * Routines to manipulate domains.
 */
extern Fsdm_Domain *Fsdm_DomainFetch _ARGS_((int domain, Boolean dontStop));
extern void Fsdm_DomainRelease _ARGS_((int domainNum));
extern ReturnStatus Fsdm_InstallDomain _ARGS_((int domainNumber, 
			int serverID, char *prefixName, int flags, 
			Fsdm_Domain **domainPtrPtr));
extern ReturnStatus Fsdm_DomainInfo _ARGS_((Fs_FileID *fileIDPtr, 
			Fs_DomainInfo *domainInfoPtr));
extern void Fsdm_DomainWriteBack _ARGS_((int domain, Boolean shutdown, 
			Boolean detach));
extern ReturnStatus Fsdm_RereadSummaryInfo _ARGS_((char *prefixName));
extern ReturnStatus Fsdm_FileBlockRead _ARGS_((Fs_HandleHeader *hdrPtr,
			Fscache_Block *blockPtr, 
			Sync_RemoteWaiter *remoteWaitPtr));
extern ReturnStatus Fsdm_FileBlockWrite _ARGS_((Fs_HandleHeader *hdrPtr, 
			Fscache_Block *blockPtr, int flags));

/*
 * Directory log routines.
 */
extern ClientData Fsdm_DirOpStart _ARGS_((int opFlags, 
		Fsio_FileIOHandle *dirHandlePtr, int dirOffset, char *name, 
		int nameLen, int fileNumber, int type, 
		Fsdm_FileDescriptor *fileDescPtr));
extern void Fsdm_DirOpEnd _ARGS_((int opFlags, Fsio_FileIOHandle *dirHandlePtr,
		int dirOffset, char *name, int nameLen, int fileNumber,
		int type, Fsdm_FileDescriptor *fileDescPtr,
		ClientData clientData, ReturnStatus status));

/*
 * Miscellaneous
 */
extern int Fsdm_FindFileType _ARGS_((Fscache_FileInfo *cacheInfoPtr));
extern void Fsdm_Init _ARGS_((void));
extern Boolean Fsdm_IsSunLabel _ARGS_((Address buffer));
extern Boolean Fsdm_IsSpriteLabel _ARGS_((Address buffer));
extern Boolean Fsdm_IsDecLabel _ARGS_((Address buffer));
extern void Fsdm_RegisterDiskManager _ARGS_((char *typeName, 
		ReturnStatus (*attachProc)(Fs_Device *devicePtr,
					   char *localName, int flags, 
					   int *domainNumPtr)));

#endif /* KERNEL */

#endif /* _FSDM */
@


9.11
log
@Added define FSDM_LOG_IS_DIRECTORY.
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fsdm/RCS/fsdm.h,v 9.10 90/10/19 15:43:35 mendel Exp Locker: mendel $ SPRITE (Berkeley)
d117 1
a117 1
    short fileType;	/* FS_REGULAR, FS_DIRECTORY, FS_PIPE, FS_DEVICE,
@


9.11.1.1
log
@Initial branch for Sprite server.
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/Cvsroot/kernel/fsdm/fsdm.h,v 9.11 91/07/02 10:51:44 mendel Exp $ SPRITE (Berkeley)
@


9.10
log
@Added ifdef KERNEL so that file can safely be included by user level 
programs.
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fsdm/RCS/fsdm.h,v 9.9 90/10/10 11:04:43 mendel Exp $ SPRITE (Berkeley)
d258 1
d272 1
a272 1

@


9.9
log
@Fixed include files to work with user programs.
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fsdm/RCS/fsdm.h,v 9.8 90/10/08 16:05:18 mendel Exp Locker: mendel $ SPRITE (Berkeley)
a28 3
#include <kernel/fslcl.h>
#include <kernel/fsioFile.h>
#include <kernel/fscache.h>
d225 50
a389 9
/*
 * Types of indexing.  Order is important here because the indirect and
 * double indirect types can be used to index into the indirect block 
 * pointers in the file descriptor.
 */

#define	FSDM_INDIRECT		0 
#define	FSDM_DBL_INDIRECT		1
#define	FSDM_DIRECT		2
a390 1

a395 33
/*
 * The bad block file, the root directory of a domain and the lost and found 
 * directory have well known file numbers.
 */
#define FSDM_BAD_BLOCK_FILE_NUMBER	1
#define FSDM_ROOT_FILE_NUMBER		2
#define FSDM_LOST_FOUND_FILE_NUMBER	3

/*
 * Directry change log operations and flags.
 *	Operations:
 * FSDM_LOG_CREATE		Creating a new object in a directory.	
 * FSDM_LOG_UNLINK		Unlinking an object from a directory.	
 * FSDM_LOG_LINK		Linking to an existing object.	
 * FSDM_LOG_RENAME_DELETE	Deleting an object as part of a rename.	
 * FSDM_LOG_RENAME_LINK		Linking to an object as part of a rename.
 * FSDM_LOG_RENAME_UNLINK	Unlinking an object as part of a rename.
 * FSDM_LOG_OP_MASK		Mask out the log operation.
 * 
 * Flags:
 *
 * FSDM_LOG_START_ENTRY		Start of change entry
 * FSDM_LOG_END_ENTRY		End of change entry
 * FSDM_LOG_STILL_OPEN		File is still open after last unlink.
 */

#define	FSDM_LOG_CREATE		1
#define	FSDM_LOG_UNLINK		2
#define	FSDM_LOG_LINK		3
#define	FSDM_LOG_RENAME_DELETE	4
#define	FSDM_LOG_RENAME_LINK	5
#define	FSDM_LOG_RENAME_UNLINK	6
#define	FSDM_LOG_OP_MASK	0xff
a396 3
#define	FSDM_LOG_START_ENTRY	0x100
#define	FSDM_LOG_END_ENTRY	0x200
#define	FSDM_LOG_STILL_OPEN	0x1000
d477 4
a480 1
#endif _FSDM
@


9.8
log
@Major change: New domain independent interface. Removed OFS code from
module. 
Fixed include files to use <> rather than "".
Added function prototyping.  
Modified to use new cache backend interface.
Changed file name to start with "fsdm".
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fs.mendel/RCS/fsdm.h,v 1.1 90/01/16 17:12:02 mendel Exp Locker: mendel $ SPRITE (Berkeley)
d22 1
d27 6
@


9.7
log
@added support for not re-checking a disk upon reboot.
@
text
@d1 1
a1 1
/*
d4 2
a5 4
 *	Definitions related to the storage of a filesystem on a disk.
 *
 * Copyright 1986 Regents of the University of California
 * All rights reserved.
d7 8
d16 1
a16 1
 * $Header: /sprite/src/kernel/fsdm/RCS/fsdm.h,v 9.6 90/02/16 16:52:28 brent Exp $ SPRITE (Berkeley)
d22 4
a25 3
#include "dev.h"
#include "fslcl.h"
#include "fsioFile.h"
d54 1
a94 60
/*
 * FSDM_NUM_DOMAIN_SECTORS is the standard number of sectors taken
 * up by the domain header.
 */
#define FSDM_NUM_DOMAIN_SECTORS	((sizeof(Fsdm_DomainHeader)-1) / DEV_BYTES_PER_SECTOR + 1)


/*
 * ONE sector of summary information is kept on disk.  This records things
 * like the number of free blocks and free file descriptors.  This info
 * is located just before the domain header.
 */
#define FSDM_SUMMARY_PREFIX_LENGTH	64
typedef struct Fsdm_SummaryInfo {
    int		numFreeKbytes;		/* Free space in kbytes, not blocks */
    int		numFreeFileDesc;	/* Number of free file descriptors */
    int		state;			/* Unused. */
    char	domainPrefix[FSDM_SUMMARY_PREFIX_LENGTH];
					/* Last prefix used for the domain */
    int		domainNumber;		/* The domain number of the domain
					 * under which this file system was
					 * last mounted. */
    int		flags;			/* Flags defined below. */
    int		attachSeconds;		/* Time the disk was attached */
    int		detachSeconds;		/* Time the disk was off-lined.  This
					 * is the fsutil_TimeInSeconds that the
					 * system was shutdown or the disk
					 * was detached.  If the domain is
					 * marked NOT_SAFE then this field
					 * is undefined, but attachTime is ok
					 * as long as TIMES_VALID is set. */
    int		fixCount;		/* Number of consecutive times that 
					 * fscheck has found an error in this
					 * domain. Used to prevent infinite
					 * looping.
					 */
    char pad[DEV_BYTES_PER_SECTOR -
	     (8 * sizeof(int) + FSDM_SUMMARY_PREFIX_LENGTH)];
} Fsdm_SummaryInfo;

/*
 * Flags for summary info structure.
 *	FSDM_DOMAIN_NOT_SAFE	Set during normal operation. This is unset
 *		when we know we	are shutting down cleanly and the data
 *		structures on the disk partition (domain) are ok.
 *	FSDM_DOMAIN_ATTACHED_CLEAN	Set if the initial attach found the
 *		disk marked 'safe'
 *	FSDM_DOMAIN_TIMES_VALID	If set then the attach/detachSeconds fields
 *		are valid.
 *	FSDM_DOMAIN_JUST_CHECKED Set if the disk was just checked by fscheck
 *		and doesn't need to be rechecked upon reboot.  This is only
 *		useful for the root partition, since that is the only one
 *		that requires a reboot.  In theory only the 
 *		FSDM_DOMAIN_NOT_SAFE should be needed, but we don't yet
 *		trust the filesystem to shut down cleanly.
 */
#define	FSDM_DOMAIN_NOT_SAFE		0x1
#define FSDM_DOMAIN_ATTACHED_CLEAN	0x2
#define	FSDM_DOMAIN_TIMES_VALID		0x4
#define FSDM_DOMAIN_JUST_CHECKED	0x8
d173 1
a173 1
 *	FSDM_FD_RESERVED	The file descriptor is reserved and not for use.
d176 21
d198 1
d203 10
a212 1
#define FSDM_FD_DIRTY	0x8
a219 1

d221 1
a221 1
 * Stuff for block allocation 
d224 11
a234 181
#define	FSDM_NUM_FRAG_SIZES	3

/*
 * The bad block file, the root directory of a domain and the lost and found 
 * directory have well known file numbers.
 */
#define FSDM_BAD_BLOCK_FILE_NUMBER	1
#define FSDM_ROOT_FILE_NUMBER		2
#define FSDM_LOST_FOUND_FILE_NUMBER	3

/*
 * The lost and found directory is preallocated and is of a fixed size. Define
 * its size in 4K blocks here.
 */
#define	FSDM_NUM_LOST_FOUND_BLOCKS	2

/*
 * Structure to keep statistics about each cylinder.
 */

typedef struct Fsdm_Cylinder {
    int	blocksFree;	/* Number of blocks free in this cylinder. */
} Fsdm_Cylinder;



/*
 * The geometry of a disk is a parameter to the disk block allocation routine.
 * It is stored in disk in the Domain header so that different configurations
 * on the same disk can be tried out and compared.
 *
 * The following parameters define array sizes in the Fsdm_Geometry struct.
 *
 * FSDM_MAX_ROT_POSITIONS defines how many different rotational positions are
 * possible for a filesystem block.  An Eagle Drive, for example, has 23
 * rotational positions.  There are 46 sectors per track.  That means that
 * 5 4K filesystem blocks fit on a track and the 6th spills over onto the
 * next track.  This offsets all the 4K blocks on the next track by 1K.
 * This continues for 4 tracks after which 23 whole blocks have been
 * packed in.  The set of 23 blocks is called a ``rotational set''.
 * Also, because the Eagle has 20 heads, and each rotational set occupies
 * 4 tracks, there are 5 rotational sets per cylinder.
 *
 * FSDM_MAX_TRACKS_PER_SET defines how many tracks a rotational set can
 * take up.
 */
#define FSDM_MAX_ROT_POSITIONS	32
#define FSDM_MAX_TRACKS_PER_SET	10

/*
 * There is a new mapping available for SCSI disks.  In this mapping we
 * ignore rotational sets altogether and pack as many blocks as possible
 * into a cylinder. The field rotSetsPerCyl is overloaded to allow us
 * to be backwards compatible. If rotSetsPerCyl == FSDM_SCSI_MAPPING
 * then we are using the new mapping.  The other fields relating to
 * rotational sets and block offsets are ignored.
 */

#define FSDM_SCSI_MAPPING -1

typedef struct Fsdm_Geometry {
    /*
     * Fundamental disk geometry that cannot be varied.
     */
    int		sectorsPerTrack;/* The number of sectors per track */
    int		numHeads;	/* The number of surfaces on the disk */
    /*
     * Filesystem blocks take up several disk sectors, and filesystem
     * blocks on different surfaces may be skewed relative to each other
     * because a whole number of filesystem blocks generally does not fit
     * on one track.  (This property is exploited when looking for blocks
     * that are rotationaly optimal with respect to each other.)  The
     * skewing pattern is repeated after a certain number of filesystem
     * blocks.  The pattern is contrained to fit on a whole number of
     * tracks, and a whole number of the patterns has to fit in one
     * cylinder.  This means that there may be unused sectors at the end
     * of each set of filesystem blocks.
     */
    int		blocksPerRotSet;	/* The number of distinct rotational
					 * positions for filesystem blocks */
    int		tracksPerRotSet;	/* The number of disk tracks taken
					 * up by a rotational set.  Used to
					 * bounce from one set to another
					 * and to map from filesystem block
					 * indexes to disk sectors */
    int		rotSetsPerCyl;		/* The number of rotational sets in a
					 * cylinder.  There are numRotPositions
					 * filesystem blocks in each set */
    int		blocksPerCylinder;	/* This is the product of blocksPerSet
					 * and numRotationSets */
    /*
     * The following diagram shows a rotational set for a disk with 46
     * 512 byte sectors per track.  8 disk sectors are needed for each
     * filesystem block, and this allows 5 3/4 blocks per trask.
     * This means that 23 filesystem blocks make up a rotational set
     * that occupies 4 tracks.
	----------------------------------------------------
	|..1.....|..2.....|..3.....|..4.....|..5.....|..6...	track 1
	----------------------------------------------------
	..|..7.....|..8.....|..9.....|..10....|..11....|..12	track 2
	----------------------------------------------------
	....|..13....|..14....|..15....|..16....|..17....|..	track 3
	----------------------------------------------------
	.18...|..19....|..20....|..21....|..22....|..23....|	track 4
	----------------------------------------------------
     * In order to facilitate rotationally optimal allocation the
     * rotational positions are sorted by increasing offset.  In the
     * above example, the sorted ordering is (1, 7, 13, 19, 2, 8...)
     */
    int		blockOffset[FSDM_MAX_ROT_POSITIONS];	/* This keeps the
					 * starting sector number for each
					 * rotational position.  This table
					 * is computed by the makeFilesystem
					 * user program */
    int		sortedOffsets[FSDM_MAX_ROT_POSITIONS];	/* An ordered set of
					 * the rotational positions */
    /*
     * Add more data after here so we have to reformat the disk less often.
     */
} Fsdm_Geometry;


/*
 * A disk is partitioned into areas that each store a domain.  Each domain
 * contains a DomainHeader that describes how the blocks of the domain are
 * used.  The layout information takes into account the blocks that are
 * reserved for the copy of the Disk Header and the boot program.
 */
typedef struct Fsdm_DomainHeader {
    unsigned int magic;		/* magic number for consistency check */
    int		firstCylinder;	/* Disk relative number of the first cylinder
				 * in the domain.  This is redundant with
				 * respect to the complete partition map
				 * kept in the Disk Header */
    int		numCylinders;	/* The number of cylinders in the domain.
				 * Also redundant with Disk Header */
    Fs_Device	device;		/* Device identifier of the domain passed to
				 * the device driver block IO routines.
				 * Two fields are valid on disk: the serverID
				 * records the rpc_SpriteID of the server,
				 * and the unit number indicates which partition
				 * in the superblock this header corresponds
				 * to.  This is needed because more than one
				 * partition can start at the same spot on
				 * disk (of course, only one is valid to use).
				 * The device type on disk is ignored */
    /*
     * An array of FsDescriptors is kept on the disk and an accompanying
     * bitmap is used to keep track of free and allocated file descriptors.
     */
    int		fdBitmapOffset;	/* The block offset of the bitmap used to
				 * keep track of free FileDescriptors */
    int		fdBitmapBlocks;	/* The number of blocks in the bitmap */
    int		fileDescOffset;	/* The block offset of the array of fds.
				 * The number of blocks in the array comes
				 * from numFileDesc */
    int		numFileDesc;	/* The number of FsDescriptors in the domain.
				 * This is an upper limit on the number of
				 * files that be kept in the domain */ 
    /*
     * A large bitmap is used to record the status of all the data blocks
     * in the domain.
     */
    int		bitmapOffset;	/* The block number of the start of bitmap */
    int		bitmapBlocks;	/* Number of blocks used to store bitmap */
    /*
     * The data blocks take up the rest of the domain.
     */
    int		dataOffset;	/* The block number of the start of data */
    int		dataBlocks;	/* Number of data blocks */
    int		dataCylinders;	/* Number of cylinders containing data blocks */
    /*
     * Disk geometery parameters are used map from block indexes to
     * disk sectors, and also to optimally allocate blocks.
     */
    Fsdm_Geometry	geometry;	/* Used by the allocation routines and
				 * by the block IO routines */
} Fsdm_DomainHeader;

#define FSDM_DOMAIN_MAGIC	(unsigned int)0xF8E7D6C5

d236 1
a236 1
 * Structure for each domain.
d238 84
a322 32
typedef struct Fsdm_Domain {
    Fsio_FileIOHandle	physHandle;	/* Handle to use to read and write
					 * physical blocks. */
    Fsdm_DomainHeader *headerPtr; 		/* Disk information for the domain. */
    /*
     * Disk summary information.
     */
    Fsdm_SummaryInfo *summaryInfoPtr;
    int		  summarySector;
    /*
     * Data block allocation.
     */
    unsigned char *dataBlockBitmap;	/* The per domain data block bit map.*/
    int		bytesPerCylinder;	/* The number of bytes in the bit map
					 * for each cylinder. */
    Fsdm_Cylinder	*cylinders;		/* Pointer to array of cylinder
					 * information. */
    List_Links	*fragLists[FSDM_NUM_FRAG_SIZES];	/* Lists of fragments. */
    Sync_Lock	dataBlockLock;		/* Lock for data block allocation. */
    int		minKFree;		/* The minimum number of kbytes that 
					 * must be free at all times. */
    /*
     * File descriptor allocation.
     */
    unsigned char *fileDescBitmap;	/* The per domain file descriptor bit
					 * map.*/
    Sync_Lock	fileDescLock;		/* Lock for file descriptor
					 * allocation. */
    int		flags;		/* Flags defined below. */		
    int		refCount;	/* Number of active users of the domain. */
    Sync_Condition condition;	/* Condition to wait on. */
} Fsdm_Domain;
d325 1
a325 1
 * Domain flags
d332 1
a332 1
#define	FSDM_DOMAIN_GOING_DOWN		0x1
a345 1
typedef	int	Fsdm_BlockIndexType;
d348 3
a350 61
 * Structure to keep information about the indirect and doubly indirect
 * blocks used in indexing.
 */

typedef struct Fsdm_IndirectInfo {
    	Fscache_Block 	*blockPtr;	/* Pointer to indirect block. */
    	int		index;		/* An index into the indirect block. */
    	Boolean	 	blockDirty;	/* TRUE if the block has been
					   modified. */
    	int	 	deleteBlock;	/* FSCACHE_DELETE_BLOCK bit set if should 
					   delete the block when are
					   done with it. */
} Fsdm_IndirectInfo;

/*
 * Structure used when going through the indexing structure of a file.
 */

typedef struct Fsdm_BlockIndexInfo {
    Fsdm_BlockIndexType	 indexType;	/* Whether chasing direct, indirect,
					   or doubly indirect blocks. */
    int		blockNum;		/* Block that is being read, written,
					   or allocated. */
    int		lastDiskBlock;		/* The disk block for the last file
					   block. */
    int		*blockAddrPtr;		/* Pointer to pointer to block. */
    int		directIndex;		/* Index into direct block pointers. */
    Fsdm_IndirectInfo indInfo[2];		/* Used to keep track of the two 
					   indirect blocks. */
    int		 flags;			/* Flags defined below. */
    Fsdm_Domain	*domainPtr;		/* Domain that the file is in. */
} Fsdm_BlockIndexInfo;

/*
 * Flags for the index structure.
 *
 *     FSDM_ALLOC_INDIRECT_BLOCKS		If an indirect is not allocated then
 *					allocate it.
 *     FSDM_DELETE_INDIRECT_BLOCKS	After are finished with an indirect
 *					block if it is empty delete it.
 *     FSDM_DELETING_FROM_FRONT		Are deleting blocks from the front
 *					of the file.
 *     FSDM_DELETE_EVERYTHING		The file is being truncated to length
 *					0 so delete all blocks and indirect
 *					blocks.
 *	FSCACHE_DONT_BLOCK		Don't block on a full cache.  The cache
 *					can get so full of dirty blocks it can
 *					prevent the fetching of needed indirect
 *					blocks.  Our caller can deal with this
 *					if it sets FSCACHE_DONT_BLOCK, otherwise
 *					we'll wait for a free cache block.
 *					(FSCACHE_DONT_BLOCK value is used as
 *					 a convenience - it gets passed to
 *					 Fscache_FetchBlock)
 */

#define	FSDM_ALLOC_INDIRECT_BLOCKS	0x01
#define	FSDM_DELETE_INDIRECT_BLOCKS	0x02
#define	FSDM_DELETING_FROM_FRONT	0x04
#define	FSDM_DELETE_EVERYTHING		0x08
/*resrv FSCACHE_DONT_BLOCK		0x40000 */
d353 2
a354 1
 * Whether or not to keep information about file I/O by user file type.
d356 33
a388 1
extern Boolean fsdmKeepTypeInfo;
d394 19
d414 2
a415 21
extern ReturnStatus	Fsdm_FileDescInit();
extern ReturnStatus	Fsdm_FileDescFetch();
extern ReturnStatus	Fsdm_FileDescStore();
extern ReturnStatus	Fsdm_FileDescFree();
extern ReturnStatus	Fsdm_FileDescTrunc();
extern ReturnStatus 	Fsdm_GetNewFileNumber();
extern ReturnStatus	Fsdm_FileDescWriteBack();

extern ReturnStatus	Fsdm_BlockAllocate();
extern ReturnStatus	Fsdm_FindFileType();
extern ReturnStatus	Fsdm_FreeFileNumber();


/*
 * Declarations for the local Domain data block allocation routines and 
 * indexing routines.
 */

extern	ReturnStatus	Fsdm_GetFirstIndex();
extern	ReturnStatus	Fsdm_GetNextIndex();
extern	void		Fsdm_EndIndex();
d420 6
a425 3
extern  ReturnStatus	Fsdm_AttachDisk();
extern  ReturnStatus	Fsdm_AttachDiskByHandle();
extern  ReturnStatus	Fsdm_DetachDisk();
d429 28
a456 5
extern	Fsdm_Domain	*Fsdm_DomainFetch();
extern	void		Fsdm_DomainRelease();
extern  ReturnStatus	Fsdm_DomainInfo();
extern void 	     Fsdm_DomainWriteBack();
extern ReturnStatus	Fsdm_RereadSummaryInfo();
d460 9
a468 3
extern	void		Fsdm_RecordDeletionStats();
extern  void		Fsdm_Init();

@


9.6
log
@Added padding to Fsdm_SummaryInfo so its exactly DEV_BYTES_PER_SECTOR
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fsdm/RCS/fsdm.h,v 9.5 90/02/13 16:06:41 shirriff Exp $ SPRITE (Berkeley)
d465 1
a465 1
 * Domain flags used for two stage process of detaching a domain:
d469 2
d472 1
a472 1
#define	FSDM_DOMAIN_GOING_DOWN	0x1
d474 1
@


9.5
log
@Removed comment that doesn't seem to be relevant.
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fsdm/RCS/fsdm.h,v 9.4 89/12/14 13:10:22 brent Exp Locker: shirriff $ SPRITE (Berkeley)
d99 1
d104 2
a105 1
    char	domainPrefix[64];	/* Last prefix used for the domain */
d123 2
a124 1

@


9.4
log
@Added FSCACHE_DONT_BLOCK to flags allowed with Fsdm_GetFirstIndex.
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fsdm/RCS/fsdm.h,v 9.3 89/11/27 13:18:35 jhh Exp $ SPRITE (Berkeley)
a46 6
 *
 *      NOTE: we are temporarily using Sun's format of the Disk Header,
 *      not the following typedef.  Sun's label is defined in
 *      "../sun/sunDiskLabel.h".  We assume that sector zero contains a
 *      Sun format label, and the boot program starts at sector 1. 
 *	Sun3's read 16 boot sectors and Sun4's read 64.
@


9.3
log
@started adding support for avoiding redundant fschecks during
subsequent reboots
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fsdm/RCS/fsdm.h,v 9.2 89/10/23 12:32:27 brent Exp Locker: jhh $ SPRITE (Berkeley)
d534 9
d547 1
a547 1
#define	FSDM_DELETING_FROM_FRONT		0x04
d549 1
@


9.2
log
@Added extern
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fsdm/RCS/fsdm.h,v 9.1 89/10/02 23:17:08 jhh Exp Locker: brent $ SPRITE (Berkeley)
d139 6
d149 1
@


9.1
log
@New scsi disk mapping
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fsdm/RCS/fsdm.h,v 9.0 89/09/12 15:05:11 douglis Stable Locker: jhh $ SPRITE (Berkeley)
d580 4
a583 3



@


9.0
log
@Changing version numbers.
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fsdm/RCS/fsdm.h,v 8.6 89/08/21 15:25:20 mendel Exp Locker: douglis $ SPRITE (Berkeley)
d253 6
d290 11
@


8.6
log
@Break up fs into many modules.    
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fs/RCS/fsDisk.h,v 8.4 89/07/18 13:11:35 jhh Exp $ SPRITE (Berkeley)
@


8.5
log
@Commented #endif labels.
@
text
@d2 1
a2 1
 * fsDisk.h --
d10 1
a10 1
 * $Header: /sprite/src/kernel/fs/RCS/fsDisk.h,v 8.4 89/07/18 13:11:35 jhh Exp Locker: rab $ SPRITE (Berkeley)
d13 2
a14 2
#ifndef _FSDISK
#define _FSDISK
d17 2
d23 1
a23 1
 * An array of FsDiskPartition's is kept on the disk to define how the
d26 2
a27 2
 * FS_NUM_DISK_PARTS defines how many different domains there could be
 *	on a disk.  Generally, not all the domains are defined.
d29 1
a29 1
#define FS_NUM_DISK_PARTS	8
d31 1
a31 1
typedef struct FsDiskPartition {
d35 1
a35 1
} FsDiskPartition;
d51 1
a51 1
 *      Sun format label, and the boot program starts at sector 1.
d55 2
a56 2
#define FS_MAX_BOOT_SECTORS	128
#define FS_BOOT_SECTOR_INC	16
d58 1
a58 1
typedef struct FsDiskHeader {
d67 1
a67 1
	     (12 + FS_NUM_DISK_PARTS * 2) * sizeof(int)];
d84 1
a84 1
    FsDiskPartition map[FS_NUM_DISK_PARTS];	/* Partition map */
d88 1
a88 1
} FsDiskHeader;
d90 1
a90 1
#define FS_DISK_MAGIC	(unsigned int)0xD15CFEBA	/* 'disk fever' */
d93 168
d267 1
a267 1
 * The following parameters define array sizes in the FsGeometry struct.
d269 1
a269 1
 * FS_MAX_ROT_POSITIONS defines how many different rotational positions are
d279 1
a279 1
 * FS_MAX_TRACKS_PER_SET defines how many tracks a rotational set can
d282 2
a283 2
#define FS_MAX_ROT_POSITIONS	32
#define FS_MAX_TRACKS_PER_SET	10
d285 1
a285 1
typedef struct FsGeometry {
d334 1
a334 1
    int		blockOffset[FS_MAX_ROT_POSITIONS];	/* This keeps the
d339 1
a339 1
    int		sortedOffsets[FS_MAX_ROT_POSITIONS];	/* An ordered set of
d344 2
a345 1
} FsGeometry;
d353 1
a353 1
typedef struct FsDomainHeader {
d383 1
a383 1
				 * files that be kept in the domain */
d400 1
a400 1
    FsGeometry	geometry;	/* Used by the allocation routines and
d402 1
a402 3
} FsDomainHeader;

#define FS_DOMAIN_MAGIC	(unsigned int)0xF8E7D6C5
d404 1
a404 5
/*
 * FS_NUM_DOMAIN_SECTORS is the standard number of sectors taken
 * up by the domain header.
 */
#define FS_NUM_DOMAIN_SECTORS	((sizeof(FsDomainHeader)-1) / DEV_BYTES_PER_SECTOR + 1)
a405 1

d407 110
a516 29
 * ONE sector of summary information is kept on disk.  This records things
 * like the number of free blocks and free file descriptors.  This info
 * is located just before the domain header.
 */
typedef struct FsSummaryInfo {
    int		numFreeKbytes;		/* Free space in kbytes, not blocks */
    int		numFreeFileDesc;	/* Number of free file descriptors */
    int		state;			/* Unused. */
    char	domainPrefix[64];	/* Last prefix used for the domain */
    int		domainNumber;		/* The domain number of the domain
					 * under which this file system was
					 * last mounted. */
    int		flags;			/* Flags defined below. */
    int		attachSeconds;		/* Time the disk was attached */
    int		detachSeconds;		/* Time the disk was off-lined.  This
					 * is the fsTimeInSeconds that the
					 * system was shutdown or the disk
					 * was detached.  If the domain is
					 * marked NOT_SAFE then this field
					 * is undefined, but attachTime is ok
					 * as long as TIMES_VALID is set. */
    int		fixCount;		/* Number of consecutive times that
					 * fscheck has found an error in this
					 * domain. Used to prevent infinite
					 * looping.
					 */

} FsSummaryInfo;

d518 1
a518 8
 * Flags for summary info structure.
 *	FS_DOMAIN_NOT_SAFE	Set during normal operation. This is unset
 *		when we know we	are shutting down cleanly and the data
 *		structures on the disk partition (domain) are ok.
 *	FS_DOMAIN_ATTACHED_CLEAN	Set if the initial attach found the
 *		disk marked 'safe'
 *	FS_DOMAIN_TIMES_VALID	If set then the attach/detachSeconds fields
 *		are valid.
d520 1
a520 3
#define	FS_DOMAIN_NOT_SAFE		0x1
#define FS_DOMAIN_ATTACHED_CLEAN	0x2
#define	FS_DOMAIN_TIMES_VALID		0x4
d524 1
a524 3
 * A File Descriptor is kept on disk for every file in a domain.  It
 * contains administrative information and also the indexing structure
 * used to access the file's data blocks.
d527 37
a563 65
#define FS_NUM_DIRECT_BLOCKS	10
#define FS_NUM_INDIRECT_BLOCKS	3
#define	FS_INDICES_PER_BLOCK	1024

#define FS_MAX_FILE_DESC_SIZE	128
#define FS_FILE_DESC_PER_BLOCK	(FS_BLOCK_SIZE / FS_MAX_FILE_DESC_SIZE)

typedef struct FsFileDescriptor {
    unsigned short magic;/* FS_FD_MAGIC, for disk consistency check */
    short flags;	/* FS_FD_FREE, FS_FD_ALLOC, FS_FD_RESERVED */
    short fileType;	/* FS_REGULAR, FS_DIRECTORY, FS_PIPE, FS_DEVICE,
			 * FS_SYMLINK, FS_RMTLINK */
    short permissions;	/* 9 permission bits plus flags for set user ID
			 * upon execution */
    int uid;		/* ID of owner */
    int gid;		/* Group ID of owner */
    int lastByte;	/* The number of bytes in the file */
    int lastByteXtra;	/* (Some day we may have 64 bit sizes?) */
    int firstByte;	/* For named pipes, offset of the first valid byte */
    int userType;	/* Information about what sort of user file it is. */
    int numLinks;	/* Number of directory references to the file */
    int devServerID;	/* ID of the host that controls the device */
    short devType;	/* For devices, their type.  For others this is the
			 * type of disk the file is stored on */
    unsigned short devUnit;	/* For devices, their unit number.  For others,
			 * the unit indicates the disk partition */
    /*
     * All times in seconds since Jan 1 1970, Greenwich time.
     */

    int createTime;	/* Time the file was created. */
    int accessTime;	/* Time of last access.  This is not updated by
			 * directory traversals. */
    int descModifyTime;	/* Time of last modification to the file descriptor */
    int dataModifyTime;	/* Time of last modification to the file data */

    /*
     * Pointers to the data blocks of the file.   The pointers are really
     * indexes into the array of blocks stored in the data block section
     * of a partition.  The direct array contains the indexes of the first
     * several blocks of the files.  The indirect indexes are interpreted
     * as follows.  The first indirect index is the index of a block that
     * contains 1 K indexes of data blocks.  This is called a singly-indirect
     * block.  The second indirect index is the index of a block that
     * contains 1 K indexes of singly-indirect blocks.  This is called
     * a doubly-indirect block.  Finally, the third indirect index is the index
     * of a block that contains 1 K indexes of doubly-indirect blocks.
     * Each data block contains 4Kbytes, so this indexing scheme supports
     * files up to 40K + 4Meg + 4Gig + 4Pig bytes.
     *
     * The values of the direct and indirect indexes are indexes of
     * fragments, ie. 1k pieces.  All the but the last index point to the
     * beginning of a filesystem block, ie. 4K.  The last valid direct
     * block may point to a fragment, and fragments can start on 1K
     * boundaries.
     */

    int direct[FS_NUM_DIRECT_BLOCKS];
    int indirect[FS_NUM_INDIRECT_BLOCKS];
    int numKbytes;	/* The number of KiloBytes acutally allocated towards
			 * the file on disk.  This accounts for fragments
			 * and indirect blocks. */
    int version;	/* Version number of the handle for the file.  Needed
			 * on disk for recovery purposes (client re-open */
} FsFileDescriptor;
a564 13
/*
 * Magic number and flag definitions for file descriptors.
 *	FS_FD_FREE	The file descriptor is unused
 *	FS_FD_ALLOC	The file descriptor is used for a file.
 *	FS_FD_RESERVED	The file descriptor is reserved and not for use.
 *	FS_FD_DIRTY	The file descriptor has been modified since the
 *			last time that it was written to disk.
 */
#define FS_FD_MAGIC	(unsigned short)0xF1D0
#define FS_FD_FREE	0x1
#define FS_FD_ALLOC	0x2
#define FS_FD_RESERVED	0x4
#define FS_FD_DIRTY	0x8
d566 1
a566 47
/*
 * The special index value FS_NIL_INDEX for direct[] and indirect[]
 * means there is no block allocated for that index.
 */
#define FS_NIL_INDEX	-1
/*
 * The bad block file, the root directory of a domain and the lost and found
 * directory have well known file numbers.
 */
#define FS_BAD_BLOCK_FILE_NUMBER	1
#define FS_ROOT_FILE_NUMBER		2
#define FS_LOST_FOUND_FILE_NUMBER	3
/*
 * The lost and found directory is preallocated and is of a fixed size. Define
 * its size in 4K blocks here.
 */
#define	FS_NUM_LOST_FOUND_BLOCKS	2

/*
 * A directory entry:
 */
typedef struct FsDirEntry {
    int fileNumber;		/* Index of the file descriptor for the file. */
    short recordLength;		/* How many bytes this directory entry is */
    short nameLength;		/* The length of the name in bytes */
    char fileName[FS_MAX_NAME_LENGTH+1];	/* The name itself */
} FsDirEntry;
/*
 *	FS_DIR_BLOCK_SIZE	Directory's grow in multiples of this constant,
 *		and records within a directory don't cross directory blocks.
 *	FS_DIR_ENTRY_HEADER	The size of the header of a FsDirEntry;
 *	FS_REC_LEN_GRAIN	The number of bytes in a directory record
 *				are rounded up to a multiple of this constant.
 */
#define FS_DIR_BLOCK_SIZE	512
#define FS_DIR_ENTRY_HEADER	(sizeof(int) + 2 * sizeof(short))
#define FS_REC_LEN_GRAIN	4

/*
 * FsDirRecLength --
 *	This computes the number of bytes needed for a directory entry.
 *	The argument should be the return of the String_Length function,
 *	ie, not include the terminating null in the count.
 */
#define FsDirRecLength(stringLength) \
    (FS_DIR_ENTRY_HEADER + \
    ((stringLength / FS_REC_LEN_GRAIN) + 1) * FS_REC_LEN_GRAIN)
d568 1
a568 1
#endif /* _FSDISK */
@


8.4
log
@Allow variable number of boot sectors
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fs/RCS/fsDisk.h,v 8.3 89/03/08 12:48:15 jhh Exp Locker: jhh $ SPRITE (Berkeley)
d25 1
a25 1
 *	on a disk.  Generally, not all the domains are defined.  
d49 1
a49 1
 *      Sun format label, and the boot program starts at sector 1. 
d212 1
a212 1
				 * files that be kept in the domain */ 
d264 1
a264 1
    int		fixCount;		/* Number of consecutive times that 
d376 1
a376 1
 */ 
d379 1
a379 1
 * The bad block file, the root directory of a domain and the lost and found 
d421 1
a421 1
#endif _FSDISK
@


8.3
log
@added fixCount field to summary sector
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fs/RCS/fsDisk.h,v 8.2 89/02/01 12:50:34 brent Exp Locker: jhh $ SPRITE (Berkeley)
d42 1
a42 1
 * start in sector #1 and contain at most 15 sectors.  The boot program on
d49 2
a50 3
 *      Sun format label, sectors 1 through 16 contain a boot program.
 *      Sector SUN_SUMMARY_SECTOR contains an FsSummaryInfo structure.
 *      Sector SUN_DOMAIN_SECTOR contains an FsDomainHeader structure.
d52 3
@


8.2
log
@Changed devUnit to an unsigned short so ethernet protocol numbers
can fit in without being sign extended later.
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fs/RCS/fsDisk.h,v 8.1 89/01/05 15:20:48 brent Exp Locker: brent $ SPRITE (Berkeley)
d262 6
@


8.1
log
@Added code to mark disks as safely shutdown.
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fs/RCS/fsDisk.h,v 7.0 88/11/07 14:47:19 brent Exp $ SPRITE (Berkeley)
d309 1
a309 1
    short devUnit;	/* For devices, their unit number.  For others,
@


8.0
log
@Changing version numbers.
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fs/RCS/fsDisk.h,v 7.0 88/11/07 14:47:19 brent Exp Locker: douglis $ SPRITE (Berkeley)
d254 8
d266 7
d274 3
a276 1
#define	FS_DOMAIN_NOT_SAFE	0x1
@


7.0
log
@New version for conversion to new C library
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fs/RCS/fsDisk.h,v 6.0 88/08/11 12:15:38 brent Stable Locker: brent $ SPRITE (Berkeley)
@


6.0
log
@Changing version numbers.
@
text
@d10 1
a10 1
 * $Header: fsDisk.h,v 1.2 88/08/05 14:14:53 douglis Exp $ SPRITE (Berkeley)
@


1.2
log
@Changes to support keeping track of file deletions, certain FS system
calls, and large fsStat counters, ported from the old filesystem.
This ci message is generic.
@
text
@d10 1
a10 1
 * $Header: fsDisk.h,v 1.1 88/04/04 10:31:54 brent Exp $ SPRITE (Berkeley)
@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
 * $Header: fsDisk.h,v 5.3 87/11/02 10:41:27 brent Exp $ SPRITE (Berkeley)
d287 1
a287 1
    int fileUsageType;	/* Information about what sort of user file it is. */
@
