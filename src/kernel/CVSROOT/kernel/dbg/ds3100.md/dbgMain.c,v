head     9.13;
branch   ;
access   ;
symbols  ds3100:9.13 sun3:9.13 sun4nw:9.9 symm:9.9 spur:9.9 Summer89:9.0;
locks    ; strict;
comment  @ * @;


9.13
date     92.09.29.15.52.12;  author jhh;  state Exp;
branches ;
next     9.12;

9.12
date     92.07.23.17.28.02;  author secor;  state Exp;
branches ;
next     9.11;

9.11
date     92.03.11.13.26.33;  author jhh;  state Exp;
branches ;
next     9.10;

9.10
date     92.03.11.13.07.53;  author jhh;  state Exp;
branches ;
next     9.9;

9.9
date     91.08.09.16.27.37;  author jhh;  state Exp;
branches ;
next     9.8;

9.8
date     91.06.28.12.08.20;  author mgbaker;  state Exp;
branches ;
next     9.7;

9.7
date     91.05.27.16.41.05;  author jhh;  state Exp;
branches ;
next     9.6;

9.6
date     91.02.02.18.32.48;  author jhh;  state Exp;
branches ;
next     9.5;

9.5
date     90.10.09.11.49.56;  author jhh;  state Exp;
branches ;
next     9.4;

9.4
date     90.09.24.17.14.19;  author kupfer;  state Exp;
branches ;
next     9.3;

9.3
date     90.07.30.11.35.32;  author shirriff;  state Exp;
branches ;
next     9.2;

9.2
date     90.07.18.14.54.34;  author shirriff;  state Exp;
branches ;
next     9.1;

9.1
date     89.10.31.08.55.10;  author mendel;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.14.56.24;  author douglis;  state Stable;
branches ;
next     1.3;

1.3
date     89.08.30.11.00.57;  author douglis;  state Exp;
branches ;
next     1.2;

1.2
date     89.08.17.17.46.27;  author douglis;  state Exp;
branches ;
next     1.1;

1.1
date     89.07.10.19.51.23;  author nelson;  state Exp;
branches ;
next     ;


desc
@First code from DECWRL.
@


9.13
log
@Got rid of non-ethernet warning.
@
text
@/* dbgMain.c -
 *
 *	This contains the routines which read and execute commands from kdbx.
 *
 *	Copyright (C) 1989 Digital Equipment Corporation.
 *	Permission to use, copy, modify, and distribute this software and
 *	its documentation for any purpose and without fee is hereby granted,
 *	provided that the above copyright notice appears in all copies.  
 *	Digital Equipment Corporation makes no representations about the
 *	suitability of this software for any purpose.  It is provided "as is"
 *	without express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/dbg/ds3100.md/dbgMain.c,v 9.12 92/07/23 17:28:02 secor Exp $ SPRITE (Berkeley)";
#endif not lint

#include <sprite.h>
#include <dbg.h>
#include <dbgInt.h>
#include <mach.h>
#include <machConst.h>
#include <proc.h>
#include <vm.h>
#include <vmMach.h>
#include <machMon.h>
#include <net.h>
#include <netEther.h>
#include <netInet.h>
#include <dev.h>
#include <sys.h>
#include <sync.h>
#include <main.h>

#ifdef KDBX
#include <user/signal.h>
#endif

extern Address vmStackBaseAddr;
extern Address vmStackEndAddr;
extern Address vmBlockCacheBaseAddr;
extern Address vmBlockCacheEndAddr;
extern Address vmBootEnd;

static unsigned sstepInst;			/* The instruction that was
						 * replaced when we tried to
						 * single step. */
Boolean dbg_InDebugger = FALSE;			/* TRUE if are currently in
						 * the debug command loop. */
Boolean	dbg_BeingDebugged = FALSE;		/* TRUE if are under control
						 * of kdbx.*/
Boolean	dbg_Rs232Debug = FALSE;			/* TRUE if are using the RS232
						 * line to debug, FALSE if are
						 * using the network. */
Boolean	dbg_UsingNetwork = FALSE;		/* TRUE if the debugger is
						 * using the network interface*/
static char requestBuffer[DBG_MAX_REQUEST_SIZE];/* Buffer to receive request
						 * into. */
static int	requestOffset;			/* Offset in buffer where next
						 * bytes should be read from.*/
static char replyBuffer[DBG_MAX_REPLY_SIZE + 2];/* Buffer to hold reply. */
static int	replyOffset = 0;		/* Offset in buffer where next
						 * bytes in reply should go. */
static unsigned int	curMsgNum;		/* The current message that
						 * is being processed. */
int	dbgTraceLevel = 0;			/* The debugger tracing
						 * level. */

/*
 * Number of times to poll before timing out and resending (about 2 seconds).
 */
int	dbgTimeout = 15000;

/*
 * Information about the latest packet received.
 */
Boolean			dbgGotPacket;	
int			dbgPacketLength;
Net_InetAddress		dbgMyIPAddr;
Net_InetAddress		dbgSrcIPAddr;
Net_InetAddress		dbgSrcPort;
Net_EtherHdr		dbgEtherHdr;
Net_ScatterGather	dbgGather;
Net_Interface		*dbgInterPtr = (Net_Interface *) NIL;

/*
 * Size of debugging packet header and data.
 */
#define	PACKET_HDR_SIZE (sizeof(Net_EtherHdr) + Dbg_PacketHdrSize() + 4 + 2)
#define PACKET_DATA_SIZE (DBG_MAX_REPLY_SIZE - PACKET_HDR_SIZE)


/*
 * Strings which describe each of the opcodes that kdbx can send us.
 */
static char *opcodeNames[] = DBG_OPCODE_NAMES ;

/*
 * Strings which describe the different exceptions that can occur.
*/
static char *exceptionNames[] = DBG_EXCEPTION_NAMES;

/*
 * Whether syslog should remain diverted on continue or not.
 */
static Boolean	syslogDiverted = FALSE;

/*
 * Declare global variables.
 */
int		dbgTermReason;
int		dbgInDebugger;
int		dbgIntPending;
Boolean		dbgPanic;
Boolean		dbg_UsingSyslog = FALSE;
Boolean		dbgCanUseSyslog = TRUE;
int		dbgMaxStackAddr;
#ifdef KDBX
int		dbgSignal;
static Boolean	useKdbx = FALSE;
#endif
/*
 * Trap causes (same numbering as in ptrace.h).
 */
#define CAUSE_SINGLE	4
#define CAUSE_BREAK	5

/*
 * Trap instruction.
 */
#define SSTEP_INST	(MACH_SSTEP_VAL | 0xd)

/* 
 * Forward declarations:
 */

static char *	TranslateOpcode _ARGS_((int opcode));
static char *	TranslateException _ARGS_((int exception));
static Boolean	ReadRequest _ARGS_((Boolean timeout));
static void	SendReply _ARGS_((int dataSize));
static void	DebugToRegState _ARGS_((Mach_DebugState *debugPtr, 
			Mach_RegState *regPtr));
static void	RegStateToDebug _ARGS_((Mach_RegState *regPtr, 
		    Mach_DebugState *debugPtr)); 

#ifdef KDBX
static int	sigMap[] = {
    /* MACH_EXC_INT 		*/		SIGILL,
    /* MACH_EXC_TLB_MOD 	*/		SIGSEGV,
    /* MACH_EXC_TLB_LD_MISS 	*/		SIGSEGV, 
    /* MACH_EXC_TLB_ST_MISS 	*/		SIGSEGV, 
    /* MACH_EXC_ADDR_ERR_LD 	*/ 		SIGBUS,
    /* MACH_EXC_ADDR_ERR_ST 	*/		SIGBUS,
    /* MACH_EXC_BUS_ERR_IFETCH 	*/		SIGBUS,
    /* MACH_EXC_BUS_ERR_LD_ST 	*/		SIGBUS,
    /* MACH_EXC_SYSCALL 	*/		SIGSYS,
    /* MACH_EXC_BREAK 		*/		SIGTRAP,
    /* MACH_EXC_RES_INST 	*/		SIGILL,
    /* MACH_EXC_COP_UNUSABLE 	*/		SIGILL, 
    /* MACH_EXC_OVFLOW 		*/		SIGILL,
};

#endif


/*
 * ----------------------------------------------------------------------------
 *
 * Dbg_InRange --
 *
 *     Return true if the given address is a valid kernel address and false
 *     otherwise.
 *
 * Results:
 *     True if the given address is a valid kernel address and false
 *     otherwise.
 *
 * Side effects:
 *     None.
 *
 * ----------------------------------------------------------------------------
 */
/*ARGSUSED*/
Boolean Dbg_InRange(addr, numBytes, writeable) 
    unsigned 	int addr; 	/* Beginning address to check. */
    int		numBytes; 	/* Number of bytes to check. */
    Boolean	writeable;	/* TRUE => address must be writeable. */
{
    int			firstPage;
    int			lastPage;

    firstPage = addr >> VMMACH_PAGE_SHIFT;
    lastPage = (addr + numBytes - 1) >> VMMACH_PAGE_SHIFT;
    if (firstPage != lastPage) {
	Mach_MonPrintf("Dbg_InRange: Object spans pages\n");
	return(FALSE);
    }
    return(VmMach_MakeDebugAccessible(addr));
}


/*
 * ----------------------------------------------------------------------------
 *
 * TranslateOpcode --
 *
 *     Return the string which describes the given opcode.
 *
 * Results:
 *     Pointer to the string which describes the given opcode.
 *
 * Side effects:
 *     None.
 *
 * ----------------------------------------------------------------------------
 */
static char *
TranslateOpcode(opcode)
    int opcode;		/* The opcode which is to be translated. */
{
	int index;

	index = (int) opcode;
	if (index < 0 || index >= sizeof(opcodeNames) / 4) {
	    index = 0;
	}

	return(opcodeNames[index]);
}


/*
 * ----------------------------------------------------------------------------
 *
 * TranslateException --
 *
 *     Return the string that describes the given exception.
 *
 * Results:
 *     Pointer to string which describes the given exception.
 *
 * Side effects:
 *     None.
 *
 * ----------------------------------------------------------------------------
 */
static char *
TranslateException(exception)
    int exception;		/* The exception which is to be translated. */
{

	if (exception < 0 || exception > MACH_EXC_OVFLOW) {
	    return("Unknown");
	} else {
	    return(exceptionNames[exception]);
	}
}


/*
 * ----------------------------------------------------------------------------
 *
 * Dbg_Init --
 *
 *     Initialize the debugger.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     Global variables are initialized.
 *
 * ----------------------------------------------------------------------------
 */
void
Dbg_Init()
{
#ifdef KDBX
    extern void DbgDbxInit();
#endif
    dbgInDebugger = 0;
    dbgIntPending = 0;
    dbgPanic = FALSE;
    dbg_BeingDebugged = FALSE;
#ifdef KDBX
    DbgDbxInit();
#endif
}



/*
 * ----------------------------------------------------------------------------
 *
 * Dbg_InputPacket --
 *
 *     See if the current packet is for us.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     dbgGotPacket is set to true if we got a packet that we liked.
 *
 * ----------------------------------------------------------------------------
 */
void
Dbg_InputPacket(interPtr, packetPtr, packetLength)
    Net_Interface	*interPtr;
    Address		packetPtr;
    int			packetLength;
{
    Net_EtherHdr	*etherHdrPtr;
    Net_IPHeader	*ipPtr;
    Address		dataPtr;
    int			dataLength;

    if (interPtr->netType != NET_NETWORK_ETHER) {
	return;
    }
    etherHdrPtr = (Net_EtherHdr *)packetPtr;

    if (dbgTraceLevel >= 5) {
	if ((unsigned char)etherHdrPtr->destination.byte1 != 0xff) {
	    Mach_MonPrintf("Size=%d S: %x:%x:%x:%x:%x:%x D: %x:%x:%x:%x:%x:%x T=%x\n",
			packetLength,
			(unsigned char)etherHdrPtr->source.byte1,
			(unsigned char)etherHdrPtr->source.byte2,
			(unsigned char)etherHdrPtr->source.byte3,
			(unsigned char)etherHdrPtr->source.byte4,
			(unsigned char)etherHdrPtr->source.byte5,
			(unsigned char)etherHdrPtr->source.byte6,
			(unsigned char)etherHdrPtr->destination.byte1,
			(unsigned char)etherHdrPtr->destination.byte2,
			(unsigned char)etherHdrPtr->destination.byte3,
			(unsigned char)etherHdrPtr->destination.byte4,
			(unsigned char)etherHdrPtr->destination.byte5,
			(unsigned char)etherHdrPtr->destination.byte6,
			Net_NetToHostShort(etherHdrPtr->type));
	}
    }

    if (Net_NetToHostShort(etherHdrPtr->type) != NET_ETHER_IP) {
	if (dbgTraceLevel >= 5) {
	    Mach_MonPrintf("Non-IP (Type=0x%x) ",
		    Net_NetToHostShort(etherHdrPtr->type));
	}
	return;
    }
    if (dbgGotPacket) {
	if (dbgTraceLevel >= 4) {
	    Mach_MonPrintf("Dbg_InputPacket: already have a packet\n");
	}
	return;
    }
    if (dbgTraceLevel >= 4) {
	Mach_MonPrintf("Validating packet\n");
    }
    { 
	static char alignedBuffer[NET_ETHER_MAX_BYTES];
        /*
	 * Make sure the packet starts on a 32-bit boundry so that we can
	 * use structures for describe the data.
	 */
	if ( (unsigned int) (packetPtr + sizeof(Net_EtherHdr)) & 0x3 ) {
	      bcopy (packetPtr + sizeof(Net_EtherHdr), alignedBuffer,
			    packetLength - sizeof(Net_EtherHdr));
	      packetPtr = alignedBuffer;
	} else {
	      packetPtr = packetPtr + sizeof(Net_EtherHdr);
	}

	if (Dbg_ValidatePacket(packetLength - sizeof(Net_EtherHdr),
			       (Net_IPHeader *)(packetPtr),
			       &dataLength, &dataPtr,
			       &dbgMyIPAddr, &dbgSrcIPAddr, &dbgSrcPort)) {
	    if (dbgTraceLevel >= 4) {
		Mach_MonPrintf("Got a packet: length=%d\n", dataLength);
	    }
	    bcopy((Address)etherHdrPtr, (Address)&dbgEtherHdr,
		    sizeof(Net_EtherHdr));
	    dbgGotPacket = TRUE;
	    bcopy(dataPtr, requestBuffer, dataLength);
#ifdef KDBX
	    DbgDbxStoreRequest(dataLength, requestBuffer);
#endif
	    /*
	     * Set the interface we are using. 
	     */
	    dbgInterPtr = interPtr;
	    return;
	}
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 * ReadRequest --
 *
 *     Read the next request from kdbx.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     TRUE if didn't time out.
 *
 * ----------------------------------------------------------------------------
 */
static Boolean
ReadRequest(timeout)
    Boolean	timeout;	/* TRUE if should timeout after waiting a 
				 * while. */
{
    int			timeOutCounter;
    Net_Interface	*interPtr;
    int			i;

    dbgGotPacket = FALSE;
    timeOutCounter = dbgTimeout;
    do {
	/*
	 * Listen on all the interfaces. The debugger is relatively
	 * stateless so its easiest to just listen on them all.
	 */
	for (i = 0; ; i++) {
	    interPtr = Net_NextInterface(TRUE, &i);
	    if (interPtr == (Net_Interface *) NIL) {
		break;
	    }
	    Net_RecvPoll(interPtr);
	    if (dbgGotPacket) {
		break;
	    }
	}
	if (timeout) {
	    timeOutCounter--;
	}
    } while(!dbgGotPacket && timeOutCounter != 0);
    if (dbgGotPacket) {
	replyOffset = PACKET_HDR_SIZE;
	requestOffset = 4;
	curMsgNum = *(unsigned int *)(requestBuffer);
#ifdef KDBX
	if (curMsgNum > 0x40000000) {
	    useKdbx = FALSE;
	} else {
	    useKdbx = TRUE;
	}
#endif
	if (dbgTraceLevel >= 4) {
	    Mach_MonPrintf("MsgNum = %d\n", curMsgNum);
	}
    }

    return(dbgGotPacket);
}

/*
 * ----------------------------------------------------------------------------
 *
 * GetRequestBytes --
 *
 *     Get the next numBytes bytes from the current request.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 * ----------------------------------------------------------------------------
 */
static void
GetRequestBytes(numBytes, dest)
    int		numBytes;
    Address	dest;
{
	bcopy(requestBuffer + requestOffset, dest, numBytes);
	requestOffset += numBytes;
}


/*
 * ----------------------------------------------------------------------------
 *
 * PutReplyBytes --
 *
 *     Put the given bytes into the reply buffer.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 * ----------------------------------------------------------------------------
 */
static void
PutReplyBytes(numBytes, src)
    int		numBytes;
    Address	src;
{
    if (replyOffset + numBytes > DBG_MAX_REPLY_SIZE) {
	Mach_MonPrintf("PutReplyBytes: Buffer overflow\n");
	numBytes = DBG_MAX_REPLY_SIZE - replyOffset;
    }
    bcopy(src, &replyBuffer[replyOffset], numBytes);
    replyOffset += numBytes;
}


/*
 * ----------------------------------------------------------------------------
 *
 * SendReply --
 *
 *     Send a reply to kdbx.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 * ----------------------------------------------------------------------------
 */
static void
SendReply(dataSize)
    int	dataSize;
{
    Net_EtherHdr		*etherHdrPtr;

    if (dbgTraceLevel >= 4) {
	Mach_MonPrintf("Sending reply\n");
    }

    etherHdrPtr = (Net_EtherHdr *) (replyBuffer+2);
    etherHdrPtr->source = dbgEtherHdr.destination;
    etherHdrPtr->destination = dbgEtherHdr.source;
    etherHdrPtr->type = dbgEtherHdr.type;
    dbgGather.bufAddr = replyBuffer + sizeof(Net_EtherHdr)+2;
    dbgGather.length = replyOffset - sizeof(Net_EtherHdr)-2;
    dbgGather.mutexPtr = (Sync_Semaphore *) NIL;
    bcopy((char *)&curMsgNum,(char *)(replyBuffer + PACKET_HDR_SIZE - 4),4);
    Dbg_FormatPacket(dbgMyIPAddr, dbgSrcIPAddr, dbgSrcPort,
		 replyOffset - sizeof(Net_EtherHdr) - Dbg_PacketHdrSize()-2,
		 replyBuffer + sizeof(Net_EtherHdr) + 2);
    Net_RawOutput(dbgInterPtr, etherHdrPtr, &dbgGather, 1);
    if (dbgTraceLevel >= 4) {
	Mach_MonPrintf("Sent reply\n");
    }
}


/*
 * Should we sync the disks on entering the debugger?
 */

Boolean dbgSyncDisks = TRUE;

extern Mach_DebugState	mach_DebugState;

/*
 * Place where the TLB is dumped when the kernel enters the debugger.
 */
unsigned dbgTLB[VMMACH_NUM_TLB_ENTRIES][2];

static Mach_DebugState	*debugStatePtr;


/*
 * ----------------------------------------------------------------------------
 *
 * Dbg_Main --
 *
 *     The main debugger loop.  This will read commands from the network
 *     and call the proper routine to execute them.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 * ----------------------------------------------------------------------------
 */
unsigned
Dbg_Main()
{
    unsigned	cause;
    Boolean	  	done;		/* Boolean to tell us whether to leave
					 * the main debugger loop */
    Dbg_Opcode	  	opcode;	        /* The operation that was requested */
					/* Process table entry that we switched
					 * stacks to. */
    Proc_ControlBlock	*procPtr = (Proc_ControlBlock *) NIL;
    Boolean		atInterruptLevel;/* TRUE if we were entered from an
					  * interrupt handler. */
    extern int Mach_SwitchPoint();
#ifdef NOTDEF
/*
 * This code causes machines to "pop out" of the debugger.
 */
    if (!dbg_BeingDebugged && dbgSyncDisks) {
	/*
	 * Try to sync the disks if we aren't at interrupt level.  If we
	 * are don't bother because we'll just hang waiting for interrupts.
	 * Of course I could force interrupts to be enabled but I'm not sure
	 * if that's a great idea.
	 */
	if (mach_NumDisableIntrsPtr[0] == 0 &&
	    !mach_AtInterruptLevel) {
	    Mach_EnableIntr();
	    Sys_SyncDisks(MACH_OTHER_TRAP_TYPE);
	    Mach_DisableIntr();
	}
    }
#endif NOTDEF

    dbg_InDebugger = TRUE;

    debugStatePtr = &mach_DebugState;

    if (dbgTraceLevel >= 1) {
	unsigned int	*sp;
	extern int etext;
    
	Mach_MonPrintf("\nCause=%x SR=%x excPC=%x SP=%x BVA=%x\n", 
		       mach_DebugState.causeReg, mach_DebugState.statusReg, 
		       mach_DebugState.excPC, mach_DebugState.regs[SP],
		       mach_DebugState.badVaddr);
	Mach_MonPrintf("Stack:\n");
	for (sp = (unsigned *)mach_DebugState.regs[SP]; 
	     sp < (unsigned *)0x80030000; 
	     sp++) {
	    if ((*sp < (unsigned int)&etext) && (*sp >= (unsigned)0x80030000)) {
		Mach_MonPrintf("%x\n", *sp);
	    }
	}
    }

    atInterruptLevel = mach_AtInterruptLevel;
    mach_AtInterruptLevel = TRUE;

    /*
     * Force system log output to the console.
     */
    if (!syslogDiverted) {
	Dev_SyslogDebug(TRUE);
    }

    /*
     * We want to inform the user what caused the problem.  However we only
     * tell him if: 1) we are debugging the debugger; 2) we are not under 
     * debugger control (i.e. we don't want to inform the user on every trace 
     * trap), 3) we got something besides a trace trap or a breakpoint trap
     * exception.
     */
    cause = (mach_DebugState.causeReg & MACH_CR_EXC_CODE) >> 
						MACH_CR_EXC_CODE_SHIFT;
    if (dbgPanic) {
	dbgPanic = FALSE;
	mach_DebugState.excPC = mach_DebugState.regs[RA];
    }

    if (dbgTraceLevel >= 1 || !dbg_BeingDebugged || 
        cause != MACH_EXC_BREAK) {
	(void)Dev_VidEnable(TRUE); /* unblank the screen */
	printf("Entering debugger with a %s exception at PC 0x%x\r\n",
		   TranslateException((int)cause),
		   mach_DebugState.excPC);
    }
#ifdef KDBX
    if ((cause >= 0) && (cause < MACH_EXC_MAX)) {
	dbgSignal = sigMap[cause];
    } else {
	dbgSignal = SIGILL;
    }
#endif
    if (cause == MACH_EXC_BREAK) {
	unsigned		*pc;

	if (mach_DebugState.causeReg & MACH_CR_BR_DELAY) {
	    pc = (unsigned *)(mach_DebugState.excPC + 4);
	} else {
	    pc = (unsigned *)mach_DebugState.excPC;
	}
	if (dbgTraceLevel >= 1) {
	    Mach_MonPrintf("break inst: %x\n", *pc);
	}
	if ((*pc & MACH_BREAK_CODE_FIELD) == MACH_SSTEP_VAL) {
	    if (dbgTraceLevel >= 1) {
		Mach_MonPrintf("sstep\n");
	    }
	    mach_DebugState.trapCause = CAUSE_SINGLE;
	    if (dbgTraceLevel >= 1) {
		Mach_MonPrintf("sstep (%x) = %x\n", pc, sstepInst);
	    }
	    Mach_FlushCode((Address)pc, 4);
	    *pc = sstepInst;
	    Mach_EmptyWriteBuffer();
	} else {
	    mach_DebugState.trapCause = CAUSE_BREAK;
	}
    }

    dbg_UsingNetwork = TRUE;

    if (dbg_BeingDebugged) {
        unsigned        char    ch;
	int	timeout = 5;
        ch = 0;
#ifdef KDBX
	if (useKdbx) {
	    Dbg_DbxMain();
	    goto there;
	}
#endif
        PutReplyBytes(1, (Address)&ch);
        SendReply();
        do {
            if (ReadRequest(TRUE)) {
                GetRequestBytes(4, (Address)&opcode);
		if (opcode != DBG_CONTINUE) {
		    break;
		} else {
		    PutReplyBytes(4, (Address) &opcode);
		    SendReply();
		    continue;
		}
            }
            /*
             * We can only timeout if we are using network debugging.
             */
	    Net_RawOutput(dbgInterPtr, (Address) replyBuffer, 
		    &dbgGather, 1);
            if (dbgTraceLevel >= 5) {
                Mach_MonPrintf("DBG: Timeout\n");
            }
            Mach_MonPrintf("TI ");
        } while (timeout-- > 0);
    } else {
        (void) ReadRequest(FALSE);
#ifdef KDBX
	if (useKdbx) {
	    Dbg_DbxMain();
	    goto there;
	}
#endif
        GetRequestBytes(4, (Address)&opcode);
    }

    Vm_MachDumpTLB(dbgTLB);

    done = FALSE;
    while (!done) {
	if (dbgTraceLevel >= 2) {
	    Mach_MonPrintf("Request: (%d) %s\n", opcode, TranslateOpcode(opcode));
	}
	switch (opcode) {

	    /*
	     * The client wants to read some data from us ...
	     */

	    case DBG_GET_STOP_INFO: {
		StopInfo	stopInfo;
		stopInfo.codeStart = (int)mach_CodeStart;
		if (procPtr != (Proc_ControlBlock *) NIL &&
		    procPtr->machStatePtr != (Mach_State *)NIL) {
		    stopInfo.regs = procPtr->machStatePtr->switchRegState;
		    /*
		     * The pc isn't stored in switchRegState, but we know
		     * that we had to be in Mach_ContextSwitch.  Also,
		     * when the context switch is done the status register
		     * and a magic number are pushed on the stack. We
		     * need to adjust the sp so that the debugger doesn't
		     * get confused by them. 
		     */
		    stopInfo.regs.pc = (Address) 
					((int) Mach_ContextSwitch + 16);
		    stopInfo.regs.regs[SP] += 8;
		} else {
		    DebugToRegState(&mach_DebugState, &stopInfo.regs);
		}
		stopInfo.trapType = cause;
		PutReplyBytes(sizeof(stopInfo), (Address)&stopInfo);
		SendReply();
		break;
	    }
	    case DBG_READ_ALL_REGS: {
		Mach_RegState	regState;
		if (procPtr != (Proc_ControlBlock *) NIL &&
		    procPtr->machStatePtr != (Mach_State *)NIL) {
		    regState = procPtr->machStatePtr->switchRegState;
		    regState.pc = (Address) (Mach_SwitchPoint);
		    regState.pc = (Address) 
			    ((int) Mach_ContextSwitch + 16);
		    regState.regs[SP] += 8;
		} else {
		    DebugToRegState(&mach_DebugState, &regState);
		}
		PutReplyBytes(sizeof(regState), (Address) &regState);
		SendReply();
	    }
	    case DBG_GET_DUMP_BOUNDS: {
		Dbg_DumpBounds bounds;
		extern unsigned int end;
		bounds.pageSize = vm_PageSize;
		bounds.stackSize = mach_KernStackSize;
		bounds.kernelCodeStart = (unsigned int) mach_KernStart;
		bounds.kernelCodeSize  = 
			(unsigned int) (vmBootEnd - mach_KernStart);
		bounds.kernelDataStart	= VMMACH_VIRT_CACHED_START;
		bounds.kernelDataSize	= (unsigned int) 
				(vmMemEnd - VMMACH_VIRT_CACHED_START);
		bounds.kernelStacksStart = (unsigned int)vmStackBaseAddr;
		bounds.kernelStacksSize = (unsigned int) 
				(vmStackEndAddr - vmStackBaseAddr);
		bounds.fileCacheStart	= (unsigned int)vmBlockCacheBaseAddr;
		bounds.fileCacheSize	= (unsigned int) (vmBlockCacheEndAddr - 
						vmBlockCacheBaseAddr);

		PutReplyBytes(sizeof(bounds), (char *)&bounds);
		SendReply();
		break;
	    }
	    case DBG_GET_VERSION_STRING: {
		char	*version;

		version = SpriteVersion();
		PutReplyBytes(strlen(version) + 1, version);
		SendReply();
		break;
	    }
	    case DBG_INST_READ:
	    case DBG_DATA_READ: {
		Dbg_ReadMem	readMem;
		int		status;

		GetRequestBytes(sizeof(readMem), (Address) &readMem); 
		if (dbgTraceLevel >= 2) {
		    Mach_MonPrintf("Addr=%x Numbytes=%d ",
				readMem.address, readMem.numBytes);
		}
		if (Dbg_InRange(readMem.address, readMem.numBytes, FALSE)) {
		    status = 1;
		    PutReplyBytes(sizeof(status), (Address)&status);
		    PutReplyBytes(readMem.numBytes, (Address)readMem.address);
		} else {
		    if (dbgTraceLevel >= 2) {
			Mach_MonPrintf("FAILURE ");
		    }
		    status = 0;
		    PutReplyBytes(sizeof(status), (Address)&status);
		}
		SendReply();
		break;
	    }
	    case DBG_SET_PID: {
		Proc_PID	pid;

		GetRequestBytes(sizeof(pid), (Address) &pid);
		 {
		    int	dummy;

		    PutReplyBytes(4, (Address) &dummy);
		    SendReply();
		}
		if (dbgTraceLevel >= 2) {
		    Mach_MonPrintf("pid %x ", pid);
		}
		if (pid == 0) {
		    procPtr = (Proc_ControlBlock *) NIL;
		} else {
		    procPtr = Proc_GetPCB(pid);
		    if (procPtr == (Proc_ControlBlock *) NIL ||
		        procPtr == (Proc_ControlBlock *) 0 ||
			procPtr->state == PROC_UNUSED ||
		        procPtr->state == PROC_DEAD ||
			procPtr->state == PROC_NEW) {
			Mach_MonPrintf("Can't backtrace stack for process %x\n",
					pid);
			procPtr = (Proc_ControlBlock *) NIL;
		    }
		}
		break;
	    }
	    case DBG_REBOOT: {
		int	stringLength;
		char	rebootString[100];
		/*
		 * For a reboot command first read the size of the string and
		 * then the string itself.
		 */
		GetRequestBytes(sizeof(int), (Address)&stringLength);
		if (stringLength != 0) {
		    GetRequestBytes(stringLength, (Address)rebootString);
		}
		rebootString[stringLength] = '\0';
		 {
		    int	dummy;

		    PutReplyBytes(4, (Address) &dummy);
		    SendReply();
		}
		Mach_MonReboot(rebootString);
	    }
	    case DBG_INST_WRITE:
	    case DBG_DATA_WRITE: {
		Dbg_WriteMem		writeMem;
		unsigned	char	ch;
		/*
		 * For an instruction or a data write we first have to find out 
		 * which address to write to and how many bytes to write.  Next
		 * we have to make sure that the address is valid.  If it is
		 * then we read the data and write it to the given address.  If
		 * not we just report an error to kdbx.
		 */
		GetRequestBytes(2 * sizeof(int), (Address) &writeMem);
		if (dbgTraceLevel >= 2) {
		    Mach_MonPrintf("Addr=%x Numbytes=%d ",
				writeMem.address, writeMem.numBytes);
		}
		if (Dbg_InRange((unsigned int) writeMem.address,
			    writeMem.numBytes, opcode == DBG_DATA_WRITE)) {
		    GetRequestBytes(writeMem.numBytes,
				    (Address) writeMem.address);
		    if (opcode == DBG_INST_WRITE) {
			Mach_FlushCode((Address)writeMem.address, 
			    writeMem.numBytes);
			Mach_EmptyWriteBuffer();
		    }
		    ch = 1;
		} else {
		    char	buf[100];

		    if (dbgTraceLevel >= 2) {
			Mach_MonPrintf("FAILURE ");
		    }
		    GetRequestBytes(writeMem.numBytes, buf);
		    ch = 0;
		}
		PutReplyBytes(1, (char *) &ch);
		SendReply();

		break;
	    }
	    case DBG_WRITE_REG: {                
		Mach_RegState	regState;
		Dbg_WriteReg	writeReg;

		/*
		 * First find out which register is being written and
		 * then read the value.
		 */
		GetRequestBytes(sizeof(writeReg), (Address)&writeReg);
		 {
		    int	dummy;

		    PutReplyBytes(4, (Address) &dummy);
		    SendReply();
		}
		if (dbgTraceLevel >= 2) {
		    Mach_MonPrintf("register %d data %x ", writeReg.regNum, 
				writeReg.regVal);
		}
		if (procPtr != (Proc_ControlBlock *) NIL &&
		    procPtr->machStatePtr != (Mach_State *)NIL) {
		    ((int *) 
		    &procPtr->machStatePtr->switchRegState)[(writeReg.regNum)] 
			= writeReg.regVal;
		} else {
		    DebugToRegState(&mach_DebugState, &regState);
		    ((int *) &regState)[(writeReg.regNum)] = writeReg.regVal;
		    RegStateToDebug(&regState, &mach_DebugState);
		}
	    }
	    case DBG_DIVERT_SYSLOG: 
		GetRequestBytes(sizeof(Boolean), (Address)&syslogDiverted);
		 {
		    int	dummy;

		    PutReplyBytes(4, (Address) &dummy);
		    SendReply();
		}
		break;
	    case DBG_BEGIN_CALL: {
		/*
		 * We are beginning a call command.  Fix up the stack
		 * so that we will be able to continue.  We will put
		 * it back when we are done.
		 */
		int	dummy;
		if (dbgCanUseSyslog) {
		    dbg_UsingSyslog = TRUE;
		}

		PutReplyBytes(4, (Address) &dummy);
		SendReply();

		break;
	    }
	    case DBG_END_CALL: {
		char	*buffer;
		int	*firstIndexPtr;
		int	*lastIndexPtr;
		int	bufSize;
		int	length;
		/*
		 * Dump the syslog buffer.
		 */
		Dev_SyslogReturnBuffer(&buffer, &firstIndexPtr,
				       &lastIndexPtr, &bufSize);
		if (*firstIndexPtr == -1) {
		    length = 0;
		    PutReplyBytes(4, (Address) &length);
		    dbg_UsingSyslog = FALSE;
		} else if (*firstIndexPtr <= *lastIndexPtr) {
		    length = *lastIndexPtr - *firstIndexPtr + 1;
		    if (length + 4 > PACKET_DATA_SIZE) {
			length = PACKET_DATA_SIZE - 4;
		    }
		    PutReplyBytes(4, (Address) &length);
		    PutReplyBytes(length,
				  (Address)&buffer[*firstIndexPtr]);
		    *firstIndexPtr += length;
		    if (*firstIndexPtr > *lastIndexPtr) {
			*firstIndexPtr = *lastIndexPtr = -1;
		    }
		} else {
		    length = bufSize - *firstIndexPtr;
		    if (length + 4 > PACKET_DATA_SIZE) {
			length = PACKET_DATA_SIZE - 4;
		    }
		    PutReplyBytes(4, (Address) &length);
		    PutReplyBytes(length,
				  (Address)buffer[*firstIndexPtr]);
		    *firstIndexPtr += length;
		    if (*firstIndexPtr == bufSize) {
			*firstIndexPtr = 0;
		    }
		}
		SendReply();
		break;
	    }
	    case DBG_CALL_FUNCTION: {
		Dbg_CallFunc		callFunc;
		int			returnVal;
		static int		argBuf[128];
		GetRequestBytes(2 * sizeof(int), (Address) &callFunc);
		if (dbgTraceLevel >= 2) {
		    Mach_MonPrintf("Addr=%x Numbytes=%d ",
				callFunc.address, callFunc.numBytes);
		}
		if ((callFunc.numBytes >= 0 && callFunc.numBytes < 128) &&
		     Dbg_InRange((unsigned int) callFunc.address,4,FALSE)) {
		    GetRequestBytes(callFunc.numBytes,(Address) argBuf);
		    returnVal = (* ((int (*)()) callFunc.address))(argBuf[0],
		    argBuf[1],argBuf[2],argBuf[3],argBuf[4],argBuf[5],argBuf[6],
		    argBuf[7],argBuf[8],argBuf[9]);
		} else {

		    if (dbgTraceLevel >= 2) {
			Mach_MonPrintf("FAILURE ");
		    }
		    GetRequestBytes(callFunc.numBytes,(Address)argBuf);
		    returnVal = -1;
		}
		PutReplyBytes(4, (char *) &returnVal);
		SendReply();

		break;
	    }
	    case DBG_CONTINUE: {
		/*
		 * The client wants to continue execution.
		 */
		int	foo;
		GetRequestBytes(sizeof(int), 
			    (Address) &foo);
		if (dbgTraceLevel >= 2) {
		    Mach_MonPrintf("Continuing from pc %x ",debugStatePtr->excPC);
		}
		{
		    int	dummy;

		    PutReplyBytes(4, (Address) &dummy);
		    SendReply();
		}

		dbg_BeingDebugged = TRUE;
		done = TRUE;
		break;
	    }
	    case DBG_SINGLESTEP: {
		/*
		 * The client wants to single step.
		 */
		unsigned		*pc;
		int			status;
		int			dummy;

		GetRequestBytes(sizeof(int),  (Address) &dummy);
		pc = DbgGetDestPC((Address)(debugStatePtr->excPC));
		if (dbgTraceLevel >= 1) {
		    Mach_MonPrintf("Single-step PC=%x\n", pc);
		}
		if (!Dbg_InRange((unsigned int)pc, 4, TRUE)) {
		    Mach_MonPrintf("Bad SSTEP PC\n");
		    status = 0;
		} else {
		    sstepInst = *pc;
		    Mach_FlushCode((Address)pc, 4);
		    *pc = SSTEP_INST;
		    Mach_EmptyWriteBuffer();
		    dbg_BeingDebugged = TRUE;
		    done = TRUE;
		    status = 1;
		}
		PutReplyBytes(sizeof(status), (Address) &status);
		SendReply();
		break;
	    }
	    case DBG_DETACH:
		/*
		 * The debugger has terminated and wants to let us go about our
		 * business.
		 */
		if (dbgTraceLevel >= 2) {
		    Mach_MonPrintf("Detaching at pc %x ", debugStatePtr->excPC);
		}
	        {
		    int	dummy;

		    PutReplyBytes(4, (Address) &dummy);
		    SendReply();
		}

		dbg_BeingDebugged = FALSE;
		done = TRUE;
		printf("Sprite is now detached from the debugger\r\n");
		break;
	    case DBG_UNKNOWN:
		Mach_MonPrintf("debugger: unrecognized request\n");
		break;
	}
	if (dbgTraceLevel >= 2) {
	    Mach_MonPrintf("\r\n");
	}
	if (!done) {
	    (void)ReadRequest(FALSE);
	    GetRequestBytes(4, (Address)&opcode);
	}
    }

#ifdef KDBX
there:
#endif
    /*
     * Don't force system log output to the console.
     */
    if (!syslogDiverted) {
	Dev_SyslogDebug(FALSE);
    }

    if (dbgTraceLevel >= 1) {
	Mach_MonPrintf("Returning to %x: %x\n", debugStatePtr->excPC, 
				*(unsigned *)debugStatePtr->excPC);
    }

    mach_AtInterruptLevel = atInterruptLevel;
    dbg_UsingNetwork = FALSE;
    /*
     * Flush out the old TLB mapping.
     */
    VmMachWriteIndexedTLB(0, 0, 0);

    dbg_InDebugger = FALSE;

    return(debugStatePtr->excPC);
}

/*
 *----------------------------------------------------------------------
 *
 * DebugToRegState --
 *
 *	Converts a Mach_DebugState to Mach_RegState.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static void
DebugToRegState(debugPtr, regPtr)
    Mach_DebugState	*debugPtr;
    Mach_RegState	*regPtr;
{
    regPtr->pc = (Address) debugPtr->excPC;
    bcopy((char *) debugPtr->regs, (char *) regPtr->regs, 
	MACH_NUM_GPRS * sizeof(int));
    bcopy((char *) debugPtr->fpRegs, (char *) regPtr->fpRegs, 
	MACH_NUM_FPRS * sizeof(int));
    regPtr->fpStatusReg = debugPtr->fpCSR;
    regPtr->mfhi = debugPtr->multHi;
    regPtr->mflo = debugPtr->multLo;
}

/*
 *----------------------------------------------------------------------
 *
 * RegStateToDebug --
 *
 *	Converts a Mach_RegState to Mach_DebugState.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
RegStateToDebug(regPtr, debugPtr)
    Mach_RegState	*regPtr;
    Mach_DebugState	*debugPtr;
{
    debugPtr->excPC = (unsigned) regPtr->pc;
    bcopy((char *) regPtr->regs, (char *) debugPtr->regs, 
	MACH_NUM_GPRS * sizeof(int));
    bcopy((char *) regPtr->fpRegs, (char *) debugPtr->fpRegs, 
	MACH_NUM_FPRS * sizeof(int));
    debugPtr->fpCSR = regPtr->fpStatusReg;
    debugPtr->multHi = regPtr->mfhi;
    debugPtr->multLo = regPtr->mflo;
}

@


9.12
log
@*** empty log message ***
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/dbg/ds3100.md/dbgMain.c,v 9.11 92/03/11 13:26:33 jhh Exp $ SPRITE (Berkeley)";
a318 2
	Mach_MonPrintf("Got a debugger packet on non-ethernet interface %s\n",
	    interPtr->name);
@


9.11
log
@Got rid of left-over printfs.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/dbg/ds3100.md/dbgMain.c,v 9.10 92/03/11 13:07:53 jhh Exp $ SPRITE (Berkeley)";
d39 6
a810 1
#if 0
d818 2
a819 2
			(unsigned int) (((Address)(&end)) - mach_KernStart);
		bounds.kernelDataStart	= ((unsigned int)(&end));
d821 1
a821 1
				(vmMemEnd - ((Address)(&end)));
a832 1
#endif
@


9.10
log
@Adding to a function address cast as a char * didn't work. Probably a
compiler bug.  Turned it into an int cast seemed to work.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/dbg/ds3100.md/dbgMain.c,v 9.9 91/08/09 16:27:37 jhh Exp $ SPRITE (Berkeley)";
a781 2
		    printf("DBG_GET_STOP_INFO: pc = 0x%x, sp = 0x%x\n",
			stopInfo.regs.pc, stopInfo.regs.regs[SP]);
a798 2
		    printf("DBG_READ_ALL_REGS: pc = 0x%x, sp = 0x%x\n",
			regState.pc, regState.regs[SP]);
@


9.9
log
@Changes for kgdb support.
(Checked in by shirriff)
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/dbg.jhh/ds3100.md/RCS/dbgMain.c,v 9.9 91/08/01 17:24:40 jhh Exp $ SPRITE (Berkeley)";
d780 1
a780 1
			    ((char *) Mach_ContextSwitch + 16);
d782 2
d799 1
a799 1
			    ((char *) Mach_ContextSwitch + 16);
d801 2
@


9.8
log
@Took out disk sync.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/dbg/ds3100.md/RCS/dbgMain.c,v 9.7 91/05/27 16:41:05 jhh Exp Locker: mgbaker $ SPRITE (Berkeley)";
d35 5
a39 1
unsigned sstepInst;				/* The instruction that was
d51 1
a51 1
char	requestBuffer[DBG_MAX_REQUEST_SIZE + 2];/* Buffer to receive request
d53 7
a59 7
char	*requestBufPtr = requestBuffer + 2;	/* Offset the buffer by 2 so
						 * we four byte align the 
						 * data in the packet. */
char	replyBuffer[DBG_MAX_REPLY_SIZE + 2];	/* Buffer to hold reply. */
char	*replyBufPtr = replyBuffer + 2;		/* Offset the buffer by 2 so
						 * we four byte align the 
						 * data in the packet. */
d71 1
a71 1
Boolean			gotPacket;	
d83 2
a84 3
#define	PACKET_HDR_SIZE (sizeof(Net_EtherHdr) + Dbg_PacketHdrSize())
#define PACKET_DATA_SIZE \
    (DBG_MAX_REPLY_SIZE - PACKET_HDR_SIZE - sizeof(Dbg_Reply) + 4)
a85 7
/*
 * Message buffers.
 */

Dbg_Request	*requestPtr;
Dbg_Reply	*replyPtr;
char		*dataPtr;
d90 1
a90 26
static char *opcodeNames[] =  {
    "Unknown",
    "IREAD",
    "DREAD",
    "UREAD",
    "IWRITE",
    "DWRITE",
    "UWRITE",
    "CONTP",
    "PKILL",
    "SSTEP",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "DBREAD",
    "DBWRITE",
    "DHREAD",
    "DHWRITE",
    "QUERY",
    "BEGINCALL",
    "ENDCALL",
    "DETACH",
    "GETMAXSTACK",
    "GETSTATUS",
};
d95 1
a95 15
static char *exceptionNames[] = {
    "Interrupt",
    "TLB Mod",
    "TLB LD miss",
    "TLB ST miss",
    "TLB load address error",
    "TLB store address error",
    "TLB ifetch bus error",
    "TLB load or store bus error",
    "System call",
    "Breakpoint trap",
    "Reserved instruction",
    "Coprocessor unusable",
    "Overflow"
};
d98 1
a98 1
 * The type of machine that we are on.
d100 1
a100 1
int		machineType;
a108 1
int		dbgMaxStackAddr;
d111 5
a115 1

a126 2
Boolean	dbg_OthersCanUseNetwork = TRUE;

d135 4
d140 19
d189 1
a189 1
	printf("Dbg_InRange: Object spans pages\n");
d272 3
d279 3
a281 3
    dbgMaxStackAddr = (int)mach_StackBottom + mach_KernStackSize;
    replyPtr = (Dbg_Reply *)(replyBufPtr + PACKET_HDR_SIZE);
    dataPtr = replyBufPtr + PACKET_HDR_SIZE + sizeof(Dbg_Reply) - 4;
a283 2
char	pingBuffer[DBG_MAX_REQUEST_SIZE + 2];
char	*pingBufPtr = pingBuffer + 2;
d297 1
a297 1
 *     gotPacket is set to true if we got a packet that we liked.
d313 1
a313 1
	printf("Got a debugger packet on non-ethernet interface %s\n",
d341 1
a341 1
	    printf("Non-IP (Type=0x%x) ",
d346 4
a349 1
    if (gotPacket) {
d353 1
a353 1
	printf("Validating packet\n");
d355 12
a366 6
    if (Dbg_ValidatePacket(packetLength - sizeof(Net_EtherHdr),
			   (Net_IPHeader *)(packetPtr + sizeof(Net_EtherHdr)),
			   &dataLength, &dataPtr,
			   &dbgMyIPAddr, &dbgSrcIPAddr, &dbgSrcPort)) {
	if (dbgTraceLevel >= 4) {
	    printf("Got a packet: length=%d\n", dataLength);
a367 10
	bcopy((Address)etherHdrPtr, (Address)&dbgEtherHdr,
		sizeof(Net_EtherHdr));
	gotPacket = TRUE;
	bcopy(dataPtr, requestBuffer, dataLength);
	/*
	 * Set the interface we are using. 
	 */
	dbgInterPtr = interPtr;
	return;
    }
d369 22
a390 36
    if (Net_NetToHostShort(etherHdrPtr->type) != 0x800) {
	return;
    }
    /*
     * Handle ICMP echo requests.  This is a good test of the
     * basic networking code.
     */
    bcopy(packetPtr, pingBufPtr, packetLength);
    etherHdrPtr = (Net_EtherHdr *)pingBufPtr;
    ipPtr = (Net_IPHeader *)(pingBufPtr + sizeof(Net_EtherHdr));
    if (ipPtr->protocol == NET_IP_PROTOCOL_ICMP) {
	Net_InetAddress	tAddr;
	Net_EtherAddress	tEtherAddr;
	Net_ICMPHeader	*icmpPtr;

	tEtherAddr = etherHdrPtr->source;
	etherHdrPtr->source = etherHdrPtr->destination;
	etherHdrPtr->destination = tEtherAddr;
	tAddr = ipPtr->source;
	ipPtr->source = ipPtr->dest;
	ipPtr->dest = tAddr;
	icmpPtr = (Net_ICMPHeader *)((Address)ipPtr + ipPtr->headerLen * 4);
	if (icmpPtr->type == 8) {
	    Mach_MonPrintf("ICMP Echo\n");
	    icmpPtr->type = 0;
	    icmpPtr->checksum = 0;
	    icmpPtr->checksum = 
		Net_InetChecksum(
		(int)(Net_NetToHostShort(ipPtr->totalLen)-ipPtr->headerLen*4),
		(Address)icmpPtr);
	    dbgGather.length = packetLength - sizeof(Net_EtherHdr);
	    dbgGather.bufAddr = pingBufPtr + sizeof(Net_EtherHdr);
	    Net_RawOutput(dbgInterPtr, etherHdrPtr, &dbgGather, 1);
	}
    }
}
d417 1
a417 1
    gotPacket = FALSE;
d430 1
a430 1
	    if (gotPacket) {
d437 12
a448 3
    } while(!gotPacket && timeOutCounter != 0);
    if (gotPacket) {
	requestPtr = (Dbg_Request *)requestBuffer;
d450 1
a450 1
	    printf("MsgNum = %d\n", requestPtr->num);
d454 25
a478 1
    return(gotPacket);
d485 29
d533 1
a533 1
	printf("Sending reply\n");
a534 1
    replyPtr->num = requestPtr->num;
d536 1
a536 1
    etherHdrPtr = (Net_EtherHdr *) replyBufPtr;
d540 2
a541 3
    dbgGather.bufAddr = replyBufPtr + sizeof(Net_EtherHdr);
    dbgGather.length = PACKET_HDR_SIZE + sizeof(Dbg_Reply) + dataSize - 
		       sizeof(Net_EtherHdr);
d543 1
d545 2
a546 2
		     dataSize + sizeof(Dbg_Reply),
		     replyBufPtr + sizeof(Net_EtherHdr));
d549 1
a549 1
	printf("Sent reply\n");
a552 4
/*
 * Whether syslog should remain diverted on continue or not.
 */
static Boolean	syslogDiverted = FALSE;
d567 1
a567 2
Mach_DebugState	tmpDebugState;
Mach_DebugState	*debugStatePtr;
a588 2
    Boolean	done;
    Boolean	atInterruptLevel;
d590 9
a598 5
    int		signal;
    int		origSignal;
    int		dataSize;
    int		origMaxStackAddr;

a620 1
    origMaxStackAddr = dbgMaxStackAddr;
d672 9
d682 11
a692 28
    switch (cause) {
        case MACH_EXC_INT:
	    signal = 2;
	    break;
        case MACH_EXC_TLB_MOD:
        case MACH_EXC_TLB_LD_MISS:
        case MACH_EXC_TLB_ST_MISS:
	    signal = 11;
	    break;
        case MACH_EXC_ADDR_ERR_LD:
        case MACH_EXC_ADDR_ERR_ST:
	    signal = 10;
	    break;
        case MACH_EXC_BUS_ERR_IFETCH:
        case MACH_EXC_BUS_ERR_LD_ST:
	    signal = 10;
	    break;
        case MACH_EXC_SYSCALL:
	    signal = 12;
	    break;
        case MACH_EXC_BREAK: {
	    unsigned		*pc;

	    signal = 5;
	    if (mach_DebugState.causeReg & MACH_CR_BR_DELAY) {
		pc = (unsigned *)(mach_DebugState.excPC + 4);
	    } else {
		pc = (unsigned *)mach_DebugState.excPC;
d694 1
d696 1
a696 1
		printf("break inst: %x\n", *pc);
d698 6
a703 29
	    if ((*pc & MACH_BREAK_CODE_FIELD) == MACH_SSTEP_VAL) {
		if (dbgTraceLevel >= 1) {
		    printf("sstep\n");
		}
		mach_DebugState.trapCause = CAUSE_SINGLE;
		if (dbgTraceLevel >= 1) {
		    printf("sstep (%x) = %x\n", pc, sstepInst);
		}
		Mach_FlushCode((Address)pc, 4);
		*pc = sstepInst;
		Mach_EmptyWriteBuffer();
	    } else {
		mach_DebugState.trapCause = CAUSE_BREAK;
	    }
	    break;
	}
        case MACH_EXC_RES_INST:
	    signal = 4;
	    break;
        case MACH_EXC_COP_UNUSABLE:
	    signal = 4;
	    break;
        case MACH_EXC_OVFLOW:
	    signal = 4;
	    break;
	default:
	    printf("Bad cause\n");
	    signal = 4;
	    break;
a704 1
    origSignal = signal;
d709 15
a723 4
	SendReply(0);
	do {
	    if (ReadRequest(TRUE)) {
		if (requestPtr->request == DBG_GETSTATUS) {
d725 4
d730 5
a734 2
	    }
	    Net_RawOutput(dbgInterPtr, (Net_EtherHdr *)replyBuffer, 
d736 5
a740 2
	    printf("TI: %d ", requestPtr->request);
	} while (TRUE);
d742 8
a749 1
	(void) ReadRequest(FALSE);
d756 4
a759 1
	int	request;
d761 90
a850 72
	dataSize = 0;
	replyPtr->status = 1;
	replyPtr->data = 0;
	request = requestPtr->request;
	if (dbgTraceLevel >= 1) {
	    printf("Request: %d, %s at %x\n", request, 
			TranslateOpcode(request), requestPtr->addr);
	}
	switch (request) {
            case DBG_UREAD:
		if (requestPtr->addr > sizeof(mach_DebugState) / 4) {
		    printf("Bogus UREAD addr %x\n", requestPtr->addr);
		    replyPtr->status = 0;
		} else {
		    replyPtr->data = *((int *)debugStatePtr + requestPtr->addr);
		}
		break;
            case DBG_UWRITE: {
		extern void Mach_SwitchPoint();	/* XXX - should go elsewhere */

		if (requestPtr->addr == (unsigned)-1) {
		    Proc_ControlBlock	*procPtr;

		    if (requestPtr->data == 0) {
			debugStatePtr = &mach_DebugState;
			signal = origSignal;
			dbgMaxStackAddr = origMaxStackAddr;
			break;
		    } else {
			procPtr = Proc_GetPCB(requestPtr->data);
			if (procPtr == (Proc_ControlBlock *)NIL ||
			    procPtr->machStatePtr == (Mach_State *)NIL) {
			    printf("Bad process table index %d\n", 
				    requestPtr->data);
			    break;
			}
		    }
		    debugStatePtr = &tmpDebugState;
		    bcopy((char *) procPtr->machStatePtr->switchRegState.regs,
			  (char *) tmpDebugState.regs, 32 * sizeof(int));
		    tmpDebugState.excPC = (unsigned)(Address)Mach_SwitchPoint;
		    dbgMaxStackAddr = (int)procPtr->machStatePtr->kernStackEnd;
		    signal = 2;
		} else if (requestPtr->addr == (unsigned)-2) {
		    (void)Proc_Dump();
		} else {
		    if (requestPtr->addr > sizeof(mach_DebugState) / 4) {
			printf("Bogus UWRITE addr %x\n", requestPtr->addr);
			replyPtr->status = 0;
		    } else {
			replyPtr->data =
				*((int *)debugStatePtr + requestPtr->addr);
			*((int *)debugStatePtr + requestPtr->addr) =
							requestPtr->data;
		    }
		}
		break;
	    }
            case DBG_IREAD:
            case DBG_DREAD:
		if (Dbg_InRange(requestPtr->addr, 4, FALSE)) {
		    replyPtr->data = *(int *)requestPtr->addr;
		} else {
		    replyPtr->status = 0;
		}
		break;
            case DBG_IWRITE:
		if (Dbg_InRange(requestPtr->addr, 4, TRUE)) {
		    replyPtr->data = *(int *)requestPtr->addr;
		    Mach_FlushCode((Address)requestPtr->addr, 4);
		    *(int *)requestPtr->addr = requestPtr->data;
		    Mach_EmptyWriteBuffer();
d852 35
a886 1
		    replyPtr->status = 0;
d889 143
a1031 4
            case DBG_DWRITE:
		if (Dbg_InRange(requestPtr->addr, 4, TRUE)) {
		    replyPtr->data = *(int *)requestPtr->addr;
		    *(int *)requestPtr->addr = requestPtr->data;
d1033 11
a1043 1
		    replyPtr->status = 0;
d1045 1
d1047 46
a1092 1
            case DBG_CONTP: 
d1096 5
a1100 1
            case DBG_SSTEP: {
d1102 2
d1105 1
d1108 1
a1108 1
		    printf("Single-step PC=%x\n", pc);
d1111 28
a1138 3
		    printf("Bad SSTEP PC\n");
		    replyPtr->status = 0;
		    break;
d1140 1
a1140 47
		sstepInst = *pc;
		Mach_FlushCode((Address)pc, 4);
		*pc = SSTEP_INST;
		Mach_EmptyWriteBuffer();
		dbg_BeingDebugged = TRUE;
		done = TRUE;
		break;
	    }
            case DBG_PKILL:
		break;
            case DBG_DBREAD: 
		if (Dbg_InRange(requestPtr->addr, 1, FALSE)) {
		    replyPtr->data = *(char *)requestPtr->addr;
		} else {
		    replyPtr->status = 0;
		}
		break;
            case DBG_DBWRITE:
		if (Dbg_InRange(requestPtr->addr, 1, TRUE)) {
		    replyPtr->data = *(char *)requestPtr->addr;
		    *(char *)requestPtr->addr = requestPtr->data;
		} else {
		    replyPtr->status = 0;
		}
		break;
            case DBG_DHREAD:
		if (Dbg_InRange(requestPtr->addr, 2, FALSE)) {
		    replyPtr->data = *(short *)requestPtr->addr;
		} else {
		    replyPtr->status = 0;
		}
		break;
            case DBG_DHWRITE:
		if (Dbg_InRange(requestPtr->addr, 2, TRUE)) {
		    replyPtr->data = *(short *)requestPtr->addr;
		    *(short *)requestPtr->addr = requestPtr->data;
		} else {
		    replyPtr->status = 0;
		}
		break;
            case DBG_QUERY:
		break;
            case DBG_BEGINCALL:
		break;
            case DBG_ENDCALL:
		break;
            case DBG_DETACH:
d1145 2
a1146 2
            case DBG_GETMAXSTACK:
		replyPtr->data = dbgMaxStackAddr;
d1148 3
a1150 16
            case DBG_GETSTATUS:
		replyPtr->data = 0177 | (signal << 8);
		break;
	    case DBG_GET_VERSION_STRING: {
		char *version;
		version = SpriteVersion();
		strncpy(dataPtr, version, PACKET_DATA_SIZE);
		dataSize = strlen(version) + 1 - 4;
		break;
	    }
	    case DBG_REBOOT: {
		char	*reboot;
		reboot = (char *) &requestPtr->data;
		Mach_MonReboot(reboot);
		break;
	    }
a1151 1
	SendReply(dataSize);
d1154 1
d1158 3
d1169 1
a1169 1
	printf("Returning to %x: %x\n", debugStatePtr->excPC, 
d1174 1
a1174 3
    if (dbg_OthersCanUseNetwork) {
	dbg_UsingNetwork = FALSE;
    }
d1184 62
@


9.7
log
@sync of disks when entering debugger can be disabled via a variable
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/dbg/ds3100.md/RCS/dbgMain.c,v 9.6 91/02/02 18:32:48 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
d574 4
d592 1
@


9.6
log
@fixed it so kmsg works.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /user5/src/kernel/dbg.jhh/ds3100.md/RCS/dbgMain.c,v 9.5 90/10/09 11:49:56 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
d530 6
d574 1
a574 1
    if (!dbg_BeingDebugged) {
d606 2
a607 2
	    if (*sp < (unsigned int)&etext && *sp >= (unsigned)0x80030000) {
		Mach_MonPrintf("%x ", *sp);
@


9.5
log
@new net module
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/dbg/ds3100.md/RCS/dbgMain.c,v 9.4 90/09/24 17:14:19 kupfer Exp Locker: jhh $ SPRITE (Berkeley)";
d33 1
d80 2
a81 1
#define PACKET_DATA_SIZE (DBG_MAX_REPLY_SIZE - PACKET_HDR_SIZE - sizeof(Reply))
a85 16
typedef struct Request {
    int		num;
    int		request;
    unsigned	addr;
    int		data;
} Request;

typedef struct {
    int		num;
    int		status;
    int		data;
} Reply;

Request	*requestPtr;
Reply	*replyPtr;
char	*dataPtr;
d87 4
d296 2
a297 2
    replyPtr = (Reply *)(replyBufPtr + PACKET_HDR_SIZE);
    dataPtr = replyBufPtr + PACKET_HDR_SIZE + sizeof(Reply);
d472 1
a472 1
	requestPtr = (Request *)requestBuffer;
d513 1
a513 1
    dbgGather.length = PACKET_HDR_SIZE + sizeof(Reply) + dataSize - 
d517 1
a517 1
		     dataSize + sizeof(Reply),
a531 20
#define UREAD   3       /* read from process's user structure */
#define UWRITE  6       /* write to process's user structure */
#define IREAD   1       /* read from process's instruction space */
#define IWRITE  4       /* write to process's instruction space */
#define DREAD   2       /* read from process's data space */
#define DWRITE  5       /* write to process's data space */
#define CONTP   7       /* continue stopped process */
#define SSTEP   9       /* continue for approximately one instruction */
#define PKILL   8       /* terminate the process */
#define DBREAD  14      /* read in bytes */
#define DBWRITE 15      /* write in bytes */
#define DHREAD  16      /* read in halfwords */
#define DHWRITE 17      /* write in halfwords */
#define QUERY   18      /* query returns flags about target environment */
#define BEGINCALL 19
#define ENDCALL   20
#define DETACH    21
#define GETMAXSTACK 22
#define GETSTATUS 23

d708 1
a708 1
		if (requestPtr->request == GETSTATUS) {
d735 1
a735 1
            case UREAD:
d743 1
a743 1
            case UWRITE: {
d784 2
a785 2
            case IREAD:
            case DREAD:
d792 1
a792 1
            case IWRITE:
d802 1
a802 1
            case DWRITE:
d810 1
a810 1
            case CONTP: 
d814 1
a814 1
            case SSTEP: {
d834 1
a834 1
            case PKILL:
d836 1
a836 1
            case DBREAD: 
d843 1
a843 1
            case DBWRITE:
d851 1
a851 1
            case DHREAD:
d858 1
a858 1
            case DHWRITE:
d866 1
a866 1
            case QUERY:
d868 1
a868 1
            case BEGINCALL:
d870 1
a870 1
            case ENDCALL:
d872 1
a872 1
            case DETACH:
d877 1
a877 1
            case GETMAXSTACK:
d880 1
a880 1
            case GETSTATUS:
d883 13
@


9.4
log
@Changes for function prototypes.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/dbg/ds3100.md/RCS/dbgMain.c,v 9.3 90/07/30 11:35:32 shirriff Exp Locker: kupfer $ SPRITE (Berkeley)";
d73 1
d330 4
a333 3
Dbg_InputPacket(packetPtr, packetLength)
    Address	packetPtr;
    int		packetLength;
d340 5
d391 4
d430 1
a430 1
	    Net_OutputRawEther(etherHdrPtr, &dbgGather, 1);
d456 3
a458 1
    int	timeOutCounter;
d463 14
a476 1
	Net_RecvPoll();
d529 1
a529 1
    Net_OutputRawEther(etherHdrPtr, &dbgGather, 1);
d742 2
a743 1
	    Net_OutputRawEther((Net_EtherHdr *)replyBufPtr, &dbgGather, 1);
@


9.3
log
@Removed #include vmMachInt.h
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/dbg/ds3100.md/RCS/dbgMain.c,v 9.2 90/07/18 14:54:34 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d18 15
a32 14
#include "sprite.h"
#include "dbg.h"
#include "dbgInt.h"
#include "mach.h"
#include "machConst.h"
#include "proc.h"
#include "vm.h"
#include "machMon.h"
#include "net.h"
#include "netEther.h"
#include "netInet.h"
#include "dev.h"
#include "sys.h"
#include "sync.h"
d178 8
a185 1
unsigned *DbgGetDestPC();
a212 1
    extern Boolean	VmMach_MakeDebugAccessible();
d239 1
a239 1
char *
d269 1
a269 1
char *
d440 1
a440 1
Boolean
a484 1
    void	Dbg_FormatPacket();
a580 1
	    void Sys_SyncDisks();
d636 1
a636 1
	(void)Dev_VidEnable();	/* unblank the screen */
d747 1
a747 1
		extern void Mach_SwitchPoint();
@


9.2
log
@Changed InRange to Dbg_InRange, so I can use it elsewhere.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/dbg.ken/ds3100.md/RCS/dbgMain.c,v 1.1 90/07/17 20:00:08 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
a23 1
#include "vmMachInt.h"
@


9.1
log
@Removed lint.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/dbg/ds3100.md/RCS/dbgMain.c,v 9.0 89/09/12 14:56:24 douglis Stable Locker: mendel $ SPRITE (Berkeley)";
d184 1
a184 1
 * InRange --
d199 1
a199 1
static Boolean InRange(addr, numBytes, writeable) 
d211 1
a211 1
	printf("InRange: Object spans pages\n");
d785 1
a785 1
		if (InRange(requestPtr->addr, 4, FALSE)) {
d792 1
a792 1
		if (InRange(requestPtr->addr, 4, TRUE)) {
d802 1
a802 1
		if (InRange(requestPtr->addr, 4, TRUE)) {
d820 1
a820 1
		if (!InRange((unsigned int)pc, 4, TRUE)) {
d836 1
a836 1
		if (InRange(requestPtr->addr, 1, FALSE)) {
d843 1
a843 1
		if (InRange(requestPtr->addr, 1, TRUE)) {
d851 1
a851 1
		if (InRange(requestPtr->addr, 2, FALSE)) {
d858 1
a858 1
		if (InRange(requestPtr->addr, 2, TRUE)) {
@


9.0
log
@Changing version numbers.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/dbg/ds3100.md/RCS/dbgMain.c,v 1.3 89/08/30 11:00:57 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d31 1
a165 5
 * True when a call is occuring.
 */
static	Boolean		callInProgress = FALSE;

/*
d198 1
d408 3
a410 2
		Net_InetChecksum(Net_NetToHostShort(ipPtr->totalLen) - ipPtr->headerLen * 4,
				 icmpPtr);
d576 1
d632 1
a632 1
	Dev_VidEnable();	/* unblank the screen */
d634 1
a634 1
		   TranslateException(cause),
d678 1
a678 1
		Mach_FlushCode(pc, 4);
d763 2
a764 2
		    bcopy(procPtr->machStatePtr->switchRegState.regs,
			  tmpDebugState.regs, 32 * sizeof(int));
d769 1
a769 1
		    Proc_Dump();
d794 1
a794 1
		    Mach_FlushCode(requestPtr->addr, 4);
d816 1
a816 1
		pc = DbgGetDestPC(debugStatePtr->excPC);
d820 1
a820 1
		if (!InRange(pc, 4, TRUE)) {
d826 1
a826 1
		Mach_FlushCode(pc, 4);
@


1.3
log
@reenable display before entering debugger.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/dbg/ds3100.md/RCS/dbgMain.c,v 1.2 89/08/17 17:46:27 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
@


1.2
log
@mike's changes for Mach_SwitchPoint
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/dbg/ds3100.md/dbgMain.c,v 1.1 89/07/10 19:51:23 nelson Exp $ SPRITE (Berkeley)";
d633 1
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: dbgMain.c,v 1.13 89/06/29 09:38:30 mnelson Exp $ SPRITE (Berkeley)";
d742 3
a744 1
            case UWRITE:
d765 1
a765 1
		    tmpDebugState.excPC = (unsigned)(Address)Mach_ContextSwitch;
d782 1
@
