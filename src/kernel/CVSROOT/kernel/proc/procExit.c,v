head     9.25;
branch   ;
access   ;
symbols  ds3100:9.25 sun3:9.25 sun4nw:9.21 symm:9.21 spur:9.21 sprited:9.19.1 Summer89:9.0 newlib:8.0 Summer88:6.0 argString:5.5;
locks    ; strict;
comment  @ * @;


9.25
date     92.06.01.14.38.03;  author kupfer;  state Exp;
branches ;
next     9.24;

9.24
date     92.02.14.14.44.50;  author kupfer;  state Exp;
branches ;
next     9.23;

9.23
date     92.01.06.15.09.23;  author kupfer;  state Exp;
branches ;
next     9.22;

9.22
date     91.11.15.21.05.18;  author kupfer;  state Exp;
branches ;
next     9.21;

9.21
date     91.09.17.22.12.28;  author kupfer;  state Exp;
branches ;
next     9.20;

9.20
date     91.08.24.19.55.26;  author mottsmth;  state Exp;
branches ;
next     9.19;

9.19
date     91.07.26.16.59.47;  author shirriff;  state Exp;
branches 9.19.1.1;
next     9.18;

9.18
date     90.12.07.23.44.57;  author rab;  state Exp;
branches ;
next     9.17;

9.17
date     90.11.06.16.51.23;  author shirriff;  state Exp;
branches ;
next     9.16;

9.16
date     90.10.09.11.53.22;  author jhh;  state Exp;
branches ;
next     9.15;

9.15
date     90.09.20.16.24.59;  author mgbaker;  state Exp;
branches ;
next     9.14;

9.14
date     90.09.12.13.58.06;  author jhh;  state Exp;
branches ;
next     9.13;

9.13
date     90.09.06.17.57.03;  author jhh;  state Exp;
branches ;
next     9.12;

9.12
date     90.09.04.23.45.02;  author shirriff;  state Exp;
branches ;
next     9.11;

9.11
date     90.07.30.15.46.52;  author douglis;  state Exp;
branches ;
next     9.10;

9.10
date     90.07.29.15.50.57;  author shirriff;  state Exp;
branches ;
next     9.9;

9.9
date     90.06.27.17.04.13;  author douglis;  state Exp;
branches ;
next     9.8;

9.8
date     90.06.27.11.19.17;  author douglis;  state Exp;
branches ;
next     9.7;

9.7
date     89.10.26.15.22.38;  author douglis;  state Exp;
branches ;
next     9.6;

9.6
date     89.10.25.11.39.53;  author shirriff;  state Exp;
branches ;
next     9.5;

9.5
date     89.10.23.13.49.30;  author douglis;  state Exp;
branches ;
next     9.4;

9.4
date     89.10.23.10.33.30;  author douglis;  state Exp;
branches ;
next     9.3;

9.3
date     89.10.12.12.15.49;  author jhh;  state Exp;
branches ;
next     9.2;

9.2
date     89.10.12.11.13.54;  author douglis;  state Exp;
branches ;
next     9.1;

9.1
date     89.09.20.16.17.17;  author mgbaker;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.15.08;  author douglis;  state Stable;
branches ;
next     8.14;

8.14
date     89.09.08.16.21.07;  author shirriff;  state Exp;
branches ;
next     8.13;

8.13
date     89.08.30.12.57.08;  author mgbaker;  state Exp;
branches ;
next     8.12;

8.12
date     89.08.22.14.56.59;  author douglis;  state Exp;
branches ;
next     8.11;

8.11
date     89.07.20.16.19.44;  author douglis;  state Exp;
branches ;
next     8.10;

8.10
date     89.07.10.19.11.30;  author nelson;  state Exp;
branches ;
next     8.9;

8.9
date     89.06.15.16.51.53;  author douglis;  state Exp;
branches ;
next     8.8;

8.8
date     89.05.30.16.12.59;  author jhh;  state Exp;
branches ;
next     8.7;

8.7
date     89.05.21.18.27.21;  author mgbaker;  state Exp;
branches ;
next     8.6;

8.6
date     89.03.31.12.06.34;  author mgbaker;  state Exp;
branches ;
next     8.5;

8.5
date     89.03.02.18.42.04;  author douglis;  state Exp;
branches ;
next     8.4;

8.4
date     89.03.02.16.51.26;  author douglis;  state Exp;
branches ;
next     8.3;

8.3
date     89.02.19.22.07.18;  author jhh;  state Exp;
branches ;
next     8.2;

8.2
date     89.02.07.17.38.50;  author mendel;  state Exp;
branches ;
next     8.1;

8.1
date     88.11.30.15.28.46;  author douglis;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.29.52;  author douglis;  state Stable;
branches ;
next     6.6;

6.6
date     88.11.08.15.59.47;  author douglis;  state Exp;
branches ;
next     6.5;

6.5
date     88.10.27.20.02.48;  author mlgray;  state Exp;
branches ;
next     6.4;

6.4
date     88.10.19.11.18.55;  author douglis;  state Exp;
branches ;
next     6.3;

6.3
date     88.10.07.12.54.50;  author douglis;  state Exp;
branches ;
next     6.2;

6.2
date     88.08.31.17.55.19;  author douglis;  state Exp;
branches ;
next     6.1;

6.1
date     88.08.25.12.09.08;  author nelson;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.22.17;  author brent;  state Stable;
branches ;
next     5.16;

5.16
date     88.08.04.15.29.32;  author douglis;  state Exp;
branches ;
next     5.15;

5.15
date     88.07.25.17.02.54;  author nelson;  state Exp;
branches ;
next     5.14;

5.14
date     88.07.18.15.03.45;  author douglis;  state Exp;
branches ;
next     5.13;

5.13
date     88.07.08.16.01.18;  author douglis;  state Exp;
branches ;
next     5.12;

5.12
date     88.06.30.17.35.31;  author douglis;  state Exp;
branches ;
next     5.11;

5.11
date     88.06.09.11.36.40;  author brent;  state Exp;
branches ;
next     5.10;

5.10
date     88.05.05.17.57.40;  author nelson;  state Exp;
branches ;
next     5.9;

5.9
date     88.05.04.16.46.00;  author nelson;  state Exp;
branches ;
next     5.8;

5.8
date     88.04.27.18.56.25;  author nelson;  state Exp;
branches ;
next     5.7;

5.7
date     88.04.22.14.20.42;  author nelson;  state Exp;
branches ;
next     5.6;

5.6
date     88.04.18.09.07.48;  author ouster;  state Exp;
branches ;
next     5.5;

5.5
date     87.12.22.14.32.45;  author douglis;  state Exp;
branches ;
next     5.4;

5.4
date     87.12.12.16.39.25;  author nelson;  state Exp;
branches ;
next     5.3;

5.3
date     87.10.22.14.58.01;  author nelson;  state Exp;
branches ;
next     5.2;

5.2
date     87.09.20.15.25.12;  author deboor;  state Exp;
branches ;
next     5.1;

5.1
date     87.08.27.10.46.27;  author brent;  state Exp;
branches ;
next     5.0;

5.0
date     87.08.11.10.47.01;  author sprite;  state Exp;
branches ;
next     ;

9.19.1.1
date     91.08.15.21.16.28;  author kupfer;  state Exp;
branches ;
next     ;


desc
@@


9.25
log
@Add support for system call timing.
@
text
@/*
 * procExit.c --
 *
 *	Routines to terminate and detach processes, and to cause a 
 *	process to wait for the termination of other processes.  This file
 *	maintains a monitor to synchronize between exiting, detaching, and
 *	waiting processes.  The monitor also synchronizes access to the
 *	dead list.
 *
 * Copyright 1986, 1988 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 *
 *	Proc table fields managed by this monitor:
 *
 *	    1) exitFlags is managed solely by this monitor.
 *	    2) When a process is about to exit the PROC_DYING flag is set
 *	       in the genFlags field.  Also PROC_NO_VM flag set before
 *	       freeing VM segments.
 *	    3) The only way a process can go to the exiting and dead states 
 *	       is through using routines in this file.
 *
 *	A process can be in one of several states:
 *
 *	PROC_READY:	It is ready to execute when a CPU becomes available.
 *			The PCB is attached to the Ready list.
 *	PROC_RUNNING:	It is currently executing on a CPU.
 *			The PCB is in the list of running processes.
 *	PROC_WAITING:	It is waiting for an event to occur. 
 *			The PCB is attached to an event-specific list of 
 *			waiting processes.
 *	PROC_EXITING:	It has finished executing but the PCB is kept around
 *			until the parent waits for it via Proc_Wait or dies
 *			via Proc_Exit.
 *	PROC_DEAD:	It has been waited on and the PCB is attached to 
 *			the Dead list.
 *	PROC_SUSPENDED  It is suspended from executing.
 *	PROC_UNUSED:	There is no process using this PCB entry.
 *
 *	In addition, the process may have the following attributes:
 *
 *	PROC_DETACHED:	It is detached from its parent.
 *	PROC_WAITED_ON:	It is detached from its parent and its parent
 *			knows about it. This attribute implies PROC_DETACHED
 *			has been set.
 *	PROC_SUSPEND_STATUS:
 *			It is suspended and its parent has not waited on it
 *			yet.  In this case it isn't detached.
 *	PROC_RESUME_STATUS:
 *			It has been resumed and its parent has not waited on
 *			it yet.  In this case it isn't detached.
 *
 *	These attributes are set independently of the process states.
 *
 *	The routines in this file deal with transitions from the
 *	RUNNING state to the EXITING and DEAD states and methods to 
 *	detach a process.
 *
 *  State and Attribute Transitions:
 *	The following tables show how a process changes attributes and states.
 *
 *
 *   Legend:
 *	ATTRIBUTE1 -> ATTRIBUTE2:
 *	---------------------------------------------------------------------
 *	  who		"routine it called to change attribute"	comments
 *
 *
 *
 *	Attached  -> Detached
 *	---------------------------------------------------------------------
 *	 current process	Proc_Detach
 *
 *	Detached -> Detached and Waited on
 *	---------------------------------------------------------------------
 *	 parent 		Proc_Wait	WAITED_ON attribute set when
 *						parent finds child is detached.
 *
 *	Attached or Detached -> Detached and Waited on
 *	---------------------------------------------------------------------
 *	 parent			Proc_ExitInt	parent exiting, child detached.
 *
 *
 *
 *
 *   Legend:
 *	STATE1 -> STATE2:	(attributes before transition)
 *	---------------------------------------------------------------------
 *	  who		"routine it called to change state" 	comments
 *
 *
 *	RUNNING -> EXITING:	(attached or detached but not waited on)
 *	RUNNING -> DEAD:	(detached and waited on)
 *	---------------------------------------------------------------------
 *	 current process	Proc_Exit	normal termination.
 *	 kernel			Proc_ExitInt	invalid process state found or
 *						process got a signal
 *
 *	EXITING -> DEAD:	(attached or detached or detached and waited on)
 *	---------------------------------------------------------------------
 *	 last family member to exit	Proc_ExitInt	
 *	 parent			Proc_Wait	parent waiting for child to exit
 *	 parent			Proc_ExitInt	parent exiting but did not 
 *						wait on child.
 *
 *	DEAD -> UNUSED:
 *	---------------------------------------------------------------------
 *	  The Reaper		Proc_Reaper 	kernel process to clean the
 *						dead list. 
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/proc/procExit.c,v 9.24 92/02/14 14:44:50 kupfer Exp $ SPRITE (Berkeley)";
#endif /* not lint */

#include <sprite.h>
#include <mach.h>
#include <status.h>
#include <proc.h>
#include <procInt.h>
#include <procMigrate.h>
#include <migrate.h>
#include <sync.h>
#include <sched.h>
#include <list.h>
#include <sys.h>
#include <vm.h>
#include <prof.h>
#include <dbg.h>
#include <stdlib.h>
#include <rpc.h>
#include <sig.h>
#include <stdio.h>
#include <vmMach.h>
#include <recov.h>
#include <sysSysCall.h>

static	Sync_Lock	exitLock = Sync_LockInitStatic("Proc:exitLock"); 
#define	LOCKPTR &exitLock

static 	INTERNAL ReturnStatus FindExitingChild _ARGS_((
				    Proc_ControlBlock *parentProcPtr,
				    Boolean returnSuspend, int numPids,
				    Proc_PID *pidArray, 
				    ProcChildInfo *infoPtr));
static 	INTERNAL void WakeupMigratedParent _ARGS_((Proc_PID pid));
static 	void 	SendSigChild _ARGS_((ClientData data, 
			Proc_CallInfo *callInfoPtr));
static 	Proc_State	ExitProcessInt _ARGS_((
				Proc_ControlBlock *exitProcPtr,
				Boolean	migrated, Boolean contextSwitch));

/*
 * Shared memory.
 */
extern int vmShmDebug;
#ifndef lint
#define dprintf if (vmShmDebug) printf
#else /* lint */
#define dprintf printf
#endif /* lint */

/*
 * SIGNAL_PARENT
 *
 * Macro to send a SIG_CHILD message to the parent.
 */
#define SIGNAL_PARENT(parentProcPtr, funcName) \
    if ((parentProcPtr)->genFlags & PROC_USER) { \
	ReturnStatus	status; \
	Proc_Lock(parentProcPtr); \
	status = Sig_SendProc(parentProcPtr, SIG_CHILD, 0, (Address)0); \
	Proc_Unlock(parentProcPtr); \
	if (status != SUCCESS) { \
	    printf("Warning: %s: Could not signal parent, status<%x>", \
				funcName, status); \
	} \
    }


/*
 *----------------------------------------------------------------------
 *
 * Proc_Exit --
 *
 *	The current process has decided to end it all voluntarily.
 *	Call an internal procedure to do the work.
 *
 * Results:
 *	None.  This routine should NOT return!
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
Proc_Exit(status)
    int	status;		/* Exit status from caller. */
{
    Proc_ExitInt(PROC_TERM_EXITED, status, 0);

    /*
     *  Proc_ExitInt should never return.
     */
}


/*
 *----------------------------------------------------------------------
 *
 * Proc_ExitInt --
 *
 *	Internal routine to handle the termination of a process.  It
 *	determines the process that is exiting and then calls
 *	ProcExitProcess to do the work. This routine does NOT return because
 *	a context switch is performed.  If the process is foreign,
 *	ProcRemoteExit is called to handle cleanup on the home node
 *	of the process, then ProcExitProcess is called.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
Proc_ExitInt(reason, status, code)
    int reason;	/* Why the process is dying: EXITED, SIGNALED, DESTROYED  */
    int	status;	/* Exit status or signal # or destroy status */
    int code;	/* Signal sub-status */
{
    register Proc_ControlBlock 	*curProcPtr;

    curProcPtr = Proc_GetActualProc();
    if (curProcPtr == (Proc_ControlBlock *) NIL) {
	panic("Proc_ExitInt: bad procPtr.\n");
    }

    if (curProcPtr->genFlags & PROC_FOREIGN) {
	ProcRemoteExit(curProcPtr, reason, status, code);
    }
    if (curProcPtr->Prof_Scale != 0) {
	Prof_Disable(curProcPtr);
    }
    if (curProcPtr->genFlags & PROC_DEBUGGED) {
	/*
	 * If a process is being debugged then force it onto the debug
	 * list before allowing it to exit.
	 */
	Proc_SuspendProcess(curProcPtr, TRUE, reason, status, code);
    }

    if (sys_ErrorShutdown) {
	/*
	 * Are shutting down the system because of an error.  In this case
	 * don't close anything down because we want to leave as much state
	 * around as possible.
	 */
	Sched_ContextSwitch(PROC_DEAD);
    }
    ProcExitProcess(curProcPtr, reason, status, code, TRUE);

    panic("Proc_ExitInt: Exiting process still alive!!!\n");
}


/*
 *----------------------------------------------------------------------
 *
 * ExitProcessInt --
 *
 *	Do monitor level exit stuff for the process.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If the process doesn't context switch, it is left locked.
 *
 *----------------------------------------------------------------------
 */

ENTRY static Proc_State
ExitProcessInt(exitProcPtr, migrated, contextSwitch) 
    register Proc_ControlBlock	*exitProcPtr;	/* The exiting process. */
    Boolean			migrated;	/* TRUE => foreign process. */
    Boolean			contextSwitch;	/* TRUE => context switch. */
{
    register	Proc_ControlBlock	*procPtr;
    Proc_State				newState = PROC_UNUSED;
    register Proc_PCBLink 		*procLinkPtr;
    Timer_Ticks 		        ticks;

    LOCK_MONITOR;


    Proc_Lock(exitProcPtr);

    exitProcPtr->genFlags |= PROC_DYING;

    if (exitProcPtr->genFlags & PROC_MIG_PENDING) {
	/*
	 * Someone is waiting for this guy to migrate.  Let them know that
	 * the process is dying.
	 */
	exitProcPtr->genFlags &= ~PROC_MIG_PENDING;
	ProcMigWakeupWaiters();
    }

    /*
     *  If the parent is still around, add the user and kernel cpu usage
     *  of this process to the parent's summary of children.
     *  If we're detached, don't give this stuff to the parent
     *  (it might not exist.)  Keep track of global usage if we're local.
     */

    if (!(exitProcPtr->genFlags & PROC_FOREIGN)) {
	if (!(exitProcPtr->exitFlags & PROC_DETACHED)) {
	    register Proc_ControlBlock 	*parentProcPtr;

	    parentProcPtr = Proc_GetPCB(exitProcPtr->parentID);
	    if (parentProcPtr != (Proc_ControlBlock *) NIL) {
		Timer_AddTicks(exitProcPtr->kernelCpuUsage.ticks, 
			       parentProcPtr->childKernelCpuUsage.ticks, 
			       &(parentProcPtr->childKernelCpuUsage.ticks));
		Timer_AddTicks(exitProcPtr->childKernelCpuUsage.ticks, 
			       parentProcPtr->childKernelCpuUsage.ticks, 
			       &(parentProcPtr->childKernelCpuUsage.ticks));
		Timer_AddTicks(exitProcPtr->userCpuUsage.ticks, 
			       parentProcPtr->childUserCpuUsage.ticks, 
			       &(parentProcPtr->childUserCpuUsage.ticks));
		Timer_AddTicks(exitProcPtr->childUserCpuUsage.ticks, 
			       parentProcPtr->childUserCpuUsage.ticks, 
			       &(parentProcPtr->childUserCpuUsage.ticks));
	    }
	}
#ifndef CLEAN
	Timer_AddTicks(exitProcPtr->kernelCpuUsage.ticks,
			exitProcPtr->userCpuUsage.ticks, &ticks);
	ProcRecordUsage(ticks, PROC_MIG_USAGE_TOTAL_CPU);
	/*
	 * Record usage for just the amount of work performed after the
	 * first eviction.
	 */
	if (exitProcPtr->migFlags & PROC_WAS_EVICTED) {
	    if (proc_MigDebugLevel > 4) {
		printf("ExitProcessInt: process %x was evicted.  Used %d ticks before eviction, %d total.\n",
		       exitProcPtr->processID,
		       exitProcPtr->preEvictionUsage.ticks,
		       ticks);
	    }
	    Timer_SubtractTicks(ticks, exitProcPtr->preEvictionUsage.ticks,
				&ticks);
	    ProcRecordUsage(ticks, PROC_MIG_USAGE_POST_EVICTION);
	    exitProcPtr->migFlags &= ~PROC_WAS_EVICTED;
	}
#endif /* CLEAN */
    }

    /* 
     * If the process is voluntarily exiting and system call profiling is 
     * enabled, update the time for Proc_Exit.
     */
    if (contextSwitch && exitProcPtr->termReason == PROC_TERM_EXITED &&
	sys_CallProfiling) {
	Sys_RecordCallFinish(SYS_PROC_EXIT);
    }
    
    /*
     * Make sure there are no lingering interval timer callbacks associated
     * with this process.
     *
     *  Go through the list of children of the current process to 
     *  make them orphans. When the children exit, this will typically
     *  cause them to go on the dead list directly.
     */

    if (!migrated) {
	ProcDeleteTimers(exitProcPtr);
	while (!List_IsEmpty(exitProcPtr->childList)) {
	    procLinkPtr = (Proc_PCBLink *) List_First(exitProcPtr->childList);
	    procPtr = procLinkPtr->procPtr;
	    List_Remove((List_Links *) procLinkPtr);
	    if (procPtr->state == PROC_EXITING) {
		/*
		 * The child is exiting waiting for us to wait for it.
		 */
		procPtr->state = PROC_DEAD;
		Proc_CallFunc(Proc_Reaper, (ClientData) procPtr, 0);
	    } else {
		/*
		 * Detach the child so when it exits, it will be
		 * put on the dead list automatically.
		 */
		procPtr->exitFlags = PROC_DETACHED | PROC_WAITED_ON;
	    }
	}
    }

    /*
     * If the debugger is waiting for this process to return to the debug
     * state wake it up so that it will realize that the process is dead.
     */

    if (exitProcPtr->genFlags & PROC_DEBUG_WAIT) {
	ProcDebugWakeup();
    }

    /*
     * If the process is still waiting on an event, this is an error.
     * [For now, flag this error only for foreign processes in case this
     * isn't really an error after all.]
     */
    if (migrated && (exitProcPtr->event != NIL)) {
	if (proc_MigDebugLevel > 0) {
	    panic(
		"ExitProcessInt: exiting process still waiting on event %x.\n",
		exitProcPtr->event);
	} else {
	    printf(
	      "%s ExitProcessInt: exiting process still waiting on event %x.\n",
	      "Warning:", exitProcPtr->event);
	}
    }

    /*
     * If the current process is detached and waited on (i.e. an orphan) then
     * one of two things happen.  If the process is a family head and its list
     * of family members is not empty then the process is put onto the exiting
     * list.  Otherwise the process is put onto the dead list since its 
     * parent has already waited for it.
     */

    if (((exitProcPtr->exitFlags & PROC_DETACHED) &&
        (exitProcPtr->exitFlags & PROC_WAITED_ON)) || migrated) {
	newState = PROC_DEAD;
	Proc_CallFunc(Proc_Reaper,  (ClientData) exitProcPtr, 0);
    } else {
	Proc_ControlBlock 	*parentProcPtr;

#ifdef DEBUG_PARENT_PID
	int hostID;
	
	hostID = Proc_GetHostID(exitProcPtr->parentID);
	if (hostID != rpc_SpriteID && hostID != 0) {
	    panic("ExitProcessInt: parent process (%x) is on wrong host.\n",
		  exitProcPtr->parentID);
	    goto done;
	}
#endif DEBUG_PARENT_PID
	parentProcPtr = Proc_GetPCB(exitProcPtr->parentID);
	if (parentProcPtr == (Proc_ControlBlock *) NIL) {
	    panic("ExitProcessInt: no parent process (pid == %x)\n",
		  exitProcPtr->parentID);
	    goto done;
	}
	if (parentProcPtr->state != PROC_MIGRATED) {
	    Sync_Broadcast(&parentProcPtr->waitCondition);
#ifdef notdef
	    SIGNAL_PARENT(parentProcPtr, "ExitProcessInt");
#endif
	} else {
	    WakeupMigratedParent(parentProcPtr->processID);
	}
	/*
	 * Signal the parent later on, when not holding the exit monitor
	 * lock.
	 */
	Proc_CallFunc(SendSigChild, (ClientData)exitProcPtr->parentID, 0);


	newState = PROC_EXITING;
    }
done:
    if (contextSwitch) {
	Proc_Unlock(exitProcPtr);
	UNLOCK_MONITOR_AND_SWITCH(newState);
	panic("ExitProcessInt: Exiting process still alive\n");
    } else {
	UNLOCK_MONITOR;
    }
    return(newState);
}


/*
 *----------------------------------------------------------------------
 *
 * ProcExitProcess --
 *
 *	Internal routine to handle the termination of a process, due
 *	to a normal exit, a signal or because the process state was
 *	inconsistent.  The file system state associated with the process 
 *	is invalidated. Any children of the process will become detatched.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The PCB entry for the process is modified to clean-up FS
 *	state. The specified process may be placed on the dead list.
 *  	If thisProcess is TRUE, a context switch is performed.  If not,
 *	then the exit is being performed on behalf of another process;
 * 	the procPtr comes in locked and is unlocked as a side effect.
 *
 *----------------------------------------------------------------------
 */
void
ProcExitProcess(exitProcPtr, reason, status, code, thisProcess) 
    register Proc_ControlBlock 	*exitProcPtr;	/* Exiting process. */
    int 			reason;		/* Why the process is dieing: 
						 * EXITED, SIGNALED, 
						 * DESTROYED  */
    int				status;		/* Exit status, signal # or 
						 * destroy status. */
    int 			code;		/* Signal sub-status */
    Boolean 			thisProcess;	/* TRUE => context switch */
{
    register Boolean 		migrated;
    Boolean			noVm;

    migrated = (exitProcPtr->genFlags & PROC_FOREIGN);

    /*
     * Decrement the reference count on the environment.
     */

    if (!migrated && exitProcPtr->environPtr != (Proc_EnvironInfo *) NIL) {
	ProcDecEnvironRefCount(exitProcPtr->environPtr);
    }

    /*
     * The process is already locked if it comes in on behalf of someone
     * else.
     */
    if (thisProcess) {
	Proc_Lock(exitProcPtr);
    }
    if (exitProcPtr->genFlags & PROC_NO_VM) {
	noVm = TRUE;
    } else {
	noVm = FALSE;
	exitProcPtr->genFlags |= PROC_NO_VM;
    }
    Proc_Unlock(exitProcPtr);

    /*
     * We have to do the Fs_CloseState in two phases:
     *
     * We must close pseudo-devices before destroying vm.
     * Otherwise there is a race (hit by migd) when a pseudo-device
     * is destroyed because data may be sent to the pseudo-device after
     * it loses its vm but before it is removed from the file system.
     * We will then crash because it has no vm for the data.
     *
     * We need to close swap files after deleting all the VM segments.
     * Otherwise we die if a COW segment has swapped-out data.  The
     * problem is we get the data from swap when we delete the segment.
     * Thus we must delete the segment before we close down the swap files.
     * --Ken Shirriff 10/90
     */

    if (exitProcPtr->fsPtr != (struct Fs_ProcessState *) NIL) {
	Fs_CloseState(exitProcPtr,0);
    }

    /*
     * Free up virtual memory resources, unless they were already freed.
     */

#ifdef sun4
    Mach_FlushWindowsToStack();
    VmMach_FlushCurrentContext();
#endif
    if ((exitProcPtr->genFlags & PROC_USER) && !noVm) {
	int i=0;
	while (exitProcPtr->vmPtr->sharedSegs != (List_Links *)NIL) {

	    if (exitProcPtr->vmPtr->sharedSegs == (List_Links *)NULL) {
		dprintf("ProcExitProcess: warning: sharedSegs == NULL\n");
		break;
	    }
  	    i++;
  	    if (i>20) {
  		dprintf("ProcExitProcess: procExit: segment loop!\n");
  		break;
  	    }
  	    if (exitProcPtr->vmPtr->sharedSegs==(List_Links *)NULL) {
  		printf("ProcExitProcess: Danger: null sharedSegs list\n");
  		break;
  	    }
  	    if (List_IsEmpty(exitProcPtr->vmPtr->sharedSegs)) {
  		printf("ProcExitProcess: Danger: empty sharedSegs list\n");
  		break;
  	    }
  	    if (List_First(exitProcPtr->vmPtr->sharedSegs)==
  		    (List_Links *)NULL) {
  		break;
  	    }
  	    Vm_DeleteSharedSegment(exitProcPtr, (Vm_SegProcList *)
		    List_First(exitProcPtr->vmPtr->sharedSegs));
  	}
	for (i = VM_CODE; i <= VM_STACK; i++) {
	    Vm_SegmentDelete(exitProcPtr->vmPtr->segPtrArray[i], exitProcPtr);
	    exitProcPtr->vmPtr->segPtrArray[i] = (Vm_Segment *)NIL;
	}
    }

    if (exitProcPtr->fsPtr != (struct Fs_ProcessState *) NIL) {
	Fs_CloseState(exitProcPtr,1);
    }

    /*
     * Remove the process from its process family.  (Note, 
     * migrated processes have family information on the home node.)
     */
    if (!migrated) {
	ProcFamilyRemove(exitProcPtr);
    }

    /*
     *  The following information is kept in case the parent
     *	calls Proc_Wait to wait for this process to terminate.
     */

    exitProcPtr->termReason	= reason;
    exitProcPtr->termStatus	= status;
    exitProcPtr->termCode	= code;

    /* If we were created with a vfork, then wake the parent up */
    if (exitProcPtr->genFlags & PROC_VFORKCHILD) {
	Proc_VforkWakeup(exitProcPtr);
    }

    exitProcPtr->state = ExitProcessInt(exitProcPtr, migrated, thisProcess);

    Proc_Unlock(exitProcPtr);
}


/*
 *----------------------------------------------------------------------
 *
 * Proc_Reaper --
 *
 *	Cleans up the state information kept in the PCB for a dead process.
 *	Processes get put on the dead list after they exit and someone has 
 *	called Proc_Wait to wait for them. Detached processes
 *	are put on the dead list when they call Proc_Exit or Proc_ExitInt.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Virtual memory state for processes on the list is deallocated.
 *
 *----------------------------------------------------------------------
 */

/* ARGSUSED */
ENTRY void
Proc_Reaper(data, callInfoPtr)
    ClientData				data;		/* procPtr */
    Proc_CallInfo			*callInfoPtr;
{
    register	Proc_ControlBlock 	*procPtr = (Proc_ControlBlock *) data;
    LOCK_MONITOR;
    /*
     * On a multiprocess there are two cases where we can't reap the process
     * right away.  1 - the dying process may not have context switched
     * into the DEAD state.  2 - the dying process's kernel stack may
     * be used by a processor in the IdleLoop().  In either of these
     * cases we reschedule ourselves for a second later.
     */
    if ((procPtr->state != PROC_DEAD) ||
	(procPtr->schedFlags & SCHED_STACK_IN_USE)) {
	callInfoPtr->interval = timer_IntOneSecond;
	UNLOCK_MONITOR;
	return;
    } else {
	callInfoPtr->interval = 0;
    }
#ifdef notdef
    /*
     * Next wait for the process's stack to become free.  On a multiprocessor
     * a DEAD processes stack may be used to field interrupt by a processor
     * until another process becomes ready.
     */
    while (procPtr->schedFlags & SCHED_STACK_IN_USE) {
	UNLOCK_MONITOR;
	Sync_WaitTime(time_OneSecond);
	LOCK_MONITOR;
    }
    /*
     * Since the SCHED_STACK_IN_USE is removed from a process before the
     * context switch from that processor occurs we need to syncronize 
     * with the scheduler.  Context switching on to the READY queue will
     * cause such a syncronization.
     */
    Sched_ContextSwitch(PROC_READY);
#endif
    /*
     * At this point a migrated process is not in the PROC_MIGRATED
     * state since it's been moved to the PROC_DEAD state.  
     * Migrated processes don't have a local machine-dependent state
     * hanging off them.  They also don't have a current context, but
     * VmMach_FreeContext can handle that.
     */
    if (procPtr->machStatePtr != (Mach_State *) NIL) {
	Mach_FreeState(procPtr);
    }
    VmMach_FreeContext(procPtr);

    ProcFreePCB(procPtr);

    UNLOCK_MONITOR;
}


/*
 *----------------------------------------------------------------------
 *
 * Proc_DetachInt --
 *
 *	The given process is detached from its parent.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	PROC_DETACHED flags set in the exitFlags field for the process.
 *
 *----------------------------------------------------------------------
 */

ENTRY void
Proc_DetachInt(procPtr)
    register	Proc_ControlBlock	*procPtr;
{
    Proc_ControlBlock 	*parentProcPtr;

    LOCK_MONITOR;

    /*
     * If the process is already detached, there's no point to do it again.
     * The process became detached by calling this routine or its parent
     * has died.
     */

    if (procPtr->exitFlags & PROC_DETACHED) {
	UNLOCK_MONITOR;
	return;
    }

    procPtr->exitFlags |= PROC_DETACHED;

    /*
     *  Wake up the parent in case it has called Proc_Wait to
     *  wait for this child (or any other children) to terminate.
     */

    parentProcPtr = Proc_GetPCB(procPtr->parentID);

    if (parentProcPtr->state == PROC_MIGRATED) {
	WakeupMigratedParent(parentProcPtr->processID);
    } else {
	Sync_Broadcast(&parentProcPtr->waitCondition);
#ifdef notdef
	SIGNAL_PARENT(parentProcPtr, "Proc_DetachInt");
#endif
    }
    /*
     * Signal the parent later on, when not holding the exit monitor
     * lock.
     */
    Proc_CallFunc(SendSigChild, (ClientData)parentProcPtr->processID, 0);

    UNLOCK_MONITOR;
}


/*
 *----------------------------------------------------------------------
 *
 * Proc_InformParent --
 *
 *	Tell the parent of the given process that the process has changed
 *	state.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Status bit set in the exit flags.
 *
 *----------------------------------------------------------------------
 */
ENTRY void
Proc_InformParent(procPtr, childStatus)
    register Proc_ControlBlock	*procPtr;	/* Process whose parent to
						 * inform of state change. */
    int				childStatus;	/* PROC_SUSPEND_STATUS |
						 * PROC_RESUME_STATUS */
{
    Proc_ControlBlock 	*parentProcPtr;
    Boolean migrated = FALSE;

    LOCK_MONITOR;

    /*
     * If the process is already detached, then there is no parent to tell.
     */
    if (procPtr->exitFlags & PROC_DETACHED) {
	UNLOCK_MONITOR;
	return;
    }

    /*
     * Wake up the parent in case it has called Proc_Wait to
     * wait for this child (or any other children) to terminate.  Also
     * clear the suspended and waited on flag.
     *
     * For a migrated process, just send a signal no matter what, since it
     * can go to an arbitrary node.  Also, do RPC's using a callback so
     * the monitor lock isn't held during the RPC.  
     */

    if (procPtr->genFlags & PROC_FOREIGN) {
	migrated = TRUE;
    }
    if (!migrated) {
	parentProcPtr = Proc_GetPCB(procPtr->parentID);
	Sync_Broadcast(&parentProcPtr->waitCondition);
    }
    Proc_CallFunc(SendSigChild, (ClientData)procPtr->parentID, 0);
    procPtr->exitFlags &= ~PROC_STATUSES;
    procPtr->exitFlags |= childStatus;

    UNLOCK_MONITOR;
}


/*
 *----------------------------------------------------------------------
 *
 * SendSigChild --
 *
 *	Send a SIG_CHILD signal to the given process.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

/* ARGSUSED */
static void
SendSigChild(data, callInfoPtr)
    ClientData		data;
    Proc_CallInfo	*callInfoPtr;	/* passed in by callback routine */
{
    (void)Sig_Send(SIG_CHILD, SIG_NO_CODE, (Proc_PID)data, FALSE, (Address)0);
}


/*
 *----------------------------------------------------------------------
 *
 * Proc_Detach --
 *
 *	The current process is detached from its parent. Proc_DetachInt called
 *	to do most work.
 *
 * Results:
 *	SUCCESS			- always returned.
 *
 * Side effects:
 *	Statuses set in the proc table for the process.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Proc_Detach(status)
    int	status;		/* Detach status from caller. */
{
    register	Proc_ControlBlock 	*procPtr;

    procPtr = Proc_GetEffectiveProc();
    if (procPtr == (Proc_ControlBlock *) NIL) {
	panic("Proc_Detach: procPtr == NIL\n");
    }

    /*
     *  The following information is kept in case the parent does a
     *	Proc_Wait on this process.
     */

    Proc_Lock(procPtr);
    procPtr->termReason	= PROC_TERM_DETACHED;
    procPtr->termStatus	= status;
    procPtr->termCode	= 0;
    Proc_Unlock(procPtr);

    Proc_DetachInt(procPtr);

    return(SUCCESS);
}

static ReturnStatus 	CheckPidArray _ARGS_((Proc_ControlBlock *curProcPtr,
				Boolean returnSuspend, int numPids,
				Proc_PID *pidArray, 
				Proc_ControlBlock **procPtrPtr));
static ReturnStatus 	LookForAnyChild _ARGS_((Proc_ControlBlock *curProcPtr,
				Boolean returnSuspend, 
				Proc_ControlBlock **procPtrPtr));
extern ReturnStatus 	DoWait _ARGS_((Proc_ControlBlock *curProcPtr,
			    int	flags, int numPids, Proc_PID *newPidArray,
			    ProcChildInfo *childInfoPtr));


/*
 *----------------------------------------------------------------------
 *
 * Proc_Wait --
 *
 *	Returns information about a child process that has changed state to
 *	one of terminated, detached, suspended or running.  If the 
 *	PROC_WAIT_FOR_SUSPEND flag is not set then info is only returned about
 *	terminated and detached processes.  If the PROC_WAIT_BLOCK flag is
 *	set then this function will wait for a child process to change state.
 *
 *	A terminated process is a process that has ceased execution because
 *	it voluntarily called Proc_Exit or was involuntarily killed by 
 *	a signal or was destroyed by the kernel due to an invalid stack. 
 *	A detached process is process that has called Proc_Detach to detach 
 *	itself from its parent. It continues to execute until it terminates.
 *
 * Results:
 *	PROC_INVALID_PID -	a process ID in the pidArray was invalid.
 *	SYS_INVALID_ARG -	the numPids argument specified a negative
 *				number of pids in pidArray, or numPids
 *				valid but pidArray was USER_NIL
 *	SYS_ARG_NOACCESS -	an out parameter was inaccessible or
 *				pidArray was inaccessible.
 *
 * Side effects:
 *	Processes may be put onto the dead list after they have been waited on.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
Proc_Wait(numPids, pidArray, flags, procIDPtr, reasonPtr, 
	  statusPtr, subStatusPtr, usagePtr)
    int 		numPids;	/* Number of entries in pidArray.  
			 		 * 0 means wait for any child. */
    Proc_PID 		pidArray[]; 	/* Array of IDs of children to wait 
					 * for. */
    int 		flags;		/* PROC_WAIT_BLOCK => wait if no 
					 * children have exited, detached or
					 * suspended.  
					 * PROC_WAIT_FOR_SUSPEND => return 
					 * status of suspended children. */

				/* The following parameters may be USER_NIL. */
    Proc_PID 		*procIDPtr; 	/* ID of the process that terminated. */
    int 		*reasonPtr;	/* Reason why the process exited. */
    int 		*statusPtr;	/* Exit status or termination signal 
					 * number.  */
    int 		*subStatusPtr;	/* Additional signal status if the 
					 * process died because of a signal. */
    Proc_ResUsage	*usagePtr;	/* Resource usage summary for the 
					 * process and its descendents. */

{
    register Proc_ControlBlock 	*curProcPtr;
    ReturnStatus		status;
    Proc_PID 			*newPidArray = (Proc_PID *) NIL;
    int 			newPidSize;
    ProcChildInfo		childInfo;
    Proc_ResUsage 		resUsage;
    Boolean			migrated = FALSE;

    curProcPtr = Proc_GetCurrentProc();
    if (curProcPtr == (Proc_ControlBlock *) NIL) {
	panic("Proc_Wait: curProcPtr == NIL.\n");
    }

    if (curProcPtr->genFlags & PROC_FOREIGN) {
	migrated = TRUE;
    }
    
    /*
     *  If a list of pids to check was given, use it, otherwise
     *  look for any child that has changed state.
     */
    if (numPids < 0) {
	return(SYS_INVALID_ARG);
    } else if (numPids > 0) {
	if (pidArray == USER_NIL) {
	    return(SYS_INVALID_ARG);
	} else {
	    /*
	     *  If pidArray is used, make it accessible. Also make sure that
	     *  the pids are in the proper range.
	     */
	    newPidSize = numPids * sizeof(Proc_PID);
	    newPidArray = (Proc_PID *) malloc(newPidSize);
	    status = Vm_CopyIn(newPidSize, (Address) pidArray,
			       (Address) newPidArray);
	    if (status != SUCCESS) {
		free((Address) newPidArray);
		return(SYS_ARG_NOACCESS);
	    }
	}
    }

    if (!migrated) {
	status = DoWait(curProcPtr, flags, numPids, newPidArray, &childInfo);
    } else {
	status = ProcRemoteWait(curProcPtr, flags, numPids, newPidArray,
				&childInfo);
    }

    if (numPids > 0) {
	free((Address) newPidArray);
    }

    if (status == SUCCESS) {
	if (procIDPtr != USER_NIL) {
	    if (Vm_CopyOut(sizeof(Proc_PID), (Address) &childInfo.processID, 
		(Address) procIDPtr) != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    }
	}
	if (reasonPtr != USER_NIL) {
	    if (Vm_CopyOut(sizeof(int), (Address) &childInfo.termReason, 
		(Address) reasonPtr) != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    }
	}
	if (statusPtr != USER_NIL) {
	    if (Vm_CopyOut(sizeof(int), (Address) &childInfo.termStatus, 
		(Address) statusPtr) != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    }
	}
	if (subStatusPtr != USER_NIL) {
	    if (Vm_CopyOut(sizeof(int), (Address) &childInfo.termCode, 
		(Address) subStatusPtr) != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    }
	}
	if (usagePtr != USER_NIL) {
	    /*
	     * Convert the usages from the internal Timer_Ticks format
	     * into the external Time format.
	     */
	    Timer_TicksToTime(childInfo.kernelCpuUsage,
			      &resUsage.kernelCpuUsage);
	    Timer_TicksToTime(childInfo.userCpuUsage,
			      &resUsage.userCpuUsage);
	    Timer_TicksToTime(childInfo.childKernelCpuUsage, 
			      &resUsage.childKernelCpuUsage);
	    Timer_TicksToTime(childInfo.childUserCpuUsage,
			      &resUsage.childUserCpuUsage);
	    resUsage.numQuantumEnds = childInfo.numQuantumEnds;
	    resUsage.numWaitEvents = childInfo.numWaitEvents;
	    if (Vm_CopyOut(sizeof(Proc_ResUsage), (Address) &resUsage, 
			   (Address) usagePtr) != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    }
	}
    }

    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * DoWait --
 *
 *	Execute monitor level code for a Proc_Wait.  Return the information
 *	about the child that was found if any. 
 *
 * Results:
 *	PROC_INVALID_PID -	a process ID in the pidArray was invalid.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ENTRY ReturnStatus 
DoWait(curProcPtr, flags, numPids, newPidArray, childInfoPtr)
    register	Proc_ControlBlock	*curProcPtr;	/* Parent process. */
			/* PROC_WAIT_BLOCK => wait if no children have changed
			 * 		      state.
			 * PROC_WAIT_FOR_SUSPEND => return status of suspended
			 *			    children. */
    int 				flags;	
    int					numPids;	/* Number of pids in
							 * newPidArray. */
    Proc_PID 				*newPidArray;	/* Array of pids. */
    ProcChildInfo			*childInfoPtr;	/* Place to store child
							 * information. */
{
    ReturnStatus	status;

    LOCK_MONITOR;

    while (TRUE) {
	/*
	 * If a pid array was given, check the array to see if someone on it
	 * has changed state. Otherwise, see if any child has done so.
	 */
	status = FindExitingChild(curProcPtr, flags & PROC_WAIT_FOR_SUSPEND,
				numPids, newPidArray, childInfoPtr);

	/* 
	 * If someone was found or there was an error, break out of the loop
	 * because we are done. FAILURE means no one was found.
	 */
	if (status != FAILURE) {
	    break;
	}

	/*
	 *  If the search doesn't yields a child, we go to sleep waiting 
	 *  for a process to wake us up if it exits or detaches itself.
	 */
	if (!(flags & PROC_WAIT_BLOCK)) {
	    /*
	     * Didn't find anyone to report on.
	     */
	    status = PROC_NO_EXITS;
	    break;

	} else {	
	    /*
	     *  Since the current process is local, it will go to sleep
	     *  on its waitCondition.  A child will wakeup the process by
	     *  doing a wakeup on its parent's waitCondition.
	     *
	     *  This technique reduces the number of woken processes
	     *  compared to having every process wait on the same
	     *  event (e.g. exiting list address) when it goes to
	     *  sleep.  When we wake up, the search will start again.
	     *
	     * Check for the signal being SIG_CHILD, in which case
	     * don't abort the Proc_Wait.  This can happen if the parent and
	     * the child are on different hosts so the Sync_Wait is aborted
	     * by the signal rather than a wakeup.  (The parent should handle
	     * SIGCHLD better, but it might not, thereby missing the child's
	     * change in state.)
	     */
	    if (Sync_Wait(&curProcPtr->waitCondition, TRUE)) {
		if (Sig_Pending(curProcPtr) != Sig_NumberToMask(SIG_CHILD)) {
		    status = GEN_ABORTED_BY_SIGNAL;
		    break;
		}
	    }
	}
    }

    UNLOCK_MONITOR;
    return(status);
}


/*
 * ----------------------------------------------------------------------------
 *
 * ProcRemoteWait --
 *
 *	Perform an RPC to do a Proc_Wait on the home node of the given
 *	process.  Transfer the information for a child that has changed state,
 *	if one exists, and set up the information for a remote
 *	wait if the process wishes to block waiting for a child.  Note
 *	that this routine is unsynchronized, since monitor locking is
 *	performed on the home machine of the process.
 *
 * Results:
 *	The status from the remote Proc_Wait (or RPC status) is returned.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */

ReturnStatus
ProcRemoteWait(procPtr, flags, numPids, pidArray, childInfoPtr)
    Proc_ControlBlock	*procPtr;
    int			flags;
    int			numPids;
    Proc_PID		pidArray[];
    ProcChildInfo	*childInfoPtr;
{
    ProcRemoteWaitCmd cmd;
    Rpc_Storage storage;
    ReturnStatus status;
    int numTries;

    if (proc_MigDebugLevel > 3) {
	printf("ProcRemoteWait(%x, ...) called.\n", procPtr->processID);
    }

    /*
     * Check to make sure the home node is up, and kill the process if
     * it isn't.  The call to exit never returns.
     */
    status = Recov_IsHostDown(procPtr->peerHostID);
    if (status != SUCCESS) {
	if (proc_MigDebugLevel > 0) {
	    printf("Proc_DoRemoteCall: host %d is down; killing process %x.\n",
		       procPtr->peerHostID, procPtr->processID);
	}
	Proc_ExitInt(PROC_TERM_DESTROYED, (int) PROC_NO_PEER, 0);
	/*
	 * This point should not be reached, but the N-O-T-R-E-A-C-H-E-D
	 * directive causes a complaint when there's code after it.
	 */
	panic("ProcRemoteWait: Proc_ExitInt returned.\n");
	return(PROC_NO_PEER);
    }
    /*
     * Set up the invariant fields of the rpc call, since we may make
     * multiple calls after waiting.
     */
    
    cmd.pid = procPtr->peerProcessID;
    cmd.numPids = numPids;
    cmd.flags = flags;
    cmd.token = NIL;

    storage.requestParamPtr = (Address) &cmd;
    storage.requestParamSize = sizeof(ProcRemoteWaitCmd);
    storage.requestDataPtr = (Address) pidArray;
    storage.requestDataSize = numPids * sizeof(Proc_PID);

    while (TRUE) {

	storage.replyParamPtr = (Address) NIL;
	storage.replyParamSize = 0;
	storage.replyDataPtr = (Address) childInfoPtr;
	storage.replyDataSize = sizeof(ProcChildInfo);

	if (flags & PROC_WAIT_BLOCK) {
	    Sync_GetWaitToken((Proc_PID *) NIL, &cmd.token);
	}

	/*
	 * Set up for the RPC.
	 */
    
	for (numTries = 0; numTries < PROC_MAX_RPC_RETRIES; numTries++) {
	    status = Rpc_Call(procPtr->peerHostID, RPC_PROC_REMOTE_WAIT,
			      &storage);
	    if (status != RPC_TIMEOUT) {
		break;
	    }
	    status = Proc_WaitForHost(procPtr->peerHostID);
	    if (status != SUCCESS) {
		break;
	    }
	}

	/*
	 * If the status is FAILURE, no children have exited so far.  In
	 * this case, we may want to sleep.
	 */
	if (status != FAILURE) {
	    break;
	}

	/*
	 * If the search doesn't yield a child and we are supposed to block,
	 * we go to sleep waiting for a process to wake us up if it
	 * exits or detaches itself.
	 */

	if (!(flags & PROC_WAIT_BLOCK)) {
	    /*
	     * Didn't find anyone to report on.
	     */
	    status = PROC_NO_EXITS;
	    break;

	} else if (Sync_ProcWait((Sync_Lock *) NIL, TRUE)) {
	    status = GEN_ABORTED_BY_SIGNAL;
	    break;
	}  
    }

    if (status == PROC_NO_PEER) {
	(void) Sig_Send(SIG_KILL, (int) PROC_NO_PEER, procPtr->processID,
			FALSE, (Address)0); 
	if (proc_MigDebugLevel > 1) {
	    printf("%s killing process %x: home node's copy (pid %x) died.\n",
		   "ProcRemoteWait", procPtr->processID,
		   procPtr->peerProcessID);
	}
    } else if (proc_MigDebugLevel > 3) {
	printf("ProcRemoteWait returning status %x.\n", status);
	if (status == SUCCESS && proc_MigDebugLevel > 6) {
	    printf("Child's id is %x, status %x.\n",
		       childInfoPtr->processID, childInfoPtr->termStatus);
	}
    }
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * ProcServiceRemoteWait --
 *
 *	Services the Proc_Wait command for a migrated process.  If
 *	there is an appropriate child, returns information about it (refer
 *	to Proc_Wait).  If not, returns	PROC_NO_EXITS.  If the migrated
 *	process specified that it should block, set up a remote wakeup
 *	for when a child changes state.
 *
 * Results:
 *	PROC_INVALID_PID -	a process ID in the pidArray is invalid.
 *	PROC_NO_EXITS    -	no children have changed state which have
 *				not already been waited upon.
 *
 * Side effects:
 *	Processes on the exiting list may be put on the dead list after 
 *	they have been waited on.  A remote wakeup may be established.
 *
 *----------------------------------------------------------------------
 */

ENTRY ReturnStatus
ProcServiceRemoteWait(curProcPtr, flags, numPids, pidArray, waitToken,
		      childInfoPtr)
    register Proc_ControlBlock 	*curProcPtr;
    int				flags;
    int numPids;	/* Number of entries in pidArray.  
			 *  0 means wait for any child. */
    Proc_PID pidArray[]; /* Array of IDs of children to wait for. */
    int waitToken;      /* Token to use if blocking. */
    ProcChildInfo *childInfoPtr; /* Information to return about child. */

{
    ReturnStatus		status;

    LOCK_MONITOR;

    status = FindExitingChild(curProcPtr, flags & PROC_WAIT_FOR_SUSPEND,
			    numPids, pidArray, childInfoPtr);
    if (proc_MigDebugLevel > 3) {
	printf("pid %x got status %x from FindExitingChild\n",
		   curProcPtr->processID, status);
	if (status == SUCCESS && proc_MigDebugLevel > 6) {
	    printf("Child's id is %x, status %x.\n",
		       childInfoPtr->processID, childInfoPtr->termStatus);
	}
    }

    /* 
     * FAILURE means no one was found, so set up a remote wakeup if needed.
     * Otherwise, just return the childInfo as it was set by FindExitingChild
     * and get out.
     */
    if (status == FAILURE) {
	if (flags & PROC_WAIT_BLOCK) {
	    Sync_SetWaitToken(curProcPtr, waitToken);
	}
    } 

    UNLOCK_MONITOR;
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 *  FindExitingChild --
 *
 *	Find a child of the specified process who has changed state,
 *	subject to possible constraints (a list of process
 *	IDs to check).  If a process is found, send that process to the
 *	reaper if appropriate.
 *
 *	If numPids is 0, look for any child, else look for specific
 *	processes.
 *
 * Results:
 *	PROC_NO_CHILDREN -	There are no children of this process left
 *				to be waited on.
 *	FAILURE -		didn't find any child of interest.
 *	SUCCESS -		got one.
 *
 * Side effects:
 *	If a process is found, *childInfoPtr is set to contain the relevant
 *	information from the child.
 *
 *----------------------------------------------------------------------
 */

INTERNAL static ReturnStatus 
FindExitingChild(parentProcPtr, returnSuspend, numPids, pidArray, infoPtr)
    Proc_ControlBlock 		*parentProcPtr;	/* Parent's PCB */
    Boolean			returnSuspend;	/* Return information about
						 * suspended or resumed
						 * children. */ 
    int 			numPids;	/* Number of Pids in pidArray */
    Proc_PID 			*pidArray;	/* Array of Pids to check */
    register ProcChildInfo	*infoPtr;	/* Place to return info */
{
    ReturnStatus status;
    Proc_ControlBlock *paramProcPtr;
    register Proc_ControlBlock *procPtr;
    
    if (numPids > 0) {
	status = CheckPidArray(parentProcPtr, returnSuspend, numPids, pidArray,
			       &paramProcPtr);
    } else {
	status = LookForAnyChild(parentProcPtr, returnSuspend, &paramProcPtr);
    }
    if (status == SUCCESS) {
	procPtr = paramProcPtr;
	if (procPtr->state == PROC_EXITING ||
	    (procPtr->exitFlags & PROC_DETACHED)) {
	    List_Remove((List_Links *) &(procPtr->siblingElement));
	    infoPtr->termReason		= procPtr->termReason;
	    if (procPtr->state == PROC_EXITING) {
		/*
		 * Once an exiting process has been waited on it is moved
		 * from the exiting state to the dead state.
		 */
		procPtr->state = PROC_DEAD;
		Proc_CallFunc(Proc_Reaper,  (ClientData) procPtr, 0);
	    } else {
		/*
		 * The child is detached and running.  Set a flag to make sure
		 * we don't find this process again in a future call to
		 * Proc_Wait.
		 */
		procPtr->exitFlags |= PROC_WAITED_ON;
	    }
	} else {
	    /*
	     * The child was suspended or resumed.
	     */
	    if (procPtr->exitFlags & PROC_SUSPEND_STATUS) {
		procPtr->exitFlags &= ~PROC_SUSPEND_STATUS;
		infoPtr->termReason = PROC_TERM_SUSPENDED;
	    } else if (procPtr->exitFlags & PROC_RESUME_STATUS) {
		procPtr->exitFlags &= ~PROC_RESUME_STATUS;
		infoPtr->termReason = PROC_TERM_RESUMED;
	    }
	}

	infoPtr->processID		= procPtr->processID;
	infoPtr->termStatus		= procPtr->termStatus;
	infoPtr->termCode		= procPtr->termCode;
	infoPtr->kernelCpuUsage		= procPtr->kernelCpuUsage.ticks;
	infoPtr->userCpuUsage		= procPtr->userCpuUsage.ticks;
	infoPtr->childKernelCpuUsage	= procPtr->childKernelCpuUsage.ticks;
	infoPtr->childUserCpuUsage 	= procPtr->childUserCpuUsage.ticks;
	infoPtr->numQuantumEnds		= procPtr->numQuantumEnds;
	infoPtr->numWaitEvents		= procPtr->numWaitEvents;

	Proc_Unlock(procPtr);
    }

    return(status);
}	     	 


/*
 *----------------------------------------------------------------------
 *
 *  LookForAnyChild --
 *
 *	Search the process's list of children to see if any of 
 *	them have exited, become detached or been suspended or resumed.
 *	If no child is found, make sure there is a child who can wake us up.
 *
 * Results:
 *	PROC_NO_CHILDREN -	There are no children of this process left
 *				to be waited on.
 *	FAILURE -		didn't find any child of interest.
 *	SUCCESS -		got one.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

INTERNAL static ReturnStatus
LookForAnyChild(curProcPtr, returnSuspend, procPtrPtr)
    register	Proc_ControlBlock	*curProcPtr;	/* Parent proc.*/
    Boolean				returnSuspend;	/* Return info about
							 * suspended children.*/    Proc_ControlBlock 			**procPtrPtr;	/* Child proc. */
{
    register Proc_ControlBlock *procPtr;
    register Proc_PCBLink *procLinkPtr;
    Boolean foundValidChild = FALSE;

    /*
     *  Loop through the list of children, looking for the first child
     *  to have changed state. Ignore children that are detached
     *  and waited-on.
     */

    LIST_FORALL((List_Links *) curProcPtr->childList,
		(List_Links *) procLinkPtr) {
        procPtr = procLinkPtr->procPtr;
	/*
	 *  It may be that one of our children is in the process of exiting.
	 *  If it is marked as 'dying' but not 'exiting', then it has
	 *  left the monitor (obvious because we're in the monitor now)
	 *  but hasn't completed the context switch to the 'exiting' state.
	 *  This can only happen if the child is on a different processor
	 *  from ourself.  We'll wait for the child to become exiting since
	 *  it will take at most the length of a context switch to finish.
	 *  If we don't wait for this child we will miss the transition
	 *  and potentially wait forever.
	 */
	if (procPtr->genFlags & PROC_DYING) {
	    while (procPtr->state != PROC_EXITING) {
		/*
		 * Wait for the other processor to set the state to exiting.
		 */
	    }
	}
	if ((procPtr->state == PROC_EXITING) ||
	    (procPtr->exitFlags & PROC_DETACHED) ||
	    (returnSuspend && (procPtr->exitFlags & PROC_STATUSES))) {
	    if (!(procPtr->exitFlags & PROC_WAITED_ON)) {
	        *procPtrPtr = procPtr;
		Proc_Lock(procPtr);
	        return(SUCCESS);
	    }
	} else {
	    foundValidChild = TRUE;
	}
    }

    if (foundValidChild) {
	return(FAILURE);
    }
    return(PROC_NO_CHILDREN);
}


/*
 *----------------------------------------------------------------------
 *
 *  CheckPidArray --
 *
 *	Search the process's array of children to see if any of them 
 *	have exited, become detached or been suspended or resumed.
 *
 * Results:
 *	FAILURE -		didn't find any child of interest.
 *	PROC_INVALID_PID -	a pid in the array was invalid.
 *	SUCCESS -		got one.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */


INTERNAL static ReturnStatus
CheckPidArray(curProcPtr, returnSuspend, numPids,  pidArray, procPtrPtr)
    register	Proc_ControlBlock	*curProcPtr;	/* Parent proc. */
    Boolean				returnSuspend;	/* Return information
							 * about suspended or
							 * resumed children. */
    int					numPids;	/* Number of pids in 
							 * pidArray. */
    Proc_PID				*pidArray;	/* Array of pids to 
							 * check. */
    Proc_ControlBlock 			**procPtrPtr;	/* Child proc. */
{
    register Proc_ControlBlock	*procPtr;
    int				i;

    /*
     * The user has specified a list of processes to wait for.
     * If a specified process is non-existent or is not a child of the
     * calling process return an error status.
     */
    for (i=0; i < numPids; i++) {
	procPtr = Proc_LockPID(pidArray[i]);
	if (procPtr == (Proc_ControlBlock *) NIL) {
	    return(PROC_INVALID_PID);
	}
	if (!Proc_ComparePIDs(procPtr->parentID, curProcPtr->processID)) {
	    Proc_Unlock(procPtr);
	    return(PROC_INVALID_PID);
	}
	if ((procPtr->state == PROC_EXITING) ||
	    (procPtr->exitFlags & PROC_DETACHED) ||
	    (returnSuspend && (procPtr->exitFlags & PROC_STATUSES))) {
	    if (!(procPtr->exitFlags & PROC_WAITED_ON)) {
		*procPtrPtr = procPtr;
		return(SUCCESS);
	    }
	}
	Proc_Unlock(procPtr);
    } 
    return(FAILURE);
}


/*
 *----------------------------------------------------------------------
 *
 * Proc_NotifyMigratedWaiters --
 *
 *	Waits to find out about migrated processes that have performed
 *	Proc_Waits and then issues Sync_RemoteNotify calls to wake them
 *	up.  Uses a monitored procedure to access the shared list containing
 *	process IDs.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	RPCs are issued as children of migrated processes detach or die.
 *
 *----------------------------------------------------------------------
 */

/* ARGSUSED */
void
Proc_NotifyMigratedWaiters(data, callInfoPtr)
    ClientData		data;			/* pid */
    Proc_CallInfo	*callInfoPtr;		/* not used */
{
    Proc_PID 			pid = (Proc_PID) data;
    register Proc_ControlBlock 	*procPtr;
    Sync_RemoteWaiter 		waiter;
    ReturnStatus 		status;

    procPtr = Proc_LockPID(pid);
    if (procPtr == (Proc_ControlBlock *) NIL) {
	return;
    }

    waiter.hostID = procPtr->peerHostID;
    waiter.pid = procPtr->peerProcessID;
    waiter.waitToken =  procPtr->waitToken;
    Proc_Unlock(procPtr);

    if (proc_MigDebugLevel > 3) {
	printf("Proc_NotifyMigratedWaiters: notifying process %x.\n",
		   waiter.pid);
    }
    status = Sync_RemoteNotify(&waiter);
    if (status != SUCCESS) {
	printf("Warning: received status %x notifying process.\n", status);
    }
}


/*
 *----------------------------------------------------------------------
 *
 * WakeupMigratedParent --
 *
 *	Call the function Proc_NotifyMigratedWaiters by starting a process
 *	on it.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static INTERNAL void
WakeupMigratedParent(pid)
    Proc_PID pid;
{

    if (proc_MigDebugLevel > 3) {
	printf("WakeupMigratedParent: inserting process %x.\n", pid);
    }
    Proc_CallFunc(Proc_NotifyMigratedWaiters, (ClientData) pid, 0);
}

@


9.24
log
@Add some debugging printf's to track down the mysterious "Error code
16"s we keep getting from pmake.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/proc/procExit.c,v 9.23 92/01/06 15:09:23 kupfer Exp $ SPRITE (Berkeley)";
d141 1
d370 8
@


9.23
log
@Use Sig_NumberToMask.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/proc/procExit.c,v 9.22 91/11/15 21:05:18 kupfer Exp $ SPRITE (Berkeley)";
d1307 3
a1309 2
	    printf("ProcRemoteWait killing process %x: home node's copy died.\n",
		   procPtr->processID);
@


9.22
log
@In Proc_Detach, lock the PCB before setting the termination reason,
status, and code.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/proc/procExit.c,v 9.21 91/09/17 22:12:28 kupfer Exp $ SPRITE (Berkeley)";
d1165 1
a1165 1
		if (Sig_Pending(curProcPtr) != (1 << (SIG_CHILD - 1))) {
@


9.21
log
@Note side effect of ExitProcessInt: process is left locked if it
doesn't context switch.

@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.20 91/08/24 19:55:26 mottsmth Exp Locker: kupfer $ SPRITE (Berkeley)";
d729 1
a729 1
 *	SUCCESS			- always returned.
d903 1
d907 1
@


9.20
log
@Add true vfork support
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.19 91/07/26 16:59:47 shirriff Exp $ SPRITE (Berkeley)";
d287 1
a287 1
 *	None.
@


9.19
log
@Large install for unix compatibility
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc.ken/RCS/procExit.c,v 1.1 91/05/30 18:12:42 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d630 5
@


9.19.1.1
log
@Initial branch for Sprite server.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.19 91/07/26 16:59:47 shirriff Exp $ SPRITE (Berkeley)";
@


9.18
log
@Unix compatibilty.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.17 90/11/06 16:51:23 shirriff Exp Locker: rab $ SPRITE (Berkeley)";
d578 1
a578 1
	while (0 && exitProcPtr->vmPtr->sharedSegs != (List_Links *)NIL) {
@


9.17
log
@Changed ProcExit to close process's files in two phases.  This is to
solve various race problems with vm and fs closing.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.16 90/10/09 11:53:22 jhh Exp Locker: shirriff $ SPRITE (Berkeley)";
d914 1
a914 1
static ReturnStatus 	DoWait _ARGS_((Proc_ControlBlock *curProcPtr,
d1094 1
a1094 1
ENTRY static ReturnStatus 
@


9.16
log
@function prototypes
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.15 90/09/20 16:24:59 mgbaker Exp Locker: jhh $ SPRITE (Berkeley)";
d549 1
a549 6
     * Note: the fs is closed before the vm, because there is
     * a race involving data sent to a pseudo-device after its
     * vm has been destroyed.  Closing the fs first prevents this.
     * The old comments (below) imply closing the fs first will
     * cause swap files to linger around, but this doesn't seem
     * to happen. --Ken Shirriff 8/90
d551 11
a561 5
     * |Clean up the filesystem state of the exiting process.
     * |Do this after deleting VM segments so we can remove swap files.
     * If the process is the home "surrogate" process for a migrated
     * |process, don't clean up its state -- the state is on the foreign
     * |node, not this one.
d565 1
a565 1
	Fs_CloseState(exitProcPtr);
d608 4
@


9.15
log
@Fixed a procedure name.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.14 90/09/12 13:58:06 jhh Exp Locker: mgbaker $ SPRITE (Berkeley)";
d139 2
d653 2
a654 2
Proc_Reaper(procPtr, callInfoPtr)
    register	Proc_ControlBlock 	*procPtr;
d657 1
d1634 2
a1635 2
Proc_NotifyMigratedWaiters(pid, callInfoPtr)
    Proc_PID 		pid;
d1638 1
@


9.14
log
@changed format of #includes to use <>
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.13 90/09/06 17:57:03 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
d570 2
a571 2
    MachFlushWindowsToStack();
    VmMachFlushCurrentContext();
@


9.13
log
@First pass at function prototypes
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.12 90/09/04 23:45:02 shirriff Exp Locker: jhh $ SPRITE (Berkeley)";
d121 18
a138 18
#include "sprite.h"
#include "mach.h"
#include "status.h"
#include "proc.h"
#include "procInt.h"
#include "procMigrate.h"
#include "migrate.h"
#include "sync.h"
#include "sched.h"
#include "list.h"
#include "sys.h"
#include "vm.h"
#include "prof.h"
#include "dbg.h"
#include "stdlib.h"
#include "rpc.h"
#include "sig.h"
#include "stdio.h"
@


9.12
log
@Switched order of closing vm and fs when a segment is deleted.
This hopefully will fix a race condition with dying pseudodevices
receiving data when they have no virtual memory.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.11 90/07/30 15:46:52 douglis Exp Locker: shirriff $ SPRITE (Berkeley)";
a127 1

d138 1
d143 11
a153 3
static INTERNAL ReturnStatus FindExitingChild();
static INTERNAL void WakeupMigratedParent();
static void SendSigChild();
d297 1
a297 1
    Proc_State				newState;
d899 10
a908 3
static ReturnStatus 	CheckPidArray();
static ReturnStatus 	LookForAnyChild();
static ReturnStatus 	DoWait();
@


9.11
log
@changed parameter to ProcRecordUsage.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.10 90/07/29 15:50:57 shirriff Exp Locker: douglis $ SPRITE (Berkeley)";
d539 19
a592 4
	if (i>0) {
	    dprintf("ProcExitProcess: deleted shared segments\n");
	    PrintSharedSegs(exitProcPtr);
	}
a599 6
     * Clean up the filesystem state of the exiting process.
     * Do this after deleting VM segments so we can remove swap files.
     * If the process is the home "surrogate" process for a migrated
     * process, don't clean up its state -- the state is on the foreign
     * node, not this one.
     *
a602 4

    if (exitProcPtr->fsPtr != (struct Fs_ProcessState *) NIL) {
	Fs_CloseState(exitProcPtr);
    }
@


9.10
log
@Added address field to Sig_Send calls.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.9 90/06/27 17:04:13 douglis Exp $ SPRITE (Berkeley)";
d339 17
a355 1
	ProcRecordUsage(ticks, FALSE);
@


9.9
log
@wake up someone waiting for migration if the process starts to exit.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.8 90/06/27 11:19:17 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d166 1
a166 1
	status = Sig_SendProc(parentProcPtr, SIG_CHILD, 0); \
d824 1
a824 1
    (void)Sig_Send(SIG_CHILD, SIG_NO_CODE, (Proc_PID)data, FALSE);
d1254 1
a1254 1
			FALSE); 
@


9.8
log
@fixed some documentation.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.7 89/10/26 15:22:38 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d299 9
@


9.7
log
@include prof.h to make lint happy
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.6 89/10/25 11:39:53 shirriff Exp Locker: douglis $ SPRITE (Berkeley)";
d775 1
a775 3
     * the monitor lock isn't held during the RPC.  (Perhaps all signals
     * could be done with a callback and the backGroundSig flag could be
     * removed??)
d1585 1
a1585 1
ENTRY void
@


9.6
log
@Changed VmDeleteSharedSegment to Vm_DeleteSharedSegment
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.5 89/10/23 13:49:30 douglis Exp Locker: shirriff $ SPRITE (Berkeley)";
d132 1
d134 1
a134 1
#include "sys.h"
@


9.5
log
@fixed lint complaints
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.4 89/10/23 10:33:30 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d545 2
a546 2
  	    VmDeleteSharedSegment(exitProcPtr,
  		    List_First(exitProcPtr->vmPtr->sharedSegs));
@


9.4
log
@wait for transition from PROC_DYING to PROC_EXITING if needed.  (change by
jhh)
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.3 89/10/12 12:15:49 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
d150 1
d152 3
a483 1
    int				i;
d748 1
a748 1
Proc_InformParent(procPtr, childStatus, backGroundSig)
a752 2
    Boolean			backGroundSig;	/* Send the SIG_CHILD to
						 * the parent in background.*/
d786 1
a786 9
#ifdef notdef
    if (backGroundSig || migrated || parentProcPtr->state == PROC_MIGRATED) {
#endif
	Proc_CallFunc(SendSigChild, (ClientData)procPtr->parentID, 0);
#ifdef notdef
    } else {
	SIGNAL_PARENT(parentProcPtr, "ProcInformParent");
    }
#endif
@


9.3
log
@spelled dying correctly
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.2 89/10/12 11:13:54 douglis Exp Locker: jhh $ SPRITE (Berkeley)";
d1472 18
@


9.2
log
@store CPU time used
@
text
@d22 1
a22 1
 *	    2) When a process is about to exit the PROC_DIEING flag is set
d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.1 89/09/20 16:17:17 mgbaker Exp Locker: douglis $ SPRITE (Berkeley)";
d293 1
a293 1
    exitProcPtr->genFlags |= PROC_DIEING;
@


9.1
log
@Cache flush changes for sun4
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 9.0 89/09/12 15:15:08 douglis Stable Locker: mgbaker $ SPRITE (Berkeley)";
d286 1
d299 1
a299 1
     *  (it might not exist.)
d302 3
a304 3
    if (!(exitProcPtr->genFlags & PROC_FOREIGN) &&
        !(exitProcPtr->exitFlags & PROC_DETACHED)) {
	register Proc_ControlBlock 	*parentProcPtr;
d306 15
a320 14
	parentProcPtr = Proc_GetPCB(exitProcPtr->parentID);
	if (parentProcPtr != (Proc_ControlBlock *) NIL) {
	    Timer_AddTicks(exitProcPtr->kernelCpuUsage.ticks, 
			   parentProcPtr->childKernelCpuUsage.ticks, 
			   &(parentProcPtr->childKernelCpuUsage.ticks));
	    Timer_AddTicks(exitProcPtr->childKernelCpuUsage.ticks, 
			   parentProcPtr->childKernelCpuUsage.ticks, 
			   &(parentProcPtr->childKernelCpuUsage.ticks));
	    Timer_AddTicks(exitProcPtr->userCpuUsage.ticks, 
			   parentProcPtr->childUserCpuUsage.ticks, 
			   &(parentProcPtr->childUserCpuUsage.ticks));
	    Timer_AddTicks(exitProcPtr->childUserCpuUsage.ticks, 
			   parentProcPtr->childUserCpuUsage.ticks, 
			   &(parentProcPtr->childUserCpuUsage.ticks));
d322 5
@


9.0
log
@Changing version numbers.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 8.14 89/09/08 16:21:07 shirriff Exp Locker: douglis $ SPRITE (Berkeley)";
d507 1
@


8.14
log
@Added shared memory support so shared memory is cleaned up on exit.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 8.13 89/08/30 12:57:08 mgbaker Exp $ SPRITE (Berkeley)";
@


8.13
log
@sun4 performance opts.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 8.12 89/08/22 14:56:59 douglis Exp Locker: mgbaker $ SPRITE (Berkeley)";
d146 5
a151 1

d510 31
d546 1
@


8.12
log
@delete interval timers on exit
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 8.11 89/07/20 16:19:44 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d502 3
@


8.11
log
@don't lock exiting process if exitProcPtr in ProcExitProcess isn't
the current process -- the caller has already locked it.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 8.10 89/07/10 19:11:30 nelson Exp Locker: douglis $ SPRITE (Berkeley)";
d317 2
d320 3
d329 1
@


8.10
log
@Incorporated changes from DECWRL.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 8.9 89/06/15 16:51:53 douglis Exp $ SPRITE (Berkeley)";
d446 3
a448 1
 *  	If contextSwitch is TRUE, a context switch is performed.
d453 1
a453 1
ProcExitProcess(exitProcPtr, reason, status, code, contextSwitch) 
d461 1
a461 1
    Boolean 			contextSwitch;	/* TRUE => context switch */
d477 7
a483 1
    Proc_Lock(exitProcPtr);
d529 1
a529 1
    exitProcPtr->state = ExitProcessInt(exitProcPtr, migrated, contextSwitch);
@


8.9
log
@don't return INTERRUPTED_BY_SIGNAL when getting a SIG_CHILD during a 
Proc_Wait.  This is because locally you get woken up on the wait
condition before the signal hits, so a migrated child might cause
different behavior.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 8.8 89/05/30 16:12:59 jhh Exp Locker: douglis $ SPRITE (Berkeley)";
d491 1
@


8.8
log
@Removed call to Sync_LockRegister
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 8.7 89/05/21 18:27:21 mgbaker Exp Locker: jhh $ SPRITE (Berkeley)";
d1042 7
d1051 4
a1054 2
		status = GEN_ABORTED_BY_SIGNAL;
		break;
@


8.7
log
@checkin before sprint cleaning
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 8.6 89/03/31 12:06:34 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
a284 1
    Sync_LockRegister(LOCKPTR);
@


8.6
log
@Eighteenth sun4 Kernel.  It executes a signal now.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 8.5 89/03/02 18:42:04 douglis Exp Locker: mgbaker $ SPRITE (Berkeley)";
a227 7

#ifdef sun4
    if (curProcPtr->genFlags & PROC_USER) {
	printf("Proc_ExitInt: user proc 0x%x exiting with status 0x%x\n",
		(unsigned int) curProcPtr, status);
    }
#endif sun4
@


8.5
log
@fixed some forward declarations to say "static"
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 8.4 89/03/02 16:51:26 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d228 7
@


8.4
log
@if PROC_NO_PEER returned on remote wait for children, kill the process
because the copy on the home node no longer exists.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 8.3 89/02/19 22:07:18 jhh Exp Locker: douglis $ SPRITE (Berkeley)";
d142 1
a144 1
ReturnStatus	FindExitingChild();
@


8.3
log
@Changes due to lock registration
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 8.2 89/02/07 17:38:50 mendel Exp Locker: jhh $ SPRITE (Berkeley)";
d1178 1
a1178 1
	}
d1181 8
a1188 1
    if (proc_MigDebugLevel > 3) {
@


8.2
log
@Changes to REAP process on a multiprocessor.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 8.1 88/11/30 15:28:46 douglis Exp Locker: mendel $ SPRITE (Berkeley)";
d135 1
a135 1
#include "mem.h"
d139 1
a139 1
static	Sync_Lock	exitLock = SYNC_LOCK_INIT_STATIC();
d232 3
d284 2
@


8.1
log
@checks agsinst bogus parentIDs, null fsPtr.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 8.0 88/11/11 18:29:52 douglis Stable Locker: douglis $ SPRITE (Berkeley)";
d139 1
a139 1
static	Sync_Lock	exitLock = {0, 0};
d376 1
a377 1
	newState = PROC_DEAD;
d548 14
a561 3

    if (procPtr->state != PROC_DEAD) {
	panic("Proc_Reaper: non-DEAD proc on dead list.\n");
d563 19
a581 1

@


8.0
log
@Changing version numbers.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 6.6 88/11/08 15:59:47 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d298 14
a311 12
	Timer_AddTicks(exitProcPtr->kernelCpuUsage.ticks, 
		parentProcPtr->childKernelCpuUsage.ticks, 
		&(parentProcPtr->childKernelCpuUsage.ticks));
	Timer_AddTicks(exitProcPtr->childKernelCpuUsage.ticks, 
		parentProcPtr->childKernelCpuUsage.ticks, 
		&(parentProcPtr->childKernelCpuUsage.ticks));
	Timer_AddTicks(exitProcPtr->userCpuUsage.ticks, 
		parentProcPtr->childUserCpuUsage.ticks, 
		&(parentProcPtr->childUserCpuUsage.ticks));
	Timer_AddTicks(exitProcPtr->childUserCpuUsage.ticks, 
		parentProcPtr->childUserCpuUsage.ticks, 
		&(parentProcPtr->childUserCpuUsage.ticks));
d381 10
d392 5
d414 1
d500 1
a500 1
    if (exitProcPtr->state != PROC_MIGRATED) {
@


6.6
log
@check for remote host being down when doing exit of migrated process.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 6.5 88/10/27 20:02:48 mlgray Exp Locker: douglis $ SPRITE (Berkeley)";
@


6.5
log
@1st pass at multi-processor, conversion to new C library.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExit.c,v 6.4 88/10/19 11:18:55 douglis Exp $ SPRITE (Berkeley)";
d1036 1
d1043 18
d1090 11
a1100 2
	status = Rpc_Call(procPtr->peerHostID, RPC_PROC_REMOTE_WAIT,
			  &storage);
@


6.4
log
@A process that's waiting on an event when exiting indicates an error.
This is now flagged for migrated processes, which are exited by another
process rather than when they themselves are running (in the event of
killing a process when its peer dies).
Also, when sending a SIG_CHILD signal to a parent, this is now done
by a background Proc_CallFunc process so the exit monitor lock isn't
held.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: procExit.c,v 6.3 88/10/07 12:54:50 douglis Exp $ SPRITE (Berkeley)";
d160 1
a160 1
	    Sys_Panic(SYS_WARNING, "%s: Could not signal parent, status<%x>", \
d226 1
a226 1
	Sys_Panic(SYS_FATAL, "Proc_ExitInt: bad procPtr.\n");
d250 1
a250 1
    Sys_Panic(SYS_FATAL, "Proc_ExitInt: Exiting process still alive!!!\n");
d353 9
a361 3
	Sys_Panic((proc_MigDebugLevel > 0) ? SYS_FATAL : SYS_WARNING,
		  "ExitProcessInt: exiting process still waiting on event %x.\n",
		  exitProcPtr->event);
d400 1
a400 1
	Sys_Panic(SYS_FATAL, "ExitProcessInt: Exiting process still alive\n");
a427 1

d532 1
a532 2
	Sys_Panic(SYS_FATAL, 
		"Proc_Reaper: non-DEAD proc on dead list.\n");
d739 1
a739 1
	Sys_Panic(SYS_FATAL, "Proc_Detach: procPtr == NIL\n");
d825 1
a825 1
	Sys_Panic(SYS_FATAL, "Proc_Wait: curProcPtr == NIL.\n");
d847 1
a847 1
	    newPidArray = (Proc_PID *) Mem_Alloc(newPidSize);
d851 1
a851 1
		Mem_Free((Address) newPidArray);
d865 1
a865 1
	Mem_Free((Address) newPidArray);
d1038 1
a1038 1
	Sys_Printf("ProcRemoteWait(%x, ...) called.\n", procPtr->processID);
d1102 1
a1102 1
	Sys_Printf("ProcRemoteWait returning status %x.\n", status);
d1104 1
a1104 1
	    Sys_Printf("Child's id is %x, status %x.\n",
d1154 1
a1154 1
	Sys_Printf("pid %x got status %x from FindExitingChild\n",
d1157 1
a1157 1
	    Sys_Printf("Child's id is %x, status %x.\n",
d1438 1
a1438 1
	Sys_Printf("Proc_NotifyMigratedWaiters: notifying process %x.\n",
d1443 1
a1443 3
	Sys_Panic(SYS_WARNING,
		  "Warning: received status %x notifying process.\n",
		  status);
d1471 1
a1471 1
	Sys_Printf("WakeupMigratedParent: inserting process %x.\n", pid);
@


6.3
log
@wake up parent in background if on another machine.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: procExit.c,v 6.2 88/08/31 17:55:19 douglis Exp $ SPRITE (Berkeley)";
d348 11
d376 1
d378 1
a380 1
	    Proc_CallFunc(SendSigChild, (ClientData)exitProcPtr->parentID, 0);
d382 5
a591 1
    Sync_Broadcast(&parentProcPtr->waitCondition);
d596 2
d599 1
d601 5
d668 1
d670 1
d672 1
d676 1
@


6.2
log
@de-linted and endif-fix'ed.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: procExit.c,v 6.1 88/08/25 12:09:08 nelson Exp $ SPRITE (Berkeley)";
d142 3
a144 1
static INTERNAL void AddWaiter();
d146 2
a164 2
ReturnStatus	FindExitingChild();

d365 1
d367 2
a368 1
	    AddWaiter(parentProcPtr->processID);
a370 1
	SIGNAL_PARENT(parentProcPtr, "ExitProcessInt");
a576 2
    SIGNAL_PARENT(parentProcPtr, "Proc_DetachInt");

d578 3
a580 1
	AddWaiter(parentProcPtr->processID);
a585 2
void SendSigChild();

d631 4
a634 1
     * can go to an arbitrary node.
d644 1
a644 1
    if (backGroundSig || migrated) {
d673 1
a673 1
void
d1421 1
a1421 1
 * AddWaiter --
d1436 1
a1436 1
AddWaiter(pid)
d1441 1
a1441 1
	Sys_Printf("AddWaiter: inserting process %x.\n", pid);
@


6.1
log
@Changed to make cpu usage be represented in a format such that both the
kernel and user programs can use time.
@
text
@d118 2
a119 2
static char rcsid[] = "$Header: procExit.c,v 6.0 88/08/11 12:22:17 brent Stable $ SPRITE (Berkeley)";
#endif not lint
@


6.0
log
@Changing version numbers.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: procExit.c,v 5.16 88/08/04 15:29:32 douglis Exp $ SPRITE (Berkeley)";
d296 12
a307 12
	Timer_AddTicks(exitProcPtr->kernelCpuUsage, 
		parentProcPtr->childKernelCpuUsage, 
		&(parentProcPtr->childKernelCpuUsage));
	Timer_AddTicks(exitProcPtr->childKernelCpuUsage, 
		parentProcPtr->childKernelCpuUsage, 
		&(parentProcPtr->childKernelCpuUsage));
	Timer_AddTicks(exitProcPtr->userCpuUsage, 
		parentProcPtr->childUserCpuUsage, 
		&(parentProcPtr->childUserCpuUsage));
	Timer_AddTicks(exitProcPtr->childUserCpuUsage, 
		parentProcPtr->childUserCpuUsage, 
		&(parentProcPtr->childUserCpuUsage));
d1225 4
a1228 4
	infoPtr->kernelCpuUsage		= procPtr->kernelCpuUsage;
	infoPtr->userCpuUsage		= procPtr->userCpuUsage;
	infoPtr->childKernelCpuUsage	= procPtr->childKernelCpuUsage;
	infoPtr->childUserCpuUsage 	= procPtr->childUserCpuUsage;
@


5.16
log
@removed duplicate include of mach.h
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: procExit.c,v 5.15 88/07/25 17:02:54 nelson Exp $ SPRITE (Berkeley)";
@


5.15
log
@Minor changes for gcc.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: procExit.c,v 5.14 88/07/18 15:03:45 douglis Exp $ SPRITE (Berkeley)";
a137 1
#include "mach.h"
@


5.14
log
@don't close fs state if migrated away (state == PROC_MIGRATED) rather
than if migrated flag set, which was wrong. Also, removed extraneous
check for status==SUCCESS within a block dependent already on status.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: procExit.c,v 5.13 88/07/08 16:01:18 douglis Exp $ SPRITE (Berkeley)";
d161 2
@


5.13
log
@only close fs state of non-migrated processes, and only free the
machState if it exists (again, for migrated processes).  Finally,
signal the parent using a background signal if the exiting process
is foreign, since you have the parentProcessID but not the actual
process.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: procExit.c,v 5.12 88/06/30 17:35:31 douglis Exp $ SPRITE (Berkeley)";
d448 6
a453 2
     * Remove the process from its process family.  In each case,
     * migrated processes have already been handled so don't do them again.
d456 3
a459 1
	Fs_CloseState(exitProcPtr);
d838 1
a838 1
	if (status == SUCCESS && reasonPtr != USER_NIL) {
d844 1
a844 1
	if (status == SUCCESS && statusPtr != USER_NIL) {
d850 1
a850 1
	if (status == SUCCESS && subStatusPtr != USER_NIL) {
d856 1
a856 1
	if (status == SUCCESS && usagePtr != USER_NIL) {
@


5.12
log
@just documentation.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: procExit.c,v 5.11 88/06/09 11:36:40 brent Exp $ SPRITE (Berkeley)";
d420 1
a420 1
     * Decrement the reference count on the environmenet.
d448 2
a451 2
    Fs_CloseState(exitProcPtr);

d453 1
d504 10
a513 1
    Mach_FreeState(procPtr);
d605 1
d621 3
d625 9
a633 3
    parentProcPtr = Proc_GetPCB(procPtr->parentID);
    Sync_Broadcast(&parentProcPtr->waitCondition);
    if (backGroundSig) {
@


5.11
log
@Moved filesystem clean-up after vm clean-up so that
swap files can be removed correctly.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: procExit.c,v 5.10 88/05/05 17:57:40 nelson Exp $ SPRITE (Berkeley)";
d640 2
d645 1
a645 1
    Proc_CallInfo	*callInfoPtr;
@


5.10
log
@Handles move of functionality from sys to mach.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: procExit.c,v 5.9 88/05/04 16:46:00 nelson Exp $ SPRITE (Berkeley)";
a419 6
     * Clean up the filesystem state of the exiting process.
     */

    Fs_CloseState(exitProcPtr);

    /*
d445 6
@


5.9
log
@Uses new mach module stuff.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: procExit.c,v 5.8 88/04/27 18:56:25 nelson Exp $ SPRITE (Berkeley)";
d122 1
d221 1
a221 1
    curProcPtr = Proc_GetActualProc(Sys_GetProcessorNumber());
d672 1
a672 1
    procPtr = Proc_GetEffectiveProc(Sys_GetProcessorNumber());
d758 1
a758 1
    curProcPtr = Proc_GetCurrentProc(Sys_GetProcessorNumber());
@


5.8
log
@Made Proc_Wait understand changes in process state.
@
text
@d118 1
a118 1
static char rcsid[] = "$Header: procExit.c,v 5.7 88/04/22 14:20:42 nelson Exp $ SPRITE (Berkeley)";
a133 1
#include "machine.h"
d137 1
d231 1
a231 2
	 * list before allowing it to exit.  NOTE: Need to get at the 
	 * machine state (registers and PC).
d233 1
a233 1
	Proc_SuspendProcess(curProcPtr, TRUE, reason, status, code, 0);
d502 1
a502 3
    if (procPtr->stackStart != NIL) {
	Vm_FreeKernelStack(procPtr->stackStart);
    }
@


5.7
log
@Puts a process onto the debug list if it exits while being debugged.
@
text
@d38 1
a38 1
 *			until thte parent waits for it via Proc_Wait or dies
a41 2
 *	PROC_DEBUGGABLE	It is on the debug list, waiting for a debugger
 *			to remove it and debug it.
d46 1
d51 6
a56 3
 *	PROC_SUSPENDED_AND_WAITED_ON:
 *			It is suspended and its parent waited on it after it
 *			was suspended.  In this	case it isn't detached.
d118 1
a118 1
static char rcsid[] = "$Header: procExit.c,v 5.6 88/04/18 09:07:48 ouster Exp $ SPRITE (Berkeley)";
d234 1
a234 1
	Proc_PutOnDebugList(curProcPtr, reason, status, code, 0);
d568 2
d574 1
a574 1
 * ProcInformParent --
d576 2
a577 2
 *	Tell the parent of the caller that the calling process has been
 *	suspended.
d583 1
a583 1
 *	None.
d588 7
a594 1
ProcInformParent()
a595 1
    register	Proc_ControlBlock	*procPtr;
a599 2
    procPtr = Proc_GetEffectiveProc(Sys_GetProcessorNumber());

d615 7
a621 2
    SIGNAL_PARENT(parentProcPtr, "ProcInformParent");
    procPtr->exitFlags &= ~PROC_SUSPENDED_AND_WAITED_ON;
d630 24
d663 1
a663 1
 *	Statues set in the proc table for the process.
d703 5
a707 4
 *	Returns information about a terminated/detached child process after
 *	(optionally) waiting for it to terminate or detach itself. 
 *	The returned information includes the reason why the process 
 * 	terminated and a summary of resource usage.
d712 1
a712 1
 *	A detached procss is process that has called Proc_Detach to detach 
a727 1

a769 1
     *  We are looking for terminated or detached children processes.
d771 1
a771 1
     *  look for any child that has terminated/detached.
a772 1

a782 1

d876 4
a879 3
			/* PROC_WAIT_BLOCK => wait if no children have exited,
			 * detached or suspended.  PROC_WAIT_FOR_SUSPEND => 
			 * return status of suspended children. */
d894 1
a894 1
	 * has exited or detached. Otherwise, see if any child has done so.
a895 1

a902 1

a910 1

a918 1

a928 1

d947 2
a948 2
 *	process.  Transfer the information for a child that has exited or
 *	detached, if one exists, and set up the information for a remote
d964 5
a968 5
    Proc_ControlBlock *procPtr;
    int	flags;
    int numPids;
    Proc_PID pidArray[];
    ProcChildInfo *childInfoPtr;
d1055 4
a1058 5
 *	there is an appropriate terminated/detached child, returns
 *	information about it (refer to Proc_Wait).  If not, returns
 *	PROC_NO_EXITS.  If the migrated process specified that it
 *	should block, set up a remote wakeup for when a child exits or
 *	detaches.
d1062 1
a1062 1
 *	PROC_NO_EXITS    -	no children have exited or detached who have
a1087 4
    /*
     * Find an exiting child if one exists.
     */

a1103 1

d1120 2
a1121 2
 *	Find a child of the specified process who has exited or become
 *	detached, subject to possible constraints (a list of process
d1145 2
a1146 1
						 * suspended children. */ 
d1163 2
a1164 1
	if (procPtr->state != PROC_SUSPENDED) {
d1166 1
a1166 1

d1170 1
a1170 2
		 * from the exiting list to the dead list unless it is the head
		 * of a family that still has members in it. 
d1176 3
a1178 3
		 * The child is detached.
		 * Set a flag to make sure we don't find this process
		 * again in a future call to Proc_Wait.
d1183 10
a1192 1
	    procPtr->exitFlags |= PROC_SUSPENDED_AND_WAITED_ON;
a1195 1
	infoPtr->termReason		= procPtr->termReason;
d1218 2
a1219 2
 *	them have exited or become detached.  If no child is
 *	found, make sure there is a child who can wake us up.
a1220 2
 *	This routine is assumed to be called with the master lock down.
 *
d1245 2
a1246 5
     *  to have exited or detached. Ignore children that are detached
     *  and waited-on.  Remember if we find a child that isn't exiting
     *  or detached, since if we don't find any like that and we don't
     *  find a child that has exited/detached, then there are no
     *  children for which to wait.
d1253 2
a1254 3
	    (returnSuspend && procPtr->state == PROC_SUSPENDED && 
		!(procPtr->exitFlags & PROC_SUSPENDED_AND_WAITED_ON)) ||
	    (procPtr->exitFlags & PROC_DETACHED))  {
d1278 1
a1278 1
 *	have exited or become detached.
d1296 2
a1297 2
							 * about suspended
							 * children. */
a1311 1

d1322 6
a1327 6
	    (returnSuspend && procPtr->state == PROC_SUSPENDED &&
		!(procPtr->exitFlags & PROC_SUSPENDED_AND_WAITED_ON)) ||
	    ((procPtr->exitFlags & PROC_DETACHED) &&
	    !(procPtr->exitFlags & PROC_WAITED_ON))) {
	    *procPtrPtr = procPtr;
	    return(SUCCESS);
@


5.6
log
@Lint cleanup, change copyright notices.
@
text
@d116 1
a116 1
static char rcsid[] = "$Header: procExit.c,v 5.5 87/12/22 14:32:45 douglis Exp $ SPRITE (Berkeley)";
d226 9
@


5.5
log
@removed extraneous "#include sync.h" that had been there ever since the
move to sprite.  (How??)
@
text
@d8 1
a8 1
 *	dead list. 
d10 9
a112 4
 *
 *
 * Copyright 1986 Regents of the University of California
 * All rights reserved.
d116 1
a116 1
static char rcsid[] = "$Header: procExit.c,v 5.4 87/12/12 16:39:25 nelson Exp $ SPRITE (Berkeley)";
@


5.4
log
@Handles moving of hardware dependencies from vm to sun.
@
text
@d111 1
a111 1
static char rcsid[] = "$Header: procExit.c,v 5.3 87/10/22 14:58:01 nelson Exp $ SPRITE (Berkeley)";
a125 1
#include "sync.h"
@


5.3
log
@Changed VM to only contain a single pointer.
@
text
@d111 1
a111 1
static char rcsid[] = "$Header: procExit.c,v 5.2 87/09/20 15:25:12 deboor Exp $ SPRITE (Berkeley)";
a434 1
	Vm_MachExit(exitProcPtr);
d491 1
a491 1
    Vm_ContextFree(procPtr);
@


5.2
log
@Fixed condition in CheckPidArray that caused it to complain about a process
that was the child of the current one, rather than one that wasn't a child...
@
text
@d111 1
a111 1
static char rcsid[] = "$Header: procExit.c,v 5.1 87/08/27 10:46:27 brent Exp $ SPRITE (Berkeley)";
d433 1
a433 1
	    Vm_SegmentDelete(exitProcPtr->segPtrArray[i], exitProcPtr);
@


5.1
log
@
Shuffled status.h because sprite.h doesn't include it anymore.
@
text
@d111 1
a111 1
static char rcsid[] = "$Header: procExit.c,v 5.0 87/08/11 10:47:01 sprite Exp $ SPRITE (Berkeley)";
d1280 1
a1280 1
	if (Proc_ComparePIDs(procPtr->parentID, curProcPtr->processID)) {
@


5.0
log
@First Sprite native copy
@
text
@d111 1
a111 1
static char rcsid[] = "$Header: procExit.c,v 4.10 87/08/07 15:05:13 nelson Exp $ SPRITE (Berkeley)";
d114 1
a115 1
#include "sprite.h"
@
