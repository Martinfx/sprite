head     9.19;
branch   ;
access   ;
symbols  ds3100:9.19 sun3:9.19 sun4nw:9.16 symm:9.16 spur:9.16 sprited:9.14.1 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.19
date     92.10.26.13.55.12;  author mgbaker;  state Exp;
branches ;
next     9.18;

9.18
date     92.06.01.15.29.29;  author kupfer;  state Exp;
branches ;
next     9.17;

9.17
date     92.03.06.11.54.06;  author mgbaker;  state Exp;
branches ;
next     9.16;

9.16
date     91.09.06.15.41.20;  author mgbaker;  state Exp;
branches ;
next     9.15;

9.15
date     91.09.06.15.34.22;  author rab;  state Exp;
branches ;
next     9.14;

9.14
date     91.08.22.12.47.32;  author mendel;  state Exp;
branches 9.14.1.1;
next     9.13;

9.13
date     91.03.30.17.08.16;  author mgbaker;  state Exp;
branches ;
next     9.12;

9.12
date     91.03.09.17.33.48;  author kupfer;  state Exp;
branches ;
next     9.11;

9.11
date     91.01.26.15.32.58;  author mgbaker;  state Exp;
branches ;
next     9.10;

9.10
date     90.10.10.16.37.29;  author kupfer;  state Exp;
branches ;
next     9.9;

9.9
date     90.10.08.16.18.01;  author mendel;  state Exp;
branches ;
next     9.8;

9.8
date     90.05.18.12.08.46;  author shirriff;  state Exp;
branches ;
next     9.7;

9.7
date     90.05.03.19.24.39;  author douglis;  state Exp;
branches ;
next     9.6;

9.6
date     90.02.15.09.25.43;  author brent;  state Exp;
branches ;
next     9.5;

9.5
date     89.12.11.17.39.49;  author brent;  state Exp;
branches ;
next     9.4;

9.4
date     89.11.07.10.39.50;  author shirriff;  state Exp;
branches ;
next     9.3;

9.3
date     89.10.26.18.46.12;  author brent;  state Exp;
branches ;
next     9.2;

9.2
date     89.10.23.12.31.50;  author brent;  state Exp;
branches ;
next     9.1;

9.1
date     89.09.18.13.50.11;  author brent;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.04.16;  author douglis;  state Stable;
branches ;
next     8.4;

8.4
date     89.08.21.15.24.28;  author mendel;  state Exp;
branches ;
next     8.3;

8.3
date     89.08.15.18.42.11;  author rab;  state Exp;
branches ;
next     8.2;

8.2
date     89.06.09.11.23.47;  author brent;  state Exp;
branches ;
next     8.1;

8.1
date     89.02.09.08.38.17;  author brent;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.17.59;  author douglis;  state Stable;
branches ;
next     7.0;

7.0
date     88.11.07.14.47.05;  author brent;  state Exp;
branches ;
next     6.2;

6.2
date     88.09.14.11.34.35;  author nelson;  state Exp;
branches ;
next     6.1;

6.1
date     88.09.07.21.19.40;  author nelson;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.14.46;  author brent;  state Stable;
branches ;
next     1.5;

1.5
date     88.08.04.14.49.08;  author mlgray;  state Exp;
branches ;
next     1.4;

1.4
date     88.06.06.09.34.36;  author brent;  state Exp;
branches ;
next     1.3;

1.3
date     88.06.01.16.50.54;  author brent;  state Exp;
branches ;
next     1.2;

1.2
date     88.04.11.08.25.56;  author brent;  state Exp;
branches ;
next     1.1;

1.1
date     88.04.04.10.29.25;  author brent;  state Exp;
branches ;
next     ;

9.14.1.1
date     91.09.15.18.10.04;  author kupfer;  state Exp;
branches ;
next     ;


desc
@Definitions for the block cache manager
@


9.19
log
@New code to support recovery that ignores files without dirty cache blocks.
@
text
@/*
 * fscache.h --
 *
 *	Declarations of interface to the Sprite file system cache. 
 *
 * Copyright 1989 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 *
 * $Header: /sprite/src/kernel/Cvsroot/kernel/fscache/fscache.h,v 9.18 92/06/01 15:29:29 kupfer Exp $ SPRITE (Berkeley)
 */

#ifndef _FSCACHE
#define _FSCACHE

#include <sync.h>
#include <list.h>
#include <fs.h>
#include <user/time.h>

/* data structures */	


/*
 * Cache information for each file.
 */

typedef struct Fscache_Attributes {
    int		firstByte;	/* Cached version of desc. firstByte */
    int		lastByte;	/* Cached version of desc. lastByte */
    int		accessTime;	/* Cached version of access time */
    int		modifyTime;	/* Cached version of modify time */
    int		createTime;	/* Create time (won't change, but passed
				 * to clients for use in
				 * statistics-gathering) */
    int		userType;	/* user advisory file type, defined in
				 * user/fs.h */
    /*
     * The following fields are needed by Proc_Exec.
     */
    int		permissions;	/* File permissions */
    int		uid;		/* User ID of owner */
    int		gid;		/* Group Owner ID */
} Fscache_Attributes;




/*
 * Structure to represent a cache block in the fileservers cache block 
 * list and the core map list.
 */
typedef struct Fscache_FileInfo {
    List_Links	   links;	   /* Links for the list of dirty files.
				      THIS MUST BE FIRST in the struct */
    List_Links	   dirtyList;	   /* List of dirty blocks for this file.
				    * THIS MUST BE SECOND, see the macro
				    * in fsBlockCache.c that depends on it. */
    List_Links	   blockList;      /* List of blocks for the file */
    List_Links	   indList;	   /* List of indirect blocks for the file */
    Sync_Lock	   lock;	   /* This is used to serialize cache access */
    int		   flags;	   /* Flags to indicate the state of the
				      file, defined below. */
    int		   version;	   /* Used to verify validity of cached data */
    struct Fs_HandleHeader *hdrPtr; /* Back pointer to I/O handle */
    int		   blocksInCache;  /* The number of blocks that this file has
				      in the cache. */
    int		   blocksWritten;  /* The number of blocks that have been
				    * written in a row without requiring a 
				    * sync of the servers cache. */
    int		   numDirtyBlocks; /* The number of dirty blocks in the cache.*/
    Sync_Condition noDirtyBlocks;  /* Notified when all write backs done. */
    int		   lastTimeTried;  /* Time that last tried to see if disk was
				    * available for this block. */
    time_t	   oldestDirtyBlockTime;
    Fscache_Attributes attr;	   /* Local version of descriptor attributes. */
    struct Fscache_Backend   *backendPtr;  
			/* Routines for read/write/allocate/copy. */
} Fscache_FileInfo;

/*
 * Values for flags field in the Fscache_FileInfo struct.
 *
 *   FSCACHE_CLOSE_IN_PROGRESS	There is a close being done on this file so
 *				no more delayed writes are allowed.
 *   FSCACHE_SERVER_DOWN	The host that this file belongs is down.
 *   FSCACHE_NO_DISK_SPACE	The domain that this file lives in has no
 *				disk space.
 *   FSCACHE_DOMAIN_DOWN	The domain to write to is not available.
 *   FSCACHE_GENERIC_ERROR	An error occured for which we just hang onto
 *				file blocks until we can write them out.
 *   FSCACHE_SYNC_DONE		The server has been told to force all blocks
 *				for this file to disk.
 *   FSCACHE_FILE_BEING_WRITTEN	There already is a block cleaner working on
 *				this process.
 *   FSCACHE_FILE_ON_DIRTY_LIST	This file is on the dirty list.
 *   FSCACHE_WRITE_TO_DISK	Want file forced to disk.
 *   FSCACHE_FILE_NOT_CACHEABLE	This is set when files served by remote hosts
 *				are no longer caching because of write sharing
 *				or because the file is a directory.
 *   FSCACHE_LARGE_FILE_MODE	This file is large enough such that we limit it
 *				to only a few blocks in the cache.
 *   FSCACHE_FILE_GONE		The file has been removed and any delayed
 *				writes should be discarded.
 *   FSCACHE_IS_DIR		File not cacheable because it's a directory.
 *				This is used for keeping statistics.
 *   FSCACHE_ALLOC_FAILED	Allocated failed due to disk full.  This
 *				is used to throttle error messages.
 *   FSCACHE_FILE_BEING_CLEANED
 */
#define	FSCACHE_CLOSE_IN_PROGRESS	0x0001
#define	FSCACHE_SERVER_DOWN		0x0002
#define	FSCACHE_NO_DISK_SPACE		0x0004
#define FSCACHE_DOMAIN_DOWN		0x0008
#define FSCACHE_GENERIC_ERROR		0x0010
#define	FSCACHE_SYNC_DONE		0x0020
#define FSCACHE_FILE_BEING_WRITTEN	0x0040
#define	FSCACHE_FILE_ON_DIRTY_LIST	0x0080
#define FSCACHE_WRITE_TO_DISK		0x0100
#define FSCACHE_FILE_NOT_CACHEABLE	0x0200
#define	FSCACHE_LARGE_FILE_MODE		0x0400
#define FSCACHE_FILE_GONE		0x0800
#define	FSCACHE_IS_DIR			0x1000
#define FSCACHE_ALLOC_FAILED		0x2000
#define	FSCACHE_FILE_FSYNC		0x4000
#define	FSCACHE_FILE_DESC_DIRTY		0x8000
#define	FSCACHE_FILE_BEING_CLEANED     0x10000

/*
 * Structure to represent a cache block in the fileservers cache block 
 * list and the core map list.
 */
typedef struct Fscache_Block {
    List_Links	dirtyLinks;	/* Links to put block into list of dirty
				 * blocks for the file.  THIS MUST BE FIRST 
				 * in the struct. It may be used by the
				 * cache backend's after a Fetch_DirtyBlock
				 * call.  */
    List_Links	useLinks;	/* Links to put block into list of unused 
				   cache blocks or LRU list of cache blocks.
				   THIS MUST BE SECOND in the struct. */
    List_Links	fileLinks;	/* Links to put block into list of blocks
				 * for the file.  There are two lists, either
				 * regular or for indirect blocks. */
    time_t timeDirtied;		/* Time in seconds that block was
				   dirtied if at all. */
    time_t timeReferenced;	/* Time in seconds that this block was
				 * last referenced. */
    Address	blockAddr;	/* Kernel virtual address where data for
				   cache block is at. */
    Fscache_FileInfo *cacheInfoPtr;	/* Reference to file's cache info. */
    int		fileNum;	/* For consistency checks */
    int		blockNum;	/* The number of this block in the file. */
    int		diskBlock;	/* The block number on disk for this block. 
				   For remote blocks this equals blockNum. */
    int		blockSize;	/* The number of valid bytes in this block. */
    int		refCount;	/* Number of times that the block is referenced.
				   0 means is unreferenced. */
    Sync_Condition ioDone;	/* Notified when block is unlocked after I/O */
    int		flags;		/* Flags to indicate state of block. */
} Fscache_Block;

/* 
 * Flags for a Fscache_Block: 
 * 
 *   FSCACHE_BLOCK_FREE			The block is not being used.
 *   FSCACHE_BLOCK_ON_DIRTY_LIST	The block is on the dirty list.
 *   FSCACHE_BLOCK_BEING_WRITTEN	The block is in the process of being
 *					written to disk.
 *   FSCACHE_BLOCK_DIRTY		The block contains dirty data.
 *   FSCACHE_BLOCK_DELETED		This block has been deleted.  This
 *					flag is set when a block is to be
 *					invalidated after it has been cleaned.
 *   FSCACHE_MOVE_TO_FRONT		After this block has finished being
 *					cleaned move it to the front of the
 *					LRU list.
 *   FSCACHE_WRITE_BACK_WAIT		This block is being written out by 
 *					FsCacheWriteBack which is waiting
 *					for all such blocks to be written out.
 *   FSCACHE_BLOCK_WRITE_LOCKED		This block is being modified.
 *   FSCACHE_BLOCK_NEW			This block was just created.
 *   FSCACHE_BLOCK_CLEANER_WAITING	The block cleaner is waiting for this
 *					block to become unlocked in order to
 *					write it out.
 *   FSCACHE_NOT_MAPPED			This cache block does not have
 *					physical memory behind it.
 *   FSCACHE_IND_BLOCK			This block is an indirect block.
 *   FSCACHE_DESC_BLOCK			This block is a file descriptor block.
 *   FSCACHE_DIR_BLOCK			This is a directory block.
 *   FSCACHE_DATA_BLOCK			This is a data block.
 *   FSCACHE_READ_AHEAD_BLOCK		This block was read ahead.
 *   FSCACHE_IO_IN_PROGRESS		IO is in progress on this block.
 *   FSCACHE_CANT_BLOCK
 *   FSCACHE_DONT_BLOCK			Don't block if the cache block is
 *					already locked.	
 *   FSCACHE_PIPE_BLOCK			This is a block that is permanently
 *					locked so that it can serve as the
 *					data area for a pipe. (NOT USED)
 *   FSCACHE_WRITE_THRU_BLOCK		This block is being written through by
 *					the caller to Fscache_UnlockBlock.
 *   FSCACHE_BLOCK_BEING_CLEANED        The block is being cleaned.
 */
#define	FSCACHE_BLOCK_FREE			0x000001
#define	FSCACHE_BLOCK_ON_DIRTY_LIST		0x000002
#define	FSCACHE_BLOCK_BEING_WRITTEN		0x000004
#define	FSCACHE_BLOCK_DIRTY			0x000008
#define	FSCACHE_BLOCK_DELETED			0x000010
#define	FSCACHE_MOVE_TO_FRONT			0x000020
#define	FSCACHE_WRITE_BACK_WAIT			0x000040
#define	FSCACHE_BLOCK_WRITE_LOCKED		0x000100
#define	FSCACHE_BLOCK_NEW			0x000200
#define	FSCACHE_BLOCK_CLEANER_WAITING		0x000400
#define	FSCACHE_NOT_MAPPED			0x000800
#define	FSCACHE_IND_BLOCK			0x001000
#define	FSCACHE_DESC_BLOCK			0x002000
#define	FSCACHE_DIR_BLOCK			0x004000
#define	FSCACHE_DATA_BLOCK			0x008000
#define	FSCACHE_READ_AHEAD_BLOCK		0x010000
#define	FSCACHE_IO_IN_PROGRESS			0x020000
#define FSCACHE_DONT_BLOCK			0x040000
#define FSCACHE_PIPE_BLOCK			0x080000
#define	FSCACHE_WRITE_THRU_BLOCK		0x100000
#define	FSCACHE_CANT_BLOCK			0x200000
#define	FSCACHE_BLOCK_BEING_CLEANED		0x400000

/*
 * Macro to get the block address field of the Fscache_Block struct.
 */

#define	Fscache_BlockAddress(cacheBlockPtr) ((cacheBlockPtr)->blockAddr)

/*
 * Constant to pass to Fscache_FileWriteBack, which takes block numbers as
 * arguments.
 */
#define FSCACHE_LAST_BLOCK	-1

/*
 * Constants to pass as flags to Fscache_FileWriteBack.
 *
 *    FSCACHE_FILE_WB_WAIT		Wait for blocks to be written back.
 *    FSCACHE_WRITE_BACK_INDIRECT	Write back indirect blocks.
 *    FSCACHE_WRITE_BACK_AND_INVALIDATE	Invalidate after writing back.
 *    FSCACHE_WB_MIGRATION		Invalidation due to migration (for
 *					statistics purposes only).
 *    FSCACHE_WRITE_BACK_DESC_ONLY 	Only writeback the descriptor.
 */
#define FSCACHE_FILE_WB_WAIT		0x1
#define	FSCACHE_WRITE_BACK_INDIRECT	0x2
#define	FSCACHE_WRITE_BACK_AND_INVALIDATE	0x4
#define	FSCACHE_WB_MIGRATION	0x8
#define	FSCACHE_WRITE_BACK_DESC_ONLY	0x10

/*
 * Constants to pass as flags to FsUnlockCacheBlock.
 *
 *    FSCACHE_DELETE_BLOCK	    The block should be deleted when it is unlocked.
 *    FSCACHE_CLEAR_READ_AHEAD   Clear the read ahead flag from the block.
 *    FSCACHE_BLOCK_UNNEEDED     This block is not needed anymore.  Throw it away
 *			    as soon as possible.
 *    FSCACHE_DONT_WRITE_THRU    Don't write this block through to disk.
 *
 * Also can pass one of the 4 block types defined above (0x1000 - 0x8000).
 */
#define	FSCACHE_DELETE_BLOCK			0x0001
#define	FSCACHE_CLEAR_READ_AHEAD		0x0002
#define FSCACHE_BLOCK_UNNEEDED		0x0004
#define	FSCACHE_DONT_WRITE_THRU		0x0008

/*
 * Flags for Fscache_Trunc
 *	FSCACHE_TRUNC_DELETE	Truncate because the file is deleted.  This
 *				is used to prevent delayed writes during the
 *				truncation of the file.
 */
#define FSCACHE_TRUNC_DELETE		0x1

typedef struct Fscache_BackendRoutines {
    /*
     *	FooAllocate(hdrPtr, offset, bytes, flags, blockAddrPtr, newBlockPtr)
     *		Fs_HandleHeader *hdrPtr;			(File handle)
     *		int		offset;			(Byte offset)
     *		int		bytes;			(Bytes to allocate)
     *		int		flags;			(FSCACHE_DONT_BLOCK)
     *		int		*blockAddrPtr;		(Returned block number)
     *		Boolean		*newBlockPtr;		(TRUE if new block)
     *	FooTruncate(hdrPtr, size, delete)
     *		Fs_HandleHeader	*hdrPtr;		(File handle)
     *		int		size;			(New size)
     *		Boolean		delete;			(TRUE if file being 
     *							 removed)
     *	FooBlockRead(hdrPtr, blockPtr,remoteWaitPtr)
     *		Fs_HandleHeader	*hdrPtr;		(File handle)
     *		Fscache_Block	*blockPtr;		(Cache block to read)
     *		Sync_RemoteWaiter *remoteWaitPtr;	(For remote waiting)
     *	FooBlockWrite(hdrPtr, blockPtr, lastDirtyBlock)
     *		Boolean		lastDirtyBlock;		(Indicates last block)
     *	FooReallocBlock(data, callInfoPtr)
     *		ClientData	data = 	blockPtr;  (Cache block to realloc)
     *		Proc_CallInfo	*callInfoPtr;	
     *	FooStartWriteBack(backendPtr)
     *        Fscache_Backend *backendPtr;	(Backend to start writeback.)
     */ 
    ReturnStatus (*allocate) _ARGS_((Fs_HandleHeader *hdrPtr, int offset,
				    int numBytes, int flags, int *blockAddrPtr,
				    Boolean *newBlockPtr));
    ReturnStatus (*truncate) _ARGS_((Fs_HandleHeader *hdrPtr, int size, 
				     Boolean delete));
    ReturnStatus (*blockRead) _ARGS_((Fs_HandleHeader *hdrPtr, 
				      Fscache_Block *blockPtr, 
				      Sync_RemoteWaiter *remoteWaitPtr));
    ReturnStatus (*blockWrite) _ARGS_((Fs_HandleHeader *hdrPtr, 
				       Fscache_Block *blockPtr, int flags));
    void	 (*reallocBlock) _ARGS_((ClientData data, 
					 Proc_CallInfo *callInfoPtr));

				/* Second parameter is for ASPLOS only.
				 * Remove when that's over. -Mary 2/15/92. */
    ReturnStatus (*startWriteBack) _ARGS_((struct Fscache_Backend *backendPtr, Boolean fileFsynced));
} Fscache_BackendRoutines;


/*
 * Routines and data structures defining a backend to the cache. 
 */
typedef struct Fscache_Backend {
    List_Links	cacheLinks;	/* Used by fscacheBlocks.c to link backends
				 * onto a list. Must be first in structure! */
    int		flags;		/* See below. */
    ClientData	clientData;	/* ClientData for the backend. */
    List_Links	dirtyListHdr;   /* List of dirty files for this backend. */

    Fscache_BackendRoutines ioProcs; /* Routines for backend. */
} Fscache_Backend;


/*
 * Read-ahead is used for both local and remote files that are cached.
 * The following structure is used to synchronize read ahead with other I/O.
 */

typedef struct Fscache_ReadAheadInfo {
    Sync_Lock		lock;		/* Access to this state is monitored */
    int			count;		/* Number of read aheads in progress */
    Boolean		blocked;	/* TRUE if read ahead is blocked */
    Sync_Condition	done;		/* Notified when there are no more read
					 * aheads in progress. */
    Sync_Condition	okToRead;	/* Notified when there are no more
					 * conflicts with read ahead. */
} Fscache_ReadAheadInfo;			/* 24 BYTES */

#define	FSCACHE_NUM_DOMAIN_TYPES	2

#ifndef CLEAN
#define FSCACHE_DEBUG_PRINT(string) \
	if (fsconsist_Debug) {\
	    printf(string);\
	}
#define FSCACHE_DEBUG_PRINT1(string, arg1) \
	if (fsconsist_Debug) {\
	    printf(string, arg1);\
	}
#define FSCACHE_DEBUG_PRINT2(string, arg1, arg2) \
	if (fsconsist_Debug) {\
	    printf(string, arg1, arg2);\
	}
#define FSCACHE_DEBUG_PRINT3(string, arg1, arg2, arg3) \
	if (fsconsist_Debug) {\
	    printf(string, arg1, arg2, arg3);\
	}
#else
#define FSCACHE_DEBUG_PRINT(string)
#define FSCACHE_DEBUG_PRINT1(string, arg1)
#define FSCACHE_DEBUG_PRINT2(string, arg1, arg2)
#define FSCACHE_DEBUG_PRINT3(string, arg1, arg2, arg3)
#endif not CLEAN

/*
 * The cache uses a number of Proc_ServerProcs to do write-backs.
 * FSCACHE_MAX_CLEANER_PROCS defines the maximum number, and this
 * is used to configure the right number of Proc_ServerProcs.
 */
#define FSCACHE_MAX_CLEANER_PROCS	6

extern int	fscache_MaxBlockCleaners;
extern int	fscache_NumReadAheadBlocks;

extern List_Links *fscacheFullWaitList;

/* procedures */

/*
 * Block Cache routines. 
 */
extern void Fscache_WriteBack _ARGS_((unsigned int writeBackTime,
			int *blocksSkippedPtr, Boolean writeBackAll));
extern ReturnStatus Fscache_FileWriteBack _ARGS_((
			Fscache_FileInfo *cacheInfoPtr, int firstBlock, 
			int lastBlock, int flags, int *blocksSkippedPtr));
extern void Fscache_FileInvalidate _ARGS_((Fscache_FileInfo *cacheInfoPtr, 
			int firstBlock, int lastBlock));
extern void Fscache_Empty _ARGS_((int *numLockedBlocksPtr));
extern void Fscache_CheckFragmentation _ARGS_((int *numBlocksPtr, 
			int *totalBytesWastedPtr, int *fragBytesWastedPtr));

extern ReturnStatus Fscache_CheckVersion _ARGS_((
			Fscache_FileInfo *cacheInfoPtr, int version, 
			int clientID));
extern ReturnStatus Fscache_Consist _ARGS_((
			Fscache_FileInfo *cacheInfoPtr, int flags, 
			Fscache_Attributes *cachedAttrPtr));

extern void Fscache_SetMinSize _ARGS_((int minBlocks));
extern void Fscache_SetMaxSize _ARGS_((int maxBlocks));
extern void Fscache_BlocksUnneeded _ARGS_((Fs_Stream *streamPtr,
				int offset, int numBytes, Boolean objectFile));
extern void Fscache_DumpStats _ARGS_((ClientData dummy));
extern void Fscache_GetPageFromFS _ARGS_((time_t timeLastAccessed, 
				int *pageNumPtr));

extern void Fscache_FileInfoInit _ARGS_((Fscache_FileInfo *cacheInfoPtr,
		Fs_HandleHeader *hdrPtr, int version, Boolean cacheable,
		Fscache_Attributes *attrPtr, Fscache_Backend *backendPtr));
extern void Fscache_InfoSyncLockCleanup _ARGS_((Fscache_FileInfo *cacheInfoPtr));
extern Fscache_Backend *Fscache_RegisterBackend _ARGS_((
		Fscache_BackendRoutines *ioProcsPtr, ClientData clientData, 
		int flags));
extern void Fscache_UnregisterBackend _ARGS_((Fscache_Backend *backendPtr));

extern void Fscache_FetchBlock _ARGS_((Fscache_FileInfo *cacheInfoPtr, 
		int blockNum, int flags, Fscache_Block **blockPtrPtr, 
		Boolean *foundPtr));
extern void Fscache_IODone _ARGS_((Fscache_Block *blockPtr));
extern void Fscache_UnlockBlock _ARGS_((Fscache_Block *blockPtr, 
		time_t timeDirtied, int diskBlock, int blockSize, 
		int flags));
extern void Fscache_BlockTrunc _ARGS_((Fscache_FileInfo *cacheInfoPtr, 
		int blockNum, int newBlockSize));

extern void Fscache_Init _ARGS_((int blockHashSize));
extern void Fscache_ZeroStats _ARGS_((void));
extern int Fscache_PreventWriteBacks _ARGS_((Fscache_FileInfo *cacheInfoPtr));
extern void Fscache_AllowWriteBacks _ARGS_((Fscache_FileInfo *cacheInfoPtr));
extern Fscache_FileInfo *Fscache_GetDirtyFile _ARGS_((
			Fscache_Backend *backendPtr, Boolean fsyncOnly, 
			Boolean (*fileMatchProc)(), ClientData clientData));
extern void Fscache_ReturnDirtyFile _ARGS_((Fscache_FileInfo *cacheInfoPtr,
		Boolean onFront));
extern Fscache_Block *Fscache_GetDirtyBlock _ARGS_((
		Fscache_FileInfo *cacheInfoPtr, 
		Boolean (*blockMatchProc)(Fscache_Block *blockPtr, 
					  ClientData clientData), 
		ClientData clientData, int *lastDirtyBlockPtr));
extern void Fscache_ReturnDirtyBlock _ARGS_((Fscache_Block *blockPtr,
			ReturnStatus status));
extern ReturnStatus Fscache_PutFileOnDirtyList _ARGS_((
			Fscache_FileInfo *cacheInfoPtr, int flags));
extern ReturnStatus Fscache_RemoveFileFromDirtyList _ARGS_((
			Fscache_FileInfo *cacheInfoPtr));

/*
 * Cache operations.  There are I/O operations, plus routines to deal
 * with the cached I/O attributes like access time, modify time, and size.
 */

extern ReturnStatus Fscache_Read _ARGS_((Fscache_FileInfo *cacheInfoPtr,
		int flags, register Address buffer, int offset, int *lenPtr,
		Sync_RemoteWaiter *remoteWaitPtr));
extern ReturnStatus Fscache_Write _ARGS_((Fscache_FileInfo *cacheInfoPtr, 
		int flags,  Address buffer, int offset, int *lenPtr, 
		Sync_RemoteWaiter *remoteWaitPtr));
extern ReturnStatus Fscache_BlockRead _ARGS_((Fscache_FileInfo *cacheInfoPtr,
		int blockNum, Fscache_Block **blockPtrPtr, int *numBytesPtr, 
		int blockType, Boolean allocate));
extern ReturnStatus Fscache_Trunc _ARGS_((Fscache_FileInfo *cacheInfoPtr, 
					int length, int flags));


extern Boolean Fscache_UpdateFile _ARGS_((Fscache_FileInfo *cacheInfoPtr, 
		Boolean openForWriting, int version, Boolean cacheable, 
		Fscache_Attributes *attrPtr));
extern void Fscache_UpdateAttrFromClient _ARGS_((int clientID, 
		Fscache_FileInfo *cacheInfoPtr,  Fscache_Attributes *attrPtr));
extern void Fscache_UpdateDirSize _ARGS_((Fscache_FileInfo *cacheInfoPtr, 
		int newLastByte));
extern void Fscache_UpdateAttrFromCache _ARGS_((Fscache_FileInfo *cacheInfoPtr,
		Fs_Attributes *attrPtr));
extern void Fscache_GetCachedAttr _ARGS_((Fscache_FileInfo *cacheInfoPtr, 
		int *versionPtr, Fscache_Attributes *attrPtr));
extern void Fscache_UpdateCachedAttr _ARGS_((Fscache_FileInfo *cacheInfoPtr,
		Fs_Attributes *attrPtr, int flags));


extern Boolean Fscache_OkToScavenge _ARGS_((Fscache_FileInfo *cacheInfoPtr));
extern Boolean Fscache_OkToScavengeExceptDirty _ARGS_((Fscache_FileInfo
	*cacheInfoPtr));


extern int Fscache_ReserveBlocks _ARGS_((Fscache_Backend *backendPtr, 
			int numResBlocks, int numNonResBlocks));

extern void Fscache_ReleaseReserveBlocks _ARGS_((Fscache_Backend *backendPtr,
			int numBlocks));

/*
 * Read ahead routines.
 */

extern void Fscache_ReadAheadInit _ARGS_((Fscache_ReadAheadInfo *readAheadPtr));
extern void Fscache_ReadAheadSyncLockCleanup _ARGS_((
			Fscache_ReadAheadInfo *readAheadPtr));
extern void FscacheReadAhead _ARGS_((Fscache_FileInfo *cacheInfoPtr, 
				int blockNum));

extern void Fscache_WaitForReadAhead _ARGS_((
			Fscache_ReadAheadInfo *readAheadPtr));
extern void Fscache_AllowReadAhead _ARGS_((Fscache_ReadAheadInfo *readAheadPtr));

extern void FscacheReadAhead _ARGS_((Fscache_FileInfo *cacheInfoPtr,
			int blockNum));


extern void FscacheBackendIdle _ARGS_((Fscache_Backend *backendPtr));
extern void FscacheFinishRealloc _ARGS_((Fscache_Block *blockPtr, 
			int diskBlock));

extern void Fscache_CountBlocks _ARGS_((int serverID, int majorNumber,
			int *numBlocksPtr, int *numDirtyBlocksPtr));

#endif /* _FSCACHE */

@


9.18
log
@Lint.  Add Fscache_ZeroStats.
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/Cvsroot/kernel/fscache/fscache.h,v 9.17 92/03/06 11:54:06 mgbaker Exp $ SPRITE (Berkeley)
d500 2
@


9.17
log
@Added temporary measurements for ASPLOS paper.
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/Cvsroot/kernel/fscache/fscache.h,v 9.16 91/09/06 15:41:20 mgbaker Exp $ SPRITE (Berkeley)
d80 1
a80 1
    int		   oldestDirtyBlockTime;
d446 1
@


9.16
log
@Added back needed FSCACHE_IS_DIR flag.
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fscache/RCS/fscache.h,v 9.15 91/09/06 15:34:22 rab Exp Locker: mgbaker $ SPRITE (Berkeley)
d322 3
a324 1
    ReturnStatus (*startWriteBack) _ARGS_((struct Fscache_Backend *backendPtr));
@


9.15
log
@Removed tracing.
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fscache/RCS/fscache.h,v 9.14 91/08/22 12:47:32 mendel Exp Locker: rab $ SPRITE (Berkeley)
d110 2
d128 1
a128 1
/* There's space for a new flag in here. */
@


9.14
log
@Increased the number of cleaner processes from 3 to 6 to handle the
heavier uses of Proc_Server.
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fscache/RCS/fscache.h,v 9.13 91/03/30 17:08:16 mgbaker Exp Locker: mendel $ SPRITE (Berkeley)
a109 3
#ifdef SOSP91
 *   FSCACHE_IS_DIR		File not cacheable because it's a directory.
#endif SOSP91
a126 3
#ifdef SOSP91
#define	FSCACHE_IS_DIR			0x1000
#endif /* SOSP91 */
a130 57
#ifdef SOSP91
/*
 * The counters of why bytes leave the cache.
 */
#define	FSCACHE_REASON_FLAGS	    0xFFF00000	
#define	FSCACHE_CONSIST_WB	    0x00100000
#define	FSCACHE_CONSIST_WBINV	    0x00200000
#define	FSCACHE_SYNC	    	    0x00400000
#define	FSCACHE_REOPEN	    	    0x00800000
#define	FSCACHE_DETACH	    	    0x01000000
#define	FSCACHE_DESC	    	    0x02000000
#define	FSCACHE_TIME	    	    0x04000000
#define	FSCACHE_SPACE	    	    0x08000000
#define	FSCACHE_VM		    0x10000000
#define	FSCACHE_SHRINK		    0x20000000
#define	FSCACHE_LRU		    0x40000000

typedef struct Fscache_ExtraStats {
    unsigned int	consistWB;
    unsigned int	cwbDLife;
    unsigned int	consistWBInv;
    unsigned int	cwbiDLife;
    unsigned int	sync;
    unsigned int	syncDLife;
    unsigned int	reopen;
    unsigned int	reDLife;
    unsigned int	detach;
    unsigned int	detDLife;
    unsigned int	desc;
    unsigned int	descDLife;
    unsigned int	time;
    unsigned int	timeDLife;
    unsigned int	space;
    unsigned int	spaceDLife;
    unsigned int	vm;
    unsigned int	vmDLife;
    unsigned int	shrink;
    unsigned int	shrinkDLife;
    unsigned int	lru;
    unsigned int	lruDLife;
    unsigned int	unknown;
    unsigned int	unDLife;
    unsigned int	cleanVm;
    unsigned int	cVmLife;
    unsigned int	unRcleanVm;
    unsigned int	cleanShrink;
    unsigned int	cShrinkLife;
    unsigned int	unRcleanShrink;
    unsigned int	cleanLru;
    unsigned int	cLruLife;
    unsigned int	unRcleanLru;
} Fscache_ExtraStats;

extern	Fscache_ExtraStats	fscache_ExtraStats;

#endif SOSP91

a227 7
#ifdef SOSP91
#define	FSCACHE_BLOCK_REASON	              0xFF000000
#define	FSCACHE_BLOCK_LRU	              0x01000000
#define	FSCACHE_BLOCK_VM	              0x02000000
#define	FSCACHE_BLOCK_SHRINK	              0x04000000
#endif SOSP91

a386 1
extern Boolean	fscache_RATracing;
a395 4
#ifdef SOSP91
extern void Fscache_AddBlockToStats _ARGS_((Fscache_FileInfo *cacheInfoPtr, Fscache_Block *blockPtr));
extern void Fscache_AddCleanStats _ARGS_((unsigned int flags, Fscache_Block *blockPtr));
#endif SOSP91
@


9.14.1.1
log
@Initial branch for Sprite server.
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fscache/RCS/fscache.h,v 9.14 91/08/22 12:47:32 mendel Exp $ SPRITE (Berkeley)
@


9.13
log
@Got rid of FS_CONSUME flag.
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fscache/RCS/fscache.h,v 9.12 91/03/09 17:33:48 kupfer Exp Locker: mgbaker $ SPRITE (Berkeley)
d454 1
a454 1
#define FSCACHE_MAX_CLEANER_PROCS	3
@


9.12
log
@Times are signed.  Use "time_t" instead of "int" in a few places.
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fscache/RCS/fscache.h,v 9.11 91/01/26 15:32:58 mgbaker Exp Locker: kupfer $ SPRITE (Berkeley)
d105 2
a106 1
 *   FSCACHE_LARGE_FILE_MODE		This file is large enough such that we limit it
d110 3
d130 3
@


9.11
log
@Sosp stuff.
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fscache/RCS/fscache.h,v 9.10 90/10/10 16:37:29 kupfer Exp Locker: mgbaker $ SPRITE (Berkeley)
d24 1
d204 1
a204 1
    unsigned int timeDirtied;	/* Time in seconds that block was
d206 1
a206 1
    unsigned int timeReferenced;/* Time in seconds that this block was
d487 1
a487 1
extern void Fscache_GetPageFromFS _ARGS_((int timeLastAccessed, 
d504 1
a504 1
		unsigned int timeDirtied, int diskBlock, int blockSize, 
@


9.10
log
@Fscache_DumpStats should take a ClientData.
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fscache/RCS/fscache.h,v 9.9 90/10/08 16:18:01 mendel Exp Locker: kupfer $ SPRITE (Berkeley)
a107 2
 *   FSCACHE_WB_ON_LDB		Force this file to be written back to disk
 *				on the last dirty block.
d124 1
a124 1
#define	FSCACHE_WB_ON_LDB		0x1000
d129 57
d283 6
d459 4
@


9.9
log
@Major changes:
Changed file names to start with "fscache".
Added new cache backend interface. 
Added function prototypes and new include format.
Removed old traceing code.
Added locking/unlocking of cache blocks.
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fs.mendel/RCS/fscache.h,v 1.1 90/01/16 17:12:01 mendel Exp Locker: mendel $ SPRITE (Berkeley)
d420 1
a420 1
extern void Fscache_DumpStats _ARGS_((void));
@


9.8
log
@Added FSCACHE_WRITE_TO_DISK flag to force information to disk.
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fscache.ken/RCS/fscache.h,v 1.2 90/05/15 14:37:01 shirriff Exp $ SPRITE (Berkeley)
d21 3
a23 3
#include "sync.h"
#include "list.h"
#include "fs.h" /* For Handle declarations. */
d49 1
a49 34

/*
 * Block cache IO operation routines. 
 */
typedef struct Fscache_IOProcs {
    /*
     *	FooAllocate(hdrPtr, offset, bytes, flags, blockAddrPtr, newBlockPtr)
     *		Fs_HandleHeader *hdrPtr;			(File handle)
     *		int		offset;			(Byte offset)
     *		int		bytes;			(Bytes to allocate)
     *		int		flags;			(FSCACHE_DONT_BLOCK)
     *		int		*blockAddrPtr;		(Returned block number)
     *		Boolean		*newBlockPtr;		(TRUE if new block)
     *	FooBlockRead(hdrPtr, flags, buffer, offsetPtr, lenPtr, waitPtr)
     *		Fs_HandleHeader *hdrPtr;			(File handle)
     *		int		flags;		(For compatibility with .read)
     *		Address		buffer;			(Target of read)
     *		int		*offsetPtr;		(Byte offset)
     *		int		*lenPtr;		(Byte count)
     *		Sync_RemoteWaiter *waitPtr;		(For remote waiting)
     *	FooBlockWrite(hdrPtr, blockPtr, lastDirtyBlock)
     *		Fs_HandleHeader	*hdrPtr;		(File handle)
     *		Fscache_Block	*blockPtr;		(Cache block to write)
     *		Boolean		lastDirtyBlock;		(Indicates last block)
     *	FooBlockCopy(srcHdrPtr, dstHdrPtr, blockNumber)
     *		Fs_HandleHeader	*srcHdrPtr;		(Source file handle)
     *		Fs_HandleHeader	*dstHdrPtr;		(Destination handle)
     *		int		blockNumber;		(Block to copy)
     */
    ReturnStatus (*allocate)();
    ReturnStatus (*blockRead)();
    ReturnStatus (*blockWrite)();
    ReturnStatus (*blockCopy)();
} Fscache_IOProcs;
d79 1
d81 2
a82 1
    Fscache_IOProcs   *ioProcsPtr;  /* Routines for read/write/allocate/copy. */
d112 1
d128 3
d137 6
a142 1
    List_Links	cacheLinks;	/* Links to put block into list of unused 
d144 1
a144 3
				   THIS MUST BE FIRST in the struct. */
    List_Links	dirtyLinks;	/* Links to put block into list of dirty
				 * blocks for the file.  THIS MUST BE 2ND */
d196 1
d204 1
d226 3
d250 1
d256 1
d276 1
a276 2
 *	FSCACHE_TRUNC_CONSUME	Truncate a la named pipes, consuming from front
 *	FSCACHE_TRUNC_DELETE		Truncate because the file is deleted.  This
d280 57
a336 2
#define FSCACHE_TRUNC_CONSUME	0x1
#define FSCACHE_TRUNC_DELETE		0x2
d338 1
d354 1
d386 1
a387 1

d398 64
a461 25
extern  void            Fscache_WriteBack();
extern  ReturnStatus    Fscache_FileWriteBack();
extern  void            Fscache_FileInvalidate();
extern  void            Fscache_Empty();
extern  void            Fscache_CheckFragmentation();

extern  ReturnStatus	Fscache_CheckVersion();
extern  ReturnStatus    Fscache_Consist();

extern	void		Fscache_SetMaxSize();
extern	void		Fscache_SetMinSize();
extern	void		Fscache_BlocksUnneeded();
extern	void		Fscache_DumpStats();
extern  void		Fscache_GetPageFromFS();

extern  void            Fscache_InfoInit();
extern  void            Fscache_InfoSyncLockCleanup();
extern  void            Fscache_FetchBlock();
extern  void            Fscache_UnlockBlock();
extern  void            Fscache_BlockTrunc();
extern  void            Fscache_IODone();
extern  void            Fscache_CleanBlocks();
extern  void            Fscache_Init();
extern  int             Fscache_PreventWriteBacks();
extern  void            Fscache_AllowWriteBacks();
d468 33
a500 4
extern void             Fscache_Trunc();
extern ReturnStatus     Fscache_Read();
extern ReturnStatus     Fscache_Write();
extern ReturnStatus     Fscache_BlockRead();
d502 2
a503 6
extern Boolean          Fscache_UpdateFile();
extern void             Fscache_UpdateAttrFromClient();
extern void             Fscache_UpdateAttrFromCache();
extern void             Fscache_UpdateCachedAttr();
extern void             Fscache_UpdateDirSize();
extern void             Fscache_GetCachedAttr();
a504 3
extern Boolean		Fscache_AllBlocksInCache();
extern Boolean		Fscache_OkToScavenge();

d508 18
a525 4
extern void		Fscache_ReadAheadInit();
extern void		Fscache_ReadAheadSyncLockCleanup();
extern void		Fscache_WaitForReadAhead();
extern void		Fscache_AllowReadAhead();
d527 2
a528 1
extern void		FscacheReadAhead();
@


9.7
log
@added FSCACHE_WB_MIGRATION flag.
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fd.fscache/RCS/fscache.h,v 9.6 90/02/15 09:25:43 brent Exp Locker: douglis $ SPRITE (Berkeley)
d132 1
a132 1
 *   FSCACHE_FILE_IS_WRITE_THRU	(unused?) Means that there is no delayed write.
d144 1
a144 1
#define	FSCACHE_CLOSE_IN_PROGRESS		0x0001
d150 4
a153 4
#define FSCACHE_FILE_BEING_WRITTEN		0x0040
#define	FSCACHE_FILE_ON_DIRTY_LIST		0x0080
#define FSCACHE_FILE_IS_WRITE_THRU		0x0100
#define FSCACHE_FILE_NOT_CACHEABLE		0x0200
d155 1
a155 1
#define FSCACHE_FILE_GONE			0x0800
@


9.6
log
@Added FSCACHE_MAX_CLEANER_PROCS
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fscache/RCS/fscache.h,v 9.5 89/12/11 17:39:49 brent Exp Locker: brent $ SPRITE (Berkeley)
d267 2
d273 1
@


9.5
log
@Changed interface to block I/O routines
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fscache/RCS/fscache.h,v 9.4 89/11/07 10:39:50 shirriff Exp $ SPRITE (Berkeley)
d338 6
a343 1
/* Data. */
d345 1
@


9.4
log
@Fixed typos and formatting of the comments
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fscache/RCS/fscache.h,v 9.3 89/10/26 18:46:12 brent Exp $ SPRITE (Berkeley)
d69 1
a69 1
     *	FooBlockWrite(hdrPtr, blockNumber, numBytes, buffer, lastDirtyBlock)
d71 1
a71 3
     *		int		blockNumber;		(Disk block number)
     *		int		numBytes;		(Byte count in block)
     *		Address		buffer;			(Source of data)
d224 1
a224 1
 *					data area for a pipe.
@


9.3
log
@Added FSCACHE_ALLOC_FAILED, which is used to control print statements.
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fscache/RCS/fscache.h,v 9.2 89/10/23 12:31:50 brent Exp $ SPRITE (Berkeley)
d195 1
a195 1
 *   FSCACHE_BLOCK_FREE		The block is not being used.
d197 2
a198 2
 *   FSCACHE_BLOCK_BEING_WRITTEN	The block is in the process of being written to
 *				disk.
d200 6
a205 5
 *   FSCACHE_BLOCK_DELETED		This block has been deleted.  This flag is set
 *				when a block is to be invalidated after it has
 *				been cleaned.
 *   FSCACHE_MOVE_TO_FRONT		After this block has finished being cleaned
 *				move it to the front of the LRU list.
d207 4
a210 4
 *				FsCacheWriteBack which is waiting for all 
 *				such blocks to be written out.
 *   FSCACHE_BLOCK_WRITE_LOCKED	This block is being modified.
 *   FSCACHE_BLOCK_NEW		This block was just created.
d212 9
a220 9
 *				block to become unlocked in order to write
 *				it out.
 *   FSCACHE_NOT_MAPPED		This cache block does not have physical memory 
 *				behind it.
 *   FSCACHE_IND_BLOCK		This block is an indirect block.
 *   FSCACHE_DESC_BLOCK	This block is a file descriptor block.
 *   FSCACHE_DIR_BLOCK		This is a directory block.
 *   FSCACHE_DATA_BLOCK	This is a data block.
 *   FSCACHE_READ_AHEAD_BLOCK	This block was read ahead.
d222 7
a228 7
 *   FSCACHE_DONT_BLOCK	Don't block if the cache block is already
 *				locked.	
 *   FSCACHE_PIPE_BLOCK		This is a block that is permanently locked
 *				so that it can serve as the data area for
 *				a pipe.
 *   FSCACHE_WRITE_THRU_BLOCK	This block is being written through by the
 *				caller to Fscache_UnlockBlock.
@


9.2
log
@Added externs
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fscache/RCS/fscache.h,v 9.1 89/09/18 13:50:11 brent Exp Locker: brent $ SPRITE (Berkeley)
d143 2
d159 1
@


9.1
log
@Updated comments
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fscache/RCS/fscache.h,v 8.4 89/08/21 15:24:28 mendel Exp $ SPRITE (Berkeley)
d337 4
a340 3
extern int fscache_MaxBlockCleaners;
extern Boolean fscache_RATracing;
extern int fscache_NumReadAheadBlocks;
d391 1
d399 4
@


9.0
log
@Changing version numbers.
@
text
@d15 1
a15 1
 * $Header: /sprite/src/kernel/fscache/RCS/fscache.h,v 8.4 89/08/21 15:24:28 mendel Exp Locker: douglis $ SPRITE (Berkeley)
d55 1
a55 1
     *	FooAllocate(hdrPtr, offset, bytes, blockAddrPtr, newBlockPtr)
d59 1
d230 3
a232 3
#define	FSCACHE_BLOCK_DELETED		0x000010
#define	FSCACHE_MOVE_TO_FRONT		0x000020
#define	FSCACHE_WRITE_BACK_WAIT		0x000040
d235 1
a235 1
#define	FSCACHE_BLOCK_CLEANER_WAITING	0x000400
d237 4
a240 4
#define	FSCACHE_IND_BLOCK		0x001000
#define	FSCACHE_DESC_BLOCK		0x002000
#define	FSCACHE_DIR_BLOCK		0x004000
#define	FSCACHE_DATA_BLOCK		0x008000
d242 2
a243 2
#define	FSCACHE_IO_IN_PROGRESS		0x020000
#define FSCACHE_DONT_BLOCK		0x040000
d340 1
@


8.4
log
@Break up fs into many modules.
@
text
@d15 1
a15 1
 * $Header: /sprite/lib/forms/RCS/proto.h,v 1.2 89/01/07 04:12:44 rab Exp $ SPRITE (Berkeley)
@


8.3
log
@Commented #endif labels.
@
text
@d2 1
a2 1
 * fsBlockCache.h --
d4 1
a4 1
 *	Declarations for the file systems block cache.
d6 10
a15 5
 * Copyright 1986 Regents of the University of California
 * All rights reserved.
 *
 *
 * $Header: /sprite/src/kernel/fs/RCS/fsBlockCache.h,v 8.2 89/06/09 11:23:47 brent Exp Locker: rab $ SPRITE (Berkeley)
d18 2
a19 2
#ifndef _FSBLOCKCACHE
#define _FSBLOCKCACHE
d23 1
a23 1
#include "fs.h"
d25 62
d88 28
a115 6
 * Minimum number of cache blocks required.  The theoretical limit
 * is about 3, enough for indirect blocks and data blocks, but
 * that is a bit extreme.  The maximum number of cache blocks is
 * a function of the physical memory size and is computed at boot time.
 */
#define FS_MIN_CACHE_BLOCKS	32
d118 1
a118 1
 * Values for flags field in the FsCacheFileInfo struct defined in fsInt.h
d120 1
a120 1
 *   FS_CLOSE_IN_PROGRESS	There is a close being done on this file so
d122 2
a123 2
 *   FS_CACHE_SERVER_DOWN	The host that this file belongs is down.
 *   FS_CACHE_NO_DISK_SPACE	The domain that this file lives in has no
d125 2
a126 2
 *   FS_CACHE_DOMAIN_DOWN	The domain to write to is not available.
 *   FS_CACHE_GENERIC_ERROR	An error occured for which we just hang onto
d128 1
a128 1
 *   FS_CACHE_SYNC_DONE		The server has been told to force all blocks
d130 1
a130 1
 *   FS_FILE_BEING_WRITTEN	There already is a block cleaner working on
d132 3
a134 3
 *   FS_FILE_ON_DIRTY_LIST	This file is on the dirty list.
 *   FS_FILE_IS_WRITE_THRU	(unused?) Means that there is no delayed write.
 *   FS_FILE_NOT_CACHEABLE	This is set when files served by remote hosts
d136 1
a136 1
 *   FS_LARGE_FILE_MODE		This file is large enough such that we limit it
d138 1
a138 1
 *   FS_FILE_GONE		The file has been removed and any delayed
d140 1
a140 1
 *   FS_CACHE_WB_ON_LDB		Force this file to be written back to disk
d143 13
a155 14
#define	FS_CLOSE_IN_PROGRESS		0x0001
#define	FS_CACHE_SERVER_DOWN		0x0002
#define	FS_CACHE_NO_DISK_SPACE		0x0004
#define FS_CACHE_DOMAIN_DOWN		0x0008
#define FS_CACHE_GENERIC_ERROR		0x0010
#define	FS_CACHE_SYNC_DONE		0x0020
#define FS_FILE_BEING_WRITTEN		0x0040
#define	FS_FILE_ON_DIRTY_LIST		0x0080
#define FS_FILE_IS_WRITE_THRU		0x0100
#define FS_FILE_NOT_CACHEABLE		0x0200
#define	FS_LARGE_FILE_MODE		0x0400
#define FS_FILE_GONE			0x0800
#define	FS_CACHE_WB_ON_LDB		0x1000

d158 1
a158 1
 * Structure to represent a cache block in the fileservers cache block
d161 2
a162 3

typedef struct FsCacheBlock {
    List_Links	cacheLinks;	/* Links to put block into list of unused
d176 1
a176 1
    FsCacheFileInfo *cacheInfoPtr;	/* Reference to file's cache info. */
d179 1
a179 1
    int		diskBlock;	/* The block number on disk for this block.
d186 1
a186 1
} FsCacheBlock;
d188 6
a193 14
/*
 * Macros to get from the dirtyLinks of a cache block to the cache block itself.
 */
#define DIRTY_LINKS_TO_BLOCK(ptr) \
		((FsCacheBlock *) ((int) (ptr) - sizeof(List_Links)))

#define FILE_LINKS_TO_BLOCK(ptr) \
		((FsCacheBlock *) ((int) (ptr) - 2 * sizeof(List_Links)))
/*
 * Flags for a FsCacheBlock:
 *
 *   FS_BLOCK_FREE		The block is not being used.
 *   FS_BLOCK_ON_DIRTY_LIST	The block is on the dirty list.
 *   FS_BLOCK_BEING_WRITTEN	The block is in the process of being written to
d195 2
a196 2
 *   FS_BLOCK_DIRTY		The block contains dirty data.
 *   FS_BLOCK_DELETED		This block has been deleted.  This flag is set
d199 1
a199 1
 *   FS_MOVE_TO_FRONT		After this block has finished being cleaned
d201 2
a202 2
 *   FS_WRITE_BACK_WAIT		This block is being written out by
 *				FsCacheWriteBack which is waiting for all
d204 3
a206 3
 *   FS_BLOCK_WRITE_LOCKED	This block is being modified.
 *   FS_BLOCK_NEW		This block was just created.
 *   FS_BLOCK_CLEANER_WAITING	The block cleaner is waiting for this
d209 1
a209 1
 *   FS_NOT_MAPPED		This cache block does not have physical memory
d211 9
a219 9
 *   FS_IND_CACHE_BLOCK		This block is an indirect block.
 *   FS_DESC_CACHE_BLOCK	This block is a file descriptor block.
 *   FS_DIR_CACHE_BLOCK		This is a directory block.
 *   FS_DATA_CACHE_BLOCK	This is a data block.
 *   FS_READ_AHEAD_BLOCK	This block was read ahead.
 *   FS_IO_IN_PROGRESS		IO is in progress on this block.
 *   FS_CACHE_DONT_BLOCK	Don't block if the cache block is already
 *				locked.
 *   FS_PIPE_BLOCK		This is a block that is permanently locked
d222 2
a223 2
 *   FS_WRITE_THRU_BLOCK	This block is being written through by the
 *				caller to FsCacheUnlockBlock.
d225 24
a248 24
#define	FS_BLOCK_FREE			0x000001
#define	FS_BLOCK_ON_DIRTY_LIST		0x000002
#define	FS_BLOCK_BEING_WRITTEN		0x000004
#define	FS_BLOCK_DIRTY			0x000008
#define	FS_BLOCK_DELETED		0x000010
#define	FS_MOVE_TO_FRONT		0x000020
#define	FS_WRITE_BACK_WAIT		0x000040
#define	FS_BLOCK_WRITE_LOCKED		0x000100
#define	FS_BLOCK_NEW			0x000200
#define	FS_BLOCK_CLEANER_WAITING	0x000400
#define	FS_NOT_MAPPED			0x000800
#define	FS_IND_CACHE_BLOCK		0x001000
#define	FS_DESC_CACHE_BLOCK		0x002000
#define	FS_DIR_CACHE_BLOCK		0x004000
#define	FS_DATA_CACHE_BLOCK		0x008000
#define	FS_READ_AHEAD_BLOCK		0x010000
#define	FS_IO_IN_PROGRESS		0x020000
#define FS_CACHE_DONT_BLOCK		0x040000
#define FS_PIPE_BLOCK			0x080000
#define	FS_WRITE_THRU_BLOCK		0x100000

/*
 * Macro to get the block address field of the FsCacheBlock struct.
 */
d250 1
a250 1
#define	FsCacheBlockAddress(cacheBlockPtr) ((cacheBlockPtr)->blockAddr)
d253 1
a253 1
 * Constant to pass to FsCacheFileWriteBack, which takes block numbers as
d256 1
a256 1
#define FS_LAST_BLOCK	-1
d259 1
a259 1
 * Constants to pass as flags to FsCacheFileWriteBack.
d261 7
a267 7
 *    FS_FILE_WB_WAIT		Wait for blocks to be written back.
 *    FS_FILE_WB_INDIRECT	Write back indirect blocks.
 *    FS_FILE_WB_INVALIDATE	Invalidate after writing back.
 */
#define FS_FILE_WB_WAIT		0x1
#define	FS_FILE_WB_INDIRECT	0x2
#define	FS_FILE_WB_INVALIDATE	0x4
d272 3
a274 3
 *    FS_DELETE_BLOCK	    The block should be deleted when it is unlocked.
 *    FS_CLEAR_READ_AHEAD   Clear the read ahead flag from the block.
 *    FS_BLOCK_UNNEEDED     This block is not needed anymore.  Throw it away
d276 1
a276 1
 *    FS_DONT_WRITE_THRU    Don't write this block through to disk.
d280 115
a394 4
#define	FS_DELETE_BLOCK			0x0001
#define	FS_CLEAR_READ_AHEAD		0x0002
#define FS_BLOCK_UNNEEDED		0x0004
#define	FS_DONT_WRITE_THRU		0x0008
d396 1
a396 35
/*
 * Global cache variables.
 */
extern	int	fsCacheDebug;		/* Debug flag */
extern	int	fsNumCacheBlocks;	/* Number of blocks in the cache */
extern	Boolean	fsLargeFileMode;	/* TRUE => are in mode where large
					 * files cannot occupy too large a
					 * portion of the cache. */
extern	int	fsMaxFilePortion;	/* Number to divide maximum number of
					 * cache blocks by determine size of
					 * file that puts it into large file
					 * mode. */
extern	int	fsMaxFileSize;		/* Maximum size of a file before
					 * changing to large file mode. */
/*
 * Cache routines.
 */
extern	void		Fs_CacheWriteBack();
extern	ReturnStatus	FsCacheFileWriteBack();
extern	void		FsCacheFileInvalidate();
extern	void		Fs_CacheEmpty();
extern	void		Fs_CheckFragmentation();
extern	void		Fs_BlockCleaner();

extern	void		FsCacheInfoInit();
extern	void		FsCacheInfoSyncLockCleanup();
extern	void		FsCacheFetchBlock();
extern	void		FsCacheUnlockBlock();
extern	void		FsCacheBlockTrunc();
extern	void		FsCacheIODone();
extern	void		FsCacheBlocksUnneeded();
extern	void		FsCleanBlocks();
extern	void		FsBlockCacheInit();
extern	int		FsPreventWriteBacks();
extern	void		FsAllowWriteBacks();
a397 1
#endif /* _FSBLOCKCACHE */
@


8.2
log
@Added FS_MIN_CACHE_BLOCKS
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fs/RCS/fsBlockCache.h,v 8.1 89/02/09 08:38:17 brent Exp Locker: brent $ SPRITE (Berkeley)
d70 1
a70 1
 * Structure to represent a cache block in the fileservers cache block 
d75 1
a75 1
    List_Links	cacheLinks;	/* Links to put block into list of unused 
d92 1
a92 1
    int		diskBlock;	/* The block number on disk for this block. 
d109 3
a111 3
/* 
 * Flags for a FsCacheBlock: 
 * 
d122 2
a123 2
 *   FS_WRITE_BACK_WAIT		This block is being written out by 
 *				FsCacheWriteBack which is waiting for all 
d130 1
a130 1
 *   FS_NOT_MAPPED		This cache block does not have physical memory 
d139 1
a139 1
 *				locked.	
d211 1
a211 1
extern	Boolean	fsLargeFileMode;	/* TRUE => are in mode where large 
d218 1
a218 1
extern	int	fsMaxFileSize;		/* Maximum size of a file before 
d221 1
a221 1
 * Cache routines. 
d242 1
a242 1
#endif _FSBLOCKCACHE
@


8.1
log
@Added FsCacheInfoSyncLockCleanup
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fs/RCS/fsBlockCache.h,v 8.0 88/11/11 18:17:59 douglis Stable Locker: brent $ SPRITE (Berkeley)
d19 8
@


8.0
log
@Changing version numbers.
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fs/RCS/fsBlockCache.h,v 7.0 88/11/07 14:47:05 brent Exp Locker: douglis $ SPRITE (Berkeley)
d223 1
@


7.0
log
@New version for conversion to new C library
@
text
@d10 1
a10 1
 * $Header: /sprite/src/kernel/fs/RCS/fsBlockCache.h,v 6.2 88/09/14 11:34:35 nelson Exp Locker: brent $ SPRITE (Berkeley)
@


6.2
log
@Added flag to allow cache blocks to be selectively not be written through
even though are in write-thru mode.
@
text
@d10 1
a10 1
 * $Header: fsBlockCache.h,v 6.1 88/09/07 21:19:40 nelson Exp $ SPRITE (Berkeley)
@


6.1
log
@Put alternative writing policies into the file system.
@
text
@d10 1
a10 1
 * $Header: fsBlockCache.h,v 6.0 88/08/11 12:14:46 brent Stable $ SPRITE (Berkeley)
d187 1
a187 1
 *    FS_BLOCK_UNNEEDED    This block is not needed anymore.  Throw it away
d189 1
d196 1
@


6.0
log
@Changing version numbers.
@
text
@d10 1
a10 1
 * $Header: fsBlockCache.h,v 1.5 88/08/04 14:49:08 mlgray Exp $ SPRITE (Berkeley)
d43 2
d46 13
a58 12
#define	FS_CLOSE_IN_PROGRESS		0x01
#define	FS_CACHE_SERVER_DOWN		0x02
#define	FS_CACHE_NO_DISK_SPACE		0x04
#define FS_CACHE_DOMAIN_DOWN		0x08
#define FS_CACHE_GENERIC_ERROR		0x10
#define	FS_CACHE_SYNC_DONE		0x20
#define FS_FILE_BEING_WRITTEN		0x40
#define	FS_FILE_ON_DIRTY_LIST		0x80
#define FS_FILE_IS_WRITE_THRU		0x100
#define FS_FILE_NOT_CACHEABLE		0x200
#define	FS_LARGE_FILE_MODE		0x400
#define FS_FILE_GONE			0x800
@


1.5
log
@merging changes from fs into fs.new.
@
text
@d10 1
a10 1
 * $Header: fsBlockCache.h,v 1.4 88/06/06 09:34:36 brent Exp $ SPRITE (Berkeley)
@


1.4
log
@Added the per-file list of blocks and indirect blocks
@
text
@d10 1
a10 1
 * $Header: fsBlockCache.h,v 1.3 88/06/01 16:50:54 brent Exp $ SPRITE (Berkeley)
a18 1
#include "fsInt.h"
@


1.3
log
@Moved FS_FILE_GONE flag to the block cache info struct
so the delayed write/close synchronization works right.
@
text
@d10 1
a10 1
 * $Header: fsBlockCache.h,v 1.2 88/04/11 08:25:56 brent Exp $ SPRITE (Berkeley)
d70 3
d97 2
@


1.2
log
@Added FS_BLOCK_UNNEEDED flag.
@
text
@d10 1
a10 1
 * $Header: fsBlockCache.h,v 1.1 88/04/04 10:29:25 brent Exp $ SPRITE (Berkeley)
d42 2
d56 1
d77 1
@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
 * $Header: fsBlockCache.h,v 6.0 87/12/03 11:04:46 brent Exp $ SPRITE (Berkeley)
d176 2
a177 2
 *    FS_CACHE_SCHED_WRITE_THRU	Schedule this block to be written through to
 *				disk as soon as possible.
d183 1
a183 1
#define FS_CACHE_SCHED_WRITE_THRU	0x0004
@
