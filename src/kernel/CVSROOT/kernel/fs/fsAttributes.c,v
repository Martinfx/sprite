head     9.4;
branch   ;
access   ;
symbols  ds3100:9.4 sun3:9.4 sprited:9.3.1 sun4nw:9.4 symm:9.4 spur:9.4 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.4
date     91.09.10.18.22.19;  author rab;  state Exp;
branches ;
next     9.3;

9.3
date     91.02.01.16.28.31;  author shirriff;  state Exp;
branches 9.3.1.1;
next     9.2;

9.2
date     91.01.08.16.25.21;  author shirriff;  state Exp;
branches ;
next     9.1;

9.1
date     90.10.08.10.54.05;  author mendel;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.02.43;  author douglis;  state Stable;
branches ;
next     8.7;

8.7
date     89.08.21.15.22.19;  author mendel;  state Exp;
branches ;
next     8.6;

8.6
date     89.08.04.17.58.09;  author brent;  state Exp;
branches ;
next     8.5;

8.5
date     89.06.15.09.04.43;  author brent;  state Exp;
branches ;
next     8.4;

8.4
date     89.03.17.12.49.44;  author brent;  state Exp;
branches ;
next     8.3;

8.3
date     89.01.25.09.51.02;  author brent;  state Exp;
branches ;
next     8.2;

8.2
date     89.01.24.12.22.19;  author brent;  state Exp;
branches ;
next     8.1;

8.1
date     88.12.07.08.23.23;  author brent;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.17.23;  author douglis;  state Stable;
branches ;
next     7.0;

7.0
date     88.11.11.15.28.52;  author brent;  state Exp;
branches ;
next     6.13;

6.13
date     88.10.22.15.11.22;  author brent;  state Exp;
branches ;
next     6.12;

6.12
date     88.10.14.12.13.46;  author brent;  state Exp;
branches ;
next     6.11;

6.11
date     88.10.13.09.51.08;  author brent;  state Exp;
branches ;
next     6.10;

6.10
date     88.10.05.12.07.14;  author brent;  state Exp;
branches ;
next     6.9;

6.9
date     88.09.28.08.31.03;  author brent;  state Exp;
branches ;
next     6.8;

6.8
date     88.09.23.13.33.49;  author brent;  state Exp;
branches ;
next     6.7;

6.7
date     88.09.14.12.45.35;  author brent;  state Exp;
branches ;
next     6.6;

6.6
date     88.09.07.16.51.34;  author brent;  state Exp;
branches ;
next     6.5;

6.5
date     88.09.01.17.13.36;  author brent;  state Exp;
branches ;
next     6.4;

6.4
date     88.08.31.12.03.38;  author brent;  state Exp;
branches ;
next     6.3;

6.3
date     88.08.18.17.58.50;  author brent;  state Exp;
branches ;
next     6.2;

6.2
date     88.08.16.11.23.46;  author brent;  state Exp;
branches ;
next     6.1;

6.1
date     88.08.13.11.27.03;  author brent;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.14.15;  author brent;  state Stable;
branches ;
next     1.12;

1.12
date     88.08.11.12.11.59;  author mlgray;  state Exp;
branches ;
next     1.11;

1.11
date     88.08.11.10.42.50;  author brent;  state Exp;
branches ;
next     1.10;

1.10
date     88.08.05.14.13.48;  author douglis;  state Exp;
branches ;
next     1.9;

1.9
date     88.08.04.15.01.27;  author mlgray;  state Exp;
branches ;
next     1.8;

1.8
date     88.08.03.17.17.48;  author mlgray;  state Exp;
branches ;
next     1.7;

1.7
date     88.06.23.14.46.17;  author mlgray;  state Exp;
branches ;
next     1.6;

1.6
date     88.06.15.11.52.22;  author brent;  state Exp;
branches ;
next     1.5;

1.5
date     88.06.08.14.56.33;  author brent;  state Exp;
branches ;
next     1.4;

1.4
date     88.06.02.11.34.13;  author brent;  state Exp;
branches ;
next     1.3;

1.3
date     88.06.01.16.53.59;  author brent;  state Exp;
branches ;
next     1.2;

1.2
date     88.04.11.17.39.52;  author brent;  state Exp;
branches ;
next     1.1;

1.1
date     88.04.04.10.28.52;  author brent;  state Exp;
branches ;
next     ;

9.3.1.1
date     91.11.15.13.25.13;  author kupfer;  state Exp;
branches ;
next     ;


desc
@File attributes getting/setting
@


9.4
log
@Fixed lint errors and removed tracing.
@
text
@/*
 * fsAttributes.c --
 *
 *	This has procedures for operations done on file attributes.
 *	The general strategy when getting attributes is to make one call to
 *	the name server to get an initial version of the attributes, and
 *	then make another call to the I/O server to update things like
 *	the access time and modify time.  There are two ways to get to
 *	the name server, either via a pathname or an open file.  The
 *	I/O server is always contacted using a fileID.
 *
 * Copyright 1987 Regents of the University of California
 * All rights reserved.
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsAttributes.c,v 9.3 91/02/01 16:28:31 shirriff Exp Locker: rab $ SPRITE (Berkeley)";
#endif not lint


#include <sprite.h>
#include <fs.h>
#include <fsutil.h>
#include <fsNameOps.h>
#include <fslcl.h>
#include <fsconsist.h>
#include <fscache.h>
#include <fsdm.h>
#include <fsStat.h>
#include <rpc.h>

#include <stdio.h>


/*
 *----------------------------------------------------------------------
 *
 * Fs_GetAttrStream --
 *
 *	Get the attributes of an open file.  The name server for the
 *	file (if any, anonymous pipes won't have one) is contacted
 *	to get the initial version of the attributes.  This includes
 *	ownership, permissions, and a guess as to the size.  Then
 *	a stream-specific call is made to update the attributes
 *	from info at the I/O server.  For example, there may be
 *	more up-to-date access and modify times at the I/O server.
 *
 * Results:
 *	An error code and the attibutes.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Fs_GetAttrStream(streamPtr, attrPtr)
    Fs_Stream *streamPtr;
    Fs_Attributes *attrPtr;
{
    register ReturnStatus	status;
    register Fs_HandleHeader	*hdrPtr = streamPtr->ioHandlePtr;
    register Fs_NameInfo		*nameInfoPtr = streamPtr->nameInfoPtr;

    if (!Fsutil_HandleValid(hdrPtr)) {
	status = FS_STALE_HANDLE;
    } else {
	if (nameInfoPtr == (Fs_NameInfo *)NIL) {
	    /*
	     * Anonymous pipes have no name info.
	     */
	    bzero((Address)attrPtr, sizeof(Fs_Attributes));
	    status = SUCCESS;
	} else {
	    /*
	     * Get the initial version of the attributes from the file server
	     * that has the name of the file.
	     */
	    status = (*fs_AttrOpTable[nameInfoPtr->domainType].getAttr)
			(&nameInfoPtr->fileID, rpc_SpriteID, attrPtr);
#ifdef lint
	    status = FslclGetAttr(&nameInfoPtr->fileID, rpc_SpriteID,attrPtr);
	    status = FsrmtGetAttr(&nameInfoPtr->fileID,rpc_SpriteID,attrPtr);
	    status = FspdevPseudoGetAttr(&nameInfoPtr->fileID,rpc_SpriteID,attrPtr);
#endif lint
	    if (status != SUCCESS) {
		printf(
		    "Fs_GetAttrStream: can't get name attributes <%x> for %s\n",
		    status, Fsutil_GetFileName(streamPtr));
	    }
	}
	if (status == SUCCESS) {
	    /*
	     * Update the attributes by contacting the I/O server.
	     */
	    fs_Stats.cltName.getIOAttrs++;
	    status = (*fsio_StreamOpTable[hdrPtr->fileID.type].getIOAttr)
			(&hdrPtr->fileID, rpc_SpriteID, attrPtr);
#ifdef lint
	    status = Fsrmt_GetIOAttr(&hdrPtr->fileID, rpc_SpriteID, attrPtr);
	    status = FsrmtFileGetIOAttr(&hdrPtr->fileID, rpc_SpriteID, attrPtr);
	    status = Fsio_DeviceGetIOAttr(&hdrPtr->fileID, rpc_SpriteID, attrPtr);
	    status = Fsio_PipeGetIOAttr(&hdrPtr->fileID, rpc_SpriteID, attrPtr);
	    status = FsRmtControlGetIOAttr(&hdrPtr->fileID, rpc_SpriteID,
			attrPtr);
	    status = FspdevControlGetIOAttr(&hdrPtr->fileID, rpc_SpriteID,
			attrPtr);
#endif lint
	}
	fs_Stats.cltName.getAttrIDs++;
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * Fs_SetAttrStream --
 *
 *	Set the attributes of an open file.  First the name server is
 *	contacted to verify permissions and to update the file descriptor.
 *	Then the I/O server is contacted to update any cached attributes.
 *
 * Results:
 *	An error code.
 *
 * Side effects:
 *	The modify and access times are set.
 *	The owner and group ID are set.
 *	The permission bits are set.
 * 	If the operation is successful, the count of setAttrs is incremented.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Fs_SetAttrStream(streamPtr, attrPtr, idPtr, flags)
    Fs_Stream *streamPtr;	/* References file to manipulate. */
    Fs_Attributes *attrPtr;	/* Attributes to give to the file. */
    Fs_UserIDs *idPtr;		/* Owner and groups of calling process */
    int flags;			/* Specify what attributes to set. */
{
    register ReturnStatus	status;
    register Fs_HandleHeader	*hdrPtr = streamPtr->ioHandlePtr;
    register Fs_NameInfo		*nameInfoPtr = streamPtr->nameInfoPtr;

    if (!Fsutil_HandleValid(hdrPtr)) {
	status = FS_STALE_HANDLE;
    } else {
	if (streamPtr->nameInfoPtr != (Fs_NameInfo *)NIL) {
	    /*
	     * Set the attributes at the name server.
	     */
	    status = (*fs_AttrOpTable[nameInfoPtr->domainType].setAttr)
			(&nameInfoPtr->fileID, attrPtr, idPtr, flags);
#ifdef lint
	    status = FslclSetAttr(&nameInfoPtr->fileID, attrPtr,idPtr,flags);
	    status = FsrmtSetAttr(&nameInfoPtr->fileID, attrPtr,idPtr,flags);
	    status = FspdevPseudoSetAttr(&nameInfoPtr->fileID, attrPtr,idPtr,flags);
#endif lint
	} else {
	    status = SUCCESS;
	}
	if (status == SUCCESS) {
	    /*
	     * Set the attributes at the I/O server.
	     */
	    fs_Stats.cltName.setIOAttrs++;
	    status = (*fsio_StreamOpTable[hdrPtr->fileID.type].setIOAttr)
			(&hdrPtr->fileID, attrPtr, flags);
#ifdef lint
	    status = Fsrmt_SetIOAttr(&hdrPtr->fileID, attrPtr, flags);
	    status = FsrmtFileSetIOAttr(&hdrPtr->fileID, attrPtr, flags);
	    status = Fsio_DeviceSetIOAttr(&hdrPtr->fileID, attrPtr, flags);
	    status = Fsio_PipeSetIOAttr(&hdrPtr->fileID, attrPtr, flags);
	    status = FsRmtControlSetIOAttr(&hdrPtr->fileID, attrPtr, flags);
	    status = FspdevControlSetIOAttr(&hdrPtr->fileID, attrPtr, flags);
#endif lint
	}
    fs_Stats.cltName.setAttrIDs++;
    }
    return(status);
}
@


9.3
log
@Added sprite ID to attribute tracing.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsAttributes.c,v 9.2 91/01/08 16:25:21 shirriff Exp $ SPRITE (Berkeley)";
a86 12
#ifdef SOSP91
	    int hostID, userID;
	    userID = Proc_GetEffectiveProc()->userID;
	    if (Proc_GetEffectiveProc()->genFlags & PROC_FOREIGN) {
		hostID = Proc_GetEffectiveProc()->peerHostID;
	    } else {
		hostID = rpc_SpriteID;
	    }
	    status = (*fs_AttrOpTable[nameInfoPtr->domainType].getAttr)
			(&nameInfoPtr->fileID, rpc_SpriteID, attrPtr, hostID,
			userID);
#else
a88 1
#endif
a161 12
#ifdef SOSP91
	    int hostID, userID;
	    userID = Proc_GetEffectiveProc()->userID;
	    if (Proc_GetEffectiveProc()->genFlags & PROC_FOREIGN) {
		hostID = Proc_GetEffectiveProc()->peerHostID;
	    } else {
		hostID = rpc_SpriteID;
	    }
	    status = (*fs_AttrOpTable[nameInfoPtr->domainType].setAttr)
			(&nameInfoPtr->fileID, attrPtr, idPtr, flags,
			rpc_SpriteID, hostID, userID);
#else
a163 1
#endif
@


9.3.1.1
log
@Initial branch for Sprite server.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fs/fsAttributes.c,v 9.3 91/02/01 16:28:31 shirriff Exp $ SPRITE (Berkeley)";
@


9.2
log
@Changed getAttr/setAttr to log the userID.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsAttributes.c,v 9.1 90/10/08 10:54:05 mendel Exp Locker: shirriff $ SPRITE (Berkeley)";
d185 1
a185 1
			hostID, userID);
@


9.1
log
@Fixed include files.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs.mendel/RCS/fsAttributes.c,v 8.7 89/08/21 15:22:19 mendel Exp $ SPRITE (Berkeley)";
d87 12
d101 1
d175 12
d189 1
@


9.0
log
@Changing version numbers.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsAttributes.c,v 8.7 89/08/21 15:22:19 mendel Exp Locker: douglis $ SPRITE (Berkeley)";
d28 12
a39 10
#include "sprite.h"
#include "fs.h"
#include "fsutil.h"
#include "fsNameOps.h"
#include "fslcl.h"
#include "fsconsist.h"
#include "fscache.h"
#include "fsdm.h"
#include "fsStat.h"
#include "rpc.h"
@


8.7
log
@Break up fs to sperate modules.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsAttributes.c,v 8.6 89/08/04 17:58:09 brent Exp $ SPRITE (Berkeley)";
@


8.6
log
@Fixed FsAssignAttrs so that the descModifyTime is
always at least as great as the dataModifyTime
@
text
@a10 6
 *	The 3 corrsponding RPCs are:
 *	RPC_FS_GET_ATTR_PATH	To get attributes from name server given path.
 *	RPC_FS_GET_ATTR		To get attributes from name server given fileID
 *	RPC_FS_GET_IO_ATTR	To get (a few) attributes from the I/O server.
 *	Setting attributes is done the same way, and there are three more
 *	corresponding RPCs.
d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsAttributes.c,v 8.5 89/06/15 09:04:43 brent Exp $ SPRITE (Berkeley)";
d30 1
a30 3
#include "fsInt.h"
#include "fsOpTable.h"
#include "fsLocalDomain.h"
d32 4
a35 4
#include "fsConsist.h"
#include "fsCacheOps.h"
#include "fsRecovery.h"
#include "fsDisk.h"
a38 2
FsHandleHeader *VerifyIOHandle();

d68 2
a69 2
    register FsHandleHeader	*hdrPtr = streamPtr->ioHandlePtr;
    register FsNameInfo		*nameInfoPtr = streamPtr->nameInfoPtr;
d71 1
a71 1
    if (!FsHandleValid(hdrPtr)) {
d74 1
a74 1
	if (nameInfoPtr == (FsNameInfo *)NIL) {
d85 1
a85 1
	    status = (*fsAttrOpTable[nameInfoPtr->domainType].getAttr)
d88 3
a90 3
	    status = FsLocalGetAttr(&nameInfoPtr->fileID, rpc_SpriteID,attrPtr);
	    status = FsRemoteGetAttr(&nameInfoPtr->fileID,rpc_SpriteID,attrPtr);
	    status = FsPseudoGetAttr(&nameInfoPtr->fileID,rpc_SpriteID,attrPtr);
d95 1
a95 1
		    status, Fs_GetFileName(streamPtr));
d102 2
a103 2
	    fsStats.cltName.getIOAttrs++;
	    status = (*fsStreamOpTable[hdrPtr->fileID.type].getIOAttr)
d106 4
a109 4
	    status = FsRemoteGetIOAttr(&hdrPtr->fileID, rpc_SpriteID, attrPtr);
	    status = FsRmtFileGetIOAttr(&hdrPtr->fileID, rpc_SpriteID, attrPtr);
	    status = FsDeviceGetIOAttr(&hdrPtr->fileID, rpc_SpriteID, attrPtr);
	    status = FsPipeGetIOAttr(&hdrPtr->fileID, rpc_SpriteID, attrPtr);
d112 1
a112 1
	    status = FsControlGetIOAttr(&hdrPtr->fileID, rpc_SpriteID,
d116 1
a116 1
	fsStats.cltName.getAttrIDs++;
a123 147
 * FsLocalGetAttr --
 *
 *	Get the attributes of a local file given its fileID.  This is called
 *	from Fs_GetAttrStream to get the attributes from the file descriptor.
 *	Also, as a special case, files that are cached remotely have their
 *	attributes updated here (on the server) by doing a call-back to
 *	clients to get the most recent access time, modify time, and size.
 *
 * Results:
 *	An error code.
 *
 * Side effects:
 *	Fills in the attributes structure with info from the disk descriptor.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
FsLocalGetAttr(fileIDPtr, clientID, attrPtr)
    register Fs_FileID		*fileIDPtr;	/* Identfies file */
    int				clientID;	/* Host ID of process asking
						 * for the attributes */
    register Fs_Attributes	*attrPtr;	/* Return - the attributes */
{
    if (fileIDPtr->type != FS_LCL_FILE_STREAM) {
	panic( "FsLocalGetAttr, bad fileID type <%d>\n",
	    fileIDPtr->type);
	return(GEN_INVALID_ARG);
    } else {
	FsLocalFileIOHandle *handlePtr;
	Boolean isExeced;
	ReturnStatus status;

	handlePtr = FsHandleFetchType(FsLocalFileIOHandle, fileIDPtr);
	if (handlePtr == (FsLocalFileIOHandle *)NIL) {
	    status = FsLocalFileHandleInit(fileIDPtr, (char *)NIL, &handlePtr);
	    if (status != SUCCESS) {
		bzero((Address)attrPtr, sizeof(Fs_Attributes));
		return(status);
	    }
	}
	/*
	 * Call-back to clients to get cached attributes, then copy
	 * attributes from the file descriptor to the attributes struct.
	 * NOTE: this only gets cached attributes for regular files.
	 * Device servers may cache attributes too, but that is handled
	 * on the client, not here on the name server.  Why?  Because
	 * generic devices crossed with migration lead to cases where
	 * we, the name server, don't know what's happening on the client.
	 */
	FsGetClientAttrs(handlePtr, clientID, &isExeced);
	FsAssignAttrs(handlePtr, isExeced, attrPtr);
	FsHandleRelease(handlePtr, TRUE);
	return(SUCCESS);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * FsAssignAttrs --
 *
 *	Fill in the Fs_Attributes structure for a regular file.
 *	If the isExeced flag is TRUE then the current time is used as the
 *	access time.  This is an optimization to avoid contacting every
 *	client using the file.  Furthermore, due to segment caching by
 *	VM, we have no accurate access time on an executable anyway.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Attribute structure set to contain attributes from disk descriptor
 *	and the cache information.
 *
 *----------------------------------------------------------------------
 */
void
FsAssignAttrs(handlePtr, isExeced, attrPtr)
    register	FsLocalFileIOHandle	*handlePtr;
    Boolean				isExeced;  /* TRUE if being executed,
						    * use current time for
						    * the access time. */
    register	Fs_Attributes		*attrPtr;
{
    register FsFileDescriptor *descPtr = handlePtr->descPtr;
    register FsCacheFileInfo *cacheInfoPtr = &handlePtr->cacheInfo;

    attrPtr->serverID			= handlePtr->hdr.fileID.serverID;
    attrPtr->domain			= handlePtr->hdr.fileID.major;
    attrPtr->fileNumber			= handlePtr->hdr.fileID.minor;
    attrPtr->type			= descPtr->fileType;
    attrPtr->permissions		= descPtr->permissions;
    attrPtr->numLinks			= descPtr->numLinks;
    attrPtr->uid			= descPtr->uid;
    attrPtr->gid			= descPtr->gid;
    attrPtr->userType			= descPtr->userType;
    attrPtr->devServerID		= descPtr->devServerID;
    attrPtr->devType			= descPtr->devType;
    attrPtr->devUnit			= descPtr->devUnit;
    /*
     * Take creation and descriptor modify time from disk descriptor,
     * except that the descModifyTime is >= dataModifyTime.  This
     * constraint is enforced later when the descriptor is written back,
     * so the descriptor may still be out-of-date at this point.
     */
    attrPtr->createTime.seconds		= descPtr->createTime;
    attrPtr->createTime.microseconds	= 0;
    attrPtr->descModifyTime.seconds	= descPtr->descModifyTime;
    attrPtr->descModifyTime.microseconds= 0;
    if (cacheInfoPtr->attr.modifyTime > attrPtr->descModifyTime.seconds) {
	attrPtr->descModifyTime.seconds = cacheInfoPtr->attr.modifyTime;
    }
    /*
     * Take size, access time, and modify time from cache info because
     * remote caching means the disk descriptor attributes can be out-of-date.
     */
    attrPtr->size			= cacheInfoPtr->attr.lastByte + 1;
    if (cacheInfoPtr->attr.firstByte >= 0) {
	attrPtr->size			-= cacheInfoPtr->attr.firstByte;
    }
    attrPtr->dataModifyTime.seconds	= cacheInfoPtr->attr.modifyTime;
    attrPtr->dataModifyTime.microseconds= 0;
    if (isExeced) {
	attrPtr->accessTime.seconds	= fsTimeInSeconds;
    } else {
	attrPtr->accessTime.seconds	= cacheInfoPtr->attr.accessTime;
    }
    attrPtr->accessTime.microseconds	= 0;
    /*
     * Again, if delayed writes mean we don't have any blocks for the
     * file then we estimate a block count from the cache size.  This
     * can be wrong due to granularity errors and wholes in files.
     * Also, even if the descriptor has some blocks it may not have them all.
     */
    if (cacheInfoPtr->attr.lastByte > 0 && descPtr->numKbytes == 0) {
	attrPtr->blocks			= cacheInfoPtr->attr.lastByte / 1024 +1;
    } else {
	attrPtr->blocks			= descPtr->numKbytes;
    }
    attrPtr->blockSize			= FS_BLOCK_SIZE;
    attrPtr->version			= descPtr->version;
    attrPtr->userType			= descPtr->userType;
}

/*
 *----------------------------------------------------------------------
 *
d150 2
a151 2
    register FsHandleHeader	*hdrPtr = streamPtr->ioHandlePtr;
    register FsNameInfo		*nameInfoPtr = streamPtr->nameInfoPtr;
d153 1
a153 1
    if (!FsHandleValid(hdrPtr)) {
d156 1
a156 1
	if (streamPtr->nameInfoPtr != (FsNameInfo *)NIL) {
d160 1
a160 1
	    status = (*fsAttrOpTable[nameInfoPtr->domainType].setAttr)
d163 3
a165 3
	    status = FsLocalSetAttr(&nameInfoPtr->fileID, attrPtr,idPtr,flags);
	    status = FsRemoteSetAttr(&nameInfoPtr->fileID, attrPtr,idPtr,flags);
	    status = FsPseudoSetAttr(&nameInfoPtr->fileID, attrPtr,idPtr,flags);
d174 2
a175 2
	    fsStats.cltName.setIOAttrs++;
	    status = (*fsStreamOpTable[hdrPtr->fileID.type].setIOAttr)
d178 4
a181 4
	    status = FsRemoteSetIOAttr(&hdrPtr->fileID, attrPtr, flags);
	    status = FsRmtFileSetIOAttr(&hdrPtr->fileID, attrPtr, flags);
	    status = FsDeviceSetIOAttr(&hdrPtr->fileID, attrPtr, flags);
	    status = FsPipeSetIOAttr(&hdrPtr->fileID, attrPtr, flags);
d183 1
a183 646
	    status = FsControlSetIOAttr(&hdrPtr->fileID, attrPtr, flags);
#endif lint
	}
    fsStats.cltName.setAttrIDs++;
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FsLocalSetAttr --
 *
 *	Set the attributes of a local file given its fileID.  This is
 *	called from Fs_SetAttrStream to set the attributes at the name server.
 *	The flags argument defines which attributes are updated.
 *	This updates the disk descriptor and copies the new information
 * 	into the cache.  It will go to disk on the next sync.
 *
 *	Various constraints are implemented here.
 *	1) You must be super-user or own the file to succeed at all.
 *	2) You must be super-user to change the owner of a file.
 *	3) You must be super-user or a member of the new group
 *		to change the group of a file.  The SETGID bit is
 *		cleared if a non-super-user changes the group.
 *	4) You must be super-user or a member of the file's group
 *		to set the SETGID bit of the file.
 *	5) If you've made it this far you can set the access time,
 *		modify time, and user-defined file type.
 *
 * Results:
 *	FS_NOT_OWNER if you don't own the file
 *	FS_NO_ACCESS if you violate one of the above constraints.
 *
 * Side effects:
 *	Sets the attributes of the file, subject to the above constraints.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
FsLocalSetAttr(fileIDPtr, attrPtr, idPtr, flags)
    Fs_FileID			*fileIDPtr;	/* Target file. */
    register Fs_Attributes	*attrPtr;	/* New attributes */
    register Fs_UserIDs		*idPtr;		/* Process's owner/group */
    register int		flags;		/* What attrs to set */
{
    register ReturnStatus	status = SUCCESS;
    FsLocalFileIOHandle		*handlePtr;
    register FsFileDescriptor	*descPtr;
    FsDomain			*domainPtr;

    handlePtr = FsHandleFetchType(FsLocalFileIOHandle, fileIDPtr);
    if (handlePtr == (FsLocalFileIOHandle *)NIL) {
	printf(
		"FsLocalSetAttr, no handle for %s <%d,%d,%d>\n",
		FsFileTypeToString(fileIDPtr->type),
		fileIDPtr->serverID, fileIDPtr->major, fileIDPtr->minor);
	return(FS_FILE_NOT_FOUND);
    }
    descPtr = handlePtr->descPtr;
    if (descPtr == (FsFileDescriptor *)NIL) {
	printf( "FsLocalSetAttr, NIL descPtr\n");
	status = FAILURE;
	goto exit;
    }
    if ((idPtr->user != 0) && (idPtr->user != descPtr->uid)) {
	status = FS_NOT_OWNER;
	goto exit;
    }
    if (flags & FS_SET_OWNER) {
	if (attrPtr->uid >= 0 && descPtr->uid != attrPtr->uid) {
	    if (idPtr->user != 0) {
		/*
		 * Don't let ordinary people give away ownership.
		 */
		status = FS_NO_ACCESS;
		goto exit;
	    } else {
		descPtr->uid = attrPtr->uid;
	    }
	}
	if (attrPtr->gid >= 0 && descPtr->gid != attrPtr->gid) {
	    register int g;
	    /*
	     * Can only set to a group you belong to.  The set-gid
	     * bit is also reset as an extra precaution.
	     */
	    for (g=0 ; g < idPtr->numGroupIDs; g++) {
		if (attrPtr->gid == idPtr->group[g] || idPtr->user == 0) {
		    descPtr->gid = attrPtr->gid;
		    if (idPtr->user != 0) {
			descPtr->permissions &= ~FS_SET_GID;
		    }
		    break;
		}
	    }
	    if (g >= idPtr->numGroupIDs) {
		status = FS_NO_ACCESS;
		goto exit;
	    }
	}
    }
    if (flags & FS_SET_MODE) {
	if (attrPtr->permissions & FS_SET_GID) {
	    /*
	     * Have to verify that the process belongs to the
	     * new group of the file.  We have already verified that
	     * the process's user ID matches the file's owner.
	     */
	    register int g;
	    for (g=0 ; g < idPtr->numGroupIDs; g++) {
		if (attrPtr->gid == idPtr->group[g] || idPtr->user == 0) {
#ifndef lint
		    goto setMode;
#endif not lint
		}
	    }
	    status = FS_NO_ACCESS;
	    goto exit;		/* Note: can't have changed *descPtr by now. */
	}
#ifndef lint
setMode:
#endif not lint
	descPtr->permissions = attrPtr->permissions;
    }
    if (flags & FS_SET_DEVICE) {
	if (descPtr->fileType == FS_DEVICE ||
		  descPtr->fileType == FS_REMOTE_DEVICE) {
	      descPtr->devServerID = attrPtr->devServerID;
	      descPtr->devType = attrPtr->devType;
	      descPtr->devUnit = attrPtr->devUnit;
	}
    }
    if (flags & FS_SET_TIMES) {
	descPtr->accessTime       = attrPtr->accessTime.seconds;
	descPtr->dataModifyTime   = attrPtr->dataModifyTime.seconds;
	/*
	 * Patch this because it gets copied below by FsUpdateCachedAttr.
	 */
	attrPtr->createTime.seconds = descPtr->createTime;
    }

    if (flags & FS_SET_FILE_TYPE) {
	descPtr->userType    = attrPtr->userType;
    }

    /*
     * Copy this new information into the cache block containing the descriptor.
     */
    descPtr->descModifyTime   = fsTimeInSeconds;
    domainPtr = FsDomainFetch(handlePtr->hdr.fileID.major, FALSE);
    if (domainPtr == (FsDomain *)NIL) {
	status = FS_DOMAIN_UNAVAILABLE;
    } else {
	status = FsStoreFileDesc(domainPtr, handlePtr->hdr.fileID.minor,
		 descPtr);
	FsDomainRelease(handlePtr->hdr.fileID.major);
    }
    if (status == SUCCESS) {
	/*
	 * Update the attributes cached in the file handle.
	 */
	FsUpdateCachedAttr(&handlePtr->cacheInfo, attrPtr, flags);
    }
exit:
    FsHandleRelease(handlePtr, TRUE);
    return(status);
}

/*
 * Return parameters from RPC_FS_GET_ATTR_PATH.  The file ID is used to
 * get to the I/O server.
 */
typedef struct FsRemoteGetAttrResults {
    Fs_Attributes	attributes;
    Fs_FileID		fileID;
} FsRemoteGetAttrResults;


/*
 *----------------------------------------------------------------------
 *
 * FsRemoteGetAttrPath --
 *
 *	Get the attributes of a remote Sprite file given its name.  This
 *	is called from Fs_GetAttributes for files named by remote servers.
 *	Note:  the attributes from the disk descriptor on the name server
 *	are returned.  The attributes need to be updated by the I/O server
 *	if there is one.
 *
 * Results:
 *	A return code from the RPC or the remote server.
 *
 * Side effects:
 *	FS_RPC_GET_ATTR.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
FsRemoteGetAttrPath(prefixHandle, relativeName, argsPtr, resultsPtr,
         	    newNameInfoPtrPtr)
    FsHandleHeader *prefixHandle;	/* Handle from the prefix table */
    char           *relativeName;	/* The name of the file. */
    Address        argsPtr;		/* Bundled arguments for us */
    Address        resultsPtr;		/* Where to store attributes */
    FsRedirectInfo **newNameInfoPtrPtr;	/* We return this if the server leaves 
					 * its domain during the lookup. */
{
    ReturnStatus 		status;
    FsOpenArgs			*openArgsPtr;
    FsGetAttrResults		*getAttrResultsPtr;
    FsGetAttrResultsParam	getAttrResultsParam;
    Rpc_Storage			storage;
    char			replyName[FS_MAX_PATH_NAME_LENGTH];	 /* This
						     * may get filled with a
						     * redirected pathname. */

    openArgsPtr = (FsOpenArgs *) argsPtr;
    getAttrResultsPtr = (FsGetAttrResults *)resultsPtr;

    storage.requestParamPtr = (Address) openArgsPtr;
    storage.requestParamSize = sizeof(FsOpenArgs);
    storage.requestDataPtr = (Address) relativeName;
    storage.requestDataSize = strlen(relativeName) + 1;
    storage.replyParamPtr = (Address) &(getAttrResultsParam);
    storage.replyParamSize = sizeof(FsGetAttrResultsParam);
    storage.replyDataPtr = (Address) replyName;
    storage.replyDataSize = FS_MAX_PATH_NAME_LENGTH;

    status = Rpc_Call(prefixHandle->fileID.serverID, RPC_FS_GET_ATTR_PATH,
			&storage);
     if (status == SUCCESS) {
	/*
	 * The return param area has a fileID that we need.  The
	 * return parameter area has also been filled in with
	 * the attributes.
	 */
	*(getAttrResultsPtr->fileIDPtr) =
		 getAttrResultsParam.attrResults.fileID;
	*(getAttrResultsPtr->attrPtr) =
		getAttrResultsParam.attrResults.attrs;
    } else if (status == FS_LOOKUP_REDIRECT) {
	/*
	 * Copy the info from our stack to a buffer for our caller
	 */
	*newNameInfoPtrPtr = mnew(FsRedirectInfo);
	(*newNameInfoPtrPtr)->prefixLength = getAttrResultsParam.prefixLength;
	(void)strcpy((*newNameInfoPtrPtr)->fileName, replyName);
	return(FS_LOOKUP_REDIRECT);
    }

    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * Fs_RpcGetAttrPath --
 *
 *	Service stub for the RPC_FS_GET_ATTR_PATH call.  This is used to
 *	get the attributes from the disk descriptor of a file.  NOTE:  the
 *	attributes are not complete until the I/O server for the (non-regular)
 *	file is contacted.  This routine does, however, suck in attributes
 *	of regular files that are cached.
 *
 * Results:
 *	If this procedure returns SUCCESS then a reply has been sent to
 *	the client.  If the arguments are bad then an error is 
 *	returned and the main level sends back an error reply.
 *
 * Side effects:
 *	Allocates a buffer to return the results in.
 *	
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Fs_RpcGetAttrPath(srvToken, clientID, command, storagePtr)
    ClientData 		 srvToken;	/* Handle on server process passed to
				 	 * Rpc_Reply */
    int 		 clientID;	/* Sprite ID of client host */
    int 		 command;	/* IGNORED */
    register Rpc_Storage *storagePtr;	/* The request fields refer to the 
					 * request buffers and also indicate 
					 * the exact amount of data in the 
					 * request buffers.  The reply fields 
					 * are initialized to NIL for the
				 	 * pointers and 0 for the lengths.  
					 * This can be passed to Rpc_Reply */
{
    register FsOpenArgs		*openArgsPtr;	/* Tmp pointer into openParams*/
    FsGetAttrResults 		getAttrResults;	/* Results from local  routine */
    FsGetAttrResultsParam	*getAttrResultsParamPtr;	/* rpc param
								 * bundle */
    FsHandleHeader		*prefixHandle;	/* Handle for domain */
    ReturnStatus		status;		/* General return code */
    FsRedirectInfo		*newNameInfoPtr;/* For prefix re-directs,
						 * unallocated since proc call
						 * allocates space for it. */
    int				domainType;

    openArgsPtr = (FsOpenArgs *) storagePtr->requestParamPtr;

    if (openArgsPtr->prefixID.serverID != rpc_SpriteID) {
	/*
	 * Filesystem mis-match.
	 */
	return(GEN_INVALID_ARG);
    }
    prefixHandle = (*fsStreamOpTable[openArgsPtr->prefixID.type].clientVerify)
	    (&openArgsPtr->prefixID, clientID, &domainType);
    if (prefixHandle == (FsHandleHeader *)NIL) {
	return(FS_STALE_HANDLE);
    }
    FsHandleRelease(prefixHandle, TRUE);

    newNameInfoPtr = (FsRedirectInfo *) NIL;
    getAttrResultsParamPtr = mnew(FsGetAttrResultsParam);

    getAttrResults.attrPtr = &(getAttrResultsParamPtr->attrResults.attrs);
    getAttrResults.fileIDPtr = &(getAttrResultsParamPtr->attrResults.fileID);

    fsStats.srvName.getAttrs++;
    status = (*fsDomainLookup[domainType][FS_DOMAIN_GET_ATTR])(prefixHandle,
		(char *) storagePtr->requestDataPtr, (Address)openArgsPtr,
		(Address)(&getAttrResults), &newNameInfoPtr);

    if (status == SUCCESS) {
	storagePtr->replyParamPtr = (Address) getAttrResultsParamPtr;
	storagePtr->replyParamSize = sizeof(FsGetAttrResultsParam);
	storagePtr->replyDataPtr = (Address) NIL;
	storagePtr->replyDataSize = 0;
    } else if (status == FS_LOOKUP_REDIRECT) {
	/*
	 * The file is not found on this server, but somewhere else.
	 */
	getAttrResultsParamPtr->prefixLength = newNameInfoPtr->prefixLength;
	storagePtr->replyParamPtr = (Address) getAttrResultsParamPtr;
	storagePtr->replyParamSize = sizeof(FsGetAttrResultsParam);
	storagePtr->replyDataSize = strlen(newNameInfoPtr->fileName) + 1;
	storagePtr->replyDataPtr =
		(Address) malloc(storagePtr->replyDataSize);
	(void)strcpy((char *) storagePtr->replyDataPtr, newNameInfoPtr->fileName);
	free((Address)newNameInfoPtr);
    }
    if (status == SUCCESS || status == FS_LOOKUP_REDIRECT) {
	Rpc_ReplyMem	*replyMemPtr;

        replyMemPtr = (Rpc_ReplyMem *) malloc(sizeof(Rpc_ReplyMem));
        replyMemPtr->paramPtr = storagePtr->replyParamPtr;
        replyMemPtr->dataPtr = storagePtr->replyDataPtr;
        Rpc_Reply(srvToken, status, storagePtr, Rpc_FreeMem,
		    (ClientData)replyMemPtr);
        return(SUCCESS);
    } else {
	free((Address) getAttrResultsParamPtr);
        return(status);
    }
}


/*
 *----------------------------------------------------------------------
 *
 * FsRemoteSetAttrPath --
 *
 *	Set the attributes of a remote Sprite file given its path name.
 *	This is called from Fs_SetAttributes.  This used the
 *	RPC_FS_SET_ATTR_PATH rpc to invoke FsLocalSetAttrPath on the
 *	name server.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
FsRemoteSetAttrPath(prefixHandle, relativeName, argsPtr, resultsPtr,
         	    newNameInfoPtrPtr)
    FsHandleHeader *prefixHandle;   /* Token from the prefix table */
    char           *relativeName;   /* The name of the file. */
    Address        argsPtr;	    /* Bundled arguments for us */
    Address        resultsPtr;	    /* FileID */
    FsRedirectInfo **newNameInfoPtrPtr; /* We return this if the server leaves 
					 * its domain during the lookup. */
{
    ReturnStatus 		status;
    Rpc_Storage			storage;
    char			replyName[FS_MAX_PATH_NAME_LENGTH];
    FsGetAttrResultsParam	getAttrResultsParam;
    Fs_FileID			*fileIDPtr;

    storage.requestParamPtr = (Address) argsPtr;
    storage.requestParamSize = sizeof(FsSetAttrArgs);
    storage.requestDataPtr = (Address) relativeName;
    storage.requestDataSize = strlen(relativeName) + 1;
    storage.replyParamPtr = (Address) &(getAttrResultsParam);
    storage.replyParamSize = sizeof(FsGetAttrResultsParam);
    storage.replyDataPtr = (Address) replyName;
    storage.replyDataSize = FS_MAX_PATH_NAME_LENGTH;

    fileIDPtr = (Fs_FileID *) resultsPtr;

    status = Rpc_Call(prefixHandle->fileID.serverID, RPC_FS_SET_ATTR_PATH,
			&storage);
    if (status == SUCCESS) {
	/*
	 * Copy result fileID to resultsPtr (== fileIDPtr).
	 */
	(* fileIDPtr) = getAttrResultsParam.attrResults.fileID;
    } else if (status == FS_LOOKUP_REDIRECT) {
	/*
	 * Copy the info from our stack to a buffer for our caller.
	 */
	*newNameInfoPtrPtr = mnew(FsRedirectInfo);
	(*newNameInfoPtrPtr)->prefixLength = getAttrResultsParam.prefixLength;
	(void)strcpy((*newNameInfoPtrPtr)->fileName, replyName);
    }

    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * Fs_RpcSetAttrPath --
 *
 *	Service stub for the RPC_FS_SET_ATTR_PATH call.  This branches
 *	to FsLocalSetAttrPath which sets the attributes on the file descriptor.
 *
 * Results:
 *	If this procedure returns SUCCESS then a reply has been sent to
 *	the client.  If the arguments are bad then an error is 
 *	returned and the main level sends back an error reply.
 *
 * Side effects:
 *	Allocates a buffer to return the results in.
 *	
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Fs_RpcSetAttrPath(srvToken, clientID, command, storagePtr)
    ClientData 		 srvToken;	/* Handle on server process passed to
				 	 * Rpc_Reply */
    int 		 clientID;	/* Sprite ID of client host */
    int 		 command;	/* IGNORED */
    register Rpc_Storage *storagePtr;	/* The request fields refer to the 
					 * request buffers and also indicate 
					 * the exact amount of data in the 
					 * request buffers.  The reply fields 
					 * are initialized to NIL for the
				 	 * pointers and 0 for the lengths.  
					 * This can be passed to Rpc_Reply */
{
    Fs_FileID			*ioFileIDPtr;	/* Results from local routine */
    FsHandleHeader		*prefixHandle;	/* Handle for domain */
    ReturnStatus		status;		/* General return code */
    FsSetAttrArgs		*setAttrArgsPtr;
    FsRedirectInfo		*newNameInfoPtr;/* For prefix re-directs */
    FsGetAttrResultsParam	*getAttrResultsParamPtr;	/* rpc param
								 * bundle */
    int				domainType;

    setAttrArgsPtr = (FsSetAttrArgs *) storagePtr->requestParamPtr;

    prefixHandle =
	(*fsStreamOpTable[setAttrArgsPtr->openArgs.prefixID.type].clientVerify)
	    (&setAttrArgsPtr->openArgs.prefixID, clientID, &domainType);
    if (prefixHandle == (FsHandleHeader *)NIL) {
	return(FS_STALE_HANDLE);
    }
    FsHandleRelease(prefixHandle, TRUE);


    fsStats.srvName.setAttrs++;
    newNameInfoPtr = (FsRedirectInfo *) NIL;
    getAttrResultsParamPtr = mnew(FsGetAttrResultsParam);
    ioFileIDPtr = &(getAttrResultsParamPtr->attrResults.fileID);
    status = (*fsDomainLookup[domainType][FS_DOMAIN_SET_ATTR])(prefixHandle,
		(char *) storagePtr->requestDataPtr,
		(Address) storagePtr->requestParamPtr,
		(Address) ioFileIDPtr, &newNameInfoPtr);

    if (status == SUCCESS) {
	storagePtr->replyParamPtr = (Address) getAttrResultsParamPtr;
	storagePtr->replyParamSize = sizeof(FsGetAttrResultsParam);
	storagePtr->replyDataPtr = (Address) NIL;
	storagePtr->replyDataSize = 0;
    } else if (status == FS_LOOKUP_REDIRECT) {
	/*
	 * The file is not found on this server.
	 */
	getAttrResultsParamPtr->prefixLength = newNameInfoPtr->prefixLength;
	storagePtr->replyParamPtr = (Address) getAttrResultsParamPtr;
	storagePtr->replyParamSize = sizeof(FsGetAttrResultsParam);
	storagePtr->replyDataSize = strlen(newNameInfoPtr->fileName) + 1;
	storagePtr->replyDataPtr =
		(Address) malloc(storagePtr->replyDataSize);
	(void)strcpy((char *) storagePtr->replyDataPtr, newNameInfoPtr->fileName);
	free((Address)newNameInfoPtr);
    }
    if (status == SUCCESS || status == FS_LOOKUP_REDIRECT) {
	Rpc_ReplyMem	*replyMemPtr;

        replyMemPtr = (Rpc_ReplyMem *) malloc(sizeof(Rpc_ReplyMem));
        replyMemPtr->paramPtr = storagePtr->replyParamPtr;
        replyMemPtr->dataPtr = storagePtr->replyDataPtr;
        Rpc_Reply(srvToken, status, storagePtr, Rpc_FreeMem,
		(ClientData)replyMemPtr);
        return(SUCCESS);
    } else {
	free((Address)getAttrResultsParamPtr);
        return(status);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * FsRemoteGetAttr --
 *
 *	Get the attributes of a remote file given its fileID.  This is called
 *	from Fs_GetAttrStream.  This does an RPC to the name server which
 *	then calls FsLocalGetAttr.
 *
 * Results:
 *	An error code.
 *
 * Side effects:
 *	Fills in the attributes structure with info from the file server.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsRemoteGetAttr(fileIDPtr, clientID, attrPtr)
    register Fs_FileID		*fileIDPtr;	/* Identfies file */
    int				clientID;	/* IGNORED, implicitly passed
						 * by the RPC system. */
    register Fs_Attributes	*attrPtr;	/* Return - the attributes */
{
    register ReturnStatus	status;
    Rpc_Storage storage;

    storage.requestParamPtr = (Address) fileIDPtr;
    storage.requestParamSize = sizeof(Fs_FileID);
    storage.requestDataPtr = (Address) NIL;
    storage.requestDataSize = 0;

    storage.replyParamPtr = (Address) attrPtr;
    storage.replyParamSize = sizeof(Fs_Attributes);
    storage.replyDataPtr = (Address) NIL;
    storage.replyDataSize = 0;

    status = Rpc_Call(fileIDPtr->serverID, RPC_FS_GET_ATTR, &storage);
    if (status == RPC_TIMEOUT || status == FS_STALE_HANDLE ||
	status == RPC_SERVICE_DISABLED) {
	/*
	 * If there was a problem at the server then try to recover
	 * the handle.  We may not have a handle in the case of devices.
	 * In that case the fileID we have here comes from the stream's
	 * nameInfo, which doesn't get installed into the handle table.
	 */
	register FsHandleHeader *hdrPtr = FsHandleFetch(fileIDPtr);
	if (hdrPtr != (FsHandleHeader *)NIL) {
	    FsWantRecovery(hdrPtr);
	    FsHandleRelease(hdrPtr, TRUE);
	}
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * Fs_RpcGetAttr --
 *
 *	Service stub for the RPC_FS_GET_ATTR call.  This calls FsLocalGetAttr
 *	(or FsPseudoGetAttr) to get the attributes of a file.  This
 *	is a name server operation used when the file is already open.
 *	Note: Attributes are not complete until the I/O server has also
 *	been contacted.  See Fs_RpcGetIOAttr.
 *
 * Results:
 *	If this procedure returns SUCCESS then a reply has been sent to
 *	the client.  If the arguments are bad then an error is 
 *	returned and the main level sends back an error reply.
 *
 * Side effects:
 *	Allocates a buffer to return the results in.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Fs_RpcGetAttr(srvToken, clientID, command, storagePtr)
    ClientData 		 srvToken;	/* Handle on server process passed to
				 	 * Rpc_Reply */
    int 		 clientID;	/* Sprite ID of client host */
    int 		 command;	/* IGNORED */
    register Rpc_Storage *storagePtr;	/* The request fields refer to the 
					 * request buffers and also indicate 
					 * the exact amount of data in the 
					 * request buffers.  The reply fields 
					 * are initialized to NIL for the
					 * pointers and 0 for the lengths.  
					 * This can be passed to Rpc_Reply */
{
    register ReturnStatus	status;
    FsHandleHeader		*tHdrPtr;
    register FsHandleHeader	*hdrPtr;
    register Fs_FileID		*fileIDPtr;
    register Fs_Attributes	*attrPtr;
    Rpc_ReplyMem		*replyMemPtr;
    int				domainType = FS_LOCAL_DOMAIN;

    fileIDPtr = (Fs_FileID *) storagePtr->requestParamPtr;
    hdrPtr = VerifyIOHandle(fileIDPtr);
    if (fileIDPtr->type == FS_LCL_PFS_STREAM) {
	if (hdrPtr == (FsHandleHeader *)NIL) {
	    return(FS_STALE_HANDLE);
	}
	domainType = FS_PSEUDO_DOMAIN;
    } else if (hdrPtr == (FsHandleHeader *)NIL) {
	status = FsLocalFileHandleInit(fileIDPtr, (char *)NIL,
			(FsLocalFileIOHandle **)&tHdrPtr);
	if (status != SUCCESS) {
	    return(status);
	}
	hdrPtr = tHdrPtr;
    }
    FsHandleUnlock(hdrPtr);

    fsStats.srvName.getAttrs++;
    attrPtr = mnew(Fs_Attributes);
    status = (*fsAttrOpTable[domainType].getAttr)(fileIDPtr, clientID, attrPtr);
#ifdef lint
    status = FsLocalGetAttr(fileIDPtr, clientID, attrPtr);
    status = FsPseudoGetAttr(fileIDPtr, clientID, attrPtr);
a184 127
    FsHandleRelease(hdrPtr, FALSE);

    storagePtr->replyParamPtr = (Address) attrPtr;
    storagePtr->replyParamSize = sizeof(Fs_Attributes);
    replyMemPtr = (Rpc_ReplyMem *) malloc(sizeof(Rpc_ReplyMem));
    replyMemPtr->paramPtr = storagePtr->replyParamPtr;
    replyMemPtr->dataPtr = (Address) NIL;

    Rpc_Reply(srvToken, status, storagePtr, Rpc_FreeMem,
	    (ClientData)replyMemPtr);
    return(SUCCESS);
}

/*
 * Parameters for RPC_FS_SET_ATTR.  This is a sub-set of FsSetAttrArgs
 * (which has extra stuff required to handle path name lookup).
 */

typedef struct FsRemoteSetAttrParams {
    Fs_FileID		fileID;
    Fs_UserIDs		ids;
    Fs_Attributes	attrs;
    int			flags;
} FsRemoteSetAttrParams;

/*
 *----------------------------------------------------------------------
 *
 * FsRemoteSetAttr
 *
 *	Set selected attributes of a remote file given its fileID.  This
 *	is called from Fs_SetAttrStream.  This does the RPC_FS_SET_ATTR
 *	remote call which invokes FsLocalSetAttr on the name server.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
FsRemoteSetAttr(fileIDPtr, attrPtr, idPtr, flags)
    Fs_FileID		*fileIDPtr;
    Fs_Attributes	*attrPtr;
    Fs_UserIDs		 *idPtr;
    int			flags;
{
    ReturnStatus status;
    Rpc_Storage storage;
    FsRemoteSetAttrParams params;

    params.fileID = *fileIDPtr;
    params.ids = *idPtr;
    params.attrs = *attrPtr;
    params.flags = flags;
    storage.requestParamPtr = (Address)&params;
    storage.requestParamSize = sizeof(FsRemoteSetAttrParams);
    storage.requestDataPtr = (Address)NIL;;
    storage.requestDataSize = 0;
    storage.replyParamPtr = (Address)NIL;
    storage.replyParamSize = 0;
    storage.replyDataPtr = (Address)NIL;
    storage.replyDataSize = 0;

    status = Rpc_Call(fileIDPtr->serverID, RPC_FS_SET_ATTR, &storage);
    if (status == RPC_TIMEOUT || status == FS_STALE_HANDLE ||
	status == RPC_SERVICE_DISABLED) {
	register FsHandleHeader *hdrPtr = FsHandleFetch(fileIDPtr);
	if (hdrPtr != (FsHandleHeader *)NIL) {
	    FsWantRecovery(hdrPtr);
	    FsHandleRelease(hdrPtr, TRUE);
	}
    }

    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * Fs_RpcSetAttr --
 *
 *	Service stub for RPC_FS_SET_ATTR.  This calls FsLocalSetAttr.
 *
 * Results:
 *	If this procedure returns SUCCESS then a reply has been sent to
 *	the client.  If the arguments are bad then FS_STALE_HANDLE is 
 *	returned and the main level sends back an error reply.
 *
 * Side effects:
 *	Uses FsLocalSetAttr to set attributes in the file descriptor.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Fs_RpcSetAttr(srvToken, clientID, command, storagePtr)
    ClientData 		 srvToken;	/* Handle on server process passed to
				 	 * Rpc_Reply */
    int 		 clientID;	/* Sprite ID of client host */
    int 		 command;	/* IGNORED */
    register Rpc_Storage *storagePtr;	/* The request fields refer to the 
					 * request buffers and also indicate 
					 * the exact amount of data in the 
					 * request buffers.  The reply fields 
					 * are initialized to NIL for the
				 	 * pointers and 0 for the lengths.  
					 * This can be passed to Rpc_Reply */
{
    FsHandleHeader		*hdrPtr;
    register Fs_FileID		*fileIDPtr;
    register Fs_Attributes	*attrPtr;
    register ReturnStatus	status;
    FsRemoteSetAttrParams	*paramPtr;
    int				domainType = FS_LOCAL_DOMAIN;

    paramPtr = (FsRemoteSetAttrParams *) storagePtr->requestParamPtr;
    attrPtr = &paramPtr->attrs;
    fileIDPtr = &paramPtr->fileID;

    hdrPtr = VerifyIOHandle(fileIDPtr);
    if (fileIDPtr->type == FS_LCL_PFS_STREAM) {
	if (hdrPtr == (FsHandleHeader *)NIL) {
	    return(FS_STALE_HANDLE);
d186 1
a186 235
	domainType = FS_PSEUDO_DOMAIN;
    } else if (hdrPtr == (FsHandleHeader *)NIL) {
	status = FsLocalFileHandleInit(fileIDPtr, (char *)NIL,
			(FsLocalFileIOHandle **)&hdrPtr);
	if (status != SUCCESS) {
	    return(status);
	}
    }
    fsStats.srvName.setAttrs++;
    FsHandleUnlock(hdrPtr);
    status = (*fsAttrOpTable[domainType].setAttr)(fileIDPtr, attrPtr,
						&paramPtr->ids,paramPtr->flags);
#ifdef lint
    status = FsLocalSetAttr(fileIDPtr, attrPtr, &paramPtr->ids,paramPtr->flags);
    status = FsPseudoSetAttr(fileIDPtr,attrPtr, &paramPtr->ids,paramPtr->flags);
#endif lint
    FsHandleRelease(hdrPtr, FALSE);

    Rpc_Reply(srvToken, status, storagePtr, (int (*)())NIL,
		(ClientData)NIL);
    return(SUCCESS);
}


/*
 *----------------------------------------------------------------------
 *
 * FsRemoteGetIOAttr --
 *
 *	Get the attributes cached at a remote I/O server.  This makes the
 *	RPC_FS_GET_IO_ATTR RPC to the I/O server which then calls
 *	stream-type getIOAttrs routine.
 *
 * Results:
 *	An error code.
 *
 * Side effects:
 *	Update attributes structure with info from the I/O server.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsRemoteGetIOAttr(fileIDPtr, clientID, attrPtr)
    register Fs_FileID		*fileIDPtr;	/* Remote device/pipe fileID */
    int				clientID;	/* IGNORED, implicitly passed
						 * by the RPC system. */
    register Fs_Attributes	*attrPtr;	/* In/Out - the attributes are
						 * updated by the I/O server */
{
    register ReturnStatus status;
    Rpc_Storage storage;
    FsGetAttrResultsParam	getAttrResultsParam;

    getAttrResultsParam.attrResults.fileID = *fileIDPtr;
    getAttrResultsParam.attrResults.attrs = *attrPtr;
    /*
     * We have to fix up the fileID of control handles in the case that
     * the pseudo-device server is remote from us.  The problem is that
     * we have to RPC to the pseduo-device server, but the fileID of the
     * control stream (where the access/modify times are) has the
     * file serverID.  Fortuneatly this is in the regular attributes so
     * we can patch it up.  We add two lines of code here instead of
     * nearly duplicating this procedure into a FsRmtControlGetIOAttr
     * routine that has the patch.
     */
    if (fileIDPtr->type == FS_RMT_CONTROL_STREAM) {
	getAttrResultsParam.attrResults.fileID.serverID = attrPtr->serverID;
    }

    storage.requestParamPtr = (Address) &getAttrResultsParam;
    storage.requestParamSize = sizeof(FsGetAttrResultsParam);
    storage.requestDataPtr = (Address) NIL;
    storage.requestDataSize = 0;

    storage.replyParamPtr = (Address) attrPtr;
    storage.replyParamSize = sizeof(Fs_Attributes);
    storage.replyDataPtr = (Address) NIL;
    storage.replyDataSize = 0;

    status = Rpc_Call(fileIDPtr->serverID, RPC_FS_GET_IO_ATTR, &storage);
    /*
     * We punt on I/O server recovery, and mask errors so a stat() works.
     */
    if (status != SUCCESS) {
	printf(
	    "FsRemoteGetIOAttr failed <%x>: device <%d,%d> at server %d\n",
	    status, fileIDPtr->major, fileIDPtr->minor, fileIDPtr->serverID);
	status = SUCCESS;
    }

    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * Fs_RpcGetIOAttr --
 *
 *	Service stub for the RPC_FS_GET_IO_ATTR call.  This calls
 *	the stream-type routine to get attributes cached at the I/O server.
 *
 * Results:
 *	If this procedure returns SUCCESS then a reply has been sent to
 *	the client.  If the arguments are bad then an error is 
 *	returned and the main level sends back an error reply.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Fs_RpcGetIOAttr(srvToken, clientID, command, storagePtr)
    ClientData 		 srvToken;	/* Handle on server process passed to
				 	 * Rpc_Reply */
    int 		 clientID;	/* Sprite ID of client host */
    int 		 command;	/* IGNORED */
    register Rpc_Storage *storagePtr;	/* The request fields refer to the 
					 * request buffers and also indicate 
					 * the exact amount of data in the 
					 * request buffers.  The reply fields 
					 * are initialized to NIL for the
				 	 * pointers and 0 for the lengths.  
					 * This can be passed to Rpc_Reply */
{
    register ReturnStatus	status;
    register FsHandleHeader	*hdrPtr;
    register Fs_FileID		*fileIDPtr;
    Fs_Attributes		*attrPtr;
    FsGetAttrResultsParam	*getAttrResultsParamPtr;

    getAttrResultsParamPtr =
	    (FsGetAttrResultsParam *) storagePtr->requestParamPtr;
    fileIDPtr = &(getAttrResultsParamPtr->attrResults.fileID);
    attrPtr = &(getAttrResultsParamPtr->attrResults.attrs);

    hdrPtr = VerifyIOHandle(fileIDPtr);
    if (hdrPtr != (FsHandleHeader *) NIL) {
	/*
	 * If someone has the I/O device open we'll have a handle and
	 * should go get the access and modify times.
	 */
	fsStats.srvName.getIOAttrs++;
	FsHandleUnlock(hdrPtr);
	status = (*fsStreamOpTable[hdrPtr->fileID.type].getIOAttr)
		(&hdrPtr->fileID, clientID, attrPtr);
#ifdef lint
	status = FsDeviceGetIOAttr(&hdrPtr->fileID, rpc_SpriteID, attrPtr);
	status = FsPipeGetIOAttr(&hdrPtr->fileID, rpc_SpriteID, attrPtr);
	status = FsControlGetIOAttr(&hdrPtr->fileID, rpc_SpriteID,attrPtr);
#endif lint
	FsHandleRelease(hdrPtr, FALSE);
    } else {
	/*
	 * No information to add. We just return what was passed to us.
	 */
	status = SUCCESS;
    }
    if (status == SUCCESS) {
	storagePtr->replyParamPtr = (Address) attrPtr;
	storagePtr->replyParamSize = sizeof(Fs_Attributes);
    }
    /*
     * No clean-up call-back needed because we are returning the attributes
     * that are sitting in the request buffer.
     */
    Rpc_Reply(srvToken, status, storagePtr, (int (*)())NIL, (ClientData)NIL);
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FsRemoteSetIOAttr --
 *
 *	Set the attributes cached at a remote I/O server.  This makes the
 *	RPC_FS_SET_IO_ATTR RPC to the I/O server which then calls
 *	stream-type setIOAttrs routine.
 *
 * Results:
 *	An error code.
 *
 * Side effects:
 *	Set attributes cached with the I/O server.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsRemoteSetIOAttr(fileIDPtr, attrPtr, flags)
    register Fs_FileID		*fileIDPtr;	/* Remote device/pipe fileID */
    register Fs_Attributes	*attrPtr;	/* Attributes to copy */
    int				flags;		/* What attributes to set */
{
    register ReturnStatus	status;
    Rpc_Storage			storage;
    FsRemoteSetAttrParams	setAttrParam;

    setAttrParam.fileID = *fileIDPtr;
    setAttrParam.attrs = *attrPtr;
    setAttrParam.flags = flags;
    /*
     * We have to fix up the fileID of control handles in the case that
     * the pseudo-device server is remote from us.  The problem is that
     * we have to RPC to the pseduo-device server, but the fileID of the
     * control stream (where the access/modify times are) has the
     * file serverID.  Fortuneatly this is in the regular attributes so
     * we can patch it up.  We add two lines of code here instead of
     * nearly duplicating this procedure into a FsRmtControlSetIOAttr
     * routine that has the patch.
     */
    if (fileIDPtr->type == FS_RMT_CONTROL_STREAM) {
	setAttrParam.fileID.serverID = attrPtr->serverID;
    }
    storage.requestParamPtr = (Address) &setAttrParam;
    storage.requestParamSize = sizeof(FsRemoteSetAttrParams);
    storage.requestDataPtr = (Address) NIL;
    storage.requestDataSize = 0;

    storage.replyParamPtr = (Address) NIL;
    storage.replyParamSize = 0;
    storage.replyDataPtr = (Address) NIL;
    storage.replyDataSize = 0;

    status = Rpc_Call(fileIDPtr->serverID, RPC_FS_SET_IO_ATTR, &storage);
    /*
     * We punt on I/O server recovery, and mask errors so a chmod() works.
     */
    if (status != SUCCESS) {
	printf(
	    "FsRemoteSetIOAttr failed <%x>: device <%d,%d> at server %d\n",
	    status, fileIDPtr->major, fileIDPtr->minor, fileIDPtr->serverID);
	status = SUCCESS;
a188 111
}

/*
 *----------------------------------------------------------------------
 *
 * Fs_RpcSetIOAttr --
 *
 *	Service stub for the RPC_FS_SET_IO_ATTR call.  This calls
 *	the stream-type routine to set attributes cached at the I/O server.
 *
 * Results:
 *	If this procedure returns SUCCESS then a reply has been sent to
 *	the client.  If the arguments are bad then an error is 
 *	returned and the main level sends back an error reply.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Fs_RpcSetIOAttr(srvToken, clientID, command, storagePtr)
    ClientData 		 srvToken;	/* Handle on server process passed to
				 	 * Rpc_Reply */
    int 		 clientID;	/* Sprite ID of client host */
    int 		 command;	/* IGNORED */
    register Rpc_Storage *storagePtr;	/* The request fields refer to the 
					 * request buffers and also indicate 
					 * the exact amount of data in the 
					 * request buffers.  The reply fields 
					 * are initialized to NIL for the
				 	 * pointers and 0 for the lengths.  
					 * This can be passed to Rpc_Reply */
{
    register ReturnStatus	status;
    register FsHandleHeader	*hdrPtr;
    register Fs_FileID		*fileIDPtr;
    Fs_Attributes		*attrPtr;
    FsRemoteSetAttrParams	*setAttrParamPtr;

    setAttrParamPtr =
	    (FsRemoteSetAttrParams *) storagePtr->requestParamPtr;
    fileIDPtr = &(setAttrParamPtr->fileID);
    attrPtr = &(setAttrParamPtr->attrs);

   fsStats.srvName.setIOAttrs++;
   hdrPtr = VerifyIOHandle(fileIDPtr);
    if (hdrPtr == (FsHandleHeader *) NIL) {
	/*
	 * Noone has the I/O device open so we don't have a handle.
	 * Return SUCCESS but take no action.
	 */
	return(SUCCESS);
    } 
    FsHandleUnlock(hdrPtr);

    status = (*fsStreamOpTable[hdrPtr->fileID.type].setIOAttr)
	    (&hdrPtr->fileID, attrPtr, setAttrParamPtr->flags);
#ifdef lint
    status = FsDeviceSetIOAttr(&hdrPtr->fileID, attrPtr,setAttrParamPtr->flags);
    status = FsPipeSetIOAttr(&hdrPtr->fileID, attrPtr, setAttrParamPtr->flags);
    status = FsControlSetIOAttr(&hdrPtr->fileID, attrPtr,
					setAttrParamPtr->flags);
#endif lint

    FsHandleRelease(hdrPtr, FALSE);

    /*
     * No clean-up call-back needed because there are no reply parameters.
     */
    Rpc_Reply(srvToken, status, storagePtr, (int (*)())NIL, (ClientData)NIL);
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * VerifyIOHandle --
 *
 *	Verify an I/O handle from a remote client.  This is only used when
 *	getting/setting attributes.  We do not require that the client be
 *	listed for the I/O handle because in two important cases it won't be.
 *	The first is if we are the I/O server for a device, and someone
 *	does a Fs_GetAttributes(pathname, ...).  We are contacted for the
 *	latest I/O attributes, and the client won't have opened the device.
 *	The second case is if we are the name server and someone is doing
 *	a Fs_GetAttributesID(streamID, ...).  Here the I/O server has the
 *	client in its list, but we (the name server) do not.
 *
 * Results:
 *	A locked pointer to the I/O handle if it exists.
 *
 * Side effects:
 *	The returned handle must be released because we fetch it here.
 *
 *----------------------------------------------------------------------
 */
FsHandleHeader *
VerifyIOHandle(fileIDPtr)
    Fs_FileID *fileIDPtr;
{
    if (fileIDPtr->type <= 0 || fileIDPtr->type >= FS_NUM_STREAM_TYPES) {
	printf(
		"Bad stream type (%d) in VerifyIOHandle.\n",
		fileIDPtr->type);
	return((FsHandleHeader *)NIL);
    } else {
	fileIDPtr->type = fsRmtToLclType[fileIDPtr->type];
    }
    return(FsHandleFetch(fileIDPtr));
@


8.5
log
@Added counters of attribute related calls
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsAttributes.c,v 8.4 89/03/17 12:49:44 brent Exp $ SPRITE (Berkeley)";
d234 4
a237 1
     * Take creation and descriptor modify time from disk descriptor.
d243 3
@


8.4
log
@Fixed indentation
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsAttributes.c,v 8.3 89/01/25 09:51:02 brent Exp $ SPRITE (Berkeley)";
d112 1
d126 1
d325 1
d337 1
a337 3
	if (status == SUCCESS) {
	    fsStats.gen.numSetAttrs ++;
	}
d657 1
d814 2
d974 1
d1117 1
d1253 1
d1392 2
a1393 1
    hdrPtr = VerifyIOHandle(fileIDPtr);
@


8.3
log
@Patched FsGet/SetRemoteIOAttr routines to handle FS_RMT_CONTROL_STREAMS
which need 2 lines of special hanling.
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsAttributes.c,v 8.2 89/01/24 12:22:19 brent Exp $ SPRITE (Berkeley)";
d565 6
a570 6
	 /*
	  * The return param area has a fileID that we need.  The
	  * return parameter area has also been filled in with
	  * the attributes.
	  */
	 *(getAttrResultsPtr->fileIDPtr) =
d572 3
a574 3
	 *(getAttrResultsPtr->attrPtr) =
		     getAttrResultsParam.attrResults.attrs;
	} else if (status == FS_LOOKUP_REDIRECT) {
@


8.2
log
@Added pdev get/set IO routines
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsAttributes.c,v 8.1 88/12/07 08:23:23 brent Exp $ SPRITE (Berkeley)";
d119 1
a119 1
	    status = FsPseudoStreamGetIOAttr(&hdrPtr->fileID, rpc_SpriteID,
d121 2
d330 2
a331 1
	    status = FsPseudoStreamSetIOAttr(&hdrPtr->fileID, attrPtr, flags);
d1159 13
d1253 1
a1253 1
	status = FsPseudoStreamGetIOAttr(&hdrPtr->fileID, rpc_SpriteID,attrPtr);
d1305 13
d1400 1
a1400 1
    status = FsPseudoStreamSetIOAttr(&hdrPtr->fileID, attrPtr,
@


8.1
log
@Fixed Fs_RpcGetIOAttr stub to return a reply.
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsAttributes.c,v 7.0 88/11/11 15:28:52 brent Exp $ SPRITE (Berkeley)";
d119 2
d328 1
d1237 1
d1371 2
@


8.0
log
@Changing version numbers.
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsAttributes.c,v 7.0 88/11/11 15:28:52 brent Exp Locker: douglis $ SPRITE (Berkeley)";
d1223 1
a1223 1
    if (hdrPtr == (FsHandleHeader *) NIL) {
d1225 2
a1226 2
	 * Noone has the I/O device open so we don't have a handle.
	 * Return SUCCESS but no reply data.
d1228 3
a1230 6
	return(SUCCESS);
    } 
    FsHandleUnlock(hdrPtr);

    status = (*fsStreamOpTable[hdrPtr->fileID.type].getIOAttr)
	    (&hdrPtr->fileID, clientID, attrPtr);
d1232 2
a1233 2
    status = FsDeviceGetIOAttr(&hdrPtr->fileID, rpc_SpriteID, attrPtr);
    status = FsPipeGetIOAttr(&hdrPtr->fileID, rpc_SpriteID, attrPtr);
d1235 7
a1241 3

    FsHandleRelease(hdrPtr, FALSE);

@


7.0
log
@New version for conversion to new C library
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsAttributes.c,v 6.13 88/10/22 15:11:22 brent Exp Locker: brent $ SPRITE (Berkeley)";
@


6.13
log
@Fixed attributes operations on open streams to handle pseudo-device
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 6.12 88/10/14 12:13:46 brent Exp $ SPRITE (Berkeley)";
a44 1
#include "mem.h"
d88 1
a88 1
	    Byte_Zero(sizeof(Fs_Attributes), (Address)attrPtr);
d99 1
a99 1
	    status = FsSpriteGetAttr(&nameInfoPtr->fileID,rpc_SpriteID,attrPtr);
d103 1
a103 1
		Sys_Panic(SYS_WARNING,
d152 1
a152 1
	Sys_Panic(SYS_FATAL, "FsLocalGetAttr, bad fileID type <%d>\n",
d164 1
a164 1
		Byte_Zero(sizeof(Fs_Attributes), (Address)attrPtr);
d309 1
a309 1
	    status = FsSpriteSetAttr(&nameInfoPtr->fileID, attrPtr,idPtr,flags);
d380 1
a380 1
	Sys_Panic(SYS_WARNING,
d388 1
a388 1
	Sys_Panic(SYS_WARNING, "FsLocalSetAttr, NIL descPtr\n");
d500 1
a500 1
typedef struct FsSpriteGetAttrResults {
d503 1
a503 1
} FsSpriteGetAttrResults;
d509 1
a509 1
 * FsSpriteGetAttrPath --
d526 1
a526 1
FsSpriteGetAttrPath(prefixHandle, relativeName, argsPtr, resultsPtr,
d550 1
a550 1
    storage.requestDataSize = String_Length(relativeName) + 1;
d572 1
a572 1
	*newNameInfoPtrPtr = Mem_New(FsRedirectInfo);
d574 1
a574 1
	(void)String_Copy(replyName, (*newNameInfoPtrPtr)->fileName);
d645 1
a645 1
    getAttrResultsParamPtr = Mem_New(FsGetAttrResultsParam);
d666 1
a666 1
	storagePtr->replyDataSize = String_Length(newNameInfoPtr->fileName) + 1;
d668 3
a670 4
		(Address) Mem_Alloc(storagePtr->replyDataSize);
	(void)String_Copy(newNameInfoPtr->fileName,
			  (char *) storagePtr->replyDataPtr);
	Mem_Free((Address)newNameInfoPtr);
d675 1
a675 1
        replyMemPtr = (Rpc_ReplyMem *) Mem_Alloc(sizeof(Rpc_ReplyMem));
d682 1
a682 1
	Mem_Free((Address) getAttrResultsParamPtr);
d691 1
a691 1
 * FsSpriteSetAttrPath --
d708 1
a708 1
FsSpriteSetAttrPath(prefixHandle, relativeName, argsPtr, resultsPtr,
d726 1
a726 1
    storage.requestDataSize = String_Length(relativeName) + 1;
d745 1
a745 1
	*newNameInfoPtrPtr = Mem_New(FsRedirectInfo);
d747 1
a747 1
	(void)String_Copy(replyName, (*newNameInfoPtrPtr)->fileName);
d807 1
a807 1
    getAttrResultsParamPtr = Mem_New(FsGetAttrResultsParam);
d826 1
a826 1
	storagePtr->replyDataSize = String_Length(newNameInfoPtr->fileName) + 1;
d828 3
a830 4
		(Address) Mem_Alloc(storagePtr->replyDataSize);
	(void)String_Copy(newNameInfoPtr->fileName,
		(char *) storagePtr->replyDataPtr);
	Mem_Free((Address)newNameInfoPtr);
d835 1
a835 1
        replyMemPtr = (Rpc_ReplyMem *) Mem_Alloc(sizeof(Rpc_ReplyMem));
d842 1
a842 1
	Mem_Free((Address)getAttrResultsParamPtr);
d850 1
a850 1
 * FsSpriteGetAttr --
d866 1
a866 1
FsSpriteGetAttr(fileIDPtr, clientID, attrPtr)
d964 1
a964 1
    attrPtr = Mem_New(Fs_Attributes);
d974 1
a974 1
    replyMemPtr = (Rpc_ReplyMem *) Mem_Alloc(sizeof(Rpc_ReplyMem));
d988 1
a988 1
typedef struct FsSpriteSetAttrParams {
d993 1
a993 1
} FsSpriteSetAttrParams;
d998 1
a998 1
 * FsSpriteSetAttr
d1014 1
a1014 1
FsSpriteSetAttr(fileIDPtr, attrPtr, idPtr, flags)
d1022 1
a1022 1
    FsSpriteSetAttrParams params;
d1029 1
a1029 1
    storage.requestParamSize = sizeof(FsSpriteSetAttrParams);
d1086 1
a1086 1
    FsSpriteSetAttrParams	*paramPtr;
d1089 1
a1089 1
    paramPtr = (FsSpriteSetAttrParams *) storagePtr->requestParamPtr;
d1169 1
a1169 1
	Sys_Panic(SYS_WARNING,
d1279 1
a1279 1
    FsSpriteSetAttrParams	setAttrParam;
d1285 1
a1285 1
    storage.requestParamSize = sizeof(FsSpriteSetAttrParams);
d1299 1
a1299 1
	Sys_Panic(SYS_WARNING,
d1344 1
a1344 1
    FsSpriteSetAttrParams	*setAttrParamPtr;
d1347 1
a1347 1
	    (FsSpriteSetAttrParams *) storagePtr->requestParamPtr;
d1405 1
a1405 1
	Sys_Panic(SYS_WARNING,
@


6.12
log
@FsFileID FsUserID change
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 6.11 88/10/13 09:51:08 brent Exp $ SPRITE (Berkeley)";
a877 5
    if (fileIDPtr->type != FS_RMT_FILE_STREAM) {
	Sys_Panic(SYS_FATAL, "FsSpriteGetAttr, bad fileID type <%d>\n",
	    fileIDPtr->type);
	return(GEN_INVALID_ARG);
    }
d912 1
a912 1
 *	to get the attributes of a file from its disk descriptor.  This
d948 1
d952 6
a957 1
    if (hdrPtr == (FsHandleHeader *)NIL) {
d968 5
a972 1
    status = FsLocalGetAttr(&hdrPtr->fileID, clientID, attrPtr);
a1026 6
    if (fileIDPtr->type != FS_RMT_FILE_STREAM) {
	Sys_Panic(SYS_FATAL, "FsSpriteSetAttr, bad fileID type <%d>\n",
	    fileIDPtr->type);
	return(GEN_INVALID_ARG);
    }

d1090 1
d1097 6
a1102 1
    if (hdrPtr == (FsHandleHeader *)NIL) {
d1104 1
a1104 1
				       (FsLocalFileIOHandle **)&hdrPtr);
d1110 3
d1114 2
d1407 7
a1413 21
    switch(fileIDPtr->type) {
	case FS_LCL_FILE_STREAM:
	case FS_LCL_DEVICE_STREAM:
	    break;
	case FS_RMT_FILE_STREAM:
	    fileIDPtr->type = FS_LCL_FILE_STREAM;
	    break;
	case FS_RMT_DEVICE_STREAM:
	    fileIDPtr->type = FS_LCL_DEVICE_STREAM;
	    break;
        case FS_RMT_PSEUDO_STREAM:
	    fileIDPtr->type = FS_LCL_PSEUDO_STREAM;
	    break;
	case FS_RMT_PIPE_STREAM:
	    fileIDPtr->type = FS_LCL_PIPE_STREAM;
	    break;
	default:
	    Sys_Panic(SYS_WARNING,
		    "Unknown stream type (%d) in VerifyIOHandle.\n",
		    fileIDPtr->type);
	    return((FsHandleHeader *)NIL);
@


6.11
log
@Updated #ifdef lint calls through switch table.
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 6.10 88/10/05 12:07:14 brent Exp $ SPRITE (Berkeley)";
d147 1
a147 1
    register FsFileID		*fileIDPtr;	/* Identfies file */
d292 1
a292 1
    FsUserIDs *idPtr;		/* Owner and groups of calling process */
d369 1
a369 1
    FsFileID			*fileIDPtr;	/* Target file. */
d371 1
a371 1
    register FsUserIDs		*idPtr;		/* Process's owner/group */
d503 1
a503 1
    FsFileID		fileID;
d723 1
a723 1
    FsFileID			*fileIDPtr;
d734 1
a734 1
    fileIDPtr = (FsFileID *) resultsPtr;
d789 1
a789 1
    FsFileID			*ioFileIDPtr;	/* Results from local routine */
d870 1
a870 1
    register FsFileID		*fileIDPtr;	/* Identfies file */
d884 1
a884 1
    storage.requestParamSize = sizeof(FsFileID);
d950 1
a950 1
    register FsFileID		*fileIDPtr;
d954 1
a954 1
    fileIDPtr = (FsFileID *) storagePtr->requestParamPtr;
d987 2
a988 2
    FsFileID		fileID;
    FsUserIDs		ids;
d1013 1
a1013 1
    FsFileID		*fileIDPtr;
d1015 1
a1015 1
    FsUserIDs		 *idPtr;
d1087 1
a1087 1
    register FsFileID		*fileIDPtr;
d1134 1
a1134 1
    register FsFileID		*fileIDPtr;	/* Remote device/pipe fileID */
d1206 1
a1206 1
    register FsFileID		*fileIDPtr;
d1266 1
a1266 1
    register FsFileID		*fileIDPtr;	/* Remote device/pipe fileID */
d1335 1
a1335 1
    register FsFileID		*fileIDPtr;
d1395 1
a1395 1
    FsFileID *fileIDPtr;
@


6.10
log
@Added domainTypePtr parameter to the clientVerify routine
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 6.9 88/09/28 08:31:03 brent Exp $ SPRITE (Berkeley)";
d101 1
d311 1
@


6.9
log
@Fixed allocation of buffer for redirected pathname.
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 6.8 88/09/23 13:33:49 brent Exp $ SPRITE (Berkeley)";
d626 1
d637 1
a637 1
	    (&openArgsPtr->prefixID, clientID);
d649 1
a649 1
    status = FsLocalGetAttrPath(prefixHandle,
d794 1
d800 1
a800 1
	    (&setAttrArgsPtr->openArgs.prefixID, clientID);
d809 1
a809 1
    status = FsLocalSetAttrPath(prefixHandle,
@


6.8
log
@Tweaked print statement
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 6.7 88/09/14 12:45:35 brent Exp $ SPRITE (Berkeley)";
d569 1
a569 2
	 * Allocate enough space to fit the prefix length and the file name and
	 * copy over the structure that we have on our stack.
d571 1
a571 3
	register int	redirectSize;
	redirectSize = sizeof(int) + String_Length(replyName) + 1;
	*newNameInfoPtrPtr = (FsRedirectInfo *) Mem_Alloc(redirectSize);
d742 1
a742 2
	 * Allocate enough space to fit the prefix length and the file name and
	 * copy over the info.
d744 1
a744 3
	register int redirectSize;
	redirectSize = sizeof(int) + String_Length(replyName) + 1;
	*newNameInfoPtrPtr = (FsRedirectInfo *) Mem_Alloc(redirectSize);
@


6.7
log
@Fixed Get/Set I/O Attr routines so a remote device that isn't
opened by anyone won't cause errors
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 6.6 88/09/07 16:51:34 brent Exp $ SPRITE (Berkeley)";
d380 1
a380 1
		"FsLocalSetAttr, no handle for %s <%d,%d> from server %d\n",
d382 1
a382 1
		fileIDPtr->major, fileIDPtr->minor, fileIDPtr->serverID);
@


6.6
log
@Moved name from stream to I/O handle.
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 6.5 88/09/01 17:13:36 brent Exp $ SPRITE (Berkeley)";
d1161 1
a1161 1
     * I/O Server recovery??	TODO
d1163 7
d1219 5
a1223 1
	return(FS_STALE_HANDLE);
d1291 1
a1291 1
     * I/O Server recovery??	TODO
d1293 6
d1348 5
a1352 1
	return(FS_STALE_HANDLE);
@


6.5
log
@Added use of FsFileTypeToString for better error messages
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 6.4 88/08/31 12:03:38 brent Exp $ SPRITE (Berkeley)";
d105 1
a105 3
		    status,
		    (nameInfoPtr->name == (char *)NIL) ? "(no name)" :
							 nameInfoPtr->name);
d162 1
a162 1
	    status = FsLocalFileHandleInit(fileIDPtr, &handlePtr);
d959 1
a959 1
	status = FsLocalFileHandleInit(fileIDPtr,
d1100 1
a1100 1
	status = FsLocalFileHandleInit(fileIDPtr,
@


6.4
log
@Removed lint.
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 6.3 88/08/18 17:58:50 brent Exp $ SPRITE (Berkeley)";
d381 4
a384 3
	Sys_Panic(SYS_WARNING, "FsLocalSetAttr, no handle <%d,%d,%d,%d>\n",
		    fileIDPtr->type, fileIDPtr->serverID,
		    fileIDPtr->major, fileIDPtr->minor);
@


6.3
log
@Fixed setting of attributes
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 6.2 88/08/16 11:23:46 brent Exp $ SPRITE (Berkeley)";
d41 1
d481 2
a482 1
	FsStoreFileDesc(domainPtr, handlePtr->hdr.fileID.minor, descPtr);
d485 6
a490 4
    /*
     * Update the attributes cached in the file handle.
     */
    FsUpdateCachedAttr(&handlePtr->cacheInfo, attrPtr, flags);
d577 1
a577 1
	String_Copy(replyName, (*newNameInfoPtrPtr)->fileName);
d671 3
a673 2
	String_Copy(newNameInfoPtr->fileName, (char *) storagePtr->replyDataPtr);
	Mem_Free(newNameInfoPtr);
d753 1
a753 1
	String_Copy(replyName, (*newNameInfoPtrPtr)->fileName);
d834 1
a834 1
	String_Copy(newNameInfoPtr->fileName,
d836 1
a836 1
	Mem_Free(newNameInfoPtr);
d848 1
a848 1
	Mem_Free(getAttrResultsParamPtr);
@


6.2
log
@Removed lint.
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 6.1 88/08/13 11:27:03 brent Exp $ SPRITE (Berkeley)";
d342 1
d346 11
d358 2
a359 1
 *	An error code.
d362 1
a362 1
 *	None.
d371 1
a371 1
    int				flags;		/* What attrs to set */
d391 1
a391 1
    if (!FsOwner(idPtr, descPtr)) {
a401 1
#ifdef not_yet
a402 1
#endif
d409 4
d416 3
a423 1
#ifdef not_yet
a424 1
#endif
d429 20
d463 1
a463 1
	 * Patch this because it gets copied by FsUpdateCachedAttr.
a489 37
}

/*
 *----------------------------------------------------------------------
 *
 * FsOwner --
 *
 *	Determine if the process owns the file.
 *
 * Results:
 *	TRUE if the owner ID or group owner ID of the process
 *	match with that of the file.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
Boolean
FsOwner(idPtr, descPtr)
    FsUserIDs *idPtr;
    FsFileDescriptor *descPtr;
{
    register int index;

    if (idPtr->user == 0) {
	return(TRUE);
    }
    if (idPtr->user == descPtr->uid) {
	return(TRUE);
    }
    for (index=0 ; index < idPtr->numGroupIDs ; index++) {
	if (idPtr->group[index] == descPtr->gid) {
	    return(TRUE);
	}
    }
    return(FALSE);
@


6.1
log
@Added flags to SetAttr routines that indicate what attributes to update.
Also added call to update cached attributes that seemed to have
been missing before.  RPC interface changed.
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 1.12 88/08/11 12:11:59 mlgray Exp $ SPRITE (Berkeley)";
d1335 2
a1336 2
    status = FsDeviceSetIOAttr(&hdrPtr->fileID, attrPtr, flags);
    status = FsPipeSetIOAttr(&hdrPtr->fileID, attrPtr, flags);
@


6.0
log
@Changing version numbers.
@
text
@d97 4
d115 6
d289 5
a293 4
Fs_SetAttrStream(streamPtr, attrPtr, idPtr)
    Fs_Stream *streamPtr;
    Fs_Attributes *attrPtr;
    FsUserIDs *idPtr;
d307 5
a311 1
			(&nameInfoPtr->fileID, attrPtr, idPtr);
d320 7
a326 1
			(&hdrPtr->fileID, attrPtr);
d342 2
a343 1
 *	This updates the disk descriptor and pushes it to disk.
d354 5
a358 4
FsLocalSetAttr(fileIDPtr, attrPtr, idPtr)
    register FsFileID		*fileIDPtr;
    register Fs_Attributes	*attrPtr;
    FsUserIDs *idPtr;
a363 1
    int				g;
d382 13
a394 30
    descPtr->permissions = attrPtr->permissions;
       
    if (descPtr->fileType == FS_DEVICE ||
              descPtr->fileType == FS_REMOTE_DEVICE) {
	  descPtr->devServerID = attrPtr->devServerID;
	  descPtr->devType = attrPtr->devType;
	  descPtr->devUnit = attrPtr->devUnit;
    }
    descPtr->accessTime       = attrPtr->accessTime.seconds;
    descPtr->dataModifyTime   = attrPtr->dataModifyTime.seconds;
    descPtr->descModifyTime   = fsTimeInSeconds;
       
    descPtr->userType    = attrPtr->userType;

    /*
     * Set the cached user file type in the handle, unless it's specified
     * as undefined.
     */
    if (attrPtr->userType != FS_USER_TYPE_UNDEFINED) {
	handlePtr->cacheInfo.attr.userType = attrPtr->userType;
    }

    if (attrPtr->uid >= 0 && descPtr->uid != attrPtr->uid) {
	if (idPtr->user != 0) {
	    /*
	     * Don't let people give away ownership.
	     */
	    status = FS_NO_ACCESS;
	} else {
	    descPtr->uid = attrPtr->uid;
d396 7
a402 6
    }
    if (attrPtr->gid >= 0 && descPtr->gid != attrPtr->gid) {
	for (g=0 ; g < idPtr->numGroupIDs; g++) {
	    if (attrPtr->gid == idPtr->group[g] || idPtr->user == 0) {
		descPtr->gid = attrPtr->gid;
		break;
d404 6
d411 10
a420 2
	if (g >= idPtr->numGroupIDs) {
	    status = FS_NO_ACCESS;
d423 8
d432 4
d437 1
a437 1
     * Make sure this new info gets to disk.
d439 1
d447 4
a798 6
    if (setAttrArgsPtr->openArgs.prefixID.serverID != rpc_SpriteID) {
	/*
	 * Filesystem mis-match.
	 */
	return(GEN_INVALID_ARG);
    }
d981 2
a982 1
 * Parameters for RPC_FS_SET_ATTR.
d989 1
d1011 1
a1011 1
FsSpriteSetAttr(fileIDPtr, attrPtr, idPtr)
d1015 1
d1030 1
d1104 1
a1104 1
    status = FsLocalSetAttr(fileIDPtr, attrPtr, &paramPtr->ids);
d1116 1
a1116 1
 * FsSpriteGetIOAttr --
d1118 1
a1118 1
 *	Get the attributes cached at the I/O server.  This makes the
d1132 1
a1132 1
FsSpriteGetIOAttr(fileIDPtr, clientID, attrPtr)
d1215 5
d1237 1
a1237 1
 * FsSpriteSetIOAttr --
d1239 1
a1239 1
 *	Set the attributes cached at the I/O server.  This makes the
d1253 1
a1253 1
FsSpriteSetIOAttr(fileIDPtr, attrPtr)
d1256 1
d1260 1
a1260 1
    FsGetAttrResultsParam	getAttrResultsParam;
d1262 5
a1266 4
    getAttrResultsParam.attrResults.fileID = *fileIDPtr;
    getAttrResultsParam.attrResults.attrs = *attrPtr;
    storage.requestParamPtr = (Address) &getAttrResultsParam;
    storage.requestParamSize = sizeof(FsGetAttrResultsParam);
d1319 1
a1319 1
    FsGetAttrResultsParam	*getAttrResultsParamPtr;
d1321 4
a1324 4
    getAttrResultsParamPtr =
	    (FsGetAttrResultsParam *) storagePtr->requestParamPtr;
    fileIDPtr = &(getAttrResultsParamPtr->attrResults.fileID);
    attrPtr = &(getAttrResultsParamPtr->attrResults.attrs);
d1333 6
a1338 1
	    (&hdrPtr->fileID, attrPtr);
@


1.12
log
@fixed core leak
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 1.11 88/08/11 10:42:50 brent Exp $ SPRITE (Berkeley)";
@


1.11
log
@Plugged core leak
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 1.10 88/08/05 14:13:48 douglis Exp $ SPRITE (Berkeley)";
d789 13
a801 16
    } else {
	if (status == FS_LOOKUP_REDIRECT) {
	    /*
	     * The file is not found on this server.
	     */
	    getAttrResultsParamPtr->prefixLength = newNameInfoPtr->prefixLength;
	    storagePtr->replyParamPtr = (Address) getAttrResultsParamPtr;
	    storagePtr->replyParamSize = sizeof(FsGetAttrResultsParam);
	    storagePtr->replyDataSize =
		    String_Length(newNameInfoPtr->fileName) + 1;
	    storagePtr->replyDataPtr =
		    (Address) Mem_Alloc(storagePtr->replyDataSize);
	    String_Copy(newNameInfoPtr->fileName,
		    (char *) storagePtr->replyDataPtr);
	    Mem_Free(newNameInfoPtr);
	}
d813 1
@


1.10
log
@Changes to support keeping track of file deletions, certain FS system
calls, and large fsStat counters, ported from the old filesystem.
This ci message is generic.
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 1.9 88/08/04 15:01:27 mlgray Exp $ SPRITE (Berkeley)";
d644 1
@


1.9
log
@merging changes from fs to fs.new
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 1.8 88/08/03 17:17:48 mlgray Exp $ SPRITE (Berkeley)";
d214 1
d254 1
a254 1
    attrPtr->userType			= descPtr->fileUsageType;
d273 1
d307 3
d372 9
a380 1
    descPtr->fileUsageType    = attrPtr->userType;
@


1.8
log
@works on Spur.
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 1.7 88/06/23 14:46:17 mlgray Exp $ SPRITE (Berkeley)";
d332 1
a332 1
    register ReturnStatus	status;
d355 14
d375 2
a376 1
	    goto exit;
a377 1
	descPtr->uid = attrPtr->uid;
a387 1
	    goto exit;
a389 1
    descPtr->permissions = attrPtr->permissions;
a390 12
    if (descPtr->fileType == FS_DEVICE ||
	descPtr->fileType == FS_REMOTE_DEVICE) {
	descPtr->devServerID = attrPtr->devServerID;
	descPtr->devType = attrPtr->devType;
	descPtr->devUnit = attrPtr->devUnit;
    }
    descPtr->accessTime       = attrPtr->accessTime.seconds;
    descPtr->dataModifyTime   = attrPtr->dataModifyTime.seconds;
    descPtr->descModifyTime   = fsTimeInSeconds;

    descPtr->fileUsageType    = attrPtr->userType;

a399 1
	status = SUCCESS;
d1326 6
d1333 3
a1335 2
	    Sys_Panic(SYS_WARNING, "Unknown stream type in VerifyIOHandle %d\n",
		fileIDPtr->type);
a1339 1

@


1.7
log
@First go-round at cleaning up parameters and data in preparation for
byte-swapping in the attributes calls.  This is an interim checkin
and probably doesn't even compile.
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 1.6 88/06/15 11:52:22 brent Exp $ SPRITE (Berkeley)";
d668 1
a668 1
    char			replyName[FS_MAX_PATH_LENGTH];
d679 1
a679 1
    storage.replyDataSize = FS_MAX_PATH_LENGTH;
d773 1
a773 1
	storagePtr->replyParamSize = sizeof(getAttrResultsParam);
d788 1
a788 1
	    String_Copy(nwNameInfoPtr->fileName,
@


1.6
log
@Fixed FsAssignAttrs to use cached values of modifyTime, accessTime and size.
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 1.5 88/06/08 14:56:33 brent Exp $ SPRITE (Berkeley)";
d486 1
d488 3
a490 3
    char		replyData[sizeof(FsRedirectInfo)];	 /* This
					 * gets filled with either a fileID
					 * or with a redirected pathname. */
d499 4
a502 4
    storage.replyParamPtr = (Address) getAttrResultsPtr->attrPtr;
    storage.replyParamSize = sizeof(Fs_Attributes);
    storage.replyDataPtr = (Address) replyData;
    storage.replyDataSize = sizeof(FsRedirectInfo);
d508 2
a509 2
	  * The return data area has a fileID that we need.  The
	  * return parameter area has already been filled in with
d512 5
a516 3
	 register FsFileID *fileIDPtr = (FsFileID *)replyData;
	 *getAttrResultsPtr->fileIDPtr = *fileIDPtr;
    } else if (status == FS_LOOKUP_REDIRECT) {
d522 1
a522 2
	register FsRedirectInfo *redirectPtr = (FsRedirectInfo *)replyData;
	redirectSize = sizeof(int) + String_Length(redirectPtr->fileName) + 1;
d524 2
a525 2
	(*newNameInfoPtrPtr)->prefixLength = redirectPtr->prefixLength;
	String_Copy(redirectPtr->fileName, (*newNameInfoPtrPtr)->fileName);
d569 4
a572 2
    register FsOpenArgs		 *openArgsPtr;	/* Tmp pointer into openParams*/
    FsGetAttrResults 		getAttrResults;	/* Results from local routine */
d575 3
a577 1
    FsRedirectInfo		*newNameInfoPtr;/* For prefix re-directs */
d595 5
a599 2
    getAttrResults.attrPtr = Mem_New(Fs_Attributes);
    getAttrResults.fileIDPtr = Mem_New(FsFileID);
d602 1
a602 1
		(Address)&getAttrResults, &newNameInfoPtr);
d605 16
a620 14
	storagePtr->replyParamPtr = (Address) getAttrResults.attrPtr;
	storagePtr->replyParamSize = sizeof(Fs_Attributes);
	storagePtr->replyDataPtr = (Address) getAttrResults.fileIDPtr;
	storagePtr->replyDataSize = sizeof(FsFileID);
    } else {
	Mem_Free((Address) getAttrResults.attrPtr);
	Mem_Free((Address) getAttrResults.fileIDPtr);
	if (status == FS_LOOKUP_REDIRECT) {
	    /*
	     * The file is not found on this server, but somewhere else.
	     */
	    storagePtr->replyDataPtr = (Address)newNameInfoPtr;
	    storagePtr->replyDataSize = sizeof(FsRedirectInfo);
	}
d662 1
a662 1
    Address        resultsPtr;	    /* == NIL */
d668 3
a670 1
    FsRedirectInfo		redirectInfo;
d676 4
a679 4
    storage.replyParamPtr = (Address) resultsPtr;
    storage.replyParamSize = sizeof(FsFileID);
    storage.replyDataPtr = (Address) &redirectInfo;
    storage.replyDataSize = sizeof(FsRedirectInfo);
d681 2
d685 1
a685 1
    if (status == FS_LOOKUP_REDIRECT) {
d687 5
d693 1
a693 1
	 * copy over the structure that we have on our stack.
d696 1
a696 1
	redirectSize = sizeof(int) + String_Length(redirectInfo.fileName) + 1;
d698 2
a699 2
	(*newNameInfoPtrPtr)->prefixLength = redirectInfo.prefixLength;
	String_Copy(redirectInfo.fileName, (*newNameInfoPtrPtr)->fileName);
d701 1
d744 2
d764 2
a765 1
    ioFileIDPtr = Mem_New(FsFileID);
d772 2
a773 2
	storagePtr->replyParamPtr = (Address) ioFileIDPtr;
	storagePtr->replyParamSize = sizeof(FsFileID);
a776 1
	Mem_Free((Address) ioFileIDPtr);
d781 10
a790 2
	    storagePtr->replyDataPtr = (Address)newNameInfoPtr;
	    storagePtr->replyDataSize = sizeof(FsRedirectInfo);
d945 1
d984 1
d987 2
a988 2
    storage.requestDataPtr = (Address) attrPtr;
    storage.requestDataSize = sizeof(Fs_Attributes);
d1046 1
a1046 1
    attrPtr = (Fs_Attributes *) storagePtr->requestDataPtr;
d1095 1
d1097 2
a1098 4
    storage.requestParamPtr = (Address) fileIDPtr;
    storage.requestParamSize = sizeof(FsFileID);
    storage.requestDataPtr = (Address) attrPtr;
    storage.requestDataSize = sizeof(Fs_Attributes);
d1100 5
d1154 1
d1156 4
a1159 1
    fileIDPtr = (FsFileID *) storagePtr->requestParamPtr;
a1166 1
    attrPtr = (Fs_Attributes *)storagePtr->requestDataPtr;
d1206 3
a1208 2
    register ReturnStatus status;
    Rpc_Storage storage;
d1210 6
a1215 4
    storage.requestParamPtr = (Address) fileIDPtr;
    storage.requestParamSize = sizeof(FsFileID);
    storage.requestDataPtr = (Address) attrPtr;
    storage.requestDataSize = sizeof(Fs_Attributes);
d1266 1
d1268 4
a1271 1
    fileIDPtr = (FsFileID *) storagePtr->requestParamPtr;
a1278 1
    attrPtr = (Fs_Attributes *)storagePtr->requestDataPtr;
@


1.5
log
@Plugged core leak
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 1.4 88/06/02 11:34:13 brent Exp $ SPRITE (Berkeley)";
d180 1
a180 1
 *	Assign the attributes in the file handle to an attribute structure.
d190 2
a191 1
 *	Attribute structure set to contain attributes from file handle.
d203 2
a204 1
    register FsFileDescriptor *descPtr;
a205 1
    descPtr = handlePtr->descPtr;
a211 4
    attrPtr->size			= descPtr->lastByte + 1;
    if (descPtr->firstByte >= 0) {
	attrPtr->size			-= descPtr->firstByte;
    }
d217 3
d224 9
a232 1
    attrPtr->dataModifyTime.seconds	= descPtr->dataModifyTime;
d237 1
a237 1
	attrPtr->accessTime.seconds	= descPtr->accessTime;
d240 11
a250 1
    attrPtr->blocks			= descPtr->numKbytes;
@


1.4
log
@Fixed set attributes so you can't give away ownership of a file.
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 1.3 88/06/01 16:53:59 brent Exp $ SPRITE (Berkeley)";
d582 1
a582 4
    } else if (status == FS_LOOKUP_REDIRECT) {
	/*
	 * The file is not found on this server.
	 */
d585 7
a591 2
	storagePtr->replyDataPtr = (Address)newNameInfoPtr;
	storagePtr->replyDataSize = sizeof(FsRedirectInfo);
d734 1
a734 4
    } else if (status == FS_LOOKUP_REDIRECT) {
	/*
	 * The file is not found on this server.
	 */
d736 7
a742 2
	storagePtr->replyDataPtr = (Address)newNameInfoPtr;
	storagePtr->replyDataSize = sizeof(FsRedirectInfo);
@


1.3
log
@Put in checks against 'old filesystem' clients
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 1.2 88/04/11 17:39:52 brent Exp $ SPRITE (Berkeley)";
a203 25
#ifdef file_specific_junk
    if (handlePtr->rec.fileType == FS_LOCAL_PIPE) {
	Byte_Zero(sizeof(Fs_Attributes), (Address) attrPtr);
	attrPtr->type				= FS_LOCAL_PIPE;
	attrPtr->devType			= -1;
	attrPtr->devUnit			= -1;
    } else if ((handlePtr->rec.fileType == FS_XTRA_FILE) &&
	       (handlePtr->rec.fileID.openInstance > 0)) {
	/*
	 * Cloned handles from pseudo devices don't have good attributes yet.
	 * We might try fetching the parent, but I'd rather wait for a new
	 * data structure organization that does this part right.
	 */
	Byte_Zero(sizeof(Fs_Attributes), (Address) attrPtr);
	attrPtr->type				= FS_PSEUDO_DEV;
    } else if (handlePtr->nameToken == (ClientData) NIL) {
        /*
	 * Devices for now go to the wrong place so just zero out the structure
	 * and return.
	 */
	Sys_Panic(SYS_WARNING, "FsAssignAttr: NIL name token\n");
	Byte_Zero(sizeof(Fs_Attributes), (Address) attrPtr);
    } else {
#endif file_specific_junk

d318 1
d337 22
a358 2
    descPtr->uid = attrPtr->uid;
    descPtr->gid = attrPtr->gid;
@


1.2
log
@Changed nameInfoStruct
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsAttributes.c,v 1.1 88/04/04 10:28:52 brent Exp $ SPRITE (Berkeley)";
d561 6
d710 6
@


1.1
log
@Initial revision
@
text
@d30 1
a30 1
static char rcsid[] = "$Header: fsFileOps.c,v 5.6 87/10/21 10:19:12 brent Exp $ SPRITE (Berkeley)";
d95 1
a95 1
	    status = (*fsAttrOpTable[nameInfoPtr->nameDomain].getAttr)
d300 1
a300 1
	    status = (*fsAttrOpTable[nameInfoPtr->nameDomain].setAttr)
@
