head     9.10;
branch   ;
access   ;
symbols  ds3100:9.10 sun3:9.10 sprited:9.6.1 sun4nw:9.8 symm:9.8 spur:9.8 Summer89:9.0 newlib:8.0;
locks    ; strict;
comment  @ * @;


9.10
date     92.08.10.17.30.02;  author mgbaker;  state Exp;
branches ;
next     9.9;

9.9
date     91.12.12.12.00.26;  author mgbaker;  state Exp;
branches ;
next     9.8;

9.8
date     91.09.16.15.59.03;  author mottsmth;  state Exp;
branches ;
next     9.7;

9.7
date     91.09.06.15.57.59;  author mottsmth;  state Exp;
branches ;
next     9.6;

9.6
date     91.06.26.01.05.40;  author mottsmth;  state Exp;
branches 9.6.1.1;
next     9.5;

9.5
date     91.06.23.16.43.51;  author mottsmth;  state Exp;
branches ;
next     9.4;

9.4
date     91.03.20.23.22.00;  author kupfer;  state Exp;
branches ;
next     9.3;

9.3
date     90.12.06.21.56.23;  author jhh;  state Exp;
branches ;
next     9.2;

9.2
date     90.10.08.12.41.35;  author mendel;  state Exp;
branches ;
next     9.1;

9.1
date     89.10.26.18.37.44;  author brent;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.08.22;  author douglis;  state Stable;
branches ;
next     8.9;

8.9
date     89.08.21.15.27.56;  author mendel;  state Exp;
branches ;
next     8.8;

8.8
date     89.06.15.09.22.28;  author brent;  state Exp;
branches ;
next     8.7;

8.7
date     89.05.14.15.25.52;  author brent;  state Exp;
branches ;
next     8.6;

8.6
date     89.04.09.12.20.23;  author brent;  state Exp;
branches ;
next     8.5;

8.5
date     89.03.21.17.07.04;  author douglis;  state Exp;
branches ;
next     8.4;

8.4
date     89.01.25.13.32.03;  author brent;  state Exp;
branches ;
next     8.3;

8.3
date     89.01.25.09.55.37;  author brent;  state Exp;
branches ;
next     8.2;

8.2
date     89.01.19.09.43.09;  author brent;  state Exp;
branches ;
next     8.1;

8.1
date     88.12.21.10.18.19;  author brent;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.25.09;  author douglis;  state Stable;
branches ;
next     7.0;

7.0
date     88.11.11.15.35.53;  author brent;  state Exp;
branches ;
next     6.6;

6.6
date     88.11.02.11.07.13;  author brent;  state Exp;
branches ;
next     6.5;

6.5
date     88.10.22.15.20.23;  author brent;  state Exp;
branches ;
next     6.4;

6.4
date     88.10.20.15.48.31;  author brent;  state Exp;
branches ;
next     6.3;

6.3
date     88.10.19.09.57.38;  author brent;  state Exp;
branches ;
next     6.2;

6.2
date     88.10.14.12.19.33;  author brent;  state Exp;
branches ;
next     6.1;

6.1
date     88.10.14.10.42.17;  author brent;  state Exp;
branches ;
next     6.0;

6.0
date     88.10.11.15.56.00;  author brent;  state Exp;
branches ;
next     1.3;

1.3
date     88.10.10.11.32.41;  author douglis;  state Exp;
branches ;
next     1.2;

1.2
date     88.10.05.16.59.55;  author brent;  state Exp;
branches ;
next     1.1;

1.1
date     88.10.03.09.05.26;  author brent;  state Exp;
branches ;
next     ;

9.6.1.1
date     91.11.15.16.31.29;  author kupfer;  state Exp;
branches ;
next     ;


desc
@Pseduo-device setup routines.
@


9.10
log
@Changes for transparent server recovery.
@
text
@/* 
 * fsPdevSetup.c --
 *
 *	Open/Close/Migration routines for pseudo-devices.
 *	
 *	There are three kinds of streams involved in the implementation,
 *	a "control" stream that is returned to the server when it first
 *	opens the pseudo-device.  When a client opens the pseudo-device
 *	two streams are created and looked together.  The "client" stream
 *	is returned to the client process, and the "server" stream is
 *	passed to the server process via the control stream.
 *
 * Copyright 1987, 1988 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fspdev/fspdevSetup.c,v 9.9 91/12/12 12:00:26 mgbaker Exp $ SPRITE (Berkeley)";
#endif not lint

#include <sprite.h>
#include <fs.h>
#include <fsutil.h>
#include <fsNameOps.h>
#include <fsio.h>
#include <fsconsist.h>
#include <fsdm.h>
#include <fsioLock.h>
#include <proc.h>
#include <rpc.h>
#include <fspdevInt.h>
#include <fspdev.h>
#include <fsrecov.h>
#include <recov.h>

/*
 *----------------------------------------------------------------------------
 *
 * FspdevNameOpen --
 *
 *	Early open time processing, this is called on a fileserver
 *	when setting up state for a call to the CltOpen routines on
 *	the client host.  For pseudo-device server processes, which
 *	are indicated by the FS_PDEV_MASTER flag, check that no other
 *	server exists.  For all other processes, which are referred to
 *	as "clients", make sure that a server process exists and
 *	generate a new ioFileID for the connection between the client
 *	and the server.
 *
 * Results:
 *	For server processes, SUCCESS if it is now the server,
 *	FS_FILE_BUSY if there already exists a server process.  For
 *	clients, SUCCESS if there is a server or the parameters
 *	indicate this is only for get/set attributes, DEV_OFFLINE if
 *	there is no server. 
 *
 * Side effects:
 *	Save the hostID of the calling process if
 *	it is to be the server for the pseudo-device.
 *
 *----------------------------------------------------------------------------
 *
 */
ReturnStatus
FspdevNameOpen(handlePtr, openArgsPtr, openResultsPtr)
     register Fsio_FileIOHandle *handlePtr;	/* A handle from FslclLookup.
					 * Should be LOCKED upon entry,
					 * unlocked upon exit. */
     Fs_OpenArgs		*openArgsPtr;	/* Standard open arguments */
     Fs_OpenResults	*openResultsPtr;/* For returning ioFileID, streamID,
					 * and Fsio_DeviceState */
{
    register	ReturnStatus status = SUCCESS;
    Fs_FileID	ioFileID;
    register	Fspdev_ControlIOHandle *ctrlHandlePtr;
    register	Fs_Stream *streamPtr;
    register	Fspdev_State *pdevStatePtr;
    Fsrecov_HandleState		recovInfo;

    /*
     * The control I/O handle is identified by the fileID of the pseudo-device
     * file with type CONTROL, and with the decriptor version number
     * xor'ed into the minor number to avoid conflict when you delete the
     * pdev file and recreate one with the same file number (minor field).
     */
    ioFileID = handlePtr->hdr.fileID;
    ioFileID.type = FSIO_CONTROL_STREAM;
    ioFileID.serverID = rpc_SpriteID;
    ioFileID.major = handlePtr->hdr.fileID.major;
    ioFileID.minor = handlePtr->hdr.fileID.minor ^
		    (handlePtr->descPtr->version << 16);
    ctrlHandlePtr = FspdevControlHandleInit(&ioFileID, handlePtr->hdr.name);

    if (openArgsPtr->useFlags & FS_PDEV_MASTER) {
	/*
	 * When a server opens we ensure there is only one.
	 */
	if (ctrlHandlePtr->serverID != NIL) {
	    status = FS_FILE_BUSY;
printf("FspdevNameOpen: file busy: clientID is %d, ctrlPtr->serverID is %d\n",
openArgsPtr->clientID, ctrlHandlePtr->serverID);
	} else {
	    /*
	     * Note which host is running the pseudo-device server.
	     */
	    ctrlHandlePtr->serverID = openArgsPtr->clientID;
	    /*
	     * Note our hostID is still in the hdr.serverID field of the
	     * control handle being returned to the opening process. This is
	     * used when closing the control stream to get back to us
	     * so we can clear the serverID field here.  We also set up
	     * a shadow stream here, which has us as the server so
	     * recovery and closing work right.
	     */
	    openResultsPtr->ioFileID = ioFileID;
	    openResultsPtr->streamData = (ClientData)NIL;
	    openResultsPtr->dataSize = 0;
	    streamPtr = Fsio_StreamCreate(rpc_SpriteID, openArgsPtr->clientID,
				    (Fs_HandleHeader *)ctrlHandlePtr,
				    openArgsPtr->useFlags, handlePtr->hdr.name);
	    openResultsPtr->streamID = streamPtr->hdr.fileID;
	    /*
	     * We're the name server for this pdev, and if we're not the
	     * machine running the pdev server, then we update the recov box.
	     */
	    if (recov_Transparent && openArgsPtr->clientID != rpc_SpriteID) {
		if (fsrecov_DebugLevel <= 2) {
		    printf("FspdevNameOpen: Adding control handle ");
		    printf("%d.%d.%d.%d\n\tclient %d, serverID %d\n",
			    ((Fs_HandleHeader *) ctrlHandlePtr)->fileID.type,
			    ((Fs_HandleHeader *)
			    ctrlHandlePtr)->fileID.serverID,
			    ((Fs_HandleHeader *) ctrlHandlePtr)->fileID.major,
			    ((Fs_HandleHeader *) ctrlHandlePtr)->fileID.minor,
			    openArgsPtr->clientID,
			    ctrlHandlePtr->serverID);
		}
/* MIMIC_PDEV_BUG */
		/*
		 * No reference counts are kept on pdev control handles,
		 * so we can't allow them to acrue in the recov box, either.
		 * So if it's already there, just "update" it, else add it.
		 */
		if (Fsrecov_GetHandle(((Fs_HandleHeader *)
			ctrlHandlePtr)->fileID, openArgsPtr->clientID,
			&recovInfo, FALSE) == SUCCESS) {
		    recovInfo.info = ctrlHandlePtr->serverID;
		    recovInfo.clientData = ctrlHandlePtr->seed;
		    if (Fsrecov_UpdateHandle(((Fs_HandleHeader *)
			    ctrlHandlePtr)->fileID, openArgsPtr->clientID,
			    &recovInfo) != SUCCESS) {
			panic("FspdevNameOpen: couldn't update open handle.");
		    }
		} else {
/* END_MIMIC_PDEV_BUG */
		    status = Fsrecov_AddHandle((Fs_HandleHeader *)
			    ctrlHandlePtr,
			    (Fs_FileID *) NIL, openArgsPtr->clientID, 0,
			    ctrlHandlePtr->seed, TRUE);
		    /* We'll have to do better than this! */
		    if (status != SUCCESS) {
			panic(
			"FspdevNameOpen: couldn't add handle to recov box.");
		    }
		}
		/*
		 * Now add mapping between stream and ioHandle.  We'll need
		 * to handle error cases better!!
		 */
		if (fsrecov_DebugLevel <= 2) {
		    printf("FspdevNameOpen: Adding stream handle with ");
		    printf("ioFileID %d.%d.%d.%d\n", ioFileID.type,
			    ioFileID.serverID, ioFileID.major, ioFileID.minor);
		}
		status = Fsrecov_AddHandle((Fs_HandleHeader *) streamPtr,
			&ioFileID, openArgsPtr->clientID, streamPtr->flags,
			streamPtr->offset, TRUE);
	    }
	    Fsutil_HandleRelease(streamPtr, TRUE);
	}
    } else {
	if (openArgsPtr->useFlags == 0) {
	    /*
	     * Set up for get/set attributes.  We point the client
	     * at the name of the pseudo-device if it is not active,
	     * otherwise we point it at the control stream handle that
	     * has the current access and modify times.
	     */
	    if (ctrlHandlePtr->serverID == NIL) {
		openResultsPtr->ioFileID = handlePtr->hdr.fileID;
	    } else {
		openResultsPtr->ioFileID = ctrlHandlePtr->rmt.hdr.fileID;
		if (openArgsPtr->clientID != ctrlHandlePtr->serverID) {
		    /*
		     * The requesting client is different than the pdev
		     * server host.  Unfortunately the serverID in the
		     * control handle is us, the file server.  We have
		     * to hack the fileID so the client makes the RPC to
		     * the pdev server.  This relies on a parallel hack
		     * in Fsrmt_GetIOAttr to fix up the serverID by
		     * using the Fs_Attributes.serverID, which is us,
		     * so that the correct control handle is found.
		     */
		    openResultsPtr->ioFileID.type = FSIO_RMT_CONTROL_STREAM;
		    openResultsPtr->ioFileID.serverID = ctrlHandlePtr->serverID;
		}
	    }
	} else if (ctrlHandlePtr->serverID == NIL) {
	    /*
	     * No server process.
	     */
	    status = DEV_OFFLINE;
	} else {
	    /*
	     * The server exists.  Create a new I/O handle for the client.
	     * The major and minor numbers are generated from the fileID
	     * of the pseudo-device name (to avoid conflict with other
	     * pseudo-devices) and a clone seed (to avoid conflict with
	     * other clients of this pseudo-device).
	     */
	    if (ctrlHandlePtr->serverID == openArgsPtr->clientID) {
		openResultsPtr->ioFileID.type = FSIO_LCL_PSEUDO_STREAM;
	    } else {
		openResultsPtr->ioFileID.type = FSIO_RMT_PSEUDO_STREAM;
	    }
	    openResultsPtr->ioFileID.serverID = ctrlHandlePtr->serverID;
	    openResultsPtr->ioFileID.major =
				(handlePtr->hdr.fileID.serverID << 16) |
				 handlePtr->hdr.fileID.major;
	    ctrlHandlePtr->seed++;
	    /*
	     * If we're the name server, and we're not the pdev server's
	     * machine, then update recov box copy of seed.  For "clientID"
	     * field of the Fsrecov_GetHandle call, we need to use the ID of the
	     * machine that's running the pdev server, since that's the
	     * original "client" that opened the thing.
	     */
	    if (recov_Transparent && ctrlHandlePtr->rmt.hdr.fileID.serverID ==
		    rpc_SpriteID && ctrlHandlePtr->serverID != rpc_SpriteID) {
		if (Fsrecov_GetHandle(ioFileID, ctrlHandlePtr->serverID,
			&recovInfo, FALSE) != SUCCESS) {
		    panic(
		    "FspdevNameOpen: couldn't get recov info for handle.");
		}
		recovInfo.clientData = ctrlHandlePtr->seed;
		if (fsrecov_DebugLevel <= 2) {
		    printf("FspdevNameOpen: Updating seed for ioFileID ");
		    printf(" %d.%d.%d.%d for client %d with serverID %d\n",
			    ioFileID.type, ioFileID.serverID,
			    ioFileID.major, ioFileID.minor,
			    openArgsPtr->clientID, ctrlHandlePtr->serverID);
		}
		if (Fsrecov_UpdateHandle(ioFileID, ctrlHandlePtr->serverID,
			&recovInfo) != SUCCESS) {
		    panic("FspdevNameOpen: couldn't update handle.");
		}
	    }

	    openResultsPtr->ioFileID.minor =
				((handlePtr->descPtr->version << 24) ^
				 (handlePtr->hdr.fileID.minor << 12)) |
				 ctrlHandlePtr->seed;
	    /*
	     * Return the control stream file ID so it can be found again
	     * later when setting up the client's stream and the
	     * corresponding server stream.  The procID and uid fields are
	     * extra here, but will be used later if the client is remote.
	     */
	    pdevStatePtr = mnew(Fspdev_State);
	    pdevStatePtr->ctrlFileID = ctrlHandlePtr->rmt.hdr.fileID;
	    pdevStatePtr->procID = (Proc_PID)NIL;
	    pdevStatePtr->uid = NIL;
	    openResultsPtr->streamData = (ClientData)pdevStatePtr ;
	    openResultsPtr->dataSize = sizeof(Fspdev_State);
	    /*
	     * Create a streamID for the opening process.  No shadow
	     * stream is kept here.  Instead, the streamID is returned to
	     * the pdev server who sets up the shadow stream.
	     */
	    Fsio_StreamCreateID(ctrlHandlePtr->serverID, &openResultsPtr->streamID);
	    pdevStatePtr->streamID = openResultsPtr->streamID;
	}
    }
    Fsutil_HandleRelease(ctrlHandlePtr, TRUE);
    Fsutil_HandleUnlock(handlePtr);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoStreamIoOpen --
 *
 *	This is called from Fs_Open, or from the RPC stub if the client
 *	is remote, to complete setup of a client's
 *	stream to the pseudo-device.  The server is running on this
 *	host.  This routine creates a trivial client I/O handle
 *	that references the server's I/O handle that has the main
 *	state for the connection to the server.  FspdevServerStreamCreate
 *	is then called to set up the server's I/O handle, and the control
 *	stream is used to pass a server stream to the server.  Finally
 *	an open transaction is made with the server process
 *	to see if it will accept the client.
 * 
 * Results:
 *	SUCCESS, unless the server process has died recently, or the
 *	server rejects the open.
 *
 * Side effects:
 *	Creates the client's I/O handle.  Calls FspdevServerStreamCreate
 *	which sets up the servers corresponding I/O handle.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
FspdevPseudoStreamIoOpen(ioFileIDPtr, flagsPtr, clientID, streamData, name,
	ioHandlePtrPtr)
    register Fs_FileID	*ioFileIDPtr;	/* I/O fileID */
    int			*flagsPtr;	/* FS_READ | FS_WRITE ... */
    int			clientID;	/* Host doing the open */
    ClientData		streamData;	/* Pointer to Fspdev_State. */
    char		*name;		/* File name for error msgs */
    Fs_HandleHeader	**ioHandlePtrPtr;/* Return - a locked handle set up for
					 * I/O to a pseudo device, or NIL */
{
    ReturnStatus		status;
    Boolean			foundStream;
    register Fspdev_ClientIOHandle	*cltHandlePtr;
    register Fspdev_ControlIOHandle *ctrlHandlePtr;
    register Fspdev_State	*pdevStatePtr;
    Fs_Stream			*cltStreamPtr;
    Fs_Stream			*srvStreamPtr;
    FspdevNotify			*notifyPtr;
    Proc_ControlBlock		*procPtr;
    Proc_PID 			procID;
    int				uid;

    pdevStatePtr = (Fspdev_State *)streamData;
    ctrlHandlePtr = Fsutil_HandleFetchType(Fspdev_ControlIOHandle,
				    &pdevStatePtr->ctrlFileID);
    /*
     * If there is no server present the creation of the stream
     * can't succeed.  This case arises when the pseudo-device
     * master goes away between FspdevNameOpen and this call.
     */
    if ((ctrlHandlePtr == (Fspdev_ControlIOHandle *)NIL) ||
	(ctrlHandlePtr->serverID == NIL)) {
	status = DEV_OFFLINE;
	goto exit;
    }

    if (ctrlHandlePtr->rmt.hdr.fileID.serverID != rpc_SpriteID) {
	/*
	 * Extract the seed from the minor field (see the SrvOpen routine).
	 * This done in case of recovery when we'll need to reset the
	 * seed kept on the file server.
	 */
	ctrlHandlePtr->seed = ioFileIDPtr->minor & 0x0FFF;
    }

    cltHandlePtr = FspdevConnect(ctrlHandlePtr, ioFileIDPtr, clientID, 0);
    if (cltHandlePtr == (Fspdev_ClientIOHandle *)NIL) {
	status = DEV_OFFLINE;
	goto exit;
    }
    /*
     * Put the client on its own stream list.
     */
    cltStreamPtr = Fsio_StreamAddClient(&pdevStatePtr->streamID, clientID,
		(Fs_HandleHeader *)cltHandlePtr, *flagsPtr, name,
		(Boolean *)NIL, &foundStream);
    Fsutil_HandleRelease(cltStreamPtr, TRUE);
    Fsutil_HandleUnlock(cltHandlePtr);
    /*
     * Set up a stream for the server process.  This will be picked
     * up by FspdevControlRead and converted to a user-level streamID.
     */
    srvStreamPtr = Fsio_StreamCreate(rpc_SpriteID, rpc_SpriteID,
			    (Fs_HandleHeader *)cltHandlePtr->pdevHandlePtr,
			    FS_READ|FS_USER, name);
    notifyPtr = mnew(FspdevNotify);
    notifyPtr->streamPtr = srvStreamPtr;
    List_InitElement((List_Links *)notifyPtr);
    List_Insert((List_Links *)notifyPtr,
		LIST_ATREAR(&ctrlHandlePtr->queueHdr));
    Fsutil_HandleUnlock(srvStreamPtr);

    Fsutil_FastWaitListNotify(&ctrlHandlePtr->readWaitList);
    Fsutil_HandleRelease(ctrlHandlePtr, TRUE);
    ctrlHandlePtr = (Fspdev_ControlIOHandle *)NIL;
    /*
     * Now that the request response stream is set up we do
     * our first transaction with the server process to see if it
     * will accept the open.  We unlock the handle and rely on the
     * per-connection monitor lock instead.  This is important because a
     * buggy pseudo-device server could be ignoring this connection
     * request indefinitely, and leaving handles locked for long periods
     * clogs up handle scavenging, and potentially recovery callbacks too.
     */
    if (clientID == rpc_SpriteID) {
	procPtr = Proc_GetEffectiveProc();
	procID = procPtr->processID;
	uid = procPtr->effectiveUserID;
    } else {
	procID = pdevStatePtr->procID;
	uid = pdevStatePtr->uid;
    }
    status = FspdevPseudoStreamOpen(cltHandlePtr->pdevHandlePtr, *flagsPtr,
				clientID, procID, uid);
    if (status == SUCCESS) {
	*ioHandlePtrPtr = (Fs_HandleHeader *)cltHandlePtr;
    } else {
	/*
	 * Clean up client side, we assume server closes its half.
	 */
	Fsutil_HandleInvalidate((Fs_HandleHeader *) cltHandlePtr);
	Fsutil_HandleRemove(cltHandlePtr);
	(void)Fsio_StreamClientClose(&cltStreamPtr->clientList, clientID);
	if (!foundStream) {
	    /*
	     * The client's stream wasn't already around from being installed
	     * in Fs_Open, so we nuke the shadow stream we've created.
	     */
	    cltStreamPtr = Fsutil_HandleFetchType(Fs_Stream,
					     &cltStreamPtr->hdr.fileID);
	    Fsio_StreamDestroy(cltStreamPtr);
	}
    }
exit:
    if (ctrlHandlePtr != (Fspdev_ControlIOHandle *)NIL) {
	Fsutil_HandleRelease(ctrlHandlePtr, TRUE);
    }
    free((Address)streamData);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevConnect --
 *
 *	This sets up a pseduo-device connection.  This is called from
 *	the PseudoStreamCltOpen routine with ordinary pseudo-devices,
 *	and from FspdevPfsIoOpen to set up the naming connection to a
 *	pseudo-filesystem server, and during an IOC_PFS_OPEN by a
 *	pseudo-filesystem server to set up a connection to a client.
 *	The case of the naming stream is distinguished by the last
 *	parameter.  The state of this needs to be marked specially
 *	so proper clean up can be made later.
 * 
 * Results:
 *	A pointer to a Fspdev_ClientIOHandle that references a Fspdev_ServerIOHandle.
 *	The client handle is returned locked, but the server handle it
 *	references is not locked.
 *
 * Side effects:
 *	Creates the client's I/O handle.  Calls FspdevServerStreamCreate
 *	which sets up the servers corresponding I/O handle.
 *	This changes the ioFileIDPtr->type from FSIO_LCL_PSEUDO_STREAM to
 *	FSIO_SERVER_STREAM.
 *
 *----------------------------------------------------------------------
 */

Fspdev_ClientIOHandle *
FspdevConnect(ctrlHandlePtr, ioFileIDPtr, clientID, naming)
    Fspdev_ControlIOHandle *ctrlHandlePtr;	/* Control stream handle */
    register Fs_FileID	*ioFileIDPtr;	/* I/O fileID */
    int			clientID;	/* Host ID of client-side */
    Boolean		naming;		/* TRUE if called from FspdevPfsIoOpen
					 * to set up the naming stream */
{
    Boolean			found;
    Fs_HandleHeader		*hdrPtr;
    register Fspdev_ClientIOHandle	*cltHandlePtr;

    found = Fsutil_HandleInstall(ioFileIDPtr, sizeof(Fspdev_ClientIOHandle),
		ctrlHandlePtr->rmt.hdr.name, FALSE, &hdrPtr);
    cltHandlePtr = (Fspdev_ClientIOHandle *)hdrPtr;
    if (found) {
	if ((cltHandlePtr->pdevHandlePtr != (Fspdev_ServerIOHandle *)NIL) &&
	    (cltHandlePtr->pdevHandlePtr->clientPID != (unsigned int)NIL)) {
	    printf(
		"FspdevConnect found client handle\n");
	    printf("Check (and kill) client process %x\n",
		cltHandlePtr->pdevHandlePtr->clientPID);
	}
	/*
	 * Invalidate this lingering handle.  The client process is hung
	 * or suspended and hasn't closed its end of the pdev connection.
	 */
	Fsutil_HandleInvalidate((Fs_HandleHeader *)cltHandlePtr);
	Fsutil_HandleRelease(cltHandlePtr, TRUE);

	found = Fsutil_HandleInstall(ioFileIDPtr, sizeof(Fspdev_ClientIOHandle),
			ctrlHandlePtr->rmt.hdr.name, FALSE, &hdrPtr);
	cltHandlePtr = (Fspdev_ClientIOHandle *)hdrPtr;
	if (found) {
	    panic( "FspdevConnect handle still there\n");
	}
    }
    /*
     * Set up the connection state and hook the client handle to it.
     */
    cltHandlePtr->pdevHandlePtr = FspdevServerStreamCreate(ioFileIDPtr,
				    ctrlHandlePtr->rmt.hdr.name, naming);
    if (cltHandlePtr->pdevHandlePtr == (Fspdev_ServerIOHandle *)NIL) {
	Fsutil_HandleRemove(cltHandlePtr);
	return((Fspdev_ClientIOHandle *)NIL);
    }
    cltHandlePtr->pdevHandlePtr->ctrlHandlePtr = ctrlHandlePtr;
    cltHandlePtr->segPtr = (struct Vm_Segment *)NIL; /* JMS */
    /*
     * Set up the client list in case the client is remote.
     */
    List_Init(&cltHandlePtr->clientList);
    (void)Fsconsist_IOClientOpen(&cltHandlePtr->clientList, clientID, 0, FALSE);
    /*
     * Grab an extra reference to the server's handle so the
     * server close routine can remove the handle and it won't
     * go away until the client also closes.
     */
    Fsutil_HandleUnlock(cltHandlePtr->pdevHandlePtr);
    (void)Fsutil_HandleDup((Fs_HandleHeader *)cltHandlePtr->pdevHandlePtr);
    Fsutil_HandleUnlock(cltHandlePtr->pdevHandlePtr);

    return(cltHandlePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevRmtPseudoStreamIoOpen --
 *
 *	Complete a remote client's stream to a pseudo-device.
 *	The client is on a different host than the server process.  This
 *	makes an RPC to the pseudo-device server's host to invoke
 *	FspdevPseudoStreamIoOpen, which sets up the pdev connection.
 *	This host only keeps a Fsrmt_IOHandle that implicitly references
 *	the pdev connection on the pdev server's host.
 * 
 * Results:
 *	SUCCESS unless the server process has died recently, then DEV_OFFLINE.
 *
 * Side effects:
 *	RPC to the server's host to invoke the regular setup routines.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevRmtPseudoStreamIoOpen(ioFileIDPtr, flagsPtr, clientID, streamData, name,
	ioHandlePtrPtr)
    register Fs_FileID	*ioFileIDPtr;	/* I/O fileID */
    int			*flagsPtr;	/* FS_READ | FS_WRITE ... */
    int			clientID;	/* IGNORED (== rpc_SpriteID) */
    ClientData		streamData;	/* NIL for us. */
    char		*name;		/* File name for error msgs */
    Fs_HandleHeader	**ioHandlePtrPtr;/* Return - a locked handle set up for
					 * I/O to a pseudo device, or NIL */
{
    register ReturnStatus status;
    register Proc_ControlBlock *procPtr;
    register Fspdev_State *pdevStatePtr = (Fspdev_State *)streamData;

    /*
     * Use RPC to invoke FspdevPseudoStreamIoOpen which sets up the connection.
     */
    procPtr = Proc_GetEffectiveProc();
    pdevStatePtr->procID = procPtr->processID;
    pdevStatePtr->uid = procPtr->effectiveUserID;
    ioFileIDPtr->type = FSIO_LCL_PSEUDO_STREAM;
    status = Fsrmt_DeviceOpen(ioFileIDPtr, *flagsPtr,	sizeof(Fspdev_State),
				(ClientData)pdevStatePtr);
    if (status == SUCCESS) {
	ioFileIDPtr->type = FSIO_RMT_PSEUDO_STREAM;
	Fsrmt_IOHandleInit(ioFileIDPtr, *flagsPtr, name, ioHandlePtrPtr);
    }
    free((Address)pdevStatePtr);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoStreamClose --
 *
 *	Close a pseudo stream that's been used by a client to talk to a server.
 *	This issues a close message to the server and then tears down the
 *	state used to implement the pseudo stream connection.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Other than the request-response to the server, this releases the
 *	pseudo stream's reference to the handle.  This may also have
 *	to contact a remote host to clean up references there, too.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevPseudoStreamClose(streamPtr, clientID, procID, flags, size, data)
    Fs_Stream		*streamPtr;	/* Client pseudo-stream to close */
    int			clientID;	/* HostID of client closing */
    Proc_PID		procID;		/* ID of closing process, IGNORED */
    int			flags;		/* IGNORED */
    int			size;		/* Should be zero */
    ClientData		data;		/* IGNORED */
{
    register Fspdev_ClientIOHandle *cltHandlePtr =
	    (Fspdev_ClientIOHandle *)streamPtr->ioHandlePtr;
    Boolean cache = FALSE;
    Vm_Segment *segPtr = cltHandlePtr->segPtr;

    DBG_PRINT( ("Client closing pdev %x,%x\n", 
		cltHandlePtr->hdr.fileID.major,
		cltHandlePtr->hdr.fileID.minor) );

    if (!Fsconsist_IOClientClose(&cltHandlePtr->clientList, clientID, 0, &cache)) {
	/*
	 * Invalid client trying to close.
	 */
	printf( "FspdevPseudoStreamClose: client %d not found\n",
	    clientID);
	Fsutil_HandleUnlock(cltHandlePtr);
	return(GEN_INVALID_ARG);
    } else if (!List_IsEmpty(&cltHandlePtr->clientList)) {
	/*
	 * Still clients out there.
	 */
	Fsutil_HandleUnlock(cltHandlePtr);
    } else {
	/*
	 * No clients remaining so we can close down the connection.
	 * Notify the server that a client has gone away.  Then we get rid
	 * of our reference to the server's handle and nuke our own.
	 * Note we unlock the client handle before the request response
	 * in case the server process is buggy and hangs us.
	 */
	if ((segPtr != (struct Vm_Segment *)NIL) &&
	    (segPtr != (struct Vm_Segment *)0) &&
	    (segPtr->type == VM_CODE)) {
	    Vm_FileChanged(&segPtr);
	}
	Fsutil_HandleUnlock(cltHandlePtr);
	FspdevPseudoStreamCloseInt(cltHandlePtr->pdevHandlePtr);
	Fsutil_HandleRelease(cltHandlePtr->pdevHandlePtr, FALSE);
	Fsutil_HandleRelease(cltHandlePtr, FALSE);
	Fsutil_HandleRemove(cltHandlePtr);
    }
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevRmtPseudoStreamClose --
 *
 *	Close a pseudo stream that's been used by a client to talk to a server.
 *	This issues a close message to the server and then tears down the
 *	state used to implement the pseudo stream connection.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Other than the request-response to the server, this releases the
 *	pseudo stream's reference to the handle.  This may also have
 *	to contact a remote host to clean up references there, too.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevRmtPseudoStreamClose(streamPtr, clientID, procID, flags, size, data)
    Fs_Stream		*streamPtr;	/* Client pseudo-stream to close */
    int			clientID;	/* HostID of client closing */
    Proc_PID		procID;		/* ID of closing process, IGNORED */
    int			flags;		/* IGNORED */
    int			size;		/* Should be zero */
    ClientData		data;		/* IGNORED */
{
    register Fspdev_ClientIOHandle *cltHandlePtr =
	    (Fspdev_ClientIOHandle *)streamPtr->ioHandlePtr;
    Vm_Segment *segPtr = cltHandlePtr->segPtr;

    DBG_PRINT( ("Client closing rmt pdev %x,%x\n", 
		cltHandlePtr->hdr.fileID.major,
		cltHandlePtr->hdr.fileID.minor) );

    if ((segPtr != (struct Vm_Segment *)NIL) &&
	(segPtr != (struct Vm_Segment *)0) &&
	(segPtr->type == VM_CODE)) {
	Vm_FileChanged(&segPtr);
    }
    Fsrmt_IOClose(streamPtr, clientID, procID, flags, size, data);
    
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoStreamMigClose --
 *
 *	Called to release a reference on a pseudo stream.  However, there
 *	is always only one refernece on the handle so we do nothing.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Release the I/O handle.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevPseudoStreamMigClose(hdrPtr, flags)
    Fs_HandleHeader *hdrPtr;	/* File being encapsulated */
    int flags;			/* Use flags from the stream */
{
    panic( "FspdevPseudoStreamMigClose called\n");

    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoStreamMigrate --
 *
 *	Migrate a pseudo-stream client.
 *
 *	This takes care of transfering references from one client to the other.
 *	A useful side-effect of this routine is	to properly set the type in
 *	the ioFileID, either FSIO_LCL_PSEUDO_STREAM or FSIO_RMT_PSEUDO_STREAM.
 *	In the latter case FspdevRmtPseudoStreamMigrate is called to do all
 *	the work.
 *
 * Results:
 *	An error status if the I/O handle can't be set-up.
 *	Otherwise SUCCESS is returned, *flagsPtr may have the FS_RMT_SHARED
 *	bit set, and *sizePtr and *dataPtr are set to reference Fspdev_State.
 *
 * Side effects:
 *	Sets the correct stream type on the ioFileID.
 *	Shifts client references from the srcClient to the destClient.
 *	Set up and return Fspdev_State for use by the MigEnd routine.
 
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevPseudoStreamMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr, sizePtr,
		      dataPtr)
    Fsio_MigInfo	*migInfoPtr;	/* Migration state */
    int		dstClientID;	/* ID of target client */
    int		*flagsPtr;	/* In/Out Stream usage flags */
    int		*offsetPtr;	/* Return - new stream offset */
    int		*sizePtr;	/* Return - sizeof(Fspdev_State) */
    Address	*dataPtr;	/* Return - pointer to Fspdev_State */
{
    Fspdev_ClientIOHandle			*cltHandlePtr;
    Boolean				closeSrcClient;

    if (migInfoPtr->ioFileID.serverID != rpc_SpriteID) {
	/*
	 * The device was local, which is why we were called, but is
	 * now remote.
	 */
	migInfoPtr->ioFileID.type = FSIO_RMT_PSEUDO_STREAM;
	return(FspdevRmtPseudoStreamMigrate(migInfoPtr, dstClientID, flagsPtr,
					offsetPtr, sizePtr, dataPtr));
    }
    migInfoPtr->ioFileID.type = FSIO_LCL_PSEUDO_STREAM;
    cltHandlePtr = Fsutil_HandleFetchType(Fspdev_ClientIOHandle, &migInfoPtr->ioFileID);
    if (cltHandlePtr == (Fspdev_ClientIOHandle *)NIL) {
	panic( "FspdevPseudoStreamMigrate, no client handle <%d,%x,%x>\n",
		migInfoPtr->ioFileID.serverID,
		migInfoPtr->ioFileID.major, migInfoPtr->ioFileID.minor);
	return(FAILURE);
    }
    DBG_PRINT( ("Migrating pdev %x,%x, ref %d.\n", 
		cltHandlePtr->hdr.fileID.major,
		cltHandlePtr->hdr.fileID.minor,
		cltHandlePtr->hdr.refCount) );
    /*
     * At the stream level, add the new client to the set of clients
     * for the stream, and check for any cross-network stream sharing.
     */
    Fsio_StreamMigClient(migInfoPtr, dstClientID, (Fs_HandleHeader *)cltHandlePtr,
			&closeSrcClient);

    /*
     * Move the client at the I/O handle level.  The flags are used
     * by FsIOClient{Open,Close} and are different for pdevs than
     * other files -- namely, the flags are set to 0 before calls to these
     * routines.  The only flag we have to make sure to pass is
     * whether it's a new stream, since this is used by Fsio_MigrateClient
     * itself.
     */
    Fsio_MigrateClient(&cltHandlePtr->clientList, migInfoPtr->srcClientID,
		      dstClientID, (int)(migInfoPtr->flags & FS_NEW_STREAM),
		      closeSrcClient);

    *sizePtr = 0;
    *dataPtr = (Address)NIL;
    *flagsPtr = migInfoPtr->flags;
    *offsetPtr = migInfoPtr->offset;
    /*
     * We don't need this reference on the I/O handle; there is no change.
     */
    Fsutil_HandleRelease(cltHandlePtr, TRUE);
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevRmtPseudoStreamMigrate --
 *
 *	Migrate a pseudo-stream client.
 *	This takes care of transfering references from one client to the other.
 *	A useful side-effect of this routine is	to properly set the type in
 *	the ioFileID, either FSIO_LCL_PSEUDO_STREAM or FSIO_RMT_PSEUDO_STREAM.
 *	In the former case FspdevPseudoStreamMigrate is called to do all the work.
 *
 * Results:
 *	An error status if the I/O handle can't be set-up.
 *	Otherwise SUCCESS is returned, *flagsPtr may have the FS_RMT_SHARED
 *	bit set, and *sizePtr and *dataPtr are set to reference Fspdev_State.
 *
 * Side effects:
 *	Sets the correct stream type on the ioFileID.
 *	Shifts client references from the srcClient to the destClient.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevRmtPseudoStreamMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr,
			 sizePtr, dataPtr)
    Fsio_MigInfo	*migInfoPtr;	/* Migration state */
    int		dstClientID;	/* ID of target client */
    int		*flagsPtr;	/* In/Out Stream usage flags */
    int		*offsetPtr;	/* Return - the new stream offset */
    int		*sizePtr;	/* Return - 0 */
    Address	*dataPtr;	/* Return - NIL */
{
    register ReturnStatus		status;

    if (migInfoPtr->ioFileID.serverID == rpc_SpriteID) {
	/*
	 * The device was remote, which is why we were called, but is now local.
	 */
	migInfoPtr->ioFileID.type = FSIO_LCL_PSEUDO_STREAM;
	return(FspdevPseudoStreamMigrate(migInfoPtr, dstClientID, flagsPtr,
				     offsetPtr, sizePtr, dataPtr));
    }
    migInfoPtr->ioFileID.type = FSIO_RMT_PSEUDO_STREAM;
    status = Fsrmt_NotifyOfMigration(migInfoPtr, flagsPtr, offsetPtr,
				0, (Address)NIL);
    DBG_PRINT( ("Migrating remote pdev %x,%x.\n", 
		migInfoPtr->ioFileID.major,
		migInfoPtr->ioFileID.minor) );
    if (status != SUCCESS) {
	printf( "FsrmtDeviceMigrate, server error <%x>\n",
	    status);
    } else {
	*dataPtr = (Address)NIL;
	*sizePtr = 0;
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoStreamMigOpen --
 *
 *	Complete setup of a pdev client I/O handle after migrating a stream
 *	to the I/O server of the pseudo-device connection (the host running
 *	the user-level server process).  FspdevPseudoStreamMigrate has done
 *	the work of shifting use counts at the stream and I/O handle level.
 *	This routine fills in the stream's ioHandlePtr, but doens't adjust
 *	the low-level reference count on the I/O handle (like other MigEnd
 *	procedures) because the reference count isn't used the same way.
 *	With pseudo-device connections, there is always only one refCount
 *	on the client handle, but there may be entries in the clientList
 *	to reflect remote clients.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevPseudoStreamMigOpen(migInfoPtr, size, data, hdrPtrPtr)
    Fsio_MigInfo	*migInfoPtr;	/* Migration state */
    int		size;		/* Zero */
    ClientData	data;		/* NIL */
    Fs_HandleHeader **hdrPtrPtr;	/* Return - handle for the file */
{
    register Fspdev_ClientIOHandle *cltHandlePtr;

    cltHandlePtr = Fsutil_HandleFetchType(Fspdev_ClientIOHandle,
				     &migInfoPtr->ioFileID);
    if (cltHandlePtr == (Fspdev_ClientIOHandle *)NIL) {
	panic( "FspdevPseudoStreamMigOpen, no handle.\n");
	return(FAILURE);
    } else {
	/*
	 * Release this reference so the client handle always has
	 * just one reference.  Instead of refcounts, an empty
	 * client list indicates there are no more clients.
	 */
	Fsutil_HandleRelease(cltHandlePtr, TRUE);
	*hdrPtrPtr = (Fs_HandleHeader *)cltHandlePtr;
	return(SUCCESS);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevRmtPseudoStreamVerify --
 *
 *	Verify that the remote client is known for the pdev, and return
 *	a locked pointer to the client I/O handle.
 *
 * Results:
 *	A pointer to the client I/O handle, or NIL if
 *	the client is bad.
 *
 * Side effects:
 *	The handle is returned locked and with its refCount incremented.
 *	It should be released with Fsutil_HandleRelease.
 *
 *----------------------------------------------------------------------
 */

Fs_HandleHeader *
FspdevRmtPseudoStreamVerify(fileIDPtr, clientID, domainTypePtr)
    Fs_FileID	*fileIDPtr;	/* Client's I/O file ID */
    int		clientID;	/* Host ID of the client */
    int		*domainTypePtr;	/* Return - FS_PSEUDO_DOMAIN */
{
    register Fspdev_ClientIOHandle	*cltHandlePtr;
    register Fsconsist_ClientInfo	*clientPtr;
    Boolean			found = FALSE;

    if (fileIDPtr->type > 0 && fileIDPtr->type < FSIO_NUM_STREAM_TYPES) {
	fileIDPtr->type = fsio_RmtToLclType[fileIDPtr->type];
    }
    if (fileIDPtr->type != FSIO_LCL_PSEUDO_STREAM &&
	fileIDPtr->type != FSIO_LCL_PFS_STREAM) {
	printf( "FspdevRmtPseudoStreamVerify, bad type <%d>\n",
	    fileIDPtr->type);
	return((Fs_HandleHeader *)NIL);
    }
    cltHandlePtr = Fsutil_HandleFetchType(Fspdev_ClientIOHandle, fileIDPtr);
    if (cltHandlePtr != (Fspdev_ClientIOHandle *)NIL) {
	LIST_FORALL(&cltHandlePtr->clientList, (List_Links *) clientPtr) {
	    if (clientPtr->clientID == clientID) {
		found = TRUE;
		break;
	    }
	}
	if (!found) {
	    Fsutil_HandleRelease(cltHandlePtr, TRUE);
	    cltHandlePtr = (Fspdev_ClientIOHandle *)NIL;
	}
    }
    if (!found) {
	printf(
	    "FspdevRmtPseudoStreamVerify, client %d not known for %s <%x,%x>\n",
	    clientID, Fsutil_FileTypeToString(fileIDPtr->type),
	    fileIDPtr->major, fileIDPtr->minor);
    }
    if (domainTypePtr != (int *)NIL) {
	*domainTypePtr = FS_PSEUDO_DOMAIN;
    }
    return((Fs_HandleHeader *)cltHandlePtr);
}
@


9.9
log
@Removed left-over code from SOSP trace kernel.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fspdev/fspdevSetup.c,v 9.8 91/09/16 15:59:03 mottsmth Exp $ SPRITE (Berkeley)";
d39 2
d84 1
d106 2
d128 57
d237 28
@


9.8
log
@Don't call Vm_FileChanged if segPtr == 0 during close operation
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fspdevSetup.c,v 9.7 91/09/06 15:57:59 mottsmth Exp Locker: mottsmth $ SPRITE (Berkeley)";
a519 1
#ifndef SOSP91
a521 5
#else
ReturnStatus
FspdevPseudoStreamClose(streamPtr, clientID, procID, flags, size, data,
    offsetPtr, rwFlagsPtr)
#endif
a527 4
#ifdef SOSP91
    int			*offsetPtr;
    int			*rwFlagsPtr;
#endif
a592 1
#ifndef SOSP91
a594 5
#else
ReturnStatus
FspdevRmtPseudoStreamClose(streamPtr, clientID, procID, flags, size, data,
    offsetPtr, rwFlagsPtr)
#endif
a600 4
#ifdef SOSP91
    int			*offsetPtr;
    int			*rwFlagsPtr;
#endif
a614 1
#ifndef SOSP91
a615 3
#else
    Fsrmt_IOClose(streamPtr, clientID, procID, flags, size, data, offsetPtr, rwflagsPtr);
#endif
@


9.7
log
@Fix sticky segment handling for pseudo file system execution
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fspdevSetup.c,v 9.6 91/06/26 01:05:40 mottsmth Exp $ SPRITE (Berkeley)";
d570 1
d631 1
@


9.6
log
@Allow execution of PFS files
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fspdevSetup.c,v 9.5 91/06/23 16:43:51 mottsmth Exp $ SPRITE (Berkeley)";
d542 1
d569 4
d579 60
@


9.6.1.1
log
@Initial branch for Sprite server.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fspdev/fspdevSetup.c,v 9.6 91/06/26 01:05:40 mottsmth Exp $ SPRITE (Berkeley)";
@


9.5
log
@Allow execution of PFS files
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fspdevSetup.c,v 9.4 91/03/20 23:22:00 kupfer Exp Locker: mottsmth $ SPRITE (Berkeley)";
d79 1
a79 1
    register	FspdevControlIOHandle *ctrlHandlePtr;
d245 2
a246 2
    register FspdevClientIOHandle	*cltHandlePtr;
    register FspdevControlIOHandle *ctrlHandlePtr;
d256 1
a256 1
    ctrlHandlePtr = Fsutil_HandleFetchType(FspdevControlIOHandle,
d263 1
a263 1
    if ((ctrlHandlePtr == (FspdevControlIOHandle *)NIL) ||
d279 1
a279 1
    if (cltHandlePtr == (FspdevClientIOHandle *)NIL) {
d307 1
a307 1
    ctrlHandlePtr = (FspdevControlIOHandle *)NIL;
d347 1
a347 1
    if (ctrlHandlePtr != (FspdevControlIOHandle *)NIL) {
d369 1
a369 1
 *	A pointer to a FspdevClientIOHandle that references a FspdevServerIOHandle.
d382 1
a382 1
FspdevClientIOHandle *
d384 1
a384 1
    FspdevControlIOHandle *ctrlHandlePtr;	/* Control stream handle */
d392 1
a392 1
    register FspdevClientIOHandle	*cltHandlePtr;
d394 1
a394 1
    found = Fsutil_HandleInstall(ioFileIDPtr, sizeof(FspdevClientIOHandle),
d396 1
a396 1
    cltHandlePtr = (FspdevClientIOHandle *)hdrPtr;
d398 1
a398 1
	if ((cltHandlePtr->pdevHandlePtr != (FspdevServerIOHandle *)NIL) &&
d412 1
a412 1
	found = Fsutil_HandleInstall(ioFileIDPtr, sizeof(FspdevClientIOHandle),
d414 1
a414 1
	cltHandlePtr = (FspdevClientIOHandle *)hdrPtr;
d424 1
a424 1
    if (cltHandlePtr->pdevHandlePtr == (FspdevServerIOHandle *)NIL) {
d426 1
a426 1
	return((FspdevClientIOHandle *)NIL);
d429 1
d539 2
a540 2
    register FspdevClientIOHandle *cltHandlePtr =
	    (FspdevClientIOHandle *)streamPtr->ioHandlePtr;
d641 1
a641 1
    FspdevClientIOHandle			*cltHandlePtr;
d654 2
a655 2
    cltHandlePtr = Fsutil_HandleFetchType(FspdevClientIOHandle, &migInfoPtr->ioFileID);
    if (cltHandlePtr == (FspdevClientIOHandle *)NIL) {
d786 1
a786 1
    register FspdevClientIOHandle *cltHandlePtr;
d788 1
a788 1
    cltHandlePtr = Fsutil_HandleFetchType(FspdevClientIOHandle,
d790 1
a790 1
    if (cltHandlePtr == (FspdevClientIOHandle *)NIL) {
d830 1
a830 1
    register FspdevClientIOHandle	*cltHandlePtr;
d843 2
a844 2
    cltHandlePtr = Fsutil_HandleFetchType(FspdevClientIOHandle, fileIDPtr);
    if (cltHandlePtr != (FspdevClientIOHandle *)NIL) {
d853 1
a853 1
	    cltHandlePtr = (FspdevClientIOHandle *)NIL;
@


9.4
log
@Fix printf in FspdevRmtPseudoStreamVerify to give the correct function name.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fspdevSetup.c,v 9.3 90/12/06 21:56:23 jhh Exp Locker: kupfer $ SPRITE (Berkeley)";
a253 8

    /*
     * PATCH - should allow execution via pseudo-devices some day.
     *	Need to fix Fs_CheckSetID, and the sticky segment stuff.
     */
    if (*flagsPtr & FS_EXECUTE) {
	return(FS_WRONG_TYPE);
    }
@


9.3
log
@Added sosp tracing code
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fspdevSetup.c,v 9.2 90/10/08 12:41:35 mendel Exp Locker: jhh $ SPRITE (Berkeley)";
d865 1
a865 1
	    "FsRmtPseudoDeviceVerify, client %d not known for %s <%x,%x>\n",
@


9.2
log
@Fixed include files to use <> rather than "".
Fixed lint.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs.mendel/RCS/fsPdevSetup.c,v 1.1 90/01/16 17:11:14 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d527 1
d530 5
d541 4
@


9.1
log
@Removed lint
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fsPdevSetup.c,v 8.9 89/08/21 15:27:56 mendel Exp $ SPRITE (Berkeley)";
d27 12
a38 12
#include "sprite.h"
#include "fs.h"
#include "fsutil.h"
#include "fsNameOps.h"
#include "fsio.h"
#include "fsconsist.h"
#include "fsdm.h"
#include "fsioLock.h"
#include "proc.h"
#include "rpc.h"
#include "fspdevInt.h"
#include "fspdev.h"
d288 1
d403 1
a403 1
		ctrlHandlePtr->rmt.hdr.name, &hdrPtr);
d421 1
a421 1
			ctrlHandlePtr->rmt.hdr.name, &hdrPtr);
d631 1
a631 1
    FsMigInfo	*migInfoPtr;	/* Migration state */
d678 1
a678 1
		      dstClientID, migInfoPtr->flags & FS_NEW_STREAM,
d718 1
a718 1
    FsMigInfo	*migInfoPtr;	/* Migration state */
d778 1
a778 1
    FsMigInfo	*migInfoPtr;	/* Migration state */
@


9.0
log
@Changing version numbers.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fsPdevSetup.c,v 8.9 89/08/21 15:27:56 mendel Exp Locker: douglis $ SPRITE (Berkeley)";
d673 1
a673 1
     * whether it's a new stream, since this is used by Fsio_IOClientMigrate
d676 1
a676 1
    Fsio_IOClientMigrate(&cltHandlePtr->clientList, migInfoPtr->srcClientID,
@


8.9
log
@Break up fs into many modules.    
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdevSetup.c,v 8.8 89/06/15 09:22:28 brent Exp $ SPRITE (Berkeley)";
@


8.8
log
@Updated srvOpen interface
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdevSetup.c,v 8.7 89/05/14 15:25:52 brent Exp Locker: brent $ SPRITE (Berkeley)";
d29 6
a34 8
#include "fsInt.h"
#include "fsOpTable.h"
#include "fsStream.h"
#include "fsClient.h"
#include "fsFile.h"
#include "fsDisk.h"
#include "fsMigrate.h"
#include "fsLock.h"
d37 2
a38 2
#include "swapBuffer.h"
#include "fsPdev.h"
d43 1
a43 1
 * FsPseudoDevSrvOpen --
d69 2
a70 2
FsPseudoDevSrvOpen(handlePtr, openArgsPtr, openResultsPtr)
     register FsLocalFileIOHandle *handlePtr;	/* A handle from FsLocalLookup.
d73 3
a75 3
     FsOpenArgs		*openArgsPtr;	/* Standard open arguments */
     FsOpenResults	*openResultsPtr;/* For returning ioFileID, streamID,
					 * and FsDeviceState */
d79 1
a79 1
    register	PdevControlIOHandle *ctrlHandlePtr;
d81 1
a81 1
    register	FsPdevState *pdevStatePtr;
d90 1
a90 1
    ioFileID.type = FS_CONTROL_STREAM;
d95 1
a95 1
    ctrlHandlePtr = FsControlHandleInit(&ioFileID, handlePtr->hdr.name);
d119 2
a120 2
	    streamPtr = FsStreamNewClient(rpc_SpriteID, openArgsPtr->clientID,
				    (FsHandleHeader *)ctrlHandlePtr,
d123 1
a123 1
	    FsHandleRelease(streamPtr, TRUE);
d144 1
a144 1
		     * in FsRemoteGetIOAttr to fix up the serverID by
d148 1
a148 1
		    openResultsPtr->ioFileID.type = FS_RMT_CONTROL_STREAM;
d166 1
a166 1
		openResultsPtr->ioFileID.type = FS_LCL_PSEUDO_STREAM;
d168 1
a168 1
		openResultsPtr->ioFileID.type = FS_RMT_PSEUDO_STREAM;
d185 1
a185 1
	    pdevStatePtr = mnew(FsPdevState);
d190 1
a190 1
	    openResultsPtr->dataSize = sizeof(FsPdevState);
d196 1
a196 1
	    FsStreamNewID(ctrlHandlePtr->serverID, &openResultsPtr->streamID);
d200 2
a201 2
    FsHandleRelease(ctrlHandlePtr, TRUE);
    FsHandleUnlock(handlePtr);
d208 1
a208 1
 * FsPseudoStreamCltOpen --
d215 1
a215 1
 *	state for the connection to the server.  FsServerStreamCreate
d226 1
a226 1
 *	Creates the client's I/O handle.  Calls FsServerStreamCreate
d233 1
a233 1
FsPseudoStreamCltOpen(ioFileIDPtr, flagsPtr, clientID, streamData, name,
d238 1
a238 1
    ClientData		streamData;	/* Pointer to FsPdevState. */
d240 1
a240 1
    FsHandleHeader	**ioHandlePtrPtr;/* Return - a locked handle set up for
d245 3
a247 3
    register PdevClientIOHandle	*cltHandlePtr;
    register PdevControlIOHandle *ctrlHandlePtr;
    register FsPdevState	*pdevStatePtr;
d250 1
a250 1
    PdevNotify			*notifyPtr;
d263 2
a264 2
    pdevStatePtr = (FsPdevState *)streamData;
    ctrlHandlePtr = FsHandleFetchType(PdevControlIOHandle,
d269 1
a269 1
     * master goes away between FsPseudoDevSrvOpen and this call.
d271 1
a271 1
    if ((ctrlHandlePtr == (PdevControlIOHandle *)NIL) ||
d286 2
a287 2
    cltHandlePtr = FsPdevConnect(ctrlHandlePtr, ioFileIDPtr, clientID, 0);
    if (cltHandlePtr == (PdevClientIOHandle *)NIL) {
d293 2
a294 2
    cltStreamPtr = FsStreamAddClient(&pdevStatePtr->streamID, clientID,
		(FsHandleHeader *)cltHandlePtr, *flagsPtr, name,
d296 2
a297 2
    FsHandleRelease(cltStreamPtr, TRUE);
    FsHandleUnlock(cltHandlePtr);
d300 1
a300 1
     * up by FsControlRead and converted to a user-level streamID.
d302 2
a303 2
    srvStreamPtr = FsStreamNewClient(rpc_SpriteID, rpc_SpriteID,
			    (FsHandleHeader *)cltHandlePtr->pdevHandlePtr,
d305 1
a305 1
    notifyPtr = mnew(PdevNotify);
d310 1
a310 1
    FsHandleUnlock(srvStreamPtr);
d312 3
a314 3
    FsFastWaitListNotify(&ctrlHandlePtr->readWaitList);
    FsHandleRelease(ctrlHandlePtr, TRUE);
    ctrlHandlePtr = (PdevControlIOHandle *)NIL;
d332 1
a332 1
    status = FsPseudoStreamOpen(cltHandlePtr->pdevHandlePtr, *flagsPtr,
d335 1
a335 1
	*ioHandlePtrPtr = (FsHandleHeader *)cltHandlePtr;
d340 3
a342 3
	FsHandleInvalidate((FsHandleHeader *) cltHandlePtr);
	FsHandleRemove(cltHandlePtr);
	(void)FsStreamClientClose(&cltStreamPtr->clientList, clientID);
d348 1
a348 1
	    cltStreamPtr = FsHandleFetchType(Fs_Stream,
d350 1
a350 1
	    FsStreamDispose(cltStreamPtr);
d354 2
a355 2
    if (ctrlHandlePtr != (PdevControlIOHandle *)NIL) {
	FsHandleRelease(ctrlHandlePtr, TRUE);
d364 1
a364 1
 * FsPdevConnect --
d368 1
a368 1
 *	and from FsPfsCltOpen to set up the naming connection to a
d376 1
a376 1
 *	A pointer to a PdevClientIOHandle that references a PdevServerIOHandle.
d381 1
a381 1
 *	Creates the client's I/O handle.  Calls FsServerStreamCreate
d383 2
a384 2
 *	This changes the ioFileIDPtr->type from FS_LCL_PSEUDO_STREAM to
 *	FS_SERVER_STREAM.
d389 3
a391 3
PdevClientIOHandle *
FsPdevConnect(ctrlHandlePtr, ioFileIDPtr, clientID, naming)
    PdevControlIOHandle *ctrlHandlePtr;	/* Control stream handle */
d394 1
a394 1
    Boolean		naming;		/* TRUE if called from FsPfsCltOpen
d398 2
a399 2
    FsHandleHeader		*hdrPtr;
    register PdevClientIOHandle	*cltHandlePtr;
d401 1
a401 1
    found = FsHandleInstall(ioFileIDPtr, sizeof(PdevClientIOHandle),
d403 1
a403 1
    cltHandlePtr = (PdevClientIOHandle *)hdrPtr;
d405 1
a405 1
	if ((cltHandlePtr->pdevHandlePtr != (PdevServerIOHandle *)NIL) &&
d408 1
a408 1
		"FsPdevConnect found client handle\n");
d416 2
a417 2
	FsHandleInvalidate((FsHandleHeader *)cltHandlePtr);
	FsHandleRelease(cltHandlePtr, TRUE);
d419 1
a419 1
	found = FsHandleInstall(ioFileIDPtr, sizeof(PdevClientIOHandle),
d421 1
a421 1
	cltHandlePtr = (PdevClientIOHandle *)hdrPtr;
d423 1
a423 1
	    panic( "FsPdevConnect handle still there\n");
d429 1
a429 1
    cltHandlePtr->pdevHandlePtr = FsServerStreamCreate(ioFileIDPtr,
d431 3
a433 3
    if (cltHandlePtr->pdevHandlePtr == (PdevServerIOHandle *)NIL) {
	FsHandleRemove(cltHandlePtr);
	return((PdevClientIOHandle *)NIL);
d440 1
a440 1
    (void)FsIOClientOpen(&cltHandlePtr->clientList, clientID, 0, FALSE);
d446 3
a448 3
    FsHandleUnlock(cltHandlePtr->pdevHandlePtr);
    (void)FsHandleDup((FsHandleHeader *)cltHandlePtr->pdevHandlePtr);
    FsHandleUnlock(cltHandlePtr->pdevHandlePtr);
d456 1
a456 1
 * FsRmtPseudoStreamCltOpen --
d461 2
a462 2
 *	FsPseudoStreamCltOpen, which sets up the pdev connection.
 *	This host only keeps a FsRemoteIOHandle that implicitly references
d475 1
a475 1
FsRmtPseudoStreamCltOpen(ioFileIDPtr, flagsPtr, clientID, streamData, name,
d482 1
a482 1
    FsHandleHeader	**ioHandlePtrPtr;/* Return - a locked handle set up for
d487 1
a487 1
    register FsPdevState *pdevStatePtr = (FsPdevState *)streamData;
d490 1
a490 1
     * Use RPC to invoke FsPseudoStreamCltOpen which sets up the connection.
d495 2
a496 2
    ioFileIDPtr->type = FS_LCL_PSEUDO_STREAM;
    status = FsDeviceRemoteOpen(ioFileIDPtr, *flagsPtr,	sizeof(FsPdevState),
d499 2
a500 2
	ioFileIDPtr->type = FS_RMT_PSEUDO_STREAM;
	FsRemoteIOHandleInit(ioFileIDPtr, *flagsPtr, name, ioHandlePtrPtr);
d509 1
a509 1
 * FsPseudoStreamClose --
d527 1
a527 1
FsPseudoStreamClose(streamPtr, clientID, procID, flags, size, data)
d535 2
a536 2
    register PdevClientIOHandle *cltHandlePtr =
	    (PdevClientIOHandle *)streamPtr->ioHandlePtr;
d543 1
a543 1
    if (!FsIOClientClose(&cltHandlePtr->clientList, clientID, 0, &cache)) {
d547 1
a547 1
	printf( "FsPseudoStreamClose: client %d not found\n",
d549 1
a549 1
	FsHandleUnlock(cltHandlePtr);
d555 1
a555 1
	FsHandleUnlock(cltHandlePtr);
d564 5
a568 5
	FsHandleUnlock(cltHandlePtr);
	FsPseudoStreamCloseInt(cltHandlePtr->pdevHandlePtr);
	FsHandleRelease(cltHandlePtr->pdevHandlePtr, FALSE);
	FsHandleRelease(cltHandlePtr, FALSE);
	FsHandleRemove(cltHandlePtr);
d576 1
a576 1
 * FsPseudoStreamRelease --
d591 2
a592 2
FsPseudoStreamRelease(hdrPtr, flags)
    FsHandleHeader *hdrPtr;	/* File being encapsulated */
d595 1
a595 1
    panic( "FsPseudoStreamRelease called\n");
d603 1
a603 1
 * FsPseudoStreamMigrate --
d609 2
a610 2
 *	the ioFileID, either FS_LCL_PSEUDO_STREAM or FS_RMT_PSEUDO_STREAM.
 *	In the latter case FsRmtPseudoStreamMigrate is called to do all
d616 1
a616 1
 *	bit set, and *sizePtr and *dataPtr are set to reference FsPdevState.
d621 1
a621 1
 *	Set up and return FsPdevState for use by the MigEnd routine.
d628 1
a628 1
FsPseudoStreamMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr, sizePtr,
d634 2
a635 2
    int		*sizePtr;	/* Return - sizeof(FsPdevState) */
    Address	*dataPtr;	/* Return - pointer to FsPdevState */
d637 1
a637 1
    PdevClientIOHandle			*cltHandlePtr;
d645 2
a646 2
	migInfoPtr->ioFileID.type = FS_RMT_PSEUDO_STREAM;
	return(FsRmtPseudoStreamMigrate(migInfoPtr, dstClientID, flagsPtr,
d649 4
a652 4
    migInfoPtr->ioFileID.type = FS_LCL_PSEUDO_STREAM;
    cltHandlePtr = FsHandleFetchType(PdevClientIOHandle, &migInfoPtr->ioFileID);
    if (cltHandlePtr == (PdevClientIOHandle *)NIL) {
	panic( "FsPseudoStreamMigrate, no client handle <%d,%x,%x>\n",
d665 1
a665 1
    FsStreamMigClient(migInfoPtr, dstClientID, (FsHandleHeader *)cltHandlePtr,
d673 1
a673 1
     * whether it's a new stream, since this is used by FsIOClientMigrate
d676 1
a676 1
    FsIOClientMigrate(&cltHandlePtr->clientList, migInfoPtr->srcClientID,
d687 1
a687 1
    FsHandleRelease(cltHandlePtr, TRUE);
d694 1
a694 1
 * FsRmtPseudoStreamMigrate --
d699 2
a700 2
 *	the ioFileID, either FS_LCL_PSEUDO_STREAM or FS_RMT_PSEUDO_STREAM.
 *	In the former case FsPseudoStreamMigrate is called to do all the work.
d705 1
a705 1
 *	bit set, and *sizePtr and *dataPtr are set to reference FsPdevState.
d715 1
a715 1
FsRmtPseudoStreamMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr,
d730 2
a731 2
	migInfoPtr->ioFileID.type = FS_LCL_PSEUDO_STREAM;
	return(FsPseudoStreamMigrate(migInfoPtr, dstClientID, flagsPtr,
d734 2
a735 2
    migInfoPtr->ioFileID.type = FS_RMT_PSEUDO_STREAM;
    status = FsNotifyOfMigration(migInfoPtr, flagsPtr, offsetPtr,
d741 1
a741 1
	printf( "FsRmtDeviceMigrate, server error <%x>\n",
d753 1
a753 1
 * FsPseudoStreamMigEnd --
d757 1
a757 1
 *	the user-level server process).  FsPseudoStreamMigrate has done
d776 1
a776 1
FsPseudoStreamMigEnd(migInfoPtr, size, data, hdrPtrPtr)
d780 1
a780 1
    FsHandleHeader **hdrPtrPtr;	/* Return - handle for the file */
d782 1
a782 1
    register PdevClientIOHandle *cltHandlePtr;
d784 1
a784 1
    cltHandlePtr = FsHandleFetchType(PdevClientIOHandle,
d786 2
a787 2
    if (cltHandlePtr == (PdevClientIOHandle *)NIL) {
	panic( "FsPseudoStreamMigEnd, no handle.\n");
d795 2
a796 2
	FsHandleRelease(cltHandlePtr, TRUE);
	*hdrPtrPtr = (FsHandleHeader *)cltHandlePtr;
d804 1
a804 1
 * FsRmtPseudoStreamVerify --
d815 1
a815 1
 *	It should be released with FsHandleRelease.
d820 2
a821 2
FsHandleHeader *
FsRmtPseudoStreamVerify(fileIDPtr, clientID, domainTypePtr)
d826 2
a827 2
    register PdevClientIOHandle	*cltHandlePtr;
    register FsClientInfo	*clientPtr;
d830 2
a831 2
    if (fileIDPtr->type > 0 && fileIDPtr->type < FS_NUM_STREAM_TYPES) {
	fileIDPtr->type = fsRmtToLclType[fileIDPtr->type];
d833 3
a835 3
    if (fileIDPtr->type != FS_LCL_PSEUDO_STREAM &&
	fileIDPtr->type != FS_LCL_PFS_STREAM) {
	printf( "FsRmtPseudoStreamVerify, bad type <%d>\n",
d837 1
a837 1
	return((FsHandleHeader *)NIL);
d839 2
a840 2
    cltHandlePtr = FsHandleFetchType(PdevClientIOHandle, fileIDPtr);
    if (cltHandlePtr != (PdevClientIOHandle *)NIL) {
d848 2
a849 2
	    FsHandleRelease(cltHandlePtr, TRUE);
	    cltHandlePtr = (PdevClientIOHandle *)NIL;
d855 1
a855 1
	    clientID, FsFileTypeToString(fileIDPtr->type),
d861 1
a861 1
    return((FsHandleHeader *)cltHandlePtr);
@


8.7
log
@Fixed PDEV_CLOSE to unlock the client handle before the
RequestResponse.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdevSetup.c,v 8.6 89/04/09 12:20:23 brent Exp $ SPRITE (Berkeley)";
d71 1
a71 2
FsPseudoDevSrvOpen(handlePtr, clientID, useFlags, ioFileIDPtr, streamIDPtr,
	dataSizePtr, clientDataPtr)
d75 3
a77 11
     int		clientID;	/* Host ID of client doing the open */
     register int	useFlags;	/* FS_MASTER, plus
					 * FS_READ | FS_WRITE | FS_EXECUTE*/
     register Fs_FileID	*ioFileIDPtr;	/* Return - I/O handle ID */
     Fs_FileID		*streamIDPtr;	/* Return - stream ID. 
					 * NIL during set/get attributes */
     int		*dataSizePtr;	/* Return - sizeof(FsPdevState) */
     ClientData		*clientDataPtr;	/* Return - a reference to FsPdevState.
					 * Nothing is returned during set/get
					 * attributes */

d99 1
a99 1
    if (useFlags & FS_PDEV_MASTER) {
d109 1
a109 1
	    ctrlHandlePtr->serverID = clientID;
d118 7
a124 7
	    *ioFileIDPtr = ioFileID;
	    *clientDataPtr = (ClientData)NIL;
	    *dataSizePtr = 0;
	    streamPtr = FsStreamNewClient(rpc_SpriteID, clientID,
				    (FsHandleHeader *)ctrlHandlePtr, useFlags,
				    handlePtr->hdr.name);
	    *streamIDPtr = streamPtr->hdr.fileID;
d128 1
a128 1
	if (streamIDPtr == (Fs_FileID *)NIL) {
d136 1
a136 1
		*ioFileIDPtr = handlePtr->hdr.fileID;
d138 2
a139 2
		*ioFileIDPtr = ctrlHandlePtr->rmt.hdr.fileID;
		if (clientID != ctrlHandlePtr->serverID) {
d150 2
a151 2
		    ioFileIDPtr->type = FS_RMT_CONTROL_STREAM;
		    ioFileIDPtr->serverID = ctrlHandlePtr->serverID;
d167 2
a168 2
	    if (ctrlHandlePtr->serverID == clientID) {
		ioFileIDPtr->type = FS_LCL_PSEUDO_STREAM;
d170 1
a170 1
		ioFileIDPtr->type = FS_RMT_PSEUDO_STREAM;
d172 4
a175 3
	    ioFileIDPtr->serverID = ctrlHandlePtr->serverID;
	    ioFileIDPtr->major = (handlePtr->hdr.fileID.serverID << 16) |
				  handlePtr->hdr.fileID.major;
d177 3
a179 2
	    ioFileIDPtr->minor = ((handlePtr->descPtr->version << 24) ^
				  (handlePtr->hdr.fileID.minor << 12)) |
d191 2
a192 2
	    *clientDataPtr = (ClientData)pdevStatePtr ;
	    *dataSizePtr = sizeof(FsPdevState);
d198 2
a199 2
	    FsStreamNewID(ctrlHandlePtr->serverID, streamIDPtr);
	    pdevStatePtr->streamID = *streamIDPtr;
@


8.6
log
@Fixed handling of failed opens of remote pseudo-devices
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdevSetup.c,v 8.5 89/03/21 17:07:04 douglis Exp $ SPRITE (Berkeley)";
d570 2
d573 1
d576 1
a576 1
	FsHandleRelease(cltHandlePtr, TRUE);
@


8.5
log
@fixed bug with calling IO open/close routines with full
flags values, which caused refcounts to get modified unexpectedly.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdevSetup.c,v 8.4 89/01/25 13:32:03 brent Exp Locker: douglis $ SPRITE (Berkeley)";
d357 2
@


8.4
log
@Added PDEV_NAMING to mark naming stream
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdevSetup.c,v 8.3 89/01/25 09:55:37 brent Exp Locker: brent $ SPRITE (Berkeley)";
d673 6
a678 1
     * Move the client at the I/O handle level.
d681 2
a682 1
			dstClientID, migInfoPtr->flags, closeSrcClient);
@


8.3
log
@1 - Changed PdevSrvOpen to create a FS_RMT_CONTROL_STREAM fileID that
is used to get/set the I/O attributes of a pseudo-device.
2 - Changed the setup code to always hook the pdev state back to
the control stream to support the access/modify times kept there.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdevSetup.c,v 8.2 89/01/19 09:43:09 brent Exp $ SPRITE (Berkeley)";
d295 1
a295 1
    cltHandlePtr = FsPdevConnect(ctrlHandlePtr, ioFileIDPtr, clientID);
d378 3
d397 1
a397 1
FsPdevConnect(ctrlHandlePtr, ioFileIDPtr, clientID)
d401 2
d437 1
a437 1
				    ctrlHandlePtr->rmt.hdr.name);
@


8.2
log
@Patched against execution of files in a pseudo-file-system.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdevSetup.c,v 8.1 88/12/21 10:18:19 brent Exp $ SPRITE (Berkeley)";
d140 3
a142 1
	     * at the name of the pseudo-device, what else?
d144 19
a162 1
	    *ioFileIDPtr = handlePtr->hdr.fileID;
d295 1
a295 1
    cltHandlePtr = FsPdevConnect(ioFileIDPtr, clientID, name);
d394 2
a395 1
FsPdevConnect(ioFileIDPtr, clientID, name)
a397 1
    char		*name;		/* File name for error msgs */
d403 2
a404 2
    found = FsHandleInstall(ioFileIDPtr, sizeof(PdevClientIOHandle), name,
			    &hdrPtr);
d421 2
a422 2
	found = FsHandleInstall(ioFileIDPtr, sizeof(PdevClientIOHandle), name,
			&hdrPtr);
d431 2
a432 1
    cltHandlePtr->pdevHandlePtr = FsServerStreamCreate(ioFileIDPtr, name);
d437 1
@


8.1
log
@Double migration bug fix
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdevSetup.c,v 7.0 88/11/11 15:35:53 brent Exp $ SPRITE (Berkeley)";
d244 8
a262 3
	if (ctrlHandlePtr != (PdevControlIOHandle *)NIL) {
	    FsHandleRelease(ctrlHandlePtr, TRUE);
	}
d303 1
d341 3
@


8.0
log
@Changing version numbers.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdevSetup.c,v 7.0 88/11/11 15:35:53 brent Exp Locker: douglis $ SPRITE (Berkeley)";
d606 1
d633 2
a634 1
    FsStreamMigClient(migInfoPtr, dstClientID, (FsHandleHeader *)cltHandlePtr);
d640 1
a640 1
			dstClientID, migInfoPtr->flags);
@


7.0
log
@New version for conversion to new C library
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdevSetup.c,v 6.6 88/11/02 11:07:13 brent Exp Locker: brent $ SPRITE (Berkeley)";
@


6.6
log
@Moved FsServerStreamCreate back to fsPdev.c because it uses
internal state bit definitions
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdevSetup.c,v 6.5 88/10/22 15:20:23 brent Exp $ SPRITE (Berkeley)";
d174 1
a174 1
	    pdevStatePtr = Mem_New(FsPdevState);
d289 1
a289 1
    notifyPtr = Mem_New(PdevNotify);
d335 1
a335 1
    Mem_Free((Address)streamData);
d380 1
a380 1
	    Sys_Panic(SYS_WARNING,
d382 1
a382 1
	    Sys_Printf("Check (and kill) client process %x\n",
d396 1
a396 1
	    Sys_Panic(SYS_FATAL, "FsPdevConnect handle still there\n");
d473 1
a473 1
    Mem_Free((Address)pdevStatePtr);
d518 1
a518 1
	Sys_Panic(SYS_WARNING, "FsPseudoStreamClose: client %d not found\n",
d563 1
a563 1
    Sys_Panic(SYS_FATAL, "FsPseudoStreamRelease called\n");
d619 1
a619 1
	Sys_Panic(SYS_FATAL, "FsPseudoStreamMigrate, no client handle <%d,%x,%x>\n",
d701 1
a701 1
	Sys_Panic(SYS_WARNING, "FsRmtDeviceMigrate, server error <%x>\n",
d747 1
a747 1
	Sys_Panic(SYS_FATAL, "FsPseudoStreamMigEnd, no handle.\n");
d795 1
a795 1
	Sys_Panic(SYS_WARNING, "FsRmtPseudoStreamVerify, bad type <%d>\n",
d813 1
a813 1
	Sys_Panic(SYS_WARNING,
@


6.5
log
@Changed CltOpen routine to use new FsRemoteIOHandleInit
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdevSetup.c,v 6.4 88/10/20 15:48:31 brent Exp $ SPRITE (Berkeley)";
a421 84
}

/*
 *----------------------------------------------------------------------
 *
 * FsServerStreamCreate --
 *
 *	Set up the stream state for a server's private channel to a client.
 *	This creates a PdevServerIOHandle that has all the state for the
 *	connection to the client.
 *
 * Results:
 *	A pointer to the I/O handle created.  The handle is locked.
 *	NIL is returned if a handle under the fileID already existed.
 *
 * Side effects:
 *	The I/O handle for this connection between a client and the server
 *	is installed and initialized.
 *
 *----------------------------------------------------------------------
 */

PdevServerIOHandle *
FsServerStreamCreate(ioFileIDPtr, name)
    Fs_FileID	*ioFileIDPtr;	/* File ID used for pseudo stream handle */
    char	*name;		/* File name for error messages */
{
    FsHandleHeader *hdrPtr;
    register PdevServerIOHandle *pdevHandlePtr;
    Boolean found;

    ioFileIDPtr->type = FS_SERVER_STREAM;
    found = FsHandleInstall(ioFileIDPtr, sizeof(PdevServerIOHandle), name,
			    &hdrPtr);
    pdevHandlePtr = (PdevServerIOHandle *)hdrPtr;
    if (found) {
	Sys_Panic(SYS_WARNING, "ServerStreamCreate, found handle <%x,%x,%x>\n",
		  hdrPtr->fileID.serverID, hdrPtr->fileID.major,
		  hdrPtr->fileID.minor);
	FsHandleRelease(pdevHandlePtr, TRUE);
	return((PdevServerIOHandle *)NIL);
    }

    DBG_PRINT( ("ServerStreamOpen <%d,%x,%x>\n",
	    ioFileIDPtr->serverID, ioFileIDPtr->major, ioFileIDPtr->minor) );

    /*
     * Initialize the state for the pseudo stream.  Remember that
     * the request and read ahead buffers for the pseudo-stream are set up
     * via IOControls by the server process later.
     */

    pdevHandlePtr->flags = 0;
    pdevHandlePtr->selectBits = 0;

    pdevHandlePtr->requestBuf.data = (Address)NIL;
    pdevHandlePtr->requestBuf.firstByte = -1;
    pdevHandlePtr->requestBuf.lastByte = -1;
    pdevHandlePtr->requestBuf.size = 0;

    pdevHandlePtr->readBuf.data = (Address)NIL;
    pdevHandlePtr->readBuf.firstByte = -1;
    pdevHandlePtr->readBuf.lastByte = -1;
    pdevHandlePtr->readBuf.size = 0;

    pdevHandlePtr->nextRequestBuffer = (Address)NIL;

    pdevHandlePtr->operation = PDEV_INVALID;
    pdevHandlePtr->replyBuf = (Address)NIL;
    pdevHandlePtr->serverPID = (Proc_PID)NIL;
    pdevHandlePtr->clientPID = (Proc_PID)NIL;
    pdevHandlePtr->clientWait.pid = NIL;
    pdevHandlePtr->clientWait.hostID = NIL;
    pdevHandlePtr->clientWait.waitToken = NIL;

    List_Init(&pdevHandlePtr->srvReadWaitList);
    List_Init(&pdevHandlePtr->cltReadWaitList);
    List_Init(&pdevHandlePtr->cltWriteWaitList);
    List_Init(&pdevHandlePtr->cltExceptWaitList);

    pdevHandlePtr->ctrlHandlePtr = (PdevControlIOHandle *)NIL;
    pdevHandlePtr->userLevelID = *ioFileIDPtr;

    return(pdevHandlePtr);
@


6.4
log
@Changed from MigStart to Release procedure to handle new structuring
of migration.  A callback is now made by the I/O server to the source
of migration when it is ok to release references on a stream, and perhaps
the underlying I/O handle.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdevSetup.c,v 6.3 88/10/19 09:57:38 brent Exp $ SPRITE (Berkeley)";
d358 2
a359 2
 *	Top-level streams are not created, that is left to our caller because
 *	of the various ways the connection will be used and set up.
d515 4
a518 3
 *	makes an RPC to the server's host to invoke FsPseudoStreamCltOpen.
 *	This host only keeps a FsRemoteIOHandle, and the FsRemoteIOClose
 *	routine is used to close it.
d541 1
a542 6
    register FsRecoveryInfo *recovPtr;
    Proc_ControlBlock *procPtr;
    FsRemoteIOHandle *rmtHandlePtr;
    int myStreamType;
    int serverStreamType = -1;
    Boolean found;
d545 1
a545 2
     * We are called for both FS_RMT_PFS_STREAM and FS_RMT_PSEUDO_STREAM.
     * These two differ only in the CltOpen routine called on the server.
a546 12
    myStreamType = ioFileIDPtr->type;
    if (myStreamType > 0 && myStreamType < FS_NUM_STREAM_TYPES) {
	serverStreamType = fsRmtToLclType[myStreamType];
    }
    if (serverStreamType != FS_LCL_PSEUDO_STREAM &&
	serverStreamType != FS_LCL_PFS_STREAM) {
	Sys_Panic(SYS_FATAL, "FsRmtPseudoStreamCltOpen, bad call\n");
	return(FAILURE);
    }
    /*
     * Use RPC to invoke either FsPseudoStreamCltOpen or FsPfsStreamCltOpen.
     */
d550 1
a550 1
    ioFileIDPtr->type = serverStreamType;
d554 2
a555 16
	/*
	 * Install a remote I/O handle and initialize its recovery state.
	 */
	ioFileIDPtr->type = myStreamType;
	found = FsHandleInstall(ioFileIDPtr, sizeof(FsRemoteIOHandle), name,
		(FsHandleHeader **)&rmtHandlePtr);
	recovPtr = &rmtHandlePtr->recovery;
	if (!found) {
	    FsRecoveryInit(recovPtr);
	}
	recovPtr->use.ref++;
	if (*flagsPtr & FS_WRITE) {
	    recovPtr->use.write++;
	}
	*ioHandlePtrPtr = (FsHandleHeader *)rmtHandlePtr;
	FsHandleUnlock(rmtHandlePtr);
@


6.3
log
@Moved FsServerStreamCreate to here from fsPdev.c.   It is only
called in one place, and may get in-lined soon.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: fsPdevSetup.c,v 6.2 88/10/14 12:19:33 brent Exp $ SPRITE (Berkeley)";
d233 1
a233 1
    Boolean			found;
d278 2
a279 1
		(FsHandleHeader *)cltHandlePtr, *flagsPtr, name, &found);
d326 1
a326 1
	if (!found) {
d445 1
a445 1
FsServerStreamCreate(ioFileIDPtr, userFileIDPtr, name)
a446 1
    Fs_FileID	*userFileIDPtr;	/* User-level fileID for pseudo-stream */
d503 1
a503 1
    pdevHandlePtr->userLevelID = *userFileIDPtr;
d659 1
a659 1
 * FsPseudoStreamMigStart --
d661 2
a662 4
 *	Begin migration of a pseudo-stream client.  We leave the state
 *	alone because the client handle, which is here on the same host
 *	as the pseudo-device master, will still be needed after the
 *	client is remote.
d674 1
a674 1
FsPseudoStreamMigStart(hdrPtr, flags, clientID, data)
a676 2
    int clientID;		/* Host doing the encapsulation */
    ClientData data;		/* Buffer we fill in */
d678 2
d747 1
a747 3
    FsStreamMigClient(&migInfoPtr->streamID, migInfoPtr->srcClientID,
		    dstClientID, (FsHandleHeader *)cltHandlePtr,
		    &migInfoPtr->offset, &migInfoPtr->flags);
d830 10
a839 4
 *	Complete migration for a pseudo stream.  Complete setup of a 
 *	FS_RMT_DEVICE_STREAM after migration.
 *	The srvMigrate routine has done most all the work.
 *	We just grab a reference on the I/O handle for the stream.
a936 52
}

/*
 *----------------------------------------------------------------------
 *
 * FsServerStreamMigStart --
 *
 *	It's too painful to migrate the pseudo-device server.
 *
 * Results:
 *	GEN_NOT_IMPLEMENTED.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsServerStreamMigStart(hdrPtr, flags, clientID, data)
    FsHandleHeader *hdrPtr;	/* File being encapsulated */
    int flags;			/* Use flags from the stream */
    int clientID;		/* Host doing the encapsulation */
    ClientData data;		/* Buffer we fill in */
{
    return(GEN_NOT_IMPLEMENTED);
}

/*
 *----------------------------------------------------------------------
 *
 * FsServerStreamMigEnd --
 *
 *	Complete migration for a server stream
 *
 * Results:
 *	GEN_NOT_IMPLEMENTED.
 *
 * Side effects:
 *	The streams that compose the Server stream are also deencapsulated.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsServerStreamMigEnd(migInfoPtr, size, data, hdrPtrPtr)
    FsMigInfo	*migInfoPtr;	/* Migration state */
    int		size;		/* Zero */
    ClientData	data;		/* NIL */
    FsHandleHeader **hdrPtrPtr;	/* Return - handle for the file */
{
    return(GEN_NOT_IMPLEMENTED);
@


6.2
log
@FsFileID FsUserID change
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: fsPdevSetup.c,v 6.1 88/10/14 10:42:17 brent Exp $ SPRITE (Berkeley)";
d421 85
@


6.1
log
@Reorganized things to use FsPdevConnect
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: fsPdevSetup.c,v 6.0 88/10/11 15:56:00 brent Exp $ SPRITE (Berkeley)";
d79 2
a80 2
     register FsFileID	*ioFileIDPtr;	/* Return - I/O handle ID */
     FsFileID		*streamIDPtr;	/* Return - stream ID. 
d89 1
a89 1
    FsFileID	ioFileID;
d137 1
a137 1
	if (streamIDPtr == (FsFileID *)NIL) {
d224 1
a224 1
    register FsFileID	*ioFileIDPtr;	/* I/O fileID */
d365 1
a365 1
    register FsFileID	*ioFileIDPtr;	/* I/O fileID */
d446 1
a446 1
    register FsFileID	*ioFileIDPtr;	/* I/O fileID */
d810 1
a810 1
    FsFileID	*fileIDPtr;	/* Client's I/O file ID */
@


6.0
log
@Cleaned up migration code.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: fsPdevSetup.c,v 1.3 88/10/10 11:32:41 douglis Exp $ SPRITE (Berkeley)";
a89 1
    Boolean	found;
d96 2
a97 2
     * file with type CONTROL.  The minor field has the disk decriptor version
     * number xor'ed into it to avoid conflict when you delete the
a98 4
     * Note, if this mapping is changed here on the file server, then
     * regular control stream recovery by clients won't work.  They will
     * recover their control handles, but we will map to a different handle
     * and thus think there is no server process.
d102 5
a106 3
    ioFileID.minor ^= (handlePtr->descPtr->version << 16);
    ctrlHandlePtr = FsControlHandleInit(&ioFileID, handlePtr->hdr.name,
					&found);
d112 1
a112 1
	if (found && ctrlHandlePtr->serverID != NIL) {
d143 1
a143 1
	} else if (!found || ctrlHandlePtr->serverID == NIL) {
d261 1
a261 18
    /*
     * Extract the seed from the minor field (see the SrvOpen routine).
     * This done in case of recovery when we'll need to reset the
     * seed kept on the file server.
     */
    ctrlHandlePtr->seed = ioFileIDPtr->minor & 0x0FFF;

    found = FsHandleInstall(ioFileIDPtr, sizeof(PdevClientIOHandle), name,
			    ioHandlePtrPtr);
    cltHandlePtr = (PdevClientIOHandle *)(*ioHandlePtrPtr);
    if (found) {
	if ((cltHandlePtr->pdevHandlePtr != (PdevServerIOHandle *)NIL) &&
	    (cltHandlePtr->pdevHandlePtr->clientPID != (unsigned int)NIL)) {
	    Sys_Panic(SYS_WARNING,
		"FsPseudoStreamCltOpen found client handle\n");
	    Sys_Printf("Check (and kill) client process %x\n",
		cltHandlePtr->pdevHandlePtr->clientPID);
	}
d263 3
a265 2
	 * Invalidate this lingering handle.  The client process is hung
	 * or suspended and hasn't closed its end of the pdev connection.
d267 2
a268 2
	FsHandleInvalidate((FsHandleHeader *)cltHandlePtr);
	FsHandleRelease(cltHandlePtr, TRUE);
d270 3
a272 6
	found = FsHandleInstall(ioFileIDPtr, sizeof(PdevClientIOHandle), name,
			ioHandlePtrPtr);
	cltHandlePtr = (PdevClientIOHandle *)(*ioHandlePtrPtr);
	if (found) {
	    Sys_Panic(SYS_FATAL, "FsPseudoStreamCltOpen handle still there\n");
	}
d275 1
a275 1
     * Put the client on the stream list.
d280 1
d282 2
a283 3
     * We have to look around and decide if we are being called
     * from Fs_Open, or via RPC from a remote client.  A remote client's
     * processID and uid are passed to us via the FsPdevState.
d285 21
d314 4
a317 6
    /*
     * Set up the connection state and hook the client handle to it.
     */
    cltHandlePtr->pdevHandlePtr = FsServerStreamCreate(ioFileIDPtr, name);
    if (cltHandlePtr->pdevHandlePtr == (PdevServerIOHandle *)NIL) {
	status = FAILURE;
d320 1
a320 2
	 * Set up a stream for the server process.  This will be picked
	 * up by FsControlRead and converted to a user-level streamID.
a321 41
	srvStreamPtr = FsStreamNewClient(rpc_SpriteID, rpc_SpriteID,
				(FsHandleHeader *)cltHandlePtr->pdevHandlePtr,
				FS_READ|FS_USER, name);
	notifyPtr = Mem_New(PdevNotify);
	notifyPtr->streamPtr = srvStreamPtr;
	List_InitElement((List_Links *)notifyPtr);
	List_Insert((List_Links *)notifyPtr,
		    LIST_ATREAR(&ctrlHandlePtr->queueHdr));
	FsHandleUnlock(srvStreamPtr);

	FsFastWaitListNotify(&ctrlHandlePtr->readWaitList);
	FsHandleUnlock(cltHandlePtr->pdevHandlePtr);
	/*
	 * Set up the client list in case the client is remote.
	 */
	List_Init(&cltHandlePtr->clientList);
	(void)FsIOClientOpen(&cltHandlePtr->clientList, clientID, 0, FALSE);
	FsHandleRelease(ctrlHandlePtr, TRUE);
	/*
	 * Grab an extra reference to the server's handle so the
	 * server close routine can remove the handle and it won't
	 * go away until the client also closes.
	 */
	(void)FsHandleDup((FsHandleHeader *)cltHandlePtr->pdevHandlePtr);
	FsHandleUnlock(cltHandlePtr->pdevHandlePtr);
	/*
	 * Now that the request response stream is set up we do
	 * our first transaction with the server process to see if it
	 * will accept the open.  We unlock the handle and rely on the
	 * per-connection monitor lock instead.  This is important because a
	 * buggy pseudo-device server could be ignoring this connection
	 * request indefinitely, and leaving handles locked for long periods
	 * clogs up handle scavenging, and potentially recovery callbacks too.
	 */
	FsHandleUnlock(cltHandlePtr);
	status = FsPseudoStreamOpen(cltHandlePtr->pdevHandlePtr, *flagsPtr,
				    clientID, procID, uid);
    }
    if (status == SUCCESS) {
	*ioHandlePtrPtr = (FsHandleHeader *)cltHandlePtr;
    } else {
d327 2
a328 1
	     * Nuke shadow stream.
d341 85
d459 2
d464 2
a465 3
     * Invoke via RPC FsPseudoStreamCltOpen.  Here we use the procID field
     * of the FsPdevState so that FsPseudoStreamCltOpen can pass them
     * to FsServerStreamCreate.
d467 12
d482 1
a482 1
    ioFileIDPtr->type = FS_LCL_PSEUDO_STREAM;
d489 1
a489 1
	ioFileIDPtr->type = FS_RMT_PSEUDO_STREAM;
d818 9
a826 1
    fileIDPtr->type = FS_LCL_PSEUDO_STREAM;
d842 3
a844 2
	    "FsRmtPseudoDeviceVerify, client %d not known for pdev <%x,%x>\n",
	    clientID, fileIDPtr->major, fileIDPtr->minor);
@


1.3
log
@Keep around reference counts for shadow streams.  Got rid of 
clientdata argument to *MigStart routines, and pass in migFlagsPtr
instead so LAST_WRITER can be set.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: fsPdevSetup.c,v 1.2 88/10/05 16:59:55 brent Exp $ SPRITE (Berkeley)";
d133 2
a134 2
	    streamPtr = FsStreamNew(rpc_SpriteID,
		(FsHandleHeader *)ctrlHandlePtr, useFlags,
d137 1
a137 3
	    (void)FsStreamClientOpen(&streamPtr->clientList,
				     clientID,useFlags);
	    FsHandleUnlock(streamPtr);
d188 2
a189 5
	    streamPtr = FsStreamNew(ctrlHandlePtr->serverID,
			(FsHandleHeader *)NIL, useFlags, handlePtr->hdr.name);
	    *streamIDPtr = streamPtr->hdr.fileID;
	    pdevStatePtr->streamID = streamPtr->hdr.fileID;
	    FsStreamDispose(streamPtr);
d297 6
d305 1
a305 4
     * processID and uid are passed to us via the FsPdevState.  We also
     * have to ensure that a FS_STREAM exists and has the client
     * on its list so the client's remote I/O ops. are accepted here, and
     * so that we have the right number of client references.
a306 4
    cltStreamPtr = FsStreamFind(&pdevStatePtr->streamID,
		(FsHandleHeader *)cltHandlePtr, *flagsPtr, name, &found);
    (void)FsStreamClientOpen(&cltStreamPtr->clientList,
			    clientID, *flagsPtr);
a310 1
	FsHandleRelease(cltStreamPtr, TRUE);
a313 4
	/*
	 * Keep a reference to the stream that will be released by Fs_RpcClose.
	 */
	FsHandleUnlock(cltStreamPtr);
d326 1
a326 1
	srvStreamPtr = FsStreamNew(rpc_SpriteID,
d335 1
a583 4
    register Fs_Stream			*streamPtr;
    Boolean				found;
    Boolean				cache = FALSE;
    Boolean				keepReference = FALSE;
d610 4
a613 35
    streamPtr = FsStreamFind(&migInfoPtr->streamID,
			     (FsHandleHeader *)cltHandlePtr, migInfoPtr->flags,
			     (char *)NIL, &found);
    if ((streamPtr->flags & FS_RMT_SHARED) == 0) {
	/*
	 * We don't think the stream is being shared so we
	 * grab the offset from the client.
	 */
	streamPtr->offset = migInfoPtr->offset;
    }
    if ((migInfoPtr->flags & FS_RMT_SHARED) == 0) {
	/*
	 * The client doesn't perceive sharing of the stream so
	 * it must be its last reference so we do an I/O close.
	 */
	(void)FsStreamClientClose(&streamPtr->clientList,
				migInfoPtr->srcClientID);
    } else if (migInfoPtr->flags & FS_NEW_STREAM) {
	keepReference = TRUE;
    }
    if (FsStreamClientOpen(&streamPtr->clientList, dstClientID,
	    migInfoPtr->flags)) {
	/*
	 * We detected network sharing so we mark the stream.
	 */
	streamPtr->flags |= FS_RMT_SHARED;
#ifdef notdef
	migInfoPtr->flags |= FS_RMT_SHARED;
#endif notdef
    }
    if (keepReference) {
	FsHandleUnlock(streamPtr);
    } else {
	FsHandleRelease(streamPtr, TRUE);
    }
d615 1
a615 4
     * Move the client at the I/O handle level.  We are careful to only
     * close the srcClient if its migration state indicates it isn't
     * shared.  We are careful to only open the dstClient if it getting
     * the stream for the first time.
d617 2
a618 13
    if ((migInfoPtr->flags & FS_RMT_SHARED) == 0) {
	found = FsIOClientClose(&cltHandlePtr->clientList,
		    migInfoPtr->srcClientID, migInfoPtr->flags, &cache);
	if (!found) {
	    Sys_Panic(SYS_WARNING,
		"FsPseudoStreamMigrate, IO Client %d not found\n",
		migInfoPtr->srcClientID);
	}
    }
    if (migInfoPtr->flags & FS_NEW_STREAM) {
	(void)FsIOClientOpen(&cltHandlePtr->clientList, dstClientID,
		migInfoPtr->flags, FALSE);
    }
d622 2
a623 2
    *flagsPtr = streamPtr->flags;
    *offsetPtr = streamPtr->offset;
@


1.2
log
@name changes, plus setting domainTypePtr in FsRmtPseudoStreamVerify.
[ci by FD]
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: fsPdevSetup.c,v 1.1 88/10/03 09:05:26 brent Exp $ SPRITE (Berkeley)";
d139 1
a139 1
	    FsHandleRelease(streamPtr, TRUE);
d597 1
d641 2
d650 1
d652 1
d654 5
a658 1
    FsHandleRelease(streamPtr, TRUE);
@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: fsPdev.c,v 6.15 88/09/28 15:24:19 douglis Exp $ SPRITE (Berkeley)";
d329 1
a329 2
    cltHandlePtr->pdevHandlePtr = FsServerStreamCreate(ioFileIDPtr, clientID,
							name);
d337 1
a337 1
	streamPtr = FsStreamNew(rpc_SpriteID,
d341 1
a341 1
	notifyPtr->streamPtr = streamPtr;
d345 1
a345 1
	FsHandleUnlock(streamPtr);
d519 1
a519 1
	PseudoStreamCloseInt(cltHandlePtr->pdevHandlePtr);
d805 1
a805 1
FsRmtPseudoStreamVerify(fileIDPtr, clientID)
d808 1
d832 3
@
