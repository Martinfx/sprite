head     9.4;
branch   ;
access   ;
symbols  ds3100:9.4 sun3:9.4 sprited:9.3.1 sun4nw:9.3 symm:9.3 spur:9.3 Summer89:9.0 newlib:8.0;
locks    ; strict;
comment  @ * @;


9.4
date     92.08.10.17.29.58;  author mgbaker;  state Exp;
branches ;
next     9.3;

9.3
date     91.06.26.01.05.59;  author mottsmth;  state Exp;
branches 9.3.1.1;
next     9.2;

9.2
date     91.06.23.16.43.18;  author mottsmth;  state Exp;
branches ;
next     9.1;

9.1
date     90.10.08.12.43.48;  author mendel;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.08.33;  author douglis;  state Stable;
branches ;
next     8.14;

8.14
date     89.08.21.15.28.06;  author mendel;  state Exp;
branches ;
next     8.13;

8.13
date     89.06.30.15.30.59;  author brent;  state Exp;
branches ;
next     8.12;

8.12
date     89.06.15.09.23.04;  author brent;  state Exp;
branches ;
next     8.11;

8.11
date     89.06.07.15.30.50;  author brent;  state Exp;
branches ;
next     8.10;

8.10
date     89.03.17.12.49.30;  author brent;  state Exp;
branches ;
next     8.9;

8.9
date     89.03.14.10.42.33;  author brent;  state Exp;
branches ;
next     8.8;

8.8
date     89.02.09.09.27.06;  author brent;  state Exp;
branches ;
next     8.7;

8.7
date     89.02.04.12.09.13;  author brent;  state Exp;
branches ;
next     8.6;

8.6
date     89.01.30.14.05.18;  author brent;  state Exp;
branches ;
next     8.5;

8.5
date     89.01.25.13.31.52;  author brent;  state Exp;
branches ;
next     8.4;

8.4
date     89.01.25.09.52.42;  author brent;  state Exp;
branches ;
next     8.3;

8.3
date     89.01.24.12.25.15;  author brent;  state Exp;
branches ;
next     8.2;

8.2
date     89.01.04.08.53.05;  author brent;  state Exp;
branches ;
next     8.1;

8.1
date     88.12.21.10.17.48;  author brent;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.23.58;  author douglis;  state Stable;
branches ;
next     7.0;

7.0
date     88.11.11.15.34.23;  author brent;  state Exp;
branches ;
next     6.8;

6.8
date     88.11.07.09.05.01;  author brent;  state Exp;
branches ;
next     6.7;

6.7
date     88.11.02.16.03.33;  author brent;  state Exp;
branches ;
next     6.6;

6.6
date     88.11.02.11.06.37;  author brent;  state Exp;
branches ;
next     6.5;

6.5
date     88.10.22.15.21.10;  author brent;  state Exp;
branches ;
next     6.4;

6.4
date     88.10.20.15.50.43;  author brent;  state Exp;
branches ;
next     6.3;

6.3
date     88.10.19.09.55.03;  author brent;  state Exp;
branches ;
next     6.2;

6.2
date     88.10.14.12.18.15;  author brent;  state Exp;
branches ;
next     6.1;

6.1
date     88.10.14.10.39.10;  author brent;  state Exp;
branches ;
next     6.0;

6.0
date     88.10.11.15.52.49;  author brent;  state Exp;
branches ;
next     ;

9.3.1.1
date     91.11.15.16.30.38;  author kupfer;  state Exp;
branches ;
next     ;


desc
@Implementation of pseudo-filesystems.  This uses the pseudo-device
interface defined in fsPdev.c
@


9.4
log
@Changes for transparent server recovery.
@
text
@/*
 * fsPfs.c --
 *
 *	Routines specific to the pseudo-filesystem implementation.
 *	The pseudo-filesystem server uses the same request response
 *	protocol as with pseudo-devices.  The overall stream setup is
 *	a bit different, however.  The server process gets back a
 *	"naming" stream when it opens a remote link with the FS_PFS_MASTER
 *	flag.  The kernel forwards naming operations (Fs_Open, Fs_Remove,
 *	Fs_MakeDir, Fs_RemoveDir, Fs_MakeDevice, Fs_Rename, Fs_Hardlink)
 *	to the server using the request response protocol over the
 *	naming stream.  Thus the naming stream is like the server stream
 *	returned to pseudo-device servers via its control stream, and the
 *	client side of the naming stream is hung off the prefix table.
 *
 *	The pseudo-filesystem server can either return a pseudo-device
 *	kind of connection in response to opens by clients, or it can
 *	return a stream to a regular file or device.  Also, the server
 *	can be private to a host, or it can export itself to the network.
 *	
 *
 * Copyright 1987, 1988 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fspdev/fspdevPfs.c,v 9.3 91/06/26 01:05:59 mottsmth Exp $ SPRITE (Berkeley)";
#endif not lint

#include <sprite.h>
#include <fs.h>
#include <fsutil.h>
#include <fsNameOps.h>
#include <fsio.h>
#include <fsconsist.h>
#include <fsdm.h>
#include <fsioLock.h>
#include <fsprefix.h>
#include <fsStat.h>
#include <proc.h>
#include <rpc.h>
#include <fspdev.h>
#include <fspdevInt.h>
#include <dev/pfs.h>
#include <string.h>
#include <fsrecov.h>
#include <recov.h>

static Fspdev_ServerIOHandle *PfsGetUserLevelIDs _ARGS_((
	Fspdev_ServerIOHandle *pdevHandlePtr, Fs_FileID *prefixIDPtr, 
	Fs_FileID *rootIDPtr));

/*
 *----------------------------------------------------------------------------
 *
 * FspdevRmtLinkNameOpen --
 *
 *	The user-level server for a pseudo-filesystem is established by
 *	opening a remote link type file with the FS_PFS_MASTER flag.
 *	This procedure is invoked on the file server when remote links
 *	are opened and detects this situation.  (If FS_PFS_MASTER is
 *	not specified then Fsio_FileNameOpen is called and the remote link
 *	is treated normally.)  Futhermore, there are two kinds of
 *	pseudo-filesystem servers, "local agents" and "network agents".
 *	If the FS_EXCLUSIVE flag is specified a local agent is created
 *	and only the opening host sees the pseudo-filesystem.  Otherwise
 *	the host sets up a network agent and exports the pseudo-filesystem
 *	to the whole Sprite network.  In the latter case a control stream
 *	is created here on the file server to record the server's existence.
 *
 * Results:
 *	A status is returned that indicates conflict if another server exists.
 *	A fileID and a streamID are also chosen for the naming stream.
 *
 * Side effects:
 *	A control I/O handle is created here on the file server to record
 *	who is the server for the pseudo device.  The handle for the
 *	remote link file is unlocked.
 *
 *----------------------------------------------------------------------------
 *
 */
ReturnStatus
FspdevRmtLinkNameOpen(handlePtr, openArgsPtr, openResultsPtr)
     register Fsio_FileIOHandle *handlePtr;	/* A handle from FslclLookup.
					 * Should be LOCKED upon entry,
					 * unlocked upon exit. */
     Fs_OpenArgs		*openArgsPtr;	/* Standard open arguments */
     Fs_OpenResults	*openResultsPtr;/* For returning ioFileID, streamID */
{
    register ReturnStatus status = SUCCESS;
    register Fs_FileID *ioFileIDPtr = &openResultsPtr->ioFileID;
    Fsrecov_HandleState	recovInfo;

    if ((openArgsPtr->useFlags & FS_PFS_MASTER) == 0) {
	return(Fsio_FileNameOpen(handlePtr, openArgsPtr, openResultsPtr));
    }
    /*
     * Generate an ID which is just like a FSIO_CONTROL_STREAM, except that
     * the serverID will be set to us, the file server, for exported
     * pseudo-filesystems, or set to the host running the server if the
     * pseudo-filesystem is not exported.
     */
    ioFileIDPtr->type = FSIO_PFS_CONTROL_STREAM;
    ioFileIDPtr->major = handlePtr->hdr.fileID.major;
    ioFileIDPtr->minor = handlePtr->hdr.fileID.minor ^
			 (handlePtr->descPtr->version << 16);
    if (openArgsPtr->useFlags & FS_EXCLUSIVE) {
	/*
	 * The pseudo-filesystem server is private to the client host.
	 * We further uniqify its control handle ID to avoid conflict with
	 * files from other servers.  We set the serverID to the host
	 * running the server so we won't see closes or re-opens.
	 */
	ioFileIDPtr->serverID = openArgsPtr->clientID;
	ioFileIDPtr->major ^= rpc_SpriteID << 16;
	Fsio_StreamCreateID(openArgsPtr->clientID, &openResultsPtr->streamID);
    } else {
	/*
	 * The pseudo-filesystem will be exported to the network.  Setting
	 * the serverID of the I/O handle to us means we'll see a close
	 * and possibly some reopens, we can do conflict checking.  However,
	 * the streamID we choose is used for the server half of the naming
	 * request-response stream, which sort of points sideways at the
	 * control handle on the client.  Thus there is no shadow stream,
	 * only a control handle here..
	 */
	register Fspdev_ControlIOHandle *ctrlHandlePtr;

	ioFileIDPtr->serverID = rpc_SpriteID;
	ctrlHandlePtr = FspdevControlHandleInit(ioFileIDPtr, handlePtr->hdr.name);
	if (ctrlHandlePtr->serverID != NIL) {
	    status = FS_FILE_BUSY;
	} else {
	    ctrlHandlePtr->serverID = openArgsPtr->clientID;
	    Fsio_StreamCreateID(openArgsPtr->clientID, &openResultsPtr->streamID);
	}
	/*
	 * We're the name server for this remote link, and if we're not
	 * the machine running the pseudo file system, then we update
	 * the recov box.
	 */
	if (recov_Transparent && openArgsPtr->clientID != rpc_SpriteID) {
	    if (fsrecov_DebugLevel <= 2) {
		printf("FspdevRmtLinkNameOpen: Adding pfs control handle ");
		printf("%d.%d.%d.%d\n\tclient %d, serverID %d\n",
			((Fs_HandleHeader *) ctrlHandlePtr)->fileID.type,
			((Fs_HandleHeader *) ctrlHandlePtr)->fileID.serverID,
			((Fs_HandleHeader *) ctrlHandlePtr)->fileID.major,
			((Fs_HandleHeader *) ctrlHandlePtr)->fileID.minor,
			openArgsPtr->clientID, ctrlHandlePtr->serverID);
	    }
/* MIMIC PDEV_BUG */
	    if (Fsrecov_GetHandle(((Fs_HandleHeader *) ctrlHandlePtr)->fileID,
		    openArgsPtr->clientID, &recovInfo, FALSE) == SUCCESS) {
		recovInfo.info = ctrlHandlePtr->serverID;
		recovInfo.clientData = ctrlHandlePtr->seed;
		if (Fsrecov_UpdateHandle(((Fs_HandleHeader *)
			ctrlHandlePtr)->fileID, openArgsPtr->clientID,
			&recovInfo) != SUCCESS) {
		    panic("FspdevRmtLinkNameOpen: couldn't update handle.");
		}
	    } else {
/* END_MIMIC_PDEV_BUG */
		status = Fsrecov_AddHandle((Fs_HandleHeader *) ctrlHandlePtr,
			(Fs_FileID *) NIL, openArgsPtr->clientID, 0,
			ctrlHandlePtr->seed, TRUE);
		/* We'll have to do better than this! */
		if (status != SUCCESS) {
		    panic("FspdevRmtLinkNameOpen: couldn't add handle.");
		}
	    }
	}
	Fsutil_HandleRelease(ctrlHandlePtr, TRUE);
    }
    openResultsPtr->streamData = (ClientData)NIL;
    openResultsPtr->dataSize = 0;
    Fsutil_HandleUnlock(handlePtr);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPfsIoOpen --
 *
 *	This is called from Fs_Open to complete setup of the stream
 *	returned to the server of a pseudo-filesystem.  This stream
 *	is called a "naming stream" because it will be used to
 *	forward naming operations from the kernel up to the server.
 *	It is structured just like the regular pseudo-device request
 *	response stream, however.  The service end is returned to
 *	the server and the client end is hung off the prefix table.
 *
 *	Note: we contrain the file name being opened to be the absolute
 *	prefix of the pseudo-filesystem.  To fix this you'd need to extract
 *	the prefix over at the file server and return it in the stream data.
 * 
 * Results:
 *	SUCCESS, unless an exclusive (private) pseudo-filesystem server
 *	already exists on this host.
 *
 * Side effects:
 *	Three handles are created.  They have the same server, major, and minor,
 *	but differ in their types (FSIO_PFS_CONTROL_STREAM, FSIO_SERVER_STREAM,
 *	and FSIO_LCL_PSEUDO_STREAM).  The server stream is returned to our caller,
 *	the client stream is hooked to the prefix table, and the control
 *	stream is left around for conflict checking.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevPfsIoOpen(ioFileIDPtr, flagsPtr, clientID, streamData, name,
	ioHandlePtrPtr)
    register Fs_FileID	*ioFileIDPtr;	/* I/O fileID */
    int			*flagsPtr;	/* FS_READ | FS_WRITE ... */
    int			clientID;	/* Host doing the open */
    ClientData		streamData;	/* Pointer to Fspdev_State. */
    char		*name;		/* File name for error msgs */
    Fs_HandleHeader	**ioHandlePtrPtr;/* Return - a locked handle set up for
					 * I/O to a pseudo device, or NIL */
{
    register ReturnStatus	status = SUCCESS;
    register Fspdev_ControlIOHandle *ctrlHandlePtr;
    register Fspdev_ServerIOHandle *pdevHandlePtr;
    register Fspdev_ClientIOHandle *cltHandlePtr;
    Fs_HandleHeader		*prefixHdrPtr;
    Fs_FileID			rootID;
    int				domain;
    int				id;
    char			*ignoredName;
    Fsprefix			*prefixPtr;
    int				prefixFlags;

    /*
     * Constrain the name to be an absolute prefix to keep things simple.
     * Then verify that the prefix is not already handled by someone.
     */
    if (name[0] != '/') {
	printf(
	    "Need absolute name (not \"%s\") for pseudo-filesystem\n", name);
	return(FS_INVALID_ARG);
    }
    status = Fsprefix_Lookup(name,
		FSPREFIX_IMPORTED|FSPREFIX_EXPORTED|FSPREFIX_EXACT, -1,
		&prefixHdrPtr, &rootID, &ignoredName, &id, &domain, &prefixPtr);
    if (status == SUCCESS) {
	printf( "Prefix \"%s\" already serviced\n", name);
	return(FS_FILE_BUSY);
    } else {
	status = SUCCESS;
    }
    /*
     * Nuke this meaningless flag so we don't get an I/O control from Fs_Open.
     */
    *flagsPtr &= ~FS_TRUNC;
    /*
     * Create a control handle that contains the seed used to generate
     * pseudo-device connections to the pseudo-filesystem server.  It is
     * important to set the serverID so the control stream won't get scavenged.
     */
    ctrlHandlePtr = FspdevControlHandleInit(ioFileIDPtr, name);
    ctrlHandlePtr->serverID = rpc_SpriteID;
    /*
     * Setup the request-response connection, and return the server
     * end to the calling process.  We save a back pointer to the
     * control stream so we can generate new request-response connections
     * when clients do opens in the pseudo-filesystem, and so we
     * can close it and clean up the prefix table when the server process exits.
     */
    ioFileIDPtr->type = FSIO_LCL_PSEUDO_STREAM;
    ioFileIDPtr->serverID = rpc_SpriteID;
    cltHandlePtr = FspdevConnect(ctrlHandlePtr, ioFileIDPtr, rpc_SpriteID, 1);
    if (cltHandlePtr == (Fspdev_ClientIOHandle *)NIL) {
	status = FAILURE;
	goto cleanup;
    }
    pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
    *ioHandlePtrPtr = (Fs_HandleHeader *)pdevHandlePtr;
    /*
     * This ID gets passed in Fs_LookupArgs
     * as the prefixID if the prefix is the root of the pseudo domain.
     * It can be reset by the user with IOC_PFS_SET_ROOT.
     */
    pdevHandlePtr->userLevelID.type = 0;
    pdevHandlePtr->userLevelID.serverID = 0;
    pdevHandlePtr->userLevelID.major = 0;
    pdevHandlePtr->userLevelID.minor = 0;
    /*
     * Install the client side of the connection in the prefix table.
     */
    prefixFlags = FSPREFIX_IMPORTED;
    if (*flagsPtr & FS_EXCLUSIVE) {
	prefixFlags |= FSPREFIX_LOCAL;
    } else {
	prefixFlags |= FSPREFIX_EXPORTED;
    }
    ctrlHandlePtr->prefixPtr = Fsprefix_Install(name,
		(Fs_HandleHeader *)cltHandlePtr, FS_PSEUDO_DOMAIN, prefixFlags);
    /*
     * No migration of pseudo-filesystem servers.
     */
    Proc_NeverMigrate(Proc_GetCurrentProc());
    Fsutil_HandleUnlock(cltHandlePtr);
cleanup:
    if (status != SUCCESS) {
	Fsutil_HandleRelease(ctrlHandlePtr, TRUE);
	*ioHandlePtrPtr = (Fs_HandleHeader *)NIL;
    } else {
	Fsutil_HandleUnlock(ctrlHandlePtr);
    }
    return(status);

}

/*
 *----------------------------------------------------------------------------
 *
 * FspdevPfsExport --
 *
 *	This is called from the Fsrmt_RpcPrefix stub to complete setup for
 *	a client that will be importing a prefix of a pseudo-filesystem
 *	that has its server process on this host.  This has to add the
 *	client to the client end of the naming request response stream
 *	so future naming operations by that client are accepted here.
 *	The remote Sprite host will call FspdevPfsNamingIoOpen to set
 *	up the handle that it will attach to its own prefix table.
 *
 * Results:
 *	This returns a fileID that the client will use to set up its I/O handle.
 *
 * Side effects:
 *	A control I/O handle is created here on the file server to record
 *	who is the server for the pseudo device.
 *
 *----------------------------------------------------------------------------
 *
 */
ReturnStatus
FspdevPfsExport(hdrPtr, clientID, ioFileIDPtr, dataSizePtr, clientDataPtr)
     Fs_HandleHeader	*hdrPtr;	/* A handle from the prefix table. */
     int		clientID;	/* Host ID of client importing prefix */
     register Fs_FileID	*ioFileIDPtr;	/* Return - I/O handle ID */
     int		*dataSizePtr;	/* Return - 0 */
     ClientData		*clientDataPtr;	/* Return - NIL */
{
    register Fspdev_ClientIOHandle *cltHandlePtr = (Fspdev_ClientIOHandle *)hdrPtr;
    register ReturnStatus status;

    Fsutil_HandleLock(cltHandlePtr);
    if (FspdevPdevServerOK(cltHandlePtr->pdevHandlePtr)) {
	(void)Fsconsist_IOClientOpen(&cltHandlePtr->clientList, clientID, 0, FALSE);
	*ioFileIDPtr = cltHandlePtr->hdr.fileID;
	ioFileIDPtr->type = FSIO_PFS_NAMING_STREAM;
	*dataSizePtr = 0;
	*clientDataPtr = (ClientData)NIL;
	status = SUCCESS;
    } else {
	status = FAILURE;
    }
    Fsutil_HandleUnlock(cltHandlePtr);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPfsNamingIoOpen --
 *
 *	This is called from FsrmtImport to complete setup of the I/O
 *	handle that hangs off the prefix table.  This stream
 *	is called a "naming stream" because it will be used to
 *	forward naming operations to the pseudo-filesystem server.  This
 *	routine is similar to FspdevRmtPseudoStreamIoOpen, except that at
 *	this point the server already knows about us, so we don't have
 *	to contact it with Fsrmt_DeviceOpen.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Creates a FSIO_PFS_NAMING_STREAM, which is like a FSIO_RMT_PSEUDO_STREAM
 *	in that its operations are forwarded via RPC to the host running
 *	the pseudo-filesystem server.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevPfsNamingIoOpen(ioFileIDPtr, flagsPtr, clientID, streamData, name,
	ioHandlePtrPtr)
    register Fs_FileID	*ioFileIDPtr;	/* I/O fileID */
    int			*flagsPtr;	/* FS_READ | FS_WRITE ... */
    int			clientID;	/* Host doing the open */
    ClientData		streamData;	/* Pointer to Fspdev_State. */
    char		*name;		/* File name for error msgs */
    Fs_HandleHeader	**ioHandlePtrPtr;/* Return - a locked handle set up for
					 * I/O to a pseudo device, or NIL */
{
    Boolean found;
    Fsrmt_IOHandle *rmtHandlePtr;

    found = Fsutil_HandleInstall(ioFileIDPtr, sizeof(Fsrmt_IOHandle), name,
			FALSE, (Fs_HandleHeader **)&rmtHandlePtr);
    if (!found) {
	Fsutil_RecoveryInit(&rmtHandlePtr->recovery);
	fs_Stats.object.remote++;
    }
    rmtHandlePtr->recovery.use.ref++;
    *ioHandlePtrPtr = (Fs_HandleHeader *)rmtHandlePtr;
    Fsutil_HandleUnlock(rmtHandlePtr);
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPfsDomainInfo --
 *
 *	Get information about a pseudo-file-system.
 *
 * Results:
 *	An error status
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
FspdevPfsDomainInfo(fileIDPtr, domainInfoPtr)
    Fs_FileID *fileIDPtr;
    Fs_DomainInfo *domainInfoPtr;
{
    ReturnStatus		status;
    Pfs_Request			request;
    Fs_RedirectInfo		*redirectPtr;
    Fspdev_ClientIOHandle		*cltHandlePtr;
    int				resultSize;

    status = FS_FILE_NOT_FOUND;
    cltHandlePtr = Fsutil_HandleFetchType(Fspdev_ClientIOHandle, fileIDPtr);
    if (cltHandlePtr != (Fspdev_ClientIOHandle *)NIL) {
	Fsutil_HandleUnlock(cltHandlePtr);
	/*
	 * Go to the pseudo-device server to get the domain information.
	 * We also change the fileID of the domain to be the user-visible
	 * one so that the getwd() library call works right.
	 */
	*fileIDPtr = cltHandlePtr->pdevHandlePtr->userLevelID;
	fileIDPtr->serverID = rpc_SpriteID;

	request.hdr.operation = PFS_DOMAIN_INFO;
	request.param.domainInfo = *fileIDPtr;
	resultSize = sizeof(Fs_DomainInfo);
	status = FspdevPseudoStreamLookup(cltHandlePtr->pdevHandlePtr, &request,
		    0, (Address)NIL,
		    &resultSize, (Address)domainInfoPtr, &redirectPtr);
	if (redirectPtr != (Fs_RedirectInfo *)NIL) {
	    free((Address)redirectPtr);
	}
	Fsutil_HandleRelease(cltHandlePtr, FALSE);
    }
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * FspdevPfsOpen --
 *
 *	Open a file served by a pseudo-filesystem server.  The stream returned
 *	to the client can either be a pseudo-device connection to the
 *	server of the pseudo-filesystem, or a regular stream that has
 *	been passed off from the server process.
 *
 * Results:
 *	SUCCESS, FS_REDIRECT, or some error code from the lookup on the server.
 *	If FS_REDIRECT, then *newNameInfoPtr has prefix information.
 *
 * Side effects:
 *	None here.  The connections are setup in the server IOControl routine.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
FspdevPfsOpen(prefixHandle, relativeName, argsPtr, resultsPtr, 
	     newNameInfoPtrPtr)
    Fs_HandleHeader  *prefixHandle;	/* Handle from prefix table or cwd */
    char 	  *relativeName;	/* The name of the file to open. */
    Address 	  argsPtr;		/* Ref. to Fs_OpenArgs */
    Address 	  resultsPtr;		/* Ref. to Fs_OpenResults */
    Fs_RedirectInfo **newNameInfoPtrPtr;	/* We return this if the server leaves 
					 * its domain during the lookup. */
{
    register Fspdev_ClientIOHandle	*cltHandlePtr;
    register Fspdev_ServerIOHandle *pdevHandlePtr;
    register Fs_OpenArgs		*openArgsPtr = (Fs_OpenArgs *)argsPtr;
    Pfs_Request			request;
    register ReturnStatus	status;
    int				resultSize;

    cltHandlePtr = (Fspdev_ClientIOHandle *)prefixHandle;

    /*
     * Set up the open arguments, and get ahold of the naming stream.
     */
    request.hdr.operation = PFS_OPEN;
    pdevHandlePtr = PfsGetUserLevelIDs(cltHandlePtr->pdevHandlePtr,
			    &openArgsPtr->prefixID, &openArgsPtr->rootID);
    if (pdevHandlePtr == (Fspdev_ServerIOHandle *)NIL) {
	return(FS_FILE_NOT_FOUND);
    }
    request.param.open = *openArgsPtr;

    resultSize = sizeof(Fs_OpenResults);

    /*
     * Do the open.  The openResults are setup by the server-side IOC
     * handler, so just we return.
     */
    status = FspdevPseudoStreamLookup(pdevHandlePtr, &request,
		strlen(relativeName) + 1, (Address)relativeName,
		&resultSize, resultsPtr, newNameInfoPtrPtr);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * PfsGetUserLevelID --
 *
 *	This takes the lookup arguments for the pseudo-domain and maps them to
 *	the correct request-response stream for naming, and to the user-level
 *	versions of the prefix and root IDs.  Because of current directories,
 *	the handle passed to the Pfs lookup routines won't always be the
 *	top-level naming request-response stream.  However, we do get passed
 *	the fileID of the root, from which we can fetch the right handle.
 *
 * Results:
 *	Returns the pdevHandlePtr for the naming request-response stream.  This
 *	is in turn passed to FspdevPseudoStreamLookup.  This also sets the prefixID
 *	to be the user-level version.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Fspdev_ServerIOHandle *
PfsGetUserLevelIDs(pdevHandlePtr, prefixIDPtr, rootIDPtr)
    Fspdev_ServerIOHandle *pdevHandlePtr;	/* Handle of name prefix */
    Fs_FileID *prefixIDPtr;		/* Prefix fileID */
    Fs_FileID *rootIDPtr;		/* ID of naming request-response */
{
    register Fspdev_ClientIOHandle *cltHandlePtr;

    *prefixIDPtr = pdevHandlePtr->userLevelID;
    rootIDPtr->type = fsio_RmtToLclType[rootIDPtr->type];
    cltHandlePtr = Fsutil_HandleFetchType(Fspdev_ClientIOHandle, rootIDPtr);
    if (cltHandlePtr != (Fspdev_ClientIOHandle *)NIL) {
	Fsutil_HandleRelease(cltHandlePtr, TRUE);
	return(cltHandlePtr->pdevHandlePtr);
    } else {
	return((Fspdev_ServerIOHandle *)NIL);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPfsOpenConnection --
 *
 *	This is called when the server does an IOC_PFS_OPEN to respond
 *	to an open request issued by FspdevPfsOpen.  This sets up the server's
 *	half of the pseudo-device connection, while FspdevPfsOpen completes
 *	the connection by opening the client's half.  This knows it is
 *	executing in the kernel context of the server process so it can
 *	establish the user-level streamID needed by the server.
 *
 * Results:
 *	A streamID that has to be returned to the server.
 *
 * Side effects:
 *	Set up the state for a pseudo-device connection.
 *
 *----------------------------------------------------------------------
 */
int
FspdevPfsOpenConnection(namingPdevHandlePtr, srvrFileIDPtr, openResultsPtr)
    Fspdev_ServerIOHandle	*namingPdevHandlePtr;/* From naming request-response */
    Fs_FileID *srvrFileIDPtr;		/* FileID from user-level server */
    Fs_OpenResults *openResultsPtr;	/* Info returned to client's open */
{
    register Fspdev_ControlIOHandle *ctrlHandlePtr;
    register Fspdev_ClientIOHandle *cltHandlePtr;
    register Fs_Stream *srvStreamPtr;
    register Fs_Stream *cltStreamPtr;
    int newStreamID;
    register Fs_FileID	*fileIDPtr;	/* FileID for new connection */

    /*
     * Pick an I/O fileID for the connection.
     */
    ctrlHandlePtr = namingPdevHandlePtr->ctrlHandlePtr;
    ctrlHandlePtr->seed++;
    fileIDPtr = &openResultsPtr->ioFileID;
    fileIDPtr->type = FSIO_LCL_PFS_STREAM;
    fileIDPtr->serverID = rpc_SpriteID;
    fileIDPtr->major = ctrlHandlePtr->rmt.hdr.fileID.major;
    fileIDPtr->minor = (ctrlHandlePtr->rmt.hdr.fileID.minor << 12)
			^ ctrlHandlePtr->seed;

    cltHandlePtr = FspdevConnect(ctrlHandlePtr, fileIDPtr,
		    namingPdevHandlePtr->open.clientID, 0);
    if (cltHandlePtr == (Fspdev_ClientIOHandle *)NIL) {
	printf( "FspdevPfsOpenConnection failing\n");
	return(-1);
    }
    /*
     * Set the ioFileID type. (FspdevConnect has munged it to FSIO_SERVER_STREAM.)
     * The open.clientID has been set curtesy of the PFS_OPEN RequestResponse.
     */
    if (namingPdevHandlePtr->open.clientID == rpc_SpriteID) {
	fileIDPtr->type = FSIO_LCL_PFS_STREAM;
    } else {
	fileIDPtr->type = FSIO_RMT_PFS_STREAM;
    }
    /*
     * Save the server process's ID for the connection.
     */
    cltHandlePtr->pdevHandlePtr->userLevelID = *srvrFileIDPtr;

    /*
     * Set up a stream to the server's half of the connection and
     * then choose a user level streamID.
     */
    srvStreamPtr = Fsio_StreamCreate(rpc_SpriteID, rpc_SpriteID,
		    (Fs_HandleHeader *)cltHandlePtr->pdevHandlePtr,
		    FS_READ|FS_USER, namingPdevHandlePtr->open.name);
    if (Fs_GetStreamID(srvStreamPtr, &newStreamID) != SUCCESS) {
	(void)Fsio_StreamClientClose(&srvStreamPtr->clientList, rpc_SpriteID);
	Fsio_StreamDestroy(srvStreamPtr);
	Sync_LockClear(&cltHandlePtr->pdevHandlePtr->lock);
	Fsutil_HandleRemove(cltHandlePtr->pdevHandlePtr);
	Fsutil_HandleRemove(cltHandlePtr);
	fs_Stats.object.pseudoStreams--;
	newStreamID = -1;
    } else {
	/*
	 * Set up a stream to the client's half of the connection.
	 */
	cltStreamPtr = Fsio_StreamCreate(rpc_SpriteID,
			    namingPdevHandlePtr->open.clientID,
			    (Fs_HandleHeader *)cltHandlePtr,
			    namingPdevHandlePtr->open.useFlags,
			    namingPdevHandlePtr->open.name);
	openResultsPtr->nameID = openResultsPtr->ioFileID;
	openResultsPtr->streamID = cltStreamPtr->hdr.fileID;
	openResultsPtr->dataSize = 0;
	openResultsPtr->streamData = (ClientData)NIL;
	Fsutil_HandleRelease(cltStreamPtr, TRUE);
	Fsutil_HandleUnlock(cltHandlePtr);
	Fsutil_HandleUnlock(srvStreamPtr);
    }
    return(newStreamID);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPfsStreamIoOpen --
 *
 *	This is called from Fs_Open to complete setup of a client's
 *	stream to a pseudo-filesystem server.  The server is running on this
 *	host, and the pseudo-device connection has already been established.
 *	This routine just latches onto it and returns.
 * 
 * Results:
 *	SUCCESS, unless the server process has died recently.
 *
 * Side effects:
 *	Fetches the handle, which increments its ref count.  The
 *	handle is unlocked before returning.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevPfsStreamIoOpen(ioFileIDPtr, flagsPtr, clientID, streamData, name,
	ioHandlePtrPtr)
    register Fs_FileID	*ioFileIDPtr;	/* I/O fileID */
    int			*flagsPtr;	/* FS_READ | FS_WRITE ... */
    int			clientID;	/* Host doing the open */
    ClientData		streamData;	/* Pointer to Fspdev_State. */
    char		*name;		/* File name for error msgs */
    Fs_HandleHeader	**ioHandlePtrPtr;/* Return - a locked handle set up for
					 * I/O to a pseudo device, or NIL */
{
    register Fspdev_ClientIOHandle *cltHandlePtr;

    cltHandlePtr = Fsutil_HandleFetchType(Fspdev_ClientIOHandle, ioFileIDPtr);
    if (cltHandlePtr == (Fspdev_ClientIOHandle *)NIL) {
	printf( "FspdevPfsStreamIoOpen, no handle\n");
	*ioHandlePtrPtr = (Fs_HandleHeader *)NIL;
	return(FS_FILE_NOT_FOUND);
    } else {
	if (cltHandlePtr->hdr.name != (char *)NIL) {
	    free((Address)cltHandlePtr->hdr.name);
	}
	cltHandlePtr->hdr.name = (char *)malloc(strlen(name) + 1);
	(void)strcpy(cltHandlePtr->hdr.name, name);
	*ioHandlePtrPtr = (Fs_HandleHeader *)cltHandlePtr;
	if (*flagsPtr & FS_EXECUTE) {         /* Promote execute access to */
	    *flagsPtr |= FS_READ;	      /* read access. JMS */
	}
	Fsutil_HandleUnlock(cltHandlePtr);
	return(SUCCESS);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevRmtPfsStreamIoOpen --
 *
 *	This is called from Fs_Open to complete setup of a client's
 *	stream to a remote pseudo-filesystem server.  The server is running
 *	on this	host, and the pseudo-device connection has already been
 *	established.  This routine just sets up a remote handle that
 *	references the connection.
 * 
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Installs a remote I/O handle.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevRmtPfsStreamIoOpen(ioFileIDPtr, flagsPtr, clientID, streamData, name,
	ioHandlePtrPtr)
    register Fs_FileID	*ioFileIDPtr;	/* I/O fileID */
    int			*flagsPtr;	/* FS_READ | FS_WRITE ... */
    int			clientID;	/* Host doing the open */
    ClientData		streamData;	/* NIL. */
    char		*name;		/* File name for error msgs */
    Fs_HandleHeader	**ioHandlePtrPtr;/* Return - FSIO_RMT_PFS_STREAM handle */
{
    Fsrmt_IOHandleInit(ioFileIDPtr, *flagsPtr, name, ioHandlePtrPtr);
    if (*flagsPtr & FS_EXECUTE) {         /* Promote execute access to */
	*flagsPtr |= FS_READ;             /* read access. JMS */
    }
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPfsGetAttrPath --
 *
 *	Get the attributes of a file in a pseudo-filesystem.
 *
 * Results:
 *	A return code from the RPC or the remote server.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
FspdevPfsGetAttrPath(prefixHandle, relativeName, argsPtr, resultsPtr,
         	    newNameInfoPtrPtr)
    Fs_HandleHeader *prefixHandle;	/* Handle from the prefix table */
    char           *relativeName;	/* The name of the file. */
    Address        argsPtr;		/* Bundled arguments for us */
    Address        resultsPtr;		/* Where to store attributes */
    Fs_RedirectInfo **newNameInfoPtrPtr;	/* We return this if the server leaves 
					 * its domain during the lookup. */
{
    register Fspdev_ServerIOHandle	*pdevHandlePtr;
    Pfs_Request			request;
    register ReturnStatus	status;
    register Fs_OpenArgs		*openArgsPtr;
    register Fs_GetAttrResults	*getAttrResultsPtr;
    int				resultSize;

    pdevHandlePtr = ((Fspdev_ClientIOHandle *)prefixHandle)->pdevHandlePtr;
    openArgsPtr = (Fs_OpenArgs *)argsPtr;

    request.hdr.operation = PFS_GET_ATTR;
    pdevHandlePtr = PfsGetUserLevelIDs(pdevHandlePtr,
			    &openArgsPtr->prefixID, &openArgsPtr->rootID);
    if (pdevHandlePtr == (Fspdev_ServerIOHandle *)NIL) {
	return(FS_FILE_NOT_FOUND);
    }
    request.param.open = *(Fs_OpenArgs *)argsPtr;

    getAttrResultsPtr = (Fs_GetAttrResults *)resultsPtr;
    resultSize = sizeof(Fs_Attributes);

    status = FspdevPseudoStreamLookup(pdevHandlePtr, &request,
		strlen(relativeName) + 1, (Address)relativeName,
		&resultSize, (Address)getAttrResultsPtr->attrPtr,
		newNameInfoPtrPtr);
    /*
     * Patch the serverID in the attributes so it matches the serverID
     * given in the prefix table.  This is needed to make getwd() work.
     */
    getAttrResultsPtr->attrPtr->serverID = rpc_SpriteID;
    /*
     * The pseudo-filesystem server has given us all the attributes.  There
     * is no reason to do a getIOAttr so we inhibit that with a special
     * ioFileID type.  However, because Fsutil_DomainInfo calls this routine
     * to fill in the file ID for the user-visible prefix table entry
     * we set up the rest of the fields to match the return of a stat() call.
     */
    getAttrResultsPtr->fileIDPtr->type = -1;
    getAttrResultsPtr->fileIDPtr->serverID = getAttrResultsPtr->attrPtr->serverID;
    getAttrResultsPtr->fileIDPtr->major = getAttrResultsPtr->attrPtr->domain;
    getAttrResultsPtr->fileIDPtr->minor = getAttrResultsPtr->attrPtr->fileNumber;
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPfsSetAttrPath --
 *
 *	Set the attributes of a file in a pseudo-filesystem.
 *
 * Results:
 *	A return code from the RPC or the remote server.
 *
 * Side effects:
 *	Setting those attributes.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
FspdevPfsSetAttrPath(prefixHandle, relativeName, argsPtr, resultsPtr,
         	    newNameInfoPtrPtr)
    Fs_HandleHeader *prefixHandle;	/* Handle from the prefix table */
    char           *relativeName;	/* The name of the file. */
    Address        argsPtr;		/* Bundled arguments for us */
    Address        resultsPtr;		/* Where to store attributes */
    Fs_RedirectInfo **newNameInfoPtrPtr;	/* We return this if the server leaves 
					 * its domain during the lookup. */
{
    register Fspdev_ServerIOHandle	*pdevHandlePtr;
    Pfs_Request			request;
    register ReturnStatus	status;
    register Fs_SetAttrArgs	*setAttrArgsPtr;
    register Pfs_SetAttrData	*setAttrDataPtr;
    register int		nameLength;
    register int		dataLength;
    int				zero = 0;

    pdevHandlePtr = ((Fspdev_ClientIOHandle *)prefixHandle)->pdevHandlePtr;

    setAttrArgsPtr = (Fs_SetAttrArgs *)argsPtr;

    request.hdr.operation = PFS_SET_ATTR;
    pdevHandlePtr = PfsGetUserLevelIDs(pdevHandlePtr,
			    &setAttrArgsPtr->openArgs.prefixID,
			    &setAttrArgsPtr->openArgs.rootID);
    if (pdevHandlePtr == (Fspdev_ServerIOHandle *)NIL) {
	return(FS_FILE_NOT_FOUND);
    }
    request.param.open = setAttrArgsPtr->openArgs;

    /*
     * The dataLength includes 4 bytes of name inside the Pfs_SetAttrData
     * so there is room for the trailing null byte.
     */
    nameLength = strlen(relativeName);
    dataLength = sizeof(Pfs_SetAttrData) + nameLength;

    setAttrDataPtr = (Pfs_SetAttrData *)malloc(dataLength);
    setAttrDataPtr->attr = setAttrArgsPtr->attr;
    setAttrDataPtr->flags = setAttrArgsPtr->flags;
    setAttrDataPtr->nameLength = nameLength;
    (void)strcpy(setAttrDataPtr->name, relativeName);

    status = FspdevPseudoStreamLookup(pdevHandlePtr, &request,
	    dataLength, (Address)setAttrDataPtr,
	    &zero, (Address)NIL, newNameInfoPtrPtr);
    free((Address)setAttrDataPtr);
    /*
     * The pseudo-filesystem server has dealt with all the attributes so
     * we don't fill in the ioFileID.
     */
    ((Fs_FileID *)resultsPtr)->type = -1;
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPfsMakeDir --
 *
 *	Make the named directory in a pseudo-filesystem.
 *
 * Results:
 *	A return code from the file server or the RPC.
 *
 * Side effects:
 *	Makes the directory.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevPfsMakeDir(prefixHandle, relativeName, argsPtr, resultsPtr, 
		newNameInfoPtrPtr)
    Fs_HandleHeader *prefixHandle;   /* Handle from the prefix table */
    char 	   *relativeName;   /* The name of the directory to create */
    Address 	   argsPtr;	    /* Ref. to Fs_OpenArgs */
    Address 	   resultsPtr;	    /* == NIL */
    Fs_RedirectInfo **newNameInfoPtrPtr;/* We return this if the server leaves 
					* its domain during the lookup. */
{
    register Fspdev_ServerIOHandle	*pdevHandlePtr;
    register Fs_OpenArgs		*openArgsPtr;
    Pfs_Request			request;
    register ReturnStatus	status;
    int				resultSize;

    pdevHandlePtr = ((Fspdev_ClientIOHandle *)prefixHandle)->pdevHandlePtr;
    openArgsPtr = (Fs_OpenArgs *)argsPtr;

    request.hdr.operation = PFS_MAKE_DIR;
    pdevHandlePtr = PfsGetUserLevelIDs(pdevHandlePtr,
			    &openArgsPtr->prefixID, &openArgsPtr->rootID);
    if (pdevHandlePtr == (Fspdev_ServerIOHandle *)NIL) {
	return(FS_FILE_NOT_FOUND);
    }
    request.param.makeDir = *openArgsPtr;

    resultSize = 0;

    status = FspdevPseudoStreamLookup(pdevHandlePtr, &request,
		strlen(relativeName) + 1, (Address)relativeName,
		&resultSize, resultsPtr, newNameInfoPtrPtr);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPfsMakeDevice --
 *
 *	Create a device file in a pseudo-filesystem.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Makes a device file.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevPfsMakeDevice(prefixHandle, relativeName, argsPtr, resultsPtr,
			       newNameInfoPtrPtr)
    Fs_HandleHeader *prefixHandle;   /* Handle from the prefix table */
    char           *relativeName;   /* The name of the file. */
    Address        argsPtr;	    /* Ref. to FsMakeDevArgs */
    Address        resultsPtr;	    /* == NIL */
    Fs_RedirectInfo **newNameInfoPtrPtr;/* We return this if the server leaves 
					* its domain during the lookup. */
{
    register Fspdev_ServerIOHandle	*pdevHandlePtr;
    register Fs_MakeDeviceArgs	*makeDevArgsPtr;
    Pfs_Request			request;
    register ReturnStatus	status;
    int				resultSize;

    pdevHandlePtr = ((Fspdev_ClientIOHandle *)prefixHandle)->pdevHandlePtr;
    makeDevArgsPtr = (Fs_MakeDeviceArgs *)argsPtr;

    request.hdr.operation = PFS_MAKE_DEVICE;
    pdevHandlePtr = PfsGetUserLevelIDs(pdevHandlePtr,
	    &makeDevArgsPtr->open.prefixID, &makeDevArgsPtr->open.rootID);
    if (pdevHandlePtr == (Fspdev_ServerIOHandle *)NIL) {
	return(FS_FILE_NOT_FOUND);
    }
    request.param.makeDevice = *makeDevArgsPtr;

    resultSize = 0;

    status = FspdevPseudoStreamLookup(pdevHandlePtr, &request,
		strlen(relativeName) + 1, (Address)relativeName,
		&resultSize, resultsPtr, newNameInfoPtrPtr);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPfsRemove --
 *
 *	Remove a file served by a pseudo-filesystem server.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Does the remove.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevPfsRemove(prefixHandle, relativeName, argsPtr, resultsPtr, 
	       newNameInfoPtrPtr)
    Fs_HandleHeader   *prefixHandle;	/* Handle from the prefix table */
    char 	   *relativeName;	/* The name of the file to remove */
    Address 	   argsPtr;		/* Ref to Fs_LookupArgs */
    Address 	   resultsPtr;		/* == NIL */
    Fs_RedirectInfo **newNameInfoPtrPtr; /* We return this if the server leaves 
					   its domain during the lookup. */
{
    register Fspdev_ServerIOHandle	*pdevHandlePtr;
    register Fs_LookupArgs	*lookupArgsPtr;
    Pfs_Request			request;
    register ReturnStatus	status;
    int				resultSize;

    pdevHandlePtr = ((Fspdev_ClientIOHandle *)prefixHandle)->pdevHandlePtr;
    lookupArgsPtr = (Fs_LookupArgs *)argsPtr;

    request.hdr.operation = PFS_REMOVE;
    pdevHandlePtr = PfsGetUserLevelIDs(pdevHandlePtr,
			    &lookupArgsPtr->prefixID, &lookupArgsPtr->rootID);
    if (pdevHandlePtr == (Fspdev_ServerIOHandle *)NIL) {
	return(FS_FILE_NOT_FOUND);
    }
    request.param.remove = *lookupArgsPtr;

    resultSize = 0;

    status = FspdevPseudoStreamLookup(pdevHandlePtr, &request,
		strlen(relativeName) + 1, (Address)relativeName,
		&resultSize, resultsPtr, newNameInfoPtrPtr);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPfsRemoveDir --
 *
 *	Remove a directory in a pseudo-filesystem.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Does the remove.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevPfsRemoveDir(prefixHandle, relativeName, argsPtr, resultsPtr, 
	       newNameInfoPtrPtr)
    Fs_HandleHeader   *prefixHandle;	/* Handle from the prefix table */
    char 	   *relativeName;	/* The name of the file to remove */
    Address 	   argsPtr;		/* Ref to Fs_LookupArgs */
    Address 	   resultsPtr;		/* == NIL */
    Fs_RedirectInfo **newNameInfoPtrPtr; /* We return this if the server leaves 
					   its domain during the lookup. */
{
    register Fspdev_ServerIOHandle	*pdevHandlePtr;
    register Fs_LookupArgs	*lookupArgsPtr;
    Pfs_Request			request;
    register ReturnStatus	status;
    int				resultSize;

    pdevHandlePtr = ((Fspdev_ClientIOHandle *)prefixHandle)->pdevHandlePtr;
    lookupArgsPtr = (Fs_LookupArgs *)argsPtr;

    request.hdr.operation = PFS_REMOVE_DIR;
    pdevHandlePtr = PfsGetUserLevelIDs(pdevHandlePtr,
			    &lookupArgsPtr->prefixID, &lookupArgsPtr->rootID);
    if (pdevHandlePtr == (Fspdev_ServerIOHandle *)NIL) {
	return(FS_FILE_NOT_FOUND);
    }
    request.param.removeDir = *lookupArgsPtr;

    resultSize = 0;

    status = FspdevPseudoStreamLookup(pdevHandlePtr, &request,
		strlen(relativeName) + 1, (Address)relativeName,
		&resultSize, resultsPtr, newNameInfoPtrPtr);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPfsRename --
 *
 *	Rename a file is a pseudo-filesystem.
 *
 * Results:
 *	A return status.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
FspdevPfsRename(prefixHandle1, relativeName1, prefixHandle2, relativeName2,
	lookupArgsPtr, newNameInfoPtrPtr, name1ErrorPtr)
    Fs_HandleHeader *prefixHandle1;	/* Handle from the prefix table */
    char *relativeName1;		/* The new name of the file. */
    Fs_HandleHeader *prefixHandle2;	/* Token from the prefix table */
    char *relativeName2;		/* The new name of the file. */
    Fs_LookupArgs *lookupArgsPtr;	/* Contains IDs */
    Fs_RedirectInfo **newNameInfoPtrPtr;	/* We return this if the server leaves 
					 * its domain during the lookup. */
    Boolean *name1ErrorPtr;	/* TRUE if redirect info or other error
				 * condition if for the first pathname,
				 * FALSE means error is on second pathname. */
{
    return(FspdevPfs2Path(PFS_RENAME, prefixHandle1, relativeName1, prefixHandle2,
	    relativeName2, lookupArgsPtr, newNameInfoPtrPtr, name1ErrorPtr));
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPfsHardLink --
 *
 *	Make a hard link between two files in a pseudo-filesystem.
 *
 * Results:
 *	A return status.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevPfsHardLink(prefixHandle1, relativeName1, prefixHandle2, relativeName2,
	    lookupArgsPtr, newNameInfoPtrPtr, name1ErrorPtr)
    Fs_HandleHeader *prefixHandle1;	/* Token from the prefix table */
    char *relativeName1;		/* The new name of the file. */
    Fs_HandleHeader *prefixHandle2;	/* Token from the prefix table */
    char *relativeName2;		/* The new name of the file. */
    Fs_LookupArgs *lookupArgsPtr;	/* Contains IDs */
    Fs_RedirectInfo **newNameInfoPtrPtr;	/* We return this if the server 
					 * leaves its domain during the lookup*/
    Boolean *name1ErrorPtr;	/* TRUE if redirect info or other error is
				 * for first path, FALSE if for the second. */
{
    return(FspdevPfs2Path(PFS_HARD_LINK, prefixHandle1, relativeName1,prefixHandle2,
	    relativeName2, lookupArgsPtr, newNameInfoPtrPtr, name1ErrorPtr));
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPfs2Path --
 *
 *	Rename or Hardlink a file is a pseudo-filesystem.  This bundles the
 *	arguments up for shipment to the server.  The prefix fileIDs are
 *	mapped to the server's version of them.
 *
 * Results:
 *	A return status.
 *
 * Side effects:
 *	Either a rename or a link.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
FspdevPfs2Path(operation,prefixHandle1, relativeName1, prefixHandle2, relativeName2,
	lookupArgsPtr, newNameInfoPtrPtr, name1ErrorPtr)
    Pdev_Op operation;			/* PFS_RENAME or PFS_HARD_LINK */
    Fs_HandleHeader *prefixHandle1;	/* Handle from the prefix table */
    char *relativeName1;		/* The new name of the file. */
    Fs_HandleHeader *prefixHandle2;	/* Token from the prefix table */
    char *relativeName2;		/* The new name of the file. */
    Fs_LookupArgs *lookupArgsPtr;	/* Contains IDs */
    Fs_RedirectInfo **newNameInfoPtrPtr;	/* We return this if the server leaves 
					 * its domain during the lookup. */
    Boolean *name1ErrorPtr;	/* TRUE if redirect info or other error
				 * condition if for the first pathname,
				 * FALSE means error is on second pathname. */
{
    register Fspdev_ServerIOHandle	*pdevHandlePtr;
    register Fspdev_ServerIOHandle	*pdevHandle2Ptr;
    Fs_2PathData			*dataPtr;
    Pfs_Request			request;
    register ReturnStatus	status;

    pdevHandlePtr = ((Fspdev_ClientIOHandle *)prefixHandle1)->pdevHandlePtr;

    request.hdr.operation = operation;
    pdevHandlePtr = PfsGetUserLevelIDs(pdevHandlePtr,
			    &lookupArgsPtr->prefixID, &lookupArgsPtr->rootID);
    if (pdevHandlePtr == (Fspdev_ServerIOHandle *)NIL) {
	return(FS_FILE_NOT_FOUND);
    }
    request.param.rename.lookup = *lookupArgsPtr;
    if ((prefixHandle2 == (Fs_HandleHeader *)NIL) ||
	(prefixHandle2->fileID.type != prefixHandle1->fileID.type) ||
	(prefixHandle2->fileID.major != prefixHandle1->fileID.major) ||
	(prefixHandle2->fileID.minor != prefixHandle1->fileID.minor)) {
	/*
	 * Second prefix isn't it the same pseudo-domain. We continue with the
	 * operation in case the first pathname leaves the pseudo-domain.
	 */
	request.param.rename.prefixID2.type = -1;
    } else {
	pdevHandle2Ptr = ((Fspdev_ClientIOHandle *)prefixHandle2)->pdevHandlePtr;
	request.param.rename.prefixID2 = pdevHandle2Ptr->userLevelID;
    }
    dataPtr = (Fs_2PathData *)malloc(sizeof(Fs_2PathData));
    (void)strcpy(dataPtr->path1, relativeName1);
    (void)strcpy(dataPtr->path2, relativeName2);

    status = FspdevPseudoStream2Path(pdevHandlePtr, &request, dataPtr,
		name1ErrorPtr, newNameInfoPtrPtr);
    free((Address)dataPtr);
    return(status);
}
@


9.3
log
@Allow execution of PFS files
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fspdevPfs.c,v 9.2 91/06/23 16:43:18 mottsmth Exp $ SPRITE (Berkeley)";
d52 2
d99 1
d143 36
@


9.3.1.1
log
@Initial branch for Sprite server.
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fspdev/fspdevPfs.c,v 9.3 91/06/26 01:05:59 mottsmth Exp $ SPRITE (Berkeley)";
@


9.2
log
@Allow execution of PFS files
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fspdevPfs.c,v 9.1 90/10/08 12:43:48 mendel Exp Locker: mottsmth $ SPRITE (Berkeley)";
d53 2
a54 2
static FspdevServerIOHandle *PfsGetUserLevelIDs _ARGS_((
	FspdevServerIOHandle *pdevHandlePtr, Fs_FileID *prefixIDPtr, 
d131 1
a131 1
	register FspdevControlIOHandle *ctrlHandlePtr;
d192 3
a194 3
    register FspdevControlIOHandle *ctrlHandlePtr;
    register FspdevServerIOHandle *pdevHandlePtr;
    register FspdevClientIOHandle *cltHandlePtr;
d242 1
a242 1
    if (cltHandlePtr == (FspdevClientIOHandle *)NIL) {
d315 1
a315 1
    register FspdevClientIOHandle *cltHandlePtr = (FspdevClientIOHandle *)hdrPtr;
d407 1
a407 1
    FspdevClientIOHandle		*cltHandlePtr;
d411 2
a412 2
    cltHandlePtr = Fsutil_HandleFetchType(FspdevClientIOHandle, fileIDPtr);
    if (cltHandlePtr != (FspdevClientIOHandle *)NIL) {
d467 2
a468 2
    register FspdevClientIOHandle	*cltHandlePtr;
    register FspdevServerIOHandle *pdevHandlePtr;
d474 1
a474 1
    cltHandlePtr = (FspdevClientIOHandle *)prefixHandle;
d482 1
a482 1
    if (pdevHandlePtr == (FspdevServerIOHandle *)NIL) {
d522 1
a522 1
static FspdevServerIOHandle *
d524 1
a524 1
    FspdevServerIOHandle *pdevHandlePtr;	/* Handle of name prefix */
d528 1
a528 1
    register FspdevClientIOHandle *cltHandlePtr;
d532 2
a533 2
    cltHandlePtr = Fsutil_HandleFetchType(FspdevClientIOHandle, rootIDPtr);
    if (cltHandlePtr != (FspdevClientIOHandle *)NIL) {
d537 1
a537 1
	return((FspdevServerIOHandle *)NIL);
d563 1
a563 1
    FspdevServerIOHandle	*namingPdevHandlePtr;/* From naming request-response */
d567 2
a568 2
    register FspdevControlIOHandle *ctrlHandlePtr;
    register FspdevClientIOHandle *cltHandlePtr;
d588 1
a588 1
    if (cltHandlePtr == (FspdevClientIOHandle *)NIL) {
d672 1
a672 1
    register FspdevClientIOHandle *cltHandlePtr;
d674 2
a675 2
    cltHandlePtr = Fsutil_HandleFetchType(FspdevClientIOHandle, ioFileIDPtr);
    if (cltHandlePtr == (FspdevClientIOHandle *)NIL) {
d686 2
a687 2
	if (*flagsPtr & FS_EXECUTE) {         /* Promote execute access to
	    *flagsPtr |= FS_READ;	       * read access. JMS */
d725 2
a726 2
    if (*flagsPtr & FS_EXECUTE) {         /* Promote execute access to
	*flagsPtr |= FS_READ;              * read access. JMS */
d756 1
a756 1
    register FspdevServerIOHandle	*pdevHandlePtr;
d763 1
a763 1
    pdevHandlePtr = ((FspdevClientIOHandle *)prefixHandle)->pdevHandlePtr;
d769 1
a769 1
    if (pdevHandlePtr == (FspdevServerIOHandle *)NIL) {
d825 1
a825 1
    register FspdevServerIOHandle	*pdevHandlePtr;
d834 1
a834 1
    pdevHandlePtr = ((FspdevClientIOHandle *)prefixHandle)->pdevHandlePtr;
d842 1
a842 1
    if (pdevHandlePtr == (FspdevServerIOHandle *)NIL) {
d898 1
a898 1
    register FspdevServerIOHandle	*pdevHandlePtr;
d904 1
a904 1
    pdevHandlePtr = ((FspdevClientIOHandle *)prefixHandle)->pdevHandlePtr;
d910 1
a910 1
    if (pdevHandlePtr == (FspdevServerIOHandle *)NIL) {
d949 1
a949 1
    register FspdevServerIOHandle	*pdevHandlePtr;
d955 1
a955 1
    pdevHandlePtr = ((FspdevClientIOHandle *)prefixHandle)->pdevHandlePtr;
d961 1
a961 1
    if (pdevHandlePtr == (FspdevServerIOHandle *)NIL) {
d1000 1
a1000 1
    register FspdevServerIOHandle	*pdevHandlePtr;
d1006 1
a1006 1
    pdevHandlePtr = ((FspdevClientIOHandle *)prefixHandle)->pdevHandlePtr;
d1012 1
a1012 1
    if (pdevHandlePtr == (FspdevServerIOHandle *)NIL) {
d1051 1
a1051 1
    register FspdevServerIOHandle	*pdevHandlePtr;
d1057 1
a1057 1
    pdevHandlePtr = ((FspdevClientIOHandle *)prefixHandle)->pdevHandlePtr;
d1063 1
a1063 1
    if (pdevHandlePtr == (FspdevServerIOHandle *)NIL) {
d1174 2
a1175 2
    register FspdevServerIOHandle	*pdevHandlePtr;
    register FspdevServerIOHandle	*pdevHandle2Ptr;
d1180 1
a1180 1
    pdevHandlePtr = ((FspdevClientIOHandle *)prefixHandle1)->pdevHandlePtr;
d1185 1
a1185 1
    if (pdevHandlePtr == (FspdevServerIOHandle *)NIL) {
d1199 1
a1199 1
	pdevHandle2Ptr = ((FspdevClientIOHandle *)prefixHandle2)->pdevHandlePtr;
@


9.1
log
@Fixed include to use <> rather than "". Added function prototyping.
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs.mendel/RCS/fsPfs.c,v 1.1 90/01/16 17:11:16 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d686 3
d725 3
@


9.0
log
@Changing version numbers.
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fsPfs.c,v 8.14 89/08/21 15:28:06 mendel Exp Locker: douglis $ SPRITE (Berkeley)";
d36 16
a51 15
#include "sprite.h"
#include "fs.h"
#include "fsutil.h"
#include "fsNameOps.h"
#include "fsio.h"
#include "fsconsist.h"
#include "fsdm.h"
#include "fsioLock.h"
#include "fsprefix.h"
#include "fsStat.h"
#include "proc.h"
#include "rpc.h"
#include "fspdev.h"
#include "fspdevInt.h"
#include "dev/pfs.h"
d53 3
a55 1
static FspdevServerIOHandle *PfsGetUserLevelIDs();
d372 1
a372 1
	    (Fs_HandleHeader **)&rmtHandlePtr);
d410 1
a410 1

@


8.14
log
@Break up fs into many modules.    
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 8.13 89/06/30 15:30:59 brent Exp $ SPRITE (Berkeley)";
@


8.13
log
@Nuked some extra code
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 8.12 89/06/15 09:23:04 brent Exp $ SPRITE (Berkeley)";
d38 1
a38 8
#include "fsInt.h"
#include "fsOpTable.h"
#include "fsStream.h"
#include "fsClient.h"
#include "fsFile.h"
#include "fsDisk.h"
#include "fsLock.h"
#include "fsPrefix.h"
d40 5
d48 2
a49 2
#include "swapBuffer.h"
#include "fsPdev.h"
d52 1
a52 2
PdevControlIOHandle *PfsControlHandleInit();
PdevServerIOHandle *PfsGetUserLevelIDs();
d57 1
a57 1
 * FsRmtLinkSrvOpen --
d63 1
a63 1
 *	not specified then FsFileSrvOpen is called and the remote link
d85 2
a86 2
FsRmtLinkSrvOpen(handlePtr, openArgsPtr, openResultsPtr)
     register FsLocalFileIOHandle *handlePtr;	/* A handle from FsLocalLookup.
d89 2
a90 2
     FsOpenArgs		*openArgsPtr;	/* Standard open arguments */
     FsOpenResults	*openResultsPtr;/* For returning ioFileID, streamID */
d96 1
a96 1
	return(FsFileSrvOpen(handlePtr, openArgsPtr, openResultsPtr));
d99 1
a99 1
     * Generate an ID which is just like a FS_CONTROL_STREAM, except that
d104 1
a104 1
    ioFileIDPtr->type = FS_PFS_CONTROL_STREAM;
d117 1
a117 1
	FsStreamNewID(openArgsPtr->clientID, &openResultsPtr->streamID);
d128 1
a128 1
	register PdevControlIOHandle *ctrlHandlePtr;
d131 1
a131 1
	ctrlHandlePtr = FsControlHandleInit(ioFileIDPtr, handlePtr->hdr.name);
d136 1
a136 1
	    FsStreamNewID(openArgsPtr->clientID, &openResultsPtr->streamID);
d138 1
a138 1
	FsHandleRelease(ctrlHandlePtr, TRUE);
d142 1
a142 1
    FsHandleUnlock(handlePtr);
d149 1
a149 1
 * FsPfsCltOpen --
d169 2
a170 2
 *	but differ in their types (FS_PFS_CONTROL_STREAM, FS_SERVER_STREAM,
 *	and FS_LCL_PSEUDO_STREAM).  The server stream is returned to our caller,
d178 1
a178 1
FsPfsCltOpen(ioFileIDPtr, flagsPtr, clientID, streamData, name,
d183 1
a183 1
    ClientData		streamData;	/* Pointer to FsPdevState. */
d185 1
a185 1
    FsHandleHeader	**ioHandlePtrPtr;/* Return - a locked handle set up for
d189 4
a192 4
    register PdevControlIOHandle *ctrlHandlePtr;
    register PdevServerIOHandle *pdevHandlePtr;
    register PdevClientIOHandle *cltHandlePtr;
    FsHandleHeader		*prefixHdrPtr;
d197 1
a197 1
    FsPrefix			*prefixPtr;
d209 2
a210 2
    status = FsPrefixLookup(name,
		FS_IMPORTED_PREFIX|FS_EXPORTED_PREFIX|FS_EXACT_PREFIX, -1,
d227 1
a227 1
    ctrlHandlePtr = FsControlHandleInit(ioFileIDPtr, name);
d236 1
a236 1
    ioFileIDPtr->type = FS_LCL_PSEUDO_STREAM;
d238 2
a239 2
    cltHandlePtr = FsPdevConnect(ctrlHandlePtr, ioFileIDPtr, rpc_SpriteID, 1);
    if (cltHandlePtr == (PdevClientIOHandle *)NIL) {
d244 1
a244 1
    *ioHandlePtrPtr = (FsHandleHeader *)pdevHandlePtr;
d246 1
a246 1
     * This ID gets passed in FsLookupArgs
d257 1
a257 1
    prefixFlags = FS_IMPORTED_PREFIX;
d259 1
a259 1
	prefixFlags |= FS_LOCAL_PREFIX;
d261 1
a261 1
	prefixFlags |= FS_EXPORTED_PREFIX;
d263 2
a264 2
    ctrlHandlePtr->prefixPtr = FsPrefixInstall(name,
		(FsHandleHeader *)cltHandlePtr, FS_PSEUDO_DOMAIN, prefixFlags);
d269 1
a269 1
    FsHandleUnlock(cltHandlePtr);
d272 2
a273 2
	FsHandleRelease(ctrlHandlePtr, TRUE);
	*ioHandlePtrPtr = (FsHandleHeader *)NIL;
d275 1
a275 1
	FsHandleUnlock(ctrlHandlePtr);
d284 1
a284 1
 * FsPfsExport --
d286 1
a286 1
 *	This is called from the Fs_RpcPrefix stub to complete setup for
d291 1
a291 1
 *	The remote Sprite host will call FsPfsNamingCltOpen to set
d305 2
a306 2
FsPfsExport(hdrPtr, clientID, ioFileIDPtr, dataSizePtr, clientDataPtr)
     FsHandleHeader	*hdrPtr;	/* A handle from the prefix table. */
d312 1
a312 1
    register PdevClientIOHandle *cltHandlePtr = (PdevClientIOHandle *)hdrPtr;
d315 3
a317 3
    FsHandleLock(cltHandlePtr);
    if (FsPdevServerOK(cltHandlePtr->pdevHandlePtr)) {
	(void)FsIOClientOpen(&cltHandlePtr->clientList, clientID, 0, FALSE);
d319 1
a319 1
	ioFileIDPtr->type = FS_PFS_NAMING_STREAM;
d326 1
a326 1
    FsHandleUnlock(cltHandlePtr);
d333 1
a333 1
 * FsPfsNamingCltOpen --
d335 1
a335 1
 *	This is called from FsSpriteImport to complete setup of the I/O
d339 1
a339 1
 *	routine is similar to FsRmtPseudoStreamCltOpen, except that at
d341 1
a341 1
 *	to contact it with FsDeviceRemoteOpen.
d347 1
a347 1
 *	Creates a FS_PFS_NAMING_STREAM, which is like a FS_RMT_PSEUDO_STREAM
d355 1
a355 1
FsPfsNamingCltOpen(ioFileIDPtr, flagsPtr, clientID, streamData, name,
d360 1
a360 1
    ClientData		streamData;	/* Pointer to FsPdevState. */
d362 1
a362 1
    FsHandleHeader	**ioHandlePtrPtr;/* Return - a locked handle set up for
d366 1
a366 1
    FsRemoteIOHandle *rmtHandlePtr;
d368 2
a369 2
    found = FsHandleInstall(ioFileIDPtr, sizeof(FsRemoteIOHandle), name,
	    (FsHandleHeader **)&rmtHandlePtr);
d371 2
a372 2
	FsRecoveryInit(&rmtHandlePtr->recovery);
	fsStats.object.remote++;
d375 2
a376 2
    *ioHandlePtrPtr = (FsHandleHeader *)rmtHandlePtr;
    FsHandleUnlock(rmtHandlePtr);
d383 1
a383 1
 * FsPseudoDomainInfo --
d397 1
a397 1
FsPseudoDomainInfo(fileIDPtr, domainInfoPtr)
d403 2
a404 2
    FsRedirectInfo		*redirectPtr;
    PdevClientIOHandle		*cltHandlePtr;
d408 3
a410 3
    cltHandlePtr = FsHandleFetchType(PdevClientIOHandle, fileIDPtr);
    if (cltHandlePtr != (PdevClientIOHandle *)NIL) {
	FsHandleUnlock(cltHandlePtr);
d422 1
a422 1
	status = FsPseudoStreamLookup(cltHandlePtr->pdevHandlePtr, &request,
d425 1
a425 1
	if (redirectPtr != (FsRedirectInfo *)NIL) {
d428 1
a428 1
	FsHandleRelease(cltHandlePtr, FALSE);
d437 1
a437 1
 * FsPfsOpen --
d455 1
a455 1
FsPfsOpen(prefixHandle, relativeName, argsPtr, resultsPtr, 
d457 1
a457 1
    FsHandleHeader  *prefixHandle;	/* Handle from prefix table or cwd */
d459 3
a461 3
    Address 	  argsPtr;		/* Ref. to FsOpenArgs */
    Address 	  resultsPtr;		/* Ref. to FsOpenResults */
    FsRedirectInfo **newNameInfoPtrPtr;	/* We return this if the server leaves 
d464 3
a466 3
    register PdevClientIOHandle	*cltHandlePtr;
    register PdevServerIOHandle *pdevHandlePtr;
    register FsOpenArgs		*openArgsPtr = (FsOpenArgs *)argsPtr;
d471 1
a471 1
    cltHandlePtr = (PdevClientIOHandle *)prefixHandle;
d479 1
a479 1
    if (pdevHandlePtr == (PdevServerIOHandle *)NIL) {
d484 1
a484 1
    resultSize = sizeof(FsOpenResults);
d490 1
a490 1
    status = FsPseudoStreamLookup(pdevHandlePtr, &request,
d510 1
a510 1
 *	is in turn passed to FsPseudoStreamLookup.  This also sets the prefixID
d519 1
a519 1
PdevServerIOHandle *
d521 1
a521 1
    PdevServerIOHandle *pdevHandlePtr;	/* Handle of name prefix */
d525 1
a525 1
    register PdevClientIOHandle *cltHandlePtr;
d528 4
a531 4
    rootIDPtr->type = fsRmtToLclType[rootIDPtr->type];
    cltHandlePtr = FsHandleFetchType(PdevClientIOHandle, rootIDPtr);
    if (cltHandlePtr != (PdevClientIOHandle *)NIL) {
	FsHandleRelease(cltHandlePtr, TRUE);
d534 1
a534 1
	return((PdevServerIOHandle *)NIL);
d541 1
a541 1
 * FsPfsOpenConnection --
d544 2
a545 2
 *	to an open request issued by FsPfsOpen.  This sets up the server's
 *	half of the pseudo-device connection, while FsPfsOpen completes
d559 2
a560 2
FsPfsOpenConnection(namingPdevHandlePtr, srvrFileIDPtr, openResultsPtr)
    PdevServerIOHandle	*namingPdevHandlePtr;/* From naming request-response */
d562 1
a562 1
    FsOpenResults *openResultsPtr;	/* Info returned to client's open */
d564 2
a565 2
    register PdevControlIOHandle *ctrlHandlePtr;
    register PdevClientIOHandle *cltHandlePtr;
d577 1
a577 1
    fileIDPtr->type = FS_LCL_PFS_STREAM;
d583 1
a583 1
    cltHandlePtr = FsPdevConnect(ctrlHandlePtr, fileIDPtr,
d585 2
a586 2
    if (cltHandlePtr == (PdevClientIOHandle *)NIL) {
	printf( "FsPfsOpenConnection failing\n");
d590 1
a590 1
     * Set the ioFileID type. (FsPdevConnect has munged it to FS_SERVER_STREAM.)
d594 1
a594 1
	fileIDPtr->type = FS_LCL_PFS_STREAM;
d596 1
a596 1
	fileIDPtr->type = FS_RMT_PFS_STREAM;
d607 2
a608 2
    srvStreamPtr = FsStreamNewClient(rpc_SpriteID, rpc_SpriteID,
		    (FsHandleHeader *)cltHandlePtr->pdevHandlePtr,
d610 3
a612 3
    if (FsGetStreamID(srvStreamPtr, &newStreamID) != SUCCESS) {
	(void)FsStreamClientClose(&srvStreamPtr->clientList, rpc_SpriteID);
	FsStreamDispose(srvStreamPtr);
d614 3
a616 3
	FsHandleRemove(cltHandlePtr->pdevHandlePtr);
	FsHandleRemove(cltHandlePtr);
	fsStats.object.pseudoStreams--;
d622 1
a622 1
	cltStreamPtr = FsStreamNewClient(rpc_SpriteID,
d624 1
a624 1
			    (FsHandleHeader *)cltHandlePtr,
d631 3
a633 3
	FsHandleRelease(cltStreamPtr, TRUE);
	FsHandleUnlock(cltHandlePtr);
	FsHandleUnlock(srvStreamPtr);
d641 1
a641 1
 * FsPfsStreamCltOpen --
d659 1
a659 1
FsPfsStreamCltOpen(ioFileIDPtr, flagsPtr, clientID, streamData, name,
d664 1
a664 1
    ClientData		streamData;	/* Pointer to FsPdevState. */
d666 1
a666 1
    FsHandleHeader	**ioHandlePtrPtr;/* Return - a locked handle set up for
d669 1
a669 1
    register PdevClientIOHandle *cltHandlePtr;
d671 4
a674 4
    cltHandlePtr = FsHandleFetchType(PdevClientIOHandle, ioFileIDPtr);
    if (cltHandlePtr == (PdevClientIOHandle *)NIL) {
	printf( "FsPfsStreamCltOpen, no handle\n");
	*ioHandlePtrPtr = (FsHandleHeader *)NIL;
d682 2
a683 2
	*ioHandlePtrPtr = (FsHandleHeader *)cltHandlePtr;
	FsHandleUnlock(cltHandlePtr);
d691 1
a691 1
 * FsRmtPfsStreamCltOpen --
d709 1
a709 1
FsRmtPfsStreamCltOpen(ioFileIDPtr, flagsPtr, clientID, streamData, name,
d716 1
a716 1
    FsHandleHeader	**ioHandlePtrPtr;/* Return - FS_RMT_PFS_STREAM handle */
d718 1
a718 1
    FsRemoteIOHandleInit(ioFileIDPtr, *flagsPtr, name, ioHandlePtrPtr);
d725 1
a725 1
 * FsPfsGetAttrPath --
d738 1
a738 1
FsPfsGetAttrPath(prefixHandle, relativeName, argsPtr, resultsPtr,
d740 1
a740 1
    FsHandleHeader *prefixHandle;	/* Handle from the prefix table */
d744 1
a744 1
    FsRedirectInfo **newNameInfoPtrPtr;	/* We return this if the server leaves 
d747 1
a747 1
    register PdevServerIOHandle	*pdevHandlePtr;
d750 2
a751 2
    register FsOpenArgs		*openArgsPtr;
    register FsGetAttrResults	*getAttrResultsPtr;
d754 2
a755 2
    pdevHandlePtr = ((PdevClientIOHandle *)prefixHandle)->pdevHandlePtr;
    openArgsPtr = (FsOpenArgs *)argsPtr;
d760 1
a760 1
    if (pdevHandlePtr == (PdevServerIOHandle *)NIL) {
d763 1
a763 1
    request.param.open = *(FsOpenArgs *)argsPtr;
d765 1
a765 1
    getAttrResultsPtr = (FsGetAttrResults *)resultsPtr;
d768 1
a768 1
    status = FsPseudoStreamLookup(pdevHandlePtr, &request,
d780 1
a780 1
     * ioFileID type.  However, because FsDomainInfo calls this routine
d794 1
a794 1
 * FsPfsSetAttrPath --
d807 1
a807 1
FsPfsSetAttrPath(prefixHandle, relativeName, argsPtr, resultsPtr,
d809 1
a809 1
    FsHandleHeader *prefixHandle;	/* Handle from the prefix table */
d813 1
a813 1
    FsRedirectInfo **newNameInfoPtrPtr;	/* We return this if the server leaves 
d816 1
a816 1
    register PdevServerIOHandle	*pdevHandlePtr;
d819 1
a819 1
    register FsSetAttrArgs	*setAttrArgsPtr;
d825 1
a825 1
    pdevHandlePtr = ((PdevClientIOHandle *)prefixHandle)->pdevHandlePtr;
d827 1
a827 1
    setAttrArgsPtr = (FsSetAttrArgs *)argsPtr;
d833 1
a833 1
    if (pdevHandlePtr == (PdevServerIOHandle *)NIL) {
d851 1
a851 1
    status = FsPseudoStreamLookup(pdevHandlePtr, &request,
d866 1
a866 1
 * FsPfsMakeDir --
d880 1
a880 1
FsPfsMakeDir(prefixHandle, relativeName, argsPtr, resultsPtr, 
d882 1
a882 1
    FsHandleHeader *prefixHandle;   /* Handle from the prefix table */
d884 1
a884 1
    Address 	   argsPtr;	    /* Ref. to FsOpenArgs */
d886 1
a886 1
    FsRedirectInfo **newNameInfoPtrPtr;/* We return this if the server leaves 
d889 2
a890 2
    register PdevServerIOHandle	*pdevHandlePtr;
    register FsOpenArgs		*openArgsPtr;
d895 2
a896 2
    pdevHandlePtr = ((PdevClientIOHandle *)prefixHandle)->pdevHandlePtr;
    openArgsPtr = (FsOpenArgs *)argsPtr;
d901 1
a901 1
    if (pdevHandlePtr == (PdevServerIOHandle *)NIL) {
d908 1
a908 1
    status = FsPseudoStreamLookup(pdevHandlePtr, &request,
d917 1
a917 1
 * FsPfsMakeDevice --
d931 1
a931 1
FsPfsMakeDevice(prefixHandle, relativeName, argsPtr, resultsPtr,
d933 1
a933 1
    FsHandleHeader *prefixHandle;   /* Handle from the prefix table */
d937 1
a937 1
    FsRedirectInfo **newNameInfoPtrPtr;/* We return this if the server leaves 
d940 2
a941 2
    register PdevServerIOHandle	*pdevHandlePtr;
    register FsMakeDeviceArgs	*makeDevArgsPtr;
d946 2
a947 2
    pdevHandlePtr = ((PdevClientIOHandle *)prefixHandle)->pdevHandlePtr;
    makeDevArgsPtr = (FsMakeDeviceArgs *)argsPtr;
d952 1
a952 1
    if (pdevHandlePtr == (PdevServerIOHandle *)NIL) {
d959 1
a959 1
    status = FsPseudoStreamLookup(pdevHandlePtr, &request,
d968 1
a968 1
 * FsPfsRemove --
d982 1
a982 1
FsPfsRemove(prefixHandle, relativeName, argsPtr, resultsPtr, 
d984 1
a984 1
    FsHandleHeader   *prefixHandle;	/* Handle from the prefix table */
d986 1
a986 1
    Address 	   argsPtr;		/* Ref to FsLookupArgs */
d988 1
a988 1
    FsRedirectInfo **newNameInfoPtrPtr; /* We return this if the server leaves 
d991 2
a992 2
    register PdevServerIOHandle	*pdevHandlePtr;
    register FsLookupArgs	*lookupArgsPtr;
d997 2
a998 2
    pdevHandlePtr = ((PdevClientIOHandle *)prefixHandle)->pdevHandlePtr;
    lookupArgsPtr = (FsLookupArgs *)argsPtr;
d1003 1
a1003 1
    if (pdevHandlePtr == (PdevServerIOHandle *)NIL) {
d1010 1
a1010 1
    status = FsPseudoStreamLookup(pdevHandlePtr, &request,
d1019 1
a1019 1
 * FsPfsRemoveDir --
d1033 1
a1033 1
FsPfsRemoveDir(prefixHandle, relativeName, argsPtr, resultsPtr, 
d1035 1
a1035 1
    FsHandleHeader   *prefixHandle;	/* Handle from the prefix table */
d1037 1
a1037 1
    Address 	   argsPtr;		/* Ref to FsLookupArgs */
d1039 1
a1039 1
    FsRedirectInfo **newNameInfoPtrPtr; /* We return this if the server leaves 
d1042 2
a1043 2
    register PdevServerIOHandle	*pdevHandlePtr;
    register FsLookupArgs	*lookupArgsPtr;
d1048 2
a1049 2
    pdevHandlePtr = ((PdevClientIOHandle *)prefixHandle)->pdevHandlePtr;
    lookupArgsPtr = (FsLookupArgs *)argsPtr;
d1054 1
a1054 1
    if (pdevHandlePtr == (PdevServerIOHandle *)NIL) {
d1061 1
a1061 1
    status = FsPseudoStreamLookup(pdevHandlePtr, &request,
d1070 1
a1070 1
 * FsPfsRename --
d1083 1
a1083 1
FsPfsRename(prefixHandle1, relativeName1, prefixHandle2, relativeName2,
d1085 1
a1085 1
    FsHandleHeader *prefixHandle1;	/* Handle from the prefix table */
d1087 1
a1087 1
    FsHandleHeader *prefixHandle2;	/* Token from the prefix table */
d1089 2
a1090 2
    FsLookupArgs *lookupArgsPtr;	/* Contains IDs */
    FsRedirectInfo **newNameInfoPtrPtr;	/* We return this if the server leaves 
d1096 1
a1096 1
    return(FsPfs2Path(PFS_RENAME, prefixHandle1, relativeName1, prefixHandle2,
d1103 1
a1103 1
 * FsPfsHardLink --
d1117 1
a1117 1
FsPfsHardLink(prefixHandle1, relativeName1, prefixHandle2, relativeName2,
d1119 1
a1119 1
    FsHandleHeader *prefixHandle1;	/* Token from the prefix table */
d1121 1
a1121 1
    FsHandleHeader *prefixHandle2;	/* Token from the prefix table */
d1123 2
a1124 2
    FsLookupArgs *lookupArgsPtr;	/* Contains IDs */
    FsRedirectInfo **newNameInfoPtrPtr;	/* We return this if the server 
d1129 1
a1129 1
    return(FsPfs2Path(PFS_HARD_LINK, prefixHandle1, relativeName1,prefixHandle2,
d1136 1
a1136 1
 * FsPfs2Path --
d1151 1
a1151 1
FsPfs2Path(operation,prefixHandle1, relativeName1, prefixHandle2, relativeName2,
d1154 1
a1154 1
    FsHandleHeader *prefixHandle1;	/* Handle from the prefix table */
d1156 1
a1156 1
    FsHandleHeader *prefixHandle2;	/* Token from the prefix table */
d1158 2
a1159 2
    FsLookupArgs *lookupArgsPtr;	/* Contains IDs */
    FsRedirectInfo **newNameInfoPtrPtr;	/* We return this if the server leaves 
d1165 3
a1167 3
    register PdevServerIOHandle	*pdevHandlePtr;
    register PdevServerIOHandle	*pdevHandle2Ptr;
    Fs2PathData			*dataPtr;
d1171 1
a1171 1
    pdevHandlePtr = ((PdevClientIOHandle *)prefixHandle1)->pdevHandlePtr;
d1176 1
a1176 1
    if (pdevHandlePtr == (PdevServerIOHandle *)NIL) {
d1180 1
a1180 1
    if ((prefixHandle2 == (FsHandleHeader *)NIL) ||
d1190 1
a1190 1
	pdevHandle2Ptr = ((PdevClientIOHandle *)prefixHandle2)->pdevHandlePtr;
d1193 1
a1193 1
    dataPtr = (Fs2PathData *)malloc(sizeof(Fs2PathData));
d1197 1
a1197 1
    status = FsPseudoStream2Path(pdevHandlePtr, &request, dataPtr,
@


8.12
log
@Updated srvOpen interface
Added FsPseudoDomainInfo
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 8.11 89/06/07 15:30:50 brent Exp Locker: brent $ SPRITE (Berkeley)";
a431 6
    }
    if (status != SUCCESS) {
	domainInfoPtr->maxKbytes = -1;
	domainInfoPtr->freeKbytes = -1;
	domainInfoPtr->maxFileDesc = -1;
	domainInfoPtr->freeFileDesc = -1;
@


8.11
log
@Updated used of FsPrefixLookup
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 8.10 89/03/17 12:49:30 brent Exp Locker: brent $ SPRITE (Berkeley)";
d88 1
a88 2
FsRmtLinkSrvOpen(handlePtr, clientID, useFlags, ioFileIDPtr, streamIDPtr,
	dataSizePtr, clientDataPtr)
d92 2
a93 10
     int		clientID;	/* Host ID of client doing the open */
     register int	useFlags;	/* FS_MASTER, plus
					 * FS_READ | FS_WRITE | FS_EXECUTE*/
     register Fs_FileID	*ioFileIDPtr;	/* Return - I/O handle ID */
     Fs_FileID		*streamIDPtr;	/* Return - stream ID. 
					 * NIL during set/get attributes */
     int		*dataSizePtr;	/* Return - sizeof(FsPdevState) */
     ClientData		*clientDataPtr;	/* Return - a reference to FsPdevState.
					 * Nothing is returned during set/get
					 * attributes */
d96 1
d98 2
a99 3
    if ((useFlags & FS_PFS_MASTER) == 0) {
	return(FsFileSrvOpen(handlePtr, clientID, useFlags, ioFileIDPtr,
			    streamIDPtr, dataSizePtr, clientDataPtr));
d111 1
a111 1
    if (useFlags & FS_EXCLUSIVE) {
d118 1
a118 1
	ioFileIDPtr->serverID = clientID;
d120 1
a120 1
	FsStreamNewID(clientID, streamIDPtr);
d138 2
a139 2
	    ctrlHandlePtr->serverID = clientID;
	    FsStreamNewID(clientID, streamIDPtr);
d143 2
a144 2
    *clientDataPtr = (ClientData)NIL;
    *dataSizePtr = 0;
d404 36
d960 1
a960 1
			    &makeDevArgsPtr->prefixID, &makeDevArgsPtr->rootID);
@


8.10
log
@Fixed getwd() in pseudo-file-systems
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 8.9 89/03/14 10:42:33 brent Exp $ SPRITE (Berkeley)";
d207 1
d223 1
a223 1
		&prefixHdrPtr, &rootID, &ignoredName, &domain, &prefixPtr);
@


8.9
log
@Changed Pfs_Request structure and fixed MakeDir bug
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 8.8 89/02/09 09:27:06 brent Exp $ SPRITE (Berkeley)";
d761 3
a763 1
     * ioFileID type.
d766 3
@


8.8
log
@Added call to Sync_LockClear
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 8.7 89/02/04 12:09:13 brent Exp $ SPRITE (Berkeley)";
d390 16
d407 7
d754 8
a761 2
     * The pseudo-filesystem server has given us all the attributes so
     * we don't fill in the ioFileID.
d866 1
a866 1
    register FsLookupArgs	*lookupArgsPtr;
d872 1
a872 1
    lookupArgsPtr = (FsLookupArgs *)argsPtr;
d876 1
a876 1
			    &lookupArgsPtr->prefixID, &lookupArgsPtr->rootID);
d880 1
a880 1
    request.param.lookup = *lookupArgsPtr;
d982 1
a982 1
    request.param.lookup = *lookupArgsPtr;
d1033 1
a1033 1
    request.param.lookup = *lookupArgsPtr;
@


8.7
log
@Nuked PfsControlHandleInit, its just like FsControlHandleInit
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 8.6 89/01/30 14:05:18 brent Exp $ SPRITE (Berkeley)";
d571 1
@


8.6
log
@Added object stats
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 8.5 89/01/25 13:31:52 brent Exp Locker: brent $ SPRITE (Berkeley)";
d143 1
a143 1
	ctrlHandlePtr = PfsControlHandleInit(ioFileIDPtr, handlePtr->hdr.name);
a155 43
}

/*
 *----------------------------------------------------------------------------
 *
 * PfsControlHandleInit --
 *
 *	Fetch and initialize a control handle for a pseudo-filesystem.
 *
 * Results:
 *	A pointer to the control stream I/O handle.
 *
 * Side effects:
 *	Initializes and installs the control handle.
 *
 *----------------------------------------------------------------------------
 *
 */
PdevControlIOHandle *
PfsControlHandleInit(fileIDPtr, name)
    Fs_FileID *fileIDPtr;
    char *name;
{
    register Boolean found;
    register PdevControlIOHandle *ctrlHandlePtr;
    FsHandleHeader *hdrPtr;

    found = FsHandleInstall(fileIDPtr, sizeof(PdevControlIOHandle), name,
			    &hdrPtr);
    ctrlHandlePtr = (PdevControlIOHandle *)hdrPtr;
    if (!found) {
	ctrlHandlePtr->serverID = NIL;
	ctrlHandlePtr->seed = 0;
	FsLockInit(&ctrlHandlePtr->lock);
	FsRecoveryInit(&ctrlHandlePtr->rmt.recovery);
	fsStats.object.controls++;
	/*
	 * These next two lists aren't used.
	 */
	List_Init(&ctrlHandlePtr->queueHdr);
	List_Init(&ctrlHandlePtr->readWaitList);
    }
    return(ctrlHandlePtr);
@


8.5
log
@Added PDEV_NAMING to mark naming stream
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 8.4 89/01/25 09:52:42 brent Exp $ SPRITE (Berkeley)";
d47 1
d191 1
d426 1
d616 1
@


8.4
log
@Updated call to FsPdevConnect
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 8.3 89/01/24 12:25:15 brent Exp $ SPRITE (Berkeley)";
d290 1
a290 1
    cltHandlePtr = FsPdevConnect(ctrlHandlePtr, ioFileIDPtr, rpc_SpriteID);
d298 1
a298 2
     * Distinguish the naming request-response stream from other connections
     * that may get established later.  This ID gets passed in FsLookupArgs
d300 1
d581 2
a582 2
    cltHandlePtr = FsPdevConnect(fileIDPtr, namingPdevHandlePtr->open.clientID,
				namingPdevHandlePtr->open.name);
d588 2
a589 2
     * Set the ioFileID type. (FsPdevConnect has set it to FS_SERVER_STREAM.)
     * The clientID has been set curtesy of the PFS_OPEN RequestResponse.
@


8.3
log
@Added #include
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 8.2 89/01/04 08:53:05 brent Exp Locker: brent $ SPRITE (Berkeley)";
d290 1
a290 1
    cltHandlePtr = FsPdevConnect(ioFileIDPtr, rpc_SpriteID, name);
a296 1
    pdevHandlePtr->ctrlHandlePtr = ctrlHandlePtr;
@


8.2
log
@Fixed FsPfs2Path to check against NIL prefixHandle2
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 8.1 88/12/21 10:17:48 brent Exp $ SPRITE (Berkeley)";
d51 1
@


8.1
log
@Double migration bug fix
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 7.0 88/11/11 15:34:23 brent Exp $ SPRITE (Berkeley)";
d1165 2
a1166 1
    if ((prefixHandle2->fileID.type != prefixHandle1->fileID.type) ||
@


8.0
log
@Changing version numbers.
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 7.0 88/11/11 15:34:23 brent Exp Locker: douglis $ SPRITE (Berkeley)";
d317 4
@


7.0
log
@New version for conversion to new C library
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 6.8 88/11/07 09:05:01 brent Exp Locker: brent $ SPRITE (Berkeley)";
@


6.8
log
@Added Pfs2PathOperation for rename and hardlink
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 6.7 88/11/02 16:03:33 brent Exp $ SPRITE (Berkeley)";
d256 1
a256 1
	Sys_Panic(SYS_WARNING,
d264 1
a264 1
	Sys_Panic(SYS_WARNING, "Prefix \"%s\" already serviced\n", name);
d485 1
a485 1
		String_Length(relativeName) + 1, (Address)relativeName,
d580 1
a580 1
	Sys_Panic(SYS_WARNING, "FsPfsOpenConnection failing\n");
d665 1
a665 1
	Sys_Panic(SYS_WARNING, "FsPfsStreamCltOpen, no handle\n");
d670 1
a670 1
	    Mem_Free((Address)cltHandlePtr->hdr.name);
d672 2
a673 2
	cltHandlePtr->hdr.name = (char *)Mem_Alloc(String_Length(name) + 1);
	(void)String_Copy(name, cltHandlePtr->hdr.name);
d761 1
a761 1
		String_Length(relativeName) + 1, (Address)relativeName,
d823 1
a823 1
    nameLength = String_Length(relativeName);
d826 1
a826 1
    setAttrDataPtr = (Pfs_SetAttrData *)Mem_Alloc(dataLength);
d830 1
a830 1
    (void)String_Copy(relativeName, setAttrDataPtr->name);
d835 1
a835 1
    Mem_Free((Address)setAttrDataPtr);
d890 1
a890 1
		String_Length(relativeName) + 1, (Address)relativeName,
d941 1
a941 1
		String_Length(relativeName) + 1, (Address)relativeName,
d992 1
a992 1
		String_Length(relativeName) + 1, (Address)relativeName,
d1043 1
a1043 1
		String_Length(relativeName) + 1, (Address)relativeName,
a1147 1
    Fs2PathParams		params;
a1150 1
    int				resultSize;
d1173 3
a1175 3
    dataPtr = (Fs2PathData *)Mem_Alloc(sizeof(Fs2PathData));
    (void)String_Copy(relativeName1, dataPtr->path1);
    (void)String_Copy(relativeName2, dataPtr->path2);
a1176 1
    resultSize = sizeof(Fs2PathReply);
d1179 1
a1179 1
    Mem_Free((Address)dataPtr);
@


6.7
log
@Fixed use of String_Length().  Need to add 1 to get the trailing NULL
sent out to the pfs server...
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 6.6 88/11/02 11:06:37 brent Exp $ SPRITE (Berkeley)";
a1062 1
/*ARGSUSED*/
d1077 2
a1078 1
    return(FAILURE);
d1110 74
a1183 1
    return(FAILURE);
@


6.6
log
@Put in robustness against server exiting.
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 6.5 88/10/22 15:21:10 brent Exp $ SPRITE (Berkeley)";
d890 1
a890 1
		String_Length(relativeName), (Address)relativeName,
d941 1
a941 1
		String_Length(relativeName), (Address)relativeName,
d992 1
a992 1
		String_Length(relativeName), (Address)relativeName,
d1043 1
a1043 1
		String_Length(relativeName), (Address)relativeName,
@


6.5
log
@Debugged/corrected establishment of a new pdev connection as a
side effect of the PFS_OPEN request
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 6.4 88/10/20 15:50:43 brent Exp $ SPRITE (Berkeley)";
d473 3
d524 6
a529 3
    FsHandleRelease(cltHandlePtr, TRUE);

    return(cltHandlePtr->pdevHandlePtr);
d752 3
d814 3
d882 3
d933 3
d984 3
d1035 3
@


6.4
log
@removed lint
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPfs.c,v 6.3 88/10/19 09:55:03 brent Exp $ SPRITE (Berkeley)";
d79 2
a80 1
 *	who is the server for the pseudo device.
d152 1
a152 1
    FsHandleRelease(handlePtr, TRUE);
d433 1
a433 2
 *	Open a file served by a pseudo-filesystem server.  This is called
 *	from FsLookupOperation based on the prefix table.  The stream returned
d547 2
a548 2
FsPfsOpenConnection(pdevHandlePtr, srvrFileIDPtr, fileIDPtr)
    PdevServerIOHandle	*pdevHandlePtr;	/* From naming request-response */
d550 1
a550 1
    register Fs_FileID	*fileIDPtr;	/* FileID for new connection */
d555 1
d557 1
a559 7
     * Lock the control stream associated with the pfs naming stream
     * in order to get a seed for the Fs_FileID's generated here.
     */
    ctrlHandlePtr = pdevHandlePtr->ctrlHandlePtr;
    FsHandleLock(ctrlHandlePtr);

    /*
d562 1
d564 1
d571 2
a572 3
    cltHandlePtr = FsPdevConnect(fileIDPtr, rpc_SpriteID,
				ctrlHandlePtr->rmt.hdr.name);
    FsHandleUnlock(ctrlHandlePtr);
d578 9
d592 2
a593 2
     * Pick a fileID for the server's stream, and map this to a
     * user-level streamID.
d597 1
a597 1
		    FS_READ|FS_USER, ctrlHandlePtr->rmt.hdr.name);
d605 13
d638 2
a639 1
 *	None.
d669 1
d672 34
@


6.3
log
@Added stuff to map out to user-level fileIDs for each connection.
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: fsPfs.c,v 6.2 88/10/14 12:18:15 brent Exp $ SPRITE (Berkeley)";
d53 1
a101 1
    register Fs_Stream *streamPtr;
d298 2
a299 1
     * that may get established later.  This ID gets passed in FsLookupArgs.
@


6.2
log
@FsFileID FsUserID change
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: fsPfs.c,v 6.1 88/10/14 10:39:10 brent Exp $ SPRITE (Berkeley)";
d131 5
a135 2
	 * and possibly some reopens, we can do conflict checking, and we
	 * must have a shadow stream so the close and reopens work.
d145 1
a145 5
	    streamPtr = FsStreamNewClient(rpc_SpriteID, clientID,
				    (FsHandleHeader *)ctrlHandlePtr,
				    useFlags, handlePtr->hdr.name);
	    *streamIDPtr = streamPtr->hdr.fileID;
	    FsHandleRelease(streamPtr, TRUE);
d241 1
d274 2
a275 1
     * pseudo-device connections to the pseudo-filesystem server.
d278 1
d281 4
a284 1
     * end to the calling process.
d287 1
d293 3
d297 8
d313 2
a314 2
    FsPrefixInstall(name, (FsHandleHeader *)cltHandlePtr, FS_PSEUDO_DOMAIN,
			    prefixFlags);
d359 1
d362 10
a371 5
    (void)FsIOClientOpen(&cltHandlePtr->clientList, clientID, 0, FALSE);
    *ioFileIDPtr = cltHandlePtr->hdr.fileID;
    ioFileIDPtr->type = FS_PFS_NAMING_STREAM;
    *dataSizePtr = 0;
    *clientDataPtr = (ClientData)NIL;
d373 1
a373 1
    return(SUCCESS);
d450 1
a450 1
    FsHandleHeader  *prefixHandle;	/* Token from the prefix table */
d457 3
a459 1
    PdevServerIOHandle		*pdevHandlePtr;
d464 1
a464 1
    pdevHandlePtr = ((PdevClientIOHandle *)prefixHandle)->pdevHandlePtr;
d466 3
d470 3
a472 1
    request.param.open = *(FsOpenArgs *)argsPtr;
d476 4
d481 1
a481 1
		String_Length(relativeName), (Address)relativeName,
d489 39
d546 1
a546 1
FsPfsOpenConnection(pdevHandlePtr, fileIDPtr)
d548 2
a549 1
    Fs_FileID		*fileIDPtr;	/* FileID for new connection */
d551 3
a553 3
    PdevControlIOHandle *ctrlHandlePtr;
    PdevClientIOHandle *cltHandlePtr;
    Fs_Stream *srvStreamPtr;
d557 1
a557 1
     * Fetch the control stream associated with the pfs naming stream
d560 2
a561 7
    *fileIDPtr = pdevHandlePtr->hdr.fileID;
    fileIDPtr->type = FS_PFS_CONTROL_STREAM;
    ctrlHandlePtr = FsHandleFetchType(PdevControlIOHandle, fileIDPtr);
    if (ctrlHandlePtr == (PdevControlIOHandle *)NIL) {
	Sys_Panic(SYS_WARNING, "FsPfsOpenConnection, no control handle\n");
	return(-1);
    }
d575 1
a575 1
    FsHandleRelease(ctrlHandlePtr, TRUE);
d580 4
d681 2
a682 1
    FsGetAttrResults		*getAttrResultsPtr;
d686 1
d689 2
d697 1
a697 1
		String_Length(relativeName), (Address)relativeName,
d736 4
a739 2
    FsSetAttrArgs		*setAttrArgsPtr;
    int				nameLength;
a740 1
    Pfs_SetAttrData		*setAttrDataPtr;
d747 3
d752 4
d757 3
a759 2
    setAttrDataPtr = (Pfs_SetAttrData *)Mem_Alloc(sizeof(Pfs_SetAttrData) +
						    nameLength);
d766 1
a766 1
	    sizeof(Pfs_SetAttrData) + nameLength, (Address)setAttrDataPtr,
d804 1
d810 1
d813 3
a815 1
    request.param.lookup = *(FsLookupArgs *)argsPtr;
d852 1
d858 1
d861 3
a863 1
    request.param.makeDevice = *(FsMakeDeviceArgs *)argsPtr;
d900 1
d906 1
d909 3
a911 1
    request.param.lookup = *(FsLookupArgs *)argsPtr;
d948 1
d954 1
d957 3
a959 1
    request.param.lookup = *(FsLookupArgs *)argsPtr;
@


6.1
log
@Fleshed out implementation through setting up of pdev connections.
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: fsPfs.c,v 6.0 88/10/11 15:52:49 brent Exp $ SPRITE (Berkeley)";
d92 2
a93 2
     register FsFileID	*ioFileIDPtr;	/* Return - I/O handle ID */
     FsFileID		*streamIDPtr;	/* Return - stream ID. 
d174 1
a174 1
    FsFileID *fileIDPtr;
d232 1
a232 1
    register FsFileID	*ioFileIDPtr;	/* I/O fileID */
d244 1
a244 1
    FsFileID			rootID;
d337 1
a337 1
     register FsFileID	*ioFileIDPtr;	/* Return - I/O handle ID */
d380 1
a380 1
    register FsFileID	*ioFileIDPtr;	/* I/O fileID */
d475 1
a475 1
    FsFileID		*fileIDPtr;	/* FileID for new connection */
d484 1
a484 1
     * in order to get a seed for the FsFileID's generated here.
d554 1
a554 1
    register FsFileID	*ioFileIDPtr;	/* I/O fileID */
d687 1
a687 1
    ((FsFileID *)resultsPtr)->type = -1;
@


6.0
log
@First partion version.  Prefix table stuff done, but opening not done.
@
text
@d33 1
a33 1
static char rcsid[] = "$Header: fsPdev.c,v 6.15 88/09/28 15:24:19 douglis Exp $ SPRITE (Berkeley)";
d43 1
d108 4
a111 2
     * Generate an ID that represents a process on the client that
     * is servicing a domain corresponding to the remote link.
d114 3
a116 3
    ioFileIDPtr->major = (handlePtr->hdr.fileID.serverID << 16) ^
			  handlePtr->hdr.fileID.major;
    ioFileIDPtr->minor = handlePtr->hdr.fileID.minor;
d120 3
a122 3
	 * We set its serverID to the client which means we won't
	 * see closes and can't do conflict checking here.  We generate
	 * a stream ID for the open, but don't keep a shadow stream here.
d125 1
d228 1
a228 1

a248 1
    Boolean			found;
a271 16

    ctrlHandlePtr = PfsControlHandleInit(ioFileIDPtr, name);
#ifdef notdef
    if (*flagsPtr & FS_EXCLUSIVE) {
	/*
	 * If this is for a private pseudo-filesystem server then we do
	 * conflict checking here.
	 */
	if (ctrlHandlePtr->serverID != NIL) {
	    status = FS_FILE_BUSY;
	    goto cleanup;
	} else {
	    ctrlHandlePtr->serverID = clientID;
	}
    }
#endif
d273 5
d282 2
a283 7
    found = FsHandleInstall(ioFileIDPtr, sizeof(PdevClientIOHandle), name,
			    ioHandlePtrPtr);
    cltHandlePtr = (PdevClientIOHandle *)(*ioHandlePtrPtr);
    if (found) {
	Sys_Panic(SYS_FATAL, "FsPfsCltOpen, found client handle <%d,%x,%x>\n",
		ioFileIDPtr->serverID, ioFileIDPtr->major, ioFileIDPtr->minor);
	FsHandleRelease(cltHandlePtr, TRUE);
a286 9
    cltHandlePtr->pdevHandlePtr = FsServerStreamCreate(ioFileIDPtr, name);
    *ioHandlePtrPtr = (FsHandleHeader *)cltHandlePtr->pdevHandlePtr;
    if (cltHandlePtr->pdevHandlePtr == (PdevServerIOHandle *)NIL) {
	Sys_Panic(SYS_FATAL, "FsPfsCltOpen, no server handle <%d,%x,%x>\n",
		ioFileIDPtr->serverID, ioFileIDPtr->major, ioFileIDPtr->minor);
	FsHandleRelease(cltHandlePtr, TRUE);
	status = FAILURE;
	goto cleanup;
    }
a287 5
     * Initialize the client list which is used to verify remote naming ops.
     */
    List_Init(&cltHandlePtr->clientList);
    (void)FsIOClientOpen(&cltHandlePtr->clientList, clientID, 0, FALSE);
    /*
a297 1
    FsHandleUnlock(cltHandlePtr->pdevHandlePtr);
d321 1
a321 1
 *	up the handle it will attach to its own prefix table.
d409 4
a412 1
 *	from FsLookupOperation based on the prefix table.
a413 1
 *
d419 1
a419 3
 *	Allocates memory for the returned streamData or re-directed path.
 *	An openCount is left up during the open as part of the open/re-open
 *	synchronization.
d434 1
a434 1
    register PdevServerIOHandle	*pdevHandlePtr;
d449 33
d483 2
a484 1
     * Lot's more code to go here, yet.
d486 44
a529 1
    return(status);
d533 50
d605 24
a628 1
    ReturnStatus 		status;
d632 1
a632 1
 * FsPfsGetAttrPath --
d634 2
d656 33
a688 1
    ReturnStatus 		status;
d694 1
a694 1
 * FsPfsRemove --
d696 1
a696 1
 *	Remove a file served by a pseudo-filesystem server.
d699 1
a699 1
 *	None.
d702 1
a702 1
 *	Does the remove.
d708 8
a715 8
FsPfsRemove(prefixHandle, relativeName, argsPtr, resultsPtr, 
	       newNameInfoPtrPtr)
    FsHandleHeader   *prefixHandle;	/* Handle from the prefix table */
    char 	   *relativeName;	/* The name of the file to remove */
    Address 	   argsPtr;		/* Ref to FsLookupArgs */
    Address 	   resultsPtr;		/* == NIL */
    FsRedirectInfo **newNameInfoPtrPtr; /* We return this if the server leaves 
					   its domain during the lookup. */
d717 16
d738 1
a738 1
 * FsPfsRemoveDir --
d740 1
a740 1
 *	Remove a directory in a pseudo-filesystem.
d746 1
a746 1
 *	Does the remove.
d752 8
a759 8
FsPfsRemoveDir(prefixHandle, relativeName, argsPtr, resultsPtr, 
	       newNameInfoPtrPtr)
    FsHandleHeader   *prefixHandle;	/* Handle from the prefix table */
    char 	   *relativeName;	/* The name of the file to remove */
    Address 	   argsPtr;		/* Ref to FsLookupArgs */
    Address 	   resultsPtr;		/* == NIL */
    FsRedirectInfo **newNameInfoPtrPtr; /* We return this if the server leaves 
					   its domain during the lookup. */
d761 4
d766 11
d782 1
a782 1
 * FsPfsMakeDir --
d784 1
a784 1
 *	Make the named directory in a pseudo-filesystem.
d787 1
a787 1
 *	A return code from the file server or the RPC.
d790 1
a790 1
 *	Makes the directory.
d796 8
a803 8
FsPfsMakeDir(prefixHandle, relativeName, argsPtr, resultsPtr, 
		newNameInfoPtrPtr)
    FsHandleHeader *prefixHandle;   /* Handle from the prefix table */
    char 	   *relativeName;   /* The name of the directory to create */
    Address 	   argsPtr;	    /* Ref. to FsOpenArgs */
    Address 	   resultsPtr;	    /* == NIL */
    FsRedirectInfo **newNameInfoPtrPtr;/* We return this if the server leaves 
					* its domain during the lookup. */
d805 16
d826 1
a826 1
 * FsPfsMakeDevice --
d828 1
a828 1
 *	Create a device file in a pseudo-filesystem.
d834 1
a834 1
 *	Makes a device file.
d840 8
a847 8
FsPfsMakeDevice(prefixHandle, relativeName, argsPtr, resultsPtr,
			       newNameInfoPtrPtr)
    FsHandleHeader *prefixHandle;   /* Handle from the prefix table */
    char           *relativeName;   /* The name of the file. */
    Address        argsPtr;	    /* Ref. to FsMakeDevArgs */
    Address        resultsPtr;	    /* == NIL */
    FsRedirectInfo **newNameInfoPtrPtr;/* We return this if the server leaves 
					* its domain during the lookup. */
d849 16
d882 1
d897 1
d915 1
d929 1
a930 2


@
