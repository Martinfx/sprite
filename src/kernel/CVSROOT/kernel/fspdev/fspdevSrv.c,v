head     9.8;
branch   ;
access   ;
symbols  ds3100:9.8 sun3:9.8 sprited:9.7.1 sun4nw:9.8 symm:9.8 spur:9.8 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.8
date     91.09.10.18.28.13;  author rab;  state Exp;
branches ;
next     9.7;

9.7
date     91.06.26.01.06.56;  author mottsmth;  state Exp;
branches 9.7.1.1;
next     9.6;

9.6
date     91.03.30.17.12.51;  author mgbaker;  state Exp;
branches ;
next     9.5;

9.5
date     90.12.06.21.56.28;  author jhh;  state Exp;
branches ;
next     9.4;

9.4
date     90.10.08.12.47.07;  author mendel;  state Exp;
branches ;
next     9.3;

9.3
date     90.07.30.11.39.15;  author shirriff;  state Exp;
branches ;
next     9.2;

9.2
date     90.06.11.16.28.17;  author douglis;  state Exp;
branches ;
next     9.1;

9.1
date     89.10.23.09.52.30;  author brent;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.08.00;  author douglis;  state Stable;
branches ;
next     8.27;

8.27
date     89.08.21.15.27.35;  author mendel;  state Exp;
branches ;
next     8.26;

8.26
date     89.08.17.17.21.33;  author jhh;  state Exp;
branches ;
next     8.25;

8.25
date     89.08.17.12.13.20;  author brent;  state Exp;
branches ;
next     8.24;

8.24
date     89.08.12.10.44.51;  author jhh;  state Exp;
branches ;
next     8.23;

8.23
date     89.08.01.20.38.59;  author jhh;  state Exp;
branches ;
next     8.22;

8.22
date     89.07.18.13.08.22;  author jhh;  state Exp;
branches ;
next     8.21;

8.21
date     89.07.08.18.39.50;  author brent;  state Exp;
branches ;
next     8.20;

8.20
date     89.06.30.15.29.06;  author brent;  state Exp;
branches ;
next     8.19;

8.19
date     89.06.21.12.32.56;  author mendel;  state Exp;
branches ;
next     8.18;

8.18
date     89.06.16.12.07.12;  author brent;  state Exp;
branches ;
next     8.17;

8.17
date     89.06.15.17.00.21;  author brent;  state Exp;
branches ;
next     8.16;

8.16
date     89.06.15.09.21.00;  author brent;  state Exp;
branches ;
next     8.15;

8.15
date     89.06.02.13.01.37;  author brent;  state Exp;
branches ;
next     8.14;

8.14
date     89.05.30.16.11.50;  author jhh;  state Exp;
branches ;
next     8.13;

8.13
date     89.04.12.14.20.44;  author brent;  state Exp;
branches ;
next     8.12;

8.12
date     89.03.30.17.07.22;  author brent;  state Exp;
branches ;
next     8.11;

8.11
date     89.03.24.17.02.00;  author brent;  state Exp;
branches ;
next     8.10;

8.10
date     89.03.14.10.43.06;  author brent;  state Exp;
branches ;
next     8.9;

8.9
date     89.02.28.08.48.37;  author brent;  state Exp;
branches ;
next     8.8;

8.8
date     89.02.07.14.22.21;  author brent;  state Exp;
branches ;
next     8.7;

8.7
date     89.02.06.18.26.51;  author brent;  state Exp;
branches ;
next     8.6;

8.6
date     89.01.30.14.04.32;  author brent;  state Exp;
branches ;
next     8.5;

8.5
date     89.01.29.14.34.51;  author brent;  state Exp;
branches ;
next     8.4;

8.4
date     89.01.25.13.31.27;  author brent;  state Exp;
branches ;
next     8.3;

8.3
date     89.01.25.09.53.07;  author brent;  state Exp;
branches ;
next     8.2;

8.2
date     89.01.24.12.24.11;  author brent;  state Exp;
branches ;
next     8.1;

8.1
date     89.01.19.09.42.04;  author brent;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.21.51;  author douglis;  state Stable;
branches ;
next     7.0;

7.0
date     88.11.11.15.32.45;  author brent;  state Exp;
branches ;
next     6.25;

6.25
date     88.11.07.09.02.01;  author brent;  state Exp;
branches ;
next     6.24;

6.24
date     88.11.02.11.03.48;  author brent;  state Exp;
branches ;
next     6.23;

6.23
date     88.10.22.15.15.50;  author brent;  state Exp;
branches ;
next     6.22;

6.22
date     88.10.20.15.49.50;  author brent;  state Exp;
branches ;
next     6.21;

6.21
date     88.10.19.09.47.51;  author brent;  state Exp;
branches ;
next     6.20;

6.20
date     88.10.17.08.54.25;  author brent;  state Exp;
branches ;
next     6.19;

6.19
date     88.10.14.12.16.47;  author brent;  state Exp;
branches ;
next     6.18;

6.18
date     88.10.14.10.37.40;  author brent;  state Exp;
branches ;
next     6.17;

6.17
date     88.10.11.16.03.55;  author brent;  state Exp;
branches ;
next     6.16;

6.16
date     88.10.03.09.06.06;  author brent;  state Exp;
branches ;
next     6.15;

6.15
date     88.09.28.15.24.19;  author douglis;  state Exp;
branches ;
next     6.14;

6.14
date     88.09.23.14.35.26;  author brent;  state Exp;
branches ;
next     6.13;

6.13
date     88.09.22.11.47.07;  author brent;  state Exp;
branches ;
next     6.12;

6.12
date     88.09.21.14.58.35;  author brent;  state Exp;
branches ;
next     6.11;

6.11
date     88.09.20.15.22.44;  author brent;  state Exp;
branches ;
next     6.10;

6.10
date     88.09.19.11.23.28;  author brent;  state Exp;
branches ;
next     6.9;

6.9
date     88.09.16.16.51.37;  author brent;  state Exp;
branches ;
next     6.8;

6.8
date     88.09.13.11.27.41;  author brent;  state Exp;
branches ;
next     6.7;

6.7
date     88.09.07.16.53.38;  author brent;  state Exp;
branches ;
next     6.6;

6.6
date     88.08.31.12.05.44;  author brent;  state Exp;
branches ;
next     6.5;

6.5
date     88.08.26.17.49.49;  author brent;  state Exp;
branches ;
next     6.4;

6.4
date     88.08.26.11.10.59;  author brent;  state Exp;
branches ;
next     6.3;

6.3
date     88.08.24.18.10.48;  author brent;  state Exp;
branches ;
next     6.2;

6.2
date     88.08.18.17.59.33;  author brent;  state Exp;
branches ;
next     6.1;

6.1
date     88.08.16.17.44.00;  author brent;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.17.23;  author brent;  state Stable;
branches ;
next     1.15;

1.15
date     88.08.05.13.59.59;  author brent;  state Exp;
branches ;
next     1.14;

1.14
date     88.08.03.17.18.58;  author mlgray;  state Exp;
branches ;
next     1.13;

1.13
date     88.06.17.10.45.04;  author brent;  state Exp;
branches ;
next     1.12;

1.12
date     88.06.08.15.01.03;  author brent;  state Exp;
branches ;
next     1.11;

1.11
date     88.06.06.09.36.56;  author brent;  state Exp;
branches ;
next     1.10;

1.10
date     88.06.03.11.30.03;  author brent;  state Exp;
branches ;
next     1.9;

1.9
date     88.06.02.11.35.38;  author brent;  state Exp;
branches ;
next     1.8;

1.8
date     88.06.02.10.11.12;  author brent;  state Exp;
branches ;
next     1.7;

1.7
date     88.06.01.17.24.12;  author brent;  state Exp;
branches ;
next     1.6;

1.6
date     88.05.05.17.33.39;  author brent;  state Exp;
branches ;
next     1.5;

1.5
date     88.05.03.14.47.12;  author brent;  state Exp;
branches ;
next     1.4;

1.4
date     88.04.28.11.03.43;  author brent;  state Exp;
branches ;
next     1.3;

1.3
date     88.04.28.08.21.52;  author brent;  state Exp;
branches ;
next     1.2;

1.2
date     88.04.19.10.50.16;  author brent;  state Exp;
branches ;
next     1.1;

1.1
date     88.04.15.09.14.31;  author brent;  state Exp;
branches ;
next     ;

9.7.1.1
date     91.11.15.16.35.00;  author kupfer;  state Exp;
branches ;
next     ;


desc
@Routines to implement psuedo-devices
@


9.8
log
@Fixed lint errors and removed tracing.
@
text
@/* 
 * fspdevSrv.c --  
 *
 *	This file contains routines directly related to the request-response
 *	protocol between the client and server processes.  Routines that
 *	setup state, i.e. the SrvOpen, CltOpen, and migration routines,
 *	are in fsPdevSetup.c.  Routines for the Control stream are
 *	found in fsPdevControl.c
 *
 *	Operations on a pseudo-device are forwarded to a user-level server
 *	process using a "request-response" protocol.
 *	The server process declares a request buffer (and optionally a read
 *	ahead buffer) in its address space.  The kernel puts requests, which
 *	are generated when a client does an operation on the pseudo stream,
 *	into the request buffer directly.  The server learns of new requests
 *	by reading messages from the server stream that contain offsets within
 *	the request buffer.  Write requests may not require a response from
 *	the server.  Instead the kernel just puts the request into the buffer
 *	and returns to the client.  This allows many requests to be buffered
 *	before a context switch to the server process.  Similarly,
 *	the server can put read data into the read ahead buffer for a pseudo
 *	stream.  In this case a client's read will be satisfied from the
 *	buffer and the server won't be contacted.
 *
 * Copyright 1987, 1988 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fspdevSrv.c,v 9.7 91/06/26 01:06:56 mottsmth Exp Locker: rab $ SPRITE (Berkeley)";
#endif not lint

#include <status.h>
#include <sprite.h>
#include <fs.h>
#include <fsutil.h>
#include <fsNameOps.h>
#include <fsio.h>
#include <fsconsist.h>
#include <fsioLock.h>
#include <fsdm.h>
#include <fsStat.h>
#include <fspdev.h>
#include <proc.h>
#include <rpc.h>
#include <string.h>
#include <fspdevInt.h>
#include <dev/pfs.h>

/*
 * Access to Fspdev_ServerIOHandle is monitored to serialize access to
 * the request-response communication channel.
 */
#define LOCKPTR (&pdevHandlePtr->lock)

/*
 * Flags for a pseudo device handle.
 *	PDEV_SETUP		The server has set up state for the stream.
 *	PDEV_BUSY		Set during request-response to ensure that
 *				only one client process is using the stream.
 *	PDEV_REPLY_READY	The server gave us a reply
 *	PDEV_REPLY_FAILED	There was some problem (usually with copy in)
 *				getting the reply from the server.
 *	PDEV_SERVER_GONE	Set after the server closes its stream.
 *	PDEV_READ_BUF_EMPTY	When set there is no data in the read ahead
 *				buf.
 *	PDEV_SERVER_KNOWS_IT	Set after the server has done a read and been
 *				told that we too think the read ahead buffer
 *				is empty.  This synchronization simplifies
 *				things; there is no wrapping; there is no
 *				confusion about full vs. empty.
 *	PDEV_READ_PTRS_CHANGED	Set when we have used data from the read
 *				ahead buffer.  This makes the server stream
 *				selectable so it will find out about the
 *				new pointers.
 *	PDEV_WRITE_BEHIND	Write-behind is enabled for this stream.
 *	PDEV_NO_BIG_WRITES	Causes writes larger than will fit into
 *				the request buffer to fail.  This is to
 *				support UDP socket semantics, sigh.
 *	PDEV_NAMING		Set on the naming request-response channel.
 *	PDEV_REQUEST_ABORTED	Set when the client aborts during a request-
 *				response transaction so we ignore the next rply.
 *	FS_USER_IN/OUT		These flags are borrowed from the stream flags
 *				and indicate which buffers are in user space
 */
#define PDEV_SETUP		0x0001
#define PDEV_BUSY		0x0002
#define PDEV_REPLY_READY	0x0004
#define PDEV_REPLY_FAILED	0x0008
#define PDEV_SERVER_GONE	0x0010
#define PDEV_READ_BUF_EMPTY	0x0020
#define PDEV_SERVER_KNOWS_IT	0x0040
#define PDEV_READ_PTRS_CHANGED	0x0080
#define PDEV_WRITE_BEHIND	0x0100
#define PDEV_NO_BIG_WRITES	0x0200
#define PDEV_NAMING		0x0400
#define PDEV_REQUEST_ABORTED	0x0800
/*resrv FS_USER_IN		0x8000 */
/*resrv FS_USER_OUT	      0x800000 */

/*
 * Forward declarations.
 */

static ReturnStatus RequestResponse _ARGS_((
	Fspdev_ServerIOHandle *pdevHandlePtr,
	int hdrSize, register Pdev_RequestHdr *requestHdrPtr, int inputSize,
	Address inputBuf, int replySize, Address replyBuf, 
	Fs_IOReply *ioReplyPtr, Sync_RemoteWaiter *waitPtr));
static void PdevClientWakeup _ARGS_((Fspdev_ServerIOHandle *pdevHandlePtr));
static void PdevClientNotify _ARGS_((Fspdev_ServerIOHandle *pdevHandlePtr));

/*
 *----------------------------------------------------------------------
 *
 * RequestResponse --
 *
 *	The general request-response protocol between a client's pseudo
 *	stream and the server stream.  This passes a request to the server
 *	that specifies the command and parameters, the size of the input data
 *	and the max size of the reply.  Then, if a reply is needed, this blocks
 *	the client until the server responds.
 *
 * Results:
 *	An error code from the server, or from errors on the vm copies.
 *
 * Side effects:
 *	The server process is locked while we copy the request into the
 *	buffer in the server's address space.  The firstByte and lastByte
 *	offsets into the pseudo stream request buffer are updated to
 *	reflect the new request.  The corresponding server stream is
 *	marked FS_READABLE.
 *
 *----------------------------------------------------------------------
 */

INTERNAL static ReturnStatus
RequestResponse(pdevHandlePtr, hdrSize, requestHdrPtr, inputSize, inputBuf,
	replySize, replyBuf, ioReplyPtr, waitPtr)
    register Fspdev_ServerIOHandle *pdevHandlePtr;	/* Caller should lock this
						 * with the monitor lock. */
    int			hdrSize;	/* Either sizeof(Pdev_Request) or
					 * sizeof(Pfs_Request) */
    register Pdev_RequestHdr *requestHdrPtr;	/* Caller fills in the
					 * command and parameter parts. The
					 * sizes are filled in here. */
    int			inputSize;	/* Size of input buffer. */
    Address		inputBuf;	/* Inputs of the remote command. */
    int			replySize;	/* Size of output buffer.  0 means
					 * no reply data expected.  If the
					 * operation is PDEV_WRITE_ASYNC then no
					 * reply is wanted and this is ignored*/
    Address		replyBuf;	/* Results of the remote command. */
    Fs_IOReply		*ioReplyPtr;	/* Amount transferred and signal to
					 * return. (May be NIL if not needed.)*/
    Sync_RemoteWaiter	*waitPtr;	/* Client process info for waiting.
					 * Only needed for read & write. */
{
    register ReturnStatus  status;
    Proc_ControlBlock	   *serverProcPtr;   /* For VM copy operations */
    register int	   firstByte;	     /* Offset into request buffer */
    register int	   lastByte;	     /* Offset into request buffer */
    int			   room;	     /* Room available in req. buf.*/
    int			   savedLastByte;    /* For error recovery */
    int			   savedFirstByte;   /*   ditto */

    if (ioReplyPtr != (Fs_IOReply *) NIL) {
	ioReplyPtr->length = 0;
    }

    if ((pdevHandlePtr == (Fspdev_ServerIOHandle *)NIL) ||
	(pdevHandlePtr->flags & PDEV_SERVER_GONE)) {
	return(DEV_OFFLINE);
    } else if ((pdevHandlePtr->flags & PDEV_SETUP) == 0) {
	panic( "RequestResponse: connection not set up\n");
    }
    /*
     * See if we have to switch to a new request buffer.  This is needed
     * to support UDP, which wants to set a maximum write size.  The max
     * is implemented by letting the UDP server change the buffer size and
     * setting the property that writes larger than the buffer fail.  We
     * wait and switch after the request buffer empties.
     */
    firstByte = pdevHandlePtr->requestBuf.firstByte;
    lastByte = pdevHandlePtr->requestBuf.lastByte;
    if ((pdevHandlePtr->nextRequestBuffer != (Address)NIL) &&
	((firstByte > lastByte) || (firstByte == -1))) {
#ifndef CLEAN
	printf( "Switching to request buffer at 0x%x\n",
			       pdevHandlePtr->nextRequestBuffer);
#endif
	pdevHandlePtr->requestBuf.data = pdevHandlePtr->nextRequestBuffer;
	pdevHandlePtr->requestBuf.size = pdevHandlePtr->nextRequestBufSize;
	pdevHandlePtr->nextRequestBuffer = (Address)NIL;
	firstByte = -1;
    }
    /*
     * FORMAT THE REQUEST HEADER.  Note that the complete message size is
     * rounded up so subsequent messages start on word boundaries.
     */
    if (hdrSize == sizeof(Pdev_Request)) {
	requestHdrPtr->magic = PDEV_REQUEST_MAGIC;
    } else if (hdrSize == sizeof(Pfs_Request)) {
	requestHdrPtr->magic = PFS_REQUEST_MAGIC;
    } else {
	panic( "RequestResponse: bad hdr size\n");
    }
    requestHdrPtr->requestSize = inputSize;
    requestHdrPtr->replySize = replySize;
    requestHdrPtr->messageSize = hdrSize +
		((inputSize + sizeof(int) - 1) / sizeof(int)) * sizeof(int);
    if (pdevHandlePtr->requestBuf.size < requestHdrPtr->messageSize) {
	printf("RequestResponse: request too large (%d > %d)\n",
	    requestHdrPtr->messageSize, pdevHandlePtr->requestBuf.size);
	return(GEN_INVALID_ARG);
    }

    PDEV_REQUEST_PRINT(&pdevHandlePtr->hdr.fileID, requestHdrPtr);
    PDEV_REQUEST(&pdevHandlePtr->hdr.fileID, requestHdrPtr);

    /*
     * PUT THE REQUEST INTO THE REQUEST BUFFER.
     * We assume that our caller will not give us a request that can't all
     * fit into the buffer.  However, if the buffer is not empty enough we
     * wait for the server to catch up with us.  (Things could be optimized
     * perhaps to wait for just enough room.  To be real clever you have
     * to be careful when you reset the firstByte so that the server only
     * notices after it has caught up with everything at the end of the
     * buffer.  To keep things simple we just wait for the server to catch up
     * completely if we can't fit this request in.)
     */

    savedFirstByte = firstByte;
    savedLastByte = lastByte;
    if (firstByte > lastByte || firstByte == -1) {
	/*
	 * Buffer has emptied.
	 */
	firstByte = 0;
	pdevHandlePtr->requestBuf.firstByte = firstByte;
	lastByte = requestHdrPtr->messageSize - 1;
    } else {
	room = pdevHandlePtr->requestBuf.size - (lastByte + 1);
	if (room < requestHdrPtr->messageSize) {
	    /*
	     * There is no room left at the end of the buffer.
	     * We wait and then put the request at the beginning.
	     */
	    while (pdevHandlePtr->requestBuf.firstByte <
		   pdevHandlePtr->requestBuf.lastByte) {
		DBG_PRINT( (" (catch up) ") );
		if (Sync_Wait(&pdevHandlePtr->caughtUp, TRUE)) {
		    status = GEN_ABORTED_BY_SIGNAL;
		    goto failure;
		} else if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
		    status = DEV_OFFLINE;
		    goto failure;
		}
	    }
	    savedFirstByte = -1;
	    firstByte = 0;
	    pdevHandlePtr->requestBuf.firstByte = firstByte;
	    lastByte = requestHdrPtr->messageSize - 1;
	} else {
	    /*
	     * Append the message to the other requests.
	     */
	    firstByte = lastByte + 1;
	    lastByte += requestHdrPtr->messageSize;
	}
    }
    pdevHandlePtr->requestBuf.lastByte = lastByte;
    DBG_PRINT( (" first %d last %d\n", firstByte, lastByte) );
    pdevHandlePtr->operation = requestHdrPtr->operation;
    if (pdevHandlePtr->operation == PFS_OPEN) {
	/*
	 * We have to snarf up the hostID of the client doing the open
	 * so the new pseudo-device connection that may be set up as
	 * a side effect of PFS_OPEN is set up right.  The useFlags are
	 * needed to initialize the new client stream right.
	 */
	register Pfs_Request *pfsRequestPtr = (Pfs_Request *)requestHdrPtr;
	pdevHandlePtr->open.clientID = pfsRequestPtr->param.open.clientID;
	pdevHandlePtr->open.useFlags = pfsRequestPtr->param.open.useFlags;
	pdevHandlePtr->open.name = (char *)inputBuf;
    }

    /*
     * COPY REQUEST AND DATA.
     * Copy the request and data out into the server's request buffer.
     * We map to a proc table pointer for the server which has a side
     * effect of locking down the server process so it can't disappear.
     */

    serverProcPtr = Proc_LockPID(pdevHandlePtr->serverPID);
    if (serverProcPtr == (Proc_ControlBlock *)NIL) {
	status = DEV_OFFLINE;
	goto failure;
    }
    status = Vm_CopyOutProc(hdrSize, (Address)requestHdrPtr, TRUE,
			    serverProcPtr, (Address)
			    &pdevHandlePtr->requestBuf.data[firstByte]);
    if (status == SUCCESS) {
	firstByte += hdrSize;
	if (inputSize > 0) {
	    status = Vm_CopyOutProc(inputSize, inputBuf, 
			(pdevHandlePtr->flags & FS_USER_IN) == 0, serverProcPtr,
			(Address)&pdevHandlePtr->requestBuf.data[firstByte]);
	}
    }
    Proc_Unlock(serverProcPtr);
    if (status != SUCCESS) {
	/*
	 * Either the message header or data couldn't get copied out.
	 * Reset the buffer pointers so the bad request isn't seen.
	 */
	pdevHandlePtr->requestBuf.firstByte = savedFirstByte;
	pdevHandlePtr->requestBuf.lastByte = savedLastByte;
	goto failure;
    }

    /*
     * POKE THE SERVER so it can read the new pointer values.
     * This is done here even if write-behind is enabled, even though our
     * scheduler tends to wake up the server too soon.
     * Although it is possible to put a notify in about 3 other places
     * to catch cases where the client does a write-behind and then waits,
     * not all clients are clever enough to use select.  That solution results
     * in cases where a write can linger a long time in the request buffer.
     * (cat /dev/syslog in a tx window is a good test case.)
     */
    Fsutil_FastWaitListNotify(&pdevHandlePtr->srvReadWaitList);

    if (pdevHandlePtr->operation != PDEV_WRITE_ASYNC) {
	/*
	 * WAIT FOR A REPLY.
	 * We save the client's reply buffer address and processID in the
	 * stream state so the kernel can copy the reply directly from
	 * the server's address space to the client's when the server
	 * makes the IOC_PDEV_REPLY IOControl.
	 */

	pdevHandlePtr->replyBuf = replyBuf;
	pdevHandlePtr->replySize = replySize;
	pdevHandlePtr->clientPID = (Proc_GetEffectiveProc())->processID;
	if (waitPtr != (Sync_RemoteWaiter *)NIL) {
	    pdevHandlePtr->clientWait = *waitPtr;
	}
	pdevHandlePtr->flags &= ~PDEV_REPLY_READY;
	while ((pdevHandlePtr->flags & PDEV_REPLY_READY) == 0) {
	    if (Sync_Wait(&pdevHandlePtr->replyReady, TRUE)) {
		if ((pdevHandlePtr->flags & PDEV_REPLY_READY) == 0) {
		    /*
		     * Client aborted before the server completed the request.
		     */
		    pdevHandlePtr->flags |= PDEV_REQUEST_ABORTED;
		}
		status = GEN_ABORTED_BY_SIGNAL;
		goto failure;
	    } else if (pdevHandlePtr->flags &
			(PDEV_REPLY_FAILED|PDEV_SERVER_GONE)) {
		status = DEV_OFFLINE;
		goto failure;
	    }
	}
	if (ioReplyPtr != (Fs_IOReply *) NIL) {
	    ioReplyPtr->length = pdevHandlePtr->reply.replySize;
	    ioReplyPtr->signal = pdevHandlePtr->reply.signal;
	    ioReplyPtr->code = pdevHandlePtr->reply.code;
	}
    } else {
	pdevHandlePtr->reply.status = SUCCESS;
    }
failure:
    pdevHandlePtr->replyBuf = (char *)NIL;
    pdevHandlePtr->replySize = 0;
    if (status == SUCCESS) {
	status = pdevHandlePtr->reply.status;
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevServerStreamCreate --
 *
 *	Set up the stream state for a server's private channel to a client.
 *	This creates a Fspdev_ServerIOHandle that has all the state for the
 *	connection to the client.
 *
 * Results:
 *	A pointer to the I/O handle created.  The handle is locked.
 *	NIL is returned if a handle under the fileID already existed.
 *
 * Side effects:
 *	The I/O handle for this connection between a client and the server
 *	is installed and initialized.
 *
 *----------------------------------------------------------------------
 */

Fspdev_ServerIOHandle *
FspdevServerStreamCreate(ioFileIDPtr, name, naming)
    Fs_FileID	*ioFileIDPtr;	/* File ID used for pseudo stream handle */
    char	*name;		/* File name for error messages */
    Boolean	naming;		/* True if this is a naming stream for a pfs */
{
    Fs_HandleHeader *hdrPtr;
    register Fspdev_ServerIOHandle *pdevHandlePtr;
    Boolean found;

    ioFileIDPtr->type = FSIO_SERVER_STREAM;
    found = Fsutil_HandleInstall(ioFileIDPtr, sizeof(Fspdev_ServerIOHandle), name,
			    FALSE, &hdrPtr);
    pdevHandlePtr = (Fspdev_ServerIOHandle *)hdrPtr;
    if (found) {
	printf("ServerStreamCreate, found handle <%x,%x,%x>\n",
		  hdrPtr->fileID.serverID, hdrPtr->fileID.major,
		  hdrPtr->fileID.minor);
	Fsutil_HandleRelease(pdevHandlePtr, TRUE);
	return((Fspdev_ServerIOHandle *)NIL);
    }
    fs_Stats.object.pseudoStreams++;

    DBG_PRINT( ("ServerStreamOpen <%d,%x,%x>\n",
	    ioFileIDPtr->serverID, ioFileIDPtr->major, ioFileIDPtr->minor) );

    /*
     * Initialize the state for the pseudo stream.  Remember that
     * the request and read ahead buffers for the pseudo-stream are set up
     * via IOControls by the server process later.  In the meantime we
     * pretend the connection is busy to lock out requests.
     */

    Sync_LockInitDynamic(&pdevHandlePtr->lock, "Fs:pdevLock");
    pdevHandlePtr->flags = PDEV_BUSY;
    if (naming) {
	pdevHandlePtr->flags |= PDEV_NAMING;
    }
    pdevHandlePtr->selectBits = 0;
    pdevHandlePtr->serverPID = (Proc_PID)NIL;
    pdevHandlePtr->clientPID = (Proc_PID)NIL;

    pdevHandlePtr->requestBuf.data = (Address)NIL;
    pdevHandlePtr->requestBuf.firstByte = -1;
    pdevHandlePtr->requestBuf.lastByte = -1;
    pdevHandlePtr->requestBuf.size = 0;

    pdevHandlePtr->nextRequestBuffer = (Address)NIL;

    pdevHandlePtr->readBuf.data = (Address)NIL;
    pdevHandlePtr->readBuf.firstByte = -1;
    pdevHandlePtr->readBuf.lastByte = -1;
    pdevHandlePtr->readBuf.size = 0;

    pdevHandlePtr->operation = 0;
    pdevHandlePtr->reply.status = NIL;
    pdevHandlePtr->reply.replySize = 0;
    pdevHandlePtr->replyBuf = (Address)NIL;

    pdevHandlePtr->setup.waiting = 0;
    pdevHandlePtr->access.waiting = 0;
    pdevHandlePtr->caughtUp.waiting = 0;
    pdevHandlePtr->replyReady.waiting = 0;

    List_Init(&pdevHandlePtr->srvReadWaitList);

    pdevHandlePtr->clientWait.pid = NIL;
    pdevHandlePtr->clientWait.hostID = NIL;
    pdevHandlePtr->clientWait.waitToken = NIL;

    List_Init(&pdevHandlePtr->cltReadWaitList);
    List_Init(&pdevHandlePtr->cltWriteWaitList);
    List_Init(&pdevHandlePtr->cltExceptWaitList);

    pdevHandlePtr->ctrlHandlePtr = (Fspdev_ControlIOHandle *)NIL;

    pdevHandlePtr->userLevelID = *ioFileIDPtr;
    pdevHandlePtr->open.clientID = NIL;
    pdevHandlePtr->open.useFlags = 0;
    pdevHandlePtr->open.name = (char *)NIL;

    return(pdevHandlePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevServerStreamSelect --
 *
 *	Select a server's request/response stream.  This returns
 *	FS_READABLE in the outFlags if there is data in the
 *	server's request buffer.  The next read on the server stream
 *	will return the current pointers into the buffer.
 *
 * Results:
 *	SUCCESS
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
FspdevServerStreamSelect(hdrPtr, waitPtr, readPtr, writePtr, exceptPtr)
    Fs_HandleHeader	*hdrPtr;	/* Handle on device to select */
    Sync_RemoteWaiter	*waitPtr;	/* Process info for remote waiting */
    int 		*readPtr;	/* Bit to clear if non-readable */
    int 		*writePtr;	/* Bit to clear if non-writeable */
    int 		*exceptPtr;	/* Bit to clear if non-exceptable */
{
    register Fspdev_ServerIOHandle	*pdevHandlePtr = (Fspdev_ServerIOHandle *)hdrPtr;

    LOCK_MONITOR;
    if (*readPtr) {
	if (((pdevHandlePtr->flags & PDEV_READ_PTRS_CHANGED) == 0) &&
	     ((pdevHandlePtr->requestBuf.firstByte == -1) ||
	      (pdevHandlePtr->requestBuf.firstByte >=
		  pdevHandlePtr->requestBuf.lastByte))) {
	    *readPtr = 0;
	    if (waitPtr != (Sync_RemoteWaiter *)NIL) {
		Fsutil_FastWaitListInsert(&pdevHandlePtr->srvReadWaitList, waitPtr);
	    }
	}
    }
    *writePtr = 0;
    *exceptPtr = 0;
    UNLOCK_MONITOR;
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevServerStreamRead --
 *
 *	When the server reads on a server stream it is looking for a
 *	message containing pointers into the request buffer that's
 *	in its address spapce.  This routine returns those values.
 *
 * Results:
 *	SUCCESS unless all clients have gone away.
 *
 * Side effects:
 *	The buffer is filled a Pdev_BufPtrs structure.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevServerStreamRead(streamPtr, readPtr, waitPtr, replyPtr)
    register Fs_Stream 	*streamPtr;	/* Stream to read from. */
    Fs_IOParam		*readPtr;	/* Read parameter block. */
    Sync_RemoteWaiter	*waitPtr;	/* Process info for remote waiting */
    Fs_IOReply		*replyPtr;	/* Signal to return, if any,
					 * plus the amount read. */
{
    register Fspdev_ServerIOHandle *pdevHandlePtr =
	    (Fspdev_ServerIOHandle *)streamPtr->ioHandlePtr;
    register ReturnStatus status;
    Pdev_BufPtrs bufPtrs;
    register int reqFirstByte, reqLastByte;

    LOCK_MONITOR;
    /*
     * The server stream is readable only if there are requests in the
     * request buffer or if the read ahead buffers have changed since
     * the last time the server did a read.
     */
    reqFirstByte = pdevHandlePtr->requestBuf.firstByte;
    reqLastByte = pdevHandlePtr->requestBuf.lastByte;
    if (reqFirstByte > pdevHandlePtr->requestBuf.size ||
	reqLastByte > pdevHandlePtr->requestBuf.size) {
	panic("PdevServerRead, pointers inconsistent\n");
	UNLOCK_MONITOR;
	return(GEN_INVALID_ARG);
    }
    if (((pdevHandlePtr->flags & PDEV_READ_PTRS_CHANGED) == 0) &&
	((reqFirstByte == -1) || (reqFirstByte > reqLastByte))) {
	status = FS_WOULD_BLOCK;
	replyPtr->length = 0;
	Fsutil_FastWaitListInsert(&pdevHandlePtr->srvReadWaitList, waitPtr);
    } else {
	/*
	 * Copy the current pointers out to the server.  We include the
	 * server's address of the request buffer to support changing
	 * the request buffer after requests have started to flow.
	 */
	bufPtrs.magic = PDEV_BUF_PTR_MAGIC;
	bufPtrs.requestAddr = pdevHandlePtr->requestBuf.data;
	if ((reqFirstByte == -1) || (reqFirstByte > reqLastByte)) {
	    /*
	     * Request buffer is empty.
	     */
	    bufPtrs.requestFirstByte = -1;
	    bufPtrs.requestLastByte = -1;
	} else {
	    bufPtrs.requestFirstByte = reqFirstByte;
	    bufPtrs.requestLastByte = reqLastByte;
	}

	/*
	 * The read ahead buffer is filled by the server until there is
	 * no room left.  Only after the kernel has emptied the
	 * read ahead buffer will the server start filling it again.
	 * We use the PDEV_SERVER_KNOWS_IT state bit to know when to
	 * expect new pointer values after the buffer empties.
	 */
	if (pdevHandlePtr->flags & PDEV_READ_BUF_EMPTY) {
	    bufPtrs.readLastByte = -1;
	    bufPtrs.readFirstByte = -1;
	    pdevHandlePtr->flags |= PDEV_SERVER_KNOWS_IT;
	} else {
	    bufPtrs.readFirstByte = pdevHandlePtr->readBuf.firstByte;
	    bufPtrs.readLastByte = pdevHandlePtr->readBuf.lastByte;
	}
	pdevHandlePtr->flags &= ~PDEV_READ_PTRS_CHANGED;
	status = Vm_CopyOut(sizeof(Pdev_BufPtrs), (Address)&bufPtrs,
			    readPtr->buffer);
	replyPtr->length = sizeof(Pdev_BufPtrs);
	DBG_PRINT( ("READ %x,%x req %d:%d read %d:%d\n",
		pdevHandlePtr->hdr.fileID.major,
		pdevHandlePtr->hdr.fileID.minor,
		pdevHandlePtr->requestBuf.firstByte,
		pdevHandlePtr->requestBuf.lastByte,
		pdevHandlePtr->readBuf.firstByte,
		pdevHandlePtr->readBuf.lastByte) );
    }
    UNLOCK_MONITOR;
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevServerStreamIOControl --
 *
 *	IOControls for the server's stream.  The server process uses this
 *	to manipulate the request and read ahead buffers in its address
 *	space.  It delcares them, and queries and sets pointers into them.
 *	The server also replies to requests here, and notifies the kernel
 *	when the pseudo-device is selectable.
 *
 * Results:
 *	SUCCESS if all went well, otherwise a status from a Vm operation
 *	or a consistency check.
 *
 * Side effects:
 *	This is the main entry point for the server process to control
 *	the pseudo-device connection to its clients.  The side effects
 *	depend on the I/O control.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ENTRY ReturnStatus
FspdevServerStreamIOControl(streamPtr, ioctlPtr, replyPtr)
    Fs_Stream	*streamPtr;	/* Stream to server handle. */
    Fs_IOCParam *ioctlPtr;	/* Standard I/O Control parameter block */
    Fs_IOReply *replyPtr;	/* Output buffer length and signal to return */
{
    ReturnStatus	status = SUCCESS;
    register Fspdev_ServerIOHandle	*pdevHandlePtr =
	    (Fspdev_ServerIOHandle *)streamPtr->ioHandlePtr;

    LOCK_MONITOR;

    if (ioctlPtr->format != mach_Format) {
	panic("FsServerStreamIOControl: wrong format\n");
    }
    switch (ioctlPtr->command) {
	case IOC_PDEV_SET_BUF: {
	    /*
	     * The server is declaring the buffer space used for requests
	     * and (optionally) for read ahead.
	     * To support UDP socket semantics, we let the server change
	     * the request buffer after things have already started up.
	     * (This is sort of a pain, as we have to let the current
	     * request buffer empty before switching.)
	     *
	     * Side effects:
	     *		Set the request, and optionally the read-ahead,
	     *		buffer pointers.  The setup condition is notified
	     *		to let the client's open transaction begin.
	     */
	    register Pdev_SetBufArgs *argPtr =
		    (Pdev_SetBufArgs *)ioctlPtr->inBuffer;
	    register int extraBytes;

	    if (ioctlPtr->inBufSize != sizeof(Pdev_SetBufArgs)) {
		status = GEN_INVALID_ARG;
	    } else if ((pdevHandlePtr->flags & PDEV_SETUP) == 0) {
		/*
		 * Normal case, first time initialization.  Make sure the
		 * buffers are word aligned.
		 */
		pdevHandlePtr->requestBuf.size = argPtr->requestBufSize;
		pdevHandlePtr->requestBuf.data = argPtr->requestBufAddr;
		extraBytes = (unsigned int)argPtr->requestBufAddr &
			     (sizeof(int) - 1);
		if (extraBytes) {
		    pdevHandlePtr->requestBuf.data += sizeof(int) - extraBytes;
		    pdevHandlePtr->requestBuf.size -= extraBytes;
		}
		pdevHandlePtr->requestBuf.firstByte = -1;
		pdevHandlePtr->requestBuf.lastByte = -1;

		if (argPtr->readBufAddr == (Address)NIL ||
		    argPtr->readBufAddr == (Address)0) {
		    pdevHandlePtr->readBuf.data = (Address)NIL;
		    pdevHandlePtr->readBuf.size = 0;
		} else {
		    pdevHandlePtr->readBuf.size = argPtr->readBufSize;
		    pdevHandlePtr->readBuf.data = argPtr->readBufAddr;
		    extraBytes = (unsigned int)argPtr->readBufAddr &
				 (sizeof(int) - 1);
		    if (extraBytes) {
			pdevHandlePtr->readBuf.data += sizeof(int) - extraBytes;
			pdevHandlePtr->readBuf.size -= extraBytes;
		    }
		}
		pdevHandlePtr->readBuf.firstByte = -1;
		pdevHandlePtr->readBuf.lastByte = -1;

		pdevHandlePtr->serverPID = ioctlPtr->procID;

		/*
		 * The state has been marked BUSY to simplify waiting in the
		 * routines that call RequestResponse, so we clear that bit.
		 */
		pdevHandlePtr->flags &= ~PDEV_BUSY;
		pdevHandlePtr->flags |= PDEV_SETUP|PDEV_READ_BUF_EMPTY|
						 PDEV_SERVER_KNOWS_IT;
		Sync_Broadcast(&pdevHandlePtr->access);
	    } else {
		/*
		 * The server is changing request buffers.  We just remember
		 * the new buffer address and size here, and switch over
		 * in RequestResponse after the current request buffer empties.
		 */
		pdevHandlePtr->nextRequestBuffer = argPtr->requestBufAddr;
		pdevHandlePtr->nextRequestBufSize = argPtr->requestBufSize;
		if (pdevHandlePtr->nextRequestBuffer == (Address)0) {
		    pdevHandlePtr->nextRequestBuffer = (Address)NIL;
		}
	    }
	    break;
	}
	case IOC_PDEV_WRITE_BEHIND: {
	    /*
	     * Side effects:
	     *		Set/unset write-behind buffering in the request buffer.
	     */
	    register Boolean writeBehind;
	    if (ioctlPtr->inBufSize < sizeof(Boolean)) {
		status = GEN_INVALID_ARG;
	    } else {
		writeBehind = *(Boolean *)ioctlPtr->inBuffer;
		if (writeBehind) {
		    pdevHandlePtr->flags |= PDEV_WRITE_BEHIND;
		} else {
		    pdevHandlePtr->flags &= ~PDEV_WRITE_BEHIND;
		}
	    }
	    break;
	}
	case IOC_PDEV_BIG_WRITES: {
	    /*
	     * Side effects:
	     *		Set/unset the client's ability to make large writes.
	     */
	    register Boolean allowLargeWrites;
	    if (ioctlPtr->inBufSize < sizeof(Boolean)) {
		status = GEN_INVALID_ARG;
	    } else {
		allowLargeWrites = *(Boolean *)ioctlPtr->inBuffer;
		if (allowLargeWrites) {
		    pdevHandlePtr->flags &= ~PDEV_NO_BIG_WRITES;
		} else {
		    pdevHandlePtr->flags |= PDEV_NO_BIG_WRITES;
		}
	    }
	    break;
	}
	case IOC_PDEV_SET_PTRS: {
	    /*
	     * The server is telling us about new pointer values.  We only
	     * pay attention to the requestFirstByte and readLastByte as
	     * it is our job to modify the other pointers.
	     *
	     * Side effects:
	     *		Set requestBuf.firstByte and readBuf.lastByte if
	     *		the server gives us new values (not equal -1).
	     *		We notify waiting clients if the server has
	     *		added read-ahead data.
	     */
	    register Pdev_BufPtrs *argPtr = (Pdev_BufPtrs *)ioctlPtr->inBuffer;
	    if (ioctlPtr->inBufSize != sizeof(Pdev_BufPtrs)) {
		status = GEN_INVALID_ARG;
	    } else {
		/*
		 * Verify the request buffer pointer.  The server may just
		 * be telling us about read ahead data, in which case we
		 * shouldn't muck with the request pointers. Otherwise we
		 * update the request first byte to reflect the processing
		 * of some requests by the server.
		 */
		DBG_PRINT( ("SET  %x,%x req %d:%d read %d:%d\n",
		    pdevHandlePtr->hdr.fileID.major,
		    pdevHandlePtr->hdr.fileID.minor,
		    argPtr->requestFirstByte, argPtr->requestLastByte,
		    argPtr->readFirstByte, argPtr->readLastByte) );
		if (argPtr->requestFirstByte <=
		            pdevHandlePtr->requestBuf.size &&
		    argPtr->requestFirstByte >= 0) {
		    pdevHandlePtr->requestBuf.firstByte =
			   argPtr->requestFirstByte;
		}
		Sync_Broadcast(&pdevHandlePtr->caughtUp);
	        if ((pdevHandlePtr->readBuf.data == (Address)NIL) ||
		    (argPtr->readLastByte < 0)) {
		    /*
		     * No read ahead info.
		     */
		    break;
		}
		if (argPtr->readLastByte > pdevHandlePtr->readBuf.size) {
		    printf("FspdevServerStreamIOControl: set bad readPtr\n");
		    status = GEN_INVALID_ARG;
		    break;
		}
		if ((pdevHandlePtr->flags & PDEV_READ_BUF_EMPTY) == 0) {
		    /*
		     * Non-empty buffer.  Break out if bad pointer, else
		     * fall through to code that updates the pointer.
		     */
		    if (argPtr->readLastByte <=
			pdevHandlePtr->readBuf.lastByte) {
			    break;	/* No new read ahead data */
		    }
		} else if (pdevHandlePtr->flags & PDEV_SERVER_KNOWS_IT) {
		    /*
		     * Empty buffer and the server already knows this.
		     * We can safely reset firstByte to the beginning.
		     * The server should rely on this behavior.
		     */
		    if (argPtr->readLastByte >= 0) {
			pdevHandlePtr->flags &= ~(PDEV_READ_BUF_EMPTY|
						 PDEV_SERVER_KNOWS_IT);
			pdevHandlePtr->readBuf.firstByte = 0;
		    } else {
			break;	/* No new read ahead data */
		    }
		} else {
		    /*
		     * We emptied the buffer, but the server added data
		     * before seeing it was empty.  Can't reset firstByte.
		     */
		    if (argPtr->readLastByte > 
			    pdevHandlePtr->readBuf.lastByte) {
			pdevHandlePtr->flags &= ~PDEV_READ_BUF_EMPTY;
		    } else {
			break;	/* No new read ahead data */
		    }
		}
		/*
		 * We know here that the lastByte pointer indicates
		 * more data.  Otherwise we've broken out.
		 * Update select state and poke waiting readers.
		 */
		pdevHandlePtr->readBuf.lastByte = argPtr->readLastByte;
		pdevHandlePtr->selectBits |= FS_READABLE;
		Fsutil_FastWaitListNotify(&pdevHandlePtr->cltReadWaitList);
	    }
	    break;
	}
	case IOC_PDEV_SMALL_REPLY:
	case IOC_PDEV_REPLY: {
	    /*
	     * The server is replying to a request.
	     *
	     * Side effects:
	     *		Copy the reply from the server to the client.
	     *		Put the client on wait lists, if appropriate.
	     *		Notify the replyReady condition, and lastly
	     *		notify waiting clients about new select state.
	     */
	    register Pdev_Reply *srvReplyPtr = (Pdev_Reply *)ioctlPtr->inBuffer;

	    if (ioctlPtr->inBufSize < sizeof(Pdev_Reply)) {
		/*
		 * inBuffer must be at least as big as Pdev_Reply.
		 * It will be larger during PDEV_SMALL_REPLY which
		 * includes a small amount of embedded data.
		 */
		status = FS_INVALID_ARG;
		pdevHandlePtr->flags |= PDEV_REPLY_READY|PDEV_REPLY_FAILED;
	    } else if (pdevHandlePtr->flags & PDEV_REQUEST_ABORTED) {
		/*
		 * Client aborted the request from its end.
		 * Do nothing but grab the select bits.
		 */
		pdevHandlePtr->flags &= ~PDEV_REQUEST_ABORTED;
		pdevHandlePtr->selectBits = srvReplyPtr->selectBits;
	    } else {
		/*
		 * Copy current reply in to pdev state.
		 */
		pdevHandlePtr->reply = *srvReplyPtr;
		if (srvReplyPtr->replySize > 0) {
		    register Proc_ControlBlock *clientProcPtr;
		    if (pdevHandlePtr->replyBuf == (char *)NIL) {
			printf("PdevReply: unwanted reply data <%s>\n",
			    Fsutil_HandleName(pdevHandlePtr));
			goto noReplyData;
		    }
		    if (srvReplyPtr->replySize > pdevHandlePtr->replySize) {
			printf("PdevReply: extra reply data (%d > %d) <%s>\n",
			    srvReplyPtr->replySize, pdevHandlePtr->replySize,
			    Fsutil_HandleName(pdevHandlePtr));
			srvReplyPtr->replySize = pdevHandlePtr->replySize;
		    }
		    /*
		     * Copy the reply into the waiting buffers.
		     */
		    if ((ioctlPtr->command == IOC_PDEV_SMALL_REPLY) &&
			((srvReplyPtr->replySize > PDEV_SMALL_DATA_LIMIT) ||
			 (ioctlPtr->inBufSize <
				 sizeof(Pdev_Reply) + srvReplyPtr->replySize))){
			status = GEN_INVALID_ARG;
		    } else {
			if ((pdevHandlePtr->flags & FS_USER_OUT) == 0) {
			    /*
			     * Reply buffer in the kernel.
			     */
			    if (ioctlPtr->command == IOC_PDEV_SMALL_REPLY) {
				bcopy(((Pdev_ReplyData *)srvReplyPtr)->data,
					pdevHandlePtr->replyBuf,
					srvReplyPtr->replySize);
			    } else {
				status = Vm_CopyIn(srvReplyPtr->replySize,
						   srvReplyPtr->replyBuf,
						   pdevHandlePtr->replyBuf);
			    }
			} else {
			    clientProcPtr = Proc_LockPID(pdevHandlePtr->clientPID);
			    /*
			     * Reply buffer in the client's address space.
			     * Do a cross-address-space copy.
			     */
			    if (clientProcPtr == (Proc_ControlBlock *)NIL) {
				status = FS_BROKEN_PIPE;
			    } else {
				if (ioctlPtr->command == IOC_PDEV_SMALL_REPLY) {
				    status =
					Vm_CopyOutProc(srvReplyPtr->replySize,
					((Pdev_ReplyData *)srvReplyPtr)->data,
					TRUE, clientProcPtr,
					pdevHandlePtr->replyBuf);
				} else {
				    status =
					Vm_CopyOutProc(srvReplyPtr->replySize,
					srvReplyPtr->replyBuf, FALSE,
					clientProcPtr, pdevHandlePtr->replyBuf);
				}
				Proc_Unlock(clientProcPtr);
			    }
			}
		    }
		    if (status != SUCCESS) {
			pdevHandlePtr->flags |= PDEV_REPLY_FAILED;
		    }
		}
noReplyData:
		PDEV_REPLY(&pdevHandlePtr->hdr.fileID, srvReplyPtr);
		if (srvReplyPtr->status == FS_WOULD_BLOCK) {
		    /*
		     * Put the client process on the appropriate wait list.
		     */
		    if (pdevHandlePtr->operation == PDEV_READ) {
			Fsutil_FastWaitListInsert(&pdevHandlePtr->cltReadWaitList,
					     &pdevHandlePtr->clientWait);
		    } else if (pdevHandlePtr->operation == PDEV_WRITE) {
			Fsutil_FastWaitListInsert(&pdevHandlePtr->cltWriteWaitList,
					     &pdevHandlePtr->clientWait);
		    }
		}
		pdevHandlePtr->flags |= PDEV_REPLY_READY;
		pdevHandlePtr->selectBits = srvReplyPtr->selectBits;
	    }
	    Sync_Broadcast(&pdevHandlePtr->replyReady);
	    PdevClientNotify(pdevHandlePtr);
	    break;
	}
	case IOC_PDEV_READY:
	    /*
	     * Master has made the device ready.  The inBuffer contains
	     * new select bits.
	     *
	     * Side effects:
	     *		Notify waiting clients.
	     */

	    if (ioctlPtr->inBufSize != sizeof(int)) {
		status = FS_INVALID_ARG;
	    } else {
		/*
		 * Update the select state of the pseudo-device and
		 * wake up any clients waiting on their pseudo-stream.
		 */
		pdevHandlePtr->selectBits = *(int *)ioctlPtr->inBuffer;
		PdevClientNotify(pdevHandlePtr);
	    }
	    break;
	case IOC_PDEV_SIGNAL_OWNER: {
	    /*
	     * The server wants to signal the process (group) that owns
	     * the device.  This is used, for example, to implement processing
	     * of interrupt characters by the TTY driver.
	     */
	    status = FspdevSignalOwner(pdevHandlePtr->ctrlHandlePtr, ioctlPtr);
	    break;
	}
	case IOC_PFS_OPEN: {
	    /*
	     * A pseudo-filesystem server is replying to an open request by
	     * asking us to open a pseudo-device connection to the client.
	     * It gives us a Fs_FileID for its own identification of the
	     * connection.  The connection is set up here. A user-level
	     * streamID is generated for the server process and returned.
	     * To finish up, we set up the Fs_OpenResults that the waiting
	     * client has to RequestResponse.  This includes a fileID so
	     * the client process can fetch its half of the connection.
	     */
	    int newStreamID;			/* For the server */
	    Fs_OpenResults openResults;		/* For the client */

	    if (ioctlPtr->inBufSize < sizeof(Fs_FileID) ||
		ioctlPtr->outBufSize < sizeof(int)) {
		status = GEN_INVALID_ARG;
	    } else if (pdevHandlePtr->flags & PDEV_REQUEST_ABORTED) {
		pdevHandlePtr->flags &= ~PDEV_REQUEST_ABORTED;
		PdevClientNotify(pdevHandlePtr);
		break;
	    } else {
		newStreamID = FspdevPfsOpenConnection(pdevHandlePtr,
			    (Fs_FileID *)ioctlPtr->inBuffer, &openResults);
		if (ioctlPtr->flags & FS_USER_OUT) {
		    Vm_CopyOut(sizeof(int), (Address)&newStreamID,
				ioctlPtr->outBuffer);
		} else {
		    *(int *)ioctlPtr->outBuffer = newStreamID;
		}
		if (newStreamID < 0) {
		    status = FAILURE;
		} else {
		    /*
		     * Here we copy the openResults to the waiting processes
		     * kernel stack (it's waiting in FspdevPfsOpen on this
		     * same host.)
		     */
		    register Fs_OpenResults *openResultsPtr =
			    (Fs_OpenResults *)pdevHandlePtr->replyBuf;
		    *openResultsPtr = openResults;
		}
	    }
	    if (status != SUCCESS) {
		pdevHandlePtr->flags |= PDEV_REPLY_FAILED;
		pdevHandlePtr->reply.replySize = 0;
	    } else {
		pdevHandlePtr->reply.replySize = sizeof(Fs_OpenResults);
	    }
	    pdevHandlePtr->reply.status = status;
	    pdevHandlePtr->flags |= PDEV_REPLY_READY;
	    Sync_Broadcast(&pdevHandlePtr->replyReady);
	    PdevClientNotify(pdevHandlePtr);
	    break;
	}
	case IOC_PFS_SET_ID: {
	    /*
	     * A pseudo-filesystem server is setting its own notion of the
	     * fileID associated with a request-response stream.
	     */
	    register Fs_FileID *fileIDPtr;

	    if (ioctlPtr->inBufSize < sizeof(Fs_FileID)) {
		status = FS_INVALID_ARG;
	    } else {
		fileIDPtr = (Fs_FileID *)ioctlPtr->inBuffer;
		pdevHandlePtr->userLevelID = *fileIDPtr;
	    }
	    break;
	}
	case IOC_PFS_PASS_STREAM: {
	    /*
	     * A pseudo-filesystem server is replying to an open request by
	     * asking us to pass one of its open streams to the client.
	     */
	    register int passedStreamID;	/* From the server */
	    Fs_OpenResults openResults;		/* For the client */
	    Address encapStream;		/* packaged stream */
	    int encapSize;			/* size of package */
	    register Proc_ControlBlock *procPtr;
	    register Fs_OpenResults *openResultsPtr;

	    if (ioctlPtr->inBufSize < sizeof(int)) {
		status = GEN_INVALID_ARG;
	    } else if (pdevHandlePtr->flags & PDEV_REQUEST_ABORTED) {
		pdevHandlePtr->flags &= ~PDEV_REQUEST_ABORTED;
		PdevClientNotify(pdevHandlePtr);
		break;
	    } else {
		passedStreamID = *(int *)ioctlPtr->inBuffer;
		procPtr = Proc_GetEffectiveProc();
		status = Fs_GetStreamPtr(procPtr, passedStreamID, &streamPtr);
		if (status == SUCCESS) {
		    encapSize = Fs_GetEncapSize();
		    encapStream = (Address)malloc(encapSize);
		    status = Fsio_EncapStream(streamPtr, encapStream);
		    if (status == SUCCESS) {
			/*
			 * Set up open results so Fs_Open will call a cltOpen
			 * routine that will unpackage the encapsulated stream.
			 */
			bzero((char *)&openResults, sizeof(Fs_OpenResults));
			openResults.ioFileID.type = FSIO_PASSING_STREAM;
			openResults.dataSize = encapSize;
			openResults.streamData = (ClientData)encapStream;

			openResultsPtr =
				(Fs_OpenResults *)pdevHandlePtr->replyBuf;
			*openResultsPtr = openResults;
		    }
		}
	    }
	    if (status != SUCCESS) {
		pdevHandlePtr->flags |= PDEV_REPLY_FAILED;
		pdevHandlePtr->reply.replySize = 0;
	    } else {
		pdevHandlePtr->reply.replySize = sizeof(Fs_OpenResults);
	    }
	    pdevHandlePtr->reply.status = status;
	    pdevHandlePtr->flags |= PDEV_REPLY_READY;
	    Sync_Broadcast(&pdevHandlePtr->replyReady);
	    PdevClientNotify(pdevHandlePtr);
	    break;
	}
	case IOC_REPOSITION:
	    status = GEN_INVALID_ARG;
	    break;
	case IOC_GET_FLAGS:
	case IOC_SET_FLAGS:
	case IOC_SET_BITS:
	case IOC_CLEAR_BITS:
	    /*
	     * There are no server stream specific flags.
	     */
	    break;
	case IOC_TRUNCATE:
	case IOC_LOCK:
	case IOC_UNLOCK:
	case IOC_MAP:
	    status = FS_INVALID_ARG;
	    break;
	case IOC_GET_OWNER:
	case IOC_SET_OWNER:
	    status = GEN_NOT_IMPLEMENTED;
	    break;
	case IOC_NUM_READABLE: {
	    /*
	     * The server stream is readable only if there are requests in the
	     * request buffer or if the read ahead buffers have changed since
	     * the last time the server did a read.
	     *
	     * Side effects:
	     *		None.
	     */
	    register int reqFirstByte, reqLastByte;
	    register int numReadable;

	    reqFirstByte = pdevHandlePtr->requestBuf.firstByte;
	    reqLastByte = pdevHandlePtr->requestBuf.lastByte;
	    if (((pdevHandlePtr->flags & PDEV_READ_PTRS_CHANGED) == 0) &&
		((reqFirstByte == -1) || (reqFirstByte > reqLastByte))) {
		numReadable = 0;
	    } else {
		numReadable = sizeof(Pdev_BufPtrs);
	    }
	    if (ioctlPtr->outBuffer == (Address)NIL ||
		ioctlPtr->outBufSize < sizeof(int)) {
		status = GEN_INVALID_ARG;
	    } else {
		*(int *)ioctlPtr->outBuffer = numReadable;
		status = SUCCESS;
	    }
	    break;
	}
	case IOC_PREFIX: 
	    status = SUCCESS;
	    break;
	default:
	    status = GEN_NOT_IMPLEMENTED;
	    break;
    }
    UNLOCK_MONITOR;
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevSignalOwner --
 *
 *	Send a signal to the owning process or family of a pseudo-device.
 *
 * Results:
 *	FS_INVALID_ARG if the input buffer isn't right.
 *
 * Side effects:
 *	Bypasses permissions and sends the signal.  Permissions have to
 *	be bypassed otherwise the pseudo-device server has to be setuid.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
FspdevSignalOwner(ctrlHandlePtr, ioctlPtr)
    Fspdev_ControlIOHandle *ctrlHandlePtr;
    Fs_IOCParam *ioctlPtr;
{
    register ReturnStatus status;
    register Pdev_Signal *sigPtr;
    register Ioc_Owner *ownerPtr = &ctrlHandlePtr->owner;
    register Proc_ControlBlock *procPtr;

    if (ownerPtr->procOrFamily == 0) {
	/*
	 * No owner declared, this is a no-op.
	 */
	status = SUCCESS;
    } else if (ioctlPtr->inBufSize != sizeof(Pdev_Signal)) {
	status = FS_INVALID_ARG;
    } else {
	register int savedEuid;

	sigPtr = (Pdev_Signal *)ioctlPtr->inBuffer;
	procPtr = Proc_GetEffectiveProc();
	savedEuid = procPtr->effectiveUserID;
	procPtr->effectiveUserID = 0;
	status = Sig_Send(sigPtr->signal, sigPtr->code, ownerPtr->id,
		 (ownerPtr->procOrFamily == IOC_OWNER_FAMILY), (Address)0);
	procPtr->effectiveUserID = savedEuid;
    }
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * FspdevServerStreamClose --
 *
 *	Clean up the state associated with a server stream.  This makes
 *	sure the client processes associated with the pseudo stream get
 *	poked, and it marks the pseudo stream's state as invalid so
 *	the clients will abort their current operations, if any.  The
 *	handle is 'removed' here, but it won't go away until the client
 *	side closes down and releases its reference to it.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Marks the pseudo stream state with PDEV_SERVER_GONE, notifies
 *	all conditions in pseudo stream state, wakes up all processes
 *	in any of the pseudo stream's wait lists, and then removes
 *	the handle from the hash table.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevServerStreamClose(streamPtr, clientID, procID, flags, size, data)
    Fs_Stream		*streamPtr;	/* Service stream to close */
    int			clientID;	/* HostID of client closing */
    Proc_PID		procID;		/* ID of closing process */
    int			flags;		/* Flags from the stream being closed */
    int			size;		/* Should be zero */
    ClientData		data;		/* IGNORED */
{
    register Fspdev_ServerIOHandle *pdevHandlePtr =
	    (Fspdev_ServerIOHandle *)streamPtr->ioHandlePtr;

    DBG_PRINT( ("Server Closing pdev %x,%x\n", 
		pdevHandlePtr->hdr.fileID.major,
		pdevHandlePtr->hdr.fileID.minor) );

    PdevClientWakeup(pdevHandlePtr);
    if (pdevHandlePtr->flags & PDEV_NAMING) {
	/*
	 * Clean up the prefix table entry associated with the pfs.
	 */
	register Fspdev_ControlIOHandle *ctrlHandlePtr;
	Fs_Stream dummy;

	ctrlHandlePtr = pdevHandlePtr->ctrlHandlePtr;
	dummy.hdr.fileID.type = -1;
	dummy.ioHandlePtr = (Fs_HandleHeader *)ctrlHandlePtr;
	Fsutil_HandleLock(ctrlHandlePtr);
	Fsprefix_HandleClose(ctrlHandlePtr->prefixPtr, FSPREFIX_ANY);
	(void)FspdevControlClose(&dummy, clientID, procID, flags, 0, (ClientData)NIL);
    }
    Sync_LockClear(&pdevHandlePtr->lock);
    Fsutil_HandleRelease(pdevHandlePtr, TRUE);
    Fsutil_HandleRemove(pdevHandlePtr);	/* No need for scavenging */
    fs_Stats.object.pseudoStreams--;
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * PdevClientWakeup --
 *
 *	Called when the server's stream is closed.  This
 *	notifies the various conditions that the client might be
 *	waiting on and marks the pdev state as invalid so the
 *	client will bail out when it wakes up.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Notifies condition variables and marks the pseudo stream as invalid.
 *
 *----------------------------------------------------------------------
 */

ENTRY static void
PdevClientWakeup(pdevHandlePtr)
    Fspdev_ServerIOHandle *pdevHandlePtr;	/* State for the pseudo stream */
{
    LOCK_MONITOR;
    /*
     * Set both "busy" and "server gone" because the standard preamble
     * for all client routines only checks against "server gone"
     * inside a while-not-busy loop.
     */
    pdevHandlePtr->flags |= (PDEV_SERVER_GONE|PDEV_REPLY_FAILED|PDEV_BUSY);
    Sync_Broadcast(&pdevHandlePtr->access);
    Sync_Broadcast(&pdevHandlePtr->caughtUp);
    Sync_Broadcast(&pdevHandlePtr->replyReady);
    Fsutil_FastWaitListNotify(&pdevHandlePtr->cltReadWaitList);
    Fsutil_FastWaitListNotify(&pdevHandlePtr->cltWriteWaitList);
    Fsutil_FastWaitListNotify(&pdevHandlePtr->cltExceptWaitList);
    Fsutil_WaitListDelete(&pdevHandlePtr->cltReadWaitList);
    Fsutil_WaitListDelete(&pdevHandlePtr->cltWriteWaitList);
    Fsutil_WaitListDelete(&pdevHandlePtr->cltExceptWaitList);
    Fsutil_WaitListDelete(&pdevHandlePtr->srvReadWaitList);
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPdevServerOK --
 *
 *	Called from FspdevPfsExport to see if the server of a prefix still exists.
 *
 * Results:
 *	TRUE if the server process is still around.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ENTRY Boolean
FspdevPdevServerOK(pdevHandlePtr)
    Fspdev_ServerIOHandle *pdevHandlePtr;	/* State for the pseudo stream */
{
    register Boolean answer;
    LOCK_MONITOR;
    if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	answer = FALSE;
    } else {
	answer = TRUE;
    }
    UNLOCK_MONITOR;
    return(answer);
}


/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoStreamOpen --
 *
 *	Do the first request-response with a pseudo-device server to see if it
 *	will accept the open by the client.   This is used to tell
 *	the server something about the new stream it is getting,
 *	and to let it decide if it will accept the open.
 *
 * Results:
 *	The return status from the server's reply.  It can reject the open.
 *
 * Side effects:
 *	An PDEV_OPEN request-response is carried out.
 *
 *----------------------------------------------------------------------
 */

ENTRY ReturnStatus
FspdevPseudoStreamOpen(pdevHandlePtr, flags, clientID, procID, userID)
    register Fspdev_ServerIOHandle *pdevHandlePtr;	/* Pdev connection state */
    int		flags;		/* Open flags */
    int		clientID;	/* Host ID of the client */
    Proc_PID	procID;		/* Process ID of the client process */
    int		userID;		/* User ID of the client process */
{
    register ReturnStatus 	status;
    Pdev_Request		request;

    LOCK_MONITOR;

    /*
     * Wait for the server to set up the request buffer.  The state starts
     * out PDEV_BUSY to eliminate an explicit check for PDEV_SETUP in all
     * the routines that call RequestResponse.  PDEV_BUSY is cleared after
     * the server initializes the request buffer with IOC_PDEV_SETUP.
     */
    while (pdevHandlePtr->flags & PDEV_BUSY) { 
	if ((pdevHandlePtr->flags & PDEV_SERVER_GONE) == 0) {
	    (void)Sync_Wait(&pdevHandlePtr->access, FALSE);
	}
	if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	    status = DEV_OFFLINE;
	    goto exit;
	}
    }
    pdevHandlePtr->flags |= PDEV_BUSY;

    /*
     * Issue the first request to the server to see if it will accept us.
     */

    request.hdr.operation	= PDEV_OPEN;
    request.param.open.flags	= flags;
    request.param.open.pid	= procID;
    request.param.open.hostID	= clientID;
    request.param.open.uid	= userID;

    pdevHandlePtr->flags &= ~(FS_USER_IN|FS_USER_OUT);
    status = RequestResponse(pdevHandlePtr, sizeof(Pdev_Request), &request.hdr,
			 0, (Address) NIL, 0, (Address) NIL, (Fs_IOReply *)NIL,
			 (Sync_RemoteWaiter *)NIL);
    pdevHandlePtr->flags &= ~PDEV_BUSY;
exit:
    Sync_Broadcast(&pdevHandlePtr->access);
    UNLOCK_MONITOR;
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoStreamLookup --
 *
 *	Do a lookup request-response to a pseudo-filesystem server over
 *	the naming request-response stream that is hooked to the prefix table.
 *	If a pathname redirection occurs this allocates a buffer for the
 *	returned pathname.  Otherwise this is a stub that passes its arguments
 *	up to the user level pseudo-filesystem server via request-response.
 *
 * Results:
 *	A status and some bundled results that aren't interpreted by us.
 *	If status is FS_REDIRECT then *newNameInfoPtrPtr has been allocated
 *	and contains the returned pathname.
 *
 * Side effects:
 *	The effect of the naming operation in the pseudo-filesystem is
 *	up to the pseudo-filesystem server.  Upon FS_REDIRECT this
 *	allocates the *newNameInfoPtrPtr buffer.
 *
 *----------------------------------------------------------------------
 */

ENTRY ReturnStatus
FspdevPseudoStreamLookup(pdevHandlePtr, requestPtr, argSize, argsPtr,
		    resultsSizePtr, resultsPtr, newNameInfoPtrPtr)
    register Fspdev_ServerIOHandle *pdevHandlePtr;	/* Pdev connection state */
    Pfs_Request		*requestPtr;	/* Semi-initialized request header */
    int			argSize;	/* Size of argsPtr buffer */
    Address		argsPtr;	/* Ref. to bundled args, usually name */
    int			*resultsSizePtr;/* Out size of results */
    Address		resultsPtr;	/* Ref. to bundled results or 
					 * Fs_RedirectInfo */
    Fs_RedirectInfo	**newNameInfoPtrPtr;/* Set if server returns name */
{
    register ReturnStatus 	status;
    Fs_RedirectInfo		redirectInfo;	/* This is a large buffer
						 * that is used for EITHER
						 * normal reply parameters
						 * or a redirected pathname */
    Fs_IOReply			ioReply;

    LOCK_MONITOR;

    *newNameInfoPtrPtr = (Fs_RedirectInfo *)NIL;

    while (pdevHandlePtr->flags & PDEV_BUSY) {
	if ((pdevHandlePtr->flags & PDEV_SERVER_GONE) == 0) {
	    (void)Sync_Wait(&pdevHandlePtr->access, FALSE);
	}
	if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	    status = FS_STALE_HANDLE;
	    goto exit;
	}
    }
    pdevHandlePtr->flags |= PDEV_BUSY;

    pdevHandlePtr->flags &= ~(FS_USER_IN|FS_USER_OUT);
    status = RequestResponse(pdevHandlePtr, sizeof(Pfs_Request),
		&requestPtr->hdr, argSize, argsPtr, sizeof(Fs_RedirectInfo),
		(Address)&redirectInfo, &ioReply,
		(Sync_RemoteWaiter *)NIL);
    if (status == FS_LOOKUP_REDIRECT) {
	*newNameInfoPtrPtr = mnew(Fs_RedirectInfo);
	(*newNameInfoPtrPtr)->prefixLength = redirectInfo.prefixLength;
	(void)strcpy((*newNameInfoPtrPtr)->fileName, redirectInfo.fileName);
    } else {
	/*
	 * Grab the result parameters.
	 */
	*resultsSizePtr = ioReply.length;
	if (ioReply.length > 0) {
	    bcopy((Address)&redirectInfo, resultsPtr, ioReply.length);
	}
    }

    if (status == DEV_OFFLINE) {
	/*
	 * Return stale handle so remote clients know to nuke
	 * their prefix table entry.
	 */
	status = FS_STALE_HANDLE;
    }
    pdevHandlePtr->flags &= ~PDEV_BUSY;
exit:
    Sync_Broadcast(&pdevHandlePtr->access);
    UNLOCK_MONITOR;
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoStream2Path --
 *
 *	Do a rename/link request-response to a pseudo-filesystem server over
 *	the naming request-response stream that is hooked to the prefix table.
 *	If a pathname redirection occurs this allocates a buffer for the
 *	returned pathname.  Otherwise this is a stub that passes its arguments
 *	up to the user level pseudo-filesystem server via request-response.
 *
 * Results:
 *	A status and some bundled results that aren't interpreted by us.
 *	If status is FS_REDIRECT then *newNameInfoPtrPtr has been allocated
 *	and contains the returned pathname.
 *
 * Side effects:
 *	The effect of the naming operation in the pseudo-filesystem is
 *	up to the pseudo-filesystem server.  Upon FS_REDIRECT this
 *	allocates the *newNameInfoPtrPtr buffer.
 *
 *----------------------------------------------------------------------
 */

ENTRY ReturnStatus
FspdevPseudoStream2Path(pdevHandlePtr, requestPtr, dataPtr, name1ErrorPtr,
		    newNameInfoPtrPtr)
    register Fspdev_ServerIOHandle *pdevHandlePtr;	/* Pdev connection state */
    Pfs_Request		*requestPtr;	/* Semi-initialized request header */
    Fs_2PathData		*dataPtr;	/* 2 pathnames */
    Boolean		*name1ErrorPtr;	/* TRUE if error applies to first path*/
    Fs_RedirectInfo	**newNameInfoPtrPtr;/* Set if server returns name */
{
    register ReturnStatus 	status;
    Fs_2PathRedirectInfo		redirectInfo;

    LOCK_MONITOR;

    while (pdevHandlePtr->flags & PDEV_BUSY) {
	if ((pdevHandlePtr->flags & PDEV_SERVER_GONE) == 0) {
	    (void)Sync_Wait(&pdevHandlePtr->access, FALSE);
	}
	if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	    status = FS_STALE_HANDLE;
	    goto exit;
	}
    }
    pdevHandlePtr->flags |= PDEV_BUSY;

    pdevHandlePtr->flags &= ~(FS_USER_IN|FS_USER_OUT);
    status = RequestResponse(pdevHandlePtr, sizeof(Pfs_Request),
		&requestPtr->hdr, sizeof(Fs_2PathData), (Address)dataPtr,
		sizeof(Fs_2PathRedirectInfo), (Address)&redirectInfo,
		(Fs_IOReply *)NIL, (Sync_RemoteWaiter *)NIL);
    if (status == FS_LOOKUP_REDIRECT) {
	*newNameInfoPtrPtr = mnew(Fs_RedirectInfo);
	(*newNameInfoPtrPtr)->prefixLength = redirectInfo.prefixLength;
	(void)strcpy((*newNameInfoPtrPtr)->fileName, redirectInfo.fileName);
    }
    if (status != SUCCESS) {
	*name1ErrorPtr = redirectInfo.name1ErrorP;
    } else {
	*name1ErrorPtr = FALSE;
    }

    if (status == DEV_OFFLINE) {
	/*
	 * Return stale handle so remote clients know to nuke
	 * their prefix table entry.
	 */
	status = FS_STALE_HANDLE;
    }
    pdevHandlePtr->flags &= ~PDEV_BUSY;
exit:
    Sync_Broadcast(&pdevHandlePtr->access);
    UNLOCK_MONITOR;
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoGetAttr --
 *
 *	Called from Fs_GetAttributesID to get the attributes of a file
 *	in a pseudo-filesystem.  The stream's nameInfoPtr->fileID is
 *	set to the fileID of the pseudo-device connection to the server,
 *	and this ID is passed into us.  This does a PDEV_GET_ATTR request.
 *
 * Results:
 *	The attributes structure is passed back from the pfs server.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevPseudoGetAttr(fileIDPtr, clientID, attrPtr)
    register Fs_FileID		*fileIDPtr;	/* Identfies pdev connection */
    int				clientID;	/* Host ID of process asking
						 * for the attributes */
    register Fs_Attributes	*attrPtr;	/* Return - the attributes */
{
    Fspdev_ClientIOHandle		*cltHandlePtr;
    Pdev_Request		request;
    register Fspdev_ServerIOHandle	*pdevHandlePtr;
    register ReturnStatus	status;

    cltHandlePtr = Fsutil_HandleFetchType(Fspdev_ClientIOHandle, fileIDPtr);
    if (cltHandlePtr == (Fspdev_ClientIOHandle *)NIL) {
	printf( "FspdevPseudoGetAttr, no %s handle <%d,%x,%x>\n",
	    Fsutil_FileTypeToString(fileIDPtr->type), fileIDPtr->serverID,
	    fileIDPtr->major, fileIDPtr->minor);
	return(FS_FILE_NOT_FOUND);
    }
    Fsutil_HandleRelease(cltHandlePtr, TRUE);
    pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
    LOCK_MONITOR;

    while (pdevHandlePtr->flags & PDEV_BUSY) {
	if ((pdevHandlePtr->flags & PDEV_SERVER_GONE) == 0) {
	    (void)Sync_Wait(&pdevHandlePtr->access, FALSE);
	}
	if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	    status = DEV_OFFLINE;
	    goto exit;
	}
    }
    pdevHandlePtr->flags |= PDEV_BUSY;
    pdevHandlePtr->flags &= ~(FS_USER_IN|FS_USER_OUT);
    request.hdr.operation = PDEV_GET_ATTR;
    status = RequestResponse(pdevHandlePtr, sizeof(Pdev_Request), &request.hdr,
			0, (Address) NIL,
			sizeof(Fs_Attributes), (Address)attrPtr,
			(Fs_IOReply *)NIL, (Sync_RemoteWaiter *)NIL);
    /*
     * Patch the serverID in the attributes so it matches the serverID
     * given in the prefix table.  This is needed to make getwd() work.
     */
    attrPtr->serverID = rpc_SpriteID;

    pdevHandlePtr->flags &= ~PDEV_BUSY;
exit:
    Sync_Broadcast(&pdevHandlePtr->access);
    UNLOCK_MONITOR;
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoSetAttr --
 *
 *	Set the attributes of a file in a pseudo-filesystem.  We have the
 *	fileID of the request-response stream to the server.  This issues
 *	a PDEV_SET_ATTR request to the server that contains new attributes.
 *
 * Results:
 *	An error code.
 *
 * Side effects:
 *	None here.  The new attributes are shipped to the pfs server.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FspdevPseudoSetAttr(fileIDPtr, attrPtr, idPtr, flags)
    register Fs_FileID		*fileIDPtr;	/* Identfies pdev connection */
    register Fs_Attributes	*attrPtr;	/* Return - the attributes */
    Fs_UserIDs			*idPtr;		/* Identfies user */
    int				flags;		/* Tells which attrs to set */
{
    Fspdev_ClientIOHandle		*cltHandlePtr;
    Pdev_Request		request;
    register Fspdev_ServerIOHandle	*pdevHandlePtr;
    register ReturnStatus	status;

    cltHandlePtr = Fsutil_HandleFetchType(Fspdev_ClientIOHandle, fileIDPtr);
    if (cltHandlePtr == (Fspdev_ClientIOHandle *)NIL) {
	printf( "FspdevPseudoSetAttr, no handle <%d,%d,%x,%x>\n",
	    fileIDPtr->serverID, fileIDPtr->type,
	    fileIDPtr->major, fileIDPtr->minor);
	return(FS_FILE_NOT_FOUND);
    }
    Fsutil_HandleRelease(cltHandlePtr, TRUE);
    pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
    LOCK_MONITOR;

    while (pdevHandlePtr->flags & PDEV_BUSY) {
	if ((pdevHandlePtr->flags & PDEV_SERVER_GONE) == 0) {
	    (void)Sync_Wait(&pdevHandlePtr->access, FALSE);
	}
	if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	    status = DEV_OFFLINE;
	    goto exit;
	}
    }
    pdevHandlePtr->flags |= PDEV_BUSY;
    pdevHandlePtr->flags &= ~(FS_USER_IN|FS_USER_OUT);
    request.hdr.operation = PDEV_SET_ATTR;
    request.param.setAttr.uid = idPtr->user;
    request.param.setAttr.flags = flags;
    status = RequestResponse(pdevHandlePtr, sizeof(Pdev_Request), &request.hdr,
			sizeof(Fs_Attributes), (Address)attrPtr,
			0, (Address) NIL,
			(Fs_IOReply *)NIL, (Sync_RemoteWaiter *)NIL);
    pdevHandlePtr->flags &= ~PDEV_BUSY;
exit:
    Sync_Broadcast(&pdevHandlePtr->access);
    UNLOCK_MONITOR;
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoStreamGetIOAttr --
 *
 *	Called from Fs_GetAttrStream to get the I/O attributes of a
 *	pseudo-device.  The access and modify times of the pseudo-device
 *	are obtained from the internal pdev state.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
FspdevPseudoStreamGetIOAttr(fileIDPtr, clientID, attrPtr)
    register Fs_FileID		*fileIDPtr;	/* Identfies pdev connection */
    int				clientID;	/* Host ID of process asking
						 * for the attributes */
    register Fs_Attributes	*attrPtr;	/* Return - the attributes */
{
    Fspdev_ClientIOHandle		*cltHandlePtr;
    register Fspdev_ServerIOHandle	*pdevHandlePtr;

    cltHandlePtr = Fsutil_HandleFetchType(Fspdev_ClientIOHandle, fileIDPtr);
    if (cltHandlePtr == (Fspdev_ClientIOHandle *)NIL) {
	printf( "FspdevPseudoStreamGetIOAttr, no %s handle <%d,%x,%x> client %d\n",
	    Fsutil_FileTypeToString(fileIDPtr->type), fileIDPtr->serverID,
	    fileIDPtr->major, fileIDPtr->minor, clientID);
	return(FS_FILE_NOT_FOUND);
    }
    Fsutil_HandleRelease(cltHandlePtr, TRUE);
    pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
    LOCK_MONITOR;

    attrPtr->accessTime.seconds = pdevHandlePtr->ctrlHandlePtr->accessTime;
    attrPtr->dataModifyTime.seconds = pdevHandlePtr->ctrlHandlePtr->modifyTime;

    UNLOCK_MONITOR;
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoStreamSetIOAttr --
 *
 *	Set the IO attributes of a pseudo-device.
 *
 * Results:
 *	An error code.
 *
 * Side effects:
 *	Updates the access and modify times kept in the pdev state.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
FspdevPseudoStreamSetIOAttr(fileIDPtr, attrPtr, flags)
    register Fs_FileID		*fileIDPtr;	/* Identfies pdev connection */
    register Fs_Attributes	*attrPtr;	/* Return - the attributes */
    int				flags;		/* Tells which attrs to set */
{
    Fspdev_ClientIOHandle		*cltHandlePtr;
    register Fspdev_ServerIOHandle	*pdevHandlePtr;

    cltHandlePtr = Fsutil_HandleFetchType(Fspdev_ClientIOHandle, fileIDPtr);
    if (cltHandlePtr == (Fspdev_ClientIOHandle *)NIL) {
	printf( "FspdevPseudoStreamSetIOAttr, no handle <%d,%d,%x,%x>\n",
	    fileIDPtr->serverID, fileIDPtr->type,
	    fileIDPtr->major, fileIDPtr->minor);
	return(FS_FILE_NOT_FOUND);
    }
    Fsutil_HandleRelease(cltHandlePtr, TRUE);
    pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
    LOCK_MONITOR;
    if (flags & FS_SET_TIMES) {
	pdevHandlePtr->ctrlHandlePtr->accessTime = attrPtr->accessTime.seconds;
	pdevHandlePtr->ctrlHandlePtr->modifyTime = attrPtr->dataModifyTime.seconds;
    }
    UNLOCK_MONITOR;
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoStreamRead --
 *
 *	Read from a pseudo-device stream. If there is data in the read
 *	ahead buffer (if one exists), that is used to satisfy the read.
 *	Otherwise a request-response exchange with the server is used
 *	to do the read.
 *
 * Results:
 *	SUCCESS, and *lenPtr reflects how much was read.  When the server
 *	goes away EOF is simulated by a SUCCESS return and *lenPtr == 0.
 *	If there is no data in the read ahead buffer FS_WOULD_BLOCK is returned.
 *
 * Side effects:
 *	If applicable, pointers into the read ahead buffer are adjusted.
 *	The buffer is filled with the number of bytes indicated by
 *	the length parameter.  The in/out length parameter specifies
 *	the buffer size on input and is updated to reflect the number
 *	of bytes actually read.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
FspdevPseudoStreamRead(streamPtr, readPtr, waitPtr, replyPtr)
    register Fs_Stream 	*streamPtr;	/* Stream to read from. */
    Fs_IOParam		*readPtr;	/* Read parameter block. */
    Sync_RemoteWaiter	*waitPtr;	/* Process info for remote waiting */
    Fs_IOReply		*replyPtr;	/* Signal to return, if any,
					 * plus the amount read. */
{
    ReturnStatus 	status;
    register Fspdev_ClientIOHandle *cltHandlePtr =
	    (Fspdev_ClientIOHandle *)streamPtr->ioHandlePtr;
    register Fspdev_ServerIOHandle *pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
    Pdev_Request	request;

    LOCK_MONITOR;
    while (pdevHandlePtr->flags & PDEV_BUSY) {
	if ((pdevHandlePtr->flags & PDEV_SERVER_GONE) == 0) {
	    (void)Sync_Wait(&pdevHandlePtr->access, FALSE);
	}
	if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	    status = DEV_OFFLINE;
	    goto exitNoServer;
	}
    }
    pdevHandlePtr->flags |= PDEV_BUSY;

#ifdef notdef
    {
	register Ioc_Owner *ownerPtr;
	/*
	 * Check for access inside the owning process group.
	 */
	ownerPtr = &pdevHandlePtr->ctrlHandlePtr->owner;
	if (((ownerPtr->procOrFamily == IOC_OWNER_FAMILY) &&
	     (readPtr->familyID != ownerPtr->id)) ||
	    ((ownerPtr->procOrFamily == IOC_OWNER_PROC) &&
	     (readPtr->procID != ownerPtr->id))) {
	    printf("PdevRead: ownership conflict\n");
	    status = GEN_ABORTED_BY_SIGNAL;
	    replyPtr->signal = SIG_TTY_INPUT;
	    goto exit;
	}
    }
#endif

    if (pdevHandlePtr->readBuf.data != (Address)NIL) {
	/*
	 * A read ahead buffer exists so we get data from it.  If it's
	 * empty we put the client on the client I/O handle read wait list.
	 */
	if (pdevHandlePtr->flags & PDEV_READ_BUF_EMPTY) {
	    status = FS_WOULD_BLOCK;
	    Fsutil_FastWaitListInsert(&pdevHandlePtr->cltReadWaitList, waitPtr);
	    replyPtr->length = 0;
	} else {
	    register int dataAvail, firstByte, lastByte, toRead;
	    register Proc_ControlBlock *serverProcPtr;

	    firstByte = pdevHandlePtr->readBuf.firstByte;
	    lastByte = pdevHandlePtr->readBuf.lastByte;
	    dataAvail = lastByte - firstByte + 1;
	    if (dataAvail <= 0) {
		panic("FspdevPseudoStreamRead, dataAvail in read buf <= 0 bytes\n");
		status = DEV_OFFLINE;
		goto exit;
	    }
	    /*
	     * Lock down the server process in preparation for copying
	     * from the read ahead buffer.
	     */
	    serverProcPtr = Proc_LockPID(pdevHandlePtr->serverPID);
	    if (serverProcPtr == (Proc_ControlBlock *)NIL) {
		status = DEV_OFFLINE;
		goto exit;
	    }
	    /*
	     * Decide how much to read and note if we empty the buffer.
	     */
	    if (dataAvail > readPtr->length) {
		toRead = readPtr->length;
	    } else {
		toRead = dataAvail;
		pdevHandlePtr->flags |= PDEV_READ_BUF_EMPTY;
	    }
	    DBG_PRINT( ("PDEV %x,%x Read %d Avail %d\n", 
		    pdevHandlePtr->hdr.fileID.major,
		    pdevHandlePtr->hdr.fileID.minor,
		    toRead, dataAvail) );
	    /*
	     * Copy out of the read ahead buffer to the client's buffer.
	     */
	    status = Vm_CopyInProc(toRead, serverProcPtr,
			  pdevHandlePtr->readBuf.data + firstByte,
			  readPtr->buffer, (readPtr->flags & FS_USER) == 0);
	    Proc_Unlock(serverProcPtr);
	    /*
	     * Update pointers and poke the server so it can find out.
	     */
	    replyPtr->length = toRead;
	    pdevHandlePtr->readBuf.firstByte = firstByte + toRead;
	    pdevHandlePtr->flags |= PDEV_READ_PTRS_CHANGED;
	    Fsutil_FastWaitListNotify(&pdevHandlePtr->srvReadWaitList);
	}
    } else if (pdevHandlePtr->selectBits & FS_READABLE) {
	/*
	 * No read ahead buffer and the state is readable.
	 * Set up and do the request-response exchange.
	 */
	request.hdr.operation		= PDEV_READ;
	request.param.read		= *readPtr;

	if (readPtr->flags & FS_USER) {
	    pdevHandlePtr->flags |= FS_USER_OUT;
	}
	status = RequestResponse(pdevHandlePtr, sizeof(Pdev_Request),
	    &request.hdr, 0, (Address) NIL, readPtr->length, readPtr->buffer,
		    replyPtr, waitPtr);
    } else {
	/*
	 * The pseudo-device is not readable now.
	 */
	Fsutil_FastWaitListInsert(&pdevHandlePtr->cltReadWaitList, waitPtr);
	replyPtr->length = 0;
	status = FS_WOULD_BLOCK;
    }
    if (status == SUCCESS) {
	pdevHandlePtr->ctrlHandlePtr->accessTime = Fsutil_TimeInSeconds();
    }
exit:
    if (status == DEV_OFFLINE) {
	/*
	 * Simulate EOF
	 */
	status = SUCCESS;
	replyPtr->length = 0;
    }
    pdevHandlePtr->flags &= ~(PDEV_BUSY|FS_USER_OUT);
exitNoServer:
    Sync_Broadcast(&pdevHandlePtr->access);
    UNLOCK_MONITOR;
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoStreamWrite --
 *
 *	Write to a pseudo-device by a client.  The write is done
 *	asynchronously if the stream allows that.  In that case we
 *	always say we could write as much as requested.  However, if
 *	the write is larger than the server's request buffer we
 *	break it into blocks that each fit. To support UDP, the
 *	stream can also be marked to dis-allow these large writes.
 *	Finally, the stream may be marked synchronous in which case
 *	we tell RequestResponse to wait for a reply.
 *
 * Results:
 *	SUCCESS			- the data was written.
 *
 * Side effects:
 *	The data in the buffer is written to the device.  Large writes
 *	are broken into a series of shorter writes, although we keep
 *	the access lock on the pseudo-stream so the whole write completes.
 *	The in/out length parameter specifies the amount of data to write
 *	and is updated to reflect the number of bytes actually written.
 *
 *----------------------------------------------------------------------
 */
ENTRY ReturnStatus
FspdevPseudoStreamWrite(streamPtr, writePtr, waitPtr, replyPtr)
    Fs_Stream 	*streamPtr;	/* Stream to write to. */
    Fs_IOParam		*writePtr;	/* Read parameter block */
    Sync_RemoteWaiter	*waitPtr;	/* Process info for remote waiting */
    Fs_IOReply		*replyPtr;	/* Signal to return, if any */
{
    register Fspdev_ClientIOHandle *cltHandlePtr =
	    (Fspdev_ClientIOHandle *)streamPtr->ioHandlePtr;
    register Fspdev_ServerIOHandle *pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
    ReturnStatus 	status = SUCCESS;
    Pdev_Request	request;
    int			amountWritten;
    int			numBytes;
    int			maxRequestSize;
    int			totalToWrite;

    LOCK_MONITOR;
    /*
     * Wait for exclusive access to the stream.
     */
    while (pdevHandlePtr->flags & PDEV_BUSY) {
	if ((pdevHandlePtr->flags & PDEV_SERVER_GONE) == 0) {
	    (void)Sync_Wait(&pdevHandlePtr->access, FALSE);
	}
	if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	    status = FS_BROKEN_PIPE;
	    goto exitNoServer;
	}
    }
    pdevHandlePtr->flags |= PDEV_BUSY;
    if (writePtr->flags & FS_USER) {
	pdevHandlePtr->flags |= FS_USER_IN;
    }

#ifdef notdef
    {
	/*
	 * Check for access inside the owning process group.
	 * (This doesn't work presently, 6/89.  We'll rely on
	 * the tty driver to do this checking for us.)
	 *
	 * Getting 4.3 BSD semantics is tricky because the operation is
	 * supposed to succeed if the TTYOUT signal is blocked. Need a
	 * flag passed down from Fs_Write.
	 */
	Ioc_Owner		*ownerPtr;
	ownerPtr = &pdevHandlePtr->ctrlHandlePtr->owner;
	if (((ownerPtr->procOrFamily == IOC_OWNER_FAMILY) &&
	     (writePtr->familyID != ownerPtr->id)) ||
	    ((ownerPtr->procOrFamily == IOC_OWNER_PROC) &&
	     (writePtr->procID != ownerPtr->id))) {
	    printf("PdevWrite: ownership conflict\n");
	    status = GEN_ABORTED_BY_SIGNAL;
	    replyPtr->signal = SIG_TTY_OUTPUT;
	    goto exit;
	}
    }
#endif
    /*
     * Allow flow control by checking the select bits and only trying
     * the operation if the state allows it.
     */
    if ((pdevHandlePtr->selectBits & FS_WRITABLE) == 0) {
	replyPtr->length = 0;
	Fsutil_FastWaitListInsert(&pdevHandlePtr->cltWriteWaitList, waitPtr);
	status = FS_WOULD_BLOCK;
	goto exit;
    }

    maxRequestSize = pdevHandlePtr->requestBuf.size - sizeof(Pdev_Request);
    if (writePtr->length > maxRequestSize &&
	(pdevHandlePtr->flags & PDEV_NO_BIG_WRITES)) {
	printf("Too large a write (%d bytes) an a (UDP?) pseudo-device\n",
	    writePtr->length);
	status = GEN_INVALID_ARG;
	goto exit;
    }

    if (pdevHandlePtr->flags & PDEV_WRITE_BEHIND) {
	request.hdr.operation		= PDEV_WRITE_ASYNC;
    } else {
	request.hdr.operation		= PDEV_WRITE;
    }
    request.param.write			= *writePtr;
    request.param.write.buffer		= 0;

    amountWritten = 0;
    totalToWrite = writePtr->length;
    while ((writePtr->length > 0) && (status == SUCCESS)) {
	/*
	 * Loop to put the maximum amount of data into the request
	 * buffer until the whole block has been transferred.  The
	 * server returns an int, the number of bytes it accepted.
	 */
	request.param.write.length = (writePtr->length > maxRequestSize) ?
				      maxRequestSize : writePtr->length;
	request.param.write.offset = writePtr->offset + amountWritten;
	status = RequestResponse(pdevHandlePtr, sizeof(Pdev_Request),
				 &request.hdr, request.param.write.length,
				 writePtr->buffer + amountWritten,
				 sizeof(int), (Address)&numBytes,
				 replyPtr, waitPtr);
	if (pdevHandlePtr->flags & PDEV_WRITE_BEHIND) {
	    /*
	     * Assume all bytes accepted when write-behind is enabled.
	     */
	    numBytes = request.param.write.length;
	} else if (replyPtr->length != sizeof(int)) {
	    numBytes = 0;
	}
	amountWritten += numBytes;
	writePtr->length -= numBytes;
    }
    if (amountWritten > totalToWrite) {
	printf("FspdevPseudoStreamWrite: \"%s\" amount written (%d) > requested (%d)\n",
	    Fsutil_HandleName(streamPtr->ioHandlePtr), amountWritten, totalToWrite);
	amountWritten = totalToWrite;
    }
    replyPtr->length = amountWritten;
    if (amountWritten > 0) {
	pdevHandlePtr->ctrlHandlePtr->modifyTime = Fsutil_TimeInSeconds();
    }
exit:
    if (status == DEV_OFFLINE) {
	/*
	 * Simulate a broken pipe so writers die.
	 */
	replyPtr->signal = SIG_PIPE;
	status = FS_BROKEN_PIPE;
    }
    if (replyPtr->signal != 0) {
	printf("PdevWrite: signal %d\n", replyPtr->signal);
    }
    pdevHandlePtr->flags &= ~(PDEV_BUSY|FS_USER_IN);
exitNoServer:
    Sync_Broadcast(&pdevHandlePtr->access);
    UNLOCK_MONITOR;
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoStreamIOControl --
 *
 *	IOControls for pseudo-device.  The in parameter block of the
 *	IOControl is passed to the server, and its response is used
 *	to fill the return parameter block of the client.
 *
 * Results:
 *	SUCCESS			- the operation was successful.
 *
 * Side effects:
 *	None here in the kernel, anyway.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
FspdevPseudoStreamIOControl(streamPtr, ioctlPtr, replyPtr)
    Fs_Stream	*streamPtr;	/* Stream to pseudo-device */
    Fs_IOCParam *ioctlPtr;	/* Standard I/O Control parameter block */
    Fs_IOReply *replyPtr;	/* Output buffer length and signal to return */
{
    ReturnStatus 	status;
    Pdev_Request	request;
    register Fspdev_ClientIOHandle *cltHandlePtr =
	    (Fspdev_ClientIOHandle *)streamPtr->ioHandlePtr;
    register Fspdev_ServerIOHandle *pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
    Boolean	sendToServer;

    LOCK_MONITOR;
    /*
     * Wait for exclusive access to the stream.
     */
    while (pdevHandlePtr->flags & PDEV_BUSY) {
	if ((pdevHandlePtr->flags & PDEV_SERVER_GONE) == 0) {
	    (void)Sync_Wait(&pdevHandlePtr->access, FALSE);
	}
	if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	    status = DEV_OFFLINE;
	    goto exit;
	}
    }
    pdevHandlePtr->flags |= PDEV_BUSY;

    /*
     * Decide if the buffers are already in the kernel or not.  The buffers
     * for generic I/O controls are copied in, and if we are being called
     * from an RPC stub they are also in kernel space.
     */
    if (ioctlPtr->flags & FS_USER_IN) {
	pdevHandlePtr->flags |= FS_USER_IN;
    }
    if (ioctlPtr->flags & FS_USER_OUT) {
	pdevHandlePtr->flags |= FS_USER_OUT;
    }

    status = SUCCESS;
    sendToServer = TRUE;

    if (ioctlPtr->command == IOC_NUM_READABLE &&
	pdevHandlePtr->readBuf.data != (Address)NIL) {
	/*
	 * Trap out the IOC_NUM_READABLE if there's a read ahead buf.
	 */
	int bytesAvail;
	if (pdevHandlePtr->flags & PDEV_READ_BUF_EMPTY) {
	    bytesAvail = 0;
	} else {
	    bytesAvail = pdevHandlePtr->readBuf.lastByte -
			 pdevHandlePtr->readBuf.firstByte + 1;
	}
	if (ioctlPtr->outBufSize != sizeof(int)) {
	    status = GEN_INVALID_ARG;
	} else if (ioctlPtr->format != mach_Format) {
	    int size = sizeof(int);
	    int inSize = sizeof(int);
	    int fmtStatus;
	    fmtStatus = Fmt_Convert("w", mach_Format, &inSize, 
			    (Address) &bytesAvail,
			    ioctlPtr->format, &size, ioctlPtr->outBuffer);
	    if (fmtStatus != 0) {
		printf("Format of ioctl failed <0x%x>\n", fmtStatus);
		status = GEN_INVALID_ARG;
	    }
	    if (size != sizeof(int)) {
		status = GEN_INVALID_ARG;
	    }
	} else {
	    *(int *)ioctlPtr->outBuffer = bytesAvail;
	}
	DBG_PRINT( ("IOC  %x,%x num readable %d\n",
		pdevHandlePtr->hdr.fileID.major,
		pdevHandlePtr->hdr.fileID.minor,
		bytesAvail) );
    } else {
	/*
	 * Switch out on command for any special processing,
	 * then do a request-response transaction with the server.
	 */
	switch(ioctlPtr->command) {
	    case IOC_SET_OWNER: {
		/*
		 * Siphon off the ownership so we can enforce it in the kernel.
		 */
		if (ioctlPtr->inBufSize < sizeof(Ioc_Owner)) {
		    status = GEN_INVALID_ARG;
		} else {
		    pdevHandlePtr->ctrlHandlePtr->owner =
			    *(Ioc_Owner *)ioctlPtr->inBuffer;
		}
		break;
	    }
	    case IOC_GET_OWNER: {
		/*
		 * Do our own get owner, but let the server see the request.
		 */
		if (ioctlPtr->outBufSize < sizeof(Ioc_Owner)) {
		    status = GEN_INVALID_ARG;
		} else {
		    *(Ioc_Owner *)ioctlPtr->outBuffer =
			    pdevHandlePtr->ctrlHandlePtr->owner;
		}
		break;
	    }
	    case IOC_PREFIX: 
		status = SUCCESS;
		sendToServer = FALSE;
		break;
	}
	if (status == SUCCESS && sendToServer) {
	    request.hdr.operation	= PDEV_IOCTL;
	    request.param.ioctl		= *ioctlPtr;

	    status = RequestResponse(pdevHandlePtr, sizeof(Pdev_Request),
				 &request.hdr,
				 ioctlPtr->inBufSize, ioctlPtr->inBuffer,
				 ioctlPtr->outBufSize, ioctlPtr->outBuffer,
				 replyPtr, (Sync_RemoteWaiter *)NIL);
	}
    }

    pdevHandlePtr->flags &= ~(PDEV_BUSY|FS_USER_IN|FS_USER_OUT);
exit:
    Sync_Broadcast(&pdevHandlePtr->access);
    UNLOCK_MONITOR;
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoStreamSelect --
 *
 *	Select on a pseudo-device.  This is done by checking the stream
 *	state kept on the host of the server.  If the pseudo device isn't
 *	selectable we just return and let the server's IOC_PDEV_READY
 *	IOControl do the wakeup for us. (ie. we don't use the handle wait
 *	lists.)
 *
 * Results:
 *	SUCCESS	or FS_WOULD_BLOCK
 *
 * Side effects:
 *	*outFlagsPtr modified to indicate whether the device is
 *	readable or writable.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
FspdevPseudoStreamSelect(hdrPtr, waitPtr, readPtr, writePtr, exceptPtr)
    Fs_HandleHeader	*hdrPtr;	/* Handle on pdev to select */
    Sync_RemoteWaiter	*waitPtr;	/* Process info for remote waiting */
    int 		*readPtr;	/* Bit to clear if non-readable */
    int 		*writePtr;	/* Bit to clear if non-writeable */
    int 		*exceptPtr;	/* Bit to clear if non-exceptable */
{
    ReturnStatus status;
    register Fspdev_ClientIOHandle *cltHandlePtr = (Fspdev_ClientIOHandle *)hdrPtr;
    register Fspdev_ServerIOHandle *pdevHandlePtr = cltHandlePtr->pdevHandlePtr;

    LOCK_MONITOR;

    PDEV_TSELECT(&cltHandlePtr->hdr.fileID, *readPtr, *writePtr, *exceptPtr);

    if ((pdevHandlePtr->flags & PDEV_SERVER_GONE) ||
	(pdevHandlePtr->flags & PDEV_SETUP) == 0) {
	status = DEV_OFFLINE;
    } else {
	if (*readPtr) {
	    if (((pdevHandlePtr->readBuf.data == (Address)NIL) &&
		 ((pdevHandlePtr->selectBits & FS_READABLE) == 0)) ||
		((pdevHandlePtr->readBuf.data != (Address)NIL) &&
		 (pdevHandlePtr->flags & PDEV_READ_BUF_EMPTY))) {
		*readPtr = 0;
		if (waitPtr != (Sync_RemoteWaiter *)NIL) {
		    Fsutil_FastWaitListInsert(&pdevHandlePtr->cltReadWaitList,
					waitPtr);
		}
	    }
	}
	if (*writePtr && ((pdevHandlePtr->selectBits & FS_WRITABLE) == 0)) {
	    *writePtr = 0;
	    if (waitPtr != (Sync_RemoteWaiter *)NIL) {
		Fsutil_FastWaitListInsert(&pdevHandlePtr->cltWriteWaitList, waitPtr);
	    }
	}    
	if (*exceptPtr && ((pdevHandlePtr->selectBits & FS_EXCEPTION) == 0)) {
            *exceptPtr = 0;
	    if (waitPtr != (Sync_RemoteWaiter *)NIL) {
		Fsutil_FastWaitListInsert(&pdevHandlePtr->cltExceptWaitList,waitPtr);
	    }
	}
	status = SUCCESS;
    }
    UNLOCK_MONITOR;
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * PdevClientNotify --
 *
 *	Wakeup any processes selecting or blocking on the pseudo-stream.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

INTERNAL static void
PdevClientNotify(pdevHandlePtr)
    Fspdev_ServerIOHandle *pdevHandlePtr;
{
    register int selectBits = pdevHandlePtr->selectBits;

    PDEV_WAKEUP(&pdevHandlePtr->hdr.fileID, pdevHandlePtr->clientPID,
		pdevHandlePtr->selectBits);
    if (selectBits & FS_READABLE) {
	Fsutil_FastWaitListNotify(&pdevHandlePtr->cltReadWaitList);
    }
    if (selectBits & FS_WRITABLE) {
	Fsutil_FastWaitListNotify(&pdevHandlePtr->cltWriteWaitList);
    }
    if (selectBits & FS_EXCEPTION) {
	Fsutil_FastWaitListNotify(&pdevHandlePtr->cltExceptWaitList);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * FspdevPseudoStreamCloseInt --
 *
 *	Do a close request-response with the server.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ENTRY void
FspdevPseudoStreamCloseInt(pdevHandlePtr)
    register Fspdev_ServerIOHandle *pdevHandlePtr;
{
    Pdev_Request	request;

    LOCK_MONITOR;

    while (pdevHandlePtr->flags & PDEV_BUSY) {
	if ((pdevHandlePtr->flags & PDEV_SERVER_GONE) == 0) {
	    (void)Sync_Wait(&pdevHandlePtr->access, FALSE);
	}
	if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	    goto exit;
	}
    }
    pdevHandlePtr->flags |= PDEV_BUSY;
    /*
     * Someday we could set up a timeout call-back here in case
     * the server never replies.
     */
    request.hdr.operation = PDEV_CLOSE;
    (void) RequestResponse(pdevHandlePtr, sizeof(Pdev_Request), &request.hdr,
		    0, (Address)NIL, 0, (Address)NIL, (Fs_IOReply *) NIL,
		    (Sync_RemoteWaiter *)NIL);
    pdevHandlePtr->flags &= ~(PDEV_BUSY|FS_USER);
exit:
    Sync_LockClear(&pdevHandlePtr->lock);
    Sync_Broadcast(&pdevHandlePtr->access);
    UNLOCK_MONITOR;
}
@


9.7
log
@ Allow execution of PFS files
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fspdevSrv.c,v 9.6 91/03/30 17:12:51 mgbaker Exp $ SPRITE (Berkeley)";
a52 5

/*
 * Prevent tracing by defining CLEAN here before this next include
 */
#undef CLEAN
a590 1
	PDEV_TRACE(&pdevHandlePtr->hdr.fileID, PDEVT_SRV_READ_WAIT);
a596 1
	PDEV_TRACE(&pdevHandlePtr->hdr.fileID, PDEVT_SRV_READ);
a1289 5
#ifdef SOSP91
ReturnStatus
FspdevServerStreamClose(streamPtr, clientID, procID, flags, size, data, 
    offsetPtr, rwFlagsPtr)
#else
a1291 1
#endif
a1297 4
#ifdef SOSP91
    int			*offsetPtr;
    int			*rwFlagsPtr;
#endif
a1318 4
#ifdef SOSP91
	(void)FspdevControlClose(&dummy, clientID, procID, flags, 0, 
	    (ClientData)NIL, (int *) NIL, (int *) NIL);
#else
a1319 1
#endif
a1944 5
	    PDEV_TRACE(&pdevHandlePtr->hdr.fileID, PDEVT_READ_WAIT);
	    DBG_PRINT( ("PDEV %x,%x Read (%d) Blocked\n", 
		    streamPtr->ioHandlePtr->fileID.major,
		    streamPtr->ioHandlePtr->fileID.minor,
		    readPtr->length) );
@


9.7.1.1
log
@Initial branch for Sprite server.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fspdev/fspdevSrv.c,v 9.7 91/06/26 01:06:56 mottsmth Exp $ SPRITE (Berkeley)";
@


9.6
log
@Included another header file.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fspdevSrv.c,v 9.5 90/12/06 21:56:28 jhh Exp Locker: mgbaker $ SPRITE (Berkeley)";
d62 1
a62 1
 * Access to FspdevServerIOHandle is monitored to serialize access to
d117 1
a117 1
	FspdevServerIOHandle *pdevHandlePtr,
d121 2
a122 2
static void PdevClientWakeup _ARGS_((FspdevServerIOHandle *pdevHandlePtr));
static void PdevClientNotify _ARGS_((FspdevServerIOHandle *pdevHandlePtr));
d151 1
a151 1
    register FspdevServerIOHandle *pdevHandlePtr;	/* Caller should lock this
d182 1
a182 1
    if ((pdevHandlePtr == (FspdevServerIOHandle *)NIL) ||
d400 1
a400 1
 *	This creates a FspdevServerIOHandle that has all the state for the
d414 1
a414 1
FspdevServerIOHandle *
d421 1
a421 1
    register FspdevServerIOHandle *pdevHandlePtr;
d425 1
a425 1
    found = Fsutil_HandleInstall(ioFileIDPtr, sizeof(FspdevServerIOHandle), name,
d427 1
a427 1
    pdevHandlePtr = (FspdevServerIOHandle *)hdrPtr;
d433 1
a433 1
	return((FspdevServerIOHandle *)NIL);
d488 1
a488 1
    pdevHandlePtr->ctrlHandlePtr = (FspdevControlIOHandle *)NIL;
d525 1
a525 1
    register FspdevServerIOHandle	*pdevHandlePtr = (FspdevServerIOHandle *)hdrPtr;
d571 2
a572 2
    register FspdevServerIOHandle *pdevHandlePtr =
	    (FspdevServerIOHandle *)streamPtr->ioHandlePtr;
d678 2
a679 2
    register FspdevServerIOHandle	*pdevHandlePtr =
	    (FspdevServerIOHandle *)streamPtr->ioHandlePtr;
d1243 1
a1243 1
    FspdevControlIOHandle *ctrlHandlePtr;
d1316 2
a1317 2
    register FspdevServerIOHandle *pdevHandlePtr =
	    (FspdevServerIOHandle *)streamPtr->ioHandlePtr;
d1328 1
a1328 1
	register FspdevControlIOHandle *ctrlHandlePtr;
d1371 1
a1371 1
    FspdevServerIOHandle *pdevHandlePtr;	/* State for the pseudo stream */
d1411 1
a1411 1
    FspdevServerIOHandle *pdevHandlePtr;	/* State for the pseudo stream */
d1446 1
a1446 1
    register FspdevServerIOHandle *pdevHandlePtr;	/* Pdev connection state */
d1522 1
a1522 1
    register FspdevServerIOHandle *pdevHandlePtr;	/* Pdev connection state */
d1613 1
a1613 1
    register FspdevServerIOHandle *pdevHandlePtr;	/* Pdev connection state */
d1691 1
a1691 1
    FspdevClientIOHandle		*cltHandlePtr;
d1693 1
a1693 1
    register FspdevServerIOHandle	*pdevHandlePtr;
d1696 2
a1697 2
    cltHandlePtr = Fsutil_HandleFetchType(FspdevClientIOHandle, fileIDPtr);
    if (cltHandlePtr == (FspdevClientIOHandle *)NIL) {
d1761 1
a1761 1
    FspdevClientIOHandle		*cltHandlePtr;
d1763 1
a1763 1
    register FspdevServerIOHandle	*pdevHandlePtr;
d1766 2
a1767 2
    cltHandlePtr = Fsutil_HandleFetchType(FspdevClientIOHandle, fileIDPtr);
    if (cltHandlePtr == (FspdevClientIOHandle *)NIL) {
d1826 2
a1827 2
    FspdevClientIOHandle		*cltHandlePtr;
    register FspdevServerIOHandle	*pdevHandlePtr;
d1829 2
a1830 2
    cltHandlePtr = Fsutil_HandleFetchType(FspdevClientIOHandle, fileIDPtr);
    if (cltHandlePtr == (FspdevClientIOHandle *)NIL) {
d1868 2
a1869 2
    FspdevClientIOHandle		*cltHandlePtr;
    register FspdevServerIOHandle	*pdevHandlePtr;
d1871 2
a1872 2
    cltHandlePtr = Fsutil_HandleFetchType(FspdevClientIOHandle, fileIDPtr);
    if (cltHandlePtr == (FspdevClientIOHandle *)NIL) {
d1923 3
a1925 3
    register FspdevClientIOHandle *cltHandlePtr =
	    (FspdevClientIOHandle *)streamPtr->ioHandlePtr;
    register FspdevServerIOHandle *pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
d2095 3
a2097 3
    register FspdevClientIOHandle *cltHandlePtr =
	    (FspdevClientIOHandle *)streamPtr->ioHandlePtr;
    register FspdevServerIOHandle *pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
d2255 3
a2257 3
    register FspdevClientIOHandle *cltHandlePtr =
	    (FspdevClientIOHandle *)streamPtr->ioHandlePtr;
    register FspdevServerIOHandle *pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
d2410 2
a2411 2
    register FspdevClientIOHandle *cltHandlePtr = (FspdevClientIOHandle *)hdrPtr;
    register FspdevServerIOHandle *pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
d2470 1
a2470 1
    FspdevServerIOHandle *pdevHandlePtr;
d2505 1
a2505 1
    register FspdevServerIOHandle *pdevHandlePtr;
@


9.5
log
@Added sosp tracing code
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fspdevSrv.c,v 9.4 90/10/08 12:47:07 mendel Exp $ SPRITE (Berkeley)";
d39 1
@


9.4
log
@Fixed include files to use <> rather than "".
Added function prototypes.
Fixed lint.
Changed fsutil_TimeInSeconds to macro Fsutil_TimeInSeconds().
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fsPdev.c,v 9.3 90/07/30 11:39:15 shirriff Exp $ SPRITE (Berkeley)";
d1296 1
d1298 4
d1303 1
d1310 4
d1335 4
d1340 1
@


9.3
log
@Added address field to Sig_Send call.
Also some changes for offline devices that I didn't make, but presumably
should be checked in.
@
text
@d2 1
a2 1
 * fsPdev.c --  
d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fsPdev.c,v 9.1 89/10/23 09:52:30 brent Exp $ SPRITE (Berkeley)";
d39 13
a51 12
#include "sprite.h"
#include "fs.h"
#include "fsutil.h"
#include "fsNameOps.h"
#include "fsio.h"
#include "fsconsist.h"
#include "fsioLock.h"
#include "fsdm.h"
#include "fsStat.h"
#include "fspdev.h"
#include "proc.h"
#include "rpc.h"
d57 2
a58 2
#include "fspdevInt.h"
#include "dev/pfs.h"
d115 7
a121 4
static	ReturnStatus		RequestResponse();
static	void			PdevClientWakeup();
static	void			PdevClientNotify();
void				FsRmtPseudoStreamClose();
d425 1
a425 1
			    &hdrPtr);
d1296 1
d2029 1
a2029 1
	pdevHandlePtr->ctrlHandlePtr->accessTime = fsutil_TimeInSeconds;
d2193 1
a2193 1
	pdevHandlePtr->ctrlHandlePtr->modifyTime = fsutil_TimeInSeconds;
@


9.2
log
@trying to fix pdev open hanging problem.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fsPdev.c,v 9.1 89/10/23 09:52:30 brent Exp Locker: douglis $ SPRITE (Berkeley)";
d1261 1
a1261 1
		 (ownerPtr->procOrFamily == IOC_OWNER_FAMILY));
d1439 2
a1440 3
     * the routines that call RequestResponse.  But, for opening the pdev,
     * if the stream isn't set up yet, we should just fail rather than
     * hanging indefinitely.
a1441 4
    if ((pdevHandlePtr->flags & PDEV_SETUP) == 0) {
	status = DEV_OFFLINE;
	goto exit;
    }
@


9.1
log
@Added protection against the server returning too much data.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fsPdev.c,v 9.0 89/09/12 15:08:00 douglis Stable Locker: brent $ SPRITE (Berkeley)";
d1439 3
a1441 2
     * the routines that call RequestResponse.  PDEV_BUSY is cleared after
     * the server initializes the request buffer with IOC_PDEV_SETUP.
d1443 4
@


9.0
log
@Changing version numbers.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fspdev/RCS/fsPdev.c,v 8.27 89/08/21 15:27:35 mendel Exp Locker: douglis $ SPRITE (Berkeley)";
d219 2
a220 1
	printf("RequestResponse request too large\n");
d350 1
d381 2
d922 11
d984 1
@


8.27
log
@Break up fs into many modules.    
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.24 89/08/12 10:44:51 jhh Exp $ SPRITE (Berkeley)";
@


8.26
log
@Changed to use Fmt_Convert
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.25 89/08/17 12:13:20 brent Exp Locker: jhh $ SPRITE (Berkeley)";
d41 6
a46 8
#include "fsInt.h"
#include "fsOpTable.h"
#include "fsFile.h"
#include "fsStream.h"
#include "fsClient.h"
#include "fsMigrate.h"
#include "fsLock.h"
#include "fsDisk.h"
d48 1
d56 1
a56 1
#include "fsPdev.h"
d60 1
a60 1
 * Access to PdevServerIOHandle is monitored to serialize access to
d146 1
a146 1
    register PdevServerIOHandle *pdevHandlePtr;	/* Caller should lock this
d177 1
a177 1
    if ((pdevHandlePtr == (PdevServerIOHandle *)NIL) ||
d337 1
a337 1
    FsFastWaitListNotify(&pdevHandlePtr->srvReadWaitList);
d388 1
a388 1
 * FsServerStreamCreate --
d391 1
a391 1
 *	This creates a PdevServerIOHandle that has all the state for the
d405 2
a406 2
PdevServerIOHandle *
FsServerStreamCreate(ioFileIDPtr, name, naming)
d411 2
a412 2
    FsHandleHeader *hdrPtr;
    register PdevServerIOHandle *pdevHandlePtr;
d415 2
a416 2
    ioFileIDPtr->type = FS_SERVER_STREAM;
    found = FsHandleInstall(ioFileIDPtr, sizeof(PdevServerIOHandle), name,
d418 1
a418 1
    pdevHandlePtr = (PdevServerIOHandle *)hdrPtr;
d423 2
a424 2
	FsHandleRelease(pdevHandlePtr, TRUE);
	return((PdevServerIOHandle *)NIL);
d426 1
a426 1
    fsStats.object.pseudoStreams++;
d479 1
a479 1
    pdevHandlePtr->ctrlHandlePtr = (PdevControlIOHandle *)NIL;
d492 1
a492 1
 * FsServerStreamSelect --
d509 2
a510 2
FsServerStreamSelect(hdrPtr, waitPtr, readPtr, writePtr, exceptPtr)
    FsHandleHeader	*hdrPtr;	/* Handle on device to select */
d516 1
a516 1
    register PdevServerIOHandle	*pdevHandlePtr = (PdevServerIOHandle *)hdrPtr;
d526 1
a526 1
		FsFastWaitListInsert(&pdevHandlePtr->srvReadWaitList, waitPtr);
d539 1
a539 1
 * FsServerStreamRead --
d555 1
a555 1
FsServerStreamRead(streamPtr, readPtr, waitPtr, replyPtr)
d562 2
a563 2
    register PdevServerIOHandle *pdevHandlePtr =
	    (PdevServerIOHandle *)streamPtr->ioHandlePtr;
d586 1
a586 1
	FsFastWaitListInsert(&pdevHandlePtr->srvReadWaitList, waitPtr);
d642 1
a642 1
 * FsServerStreamIOControl --
d663 1
a663 1
FsServerStreamIOControl(streamPtr, ioctlPtr, replyPtr)
d669 2
a670 2
    register PdevServerIOHandle	*pdevHandlePtr =
	    (PdevServerIOHandle *)streamPtr->ioHandlePtr;
d834 1
a834 1
		    printf("FsServerStreamIOControl: set bad readPtr\n");
d879 1
a879 1
		FsFastWaitListNotify(&pdevHandlePtr->cltReadWaitList);
d975 1
a975 1
			FsFastWaitListInsert(&pdevHandlePtr->cltReadWaitList,
d978 1
a978 1
			FsFastWaitListInsert(&pdevHandlePtr->cltWriteWaitList,
d1015 1
a1015 1
	    status = FsPdevSignalOwner(pdevHandlePtr->ctrlHandlePtr, ioctlPtr);
d1025 1
a1025 1
	     * To finish up, we set up the FsOpenResults that the waiting
d1030 1
a1030 1
	    FsOpenResults openResults;		/* For the client */
d1040 1
a1040 1
		newStreamID = FsPfsOpenConnection(pdevHandlePtr,
d1053 1
a1053 1
		     * kernel stack (it's waiting in FsPfsOpen on this
d1056 2
a1057 2
		    register FsOpenResults *openResultsPtr =
			    (FsOpenResults *)pdevHandlePtr->replyBuf;
d1065 1
a1065 1
		pdevHandlePtr->reply.replySize = sizeof(FsOpenResults);
d1094 1
a1094 1
	    FsOpenResults openResults;		/* For the client */
d1098 1
a1098 1
	    register FsOpenResults *openResultsPtr;
d1109 1
a1109 1
		status = FsGetStreamPtr(procPtr, passedStreamID, &streamPtr);
d1113 1
a1113 1
		    status = Fs_EncapStream(streamPtr, encapStream);
d1119 2
a1120 2
			bzero((char *)&openResults, sizeof(FsOpenResults));
			openResults.ioFileID.type = FS_PASSING_STREAM;
d1125 1
a1125 1
				(FsOpenResults *)pdevHandlePtr->replyBuf;
d1134 1
a1134 1
		pdevHandlePtr->reply.replySize = sizeof(FsOpenResults);
d1206 1
a1206 1
 * FsPdevSignalOwner --
d1221 2
a1222 2
FsPdevSignalOwner(ctrlHandlePtr, ioctlPtr)
    PdevControlIOHandle *ctrlHandlePtr;
d1255 1
a1255 1
 * FsServerStreamClose --
d1276 1
a1276 1
FsServerStreamClose(streamPtr, clientID, procID, flags, size, data)
d1284 2
a1285 2
    register PdevServerIOHandle *pdevHandlePtr =
	    (PdevServerIOHandle *)streamPtr->ioHandlePtr;
d1296 1
a1296 1
	register PdevControlIOHandle *ctrlHandlePtr;
d1301 4
a1304 4
	dummy.ioHandlePtr = (FsHandleHeader *)ctrlHandlePtr;
	FsHandleLock(ctrlHandlePtr);
	FsPrefixHandleClose(ctrlHandlePtr->prefixPtr, FS_ANY_PREFIX);
	(void)FsControlClose(&dummy, clientID, procID, flags, 0, (ClientData)NIL);
d1307 3
a1309 3
    FsHandleRelease(pdevHandlePtr, TRUE);
    FsHandleRemove(pdevHandlePtr);	/* No need for scavenging */
    fsStats.object.pseudoStreams--;
d1334 1
a1334 1
    PdevServerIOHandle *pdevHandlePtr;	/* State for the pseudo stream */
d1346 14
a1359 14
    FsFastWaitListNotify(&pdevHandlePtr->cltReadWaitList);
    FsFastWaitListNotify(&pdevHandlePtr->cltWriteWaitList);
    FsFastWaitListNotify(&pdevHandlePtr->cltExceptWaitList);
    FsWaitListDelete(&pdevHandlePtr->cltReadWaitList);
    FsWaitListDelete(&pdevHandlePtr->cltWriteWaitList);
    FsWaitListDelete(&pdevHandlePtr->cltExceptWaitList);
    FsWaitListDelete(&pdevHandlePtr->srvReadWaitList);
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * FsPdevServerOK --
d1361 1
a1361 1
 *	Called from FsPfsExport to see if the server of a prefix still exists.
d1373 2
a1374 2
FsPdevServerOK(pdevHandlePtr)
    PdevServerIOHandle *pdevHandlePtr;	/* State for the pseudo stream */
d1391 1
a1391 1
 * FsPseudoStreamOpen --
d1408 2
a1409 2
FsPseudoStreamOpen(pdevHandlePtr, flags, clientID, procID, userID)
    register PdevServerIOHandle *pdevHandlePtr;	/* Pdev connection state */
d1461 1
a1461 1
 * FsPseudoStreamLookup --
d1483 1
a1483 1
FsPseudoStreamLookup(pdevHandlePtr, requestPtr, argSize, argsPtr,
d1485 1
a1485 1
    register PdevServerIOHandle *pdevHandlePtr;	/* Pdev connection state */
d1491 2
a1492 2
					 * FsRedirectInfo */
    FsRedirectInfo	**newNameInfoPtrPtr;/* Set if server returns name */
d1495 1
a1495 1
    FsRedirectInfo		redirectInfo;	/* This is a large buffer
d1503 1
a1503 1
    *newNameInfoPtrPtr = (FsRedirectInfo *)NIL;
d1518 1
a1518 1
		&requestPtr->hdr, argSize, argsPtr, sizeof(FsRedirectInfo),
d1522 1
a1522 1
	*newNameInfoPtrPtr = mnew(FsRedirectInfo);
d1552 1
a1552 1
 * FsPseudoStream2Path --
d1574 1
a1574 1
FsPseudoStream2Path(pdevHandlePtr, requestPtr, dataPtr, name1ErrorPtr,
d1576 1
a1576 1
    register PdevServerIOHandle *pdevHandlePtr;	/* Pdev connection state */
d1578 1
a1578 1
    Fs2PathData		*dataPtr;	/* 2 pathnames */
d1580 1
a1580 1
    FsRedirectInfo	**newNameInfoPtrPtr;/* Set if server returns name */
d1583 1
a1583 1
    Fs2PathRedirectInfo		redirectInfo;
d1600 2
a1601 2
		&requestPtr->hdr, sizeof(Fs2PathData), (Address)dataPtr,
		sizeof(Fs2PathRedirectInfo), (Address)&redirectInfo,
d1604 1
a1604 1
	*newNameInfoPtrPtr = mnew(FsRedirectInfo);
d1631 1
a1631 1
 * FsPseudoGetAttr --
d1648 1
a1648 1
FsPseudoGetAttr(fileIDPtr, clientID, attrPtr)
d1654 1
a1654 1
    PdevClientIOHandle		*cltHandlePtr;
d1656 1
a1656 1
    register PdevServerIOHandle	*pdevHandlePtr;
d1659 4
a1662 4
    cltHandlePtr = FsHandleFetchType(PdevClientIOHandle, fileIDPtr);
    if (cltHandlePtr == (PdevClientIOHandle *)NIL) {
	printf( "FsPseudoGetAttr, no %s handle <%d,%x,%x>\n",
	    FsFileTypeToString(fileIDPtr->type), fileIDPtr->serverID,
d1666 1
a1666 1
    FsHandleRelease(cltHandlePtr, TRUE);
d1702 1
a1702 1
 * FsPseudoSetAttr --
d1718 1
a1718 1
FsPseudoSetAttr(fileIDPtr, attrPtr, idPtr, flags)
d1724 1
a1724 1
    PdevClientIOHandle		*cltHandlePtr;
d1726 1
a1726 1
    register PdevServerIOHandle	*pdevHandlePtr;
d1729 3
a1731 3
    cltHandlePtr = FsHandleFetchType(PdevClientIOHandle, fileIDPtr);
    if (cltHandlePtr == (PdevClientIOHandle *)NIL) {
	printf( "FsPseudoSetAttr, no handle <%d,%d,%x,%x>\n",
d1736 1
a1736 1
    FsHandleRelease(cltHandlePtr, TRUE);
d1768 1
a1768 1
 * FsPseudoStreamGetIOAttr --
d1783 1
a1783 1
FsPseudoStreamGetIOAttr(fileIDPtr, clientID, attrPtr)
d1789 2
a1790 2
    PdevClientIOHandle		*cltHandlePtr;
    register PdevServerIOHandle	*pdevHandlePtr;
d1792 4
a1795 4
    cltHandlePtr = FsHandleFetchType(PdevClientIOHandle, fileIDPtr);
    if (cltHandlePtr == (PdevClientIOHandle *)NIL) {
	printf( "FsPseudoStreamGetIOAttr, no %s handle <%d,%x,%x> client %d\n",
	    FsFileTypeToString(fileIDPtr->type), fileIDPtr->serverID,
d1799 1
a1799 1
    FsHandleRelease(cltHandlePtr, TRUE);
d1813 1
a1813 1
 * FsPseudoStreamSetIOAttr --
d1826 1
a1826 1
FsPseudoStreamSetIOAttr(fileIDPtr, attrPtr, flags)
d1831 2
a1832 2
    PdevClientIOHandle		*cltHandlePtr;
    register PdevServerIOHandle	*pdevHandlePtr;
d1834 3
a1836 3
    cltHandlePtr = FsHandleFetchType(PdevClientIOHandle, fileIDPtr);
    if (cltHandlePtr == (PdevClientIOHandle *)NIL) {
	printf( "FsPseudoStreamSetIOAttr, no handle <%d,%d,%x,%x>\n",
d1841 1
a1841 1
    FsHandleRelease(cltHandlePtr, TRUE);
d1855 1
a1855 1
 * FsPseudoStreamRead --
d1878 1
a1878 1
FsPseudoStreamRead(streamPtr, readPtr, waitPtr, replyPtr)
d1886 3
a1888 3
    register PdevClientIOHandle *cltHandlePtr =
	    (PdevClientIOHandle *)streamPtr->ioHandlePtr;
    register PdevServerIOHandle *pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
d1929 1
a1929 1
	    FsFastWaitListInsert(&pdevHandlePtr->cltReadWaitList, waitPtr);
d1944 1
a1944 1
		panic("FsPseudoStreamRead, dataAvail in read buf <= 0 bytes\n");
d1983 1
a1983 1
	    FsFastWaitListNotify(&pdevHandlePtr->srvReadWaitList);
d2003 1
a2003 1
	FsFastWaitListInsert(&pdevHandlePtr->cltReadWaitList, waitPtr);
d2008 1
a2008 1
	pdevHandlePtr->ctrlHandlePtr->accessTime = fsTimeInSeconds;
d2028 1
a2028 1
 * FsPseudoStreamWrite --
d2052 1
a2052 1
FsPseudoStreamWrite(streamPtr, writePtr, waitPtr, replyPtr)
d2058 3
a2060 3
    register PdevClientIOHandle *cltHandlePtr =
	    (PdevClientIOHandle *)streamPtr->ioHandlePtr;
    register PdevServerIOHandle *pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
d2116 1
a2116 1
	FsFastWaitListInsert(&pdevHandlePtr->cltWriteWaitList, waitPtr);
d2166 2
a2167 2
	printf("FsPseudoStreamWrite: \"%s\" amount written (%d) > requested (%d)\n",
	    FsHandleName(streamPtr->ioHandlePtr), amountWritten, totalToWrite);
d2172 1
a2172 1
	pdevHandlePtr->ctrlHandlePtr->modifyTime = fsTimeInSeconds;
d2195 1
a2195 1
 * FsPseudoStreamIOControl --
d2211 1
a2211 1
FsPseudoStreamIOControl(streamPtr, ioctlPtr, replyPtr)
d2218 3
a2220 3
    register PdevClientIOHandle *cltHandlePtr =
	    (PdevClientIOHandle *)streamPtr->ioHandlePtr;
    register PdevServerIOHandle *pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
d2346 1
a2346 1
 * FsPseudoStreamSelect --
d2365 2
a2366 2
FsPseudoStreamSelect(hdrPtr, waitPtr, readPtr, writePtr, exceptPtr)
    FsHandleHeader	*hdrPtr;	/* Handle on pdev to select */
d2373 2
a2374 2
    register PdevClientIOHandle *cltHandlePtr = (PdevClientIOHandle *)hdrPtr;
    register PdevServerIOHandle *pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
d2391 1
a2391 1
		    FsFastWaitListInsert(&pdevHandlePtr->cltReadWaitList,
d2399 1
a2399 1
		FsFastWaitListInsert(&pdevHandlePtr->cltWriteWaitList, waitPtr);
d2405 1
a2405 1
		FsFastWaitListInsert(&pdevHandlePtr->cltExceptWaitList,waitPtr);
d2433 1
a2433 1
    PdevServerIOHandle *pdevHandlePtr;
d2440 1
a2440 1
	FsFastWaitListNotify(&pdevHandlePtr->cltReadWaitList);
d2443 1
a2443 1
	FsFastWaitListNotify(&pdevHandlePtr->cltWriteWaitList);
d2446 1
a2446 1
	FsFastWaitListNotify(&pdevHandlePtr->cltExceptWaitList);
d2453 1
a2453 1
 * FsPseudoStreamCloseInt --
d2467 2
a2468 2
FsPseudoStreamCloseInt(pdevHandlePtr)
    register PdevServerIOHandle *pdevHandlePtr;
@


8.25
log
@Added check against a pseudo-device-server reporting that
it wrote more than we asked for.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.24 89/08/12 10:44:51 jhh Exp $ SPRITE (Berkeley)";
a51 1
#include "swapBuffer.h"
d675 2
a676 2
    if (ioctlPtr->byteOrder != mach_ByteOrder) {
	panic("FsServerStreamIOControl: wrong byte order\n");
d2268 1
a2268 1
	} else if (ioctlPtr->byteOrder != mach_ByteOrder) {
d2270 9
a2278 3
	    Swap_Buffer((Address)&bytesAvail, sizeof(int),
		mach_ByteOrder, ioctlPtr->byteOrder, "w", ioctlPtr->outBuffer,
		&size);
@


8.24
log
@Added IOC_PREFIX handler.
Fixed Pseudo stream operations so they only set the access and
modify times upon successful operation.  It turns out that recovery
triggers a blocking read operation on rlogin pseudo-devices,
so this was resetting the access (and implied idle) time of
the rlogin connections.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.23 89/08/01 20:38:59 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
d2068 1
d2141 1
d2166 5
@


8.23
log
@pdev locks were not cleared before they were freed
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.22 89/07/18 13:08:22 jhh Exp $ SPRITE (Berkeley)";
d1194 1
a1194 9
	case IOC_PREFIX: {
	    FsPrefix	*prefixPtr;
	    prefixPtr = streamPtr->nameInfoPtr->prefixPtr;
	    if (ioctlPtr->outBufSize < prefixPtr->prefixLength) {
		status = GEN_INVALID_ARG;
		break;
	    }
	    strcpy(ioctlPtr->outBuffer, prefixPtr->prefix);
	    replyPtr->length = prefixPtr->prefixLength;
a1196 1
	}
d1305 1
a1305 1
	FsPrefixHandleClose(ctrlHandlePtr->prefixPtr);
d2009 3
a2011 1
    pdevHandlePtr->ctrlHandlePtr->accessTime = fsTimeInSeconds;
d2166 3
a2168 1
    pdevHandlePtr->ctrlHandlePtr->modifyTime = fsTimeInSeconds;
d2307 1
a2307 13
	    case IOC_PREFIX: {
		/* 
		 * We handle the prefix request since the prefix is in the
		 * Sprite domain. 
		 */
		FsPrefix	*prefixPtr;
		prefixPtr = streamPtr->nameInfoPtr->prefixPtr;
		if (ioctlPtr->outBufSize < prefixPtr->prefixLength) {
		    status = GEN_INVALID_ARG;
		    break;
		}
		strcpy(ioctlPtr->outBuffer, prefixPtr->prefix);
		replyPtr->length = prefixPtr->prefixLength;
a2310 1
	    }
@


8.22
log
@Added IOC_PREFIX ioctl
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.21 89/07/08 18:39:50 brent Exp $ SPRITE (Berkeley)";
d2500 1
@


8.21
log
@Eliminated noisey printf
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.20 89/06/30 15:29:06 brent Exp $ SPRITE (Berkeley)";
d1194 12
d2221 1
d2251 1
d2312 17
d2330 1
a2330 1
	if (status == SUCCESS) {
@


8.20
log
@Fixed bug in FsPseudoDomainLookup regarding the redirect buffer.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.19 89/06/21 12:32:56 mendel Exp $ SPRITE (Berkeley)";
a2154 2
	    printf("Pdev_Write, no return amtWritten (%s)\n",
		    FsHandleName(pdevHandlePtr));
@


8.19
log
@Fixed use of FS_USER_IN and FS_USER_OUT
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.18 89/06/16 12:07:12 brent Exp $ SPRITE (Berkeley)";
d1502 2
a1527 1
	*newNameInfoPtrPtr = (FsRedirectInfo *)NIL;
@


8.18
log
@Updated I/O Control interface
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.16 89/06/15 09:21:00 brent Exp $ SPRITE (Berkeley)";
d1992 1
a1992 1
	    pdevHandlePtr->flags |= FS_USER_IN;
d2014 1
a2014 1
    pdevHandlePtr->flags &= ~(PDEV_BUSY|FS_USER_IN);
d2078 1
a2078 1
	pdevHandlePtr->flags |= FS_USER_OUT;
d2174 1
a2174 1
    pdevHandlePtr->flags &= ~(PDEV_BUSY|FS_USER_OUT);
@


8.17
log
@Nuked tracing print statement
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.16 89/06/15 09:21:00 brent Exp Locker: brent $ SPRITE (Berkeley)";
d94 2
a95 2
 *	FS_USER			This flag is borrowed from the stream flags
 *				and it indicates the buffers are in user space
d109 2
a110 1
/*resrv FS_USER			0x8000 */
d314 1
a314 1
			(pdevHandlePtr->flags & FS_USER) == 0, serverProcPtr,
d665 1
a665 1
FsServerStreamIOControl(streamPtr, command, byteOrder, inBufPtr, outBufPtr)
d667 2
a668 4
    int		command;	/* The control operation to be performed. */
    int		byteOrder;	/* Client's byte order, should be same */
    Fs_Buffer *inBufPtr;	/* Command inputs */
    Fs_Buffer *outBufPtr;	/* Buffer for return parameters */
d676 2
a677 2
    if (byteOrder != mach_ByteOrder) {
	panic( "FsServerStreamIOControl: wrong byte order\n");
d679 1
a679 1
    switch (command) {
d695 1
a695 2
		    (Pdev_SetBufArgs *)inBufPtr->addr;
	    register Proc_ControlBlock *procPtr;
d698 1
a698 1
	    if (inBufPtr->size != sizeof(Pdev_SetBufArgs)) {
d733 1
a733 2
		procPtr = Proc_GetEffectiveProc();
		pdevHandlePtr->serverPID = procPtr->processID;
d763 1
a763 1
	    if (inBufPtr->size < sizeof(Boolean)) {
d766 1
a766 1
		writeBehind = *(Boolean *)inBufPtr->addr;
d781 1
a781 1
	    if (inBufPtr->size < sizeof(Boolean)) {
d784 1
a784 1
		allowLargeWrites = *(Boolean *)inBufPtr->addr;
d805 2
a806 2
	    register Pdev_BufPtrs *argPtr = (Pdev_BufPtrs *)inBufPtr->addr;
	    if (inBufPtr->size != sizeof(Pdev_BufPtrs)) {
d896 1
a896 1
	    register Pdev_Reply *srvReplyPtr = (Pdev_Reply *)inBufPtr->addr;
d898 1
a898 1
	    if (inBufPtr->size < sizeof(Pdev_Reply)) {
d921 1
a921 6
		     * Copy the reply into the waiting buffers.  PDEV_WRITE is
		     * handled specially because the reply buffer is just an
		     * integer variable in the kernel, while the input buffer
		     * is in user space, which is indicated by the FS_USER flag.
		     *  - To be fully general we'd need a user space flag for
		     * 	both the input buffer and the reply.
d923 1
a923 1
		    if ((command == IOC_PDEV_SMALL_REPLY) &&
d925 1
a925 1
			 (inBufPtr->size <
d929 5
a933 3
			if (((pdevHandlePtr->flags & FS_USER) == 0) ||
			    (pdevHandlePtr->operation == PDEV_WRITE)) {
			    if (command == IOC_PDEV_SMALL_REPLY) {
d944 4
d951 1
a951 1
				if (command == IOC_PDEV_SMALL_REPLY) {
d1000 1
a1000 1
	    if (inBufPtr->size != sizeof(int)) {
d1007 1
a1007 1
		pdevHandlePtr->selectBits = *(int *)inBufPtr->addr;
d1017 1
a1017 1
	    status = FsPdevSignalOwner(pdevHandlePtr->ctrlHandlePtr, inBufPtr);
d1034 2
a1035 2
	    if (inBufPtr->size < sizeof(Fs_FileID) ||
		outBufPtr->size < sizeof(int)) {
d1043 2
a1044 2
			    (Fs_FileID *)inBufPtr->addr, &openResults);
		if (outBufPtr->flags & FS_USER) {
d1046 1
a1046 1
				outBufPtr->addr);
d1048 1
a1048 1
		    *(int *)outBufPtr->addr = newStreamID;
d1082 1
a1082 1
	    if (inBufPtr->size < sizeof(Fs_FileID)) {
d1085 1
a1085 1
		fileIDPtr = (Fs_FileID *)inBufPtr->addr;
d1102 1
a1102 1
	    if (inBufPtr->size < sizeof(int)) {
d1109 1
a1109 1
		passedStreamID = *(int *)inBufPtr->addr;
d1185 2
a1186 2
	    if (outBufPtr->addr == (Address)NIL ||
		outBufPtr->size < sizeof(int)) {
d1189 1
a1189 1
		*(int *)outBufPtr->addr = numReadable;
a1197 5
#ifdef notdef
    if (status != SUCCESS) {
	printf("PdevServer IOControl #%x returning %x\n", command, status);
    }
#endif notdef
d1220 1
a1220 1
FsPdevSignalOwner(ctrlHandlePtr, inBufPtr)
d1222 1
a1222 1
    Fs_Buffer *inBufPtr;
d1234 1
a1234 2
    } else if (inBufPtr == (Fs_Buffer *)NIL ||
	inBufPtr->size != sizeof(Pdev_Signal)) {
d1239 1
a1239 1
	sigPtr = (Pdev_Signal *)inBufPtr->addr;
d1446 1
a1446 1
    pdevHandlePtr->flags &= ~FS_USER;
d1513 1
a1513 1
    pdevHandlePtr->flags &= ~FS_USER;
d1596 1
a1596 1
    pdevHandlePtr->flags &= ~FS_USER;
d1678 1
a1678 1
    pdevHandlePtr->flags &= ~FS_USER;
d1748 1
a1748 1
    pdevHandlePtr->flags &= ~FS_USER;
a1886 1
    register Ioc_Owner *ownerPtr;
d1902 15
a1916 12
    /*
     * Check for access inside the owning process group.
     */
    ownerPtr = &pdevHandlePtr->ctrlHandlePtr->owner;
    if (((ownerPtr->procOrFamily == IOC_OWNER_FAMILY) &&
	 (readPtr->familyID != ownerPtr->id)) ||
	((ownerPtr->procOrFamily == IOC_OWNER_PROC) &&
	 (readPtr->procID != ownerPtr->id))) {
	printf("PdevRead: ownership conflict\n");
	status = GEN_ABORTED_BY_SIGNAL;
	replyPtr->signal = SIG_TTY_INPUT;
	goto exit;
d1991 3
a1993 1
	pdevHandlePtr->flags |= (readPtr->flags & FS_USER);
d2014 1
a2014 1
    pdevHandlePtr->flags &= ~(PDEV_BUSY|FS_USER);
a2061 1
    Ioc_Owner		*ownerPtr;
d2076 4
a2079 1
    pdevHandlePtr->flags |= (PDEV_BUSY|(writePtr->flags & FS_USER));
d2082 21
a2102 18
    /*
     * Check for access inside the owning process group.
     * (This doesn't work presently, 6/89.  We'll rely on
     * the tty driver to do this checking for us.)
     *
     * Getting 4.3 BSD semantics is tricky because the operation is
     * supposed to succeed if the TTYOUT signal is blocked. Need a
     * flag passed down from Fs_Write.
     */
    ownerPtr = &pdevHandlePtr->ctrlHandlePtr->owner;
    if (((ownerPtr->procOrFamily == IOC_OWNER_FAMILY) &&
	 (writePtr->familyID != ownerPtr->id)) ||
	((ownerPtr->procOrFamily == IOC_OWNER_PROC) &&
	 (writePtr->procID != ownerPtr->id))) {
	printf("PdevWrite: ownership conflict\n");
	status = GEN_ABORTED_BY_SIGNAL;
	replyPtr->signal = SIG_TTY_OUTPUT;
	goto exit;
d2174 1
a2174 1
    pdevHandlePtr->flags &= ~(PDEV_BUSY|FS_USER);
d2200 1
a2200 1
FsPseudoStreamIOControl(streamPtr, command, byteOrder, inBufPtr, outBufPtr)
d2202 2
a2203 4
    int		command;	/* The control operation to be performed. */
    int		byteOrder;	/* Client's byte order */
    Fs_Buffer   *inBufPtr;	/* Command inputs */
    Fs_Buffer	*outBufPtr;	/* Buffer for return parameters */
a2206 2
    Fs_IOReply		ioReply;
    register Proc_ControlBlock *procPtr;
d2231 5
a2235 4
    if ((command > IOC_GENERIC_LIMIT) &&
	(inBufPtr->flags & FS_USER) != 0) {
	pdevHandlePtr->flags |= FS_USER;

d2240 1
a2240 1
    if (command == IOC_NUM_READABLE &&
d2252 3
a2254 1
	if (byteOrder != mach_ByteOrder) {
d2257 2
a2258 1
		mach_ByteOrder, byteOrder, "w", outBufPtr->addr, &size);
a2261 2
	} else if (outBufPtr->size != sizeof(int)) {
	    status = GEN_INVALID_ARG;
d2263 1
a2263 1
	    *(int *)outBufPtr->addr = bytesAvail;
d2274 1
a2274 1
	switch(command) {
d2279 1
a2279 2
		if (inBufPtr == (Fs_Buffer *)NIL ||
		    inBufPtr->size < sizeof(Ioc_Owner)) {
d2283 1
a2283 1
			    *(Ioc_Owner *)inBufPtr->addr;
d2291 1
a2291 2
		if (outBufPtr == (Fs_Buffer *)NIL ||
		    outBufPtr->size < sizeof(Ioc_Owner)) {
d2294 1
a2294 1
		    *(Ioc_Owner *)outBufPtr->addr =
d2301 2
a2302 14
	    procPtr = Proc_GetEffectiveProc();
	    request.hdr.operation		= PDEV_IOCTL;
	    request.param.ioctl.command		= command;
	    request.param.ioctl.inBuffer	= 0;
	    request.param.ioctl.inBufSize	= inBufPtr->size;
	    request.param.ioctl.outBuffer	= 0;
	    request.param.ioctl.outBufSize	= outBufPtr->size;
	    request.param.ioctl.byteOrder	= byteOrder;
	    request.param.ioctl.procID		= procPtr->processID;
	    request.param.ioctl.familyID	= procPtr->familyID;
	    request.param.ioctl.uid		= procPtr->effectiveUserID;
	    if (procPtr->fsPtr->numGroupIDs > 0) {
		request.param.read.gid	= procPtr->fsPtr->groupIDs[0];
	    }
d2306 3
a2308 3
				 inBufPtr->size, inBufPtr->addr,
				 outBufPtr->size, outBufPtr->addr,
				 &ioReply, (Sync_RemoteWaiter *)NIL);
d2312 1
a2312 1
    pdevHandlePtr->flags &= ~(PDEV_BUSY|FS_USER);
@


8.16
log
@Updated read/write to use Fs_IOParam and Fs_IOReply
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.15 89/06/02 13:01:37 brent Exp Locker: brent $ SPRITE (Berkeley)";
a2016 3
    }
    if (replyPtr->signal != 0) {
	printf("PdevRead, signal %d\n", replyPtr->signal);
@


8.15
log
@New interface that allows signals to be returned by the server,
allows client operations to be interrupted if the server is hung,
and has new read/write/ioctl parameters.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.14 89/05/30 16:11:50 jhh Exp Locker: brent $ SPRITE (Berkeley)";
a91 2
 *	PDEV_SIGNAL_PENDING	Set when the server wants us to generate
 *				a signal in response to the request.
d108 1
a108 2
#define PDEV_SIGNAL_PENDING	0x0800
#define PDEV_REQUEST_ABORTED	0x1000
d358 3
a368 14
	    } else if (pdevHandlePtr->flags & PDEV_SIGNAL_PENDING) {
		status = GEN_ABORTED_BY_SIGNAL;
		if (ioReplyPtr != (Fs_IOReply *) NIL) {
		    ioReplyPtr->length = pdevHandlePtr->reply.replySize;
		    ioReplyPtr->signal = pdevHandlePtr->reply.signal;
		    ioReplyPtr->code = pdevHandlePtr->reply.code;
		    /*
		     * For now, until higher-levels do it...
		     */
		    Sig_Send(pdevHandlePtr->reply.signal,
			     pdevHandlePtr->reply.code,
			     pdevHandlePtr->clientPID, FALSE);
		}
		goto failure;
d373 2
a374 2
	    ioReplyPtr->signal = 0;
	    ioReplyPtr->code = 0;
d556 1
a556 1
FsServerStreamRead(streamPtr, flags, buffer, offsetPtr, lenPtr, waitPtr)
d558 4
a561 5
    int		flags;		/* Flags from stream */
    Address 	buffer;		/* Where to read into. */
    int		*offsetPtr;	/* In/Out byte offset for the read */
    int 	*lenPtr;	/* In/Out byte count parameter */
    Sync_RemoteWaiter *waitPtr;	/* Process info for waiting */
d579 1
a579 1
	panic( "PdevServerRead, pointers inconsistent\n");
d586 1
a586 1
	*lenPtr = 0;
d625 3
a627 2
	status = Vm_CopyOut(sizeof(Pdev_BufPtrs), (Address)&bufPtrs, buffer);
	*lenPtr = sizeof(Pdev_BufPtrs);
a986 3
		if (srvReplyPtr->signal != 0) {
		    pdevHandlePtr->flags |= PDEV_SIGNAL_PENDING;
		}
d1884 1
a1884 1
FsPseudoStreamRead(streamPtr, flags, buffer, offsetPtr, lenPtr, waitPtr)
d1886 4
a1889 4
    Address 	buffer;			/* Where to read into. */
    int		*offsetPtr;		/* In/Out byte offset for the read */
    int 	*lenPtr;		/* In/Out byte count parameter */
    Sync_RemoteWaiter *waitPtr;		/* Process info for waiting */
a1894 1
#ifdef notdef
a1895 2
#endif notdef
    Proc_ControlBlock	*procPtr;
a1896 1
    Fs_IOReply		ioReply;
a1909 1
    procPtr = Proc_GetEffectiveProc();
a1912 5
     *
     * Getting the same semantics as 4.3 BSD are tricky because different
     * things happen if the process is blocking SIG_TTY_INPUT.  It may
     * be better to return a special error code here and do the signalling
     * inside Fs_Read depending on the signal mask.
d1916 1
a1916 1
	 (procPtr->familyID != ownerPtr->id)) ||
d1918 4
a1921 3
	 (procPtr->processID != ownerPtr->id))) {
	status = FS_SIG_TTYIN;
/*	Sig_Send(SIG_TTY_INPUT, SIG_NO_CODE, procPtr->processID, 0); */
d1924 1
a1924 1
#endif /* notdef */
d1938 2
a1939 2
		    *lenPtr) );
	    *lenPtr = 0;
d1948 1
a1948 2
		panic( 
		    "FsPseudoStreamRead, dataAvail in read buf <= 0 bytes\n");
d1964 2
a1965 2
	    if (dataAvail > *lenPtr) {
		toRead = *lenPtr;
d1979 1
a1979 1
			  buffer, (flags & FS_USER) == 0);
d1984 2
a1985 3
	    *lenPtr = toRead;
	    firstByte += toRead;
	    pdevHandlePtr->readBuf.firstByte = firstByte;
d1995 1
a1995 10
	request.param.read.buffer	= 0;
	request.param.read.length	= *lenPtr;
	request.param.read.offset	= *offsetPtr;
	request.param.read.flags	= 0;
	request.param.read.familyID	= procPtr->familyID;
	request.param.read.procID	= procPtr->processID;
	request.param.read.uid		= procPtr->effectiveUserID;
	if (procPtr->fsPtr->numGroupIDs > 0) {
	    request.param.read.gid	= procPtr->fsPtr->groupIDs[0];
	}
d1997 1
a1997 1
	pdevHandlePtr->flags |= (flags & FS_USER);
d1999 2
a2000 2
	    &request.hdr, 0, (Address) NIL, *lenPtr, buffer, &ioReply, waitPtr);
	*lenPtr = ioReply.length;
d2006 1
a2006 1
	*lenPtr = 0;
a2008 1
    *offsetPtr += *lenPtr;
d2016 1
a2016 1
	*lenPtr = 0;
d2018 3
d2055 1
a2055 1
FsPseudoStreamWrite(streamPtr, flags, buffer, offsetPtr, lenPtr, waitPtr)
d2057 3
a2059 5
    int		flags;		/* Flags from the stream */
    Address 	buffer;		/* Where to write to. */
    int		*offsetPtr;	/* In/Out byte offset */
    int 	*lenPtr;	/* In/Out byte count */
    Sync_RemoteWaiter *waitPtr;	/* Process info for waiting on I/O */
a2060 1
    register Proc_ControlBlock *procPtr;
a2065 1
    register int	toWrite;
a2066 2
    register int	length;
    int			replySize;
d2069 1
a2069 4
    Fs_IOReply		ioReply;
#ifdef notdef
    IOC_Owner		*ownerPtr;
#endif
d2084 1
a2084 1
    pdevHandlePtr->flags |= (PDEV_BUSY|(flags & FS_USER));
a2085 1
    procPtr = Proc_GetEffectiveProc();
d2089 2
d2093 2
a2094 3
     * supposed to succeed if the TTYOUT signal is blocked.  We should
     * probably return a special error code here and do the signalling
     * inside Fs_Write.
d2098 1
a2098 1
	 (procPtr->familyID != ownerPtr->id)) ||
d2100 4
a2103 3
	 (procPtr->processID != ownerPtr->id))) {
	status = FS_SIG_TTYOUT;
/*	Sig_Send(SIG_TTY_OUTPUT, SIG_NO_CODE, procPtr->processID, 0); */
d2106 1
a2106 2
#endif /* notdef */

d2112 1
a2112 1
	*lenPtr = 0;
d2119 1
a2119 1
    if (toWrite > maxRequestSize &&
d2122 1
a2122 1
	    toWrite);
d2132 1
a2133 8
    request.param.write.offset		= *offsetPtr;
    request.param.write.flags		= flags;
    request.param.write.familyID	= procPtr->familyID;
    request.param.write.procID		= procPtr->processID;
    request.param.write.uid		= procPtr->effectiveUserID;
    if (procPtr->fsPtr->numGroupIDs > 0) {
	request.param.write.gid	= procPtr->fsPtr->groupIDs[0];
    }
a2134 1
    toWrite = *lenPtr;
d2136 1
a2136 1
    while ((toWrite > 0) && (status == SUCCESS)) {
d2139 2
a2140 1
	 * buffer until the whole block has been transferred.
d2142 3
a2144 7
	if (toWrite > maxRequestSize) {
	    length = maxRequestSize;
	} else {
	    length = toWrite;
	}
	request.param.write.length = length;
	replySize = sizeof(int);
d2146 4
a2149 4
				 &request.hdr, length, buffer,
				 replySize, (Address)&numBytes, &ioReply,
				 waitPtr);
	replySize = ioReply.length;
d2154 2
a2155 2
	    numBytes = length;
	} else if (replySize != sizeof(int)) {
d2161 1
a2161 3
	toWrite -= numBytes;
	request.param.write.offset += numBytes;
	buffer += numBytes;
d2163 1
a2163 2
    *lenPtr = amountWritten;
    *offsetPtr += amountWritten;
d2170 1
d2172 3
@


8.14
log
@Removed call to Sync_LockRegister
@
text
@d10 4
a13 4
 *	Operations are forwarded to a user-level server process using
 *	a "request-response" protocol.
 *	The server process declares a request buffer and optionally a read
 *	ahead buffer in its address space.  The kernel puts requests, which
d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.13 89/04/12 14:20:44 brent Exp Locker: jhh $ SPRITE (Berkeley)";
d62 2
a63 1
 * Access to PdevServerIOHandle is monitored.
d92 4
d110 2
d149 1
a149 1
	replySize, replyBuf, replySizePtr, waitPtr)
d160 3
a162 4
					 * no reply data expected.  Of the
					 * operation is PDEV_WRITE_ASYNC then
					 * no reply is wanted and ths argument
					 * is ignored. */
d164 2
a165 2
    int			*replySizePtr;	/* Amount of data actually in replyBuf.
					 * (May be NIL if not needed.) */
d177 2
a178 2
    if (replySizePtr != (int *) NIL) {
	*replySizePtr = 0;
d198 1
d201 1
d223 1
a223 1
	printf( "RequestResponse request too large\n");
d261 4
a264 2
		(void) Sync_Wait(&pdevHandlePtr->caughtUp, FALSE);
		if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
d359 8
a366 2
	    (void)Sync_Wait(&pdevHandlePtr->replyReady, FALSE);
	    if (pdevHandlePtr->flags & (PDEV_REPLY_FAILED|PDEV_SERVER_GONE)) {
d369 14
d385 4
a388 2
	if (replySizePtr != (int *) NIL) {
	    *replySizePtr = pdevHandlePtr->reply.replySize;
a393 1

d435 1
a435 1
	printf( "ServerStreamCreate, found handle <%x,%x,%x>\n",
a641 5
	/*
	 * Poke the "caughtUp" condition in case anyone is waiting to stuff
	 * more requests into the buffer.  (THIS SEEMS INAPPROPRIATE)
	 */
	Sync_Broadcast(&pdevHandlePtr->caughtUp);
d853 1
a853 2
		    printf(
			"FsServerStreamIOControl: set bad readPtr\n");
d902 1
d915 9
a923 4
	    pdevHandlePtr->reply = *srvReplyPtr;
	    if (srvReplyPtr->replySize > 0) {
		register Proc_ControlBlock *clientProcPtr;

d925 25
a949 16
		 * Copy the reply into the waiting buffers.  PDEV_WRITE is
		 * handled specially because the reply buffer is just an
		 * integer variable in the kernel, while the input buffer
		 * is in user space, which is indicated by the FS_USER flag.
		 *  - To be fully general we'd need a user space flag for
		 * 	both the input buffer and the reply.
		 */
		if (((pdevHandlePtr->flags & FS_USER) == 0) ||
		    (pdevHandlePtr->operation == PDEV_WRITE)) {
		    status = Vm_CopyIn(srvReplyPtr->replySize,
				       srvReplyPtr->replyBuf,
				       pdevHandlePtr->replyBuf);
	        } else {
		    clientProcPtr = Proc_LockPID(pdevHandlePtr->clientPID);
		    if (clientProcPtr == (Proc_ControlBlock *)NIL) {
			status = FS_BROKEN_PIPE;
d951 34
a984 4
			status = Vm_CopyOutProc(srvReplyPtr->replySize,
				srvReplyPtr->replyBuf, FALSE,
				clientProcPtr, pdevHandlePtr->replyBuf);
			Proc_Unlock(clientProcPtr);
d987 16
a1002 12
		if (status != SUCCESS) {
		    pdevHandlePtr->flags |= PDEV_REPLY_FAILED;
		}
	    }
	    PDEV_REPLY(&pdevHandlePtr->hdr.fileID, srvReplyPtr);
	    if (srvReplyPtr->status == FS_WOULD_BLOCK) {
		if (pdevHandlePtr->operation == PDEV_READ) {
		    FsFastWaitListInsert(&pdevHandlePtr->cltReadWaitList,
					 &pdevHandlePtr->clientWait);
		} else if (pdevHandlePtr->operation == PDEV_WRITE) {
		    FsFastWaitListInsert(&pdevHandlePtr->cltWriteWaitList,
					 &pdevHandlePtr->clientWait);
d1004 1
a1005 4
	    /*
	     * Wakeup the client waiting for this reply.
	     */
	    pdevHandlePtr->flags |= PDEV_REPLY_READY;
a1006 4
	    /*
	     * Notify other clients that may also be blocked on the stream.
	     */
	    pdevHandlePtr->selectBits = srvReplyPtr->selectBits;
d1056 4
d1109 1
a1109 1
	case IOC_PFS_PASS_STREAM:
a1113 1
#ifdef work_in_progress
d1123 4
d1140 2
a1141 2
			bzero((char *)&openResults, sizeof(FsOpenResults);
			openResults.fileID.type = FS_PASSING_STREAM;
d1143 1
a1143 1
			openResults.streamData = encapStream;
a1160 1
#endif work_in_progress
d1162 1
d1473 1
a1473 1
			 0, (Address) NIL, 0, (Address) NIL, (int *)NIL,
d1513 1
a1513 1
    int			*resultsSizePtr;/* In/Out size of results */
d1519 5
a1523 1
    FsRedirectInfo		redirectInfo;
d1541 1
a1541 1
		(Address)&redirectInfo, resultsSizePtr,
d1548 3
d1552 3
a1554 2
	if (*resultsSizePtr > 0) {
	    bcopy((Address)&redirectInfo, resultsPtr, *resultsSizePtr);
a1605 1
    int resultSize;
d1625 1
a1625 1
		&resultSize, (Sync_RemoteWaiter *)NIL);
d1708 1
a1708 1
			(int *)NIL, (Sync_RemoteWaiter *)NIL);
d1780 1
a1780 1
			(int *)NIL, (Sync_RemoteWaiter *)NIL);
d1917 1
d2023 2
d2026 1
d2029 4
d2036 2
a2037 1
	    &request.hdr, 0, (Address) NIL, *lenPtr, buffer, lenPtr, waitPtr);
d2110 1
d2161 10
a2170 4
    /*
     * The write request parameters are the offset and flags parameters.
     * The buffer contains the data to write.
     */
d2176 1
d2178 1
d2181 4
a2187 9
    maxRequestSize = pdevHandlePtr->requestBuf.size - sizeof(Pdev_Request);
    if (toWrite > maxRequestSize &&
	(pdevHandlePtr->flags & PDEV_NO_BIG_WRITES)) {
	printf(
	    "Too large a write (%d bytes) attempted on pseudo-device (UDP?)\n",
	    toWrite);
	status = GEN_INVALID_ARG;
	goto exit;
    }
d2198 1
d2202 1
a2202 1
				 replySize, (Address)&numBytes, &replySize,
d2204 1
d2265 1
d2364 6
d2371 5
a2375 3
	    request.param.ioctl.procID		= procPtr->processID;
	    request.param.ioctl.byteOrder	= byteOrder;
	    
d2377 4
a2380 4
				     &request.hdr,
				     inBufPtr->size, inBufPtr->addr,
				     outBufPtr->size, outBufPtr->addr,
				     (int *) NIL, (Sync_RemoteWaiter *)NIL);
d2538 1
a2538 1
		    0, (Address)NIL, 0, (Address)NIL, (int *) NIL,
@


8.13
log
@Fixed pdev setup so it word-aligns the request and read buffers.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.12 89/03/30 17:07:22 brent Exp Locker: brent $ SPRITE (Berkeley)";
a422 1
    Sync_LockRegister(&pdevHandlePtr->lock);
@


8.12
log
@Nuked PdevServer IOControl #20007 returning 10008
warning message
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.11 89/03/24 17:02:00 brent Exp Locker: brent $ SPRITE (Berkeley)";
d687 2
d693 2
a694 5
		 * Normal case, first time initialization.  The state has
		 * been marked BUSY to simplify waiting in the routines
		 * that call RequestResponse, so we clear that state bit.
		 * We also mark it explicitly as SETUP so we can bail out
		 * later if the server never sets up the request buffer.
d696 1
d698 6
a703 1
		pdevHandlePtr->requestBuf.size = argPtr->requestBufSize;
a706 3
		pdevHandlePtr->flags &= ~PDEV_BUSY;
		pdevHandlePtr->flags |= PDEV_SETUP|PDEV_READ_BUF_EMPTY|
						 PDEV_SERVER_KNOWS_IT;
d710 1
d712 1
d714 6
a720 1
		pdevHandlePtr->readBuf.size = argPtr->readBufSize;
d727 7
@


8.11
log
@Added preliminary code to support passing open streams from
pseudo-device servers to their clients.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.10 89/03/14 10:43:06 brent Exp $ SPRITE (Berkeley)";
d1128 1
d1132 1
@


8.10
log
@Patched attributes to contain real hostID so stat() matches
what is reported by prefix table.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.9 89/02/28 08:48:37 brent Exp $ SPRITE (Berkeley)";
d1028 45
@


8.9
log
@Changed object-specific select routines to handle NIL waitPtr information
so they can avoid setting up wait lists.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.8 89/02/07 14:22:21 brent Exp Locker: jhh $ SPRITE (Berkeley)";
d1566 6
@


8.8
log
@Removed Lint
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.7 89/02/06 18:26:51 brent Exp $ SPRITE (Berkeley)";
d422 2
a423 1
    SYNC_LOCK_INIT_DYNAMIC(&pdevHandlePtr->lock);
d510 3
a512 1
	    FsFastWaitListInsert(&pdevHandlePtr->srvReadWaitList, waitPtr);
d1194 1
d1237 4
d2266 4
a2269 1
		FsFastWaitListInsert(&pdevHandlePtr->cltReadWaitList, waitPtr);
d2274 3
a2276 1
	    FsFastWaitListInsert(&pdevHandlePtr->cltWriteWaitList, waitPtr);
d2280 3
a2282 1
	    FsFastWaitListInsert(&pdevHandlePtr->cltExceptWaitList, waitPtr);
@


8.7
log
@Cleaned up initialization of PdevServerIOHandle
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.6 89/01/30 14:04:32 brent Exp $ SPRITE (Berkeley)";
d1755 1
d1757 1
d1944 3
@


8.6
log
@Added object stats
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.5 89/01/29 14:34:51 brent Exp Locker: brent $ SPRITE (Berkeley)";
d422 1
d428 2
d436 2
a442 2
    pdevHandlePtr->nextRequestBuffer = (Address)NIL;

d444 2
d447 8
a454 2
    pdevHandlePtr->serverPID = (Proc_PID)NIL;
    pdevHandlePtr->clientPID = (Proc_PID)NIL;
a458 1
    List_Init(&pdevHandlePtr->srvReadWaitList);
d464 1
d466 3
@


8.5
log
@Added IOC_PDEV_SIGNAL_OWNER for better implementation of ^C on pty's
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.4 89/01/25 13:31:27 brent Exp $ SPRITE (Berkeley)";
d49 1
d410 1
d1179 1
@


8.4
log
@Added PDEV_NAMING to mark naming stream
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.3 89/01/25 09:53:07 brent Exp $ SPRITE (Berkeley)";
d909 29
a988 1
#ifdef notdef
a1003 1
#endif
a1009 20
	case IOC_PDEV_READY:
	    /*
	     * Master has made the device ready.  The inBuffer contains
	     * new select bits.
	     *
	     * Side effects:
	     *		Notify waiting clients.
	     */

	    if (inBufPtr->size != sizeof(int)) {
		status = FS_INVALID_ARG;
	    } else {
		/*
		 * Update the select state of the pseudo-device and
		 * wake up any clients waiting on their pseudo-stream.
		 */
		pdevHandlePtr->selectBits = *(int *)inBufPtr->addr;
		PdevClientNotify(pdevHandlePtr);
	    }
	    break;
d1074 50
d1738 2
d1754 21
a1840 2
	Proc_ControlBlock	*procPtr;

a1844 1
	procPtr = Proc_GetEffectiveProc();
d1941 2
d1944 19
a1975 1
    procPtr = Proc_GetEffectiveProc();
d2102 4
a2105 1
    switch (command) {
d2107 1
a2107 1
	 * Trap out the IOC_NUM_READABLE here if there's a read ahead buf.
d2109 36
a2144 5
	case IOC_NUM_READABLE: {
	    if (pdevHandlePtr->readBuf.data != (Address)NIL) {
		int bytesAvail;
		if (pdevHandlePtr->flags & PDEV_READ_BUF_EMPTY) {
		    bytesAvail = 0;
d2146 2
a2147 2
		    bytesAvail = pdevHandlePtr->readBuf.lastByte -
				 pdevHandlePtr->readBuf.firstByte + 1;
d2149 8
a2156 9
		status = SUCCESS;
		if (byteOrder != mach_ByteOrder) {
		    int size = sizeof(int);
		    Swap_Buffer((Address)&bytesAvail, sizeof(int),
			mach_ByteOrder, byteOrder, "w", outBufPtr->addr, &size);
		    if (size != sizeof(int)) {
			status = GEN_INVALID_ARG;
		    }
		} else if (outBufPtr->size != sizeof(int)) {
d2159 2
a2160 1
		    *(int *)outBufPtr->addr = bytesAvail;
a2161 4
		DBG_PRINT( ("IOC  %x,%x num readable %d\n",
			pdevHandlePtr->hdr.fileID.major,
			pdevHandlePtr->hdr.fileID.minor,
			bytesAvail) );
a2163 3
	    /*
	     * FALL through to request-response if no read-ahead buffer
	     */
d2165 1
a2165 1
	default: {
d2172 1
a2172 1
	
@


8.3
log
@Changed I/O attributes so they are kept in the control stream.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.2 89/01/24 12:24:11 brent Exp $ SPRITE (Berkeley)";
d89 1
d103 1
d389 1
a389 1
FsServerStreamCreate(ioFileIDPtr, name)
d392 1
d421 3
d1104 1
a1104 1
    if (pdevHandlePtr->ctrlHandlePtr->prefixPtr != (FsPrefix *)NIL) {
d1106 1
a1106 1
	 * This is the naming requeust-response stream of a pseudo-filesystem.
@


8.2
log
@Added set/get IO attr routines and added an access/modify time.
Also added PDEV_WRITE_ASYNC
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.1 89/01/19 09:42:04 brent Exp $ SPRITE (Berkeley)";
d1098 1
a1098 1
    if (pdevHandlePtr->ctrlHandlePtr != (PdevControlIOHandle *)NIL) {
d1589 2
a1590 2
    attrPtr->accessTime.seconds = pdevHandlePtr->accessTime;
    attrPtr->dataModifyTime.seconds = pdevHandlePtr->modifyTime;
d1631 2
a1632 2
	pdevHandlePtr->accessTime = attrPtr->accessTime.seconds;
	pdevHandlePtr->modifyTime = attrPtr->dataModifyTime.seconds;
d1779 1
a1779 1
    pdevHandlePtr->accessTime = fsTimeInSeconds;
d1925 1
a1925 1
    pdevHandlePtr->modifyTime = fsTimeInSeconds;
@


8.1
log
@Fixed handling of exiting servers so there are no lingering client processes.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 8.0 88/11/11 18:21:51 douglis Stable Locker: brent $ SPRITE (Berkeley)";
d58 1
d150 4
a153 5
					 * no reply data expected.  -1
					 * means no reply wanted.  This causes
					 * a SUCCESS return immediately
					 * without having to switch out to
					 * the server process for the reply. */
d197 1
a197 1
     * Format the request header.  Note that the complete message size is
d220 1
a220 2
     * Put the request into the request buffer.
     *
d285 1
d319 1
a319 1
     * Poke the server so it can read the new pointer values.
d330 1
a330 1
    if (replySize >= 0) {  
d332 2
a333 2
	 * If this operation needs a reply we wait for it.  We save
	 * the client's reply buffer address and processID in the
d432 1
a432 1
    pdevHandlePtr->operation = PDEV_INVALID;
d1554 87
d1779 1
d1852 2
a1853 2
	    UNLOCK_MONITOR;
	    return(FS_BROKEN_PIPE);
d1873 5
a1877 1
    request.hdr.operation		= PDEV_WRITE;
d1903 1
a1903 5
	/*
	 * Do a synchronous or asynchronous write.
	 */
	replySize = (pdevHandlePtr->flags & PDEV_WRITE_BEHIND) ? -1 :
		sizeof(int);
d1914 2
a1915 1
	    printf( "Pdev_Write, no return amtWritten\n");
d1925 2
d1934 1
a1934 1
exit:
@


8.0
log
@Changing version numbers.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 7.0 88/11/11 15:32:45 brent Exp Locker: douglis $ SPRITE (Berkeley)";
d1141 6
a1146 1
    pdevHandlePtr->flags |= (PDEV_SERVER_GONE|PDEV_REPLY_FAILED);
d1226 1
a1226 1
    while (pdevHandlePtr->flags & PDEV_BUSY) {
d1251 1
a1252 1
    pdevHandlePtr->flags &= ~PDEV_BUSY;
a1325 1
exit:
d1334 1
a1405 1
exit:
d1414 1
d1478 1
a1479 1
    pdevHandlePtr->flags &= ~PDEV_BUSY;
d1544 1
a1545 1
    pdevHandlePtr->flags &= ~PDEV_BUSY;
d1597 1
a1597 1
	    goto exit;
d1701 1
a1835 1
exit:
d1843 1
d1938 1
a1938 1
		goto exit;
d1940 3
a1942 1
	    break;
d1944 14
d1960 1
a1960 11
    procPtr = Proc_GetEffectiveProc();
    request.hdr.operation		= PDEV_IOCTL;
    request.param.ioctl.command		= command;
    request.param.ioctl.familyID	= procPtr->familyID;
    request.param.ioctl.procID		= procPtr->processID;
    request.param.ioctl.byteOrder	= byteOrder;

    status = RequestResponse(pdevHandlePtr, sizeof(Pdev_Request), &request.hdr,
			     inBufPtr->size, inBufPtr->addr,
			     outBufPtr->size, outBufPtr->addr,
			     (int *) NIL, (Sync_RemoteWaiter *)NIL);
a1961 1
    pdevHandlePtr->flags &= ~(PDEV_BUSY|FS_USER);
d2109 1
a2110 1
    pdevHandlePtr->flags &= ~(PDEV_BUSY|FS_USER);
@


7.0
log
@New version for conversion to new C library
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 6.25 88/11/07 09:02:01 brent Exp Locker: brent $ SPRITE (Berkeley)";
@


6.25
log
@Added routine to handle 2path operations on a pseudo-domain.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 6.24 88/11/02 11:03:48 brent Exp Locker: brent $ SPRITE (Berkeley)";
d176 1
a176 1
	Sys_Panic(SYS_FATAL, "RequestResponse: connection not set up\n");
d189 1
a189 1
	Sys_Panic(SYS_WARNING, "Switching to request buffer at 0x%x\n",
d205 1
a205 1
	Sys_Panic(SYS_FATAL, "RequestResponse: bad hdr size\n");
d212 1
a212 1
	Sys_Panic(SYS_WARNING, "RequestResponse request too large\n");
d400 1
a400 1
	Sys_Panic(SYS_WARNING, "ServerStreamCreate, found handle <%x,%x,%x>\n",
d539 1
a539 1
	Sys_Panic(SYS_FATAL, "PdevServerRead, pointers inconsistent\n");
d642 1
a642 1
	Sys_Panic(SYS_FATAL, "FsServerStreamIOControl: wrong byte order\n");
d787 1
a787 1
		    Sys_Panic(SYS_WARNING,
d1052 1
a1052 1
	Sys_Printf("PdevServer IOControl #%x returning %x\n", command, status);
d1311 1
a1311 1
	*newNameInfoPtrPtr = Mem_New(FsRedirectInfo);
d1313 1
a1313 1
	(void)String_Copy(redirectInfo.fileName, (*newNameInfoPtrPtr)->fileName);
d1317 1
a1317 1
	    Byte_Copy(*resultsSizePtr, (Address)&redirectInfo, resultsPtr);
d1391 1
a1391 1
	*newNameInfoPtrPtr = Mem_New(FsRedirectInfo);
d1393 1
a1393 1
	(void)String_Copy(redirectInfo.fileName, (*newNameInfoPtrPtr)->fileName);
d1448 1
a1448 1
	Sys_Panic(SYS_WARNING, "FsPseudoGetAttr, no %s handle <%d,%x,%x>\n",
d1512 1
a1512 1
	Sys_Panic(SYS_WARNING, "FsPseudoSetAttr, no handle <%d,%d,%x,%x>\n",
d1619 1
a1619 1
		Sys_Panic(SYS_FATAL, 
d1771 1
d1789 1
a1789 1
	Sys_Panic(SYS_WARNING,
d1820 1
a1820 1
	    Sys_Panic(SYS_WARNING, "Pdev_Write, no return amtWritten\n");
@


6.24
log
@Eliminated the setup condition.  Instead a pseudo-stream starts
out BUSY, and this condition is cleared after the request buffer
is initialized.  This simplifies access checking in all the
routines that use RequestResponse
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 6.23 88/10/22 15:15:50 brent Exp $ SPRITE (Berkeley)";
d1307 3
a1309 3
		    &requestPtr->hdr, argSize, argsPtr,
		    *resultsSizePtr, (Address)&redirectInfo, resultsSizePtr,
		    (Sync_RemoteWaiter *)NIL);
d1338 80
d1662 1
a1662 1
    } else {
d1666 2
a1667 1
	 * No read ahead buffer. Set up and do the request-response exchange.
d1678 7
d1764 9
@


6.23
log
@Fixed up opening of new pdev connections as a side effect of IOC_PFS_OPEN
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 6.22 88/10/20 15:49:50 brent Exp $ SPRITE (Berkeley)";
d175 2
d369 1
a369 1
 * FsServerStreamClose --
d371 3
a373 6
 *	Clean up the state associated with a server stream.  This makes
 *	sure the client processes associated with the pseudo stream get
 *	poked, and it marks the pseudo stream's state as invalid so
 *	the clients will abort their current operations, if any.  The
 *	handle is 'removed' here, but it won't go away until the client
 *	side closes down and releases its reference to it.
d376 2
a377 1
 *	SUCCESS.
d380 2
a381 4
 *	Marks the pseudo stream state with PDEV_SERVER_GONE, notifies
 *	all conditions in pseudo stream state, wakes up all processes
 *	in any of the pseudo stream's wait lists, and then removes
 *	the handle from the hash table.
d385 5
a389 8
/*ARGSUSED*/
FsServerStreamClose(streamPtr, clientID, procID, flags, size, data)
    Fs_Stream		*streamPtr;	/* Service stream to close */
    int			clientID;	/* HostID of client closing */
    Proc_PID		procID;		/* ID of closing process */
    int			flags;		/* Flags from the stream being closed */
    int			size;		/* Should be zero */
    ClientData		data;		/* IGNORED */
d391 3
a393 2
    register PdevServerIOHandle *pdevHandlePtr =
	    (PdevServerIOHandle *)streamPtr->ioHandlePtr;
d395 11
a405 3
    DBG_PRINT( ("Server Closing pdev %x,%x\n", 
		pdevHandlePtr->hdr.fileID.major,
		pdevHandlePtr->hdr.fileID.minor) );
d407 2
a408 7
    PdevClientWakeup(pdevHandlePtr);
    if (pdevHandlePtr->ctrlHandlePtr != (PdevControlIOHandle *)NIL) {
	/*
	 * This is the naming requeust-response stream of a pseudo-filesystem.
	 */
	register PdevControlIOHandle *ctrlHandlePtr;
	Fs_Stream dummy;
d410 6
a415 30
	ctrlHandlePtr = pdevHandlePtr->ctrlHandlePtr;
	dummy.hdr.fileID.type = -1;
	dummy.ioHandlePtr = (FsHandleHeader *)ctrlHandlePtr;
	FsHandleLock(ctrlHandlePtr);
	FsPrefixHandleClose(ctrlHandlePtr->prefixPtr);
	(void)FsControlClose(&dummy, clientID, procID, flags, 0, (ClientData)NIL);
    }
    FsHandleRelease(pdevHandlePtr, TRUE);
    FsHandleRemove(pdevHandlePtr);	/* No need for scavenging */
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * PdevClientWakeup --
 *
 *	Called when the server's stream is closed.  This
 *	notifies the various conditions that the client might be
 *	waiting on and marks the pdev state as invalid so the
 *	client will bail out when it wakes up.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Notifies condition variables and marks the pseudo stream as invalid.
 *
 *----------------------------------------------------------------------
 */
d417 2
a418 31
ENTRY static void
PdevClientWakeup(pdevHandlePtr)
    PdevServerIOHandle *pdevHandlePtr;	/* State for the pseudo stream */
{
    LOCK_MONITOR;
    pdevHandlePtr->flags |= (PDEV_SERVER_GONE|PDEV_REPLY_FAILED);
    Sync_Broadcast(&pdevHandlePtr->setup);
    Sync_Broadcast(&pdevHandlePtr->access);
    Sync_Broadcast(&pdevHandlePtr->caughtUp);
    Sync_Broadcast(&pdevHandlePtr->replyReady);
    FsFastWaitListNotify(&pdevHandlePtr->cltReadWaitList);
    FsFastWaitListNotify(&pdevHandlePtr->cltWriteWaitList);
    FsFastWaitListNotify(&pdevHandlePtr->cltExceptWaitList);
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * FsPdevServerOK --
 *
 *	Called from FsPfsExport to see if the server of a prefix still exists.
 *
 * Results:
 *	TRUE if the server process is still around.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
d420 29
a448 13
ENTRY Boolean
FsPdevServerOK(pdevHandlePtr)
    PdevServerIOHandle *pdevHandlePtr;	/* State for the pseudo stream */
{
    register Boolean answer;
    LOCK_MONITOR;
    if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	answer = FALSE;
    } else {
	answer = TRUE;
    }
    UNLOCK_MONITOR;
    return(answer);
a449 1

d666 5
a670 1
		 * Normal case, first time initialization.
d677 1
d693 1
a693 1
		Sync_Broadcast(&pdevHandlePtr->setup);
d1061 125
d1188 1
a1188 1
 *	Do the first request-response with the server to see if it
d1216 4
a1219 2
     * We have to wait for the server to establish buffer space for
     * the new stream before we can try to use it.
d1221 4
a1224 2
    pdevHandlePtr->flags |= PDEV_BUSY;
    while ((pdevHandlePtr->flags & PDEV_SETUP) == 0) {
a1225 3
	    /*
	     * Server bailed out before we made contact.
	     */
a1228 1
	(void) Sync_Wait(&pdevHandlePtr->setup, FALSE);
d1230 1
d1258 5
a1262 4
 *	Do a lookup request-response to a pseudo-filesystem server.  This
 *	takes care of synchronization over the pseudo-stream connection.
 *	Otherwise this is a stub that passes its bundled arguments to the
 *	server and returns the results.
d1265 3
a1267 3
 *	A status, plus a I/O fileID and related info used when a file is
 *	opened in the pseudo-filesystem.  Other operations, like remove or
 *	make-directory, return only a status.
d1271 2
a1272 1
 *	up to the pseudo-filesystem server.
d1294 3
a1296 7
    while ((pdevHandlePtr->flags & PDEV_SETUP) == 0) {
	/*
	 * Wait for the server to set up its request buffer.
	 */
	if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	    status = FS_STALE_HANDLE;
	    goto exit;
a1297 12
	Sys_Panic(SYS_WARNING,
	    "Pseudo-domain lookup waiting for server to set up\n");
	if (Sync_Wait(&pdevHandlePtr->setup, TRUE)) {
	    UNLOCK_MONITOR;
	    return(GEN_ABORTED_BY_SIGNAL);
	}
    }
    while (pdevHandlePtr->flags & PDEV_BUSY) {
	/*
	 * Wait for exclusive access to the naming stream.
	 */
	(void)Sync_Wait(&pdevHandlePtr->access, FALSE);
d1368 2
a1369 2
	Sys_Panic(SYS_WARNING, "FsPseudoGetAttr, no handle <%d,%d,%x,%x>\n",
	    fileIDPtr->serverID, fileIDPtr->type,
d1373 1
a1373 1
    FsHandleUnlock(cltHandlePtr);
d1376 1
a1376 5
    /*
     * Wait for exclusive access to the stream.  Different clients might
     * be using the shared pseudo stream at about the same time.  Things
     * are kept simple by only letting one process through at a time.
     */
d1378 3
a1380 1
	(void)Sync_Wait(&pdevHandlePtr->access, FALSE);
d1437 1
a1437 1
    FsHandleUnlock(cltHandlePtr);
d1442 3
a1444 1
	(void)Sync_Wait(&pdevHandlePtr->access, FALSE);
a1505 5
    /*
     * Wait for exclusive access to the stream.  Different clients might
     * be using the shared pseudo stream at about the same time.  Things
     * are kept simple by only letting one process through at a time.
     */
d1507 3
a1509 1
	(void)Sync_Wait(&pdevHandlePtr->access, FALSE);
d1598 1
d1666 3
a1668 1
	(void)Sync_Wait(&pdevHandlePtr->access, FALSE);
a1725 7
	if (numBytes < length) {
	    /*
	     * Stop on short writes.
	     */
	    status = FS_WOULD_BLOCK;
	    break;
	}
d1731 1
d1752 1
a1752 3
 *	to fill the return parameter block of the client.  Remember that
 *	Fs_IOControlStub copies the user buffers into and out of the kernel
 *	so we'll set the FS_USER flag in the serverIOHandle.
d1783 3
a1785 1
	(void)Sync_Wait(&pdevHandlePtr->access, FALSE);
a1982 9
    if ((pdevHandlePtr->flags & PDEV_SETUP) == 0) {
	/*
	 * Server never set the stream up so we obviously can't contact it.
	 */
	goto exit;
    }
    /*
     * Wait for exclusive access to the stream.
     */
d1984 3
a1986 1
	(void)Sync_Wait(&pdevHandlePtr->access, FALSE);
@


6.22
log
@removed lint
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPdev.c,v 6.21 88/10/19 09:47:51 brent Exp $ SPRITE (Berkeley)";
a266 1
    pdevHandlePtr->operation = requestHdrPtr->operation;
d269 13
d956 1
a956 1
			    (Fs_FileID *)inBufPtr->addr, &openResults.ioFileID);
d969 1
a969 2
		     * same host.)  The nameID part of the open results are
		     * used later if the client does an fstat().
a972 6

		    openResults.nameID = openResults.ioFileID;
		    FsStreamNewID(rpc_SpriteID, &openResults.streamID);
		    openResults.dataSize = 0;
		    openResults.streamData = (ClientData)NIL;

d978 3
d982 1
d1295 1
d1361 1
@


6.21
log
@1 - Moved FsServerStreamCreate to fsPdevSetup.c
2 - Patched FsPseudoStreamWrite to break out on short reads
    and inject the FS_WOULD_BLOCK return code so waiting works.
3 - Tweaked IOC_PFS_OPEN to accept a user level Fs_FileID
4 - Changed FsPseudoStreamLookup to return FS_STALE_HANDLE when
    the server goes away so that rmt clients can clean up prefix tables
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: fsPdev.c,v 6.19 88/10/14 12:16:47 brent Exp $ SPRITE (Berkeley)";
d404 1
a404 1
	FsControlClose(&dummy, clientID, procID, flags, 0, (ClientData)NIL);
d979 1
d995 1
d1253 4
a1256 2
 *	Get the attributes of a file in a pseudo-filesystem.  We have the
 *	fileID of the request-response stream to the server.
d1320 2
a1321 1
 *	fileID of the request-response stream to the server.
@


6.20
log
@Added user-level FileID to pseudo-device connections so the
pseudo-filesystem server can understand the FileID's in
the lookup arguments.
@
text
@a114 209
 * FsServerStreamCreate --
 *
 *	Set up the stream state for a server's private channel to a client.
 *	This creates a PdevServerIOHandle that has all the state for the
 *	connection to the client.
 *
 * Results:
 *	A pointer to the I/O handle created.  The handle is locked.
 *	NIL is returned if a handle under the fileID already existed.
 *
 * Side effects:
 *	The I/O handle for this connection between a client and the server
 *	is installed and initialized.
 *
 *----------------------------------------------------------------------
 */

PdevServerIOHandle *
FsServerStreamCreate(ioFileIDPtr, name)
    Fs_FileID	*ioFileIDPtr;	/* File ID used for pseudo stream handle */
    char	*name;		/* File name for error messages */
{
    FsHandleHeader *hdrPtr;
    register PdevServerIOHandle *pdevHandlePtr;
    Boolean found;

    ioFileIDPtr->type = FS_SERVER_STREAM;
    found = FsHandleInstall(ioFileIDPtr, sizeof(PdevServerIOHandle), name,
			    &hdrPtr);
    pdevHandlePtr = (PdevServerIOHandle *)hdrPtr;
    if (found) {
	Sys_Panic(SYS_WARNING, "ServerStreamCreate, found handle <%x,%x,%x>\n",
		  hdrPtr->fileID.serverID, hdrPtr->fileID.major,
		  hdrPtr->fileID.minor);
	FsHandleRelease(pdevHandlePtr, TRUE);
	return((PdevServerIOHandle *)NIL);
    }

    DBG_PRINT( ("ServerStreamOpen <%d,%x,%x>\n",
	    ioFileIDPtr->serverID, ioFileIDPtr->major, ioFileIDPtr->minor) );

    /*
     * Initialize the state for the pseudo stream.  Remember that
     * the request and read ahead buffers for the pseudo-stream are set up
     * via IOControls by the server process later.
     */

    pdevHandlePtr->flags = 0;
    pdevHandlePtr->selectBits = 0;

    pdevHandlePtr->requestBuf.data = (Address)NIL;
    pdevHandlePtr->requestBuf.firstByte = -1;
    pdevHandlePtr->requestBuf.lastByte = -1;
    pdevHandlePtr->requestBuf.size = 0;

    pdevHandlePtr->readBuf.data = (Address)NIL;
    pdevHandlePtr->readBuf.firstByte = -1;
    pdevHandlePtr->readBuf.lastByte = -1;
    pdevHandlePtr->readBuf.size = 0;

    pdevHandlePtr->nextRequestBuffer = (Address)NIL;

    pdevHandlePtr->operation = PDEV_INVALID;
    pdevHandlePtr->replyBuf = (Address)NIL;
    pdevHandlePtr->serverPID = (Proc_PID)NIL;
    pdevHandlePtr->clientPID = (Proc_PID)NIL;
    pdevHandlePtr->clientWait.pid = NIL;
    pdevHandlePtr->clientWait.hostID = NIL;
    pdevHandlePtr->clientWait.waitToken = NIL;

    List_Init(&pdevHandlePtr->srvReadWaitList);
    List_Init(&pdevHandlePtr->cltReadWaitList);
    List_Init(&pdevHandlePtr->cltWriteWaitList);
    List_Init(&pdevHandlePtr->cltExceptWaitList);

    pdevHandlePtr->ctrlHandlePtr = (PdevControlIOHandle *)NIL;
    pdevHandlePtr->userLevelID = *ioFileIDPtr;

    return(pdevHandlePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * FsServerStreamClose --
 *
 *	Clean up the state associated with a server stream.  This makes
 *	sure the client processes associated with the pseudo stream get
 *	poked, and it marks the pseudo stream's state as invalid so
 *	the clients will abort their current operations, if any.  The
 *	handle is 'removed' here, but it won't go away until the client
 *	side closes down and releases its reference to it.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Marks the pseudo stream state with PDEV_SERVER_GONE, notifies
 *	all conditions in pseudo stream state, wakes up all processes
 *	in any of the pseudo stream's wait lists, and then removes
 *	the handle from the hash table.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
FsServerStreamClose(streamPtr, clientID, procID, flags, size, data)
    Fs_Stream		*streamPtr;	/* Service stream to close */
    int			clientID;	/* HostID of client closing */
    Proc_PID		procID;		/* ID of closing process */
    int			flags;		/* Flags from the stream being closed */
    int			size;		/* Should be zero */
    ClientData		data;		/* IGNORED */
{
    register PdevServerIOHandle *pdevHandlePtr =
	    (PdevServerIOHandle *)streamPtr->ioHandlePtr;

    DBG_PRINT( ("Server Closing pdev %x,%x\n", 
		pdevHandlePtr->hdr.fileID.major,
		pdevHandlePtr->hdr.fileID.minor) );

    PdevClientWakeup(pdevHandlePtr);
    if (pdevHandlePtr->ctrlHandlePtr != (PdevControlIOHandle *)NIL) {
	/*
	 * This is the naming requeust-response stream of a pseudo-filesystem.
	 */
	register PdevControlIOHandle *ctrlHandlePtr;
	Fs_Stream dummy;

	ctrlHandlePtr = pdevHandlePtr->ctrlHandlePtr;
	dummy.hdr.fileID.type = -1;
	dummy.ioHandlePtr = (FsHandleHeader *)ctrlHandlePtr;
	FsHandleLock(ctrlHandlePtr);
	FsPrefixHandleClose(ctrlHandlePtr->prefixPtr);
	FsControlClose(&dummy, clientID, procID, flags, 0, (ClientData)NIL);
    }
    FsHandleRelease(pdevHandlePtr, TRUE);
    FsHandleRemove(pdevHandlePtr);	/* No need for scavenging */
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * PdevClientWakeup --
 *
 *	Called when the server's stream is closed.  This
 *	notifies the various conditions that the client might be
 *	waiting on and marks the pdev state as invalid so the
 *	client will bail out when it wakes up.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Notifies condition variables and marks the pseudo stream as invalid.
 *
 *----------------------------------------------------------------------
 */

ENTRY static void
PdevClientWakeup(pdevHandlePtr)
    PdevServerIOHandle *pdevHandlePtr;	/* State for the pseudo stream */
{
    LOCK_MONITOR;
    pdevHandlePtr->flags |= (PDEV_SERVER_GONE|PDEV_REPLY_FAILED);
    Sync_Broadcast(&pdevHandlePtr->setup);
    Sync_Broadcast(&pdevHandlePtr->access);
    Sync_Broadcast(&pdevHandlePtr->caughtUp);
    Sync_Broadcast(&pdevHandlePtr->replyReady);
    FsFastWaitListNotify(&pdevHandlePtr->cltReadWaitList);
    FsFastWaitListNotify(&pdevHandlePtr->cltWriteWaitList);
    FsFastWaitListNotify(&pdevHandlePtr->cltExceptWaitList);
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * FsPdevServerOK --
 *
 *	Called from FsPfsExport to see if the server of a prefix still exists.
 *
 * Results:
 *	TRUE if the server process is still around.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ENTRY Boolean
FsPdevServerOK(pdevHandlePtr)
    PdevServerIOHandle *pdevHandlePtr;	/* State for the pseudo stream */
{
    register Boolean answer;
    LOCK_MONITOR;
    if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	answer = FALSE;
    } else {
	answer = TRUE;
    }
    UNLOCK_MONITOR;
    return(answer);
}

/*
 *----------------------------------------------------------------------
 *
d351 35
d387 23
d414 67
d929 6
a934 4
	     * We open this connection and return a user-level streamID to
	     * the server for its half of the connection, and we pass an
	     * I/O fileID to the client process so it can set up the other
	     * half of the connection.
d936 2
a937 2
	    int newStreamID;
	    FsOpenResults openResults;
d939 2
a940 1
	    if (outBufPtr == (Fs_Buffer *)NIL || outBufPtr->size < sizeof(int)){
d944 1
a944 1
						  &openResults.ioFileID);
d956 3
a958 1
		     * kernel stack (it's waiting in FsPfsOpen).
d1194 1
a1194 1
	    status = DEV_OFFLINE;
d1210 1
a1210 1
	    status = DEV_OFFLINE;
a1215 5
    /*
     * Map the rootID in the arguments to the user-level version.
     */
    ((FsLookupArgs *)argsPtr)->rootID = pdevHandlePtr->userLevelID;

d1233 7
d1604 4
d1622 1
a1622 1
	if (replySize == sizeof(int)) {
d1624 1
a1624 1
	     * Pay attention to the number of bytes the server accepted.
d1626 2
a1627 2
	    length = numBytes;
	} else if ((pdevHandlePtr->flags & PDEV_WRITE_BEHIND) == 0) {
d1629 1
d1631 11
a1641 4
	toWrite -= length;
	request.param.write.offset += length;
	amountWritten += length;
	buffer += length;
a1921 28
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * FsPdevGetUserLevelID --
 *
 *	Return the user-level file ID associated with a pdev connection.
 *	This is called from FsPfsOpen to get the user-level ID for the
 *	pdev-connections involved in a naming operation.
 *
 * Results:
 *	Sets its fileID argument to contain the user-level ID.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ENTRY void
FsPdevGetUserLevelID(pdevHandlePtr, fileIDPtr)
    PdevServerIOHandle *pdevHandlePtr;
    Fs_FileID *fileIDPtr;
{
    LOCK_MONITOR;
    *fileIDPtr = pdevHandlePtr->userLevelID;
@


6.19
log
@FsFileID FsUserID change
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: fsPdev.c,v 6.18 88/10/14 10:37:40 brent Exp $ SPRITE (Berkeley)";
d190 3
d236 14
d293 31
d1058 15
d1295 5
d1987 28
@


6.18
log
@Added IOC_PFS_OPEN and FsPseudoGet/SetAttr
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: fsPdev.c,v 6.17 88/10/11 16:03:55 brent Exp $ SPRITE (Berkeley)";
d134 1
a134 1
    FsFileID	*ioFileIDPtr;	/* File ID used for pseudo stream handle */
d1274 1
a1274 1
    register FsFileID		*fileIDPtr;	/* Identfies pdev connection */
d1338 1
a1338 1
    register FsFileID		*fileIDPtr;	/* Identfies pdev connection */
d1340 1
a1340 1
    FsUserIDs			*idPtr;		/* Identfies user */
@


6.17
log
@Tweaked RequestResponse() interface to handle pseudo-filesystems.
Added FsPseudoStreamLookup() as general lookup routine for pfs.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: fsPdev.c,v 6.16 88/10/03 09:06:06 brent Exp $ SPRITE (Berkeley)";
d961 55
d1156 1
a1156 1
    status = RequestResponse(pdevHandlePtr, sizeof(Pdev_Request), &request,
d1205 15
d1221 3
d1248 126
@


6.16
log
@Broke this up in to fsPdevSetup.c, fsPdevControl.c, fsPdevTrace.c,
and fsPdev.c.  This file now has routines directly related
to the RequestResponse protocol.
@
text
@d36 1
a36 1
static char rcsid[] = "$Header: fsPdev.c,v 6.15 88/09/28 15:24:19 douglis Exp $ SPRITE (Berkeley)";
d133 1
a133 1
FsServerStreamCreate(ioFileIDPtr, slaveClientID, name)
a134 1
    int		slaveClientID;	/* Host ID of client process */
d298 2
a299 2
RequestResponse(pdevHandlePtr, requestPtr, inputSize, inputBuf, replySize,
	replyBuf, replySizePtr, waitPtr)
d302 3
a304 1
    register Pdev_Request *requestPtr;	/* The caller should fill in the
d359 10
a368 4
    requestPtr->magic = PDEV_REQUEST_MAGIC;
    requestPtr->requestSize = inputSize;
    requestPtr->replySize = replySize;
    requestPtr->messageSize = sizeof(Pdev_Request) +
d370 1
a370 1
    if (pdevHandlePtr->requestBuf.size < requestPtr->messageSize) {
d375 2
a376 2
    PDEV_REQUEST_PRINT(&pdevHandlePtr->hdr.fileID, requestPtr);
    PDEV_REQUEST(&pdevHandlePtr->hdr.fileID, requestPtr);
d399 1
a399 1
	lastByte = requestPtr->messageSize - 1;
d402 1
a402 1
	if (room < requestPtr->messageSize) {
d419 1
a419 1
	    lastByte = requestPtr->messageSize - 1;
d425 1
a425 1
	    lastByte += requestPtr->messageSize;
d428 1
a428 1
    pdevHandlePtr->operation = requestPtr->operation;
d443 1
a443 1
    status = Vm_CopyOutProc(sizeof(Pdev_Request), (Address)requestPtr, TRUE,
d445 1
a445 1
			        &pdevHandlePtr->requestBuf.data[firstByte]);
d447 1
a447 1
	firstByte += sizeof(Pdev_Request);
d1063 1
a1063 1
    register PdevServerIOHandle *pdevHandlePtr;/* Client's pseudo stream. */
d1094 1
a1094 1
    request.operation		= PDEV_OPEN;
d1101 3
a1103 2
    status = RequestResponse(pdevHandlePtr, &request, 0, (Address) NIL, 0,
			 (Address) NIL, (int *)NIL, (Sync_RemoteWaiter *)NIL);
d1114 71
d1308 1
a1308 1
	request.operation		= PDEV_READ;
d1314 2
a1315 2
	status = RequestResponse(pdevHandlePtr, &request, 0, (Address) NIL,
				 *lenPtr, buffer, lenPtr, waitPtr);
d1397 1
a1397 1
    request.operation			= PDEV_WRITE;
d1422 1
a1422 1
	replySize = (pdevHandlePtr->flags&PDEV_WRITE_BEHIND) ? -1 :
d1424 2
a1425 1
	status = RequestResponse(pdevHandlePtr, &request, length, buffer,
d1551 1
a1551 1
    request.operation			= PDEV_IOCTL;
d1557 3
a1559 2
    status = RequestResponse(pdevHandlePtr, &request, inBufPtr->size,
			     inBufPtr->addr, outBufPtr->size, outBufPtr->addr,
d1713 4
a1716 3
    request.operation = PDEV_CLOSE;
    (void) RequestResponse(pdevHandlePtr, &request, 0, (Address)NIL,
		    0, (Address)NIL, (int *) NIL, (Sync_RemoteWaiter *)NIL);
@


6.15
log
@Changes to support process migration (for client streams, not servers so far).
@
text
@d4 5
a8 17
 *	Routines to implement pseudo-devices. A pseudo-device is a file
 *	that acts as a communication channel between a user-level server
 *	process (hereafter called the "server"), and one or more client
 *	processes (hereafter called the "client"). Regular filesystem system
 *	calls (Fs_Read, Fs_Write, Fs_IOControl, Fs_Close) by a client process
 *	are forwarded to a special user process called the "server".  The
 *	server process can implement any sort of sementics for the file
 *	operations. The general format of Fs_IOControl, in particular, 
 *	lets the server implement any remote procedure call it cares to define.
 *	
 *	There are three kinds of streams involved in the implementation,
 *	a "control" stream that is returned to the server when it first
 *	opens the pseudo-device, a "client" stream that is returned to
 *	client processes when they open the pseudo-device, and finally
 *	there is a "server" stream for each client stream.  The server
 *	stream is created when a client opens the pseudo-device and it
 *	is passed to the server process using the control stream.
d10 2
a11 8
 *	The first routines in this file are the open and close routines
 *	for these kinds of streams.  The next main routine is RequestResponse
 *	which implements the client side of the communication protocol
 *	between the client and the server.  The server side is implemented
 *	mainly by the server stream IOControl procedure.  Finally there
 *	are the various routines for I/O, recovery, etc.
 *
 *	A buffering scheme is used to improve the performance of pseudo streams.
d17 1
a17 1
 *	the request buffer.  Write requests do not require a response from
d36 1
a36 1
static char rcsid[] = "$Header: fsPdev.c,v 6.14 88/09/23 14:35:26 brent Exp $ SPRITE (Berkeley)";
a58 8
Boolean fsPdevDebug = FALSE;		/* Turns on print statements */
Trace_Header pdevTraceHdr;
Trace_Header *pdevTraceHdrPtr = &pdevTraceHdr;
int pdevTraceLength = 200;
Boolean pdevTracing = TRUE;		/* Turns on circular trace */
int pdevMaxTraceDataSize;
int pdevTraceIndex = 0;

a59 115
 * PdevControlHandle is the I/O handle for the server's control stream.
 * There is a control handle kept on both on the file server and on the
 * host running the server process.  The one on the file server is used
 * by the SrvOpen routine to detect if a master exists, and the one on
 * the server's host is used for control messages, and it also is used
 * to detect if the server process is still alive (by looking at serverID).
 * There are not two different types of control handles because the differences
 * only come into play at close time.
 */
typedef struct PdevControlIOHandle {
    FsRemoteIOHandle rmt;	/* Type FS_CONTROL_STREAM.  This needs to
				 * be a remote I/O handle in order to do
				 * a remote close to the name server so
				 * the serverID field gets cleaned up right. */
    int serverID;		/* Host ID of server process.  If NIL it
				 * means there is no server.  This is kept */
    List_Links	queueHdr;	/* Control message queue */
    int	seed;			/* Used to make FileIDs for client handles */
    List_Links readWaitList;	/* So the server can wait for control msgs */
    FsLockState lock;		/* So the server can lock the pdev file */
} PdevControlIOHandle;

/*
 * Because there are corresponding control handles on the file server,
 * which records which host has the pdev server, and on the pdev server
 * itself, we need to be able to reopen the control handle on the
 * file server after it reboots.
 */
typedef struct PdevControlReopenParams {
    FsFileID	fileID;		/* FileID of the control handle */
    int		serverID;	/* ServerID recorded in control handle.
				 * This may be NIL if the server closes
				 * while the file server is down. */
    int		seed;		/* Used to create unique pseudo-stream fileIDs*/
} PdevControlReopenParams;

/*
 * The following control messages are passed internally from the
 * ServerStreamCreate routine to the FsControlRead routine.
 * They contain a streamPtr for a new server stream
 * that gets converted to a user-level streamID in FsControlRead.
 */

typedef struct PdevNotify {
    List_Links links;
    Fs_Stream *streamPtr;
} PdevNotify;

/*
 * Circular buffers are used for a request buffer and a read data buffer.
 * These buffers are in the address space of the server process so the
 * server can access them without system calls.  The server uses I/O controls
 * to change the pointers.
 */
typedef struct CircBuffer {
    Address data;		/* Location of the buffer in user-space */
    int firstByte;		/* Byte index of first valid data in buffer.
				 * if -1 then the buffer is empty */
    int lastByte;		/* Byte index of last valid data in buffer. */
    int size;			/* Number of bytes in the circular buffer */
} CircBuffer;

/*
 * PdevServerIOHandle has the main state for a client-server connection.
 * The client's handle is a stub which just has a pointer to this handle.
 */
typedef struct PdevServerIOHandle {
    FsHandleHeader hdr;		/* Standard header, type FS_LCL_PSEUDO_STREAM */
    Sync_Lock lock;		/* Used to synchronize access to this struct.
				 * The handle lock won't do because we
				 * use condition variables. */
    int flags;			/* Flags defined below */
    int selectBits;		/* Select state of the pseudo-stream */
    Proc_PID serverPID;		/* Server's processID needed for copy out */
    Proc_PID clientPID;		/* Client's processID needed for copy out */
    CircBuffer	requestBuf;	/* This buffer contains requests and any data
				 * that needs to follow the request header.
				 * The kernel fills this buffer and the
				 * server takes the requests and data out */
    Address nextRequestBuffer;	/* The address of the next request buffer in
				 * the server's address space to use.  We let
				 * the server change buffers in mid-flight. */
    int nextRequestBufSize;	/* Size of the new request buffer */
    CircBuffer readBuf;		/* This buffer contains read-ahead data for
				 * the pseudo-device.  The server program puts
				 * data here and the kernel removes it to
				 * satisfy client reads. If empty, the kernel
				 * asks the server explicitly for data and
				 * this buffer isn't used. */
    Pdev_Op operation;		/* Current operation.  Checked when handling
				 * the reply. */
    Pdev_Reply reply;	/* The current reply header is stuck here */
    Address replyBuf;		/* Pointer to reply data buffer.  This is in
				 * the client's address space unless the
				 * FS_USER flag is set */
    Sync_Condition setup;	/* This is notified after the server has set
				 * up buffer space for us.  A pseudo stream
				 * can't be used until this is done. */
    Sync_Condition access;	/* Notified after a RequestResponse to indicate
				 * that another client process can use the
				 * pseudo-stream. */
    Sync_Condition caughtUp;	/* This is notified after the server has read
				 * or set the buffer pointers.  The kernel
				 * waits for the server to catch up
				 * before safely resetting the pointers to
				 * the beginning of the buffer */
    Sync_Condition replyReady;	/* Notified after the server has replied */
    List_Links srvReadWaitList;	/* To remember the waiting server process */
    Sync_RemoteWaiter clientWait;/* Client process info for I/O waiting */
    List_Links cltReadWaitList;	/* These lists are used to remember clients */
    List_Links cltWriteWaitList;/*   waiting to read, write, or detect */
    List_Links cltExceptWaitList;/*   exceptions on the pseudo-stream. */
} PdevServerIOHandle;

/*
a87 6
 *	PDEV_REMOTE_CLIENT	This is set when the client process is
 *				on a remote host.  This is needed in order
 *				to properly set the FS_USER flag (defined
 *				next).
 *				If the client is remote the I/O control
 *				buffers are always in kernel space.
a100 1
#define PDEV_REMOTE_CLIENT	0x0400
a103 10
 * The client side stream for a pseudo-device.  This keeps a reference
 * to the server's handle with all the state.
 */
typedef struct PdevClientIOHandle {
    FsHandleHeader	hdr;
    PdevServerIOHandle	*pdevHandlePtr;
    List_Links		clientList;
} PdevClientIOHandle;

/*
a109 2
static	PdevServerIOHandle	*ServerStreamCreate();
static	void			PseudoStreamCloseInt();
a112 202
 *----------------------------------------------------------------------------
 *
 * FsControlHandleInit --
 *
 *	Fetch and initialize a control handle for a pseudo-device.
 *
 * Results:
 *	A pointer to the control stream I/O handle.  The found parameter is
 *	set to TRUE if the handle was already found, FALSE if we created it.
 *
 * Side effects:
 *	Initializes and installs the control handle.
 *
 *----------------------------------------------------------------------------
 *
 */
PdevControlIOHandle *
FsControlHandleInit(fileIDPtr, name, foundPtr)
    FsFileID *fileIDPtr;
    char *name;
    Boolean *foundPtr;
{
    register Boolean found;
    register PdevControlIOHandle *ctrlHandlePtr;
    FsHandleHeader *hdrPtr;

    found = FsHandleInstall(fileIDPtr, sizeof(PdevControlIOHandle), name,
			    &hdrPtr);
    ctrlHandlePtr = (PdevControlIOHandle *)hdrPtr;
    if (!found) {
	ctrlHandlePtr->serverID = NIL;
	List_Init(&ctrlHandlePtr->queueHdr);
	ctrlHandlePtr->seed = 0;
	List_Init(&ctrlHandlePtr->readWaitList);
	FsLockInit(&ctrlHandlePtr->lock);
	FsRecoveryInit(&ctrlHandlePtr->rmt.recovery);
    }
    *foundPtr = found;
    return(ctrlHandlePtr);
}

/*
 *----------------------------------------------------------------------------
 *
 * FsPseudoDevSrvOpen --
 *
 *	Early open time processing, this is called on a fileserver
 *	when setting up state for a call to the CltOpen routines on
 *	the client host.  For pseudo-device server processes, which
 *	are indicated by the FS_MASTER flag, check that no other
 *	server exists.  For all other processes, which are referred to
 *	as "clients", make sure that a server process exists and
 *	generate a new ioFileID for the connection between the client
 *	and the server.
 *
 * Results:
 *	For server processes, SUCCESS if it is now the server,
 *	FS_FILE_BUSY if there already exists a server process.  For
 *	clients, SUCCESS if there is a server or the parameters
 *	indicate this is only for get/set attributes, DEV_OFFLINE if
 *	there is no server. 
 *
 * Side effects:
 *	Save the hostID of the calling process if
 *	it is to be the server for the pseudo-device.
 *
 *----------------------------------------------------------------------------
 *
 */
ReturnStatus
FsPseudoDevSrvOpen(handlePtr, clientID, useFlags, ioFileIDPtr, streamIDPtr,
	dataSizePtr, clientDataPtr)
     register FsLocalFileIOHandle *handlePtr;	/* A handle from FsLocalLookup.
					 * Should be LOCKED upon entry,
					 * unlocked upon exit. */
     int		clientID;	/* Host ID of client doing the open */
     register int	useFlags;	/* FS_MASTER, plus
					 * FS_READ | FS_WRITE | FS_EXECUTE*/
     register FsFileID	*ioFileIDPtr;	/* Return - I/O handle ID */
     FsFileID		*streamIDPtr;	/* Return - stream ID. 
					 * NIL during set/get attributes */
     int		*dataSizePtr;	/* Return - sizeof(FsPdevState) */
     ClientData		*clientDataPtr;	/* Return - a reference to FsPdevState.
					 * Nothing is returned during set/get
					 * attributes */

{
    register	ReturnStatus status = SUCCESS;
    FsFileID	ioFileID;
    Boolean	found;
    register	PdevControlIOHandle *ctrlHandlePtr;
    register	Fs_Stream *streamPtr;
    register	FsPdevState *pdevStatePtr;

    /*
     * The control I/O handle is identified by the fileID of the pseudo-device
     * file with type CONTROL.  The minor field has the disk decriptor version
     * number xor'ed into it to avoid conflict when you delete the
     * pdev file and recreate one with the same file number (minor field).
     * Note, if this mapping is changed here on the file server, then
     * regular control stream recovery by clients won't work.  They will
     * recover their control handles, but we will map to a different handle
     * and thus think there is no server process.
     */
    ioFileID = handlePtr->hdr.fileID;
    ioFileID.type = FS_CONTROL_STREAM;
    ioFileID.minor ^= (handlePtr->descPtr->version << 16);
    ctrlHandlePtr = FsControlHandleInit(&ioFileID, handlePtr->hdr.name,
					&found);

    if (useFlags & (FS_MASTER|FS_NEW_MASTER)) {
	/*
	 * When a server opens we ensure there is only one.
	 */
	if (found && ctrlHandlePtr->serverID != NIL) {
	    status = FS_FILE_BUSY;
	} else {
	    /*
	     * Note which host is running the pseudo-device server.
	     */
	    ctrlHandlePtr->serverID = clientID;
	    /*
	     * Note our hostID is still in the hdr.serverID field of the
	     * control handle being returned to the opening process. This is
	     * used when closing the control stream to get back to us
	     * so we can clear the serverID field here.  We also set up
	     * a shadow stream here, which has us as the server so
	     * recovery and closing work right.
	     */
	    *ioFileIDPtr = ioFileID;
	    *clientDataPtr = (ClientData)NIL;
	    *dataSizePtr = 0;
	    streamPtr = FsStreamNew(rpc_SpriteID,
		(FsHandleHeader *)ctrlHandlePtr, useFlags,
				    handlePtr->hdr.name);
	    *streamIDPtr = streamPtr->hdr.fileID;
	    (void)FsStreamClientOpen(&streamPtr->clientList,
				     clientID,useFlags);
	    FsHandleRelease(streamPtr, TRUE);
	}
    } else {
	if (streamIDPtr == (FsFileID *)NIL) {
	    /*
	     * Set up for get/set attributes.  We point the client
	     * at the name of the pseudo-device, what else?
	     */
	    *ioFileIDPtr = handlePtr->hdr.fileID;
	} else if (!found || ctrlHandlePtr->serverID == NIL) {
	    /*
	     * No server process.
	     */
	    status = DEV_OFFLINE;
	} else {
	    /*
	     * The server exists.  Create a new I/O handle for the client.
	     * The major and minor numbers are generated from the fileID
	     * of the pseudo-device name (to avoid conflict with other
	     * pseudo-devices) and a clone seed (to avoid conflict with
	     * other clients of this pseudo-device).
	     */
	    if (ctrlHandlePtr->serverID == clientID) {
		ioFileIDPtr->type = FS_LCL_PSEUDO_STREAM;
	    } else {
		ioFileIDPtr->type = FS_RMT_PSEUDO_STREAM;
	    }
	    ioFileIDPtr->serverID = ctrlHandlePtr->serverID;
	    ioFileIDPtr->major = (handlePtr->hdr.fileID.serverID << 16) |
				  handlePtr->hdr.fileID.major;
	    ctrlHandlePtr->seed++;
	    ioFileIDPtr->minor = ((handlePtr->descPtr->version << 24) ^
				  (handlePtr->hdr.fileID.minor << 12)) |
				 ctrlHandlePtr->seed;
	    /*
	     * Return the control stream file ID so it can be found again
	     * later when setting up the client's stream and the
	     * corresponding server stream.  The procID and uid fields are
	     * extra here, but will be used later if the client is remote.
	     */
	    pdevStatePtr = Mem_New(FsPdevState);
	    pdevStatePtr->ctrlFileID = ctrlHandlePtr->rmt.hdr.fileID;
	    pdevStatePtr->procID = (Proc_PID)NIL;
	    pdevStatePtr->uid = NIL;
	    *clientDataPtr = (ClientData)pdevStatePtr ;
	    *dataSizePtr = sizeof(FsPdevState);
	    /*
	     * Create a streamID for the opening process.  No shadow
	     * stream is kept here.  Instead, the streamID is returned to
	     * the pdev server who sets up the shadow stream.
	     */
	    streamPtr = FsStreamNew(ctrlHandlePtr->serverID,
			(FsHandleHeader *)NIL, useFlags, handlePtr->hdr.name);
	    *streamIDPtr = streamPtr->hdr.fileID;
	    pdevStatePtr->streamID = streamPtr->hdr.fileID;
	    FsStreamDispose(streamPtr);
	}
    }
    FsHandleRelease(ctrlHandlePtr, TRUE);
    FsHandleUnlock(handlePtr);
    return(status);
}

/*
d115 1
a115 1
 * FsControlCltOpen --
a116 283
 *	Complete setup of the server's control stream.  Called from
 *	Fs_Open on the host running the server.  We mark the Control
 *	I/O handle as having a server (us).
 * 
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Installs the Control I/O handle and keeps a reference to it.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsControlCltOpen(ioFileIDPtr, flagsPtr, clientID, streamData, name,
		 ioHandlePtrPtr)
    register FsFileID	*ioFileIDPtr;	/* I/O fileID */
    int			*flagsPtr;	/* FS_READ | FS_WRITE ... */
    int			clientID;	/* Host doing the open */
    ClientData		streamData;	/* NIL. */
    char		*name;		/* File name for error msgs */
    FsHandleHeader	**ioHandlePtrPtr;/* Return - a locked handle set up for
					 * I/O to a control stream, or NIL */
{
    register PdevControlIOHandle	*ctrlHandlePtr;
    Boolean		found;

    ctrlHandlePtr = FsControlHandleInit(ioFileIDPtr, name, &found);
    if (found && !List_IsEmpty(&ctrlHandlePtr->queueHdr)) {
	Sys_Panic(SYS_FATAL, "FsControlStreamCltOpen found control msgs\n");
    }
    ctrlHandlePtr->serverID = clientID;
    *ioHandlePtrPtr = (FsHandleHeader *)ctrlHandlePtr;
    FsHandleUnlock(ctrlHandlePtr);
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FsPseudoStreamCltOpen --
 *
 *	This is called from Fs_Open, or from the RPC stub if the client
 *	is remote, to complete setup of a client's
 *	stream to the pseudo-device.  The server is running on this
 *	host.  This routine creates a trivial client I/O handle
 *	that references the server's I/O handle that has the main
 *	state for the connection to the server.  ServerStreamCreate
 *	is then called to set up the server's I/O handle, and the control
 *	stream is used to pass a server stream to the server.  Finally
 *	an open transaction is made with the server process
 *	to see if it will accept the client.
 * 
 * Results:
 *	SUCCESS, unless the server process has died recently, or the
 *	server rejects the open.
 *
 * Side effects:
 *	Creates the client's I/O handle.  Calls ServerStreamCreate
 *	which sets up the servers corresponding I/O handle.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
FsPseudoStreamCltOpen(ioFileIDPtr, flagsPtr, clientID, streamData, name,
	ioHandlePtrPtr)
    register FsFileID	*ioFileIDPtr;	/* I/O fileID */
    int			*flagsPtr;	/* FS_READ | FS_WRITE ... */
    int			clientID;	/* Host doing the open */
    ClientData		streamData;	/* Pointer to FsPdevState. */
    char		*name;		/* File name for error msgs */
    FsHandleHeader	**ioHandlePtrPtr;/* Return - a locked handle set up for
					 * I/O to a pseudo device, or NIL */
{
    ReturnStatus		status;
    Boolean			found;
    register PdevClientIOHandle	*cltHandlePtr;
    register PdevControlIOHandle	*ctrlHandlePtr;
    register FsPdevState		*pdevStatePtr;
    Fs_Stream			 *cltStreamPtr;
    Proc_ControlBlock		*procPtr;
    Proc_PID 			procID;
    int				uid;

    pdevStatePtr = (FsPdevState *)streamData;
    ctrlHandlePtr = FsHandleFetchType(PdevControlIOHandle,
				    &pdevStatePtr->ctrlFileID);
    /*
     * If there is no server present the creation of the stream
     * can't succeed.  This case arises when the pseudo-device
     * master goes away between FsPseudoDevSrvOpen and this call.
     */
    if ((ctrlHandlePtr == (PdevControlIOHandle *)NIL) ||
	(ctrlHandlePtr->serverID == NIL)) {
	status = DEV_OFFLINE;
	if (ctrlHandlePtr != (PdevControlIOHandle *)NIL) {
	    FsHandleRelease(ctrlHandlePtr, TRUE);
	}
	goto exit;
    }

    /*
     * Extract the seed from the minor field (see the SrvOpen routine).
     * This done in case of recovery when we'll need to reset the
     * seed kept on the file server.
     */
    ctrlHandlePtr->seed = ioFileIDPtr->minor & 0x0FFF;

    found = FsHandleInstall(ioFileIDPtr, sizeof(PdevClientIOHandle), name,
			    ioHandlePtrPtr);
    cltHandlePtr = (PdevClientIOHandle *)(*ioHandlePtrPtr);
    if (found) {
	if ((cltHandlePtr->pdevHandlePtr != (PdevServerIOHandle *)NIL) &&
	    (cltHandlePtr->pdevHandlePtr->clientPID != (unsigned int)NIL)) {
	    Sys_Panic(SYS_WARNING,
		"FsPseudoStreamCltOpen found client handle\n");
	    Sys_Printf("Check (and kill) client process %x\n",
		cltHandlePtr->pdevHandlePtr->clientPID);
	}
	/*
	 * Invalidate this lingering handle.  The client process is hung
	 * or suspended and hasn't closed its end of the pdev connection.
	 */
	FsHandleInvalidate((FsHandleHeader *)cltHandlePtr);
	FsHandleRelease(cltHandlePtr, TRUE);

	found = FsHandleInstall(ioFileIDPtr, sizeof(PdevClientIOHandle), name,
			ioHandlePtrPtr);
	cltHandlePtr = (PdevClientIOHandle *)(*ioHandlePtrPtr);
	if (found) {
	    Sys_Panic(SYS_FATAL, "FsPseudoStreamCltOpen handle still there\n");
	}
    }
    /*
     * We have to look around and decide if we are being called
     * from Fs_Open, or via RPC from a remote client.  A remote client's
     * processID and uid are passed to us via the FsPdevState.  We also
     * have to ensure that a FS_STREAM exists and has the client
     * on its list so the client's remote I/O ops. are accepted here, and
     * so that we have the right number of client references.
     * The remote client's stream is closed for us by the close rpc stub.
     */
    cltStreamPtr = FsStreamFind(&pdevStatePtr->streamID,
		(FsHandleHeader *)cltHandlePtr, *flagsPtr, name, &found);
    (void)FsStreamClientOpen(&cltStreamPtr->clientList,
			    clientID, *flagsPtr);
    if (clientID == rpc_SpriteID) {
	procPtr = Proc_GetEffectiveProc();
	procID = procPtr->processID;
	uid = procPtr->effectiveUserID;
	FsHandleRelease(cltStreamPtr, TRUE);
    } else {
	procID = pdevStatePtr->procID;
	uid = pdevStatePtr->uid;
	FsHandleUnlock(cltStreamPtr);
    }
    /*
     * Set up a service stream and hook the client handle to it.
     */
    cltHandlePtr->pdevHandlePtr =
	    ServerStreamCreate(ctrlHandlePtr, ioFileIDPtr, clientID, name);
    if (cltHandlePtr->pdevHandlePtr == (PdevServerIOHandle *)NIL) {
	status = FAILURE;
	FsHandleInvalidate((FsHandleHeader *) cltHandlePtr);
	FsHandleRemove(cltHandlePtr);
	(void)FsStreamClientClose(&cltStreamPtr->clientList, clientID);
	/*
	 * I'm not too clear here what to do for cleanup.... FD
	 */
	if (!found) {
	    FsStreamDispose(cltStreamPtr);
	}
	goto exit;
    }
    List_Init(&cltHandlePtr->clientList);
    (void)FsIOClientOpen(&cltHandlePtr->clientList, clientID, 0, FALSE);
    FsHandleRelease(ctrlHandlePtr, TRUE);
    /*
     * Grab an extra reference to the server's handle so the
     * server close routine can remove the handle and it won't
     * go away until the client also closes.
     */
    (void)FsHandleDup((FsHandleHeader *)cltHandlePtr->pdevHandlePtr);
    FsHandleUnlock(cltHandlePtr->pdevHandlePtr);
    /*
     * Now that the request response stream is set up we do
     * our first transaction with the server process to see if it
     * will accept the open.  We unlock the handle and rely on the
     * per-connection monitor lock instead.  This is important because a
     * buggy pseudo-device server could be ignoring this connection
     * request indefinitely, and leaving handles locked for long periods
     * clogs up handle scavenging, and potentially crash callbacks too.
     */
    FsHandleUnlock(cltHandlePtr);
    status = PseudoStreamOpen(cltHandlePtr->pdevHandlePtr, *flagsPtr, clientID,
				procID, uid);
    if (status == SUCCESS) {
	*ioHandlePtrPtr = (FsHandleHeader *)cltHandlePtr;
    } else {
	FsHandleRelease(cltHandlePtr, FALSE);
    }
exit:
    Mem_Free((Address)streamData);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FsRmtPseudoStreamCltOpen --
 *
 *	Complete a remote client's stream to a pseudo-device.
 *	The client is on a different host than the server process.  This
 *	makes an RPC to the server's host to invoke FsPseudoStreamCltOpen.
 *	This host only keeps a FsRemoteIOHandle, and the FsRemoteIOClose
 *	routine is used to close it.
 * 
 * Results:
 *	SUCCESS unless the server process has died recently, then DEV_OFFLINE.
 *
 * Side effects:
 *	RPC to the server's host to invoke the regular setup routines.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsRmtPseudoStreamCltOpen(ioFileIDPtr, flagsPtr, clientID, streamData, name,
	ioHandlePtrPtr)
    register FsFileID	*ioFileIDPtr;	/* I/O fileID */
    int			*flagsPtr;	/* FS_READ | FS_WRITE ... */
    int			clientID;	/* IGNORED (== rpc_SpriteID) */
    ClientData		streamData;	/* NIL for us. */
    char		*name;		/* File name for error msgs */
    FsHandleHeader	**ioHandlePtrPtr;/* Return - a locked handle set up for
					 * I/O to a pseudo device, or NIL */
{
    register ReturnStatus status;
    register FsPdevState *pdevStatePtr = (FsPdevState *)streamData;
    register FsRecoveryInfo *recovPtr;
    Proc_ControlBlock *procPtr;
    FsRemoteIOHandle *rmtHandlePtr;
    Boolean found;

    /*
     * Invoke via RPC FsPseudoStreamCltOpen.  Here we use the procID field
     * of the FsPdevState so that FsPseudoStreamCltOpen can pass them
     * to ServerStreamCreate.
     */
    procPtr = Proc_GetEffectiveProc();
    pdevStatePtr->procID = procPtr->processID;
    pdevStatePtr->uid = procPtr->effectiveUserID;
    ioFileIDPtr->type = FS_LCL_PSEUDO_STREAM;
    status = FsDeviceRemoteOpen(ioFileIDPtr, *flagsPtr,	sizeof(FsPdevState),
				(ClientData)pdevStatePtr);
    if (status == SUCCESS) {
	/*
	 * Install a remote I/O handle and initialize its recovery state.
	 */
	ioFileIDPtr->type = FS_RMT_PSEUDO_STREAM;
	found = FsHandleInstall(ioFileIDPtr, sizeof(FsRemoteIOHandle), name,
		(FsHandleHeader **)&rmtHandlePtr);
	recovPtr = &rmtHandlePtr->recovery;
	if (!found) {
	    FsRecoveryInit(recovPtr);
	}
	recovPtr->use.ref++;
	if (*flagsPtr & FS_WRITE) {
	    recovPtr->use.write++;
	}
	*ioHandlePtrPtr = (FsHandleHeader *)rmtHandlePtr;
	FsHandleUnlock(rmtHandlePtr);
    }
    Mem_Free((Address)pdevStatePtr);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * ServerStreamCreate --
 *
d119 1
a119 6
 *	connection to the client.  A stream to this handle is created
 *	and passed to the server process via the control stream.  Its
 *	address is enqueued in a control message, and later on FsControlRead
 *	will map the address to a user streamID for the server process.
 *	Finally, the PdevServerIOHandle is also returned to our caller
 *	so the client's I/O handle can reference it.
d122 2
a123 1
 *	None.
d127 1
a127 2
 *	is installed and initialized.  Also, a stream for the server
 *	is created and its address is enqueued in a control message.
d132 2
a133 4
static PdevServerIOHandle *
ServerStreamCreate(ctrlHandlePtr, ioFileIDPtr, slaveClientID, name)
    PdevControlIOHandle *ctrlHandlePtr;	/* Control stream of a pseudo-device.
					 * LOCKED on entry, please. */
a139 1
    Fs_Stream *streamPtr;		/* Stream created for server process */
a140 1
    PdevNotify *notifyPtr;		/* Notification message */
a163 3
    if (slaveClientID != rpc_SpriteID) {
	pdevHandlePtr->flags |= PDEV_REMOTE_CLIENT;
    }
a190 19
    /*
     * Create a stream for the server process and notify it of its new
     * client by generating a control message containing the streamID.
     * The server's control read will convert the streamPtr to a streamID
     * suitable for the server process.
     */

    streamPtr = FsStreamNew(rpc_SpriteID, (FsHandleHeader *)pdevHandlePtr,
			    FS_READ|FS_USER, name);
    notifyPtr = Mem_New(PdevNotify);
    notifyPtr->streamPtr = streamPtr;
    List_InitElement((List_Links *)notifyPtr);
    List_Insert((List_Links *)notifyPtr,
		LIST_ATREAR(&ctrlHandlePtr->queueHdr));
    FsHandleUnlock(streamPtr);

    FsFastWaitListNotify(&ctrlHandlePtr->readWaitList);

    FsHandleUnlock(pdevHandlePtr);
a196 118
 * FsPseudoStreamClose --
 *
 *	Close a pseudo stream that's been used by a client to talk to a server.
 *	This issues a close message to the server and then tears down the
 *	state used to implement the pseudo stream connection.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Other than the request-response to the server, this releases the
 *	pseudo stream's reference to the handle.  This may also have
 *	to contact a remote host to clean up references there, too.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsPseudoStreamClose(streamPtr, clientID, procID, flags, size, data)
    Fs_Stream		*streamPtr;	/* Client pseudo-stream to close */
    int			clientID;	/* HostID of client closing */
    Proc_PID		procID;		/* ID of closing process, IGNORED */
    int			flags;		/* IGNORED */
    int			size;		/* Should be zero */
    ClientData		data;		/* IGNORED */
{
    register PdevClientIOHandle *cltHandlePtr =
	    (PdevClientIOHandle *)streamPtr->ioHandlePtr;
    Boolean cache = FALSE;

    DBG_PRINT( ("Client closing pdev %x,%x\n", 
		cltHandlePtr->hdr.fileID.major,
		cltHandlePtr->hdr.fileID.minor) );

    if (!FsIOClientClose(&cltHandlePtr->clientList, clientID, 0, &cache)) {
	/*
	 * Invalid client trying to close.
	 */
	Sys_Panic(SYS_WARNING, "FsPseudoStreamClose: client %d not found\n",
	    clientID);
	FsHandleUnlock(cltHandlePtr);
	return(GEN_INVALID_ARG);
    } else if (!List_IsEmpty(&cltHandlePtr->clientList)) {
	/*
	 * Still clients out there.
	 */
	FsHandleUnlock(cltHandlePtr);
    } else {
	/*
	 * No clients remaining so we can close down the connection.
	 * Notify the server that a client has gone away.  Then we get rid
	 * of our reference to the server's handle and nuke our own.
	 */
	PseudoStreamCloseInt(cltHandlePtr->pdevHandlePtr);
	FsHandleRelease(cltHandlePtr->pdevHandlePtr, FALSE);
	FsHandleRelease(cltHandlePtr, TRUE);
	FsHandleRemove(cltHandlePtr);
    }
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * PseudoStreamCloseInt --
 *
 *	Do a close request-response with the server.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ENTRY static void
PseudoStreamCloseInt(pdevHandlePtr)
    register PdevServerIOHandle *pdevHandlePtr;
{
    Pdev_Request	request;

    LOCK_MONITOR;

    if ((pdevHandlePtr->flags & PDEV_SETUP) == 0) {
	/*
	 * Server never set the stream up so we obviously can't contact it.
	 */
	goto exit;
    }
    /*
     * Wait for exclusive access to the stream.
     */
    while (pdevHandlePtr->flags & PDEV_BUSY) {
	(void)Sync_Wait(&pdevHandlePtr->access, FALSE);
	if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	    goto exit;
	}
    }
    pdevHandlePtr->flags |= PDEV_BUSY;
    /*
     * Someday we could set up a timeout call-back here in case
     * the server never replies.
     */
    request.operation = PDEV_CLOSE;
    (void) RequestResponse(pdevHandlePtr, &request, 0, (Address)NIL,
		    0, (Address)NIL, (int *) NIL, (Sync_RemoteWaiter *)NIL);
exit:
    pdevHandlePtr->flags &= ~(PDEV_BUSY|FS_USER);
    Sync_Broadcast(&pdevHandlePtr->access);
    UNLOCK_MONITOR;
}


/*
 *----------------------------------------------------------------------
 *
a276 496
 * FsControlSelect --
 *
 *	Select on the server's control stream.  This returns readable
 *	if there are control messages in the queue.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Puts the caller on the handle's read wait list if the control
 *	stream isn't selectable.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
FsControlSelect(hdrPtr, waitPtr, readPtr, writePtr, exceptPtr)
    FsHandleHeader	*hdrPtr;	/* Handle on device to select */
    Sync_RemoteWaiter	*waitPtr;	/* Process info for remote waiting */
    int 		*readPtr;	/* Bit to clear if non-readable */
    int 		*writePtr;	/* Bit to clear if non-writeable */
    int 		*exceptPtr;	/* Bit to clear if non-exceptable */
{
    register PdevControlIOHandle *ctrlHandlePtr =
	    (PdevControlIOHandle *)hdrPtr;

    FsHandleLock(ctrlHandlePtr);
    if (List_IsEmpty(&ctrlHandlePtr->queueHdr)) {
	FsFastWaitListInsert(&ctrlHandlePtr->readWaitList, waitPtr);
	*readPtr = 0;
    }
    *writePtr = *exceptPtr = 0;
    FsHandleUnlock(ctrlHandlePtr);
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FsControlRead --
 *
 *	Read from the server's control stream.  The server learns of new
 *	clients by reading this stream.  Internally the stream is a list
 *	of addresses of streams created for the server.  This routine maps
 *	those addresses to streamIDs for the user level server process and
 *	returns them to the reader.
 *
 * Results:
 *	SUCCESS, FS_WOULD_BLOCK,
 *	or an error code from setting up a new stream ID.
 *
 * Side effects:
 *	The server's list of stream ptrs in the process table is updated.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsControlRead(streamPtr, flags, buffer, offsetPtr, lenPtr, waitPtr)
    Fs_Stream 	*streamPtr;	/* Control stream */
    int		flags;		/* FS_USER is checked */
    Address 	buffer;		/* Where to read into. */
    int		*offsetPtr;	/* IGNORED */
    int 	*lenPtr;	/* In/Out length parameter */
    Sync_RemoteWaiter *waitPtr;	/* Info for waiting */
{
    ReturnStatus 		status = SUCCESS;
    register PdevControlIOHandle *ctrlHandlePtr =
	    (PdevControlIOHandle *)streamPtr->ioHandlePtr;
    Pdev_Notify			notify;		/* Message returned */

    FsHandleLock(ctrlHandlePtr);

    if (List_IsEmpty(&ctrlHandlePtr->queueHdr)) {
	/*
	 * No control messages ready.
	 */
	FsFastWaitListInsert(&ctrlHandlePtr->readWaitList, waitPtr);
	*lenPtr = 0;
	status = FS_WOULD_BLOCK;
    } else {
	register PdevNotify *notifyPtr;
	notifyPtr = (PdevNotify *)List_First(&ctrlHandlePtr->queueHdr);
	List_Remove((List_Links *)notifyPtr);
	notify.magic = PDEV_NOTIFY_MAGIC;
	status = FsGetStreamID(notifyPtr->streamPtr, &notify.newStreamID);
	if (status != SUCCESS) {
	    *lenPtr = 0;
	} else {
	    if (flags & FS_USER) {
		status = Vm_CopyOut(sizeof(notify), (Address) &notify, buffer);
		/*
		 * No need to close on error because the stream is already
		 * installed in the server process's state.  It'll be
		 * closed automatically when the server exits.
		 */
	    } else {
		Byte_Copy(sizeof(notify), (Address)&notify, buffer);
	    }
	    *lenPtr = sizeof(notify);
	}
	Mem_Free((Address)notifyPtr);
    }
    FsHandleUnlock(ctrlHandlePtr);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FsControlIOControl --
 *
 *	IOControls for the control stream.
 *
 * Results:
 *	An error code.
 *
 * Side effects:
 *	Command dependent.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
FsControlIOControl(streamPtr, command, byteOrder, inBufPtr, outBufPtr)
    Fs_Stream *streamPtr;		/* I/O handle */
    int command;			/* File specific I/O control */
    int byteOrder;			/* Client byte order, should be same */
    Fs_Buffer *inBufPtr;		/* Command inputs */
    Fs_Buffer *outBufPtr;		/* Buffer for return parameters */

{
    register PdevControlIOHandle *ctrlHandlePtr =
	    (PdevControlIOHandle *)streamPtr->ioHandlePtr;
    register ReturnStatus status;

    if (byteOrder != mach_ByteOrder) {
	Sys_Panic(SYS_FATAL, "FsControlIOControl: wrong byte order\n");
    }
    switch(command) {
	case IOC_REPOSITION:
	    status = SUCCESS;
	    break;
	case IOC_GET_FLAGS:
	    if ((outBufPtr->size >= sizeof(int)) &&
		(outBufPtr->addr != (Address)NIL)) {
		*(int *)outBufPtr->addr = 0;
	    }
	    status = SUCCESS;
	    break;
	case IOC_SET_FLAGS:
	case IOC_SET_BITS:
	case IOC_CLEAR_BITS:
	    status = SUCCESS;
	    break;
	case IOC_TRUNCATE:
	    status = SUCCESS;
	    break;
	case IOC_LOCK:
	case IOC_UNLOCK:
	    status = FsIocLock(&ctrlHandlePtr->lock, command, byteOrder,
			       inBufPtr, &streamPtr->hdr.fileID);
	    break;
	case IOC_NUM_READABLE: {
	    register int bytesAvailable;

	    if (outBufPtr->size < sizeof(int)) {
		return(GEN_INVALID_ARG);
	    }
	    FsHandleLock(ctrlHandlePtr);
	    if (List_IsEmpty(&ctrlHandlePtr->queueHdr)) {
		bytesAvailable = 0;
	    } else {
		bytesAvailable = sizeof(Pdev_Notify);
	    }
	    FsHandleUnlock(ctrlHandlePtr);
	    status = SUCCESS;
	    *(int *)outBufPtr->addr = bytesAvailable;
	    break;
	}
	case IOC_SET_OWNER:
	case IOC_GET_OWNER:
	case IOC_MAP:
	    status = GEN_NOT_IMPLEMENTED;
	    break;
	default:
	    status = GEN_INVALID_ARG;
	    break;
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FsControlMigStart --
 *
 *	It's too painful to migrate the pseudo-device server.
 *
 * Results:
 *	GEN_NOT_IMPLEMENTED.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsControlMigStart(hdrPtr, flags, clientID, data)
    FsHandleHeader *hdrPtr;	/* File being encapsulated */
    int flags;			/* Use flags from the stream */
    int clientID;		/* Host doing the encapsulation */
    ClientData data;		/* Buffer we fill in */
{
    return(GEN_NOT_IMPLEMENTED);
}

/*
 *----------------------------------------------------------------------
 *
 * FsControlMigEnd --
 *
 *	Reverse the process of encapsulating a control stream
 *
 * Results:
 *	GEN_NOT_IMPLEMENTED.
 *
 * Side effects:
 *	<explain>.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsControlMigEnd(migInfoPtr, size, data, hdrPtrPtr)
    FsMigInfo	*migInfoPtr;	/* Migration state */
    int		size;		/* Zero */
    ClientData	data;		/* NIL */
    FsHandleHeader **hdrPtrPtr;	/* Return - handle for the file */
{
    return(FS_REMOTE_OP_INVALID);
}

/*
 *----------------------------------------------------------------------
 *
 * FsControlVerify --
 *
 *	Verify that the remote server is known for the pseudo-device,
 *	and return a locked pointer to the control I/O handle.
 *
 * Results:
 *	A pointer to the control I/O handle, or NIL if the server is bad.
 *
 * Side effects:
 *	The handle is returned locked and with its refCount incremented.
 *	It should be released with FsHandleRelease.
 *
 *----------------------------------------------------------------------
 */

FsHandleHeader *
FsControlVerify(fileIDPtr, pdevServerHostID)
    FsFileID	*fileIDPtr;		/* control I/O file ID */
    int		pdevServerHostID;	/* Host ID of the client */
{
    register PdevControlIOHandle	*ctrlHandlePtr;
    int serverID = -1;

    ctrlHandlePtr = FsHandleFetchType(PdevControlIOHandle, fileIDPtr);
    if (ctrlHandlePtr != (PdevControlIOHandle *)NIL) {
	if (ctrlHandlePtr->serverID != pdevServerHostID) {
	    serverID = ctrlHandlePtr->serverID;
	    FsHandleRelease(ctrlHandlePtr, TRUE);
	    ctrlHandlePtr = (PdevControlIOHandle *)NIL;
	}
    }
    if (ctrlHandlePtr == (PdevControlIOHandle *)NIL) {
	Sys_Panic(SYS_WARNING,
	    "FsControlVerify, server mismatch (%d not %d) for pdev <%x,%x>\n",
	    pdevServerHostID, serverID, fileIDPtr->major, fileIDPtr->minor);
    }
    return((FsHandleHeader *)ctrlHandlePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * FsControlReopen --
 *
 *	Reopen a control stream.  A control handle is kept on both the
 *	file server as well as the pseudo-device server's host.  If the
 *	file server reboots a reopen has to be done in order to set
 *	the serverID field on the file server so subsequent client opens work.
 *	Thus this is called on a remote client to contact the file server,
 *	and then on the file server from the RPC stub.
 *
 * Results:
 *	SUCCESS if there is no conflict with the server reopening.
 *
 * Side effects:
 *	On the file server the serverID field is set.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsControlReopen(hdrPtr, clientID, inData, outSizePtr, outDataPtr)
    FsHandleHeader	*hdrPtr;
    int			clientID;		/* ID of pdev server's host */
    ClientData		inData;			/* PdevControlReopenParams */
    int			*outSizePtr;		/* IGNORED */
    ClientData		*outDataPtr;		/* IGNORED */

{
    register PdevControlIOHandle *ctrlHandlePtr;
    register PdevControlReopenParams *reopenParamsPtr;
    register ReturnStatus status = SUCCESS;

    if (hdrPtr != (FsHandleHeader *)NIL) {
	/*
	 * Called on the pdev server's host to contact the remote
	 * file server and re-establish state.
	 */
	PdevControlIOHandle *ctrlHandlePtr;
	PdevControlReopenParams params;
	int outSize = 0;

	ctrlHandlePtr = (PdevControlIOHandle *)hdrPtr;
	reopenParamsPtr = &params;
	reopenParamsPtr->fileID = hdrPtr->fileID;
	reopenParamsPtr->serverID = ctrlHandlePtr->serverID;
	reopenParamsPtr->seed = ctrlHandlePtr->seed;
	status = FsSpriteReopen(hdrPtr, sizeof(PdevControlReopenParams),
		(Address)reopenParamsPtr, &outSize, (Address)NIL);
    } else {
	/*
	 * Called on the file server to re-establish a control handle
	 * that corresponds to a control handle on the pdev server's host.
	 */
	Boolean found;

	reopenParamsPtr = (PdevControlReopenParams *)inData;
	ctrlHandlePtr = FsControlHandleInit(&reopenParamsPtr->fileID,
					    (char *)NIL, &found);
	if (reopenParamsPtr->serverID != NIL) {
	    /*
	     * The remote host thinks it is running the pdev server process.
	     */
	    if (!found || ctrlHandlePtr->serverID == NIL) {
		ctrlHandlePtr->serverID = reopenParamsPtr->serverID;
		ctrlHandlePtr->seed = reopenParamsPtr->seed;
	    } else if (ctrlHandlePtr->serverID != clientID) {
		Sys_Panic(SYS_WARNING,
		    "PdevControlReopen conflict, %d lost to %d, pdev <%x,%x>\n",
		    clientID, ctrlHandlePtr->serverID,
		    ctrlHandlePtr->rmt.hdr.fileID.major,
		    ctrlHandlePtr->rmt.hdr.fileID.minor);
		status = FS_FILE_BUSY;
	    }
	} else if (ctrlHandlePtr->serverID == clientID) {
	    /*
	     * The pdev server closed while we were down or unable
	     * to communicate.
	     */
	    ctrlHandlePtr->serverID = NIL;
	}
	FsHandleRelease(ctrlHandlePtr, TRUE);
     }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FsControlClose --
 *
 *	Close a server process's control stream.  After this the pseudo-device
 *	is no longer active and client operations will fail.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Reset the control handle's serverID.
 *	Clears out the state for the control message queue.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsControlClose(streamPtr, clientID, procID, flags, size, data)
    Fs_Stream		*streamPtr;	/* Control stream */
    int			clientID;	/* HostID of client closing */
    Proc_PID		procID;		/* ID of closing process */
    int			flags;		/* Flags from the stream being closed */
    int			size;		/* Should be zero */
    ClientData		data;		/* IGNORED */
{
    register PdevControlIOHandle *ctrlHandlePtr =
	    (PdevControlIOHandle *)streamPtr->ioHandlePtr;
    register PdevNotify *notifyPtr;
    int extra = 0;

    /*
     * Close any server streams that haven't been given to
     * the master process yet.
     */
    while (!List_IsEmpty(&ctrlHandlePtr->queueHdr)) {
	notifyPtr = (PdevNotify *)List_First(&ctrlHandlePtr->queueHdr);
	List_Remove((List_Links *)notifyPtr);
	extra++;
	(void)Fs_Close(notifyPtr->streamPtr);
	Mem_Free((Address)notifyPtr);
    }
    if (extra) {
	Sys_Panic(SYS_WARNING, "FsControlClose found %d left over messages\n",
			extra);
    }
    /*
     * Reset the pseudo-device server ID, both here and at the name server.
     */
    ctrlHandlePtr->serverID = NIL;
    if (ctrlHandlePtr->rmt.hdr.fileID.serverID != rpc_SpriteID) {
	(void)FsSpriteClose(streamPtr, rpc_SpriteID, procID, 0, 0,
		(ClientData)NIL);
    }
    FsHandleRelease(ctrlHandlePtr, TRUE);
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FsControlClientKill --
 *
 *	See if a crashed client was running a pseudo-device master.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Clears the serverID field if it matches the crashed host's ID.
 *	This unlocks the handle before returning.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
void
FsControlClientKill(hdrPtr, clientID)
    FsHandleHeader *hdrPtr;	/* File being encapsulated */
{
    register PdevControlIOHandle *ctrlHandlePtr =
	    (PdevControlIOHandle *)hdrPtr;

    if (ctrlHandlePtr->serverID == clientID) {
	ctrlHandlePtr->serverID = NIL;
	FsHandleRemove(ctrlHandlePtr);
    } else {
        FsHandleUnlock(ctrlHandlePtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * FsControlScavenge --
 *
 *	See if this control stream handle is still needed.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
void
FsControlScavenge(hdrPtr)
    FsHandleHeader *hdrPtr;	/* File being encapsulated */
{
    register PdevControlIOHandle *ctrlHandlePtr = (PdevControlIOHandle *)hdrPtr;

    if (ctrlHandlePtr->serverID == NIL) {
	FsHandleRemove(ctrlHandlePtr);
    } else {
        FsHandleUnlock(ctrlHandlePtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
a504 19

/*
 *----------------------------------------------------------------------
 *
 * PseudoStreamOpen --
 *
 *	Do the first request-response with the server to see if it
 *	will accept the open by the client.   This is used to tell
 *	the server something about the new stream it is getting,
 *	and to let it decide if it will accept the open.
 *
 * Results:
 *	The return status from the server's reply.  It can reject the open.
 *
 * Side effects:
 *	An PDEV_OPEN request-response is carried out.
 *
 *----------------------------------------------------------------------
 */
a505 48
ENTRY ReturnStatus
PseudoStreamOpen(pdevHandlePtr, flags, clientID, procID, userID)
    register PdevServerIOHandle *pdevHandlePtr;/* Client's pseudo stream. */
    int		flags;		/* Open flags */
    int		clientID;	/* Host ID of the client */
    Proc_PID	procID;		/* Process ID of the client process */
    int		userID;		/* User ID of the client process */
{
    register ReturnStatus 	status;
    Pdev_Request		request;

    LOCK_MONITOR;

    /*
     * We have to wait for the server to establish buffer space for
     * the new stream before we can try to use it.
     */
    pdevHandlePtr->flags |= PDEV_BUSY;
    while ((pdevHandlePtr->flags & PDEV_SETUP) == 0) {
	if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	    /*
	     * Server bailed out before we made contact.
	     */
	    status = DEV_OFFLINE;
	    goto exit;
	}
	(void) Sync_Wait(&pdevHandlePtr->setup, FALSE);
    }

    /*
     * Issue the first request to the server to see if it will accept us.
     */

    request.operation		= PDEV_OPEN;
    request.param.open.flags	= flags;
    request.param.open.pid	= procID;
    request.param.open.hostID	= clientID;
    request.param.open.uid	= userID;

    pdevHandlePtr->flags &= ~FS_USER;
    status = RequestResponse(pdevHandlePtr, &request, 0, (Address) NIL, 0,
			 (Address) NIL, (int *)NIL, (Sync_RemoteWaiter *)NIL);
exit:
    pdevHandlePtr->flags &= ~PDEV_BUSY;
    Sync_Broadcast(&pdevHandlePtr->access);
    UNLOCK_MONITOR;
    return(status);
}
d510 1
a510 1
 * FsPseudoStreamRead --
d512 4
a515 4
 *	Read from a pseudo-device stream. If there is data in the read
 *	ahead buffer (if one exists), that is used to satisfy the read.
 *	Otherwise a request-response exchange with the server is used
 *	to do the read.
d518 1
a518 3
 *	SUCCESS, and *lenPtr reflects how much was read.  When the server
 *	goes away EOF is simulated by a SUCCESS return and *lenPtr == 0.
 *	If there is no data in the read ahead buffer FS_WOULD_BLOCK is returned.
d521 1
a521 5
 *	If applicable, pointers into the read ahead buffer are adjusted.
 *	The buffer is filled with the number of bytes indicated by
 *	the length parameter.  The in/out length parameter specifies
 *	the buffer size on input and is updated to reflect the number
 *	of bytes actually read.
d527 2
a528 383
FsPseudoStreamRead(streamPtr, flags, buffer, offsetPtr, lenPtr, waitPtr)
    register Fs_Stream 	*streamPtr;	/* Stream to read from. */
    Address 	buffer;			/* Where to read into. */
    int		*offsetPtr;		/* In/Out byte offset for the read */
    int 	*lenPtr;		/* In/Out byte count parameter */
    Sync_RemoteWaiter *waitPtr;		/* Process info for waiting */
{
    ReturnStatus 	status;
    register PdevClientIOHandle *cltHandlePtr =
	    (PdevClientIOHandle *)streamPtr->ioHandlePtr;
    register PdevServerIOHandle *pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
    Pdev_Request	request;

    LOCK_MONITOR;
    /*
     * Wait for exclusive access to the stream.  Different clients might
     * be using the shared pseudo stream at about the same time.  Things
     * are kept simple by only letting one process through at a time.
     */
    while (pdevHandlePtr->flags & PDEV_BUSY) {
	(void)Sync_Wait(&pdevHandlePtr->access, FALSE);
	if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	    status = DEV_OFFLINE;
	    goto exit;
	}
    }
    pdevHandlePtr->flags |= PDEV_BUSY;

    if (pdevHandlePtr->readBuf.data != (Address)NIL) {
	/*
	 * A read ahead buffer exists so we get data from it.  If it's
	 * empty we put the client on the client I/O handle read wait list.
	 */
	if (pdevHandlePtr->flags & PDEV_READ_BUF_EMPTY) {
	    status = FS_WOULD_BLOCK;
	    FsFastWaitListInsert(&pdevHandlePtr->cltReadWaitList, waitPtr);
	    PDEV_TRACE(&pdevHandlePtr->hdr.fileID, PDEVT_READ_WAIT);
	    DBG_PRINT( ("PDEV %x,%x Read (%d) Blocked\n", 
		    streamPtr->ioHandlePtr->fileID.major,
		    streamPtr->ioHandlePtr->fileID.minor,
		    *lenPtr) );
	    *lenPtr = 0;
	} else {
	    register int dataAvail, firstByte, lastByte, toRead;
	    register Proc_ControlBlock *serverProcPtr;

	    firstByte = pdevHandlePtr->readBuf.firstByte;
	    lastByte = pdevHandlePtr->readBuf.lastByte;
	    dataAvail = lastByte - firstByte + 1;
	    if (dataAvail <= 0) {
		Sys_Panic(SYS_FATAL, 
		    "FsPseudoStreamRead, dataAvail in read buf <= 0 bytes\n");
		status = DEV_OFFLINE;
		goto exit;
	    }
	    /*
	     * Lock down the server process in preparation for copying
	     * from the read ahead buffer.
	     */
	    serverProcPtr = Proc_LockPID(pdevHandlePtr->serverPID);
	    if (serverProcPtr == (Proc_ControlBlock *)NIL) {
		status = DEV_OFFLINE;
		goto exit;
	    }
	    /*
	     * Decide how much to read and note if we empty the buffer.
	     */
	    if (dataAvail > *lenPtr) {
		toRead = *lenPtr;
	    } else {
		toRead = dataAvail;
		pdevHandlePtr->flags |= PDEV_READ_BUF_EMPTY;
	    }
	    DBG_PRINT( ("PDEV %x,%x Read %d Avail %d\n", 
		    pdevHandlePtr->hdr.fileID.major,
		    pdevHandlePtr->hdr.fileID.minor,
		    toRead, dataAvail) );
	    /*
	     * Copy out of the read ahead buffer to the client's buffer.
	     */
	    status = Vm_CopyInProc(toRead, serverProcPtr,
			  pdevHandlePtr->readBuf.data + firstByte,
			  buffer, (flags & FS_USER) == 0);
	    Proc_Unlock(serverProcPtr);
	    /*
	     * Update pointers and poke the server so it can find out.
	     */
	    *lenPtr = toRead;
	    firstByte += toRead;
	    pdevHandlePtr->readBuf.firstByte = firstByte;
	    pdevHandlePtr->flags |= PDEV_READ_PTRS_CHANGED;
	    FsFastWaitListNotify(&pdevHandlePtr->srvReadWaitList);
	}
    } else {
	Proc_ControlBlock	*procPtr;

	/*
	 * No read ahead buffer. Set up and do the request-response exchange.
	 */
	procPtr = Proc_GetEffectiveProc();
	request.operation		= PDEV_READ;
	request.param.read.offset	= *offsetPtr;
	request.param.read.familyID	= procPtr->familyID;
	request.param.read.procID	= procPtr->processID;

	pdevHandlePtr->flags |= (flags & FS_USER);
	status = RequestResponse(pdevHandlePtr, &request, 0, (Address) NIL,
				 *lenPtr, buffer, lenPtr, waitPtr);
    }
exit:
    if (status == DEV_OFFLINE) {
	/*
	 * Simulate EOF
	 */
	status = SUCCESS;
	*lenPtr = 0;
    }
    pdevHandlePtr->flags &= ~(PDEV_BUSY|FS_USER);
    Sync_Broadcast(&pdevHandlePtr->access);
    UNLOCK_MONITOR;
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FsPseudoStreamWrite --
 *
 *	Write to a pseudo-device by a client.  The write is done
 *	asynchronously if the stream allows that.  In that case we
 *	always say we could write as much as requested.  However, if
 *	the write is larger than the server's request buffer we
 *	break it into blocks that each fit. To support UDP, the
 *	stream can also be marked to dis-allow these large writes.
 *	Finally, the stream may be marked synchronous in which case
 *	we tell RequestResponse to wait for a reply.
 *
 * Results:
 *	SUCCESS			- the data was written.
 *
 * Side effects:
 *	The data in the buffer is written to the device.  Large writes
 *	are broken into a series of shorter writes, although we keep
 *	the access lock on the pseudo-stream so the whole write completes.
 *	The in/out length parameter specifies the amount of data to write
 *	and is updated to reflect the number of bytes actually written.
 *
 *----------------------------------------------------------------------
 */
ENTRY ReturnStatus
FsPseudoStreamWrite(streamPtr, flags, buffer, offsetPtr, lenPtr, waitPtr)
    Fs_Stream 	*streamPtr;	/* Stream to write to. */
    int		flags;		/* Flags from the stream */
    Address 	buffer;		/* Where to write to. */
    int		*offsetPtr;	/* In/Out byte offset */
    int 	*lenPtr;	/* In/Out byte count */
    Sync_RemoteWaiter *waitPtr;	/* Process info for waiting on I/O */
{
    register Proc_ControlBlock *procPtr;
    register PdevClientIOHandle *cltHandlePtr =
	    (PdevClientIOHandle *)streamPtr->ioHandlePtr;
    register PdevServerIOHandle *pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
    ReturnStatus 	status = SUCCESS;
    Pdev_Request	request;
    register int	toWrite;
    int			amountWritten;
    register int	length;
    int			replySize;
    int			numBytes;
    int			maxRequestSize;

    LOCK_MONITOR;
    /*
     * Wait for exclusive access to the stream.
     */
    while (pdevHandlePtr->flags & PDEV_BUSY) {
	(void)Sync_Wait(&pdevHandlePtr->access, FALSE);
	if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	    UNLOCK_MONITOR;
	    return(FS_BROKEN_PIPE);
	}
    }
    pdevHandlePtr->flags |= (PDEV_BUSY|(flags & FS_USER));

    /*
     * The write request parameters are the offset and flags parameters.
     * The buffer contains the data to write.
     */
    procPtr = Proc_GetEffectiveProc();
    request.operation			= PDEV_WRITE;
    request.param.write.offset		= *offsetPtr;
    request.param.write.familyID	= procPtr->familyID;
    request.param.write.procID		= procPtr->processID;

    toWrite = *lenPtr;
    amountWritten = 0;
    maxRequestSize = pdevHandlePtr->requestBuf.size - sizeof(Pdev_Request);
    if (toWrite > maxRequestSize &&
	(pdevHandlePtr->flags & PDEV_NO_BIG_WRITES)) {
	Sys_Panic(SYS_WARNING,
	    "Too large a write (%d bytes) attempted on pseudo-device (UDP?)\n",
	    toWrite);
	status = GEN_INVALID_ARG;
	goto exit;
    }
    while ((toWrite > 0) && (status == SUCCESS)) {
	if (toWrite > maxRequestSize) {
	    length = maxRequestSize;
	} else {
	    length = toWrite;
	}
	/*
	 * Do a synchronous or asynchronous write.
	 */
	replySize = (pdevHandlePtr->flags&PDEV_WRITE_BEHIND) ? -1 :
		sizeof(int);
	status = RequestResponse(pdevHandlePtr, &request, length, buffer,
				 replySize, (Address)&numBytes, &replySize,
				 waitPtr);
	if (replySize == sizeof(int)) {
	    /*
	     * Pay attention to the number of bytes the server accepted.
	     */
	    length = numBytes;
	} else if ((pdevHandlePtr->flags & PDEV_WRITE_BEHIND) == 0) {
	    Sys_Panic(SYS_WARNING, "Pdev_Write, no return amtWritten\n");
	}
	toWrite -= length;
	request.param.write.offset += length;
	amountWritten += length;
	buffer += length;
    }
    *lenPtr = amountWritten;
exit:
    if (status == DEV_OFFLINE) {
	/*
	 * Simulate a broken pipe so writers die.
	 */
	status = FS_BROKEN_PIPE;
    }
    pdevHandlePtr->flags &= ~(PDEV_BUSY|FS_USER);
    Sync_Broadcast(&pdevHandlePtr->access);
    UNLOCK_MONITOR;
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FsPseudoStreamIOControl --
 *
 *	IOControls for pseudo-device.  The in parameter block of the
 *	IOControl is passed to the server, and its response is used
 *	to fill the return parameter block of the client.  Remember that
 *	Fs_IOControlStub copies the user buffers into and out of the kernel
 *	so we'll set the FS_USER flag in the serverIOHandle.
 *
 * Results:
 *	SUCCESS			- the operation was successful.
 *
 * Side effects:
 *	None here in the kernel, anyway.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
FsPseudoStreamIOControl(streamPtr, command, byteOrder, inBufPtr, outBufPtr)
    Fs_Stream	*streamPtr;	/* Stream to pseudo-device */
    int		command;	/* The control operation to be performed. */
    int		byteOrder;	/* Client's byte order */
    Fs_Buffer   *inBufPtr;	/* Command inputs */
    Fs_Buffer	*outBufPtr;	/* Buffer for return parameters */
{
    ReturnStatus 	status;
    Pdev_Request	request;
    register Proc_ControlBlock *procPtr;
    register PdevClientIOHandle *cltHandlePtr =
	    (PdevClientIOHandle *)streamPtr->ioHandlePtr;
    register PdevServerIOHandle *pdevHandlePtr = cltHandlePtr->pdevHandlePtr;

    LOCK_MONITOR;
    /*
     * Wait for exclusive access to the stream.
     */
    while (pdevHandlePtr->flags & PDEV_BUSY) {
	(void)Sync_Wait(&pdevHandlePtr->access, FALSE);
	if (pdevHandlePtr->flags & PDEV_SERVER_GONE) {
	    status = DEV_OFFLINE;
	    goto exit;
	}
    }
    pdevHandlePtr->flags |= PDEV_BUSY;

    /*
     * Decide if the buffers are already in the kernel or not.  The buffers
     * for generic I/O controls are copied in, and if we are being called
     * from an RPC stub they are also in kernel space.
     */
    if ((command > IOC_GENERIC_LIMIT) &&
	(inBufPtr->flags & FS_USER) != 0) {
	pdevHandlePtr->flags |= FS_USER;

    }

    switch (command) {
	/*
	 * Trap out the IOC_NUM_READABLE here if there's a read ahead buf.
	 */
	case IOC_NUM_READABLE: {
	    if (pdevHandlePtr->readBuf.data != (Address)NIL) {
		int bytesAvail;
		if (pdevHandlePtr->flags & PDEV_READ_BUF_EMPTY) {
		    bytesAvail = 0;
		} else {
		    bytesAvail = pdevHandlePtr->readBuf.lastByte -
				 pdevHandlePtr->readBuf.firstByte + 1;
		}
		status = SUCCESS;
		if (byteOrder != mach_ByteOrder) {
		    int size = sizeof(int);
		    Swap_Buffer((Address)&bytesAvail, sizeof(int),
			mach_ByteOrder, byteOrder, "w", outBufPtr->addr, &size);
		    if (size != sizeof(int)) {
			status = GEN_INVALID_ARG;
		    }
		} else if (outBufPtr->size != sizeof(int)) {
		    status = GEN_INVALID_ARG;
		} else {
		    *(int *)outBufPtr->addr = bytesAvail;
		}
		DBG_PRINT( ("IOC  %x,%x num readable %d\n",
			pdevHandlePtr->hdr.fileID.major,
			pdevHandlePtr->hdr.fileID.minor,
			bytesAvail) );
		goto exit;
	    }
	    break;
	}
    }

    procPtr = Proc_GetEffectiveProc();
    request.operation			= PDEV_IOCTL;
    request.param.ioctl.command		= command;
    request.param.ioctl.familyID	= procPtr->familyID;
    request.param.ioctl.procID		= procPtr->processID;
    request.param.ioctl.byteOrder	= byteOrder;

    status = RequestResponse(pdevHandlePtr, &request, inBufPtr->size,
			     inBufPtr->addr, outBufPtr->size, outBufPtr->addr,
			     (int *) NIL, (Sync_RemoteWaiter *)NIL);
exit:
    pdevHandlePtr->flags &= ~(PDEV_BUSY|FS_USER);
    Sync_Broadcast(&pdevHandlePtr->access);
    UNLOCK_MONITOR;
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * FsPseudoStreamSelect --
 *
 *	Select on a pseudo-device.  This is done by checking the stream
 *	state kept on the host of the server.  If the pseudo device isn't
 *	selectable we just return and let the server's IOC_PDEV_READY
 *	IOControl do the wakeup for us. (ie. we don't use the handle wait
 *	lists.)
 *
 * Results:
 *	SUCCESS	or FS_WOULD_BLOCK
 *
 * Side effects:
 *	*outFlagsPtr modified to indicate whether the device is
 *	readable or writable.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
FsPseudoStreamSelect(hdrPtr, waitPtr, readPtr, writePtr, exceptPtr)
    FsHandleHeader	*hdrPtr;	/* Handle on pdev to select */
d534 1
a534 3
    ReturnStatus status;
    register PdevClientIOHandle *cltHandlePtr = (PdevClientIOHandle *)hdrPtr;
    register PdevServerIOHandle *pdevHandlePtr = cltHandlePtr->pdevHandlePtr;
d537 7
a543 15

    PDEV_TSELECT(&cltHandlePtr->hdr.fileID, *readPtr, *writePtr, *exceptPtr);

    if ((pdevHandlePtr->flags & PDEV_SERVER_GONE) ||
	(pdevHandlePtr->flags & PDEV_SETUP) == 0) {
	status = DEV_OFFLINE;
    } else {
	if (*readPtr) {
	    if (((pdevHandlePtr->readBuf.data == (Address)NIL) &&
		 ((pdevHandlePtr->selectBits & FS_READABLE) == 0)) ||
		((pdevHandlePtr->readBuf.data != (Address)NIL) &&
		 (pdevHandlePtr->flags & PDEV_READ_BUF_EMPTY))) {
		*readPtr = 0;
		FsFastWaitListInsert(&pdevHandlePtr->cltReadWaitList, waitPtr);
	    }
a544 9
	if (*writePtr && ((pdevHandlePtr->selectBits & FS_WRITABLE) == 0)) {
	    *writePtr = 0;
	    FsFastWaitListInsert(&pdevHandlePtr->cltWriteWaitList, waitPtr);
	}    
	if (*exceptPtr && ((pdevHandlePtr->selectBits & FS_EXCEPTION) == 0)) {
            *exceptPtr = 0;
	    FsFastWaitListInsert(&pdevHandlePtr->cltExceptWaitList, waitPtr);
	}
	status = SUCCESS;
d546 2
d549 1
a549 1
    return(status);
a550 1

a554 35
 * PdevClientNotify --
 *
 *	Wakeup any processes selecting or blocking on the pseudo-stream.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

INTERNAL static void
PdevClientNotify(pdevHandlePtr)
    PdevServerIOHandle *pdevHandlePtr;
{
    register int selectBits = pdevHandlePtr->selectBits;

    PDEV_WAKEUP(&pdevHandlePtr->hdr.fileID, pdevHandlePtr->clientPID,
		pdevHandlePtr->selectBits);
    if (selectBits & FS_READABLE) {
	FsFastWaitListNotify(&pdevHandlePtr->cltReadWaitList);
    }
    if (selectBits & FS_WRITABLE) {
	FsFastWaitListNotify(&pdevHandlePtr->cltWriteWaitList);
    }
    if (selectBits & FS_EXCEPTION) {
	FsFastWaitListNotify(&pdevHandlePtr->cltExceptWaitList);
    }
}

/*
 *----------------------------------------------------------------------
 *
d1038 1
a1038 1
 * FsServerStreamSelect --
d1040 4
a1043 4
 *	Select a server's request/response stream.  This returns
 *	FS_READABLE in the outFlags if there is data in the
 *	server's request buffer.  The next read on the server stream
 *	will return the current pointers into the buffer.
d1046 1
a1046 1
 *	SUCCESS
d1049 1
a1049 1
 *	None.
d1054 7
a1060 7
ReturnStatus
FsServerStreamSelect(hdrPtr, waitPtr, readPtr, writePtr, exceptPtr)
    FsHandleHeader	*hdrPtr;	/* Handle on device to select */
    Sync_RemoteWaiter	*waitPtr;	/* Process info for remote waiting */
    int 		*readPtr;	/* Bit to clear if non-readable */
    int 		*writePtr;	/* Bit to clear if non-writeable */
    int 		*exceptPtr;	/* Bit to clear if non-exceptable */
d1062 2
a1063 1
    register PdevServerIOHandle	*pdevHandlePtr = (PdevServerIOHandle *)hdrPtr;
d1066 13
a1078 7
    if (*readPtr) {
	if (((pdevHandlePtr->flags & PDEV_READ_PTRS_CHANGED) == 0) &&
	     ((pdevHandlePtr->requestBuf.firstByte == -1) ||
	      (pdevHandlePtr->requestBuf.firstByte >=
		  pdevHandlePtr->requestBuf.lastByte))) {
	    *readPtr = 0;
	    FsFastWaitListInsert(&pdevHandlePtr->srvReadWaitList, waitPtr);
d1080 1
d1082 17
a1098 2
    *writePtr = 0;
    *exceptPtr = 0;
d1100 1
a1100 1
    return(SUCCESS);
d1106 1
a1106 1
 * FsServerStreamMigStart --
d1108 4
a1111 1
 *	It's too painful to migrate the pseudo-device server.
d1114 3
a1116 1
 *	GEN_NOT_IMPLEMENTED.
d1119 5
a1123 1
 *	None.
a1126 10
/*ARGSUSED*/
ReturnStatus
FsServerStreamMigStart(hdrPtr, flags, clientID, data)
    FsHandleHeader *hdrPtr;	/* File being encapsulated */
    int flags;			/* Use flags from the stream */
    int clientID;		/* Host doing the encapsulation */
    ClientData data;		/* Buffer we fill in */
{
    return(GEN_NOT_IMPLEMENTED);
}
a1127 16
/*
 *----------------------------------------------------------------------
 *
 * FsServerStreamMigEnd --
 *
 *	Complete migration for a server stream
 *
 * Results:
 *	GEN_NOT_IMPLEMENTED.
 *
 * Side effects:
 *	The streams that compose the Server stream are also deencapsulated.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
d1129 6
a1134 5
FsServerStreamMigEnd(migInfoPtr, size, data, hdrPtrPtr)
    FsMigInfo	*migInfoPtr;	/* Migration state */
    int		size;		/* Zero */
    ClientData	data;		/* NIL */
    FsHandleHeader **hdrPtrPtr;	/* Return - handle for the file */
d1136 5
a1140 73
    return(GEN_NOT_IMPLEMENTED);
}

/*
 *----------------------------------------------------------------------
 *
 * FsPseudoStreamMigStart --
 *
 *	Begin migration of a pseudo-stream client.  We leave the state
 *	alone because the client handle, which is here on the same host
 *	as the pseudo-device master, will still be needed after the
 *	client is remote.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Release the I/O handle.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsPseudoStreamMigStart(hdrPtr, flags, clientID, data)
    FsHandleHeader *hdrPtr;	/* File being encapsulated */
    int flags;			/* Use flags from the stream */
    int clientID;		/* Host doing the encapsulation */
    ClientData data;		/* Buffer we fill in */
{
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FsPseudoStreamMigrate --
 *
 *	Migrate a pseudo-stream client.
 *
 *	This takes care of transfering references from one client to the other.
 *	A useful side-effect of this routine is	to properly set the type in
 *	the ioFileID, either FS_LCL_PSEUDO_STREAM or FS_RMT_PSEUDO_STREAM.
 *	In the latter case FsRmtPseudoStreamMigrate is called to do all
 *	the work.
 *
 * Results:
 *	An error status if the I/O handle can't be set-up.
 *	Otherwise SUCCESS is returned, *flagsPtr may have the FS_RMT_SHARED
 *	bit set, and *sizePtr and *dataPtr are set to reference FsPdevState.
 *
 * Side effects:
 *	Sets the correct stream type on the ioFileID.
 *	Shifts client references from the srcClient to the destClient.
 *	Set up and return FsPdevState for use by the MigEnd routine.
 
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsPseudoStreamMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr, sizePtr,
		      dataPtr)
    FsMigInfo	*migInfoPtr;	/* Migration state */
    int		dstClientID;	/* ID of target client */
    int		*flagsPtr;	/* In/Out Stream usage flags */
    int		*offsetPtr;	/* Return - new stream offset */
    int		*sizePtr;	/* Return - sizeof(FsPdevState) */
    Address	*dataPtr;	/* Return - pointer to FsPdevState */
{
    PdevClientIOHandle			*cltHandlePtr;
    register Fs_Stream			*streamPtr;
    Boolean				found;
    Boolean				cache = FALSE;
d1142 1
a1142 21
    if (migInfoPtr->ioFileID.serverID != rpc_SpriteID) {
	/*
	 * The device was local, which is why we were called, but is
	 * now remote.
	 */
	migInfoPtr->ioFileID.type = FS_RMT_PSEUDO_STREAM;
	return(FsRmtPseudoStreamMigrate(migInfoPtr, dstClientID, flagsPtr,
					offsetPtr, sizePtr, dataPtr));
    }
    migInfoPtr->ioFileID.type = FS_LCL_PSEUDO_STREAM;
    cltHandlePtr = FsHandleFetchType(PdevClientIOHandle, &migInfoPtr->ioFileID);
    if (cltHandlePtr == (PdevClientIOHandle *)NIL) {
	Sys_Panic(SYS_FATAL, "FsPseudoStreamMigrate, no client handle <%d,%x,%x>\n",
		migInfoPtr->ioFileID.serverID,
		migInfoPtr->ioFileID.major, migInfoPtr->ioFileID.minor);
	return(FAILURE);
    }
    DBG_PRINT( ("Migrating pdev %x,%x, ref %d.\n", 
		cltHandlePtr->hdr.fileID.major,
		cltHandlePtr->hdr.fileID.minor,
		cltHandlePtr->hdr.refCount) );
d1144 3
a1146 2
     * At the stream level, add the new client to the set of clients
     * for the stream, and check for any cross-network stream sharing.
d1148 10
a1157 4
    streamPtr = FsStreamFind(&migInfoPtr->streamID,
			     (FsHandleHeader *)cltHandlePtr, migInfoPtr->flags,
			     (char *)NIL, &found);
    if ((streamPtr->flags & FS_RMT_SHARED) == 0) {
d1159 2
a1160 2
	 * We don't think the stream is being shared so we
	 * grab the offset from the client.
d1162 63
a1224 3
	streamPtr->offset = migInfoPtr->offset;
    }
    if ((migInfoPtr->flags & FS_RMT_SHARED) == 0) {
d1226 1
a1226 2
	 * The client doesn't perceive sharing of the stream so
	 * it must be its last reference so we do an I/O close.
d1228 9
a1236 2
	(void)FsStreamClientClose(&streamPtr->clientList,
				migInfoPtr->srcClientID);
d1238 2
a1239 2
    if (FsStreamClientOpen(&streamPtr->clientList, dstClientID,
	    migInfoPtr->flags)) {
d1241 1
a1241 1
	 * We detected network sharing so we mark the stream.
d1243 2
a1244 2
	streamPtr->flags |= FS_RMT_SHARED;
	migInfoPtr->flags |= FS_RMT_SHARED;
d1246 4
a1249 36
    FsHandleRelease(streamPtr, TRUE);
    /*
     * Move the client at the I/O handle level.  We are careful to only
     * close the srcClient if its migration state indicates it isn't
     * shared.  We are careful to only open the dstClient if it getting
     * the stream for the first time.
     */
    if ((migInfoPtr->flags & FS_RMT_SHARED) == 0) {
	found = FsIOClientClose(&cltHandlePtr->clientList,
		    migInfoPtr->srcClientID, migInfoPtr->flags, &cache);
	if (!found) {
	    Sys_Panic(SYS_WARNING,
		"FsPseudoStreamMigrate, IO Client %d not found\n",
		migInfoPtr->srcClientID);
	}
    }
    if (migInfoPtr->flags & FS_NEW_STREAM) {
	(void)FsIOClientOpen(&cltHandlePtr->clientList, dstClientID,
		migInfoPtr->flags, FALSE);
    }

    if (dstClientID == rpc_SpriteID) {
	cltHandlePtr->pdevHandlePtr->flags &= ~PDEV_REMOTE_CLIENT;
    } else {
	cltHandlePtr->pdevHandlePtr->flags |= PDEV_REMOTE_CLIENT;
    }

    *sizePtr = 0;
    *dataPtr = (Address)NIL;
    *flagsPtr = streamPtr->flags;
    *offsetPtr = streamPtr->offset;
    /*
     * We don't need this reference on the I/O handle; there is no change.
     */
    FsHandleRelease(cltHandlePtr, TRUE);
    return(SUCCESS);
d1255 1
a1255 1
 * FsRmtPseudoStreamMigrate --
d1257 8
a1264 5
 *	Migrate a pseudo-stream client.
 *	This takes care of transfering references from one client to the other.
 *	A useful side-effect of this routine is	to properly set the type in
 *	the ioFileID, either FS_LCL_PSEUDO_STREAM or FS_RMT_PSEUDO_STREAM.
 *	In the former case FsPseudoStreamMigrate is called to do all the work.
d1267 1
a1267 3
 *	An error status if the I/O handle can't be set-up.
 *	Otherwise SUCCESS is returned, *flagsPtr may have the FS_RMT_SHARED
 *	bit set, and *sizePtr and *dataPtr are set to reference FsPdevState.
d1270 5
a1274 2
 *	Sets the correct stream type on the ioFileID.
 *	Shifts client references from the srcClient to the destClient.
d1278 8
a1285 10
/*ARGSUSED*/
ReturnStatus
FsRmtPseudoStreamMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr,
			 sizePtr, dataPtr)
    FsMigInfo	*migInfoPtr;	/* Migration state */
    int		dstClientID;	/* ID of target client */
    int		*flagsPtr;	/* In/Out Stream usage flags */
    int		*offsetPtr;	/* Return - the new stream offset */
    int		*sizePtr;	/* Return - 0 */
    Address	*dataPtr;	/* Return - NIL */
d1287 12
a1298 1
    register ReturnStatus		status;
d1300 40
a1339 1
    if (migInfoPtr->ioFileID.serverID == rpc_SpriteID) {
d1341 1
a1341 1
	 * The device was remote, which is why we were called, but is now local.
d1343 17
a1359 3
	migInfoPtr->ioFileID.type = FS_LCL_PSEUDO_STREAM;
	return(FsPseudoStreamMigrate(migInfoPtr, dstClientID, flagsPtr,
				     offsetPtr, sizePtr, dataPtr));
d1361 7
a1367 12
    migInfoPtr->ioFileID.type = FS_RMT_PSEUDO_STREAM;
    status = FsNotifyOfMigration(migInfoPtr, flagsPtr, offsetPtr,
				0, (Address)NIL);
    DBG_PRINT( ("Migrating remote pdev %x,%x.\n", 
		migInfoPtr->ioFileID.major,
		migInfoPtr->ioFileID.minor) );
    if (status != SUCCESS) {
	Sys_Panic(SYS_WARNING, "FsRmtDeviceMigrate, server error <%x>\n",
	    status);
    } else {
	*dataPtr = (Address)NIL;
	*sizePtr = 0;
d1369 3
d1378 1
a1378 1
 * FsPseudoStreamMigEnd --
d1380 5
a1384 4
 *	Complete migration for a pseudo stream.  Complete setup of a 
 *	FS_RMT_DEVICE_STREAM after migration.
 *	The srvMigrate routine has done most all the work.
 *	We just grab a reference on the I/O handle for the stream.
d1387 1
a1387 1
 *	None.
d1390 1
a1390 1
 *	None.
d1394 1
a1394 1
/*ARGSUSED*/
d1396 6
a1401 5
FsPseudoStreamMigEnd(migInfoPtr, size, data, hdrPtrPtr)
    FsMigInfo	*migInfoPtr;	/* Migration state */
    int		size;		/* Zero */
    ClientData	data;		/* NIL */
    FsHandleHeader **hdrPtrPtr;	/* Return - handle for the file */
d1403 6
a1408 1
    register PdevClientIOHandle *cltHandlePtr;
d1410 25
a1434 6
    cltHandlePtr = FsHandleFetchType(PdevClientIOHandle,
				     &migInfoPtr->ioFileID);
    if (cltHandlePtr == (PdevClientIOHandle *)NIL) {
	Sys_Panic(SYS_FATAL, "FsPseudoStreamMigEnd, no handle.\n");
	return(FAILURE);
    } else {
d1436 1
a1436 3
	 * Release this reference so the client handle always has
	 * just one reference.  Instead of refcounts, an empty
	 * client list indicates there are no more clients.
d1438 30
a1467 3
	FsHandleRelease(cltHandlePtr, TRUE);
	*hdrPtrPtr = (FsHandleHeader *)cltHandlePtr;
	return(SUCCESS);
d1469 16
d1486 1
d1491 1
a1491 1
 * FsRmtPseudoStreamVerify --
d1493 5
a1497 2
 *	Verify that the remote client is known for the pdev, and return
 *	a locked pointer to the client I/O handle.
d1500 1
a1500 2
 *	A pointer to the client I/O handle, or NIL if
 *	the client is bad.
d1503 2
a1504 2
 *	The handle is returned locked and with its refCount incremented.
 *	It should be released with FsHandleRelease.
d1509 7
a1515 4
FsHandleHeader *
FsRmtPseudoStreamVerify(fileIDPtr, clientID)
    FsFileID	*fileIDPtr;	/* Client's I/O file ID */
    int		clientID;	/* Host ID of the client */
d1517 3
a1519 3
    register PdevClientIOHandle	*cltHandlePtr;
    register FsClientInfo	*clientPtr;
    Boolean			found = FALSE;
d1521 15
a1535 7
    fileIDPtr->type = FS_LCL_PSEUDO_STREAM;
    cltHandlePtr = FsHandleFetchType(PdevClientIOHandle, fileIDPtr);
    if (cltHandlePtr != (PdevClientIOHandle *)NIL) {
	LIST_FORALL(&cltHandlePtr->clientList, (List_Links *) clientPtr) {
	    if (clientPtr->clientID == clientID) {
		found = TRUE;
		break;
d1538 7
a1544 3
	if (!found) {
	    FsHandleRelease(cltHandlePtr, TRUE);
	    cltHandlePtr = (PdevClientIOHandle *)NIL;
d1546 1
d1548 2
a1549 6
    if (!found) {
	Sys_Panic(SYS_WARNING,
	    "FsRmtPseudoDeviceVerify, client %d not known for pdev <%x,%x>\n",
	    clientID, fileIDPtr->major, fileIDPtr->minor);
    }
    return((FsHandleHeader *)cltHandlePtr);
d1551 1
d1554 1
a1554 1
 *----------------------------------------------------------------------------
d1556 1
a1556 1
 * FsPdevTraceInit --
d1558 1
a1558 2
 *	Initialize the pseudo-device trace buffer.  Used for debugging
 *	and profiling.
a1563 20
 *	Calls to the Trace module to allocate the trace buffer, etc.
 *
 *----------------------------------------------------------------------------
 *
 */
ReturnStatus
FsPdevTraceInit()
{
    Trace_Init(pdevTraceHdrPtr, pdevTraceLength, sizeof(PdevTraceRecord),
		TRACE_NO_TIMES);
}

/*
 *----------------------------------------------------------------------------
 *
 * Fs_PdevPrintRec --
 *
 *	Print a record of the pseudo-device trace buffer.
 *
 * Results:
d1566 1
a1566 5
 * Side effects:
 *	Sys_Printf's
 *
 *----------------------------------------------------------------------------
 *
d1568 4
a1571 5
ReturnStatus
Fs_PdevPrintRec(clientData, event, printHeaderFlag)
    ClientData clientData;	/* Client data in the trace record */
    int event;			/* Type, or event, from the trace record */
    Boolean printHeaderFlag;	/* If TRUE, a header line is printed */
d1573 1
a1573 15
    PdevTraceRecord *recPtr = (PdevTraceRecord *)clientData;
    PdevTraceRecType pdevEvent = (PdevTraceRecType)event;
    if (printHeaderFlag) {
	/*
	 * Print column headers and a newline.
	 */
	Sys_Printf("%6s %17s %8s\n", "REC", "  <File ID>  ", " Event ");
    }
    if (recPtr != (PdevTraceRecord *)NIL) {
	/*
	 * Print out the fileID that's part of each record.
	 */
	Sys_Printf("%5d| ", recPtr->index);
	Sys_Printf("<%8x,%8x> ",
	  recPtr->fileID.major, recPtr->fileID.minor);
d1575 4
a1578 113
	switch(pdevEvent) {
	    case PDEVT_SRV_OPEN:
		Sys_Printf("Srv Open");
		Sys_Printf(" refs %d writes %d",
			    recPtr->un.use.ref,
			    recPtr->un.use.write);
		break;
	    case PDEVT_CLT_OPEN:
		Sys_Printf("Clt Open");
		Sys_Printf(" refs %d writes %d",
			    recPtr->un.use.ref,
			    recPtr->un.use.write);
		 break;
	    case PDEVT_SRV_CLOSE:
		Sys_Printf("Srv Close");
		Sys_Printf(" refs %d writes %d",
			    recPtr->un.use.ref,
			    recPtr->un.use.write);
		 break;
	    case PDEVT_CLT_CLOSE:
		Sys_Printf("Clt Close");
		Sys_Printf(" refs %d writes %d",
			    recPtr->un.use.ref,
			    recPtr->un.use.write);
		 break;
	    case PDEVT_SRV_READ:
		Sys_Printf("Srv Read"); break;
	    case PDEVT_SRV_READ_WAIT:
		Sys_Printf("Srv Read Blocked"); break;
	    case PDEVT_SRV_SELECT:
		Sys_Printf("Srv Select Wait"); break;
	    case PDEVT_SRV_WRITE:
		Sys_Printf("Srv Write"); break;
	    case PDEVT_CNTL_READ:
		Sys_Printf("Control Read"); break;
	    case PDEVT_READ_WAIT:
		Sys_Printf("Wait for Read"); break;
	    case PDEVT_WAIT_LIST:
		Sys_Printf("Wait List Notify"); break;
	    case PDEVT_SELECT: {
		Sys_Printf("Select "); 
		if (recPtr != (PdevTraceRecord *)NIL ) {
		    if (recPtr->un.selectBits & FS_READABLE) {
			Sys_Printf("R");
		    }
		    if (recPtr->un.selectBits & FS_WRITABLE) {
			Sys_Printf("W");
		    }
		    if (recPtr->un.selectBits & FS_EXCEPTION) {
			Sys_Printf("E");
		    }
		}
		break;
	    }
	    case PDEVT_WAKEUP: {
		/*
		 * Print the process ID from the wait info,
		 * and the select bits stashed in the wait info token.
		 */
		Sys_Printf("Wakeup");
		if (recPtr != (PdevTraceRecord *)NIL ) {
		    Sys_Printf(" %x ", recPtr->un.wait.procID);
		    if (recPtr->un.wait.selectBits & FS_READABLE) {
			Sys_Printf("R");
		    }
		    if (recPtr->un.wait.selectBits & FS_WRITABLE) {
			Sys_Printf("W");
		    }
		    if (recPtr->un.wait.selectBits & FS_EXCEPTION) {
			Sys_Printf("E");
		    }
		}
		break;
	    }
	    case PDEVT_REQUEST: {
		Sys_Printf("Request");
		if (recPtr != (PdevTraceRecord *)NIL) {
		    switch(recPtr->un.request.operation) {
			case PDEV_OPEN:
			    Sys_Printf(" OPEN"); break;
			case PDEV_DUP:
			    Sys_Printf(" DUP"); break;
			case PDEV_CLOSE:
			    Sys_Printf(" CLOSE"); break;
			case PDEV_READ:
			    Sys_Printf(" READ"); break;
			case PDEV_WRITE:
			    Sys_Printf(" WRITE"); break;
			case PDEV_IOCTL:
			    Sys_Printf(" IOCTL"); break;
			default:
			    Sys_Printf(" ??"); break;
		    }
		}
		break;
	    }
	    case PDEVT_REPLY: {
		Sys_Printf("Reply");
		if (recPtr != (PdevTraceRecord *)NIL) {
		    Sys_Printf(" <%x> ", recPtr->un.reply.status);
		    if (recPtr->un.reply.selectBits & FS_READABLE) {
			Sys_Printf("R");
		    }
		    if (recPtr->un.reply.selectBits & FS_WRITABLE) {
			Sys_Printf("W");
		    }
		}
		break;
	    }
	    default:
		Sys_Printf("<%d>", event); break;

	}
d1580 6
d1591 1
a1591 1
 * Fs_PdevPrintTrace --
d1593 1
a1593 1
 *	Dump out the pdev trace.
d1604 3
a1606 3
void
Fs_PdevPrintTrace(numRecs)
    int numRecs;
d1608 9
a1616 2
    if (numRecs < 0) {
	numRecs = pdevTraceLength;
d1618 21
a1638 2
    Sys_Printf("PDEV TRACE\n");
    (void)Trace_Print(pdevTraceHdrPtr, numRecs, Fs_PdevPrintRec);
@


6.14
log
@Changed FsPseudoStreamCltOpen so the cltHandle is unlocked before
the attempt to connect to the server process.  This is to defend against
errant server processes that refuse to pay attention to open requests.
@
text
@d43 8
a50 2
 * Copyright 1987 Regents of the University of California
 * All rights reserved.
d54 1
a54 1
static char rcsid[] = "$Header: fsPdev.c,v 6.13 88/09/22 11:47:07 brent Exp $ SPRITE (Berkeley)";
d69 2
d214 2
a215 1
 *	PDEV_READ_BUF_EMPTY	When set there is no data in the read ahead buf.
d231 2
a232 1
 *				to properly set the FS_USER flag (defined next).
d319 8
a326 7
 *	Early open time processing, this is called on a fileserver when setting
 *	up state for a call to the CltOpen routines on the client host.
 *	For pseudo-device server processes, which are indicated by the
 *	FS_MASTER flag, check that no other server exists.  For all other
 *	processes, which are referred to as "clients",
 *	make sure that a server process exists and generate a new
 *	ioFileID for the connection between the client and the server.
d329 5
a333 4
 *	For server processes, SUCCESS if it is now the server, FS_FILE_BUSY
 *	if there already exists a server process.
 *	For clients, SUCCESS if there is a server or the parameters indicate
 *	this is only for get/set attributes, DEV_OFFLINE if there is no server.
d380 2
a381 1
    ctrlHandlePtr = FsControlHandleInit(&ioFileID, handlePtr->hdr.name, &found);
d406 2
a407 1
		(FsHandleHeader *)ctrlHandlePtr, useFlags, handlePtr->hdr.name);
d409 2
a410 1
	    (void)FsStreamClientOpen(&streamPtr->clientList, clientID,useFlags);
d493 2
a494 1
FsControlCltOpen(ioFileIDPtr, flagsPtr, clientID, streamData, name, ioHandlePtrPtr)
d528 1
a528 1
 *	stream is used to pass a sever stream to the server.  Finally
d549 1
a549 1
    ClientData		streamData;	/* Ponter to FsPdevState. */
d617 3
a619 2
     * have to ensure that a FS_STREAM exists and has the remote client
     * on its list so the client's remote I/O ops. are accepted here.
d622 4
d630 1
a630 1
	cltStreamPtr = (Fs_Stream *)NIL;
a631 1

a633 5

	cltStreamPtr = FsStreamFind(&pdevStatePtr->streamID,
		    (FsHandleHeader *)cltHandlePtr, *flagsPtr, name, &found);
	(void)FsStreamClientOpen(&cltStreamPtr->clientList,
				clientID, *flagsPtr);
d639 2
a640 2
    cltHandlePtr->pdevHandlePtr = ServerStreamCreate(ctrlHandlePtr, ioFileIDPtr,
						     clientID, name);
d643 1
a643 1
	FsHandleInvalidate(cltHandlePtr);
d645 5
a649 2
	if (cltStreamPtr != (Fs_Stream *)NIL) {
	    FsStreamClientClose(&cltStreamPtr->clientList, clientID);
d802 2
a803 1
	    hdrPtr->fileID.serverID, hdrPtr->fileID.major,hdrPtr->fileID.minor);
d860 2
a861 1
    List_Insert((List_Links *)notifyPtr, LIST_ATREAR(&ctrlHandlePtr->queueHdr));
d906 25
a930 9
    /*
     * Notify the server that a client has gone away.  Then we get rid
     * of our reference to the server's handle and nuke our own.
     */
    PseudoStreamCloseInt(cltHandlePtr->pdevHandlePtr);
    (void)FsIOClientClose(&cltHandlePtr->clientList, clientID, 0, &cache);
    FsHandleRelease(cltHandlePtr->pdevHandlePtr, FALSE);
    FsHandleRelease(cltHandlePtr, TRUE);
    FsHandleRemove(cltHandlePtr);
d996 1
a996 1
 *	the client's will abort their current operations, if any.  The
d1024 2
a1025 1
	    pdevHandlePtr->hdr.fileID.major, pdevHandlePtr->hdr.fileID.minor) );
d1094 2
a1095 1
    register PdevControlIOHandle *ctrlHandlePtr = (PdevControlIOHandle *)hdrPtr;
d1195 1
a1195 1
FsControlIOControl(streamPtr, command, byteOrder, inBufSize, inBuffer, outBufSize, outBuffer)
d1199 2
a1200 4
    int inBufSize;			/* Size of inBuffer */
    Address inBuffer;			/* Buffer of input arguments */
    int outBufSize;			/* Size of outBuffer */
    Address outBuffer;			/* Buffer for return parameters */
d1215 3
a1217 2
	    if ((outBufSize >= sizeof(int)) && (outBuffer != (Address)NIL)) {
		*(int *)outBuffer = 0;
d1232 1
a1232 1
				inBuffer, inBufSize, &streamPtr->hdr.fileID);
d1237 1
a1237 1
	    if (outBufSize < sizeof(int)) {
d1248 1
a1248 1
	    *(int *)outBuffer = bytesAvailable;
d1524 2
a1525 1
    register PdevControlIOHandle *ctrlHandlePtr = (PdevControlIOHandle *)hdrPtr;
d1593 1
a1593 1
    register Pdev_Request	*requestPtr;	/* The caller should fill in the
d1610 7
a1616 7
    register ReturnStatus	status;
    Proc_ControlBlock		*serverProcPtr;	/* For VM copy operations */
    register int		firstByte;	/* Offset into request buffer */
    register int		lastByte;	/* Offset into request buffer */
    int				room;		/* Room available in req. buf.*/
    int				savedLastByte;	/* For error recovery */
    int				savedFirstByte;	/*   ditto */
d1727 2
a1728 1
	    serverProcPtr, (Address)&pdevHandlePtr->requestBuf.data[firstByte]);
d1762 5
a1766 4
	 * If this operation needs a reply we wait for it.  We save the client's
	 * reply buffer address and processID in the stream state so the
	 * kernel can copy the reply directly from the server's address space
	 * to the client's when the server makes the IOC_PDEV_REPLY IOControl.
d2104 2
a2105 1
	replySize = (pdevHandlePtr->flags&PDEV_WRITE_BEHIND) ? -1 : sizeof(int);
d2107 2
a2108 1
			    replySize, (Address)&numBytes, &replySize, waitPtr);
d2157 1
a2157 2
FsPseudoStreamIOControl(streamPtr, command, byteOrder, inBufSize, inBuffer,
		       outBufSize, outBuffer)
d2161 2
a2162 4
    int		inBufSize;	/* Size of input buffer. */
    Address	inBuffer;	/* Data to be sent to the slave/master. */
    int		outBufSize;	/* Size of output buffer. */
    Address	outBuffer;	/* Data to be obtained from the slave/master.*/
d2190 1
a2190 1
	(pdevHandlePtr->flags & PDEV_REMOTE_CLIENT) == 0) {
d2212 1
a2212 1
			mach_ByteOrder, byteOrder, "w", outBuffer, &size);
d2216 1
a2216 1
		} else if (outBufSize != sizeof(int)) {
d2219 1
a2219 1
		    *(int *)outBuffer = bytesAvail;
d2238 3
a2240 2
    status = RequestResponse(pdevHandlePtr, &request, inBufSize, inBuffer,
		outBufSize, outBuffer, (int *) NIL, (Sync_RemoteWaiter *)NIL);
d2481 1
a2481 2
FsServerStreamIOControl(streamPtr, command, byteOrder, inBufSize, inBuffer,
		       outBufSize, outBuffer)
d2485 2
a2486 4
    int		inBufSize;	/* Size of input buffer. */
    Address	inBuffer;	/* Data to be sent to the slave/master. */
    int		outBufSize;	/* Size of output buffer. */
    Address	outBuffer;	/* Data to be obtained from the slave/master.*/
d2512 2
a2513 1
	    register Pdev_SetBufArgs *argPtr = (Pdev_SetBufArgs *)inBuffer;
d2515 1
a2515 1
	    if (inBufSize != sizeof(Pdev_SetBufArgs)) {
d2562 1
a2562 1
	    if (inBufSize < sizeof(Boolean)) {
d2565 1
a2565 1
		writeBehind = *(Boolean *)inBuffer;
d2580 1
a2580 1
	    if (inBufSize < sizeof(Boolean)) {
d2583 1
a2583 1
		allowLargeWrites = *(Boolean *)inBuffer;
d2604 2
a2605 2
	    register Pdev_BufPtrs *argPtr = (Pdev_BufPtrs *)inBuffer;
	    if (inBufSize != sizeof(Pdev_BufPtrs)) {
d2620 2
a2621 1
		if (argPtr->requestFirstByte <= pdevHandlePtr->requestBuf.size &&
d2695 1
a2695 1
	    register Pdev_Reply *srvReplyPtr = (Pdev_Reply *)inBuffer;
d2760 1
a2760 1
	    if (inBufSize != sizeof(int)) {
d2767 1
a2767 1
		pdevHandlePtr->selectBits = *(int *)inBuffer;
d2812 2
a2813 1
	    if (outBuffer == (Address)NIL || outBufSize < sizeof(int)) {
d2816 1
a2816 1
		*(int *)outBuffer = numReadable;
d2934 4
a2937 1
 *	Begin migration of a pseuod-stream client.
d2940 1
a2940 1
 *	GEN_NOT_IMPLEMENTED.
d2943 1
a2943 1
 *	<explain after implementing>.
d2955 1
a2955 1
    return(GEN_NOT_IMPLEMENTED);
d2965 6
d2972 3
a2974 1
 *	GEN_NOT_IMPLEMENTED.
d2977 4
a2980 1
 *	<explain after implementing>.
d2986 2
a2987 1
FsPseudoStreamMigrate(migInfoPtr, size, data, hdrPtrPtr)
d2989 5
a2993 3
    int		size;		/* Zero */
    ClientData	data;		/* NIL */
    FsHandleHeader **hdrPtrPtr;	/* Return - handle for the file */
d2995 92
a3086 1
    return(GEN_NOT_IMPLEMENTED);
d3095 4
d3101 3
a3103 1
 *	GEN_NOT_IMPLEMENTED.
d3106 2
a3107 1
 *	<explain after implementing>.
d3113 2
a3114 1
FsRmtPseudoStreamMigrate(migInfoPtr, size, data, hdrPtrPtr)
d3116 5
a3120 3
    int		size;		/* Zero */
    ClientData	data;		/* NIL */
    FsHandleHeader **hdrPtrPtr;	/* Return - handle for the file */
d3122 24
a3145 1
    return(GEN_NOT_IMPLEMENTED);
d3151 1
a3151 1
 * FsPseudoStreamMigrate --
d3153 4
a3156 1
 *	Complete migration for a pseudo stream
d3159 1
a3159 1
 *	GEN_NOT_IMPLEMENTED.
d3162 1
a3162 1
 *	<explain after implementing>.
d3174 17
a3190 1
    return(GEN_NOT_IMPLEMENTED);
d3248 1
a3248 1
 *	Initialize the pseudo-device trace buffer.  Used for debuggin
@


6.13
log
@Changed I/O control interface to take streamPtr
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 6.12 88/09/21 14:58:35 brent Exp $ SPRITE (Berkeley)";
d649 5
a653 1
     * will accept the open.
d655 1
a659 1
	FsHandleUnlock(cltHandlePtr);
d661 1
a661 1
	FsHandleRelease(cltHandlePtr, TRUE);
@


6.12
log
@Patched fileID generation so that control stream are the same.
This allows clients to continue after the server boots with
its new mapping from pseudo-device name to pseudo-device fileIDs.
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 6.11 88/09/20 15:22:44 brent Exp $ SPRITE (Berkeley)";
d1153 2
a1154 2
FsControlIOControl(hdrPtr, command, byteOrder, inBufSize, inBuffer, outBufSize, outBuffer)
    FsHandleHeader *hdrPtr;		/* I/O handle */
d1163 2
a1164 1
    register PdevControlIOHandle *ctrlHandlePtr = (PdevControlIOHandle *)hdrPtr;
d1191 1
a1191 1
				inBuffer, inBufSize, (FsFileID *)NIL);
d2111 1
a2111 1
FsPseudoStreamIOControl(hdrPtr, command, byteOrder, inBufSize, inBuffer,
d2113 1
a2113 1
    FsHandleHeader *hdrPtr;	/* Handle header for pseudo-stream. */
d2124 2
a2125 1
    register PdevClientIOHandle *cltHandlePtr = (PdevClientIOHandle *)hdrPtr;
d2437 1
a2437 1
FsServerStreamIOControl(hdrPtr, command, byteOrder, inBufSize, inBuffer,
d2439 1
a2439 1
    FsHandleHeader 	*hdrPtr;	/* Server IO Handle. */
d2448 2
a2449 1
    register PdevServerIOHandle	*pdevHandlePtr = (PdevServerIOHandle *) hdrPtr;
@


6.11
log
@Fixed FileID generation
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 6.10 88/09/19 11:23:28 brent Exp $ SPRITE (Berkeley)";
d360 4
d367 1
a367 1
    ioFileID.minor ^= (handlePtr->descPtr->version << 24);
d378 6
a383 2
	     * Return to the pseudo-device server a ControlIOHandle that
	     * has us, the name server, in the serverID field.  This is
a388 1
	    ctrlHandlePtr->serverID = clientID;
d427 3
a429 2
	    ioFileIDPtr->minor = handlePtr->hdr.fileID.minor ^
				  (ctrlHandlePtr->seed << 16);
d443 1
a443 1
	     * Set up a top level stream for the opening process.  No shadow
d445 1
a445 1
	     * the pdev server who sets up a shadow stream.
d570 1
a570 1
    ctrlHandlePtr->seed = ioFileIDPtr->minor & 0xFFFF;
@


6.10
log
@Updated locking routines to take a streamID in order to record
the owner of a lock.
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 6.9 88/09/16 16:51:37 brent Exp $ SPRITE (Berkeley)";
d358 1
a358 1
     * number or'ed into it to avoid conflict when you delete the
d363 1
a363 1
    ioFileID.minor |= (handlePtr->descPtr->version << 16);
d420 2
a421 2
	    ioFileIDPtr->minor = (handlePtr->hdr.fileID.minor << 16) |
				  ctrlHandlePtr->seed;
d535 1
d601 1
a602 1
	register Fs_Stream *cltStreamPtr;
d618 10
d771 4
a774 1
	Sys_Panic(SYS_WARNING, "ServerStreamCreate, found server handle\n");
@


6.9
log
@Added procID to close procedure to support lock cleanup
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 6.8 88/09/13 11:27:41 brent Exp $ SPRITE (Berkeley)";
d1132 1
a1132 1
    FsHandleHeader *hdrPtr;		/* File handle */
d1162 1
a1162 1
	case IOC_TRUNCATE: {
a1164 1
	}
d1167 2
a1168 9
	    if (inBufSize < sizeof(Ioc_LockArgs)) {
		status = GEN_INVALID_ARG;
	    } else if (command == IOC_LOCK) {
		status = FsFileLock(&ctrlHandlePtr->lock,
			    (Ioc_LockArgs *)inBuffer);
	    } else {
		status = FsFileUnlock(&ctrlHandlePtr->lock,
			    (Ioc_LockArgs *)inBuffer);
	    }
@


6.8
log
@Added byte swapping code to IOControls
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 6.7 88/09/07 16:53:38 brent Exp $ SPRITE (Berkeley)";
d845 1
a845 1
FsPseudoStreamClose(streamPtr, clientID, flags, size, data)
d848 1
d950 1
a950 1
FsServerStreamClose(streamPtr, clientID, flags, size, data)
d953 1
d1407 1
a1407 1
FsControlClose(streamPtr, clientID, flags, size, data)
d1410 1
d1440 2
a1441 1
	(void)FsSpriteClose(streamPtr, rpc_SpriteID, 0, 0, (ClientData)NIL);
@


6.7
log
@Moved name from stream to I/O handle.
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 6.6 88/08/31 12:05:44 brent Exp $ SPRITE (Berkeley)";
a1127 1
/*ARGSUSED*/
d1129 1
a1129 1
FsControlIOControl(hdrPtr, command, inBufSize, inBuffer, outBufSize, outBuffer)
d1132 1
d1142 3
d2092 1
a2092 1
FsPseudoStreamIOControl(hdrPtr, command, inBufSize, inBuffer,
d2096 1
d2138 2
a2139 6
		register int bytesAvail;
		if (outBuffer == (Address)NIL ||
		    outBufSize < sizeof(int)) {
		    status = GEN_INVALID_ARG;
		    goto exit;
		} else if (pdevHandlePtr->flags & PDEV_READ_BUF_EMPTY) {
a2144 1
		*(int *)outBuffer = bytesAvail;
d2146 12
d2173 1
d2415 1
a2415 1

d2417 1
a2417 1
FsServerStreamIOControl(hdrPtr, command, inBufSize, inBuffer,
d2421 1
d2432 3
@


6.6
log
@Removed lint.
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 6.5 88/08/26 17:49:49 brent Exp $ SPRITE (Berkeley)";
d280 1
a280 1
FsControlHandleInit(fileIDPtr, foundPtr)
d282 1
d289 2
a290 1
    found = FsHandleInstall(fileIDPtr, sizeof(PdevControlIOHandle), &hdrPtr);
d364 1
a364 1
    ctrlHandlePtr = FsControlHandleInit(&ioFileID, &found);
d386 1
a386 1
				    (FsHandleHeader *)ctrlHandlePtr, useFlags);
d440 1
a440 1
				    (FsHandleHeader *)NIL, useFlags);
d470 1
a470 1
FsControlCltOpen(ioFileIDPtr, flagsPtr, clientID, streamData, ioHandlePtrPtr)
d475 1
d482 1
a482 1
    ctrlHandlePtr = FsControlHandleInit(ioFileIDPtr, &found);
d520 2
a521 1
FsPseudoStreamCltOpen(ioFileIDPtr, flagsPtr, clientID, streamData, ioHandlePtrPtr)
d526 1
d563 1
a563 1
    found = FsHandleInstall(ioFileIDPtr, sizeof(PdevClientIOHandle),
d581 1
a581 1
	found = FsHandleInstall(ioFileIDPtr, sizeof(PdevClientIOHandle),
d607 1
a607 1
			    (FsHandleHeader *)cltHandlePtr, *flagsPtr, &found);
d615 2
a616 2
    cltHandlePtr->pdevHandlePtr = ServerStreamCreate(ctrlHandlePtr,
						     ioFileIDPtr, clientID);
d666 2
a667 1
FsRmtPseudoStreamCltOpen(ioFileIDPtr, flagsPtr, clientID, streamData, ioHandlePtrPtr)
d672 1
d699 1
a699 1
	found = FsHandleInstall(ioFileIDPtr, sizeof(FsRemoteIOHandle),
d742 1
a742 1
ServerStreamCreate(ctrlHandlePtr, ioFileIDPtr, slaveClientID)
d747 1
d756 2
a757 1
    found = FsHandleInstall(ioFileIDPtr, sizeof(PdevServerIOHandle), &hdrPtr);
d811 1
a811 1
			    FS_READ|FS_USER);
d1354 2
a1355 1
	ctrlHandlePtr = FsControlHandleInit(&reopenParamsPtr->fileID, &found);
@


6.5
log
@Updated to new pseudo-device definitions
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 6.4 88/08/26 11:10:59 brent Exp $ SPRITE (Berkeley)";
d383 2
a384 1
	    streamPtr = FsStreamNew(rpc_SpriteID, ctrlHandlePtr, useFlags);
d386 1
a386 1
	    FsStreamClientOpen(&streamPtr->clientList, clientID, useFlags);
d573 1
a573 1
	FsHandleInvalidate(cltHandlePtr);
d602 1
a602 1
			    cltHandlePtr, *flagsPtr, &found);
d613 1
a613 1
    FsIOClientOpen(&cltHandlePtr->clientList, clientID, 0, FALSE);
d620 1
a620 1
    FsHandleDup((FsHandleHeader *)cltHandlePtr->pdevHandlePtr);
d855 1
a855 1
    FsIOClientClose(&cltHandlePtr->clientList, clientID, 0, &cache);
d1412 1
a1412 1
	Fs_Close(notifyPtr->streamPtr);
d1700 1
a1700 1
	    Sync_Wait(&pdevHandlePtr->replyReady, FALSE);
d3194 1
a3194 1
    Trace_Print(pdevTraceHdrPtr, numRecs, Fs_PdevPrintRec);
@


6.4
log
@Fixed RequestResponse to back out of a request after it
can't copy the associated data into the request buffer.
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 6.3 88/08/24 18:10:48 brent Exp $ SPRITE (Berkeley)";
d169 1
a169 1
    Pdev_NewReply reply;	/* The current reply header is stuck here */
d881 1
a881 1
    Pdev_NewRequest	request;
d1518 1
a1518 1
    register Pdev_NewRequest	*requestPtr;	/* The caller should fill in the
d1576 1
a1576 1
    requestPtr->messageSize = sizeof(Pdev_NewRequest) +
d1651 1
a1651 1
    status = Vm_CopyOutProc(sizeof(Pdev_NewRequest), (Address)requestPtr, TRUE,
d1654 1
a1654 1
	firstByte += sizeof(Pdev_NewRequest);
d1747 1
a1747 1
    Pdev_NewRequest		request;
a1773 1
    request.param.open.clientID	= 0;		/* XXX */
d1824 1
a1824 1
    Pdev_NewRequest	request;
d1976 1
a1976 1
    Pdev_NewRequest	request;
d2009 1
a2009 1
    maxRequestSize = pdevHandlePtr->requestBuf.size - sizeof(Pdev_NewRequest);
d2088 1
a2088 1
    Pdev_NewRequest	request;
d2604 1
a2604 1
	    register Pdev_NewReply *srvReplyPtr = (Pdev_NewReply *)inBuffer;
@


6.3
log
@Changed SrvOpen interface to return its handle unlocked
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 6.2 88/08/18 17:59:33 brent Exp $ SPRITE (Berkeley)";
d1540 2
d1599 2
d1624 1
d1663 6
@


6.2
log
@removed lint
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 6.1 88/08/16 17:44:00 brent Exp $ SPRITE (Berkeley)";
d332 2
a333 1
					 * Should be LOCKED upon entry. */
d444 1
@


6.1
log
@Fixed synchronization with remote pseudo-devices.
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 6.0 88/08/11 12:17:23 brent Stable $ SPRITE (Berkeley)";
d560 1
a560 1
	    (cltHandlePtr->pdevHandlePtr->clientPID != NIL)) {
a1533 1
    Proc_ControlBlock		*procPtr;	/* Used to get clientPID */
@


6.0
log
@Changing version numbers.
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 1.15 88/08/05 13:59:59 brent Exp $ SPRITE (Berkeley)";
d152 1
a152 3
    Proc_PID clientPID;		/* Client's processID needed for copy out
				 * and for using the wait lists */
    int clientSpriteID;		/* Used for wait list notification */
d186 1
a248 1
    Fs_Stream		*streamPtr;	/* Only if client is remote */
a251 9
 * Parameter block passed via RPC when doing operations at remote servers.
 */
typedef struct {
    FsFileID		fileID;		/* FileID of cloned handle. */
    Sync_RemoteWaiter	wait;		/* Process info for remote waiting */
    Pdev_NewRequest	hdr;		/* Request header. */
} PdevRpcParams;

/*
d559 4
a562 3
	Sys_Panic(SYS_WARNING,
	    "FsPseudoStreamCltOpen found client handle\n");
	if (cltHandlePtr->pdevHandlePtr != (PdevServerIOHandle *)NIL) {
d592 2
a594 2
	cltHandlePtr->streamPtr = (Fs_Stream *)NIL;
    } else {
d598 1
a598 1
	cltHandlePtr->streamPtr = FsStreamFind(&pdevStatePtr->streamID,
d600 1
a600 1
	(void)FsStreamClientOpen(&cltHandlePtr->streamPtr->clientList,
d602 1
a602 1
	FsHandleUnlock(cltHandlePtr->streamPtr);
d782 3
a784 1
    pdevHandlePtr->clientSpriteID = NIL;
d905 1
a905 1
				0, (Address)NIL, (int *) NIL);
d1512 2
a1513 2
RequestResponse(pdevHandlePtr, requestPtr,
		inputSize, inputBuf, replySize, replyBuf, replySizePtr)
d1530 2
d1534 1
a1534 1
    Proc_ControlBlock		*procPtr;	/* For blocking signals */
a1548 4
     * Put an entry in the scheduler trace so we can correlate...
     */
    procPtr = Proc_GetEffectiveProc();
    /*
d1679 1
a1679 2
    
	procPtr = Proc_GetEffectiveProc();
d1681 4
a1684 2
	pdevHandlePtr->clientPID = procPtr->processID;
	pdevHandlePtr->clientSpriteID = rpc_SpriteID;
d1767 2
a1768 2
    status = RequestResponse(pdevHandlePtr,
		    &request, 0, (Address) NIL, 0, (Address) NIL, (int *)NIL);
a1801 1

d1909 1
a1909 1
				 *lenPtr, buffer, lenPtr);
a1950 1
/*ARGSUSED*/
d1958 1
a1958 1
    Sync_RemoteWaiter *waitPtr;	/* IGNORED */
d2018 1
a2018 1
			    replySize, (Address)&numBytes, &replySize);
d2142 1
a2142 1
				outBufSize, outBuffer, (int *) NIL);
a2628 5
		Sync_RemoteWaiter w;

		w.pid = pdevHandlePtr->clientPID;
		w.hostID = pdevHandlePtr->clientSpriteID;
		w.waitToken = SYNC_BROADCAST_TOKEN;
d2630 2
a2631 1
		    FsFastWaitListInsert(&pdevHandlePtr->cltReadWaitList, &w);
d2633 2
a2634 1
		    FsFastWaitListInsert(&pdevHandlePtr->cltWriteWaitList, &w);
@


1.15
log
@removed lint
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 1.14 88/08/03 17:18:58 mlgray Exp $ SPRITE (Berkeley)";
@


1.14
log
@works on Spur.
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 1.13 88/06/17 10:45:04 brent Exp $ SPRITE (Berkeley)";
a540 1
    int				seed;
d561 1
a561 1
     * This done in case of recovery later.  We'll need to reset the
d618 1
a618 1
				    ioFileIDPtr, clientID, procID);
d666 1
a666 1

d671 1
a671 1
    int			clientID;	/* Host doing the open */
d742 1
a742 1
ServerStreamCreate(ctrlHandlePtr, ioFileIDPtr, slaveClientID, slaveProcessID)
a746 1
    Proc_PID	slaveProcessID;	/* Needed to clean up select'ing clients */
d839 1
a839 1

d844 1
a844 1
    int			flags;		/* Flags from the stream being closed */
d1057 1
a1057 1

d1063 1
a1063 1
    int		*offsetPtr;	/* Ignored */
a1819 1
    register Proc_ControlBlock *procPtr;
d1961 1
a1961 1

d1969 1
a1969 1
    Sync_RemoteWaiter *waitPtr;	/* Process info for waiting */
d2782 2
@


1.13
log
@1. Put in recovery from the case where a hung client still has
   a pseudo-device handle lingering around.
2. Fixed the use of the stream for remote clients.  It gets closed
   by Fs_RpcClose so FsPseudoStreamClose shouldn't close it too.
3. Took out calls to Sched_TraceInsert
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 1.12 88/06/08 15:01:03 brent Exp $ SPRITE (Berkeley)";
a100 18
 * PdevState is returned from the SrvOpen routine to the CltOpen routine.
 * It is also sent via RPC from the remoteCltOpen routine to the localCltOpen
 * routine.  In this second case the processID and uid of the remote client is
 * initialized.
 */
typedef struct PdevState {
    FsFileID ctrlFileID;	/* Control stream FileID */
    /*
     * The following fields are used when the client process is remote
     * from the server host.
     */
    Proc_PID procID;		/* Process ID of remote client */
    int uid;			/* User ID of remote client */
    FsFileID streamID;		/* Client's stream ID used to set up a
				 * matching stream here on the server */
} PdevState;

/*
d350 2
a351 2
     int		*dataSizePtr;	/* Return - sizeof(PdevState) */
     ClientData		*clientDataPtr;	/* Return - a reference to PdevState.
d361 1
a361 1
    register	PdevState *pdevStatePtr;
d435 1
a435 1
	    pdevStatePtr = Mem_New(PdevState);
d440 1
a440 1
	    *dataSizePtr = sizeof(PdevState);
d529 1
a529 1
    ClientData		streamData;	/* Ponter to PdevState. */
d537 1
a537 1
    register PdevState		*pdevStatePtr;
d543 1
a543 1
    pdevStatePtr = (PdevState *)streamData;
d594 1
a594 1
     * processID and uid are passed to us via the PdevState.  We also
d678 1
a678 1
    register PdevState *pdevStatePtr = (PdevState *)streamData;
d686 1
a686 1
     * of the PdevState so that FsPseudoStreamCltOpen can pass them
d693 1
a693 1
    status = FsDeviceRemoteOpen(ioFileIDPtr, *flagsPtr,	sizeof(PdevState),
@


1.12
log
@Cleaned up stream creation so there is a shadow stream created
on the correct server hosts and it gets closed properly.
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 1.11 88/06/06 09:36:56 brent Exp $ SPRITE (Berkeley)";
d589 19
a607 1
	Sys_Panic(SYS_FATAL, "FsPseudoStreamCltOpen found client handle\n");
d610 2
a611 4
     * Set up a service stream that corresponds to the client's
     * pseudo stream, and hook the client handle to it.  We have to look around
     * and decide if we are being called directly from Fs_Open, or via
     * RPC from a remote client.  In the latter case the remote client's
d615 1
d633 3
a874 10

    if (cltHandlePtr->streamPtr != (Fs_Stream *)NIL) {
	/*
	 * Clean up the stream we had to create on this host in order for a
	 * remote client to do I/O.
	 */
	FsHandleLock(cltHandlePtr->streamPtr);
	FsStreamClientClose(cltHandlePtr->streamPtr, clientID);
	FsStreamDispose(cltHandlePtr->streamPtr);
    }
a1577 1
    Sched_TraceInsert(procPtr, 10);
a1728 2

    Sched_TraceInsert(procPtr, 20);
@


1.11
log
@Changed close interface to pass back the streamID so the server's
shadow streams can be closed too.
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 1.10 88/06/03 11:30:03 brent Exp $ SPRITE (Berkeley)";
a53 1
#include "fsPdev.h"
a379 1
    Boolean	grabStreamID = FALSE;
d403 3
a405 1
	     * so we can clear the serverID field here.
d411 4
d459 8
a466 13
	    grabStreamID = TRUE;
	}
    }
    /*
     * Now choose a streamID for the opening process.  We return its ID
     * in the PdevState (as well as the return parameter) so the pdev
     * server can ensure that a stream exists on its host too.
     */
    if ((status == SUCCESS) && (streamIDPtr != (FsFileID *)NIL)) {
	streamPtr = FsStreamNew(ctrlHandlePtr->serverID,
			(FsHandleHeader *)NIL, useFlags);
	*streamIDPtr = streamPtr->hdr.fileID;
	if (grabStreamID) {
d468 1
a469 1
	FsStreamDispose(streamPtr);
@


1.10
log
@Changed FsHandleRelease to not re-lock the handle if it is
unlocked.  This means that the hdrPtr->refCount is no longer
protected implicitly by the handle lock, and the stream routines
(top-level stream) must lock their handle before releasing it
if they still want to access the refCount outside the
handle monitor lock
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 1.9 88/06/02 11:35:38 brent Exp $ SPRITE (Berkeley)";
d842 2
a843 2
FsPseudoStreamClose(hdrPtr, clientID, flags, size, data)
    FsHandleHeader	*hdrPtr;	/* Handle to close */
d850 1
a850 1
	    (PdevClientIOHandle *)hdrPtr;
d854 12
a865 2
		hdrPtr->fileID.major,
		hdrPtr->fileID.minor) );
a869 5
    if (cltHandlePtr->streamPtr != (Fs_Stream *)NIL) {
	FsHandleLock(cltHandlePtr->streamPtr);
	FsHandleRelease(cltHandlePtr->streamPtr, TRUE);
	FsHandleRemove(cltHandlePtr->streamPtr);
    }
d873 2
a874 6
    FsHandleRelease(hdrPtr, TRUE);
    FsHandleRemove(hdrPtr);
    /*
     * Clean up the stream we had to create on this host in order for a
     * remote client to do I/O.
     */
d956 2
a957 2
FsServerStreamClose(hdrPtr, clientID, flags, size, data)
    FsHandleHeader	*hdrPtr;	/* Handle to close */
d964 1
a964 1
	    (PdevServerIOHandle *)hdrPtr;
d967 1
a967 1
	    hdrPtr->fileID.major, hdrPtr->fileID.minor) );
d1408 2
a1409 2
FsControlClose(hdrPtr, clientID, flags, size, data)
    FsHandleHeader	*hdrPtr;	/* ControlIOHandle to close */
d1416 1
a1416 1
	    (PdevControlIOHandle *)hdrPtr;
d1440 1
a1440 2
	(void)FsSpriteClose(&ctrlHandlePtr->rmt, rpc_SpriteID, 0, 0,
				(ClientData)NIL);
@


1.9
log
@Removed ifdef'ed out code that is old and ugly
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 1.8 88/06/02 10:11:12 brent Exp $ SPRITE (Berkeley)";
d861 2
a862 1
	FsHandleRelease(cltHandlePtr->streamPtr, FALSE);
@


1.8
log
@Had to fix the server side so it would ensure a that a stream
existed to match the stream (high level stream, now) on the
client.  Checking in Fs_Rpc{Read,Write} looks for the stream,
so I/O operations were failing.
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 1.7 88/06/01 17:24:12 brent Exp $ SPRITE (Berkeley)";
a1839 9
#ifdef notdef
    if ((pdevHandlePtr->flags & PDEV_SETUP) == 0) {
	Sys_Panic(SYS_WARNING,
	    "FsPseudoStreamRead, stream not set up, flags = 0x%x\n",
	    pdevHandlePtr->flags);
	status = DEV_OFFLINE;
	goto exit;
    }
#endif notdef
a1998 9
#ifdef notdef
    if ((pdevHandlePtr->flags & PDEV_SETUP) == 0) {
	Sys_Panic(SYS_WARNING,
	    "FsNewPseudoStreamWrite, stream not set up (0x%x)\n",
	    pdevHandlePtr->flags);
	status = DEV_OFFLINE;
	goto exit;
    }
#endif notdef
a2107 7
#ifdef notdef
    if ((pdevHandlePtr->flags & PDEV_SETUP) == 0) {
	Sys_Panic(SYS_WARNING, "FsNewPseudoStreamIOControl, stream not set up\n");
	status = DEV_OFFLINE;
	goto exit;
    }
#endif notdef
@


1.7
log
@Fixed pseudo-device recovery.
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 1.6 88/05/05 17:33:39 brent Exp $ SPRITE (Berkeley)";
d109 4
d115 2
d269 1
d367 1
a367 1
     FsFileID		*streamIDPtr;	/* Return PdevState. 
d369 4
a372 4
     int		*dataSizePtr;	/* Return - sizeof(FsFileID) */
     ClientData		*clientDataPtr;	/* Return - a reference to the fileID
					 * of the control stream.  Nothing is
					 * returned during set/get attrs */
d381 1
d455 1
d459 3
a461 1
     * Now choose a streamID for the opening process.
d467 3
d483 1
a483 4
 *	I/O handle as having a server (us).  We also remember who the
 *	name server was so we can contact it again at close time;
 *	it keeps state about who the server is and that needs to get
 *	cleaned up.
d593 1
a593 1
     * Set up the server's stream that corresponds to the client's
d597 3
a599 5
     * processID and uid are passed to us via the PdevState.
     * 
     * We also note that the client is remote in order to get the
     * buffering right in the I/O control routine;  if the client is remote
     * then the in/out buffers for IOControl are always in kernel space.
d601 1
a601 4
    if (clientID != rpc_SpriteID) {
	procID = pdevStatePtr->procID;
	uid = pdevStatePtr->uid;
    } else {
d605 11
d860 4
d869 4
d1917 1
a1917 1
			  buffer, flags & FS_USER);
@


1.6
log
@Nuked Sys_GetProcessorNumber
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 1.5 88/05/03 14:47:12 brent Exp $ SPRITE (Berkeley)";
d124 1
d549 1
d568 7
d1315 1
d1319 1
d1322 2
a1323 1
	reopenParamsPtr->serverID = ((PdevControlIOHandle *)hdrPtr)->serverID;
d1337 1
a1337 1
	     * The remote host thinks it is running the pdev server.
d1340 2
a1341 1
		ctrlHandlePtr->serverID = clientID;
d2042 2
d2624 10
a2633 1
		if ((pdevHandlePtr->flags & FS_USER) == 0) {
a2662 2
		} else {
		    Sys_Panic(SYS_WARNING, "IOC_PDEV_REPLY, WOULD_BLOCK on non read/write operation\n");
@


1.5
log
@Took out the optimization where the server is not notified
of new requests during write-behind.  If the client does nothing
else to the pseudo-device (like it waits for a different I/O channel)
then the write request will languish forever in the write buffer.
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsPdev.c,v 1.2 88/04/19 10:50:16 brent Exp $ SPRITE (Berkeley)";
d587 1
a587 1
	procPtr = Proc_GetEffectiveProc(Sys_GetProcessorNumber());
d662 1
a662 1
    procPtr = Proc_GetEffectiveProc(Sys_GetProcessorNumber());
d1529 1
a1529 1
    procPtr = Proc_GetEffectiveProc(Sys_GetProcessorNumber());
d1663 1
a1663 1
	procPtr = Proc_GetEffectiveProc(Sys_GetProcessorNumber());
d1896 1
a1896 1
	procPtr = Proc_GetEffectiveProc(Sys_GetProcessorNumber());
d1995 1
a1995 1
    procPtr = Proc_GetEffectiveProc(Sys_GetProcessorNumber());
d2145 1
a2145 1
    procPtr = Proc_GetEffectiveProc(Sys_GetProcessorNumber());
d2447 1
a2447 1
		procPtr = Proc_GetEffectiveProc(Sys_GetProcessorNumber());
@


1.4
log
@Added ControlReopen.  Also incorporate the disk version number in
the control handle file ID so you can remove a pseudo-device file
and not worry about it being recreated under the same file number
@
text
@a1591 2
	     * The server is poked in case we have been generating
	     * requests that do not need a reply.
a1592 1
	    FsFastWaitListNotify(&pdevHandlePtr->srvReadWaitList);
d1644 8
a1651 4
     * If this operation needs a reply we wait for it.  We save the client's
     * reply buffer address and processID in the stream state so the
     * kernel can copy the reply directly from the server's address space
     * to the client's when the server makes the IOC_PDEV_REPLY IOControl.
d1653 1
d1655 1
a1655 1
    if (replySize >= 0) {
d1657 4
a1660 6
	 * Poke the server so it can read the new pointer values.
	 * This is done here to avoid waking up the server if we
	 * don't need a reply.  However, this also requires a
	 * patch in FsPseudoStreamSelect to notify this condition.
	 * Otherwise the server can get lost in select if the
	 * client also goes into select after an asynchronous write.
a1661 1
	FsFastWaitListNotify(&pdevHandlePtr->srvReadWaitList);
d1888 1
a1889 6
	/*
	 * Always notify the server.  Either we just changed the
	 * read pointers, or perhaps the last thing we did was an
	 * asynchronous write in which we didn't notify the server.
	 */
	FsFastWaitListNotify(&pdevHandlePtr->srvReadWaitList);
a2218 6
	/*
	 * We have to notify the server in case our last operation
	 * did not require a reply.  In that case we don't notify the
	 * server (FIX THE SCHEDULER) so we have to here.
	 */
	FsFastWaitListNotify(&pdevHandlePtr->srvReadWaitList);
@


1.3
log
@Added tracing, plus interaction with scheduler trace.
Fixed synchronization bugs associated with not notifying
the server during write-behind.
@
text
@d61 1
d114 4
a117 4
 * The following control messages are only passed internally and
 * contain a streamPtr for a new server stream.
 * The server stream is created in ServerStreamCreate and the streamPtr
 * is converted to a user level streamID by FsControlRead.
d119 6
d126 7
d374 6
d382 1
d763 1
a763 1
    pdevHandlePtr->operation = (Pdev_Op)NIL;
d1265 82
@


1.2
log
@Currently working, although not as fast as seems possible
@
text
@d48 1
a48 1
static char rcsid[] = "$Header: fsNewPdev.c,v 1.15 88/03/08 13:05:51 brent Exp $ SPRITE (Berkeley)";
d66 1
a66 1
#define CLEAN
d69 1
a69 1
Boolean fsPdevDebug = FALSE;
d73 1
a73 1
Boolean pdevTracing = TRUE;
d167 2
a485 129
 * FsControlVerify --
 *
 *	Verify that the remote server is known for the pseudo-device,
 *	and return a locked pointer to the control I/O handle.
 *
 * Results:
 *	A pointer to the control I/O handle, or NIL if the server is bad.
 *
 * Side effects:
 *	The handle is returned locked and with its refCount incremented.
 *	It should be released with FsHandleRelease.
 *
 *----------------------------------------------------------------------
 */

FsHandleHeader *
FsControlVerify(fileIDPtr, pdevServerHostID)
    FsFileID	*fileIDPtr;		/* control I/O file ID */
    int		pdevServerHostID;	/* Host ID of the client */
{
    register PdevControlIOHandle	*ctrlHandlePtr;
    int serverID = -1;

    ctrlHandlePtr = FsHandleFetchType(PdevControlIOHandle, fileIDPtr);
    if (ctrlHandlePtr != (PdevControlIOHandle *)NIL) {
	if (ctrlHandlePtr->serverID != pdevServerHostID) {
	    serverID = ctrlHandlePtr->serverID;
	    FsHandleRelease(ctrlHandlePtr, TRUE);
	    ctrlHandlePtr = (PdevControlIOHandle *)NIL;
	}
    }
    if (ctrlHandlePtr == (PdevControlIOHandle *)NIL) {
	Sys_Panic(SYS_WARNING,
	    "FsControlVerify, server mismatch (%d not %d) for pdev <%x,%x>\n",
	    pdevServerHostID, serverID, fileIDPtr->major, fileIDPtr->minor);
    }
    return((FsHandleHeader *)ctrlHandlePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * FsControlClose --
 *
 *	Close a server process's control stream.  After this the pseudo-device
 *	is no longer active and client operations will fail.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Reset the control handle's serverID.
 *	Clears out the state for the control message queue.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsControlClose(hdrPtr, clientID, flags, size, data)
    FsHandleHeader	*hdrPtr;	/* ControlIOHandle to close */
    int			clientID;	/* HostID of client closing */
    int			flags;		/* Flags from the stream being closed */
    int			size;		/* Should be zero */
    ClientData		data;		/* IGNORED */
{
    register PdevControlIOHandle *ctrlHandlePtr =
	    (PdevControlIOHandle *)hdrPtr;
    register PdevNotify *notifyPtr;
    int extra = 0;

    /*
     * Close any server streams that haven't been given to
     * the master process yet.
     */
    while (!List_IsEmpty(&ctrlHandlePtr->queueHdr)) {
	notifyPtr = (PdevNotify *)List_First(&ctrlHandlePtr->queueHdr);
	List_Remove((List_Links *)notifyPtr);
	extra++;
	Fs_Close(notifyPtr->streamPtr);
	Mem_Free((Address)notifyPtr);
    }
    if (extra) {
	Sys_Panic(SYS_WARNING, "FsControlClose found %d left over messages\n",
			extra);
    }
    /*
     * Reset the pseudo-device server ID, both here and at the name server.
     */
    ctrlHandlePtr->serverID = NIL;
    if (ctrlHandlePtr->rmt.hdr.fileID.serverID != rpc_SpriteID) {
	(void)FsSpriteClose(&ctrlHandlePtr->rmt, rpc_SpriteID, 0, 0,
				(ClientData)NIL);
    }
    FsHandleRelease(ctrlHandlePtr, TRUE);
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FsControlScavenge --
 *
 *	See if this control stream handle is still needed.
 *
 * Results:
 *	GEN_NOT_IMPLEMENTED.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
void
FsControlScavenge(hdrPtr)
    FsHandleHeader *hdrPtr;	/* File being encapsulated */
{
    register PdevControlIOHandle *ctrlHandlePtr = (PdevControlIOHandle *)hdrPtr;

    if (ctrlHandlePtr->serverID == NIL) {
	FsHandleRemove(ctrlHandlePtr);
    } else {
        FsHandleUnlock(ctrlHandlePtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
d742 1
d884 1
a884 1
 *	handle is 'removed' here but won't go away until the client
d1129 1
d1135 1
d1207 160
d1424 5
d1460 1
a1460 1
    /* Debugging trace */
d1489 2
d1492 1
d1513 1
d1554 4
a1557 1
	 * don't need a reply.
d1580 3
d1625 1
d1652 2
d1700 1
a1700 1

d1708 1
d1731 1
a1785 1
	    FsFastWaitListNotify(&pdevHandlePtr->srvReadWaitList);
d1787 6
d1873 1
a1873 1

d1881 1
a1893 1

d1989 1
a1989 1

d1995 1
d2011 1
a2011 1
     * from an RPC stub they are in kernel space.
d2094 2
a2095 1
    register PdevServerIOHandle *pdevHandlePtr = (PdevServerIOHandle *)hdrPtr;
d2099 1
a2099 1
    PDEV_TSELECT(&pdevHandlePtr->hdr.fileID, *readPtr, *writePtr, *exceptPtr);
d2122 7
d2156 3
d2222 1
d2229 1
d2263 1
a2263 1
	 * more requests into the buffer.
d2429 1
a2429 1
		 * shouldn't muck with the request pointers. If its ok, then
d2459 2
a2460 1
		     * Full buffer, update pointer if its a good value.
d2462 3
a2464 2
		    if (argPtr->readLastByte > pdevHandlePtr->readBuf.lastByte) {
			pdevHandlePtr->readBuf.lastByte = argPtr->readLastByte;
d2466 1
a2466 1
		} else {
d2468 3
a2470 3
		     * Empty buffer.  If the server already knows this then
		     * we can safely reset the pointers to the beginning.
		     * In fact, the server should rely on this behavior.
d2472 4
a2475 8
		    if (pdevHandlePtr->flags & PDEV_SERVER_KNOWS_IT) {
			if (argPtr->readLastByte >= 0) {
			    pdevHandlePtr->flags &= ~(PDEV_READ_BUF_EMPTY|
						     PDEV_SERVER_KNOWS_IT);
			    pdevHandlePtr->readBuf.firstByte = 0;
			} else {
			    break;	/* No new read ahead data */
			}
d2477 1
a2477 10
			/*
			 * The server is staying ahead of us.  We
			 * just adjust the pointer.
			 */
			if (argPtr->readLastByte > 
				pdevHandlePtr->readBuf.lastByte) {
			    pdevHandlePtr->flags &= ~PDEV_READ_BUF_EMPTY;
			} else {
			    break;	/* No new read ahead data */
			}
d2479 1
d2481 2
a2482 3
		     * We know here that the lastByte pointer indicates
		     * more data.  Otherwise we've broken out.
		     * Update select state and poke waiting readers.
d2484 15
a2498 4
		    pdevHandlePtr->readBuf.lastByte = argPtr->readLastByte;
		    pdevHandlePtr->selectBits |= FS_READABLE;
		    FsFastWaitListNotify(&pdevHandlePtr->cltReadWaitList);
	        }
d2537 1
d2539 12
a2550 10
		/* 
		 * VERIFY THIS with the remote client case and the
		 * case of blocking writes.
		 */
		Sync_RemoteWaiter wait;
		wait.pid = pdevHandlePtr->clientPID;
		wait.hostID = pdevHandlePtr->clientSpriteID;
		wait.waitToken = SYNC_BROADCAST_TOKEN;
		FsFastWaitListInsert(&pdevHandlePtr->cltReadWaitList, &wait);
		FsFastWaitListInsert(&pdevHandlePtr->cltWriteWaitList, &wait);
d2945 1
a2945 1
	Sys_Printf("%6s %12s %8s\n", "REC", "<File ID>", " Event ");
d2952 1
a2952 1
	Sys_Printf("<%x,%x> ",
d2982 4
d2990 2
d3016 2
a3017 2
		    Sys_Printf(" %x ", recPtr->un.wait.pid);
		    if (recPtr->un.wait.waitToken & FS_READABLE) {
d3020 1
a3020 1
		    if (recPtr->un.wait.waitToken & FS_WRITABLE) {
d3023 1
a3023 1
		    if (recPtr->un.wait.waitToken & FS_EXCEPTION) {
@


1.1
log
@Initial revision
@
text
@d60 1
d79 7
a85 4
 * This contains a list of control messages that
 * describe new server streams.  A seed for new fileIDs is also kept
 * here.  New handles (only used for I/O) are generated for each new
 * pseudo stream/server stream pair.
d88 4
a91 1
    FsHandleHeader	hdr;	/* Standared header, type FS_CONTROL_STREAM */
d93 1
a93 1
				 * means there is no server. */
d217 5
d235 1
d298 1
a298 1
	List_Init(ctrlHandlePtr->queueHdr);
d300 3
a302 1
	List_Init(ctrlHandlePtr->readWaitList);
d338 1
a338 2
					 * Should be locked upon entry.  It
					 * is unlocked and released here. */
d370 4
a373 2
	     * Return to the pseudo-device server a ControlIOHandle with
	     * itself as the server.
d375 1
a375 1
	    ioFileID.serverID = ctrlHandlePtr->serverID = clientID;
d418 1
a418 1
	    pdevStatePtr->ctrlFileID = ctrlHandlePtr->hdr.fileID;
d444 5
a448 1
 *	Fs_Open on the host running the server.
d464 1
a464 1
    ClientData		streamData;	/* NIL for us. */
d475 1
d484 42
a564 1
    ctrlHandlePtr->serverID = NIL;
d569 8
d684 4
d700 1
d852 3
d886 2
a887 1
    streamPtr = FsStreamNew(rpc_SpriteID, pdevHandlePtr, FS_READ|FS_USER);
d892 1
a892 1
    FsHandleRelease(streamPtr, TRUE);
d930 1
d940 1
d1415 1
a1415 1
	Sys_Panic(SYS_FATAL, "RequestResponse request too large\n");
a1472 5
     * Poke the server so it can read the new pointer values.
     */
    FsFastWaitListNotify(&pdevHandlePtr->srvReadWaitList);

    /*
d1489 1
a1489 1
			pdevHandlePtr->flags & FS_USER, serverProcPtr,
d1506 7
d1630 1
d1830 1
a1830 1
    pdevHandlePtr->flags |= (PDEV_BUSY|FS_USER);
d1832 1
d1944 1
a1944 1
    pdevHandlePtr->flags |= (PDEV_BUSY|FS_USER);
d1946 11
d2227 1
a2227 1
FsServerStreamIOControl(streamPtr, command, inBufSize, inBuffer,
d2229 1
a2229 1
    Fs_Stream 	*streamPtr;	/* Stream to control. */
d2237 1
a2237 1
    register PdevServerIOHandle	*pdevHandlePtr;
a2238 1
    pdevHandlePtr = (PdevServerIOHandle *) streamPtr->ioHandlePtr;
d2443 1
a2443 1
		if (pdevHandlePtr->flags & FS_USER) {
@
