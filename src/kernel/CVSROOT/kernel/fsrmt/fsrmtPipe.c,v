head     9.2;
branch   ;
access   ;
symbols  ds3100:9.2 sun3:9.2 sprited:9.1.1 sun4nw:9.1 symm:9.1 spur:9.1 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.2
date     92.10.26.14.10.00;  author mgbaker;  state Exp;
branches ;
next     9.1;

9.1
date     90.10.08.15.07.00;  author mendel;  state Exp;
branches 9.1.1.1;
next     9.0;

9.0
date     89.09.12.15.10.38;  author douglis;  state Stable;
branches ;
next     8.19;

8.19
date     89.08.21.15.29.31;  author mendel;  state Exp;
branches ;
next     8.18;

8.18
date     89.08.17.17.21.16;  author jhh;  state Exp;
branches ;
next     8.17;

8.17
date     89.07.18.13.08.15;  author jhh;  state Exp;
branches ;
next     8.16;

8.16
date     89.07.01.17.36.36;  author brent;  state Exp;
branches ;
next     8.15;

8.15
date     89.06.22.16.30.36;  author brent;  state Exp;
branches ;
next     8.14;

8.14
date     89.06.21.12.30.40;  author brent;  state Exp;
branches ;
next     8.13;

8.13
date     89.06.16.12.06.54;  author brent;  state Exp;
branches ;
next     8.12;

8.12
date     89.06.15.09.24.30;  author brent;  state Exp;
branches ;
next     8.11;

8.11
date     89.05.30.16.10.50;  author jhh;  state Exp;
branches ;
next     8.10;

8.10
date     89.05.09.13.10.39;  author brent;  state Exp;
branches ;
next     8.9;

8.9
date     89.02.28.08.48.19;  author brent;  state Exp;
branches ;
next     8.8;

8.8
date     89.02.14.10.56.15;  author jhh;  state Exp;
branches ;
next     8.7;

8.7
date     89.02.06.17.38.32;  author brent;  state Exp;
branches ;
next     8.6;

8.6
date     89.02.01.16.40.28;  author brent;  state Exp;
branches ;
next     8.5;

8.5
date     89.02.01.16.35.58;  author brent;  state Exp;
branches ;
next     8.4;

8.4
date     89.01.30.14.04.20;  author brent;  state Exp;
branches ;
next     8.3;

8.3
date     89.01.30.09.22.18;  author brent;  state Exp;
branches ;
next     8.2;

8.2
date     89.01.06.11.19.23;  author jhh;  state Exp;
branches ;
next     8.1;

8.1
date     88.12.21.10.17.30;  author brent;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.19.22;  author douglis;  state Stable;
branches ;
next     7.0;

7.0
date     88.11.11.15.31.07;  author brent;  state Exp;
branches ;
next     6.17;

6.17
date     88.10.20.15.48.20;  author brent;  state Exp;
branches ;
next     6.16;

6.16
date     88.10.16.11.11.36;  author brent;  state Exp;
branches ;
next     6.15;

6.15
date     88.10.14.12.15.17;  author brent;  state Exp;
branches ;
next     6.14;

6.14
date     88.10.11.15.59.15;  author brent;  state Exp;
branches ;
next     6.13;

6.13
date     88.10.10.11.25.49;  author douglis;  state Exp;
branches ;
next     6.12;

6.12
date     88.10.05.12.10.48;  author brent;  state Exp;
branches ;
next     6.11;

6.11
date     88.09.28.13.32.14;  author brent;  state Exp;
branches ;
next     6.10;

6.10
date     88.09.28.08.38.01;  author brent;  state Exp;
branches ;
next     6.9;

6.9
date     88.09.23.13.39.05;  author brent;  state Exp;
branches ;
next     6.8;

6.8
date     88.09.22.09.04.10;  author brent;  state Exp;
branches ;
next     6.7;

6.7
date     88.09.16.16.51.24;  author brent;  state Exp;
branches ;
next     6.6;

6.6
date     88.09.13.11.27.26;  author brent;  state Exp;
branches ;
next     6.5;

6.5
date     88.09.08.17.30.30;  author brent;  state Exp;
branches ;
next     6.4;

6.4
date     88.09.07.16.52.42;  author brent;  state Exp;
branches ;
next     6.3;

6.3
date     88.08.31.12.05.18;  author brent;  state Exp;
branches ;
next     6.2;

6.2
date     88.08.26.11.10.34;  author brent;  state Exp;
branches ;
next     6.1;

6.1
date     88.08.12.12.31.00;  author brent;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.15.43;  author brent;  state Stable;
branches ;
next     1.6;

1.6
date     88.08.05.13.57.59;  author brent;  state Exp;
branches ;
next     1.5;

1.5
date     88.08.04.15.05.05;  author mlgray;  state Exp;
branches ;
next     1.4;

1.4
date     88.06.08.14.59.25;  author brent;  state Exp;
branches ;
next     1.3;

1.3
date     88.06.06.09.36.48;  author brent;  state Exp;
branches ;
next     1.2;

1.2
date     88.04.19.10.34.28;  author brent;  state Exp;
branches ;
next     1.1;

1.1
date     88.04.11.10.09.00;  author brent;  state Exp;
branches ;
next     ;

9.1.1.1
date     91.11.15.16.56.48;  author kupfer;  state Exp;
branches ;
next     ;


desc
@Unnamed pipe procedures.
@


9.2
log
@Support for bulk reopen rpcs.
@
text
@/*
 * fsRmtPipe.c --
 *
 *	Routines for remote unnamed pipes.  An unnamed pipe has a fixed length
 *	resident buffer, a reading stream, and a writing stream.
 *	Process migration can result in remotely accessed pipes.
 *
 * Copyright 1989 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fsrmt/fsrmtPipe.c,v 9.1 90/10/08 15:07:00 mendel Exp $ SPRITE (Berkeley)";
#endif not lint


#include <sprite.h>

#include <fs.h>
#include <fsutil.h>
#include <fsconsist.h>
#include <fsio.h>
#include <fsNameOps.h>
#include <fsStat.h>
#include <fsrmt.h>
#include <vm.h>
#include <proc.h>
#include <rpc.h>
#include <fsioPipe.h>
#include <stdio.h>
/*
 * Migration debugging.
 */
#ifdef MIG_DEBUG

#define PIPE_CREATED(inStreamPtr, outStreamPtr) \
    { \
	printf("Create Pipe: Srvr %d Read <%d> Write <%d> I/O %d <%d,%d>\n", \
		(inStreamPtr)->hdr.fileID.serverID, \
		(inStreamPtr)->hdr.fileID.minor, \
		(outStreamPtr)->hdr.fileID.minor, \
		(inStreamPtr)->ioHandlePtr->fileID.serverID, \
		(inStreamPtr)->ioHandlePtr->fileID.major, \
		(inStreamPtr)->ioHandlePtr->fileID.minor); \
    }

#define PIPE_CLOSE(streamPtr, handlePtr) \
	printf("Pipe Close: Stream %s <%d> I/O <%d,%d> ref %d write %d flags %x\n", \
		((streamPtr)->flags & FS_READ) ? "Read" : "Write", \
		(streamPtr)->hdr.fileID.minor, \
		(handlePtr)->hdr.fileID.major, (handlePtr)->hdr.fileID.minor, \
		(handlePtr)->use.ref, (handlePtr)->use.write, \
		(handlePtr)->flags)

#define PIPE_MIG_1(migInfoPtr, dstClientID) \
	printf("Pipe Migrate: %d => %d Stream %d <%d> I/O <%d,%d> migFlags %x ", \
	    (migInfoPtr)->srcClientID, dstClientID, \
	    (migInfoPtr)->streamID.serverID, (migInfoPtr)->streamID.minor, \
	    (migInfoPtr)->ioFileID.major, (migInfoPtr)->ioFileID.minor, \
	    (migInfoPtr)->flags);

#define PIPE_MIG_2(migInfoPtr, closeSrcClient, handlePtr) \
	printf("=> %x\n    closeSrc %d (ref %d write %d", (migInfoPtr)->flags, \
		closeSrcClient, (handlePtr)->use.ref, (handlePtr)->use.write);

#define PIPE_MIG_3(handlePtr) \
	printf(" | ref %d write %d)\n", \
		(handlePtr)->use.ref, (handlePtr)->use.write);

#define PIPE_MIG_END(handlePtr) \
	printf("PipeMigEnd: I/O <%d,%d> ref %d write %d\n", \
	    (handlePtr)->hdr.fileID.major, (handlePtr)->hdr.fileID.minor, \
	    (handlePtr)->use.ref, (handlePtr)->use.write)
#else

#define PIPE_CREATED(inStreamPtr, outStreamPtr)
#define PIPE_CLOSE(streamPtr, handlePtr)
#define PIPE_MIG_1(migInfoPtr, dstClientID)
#define PIPE_MIG_2(migInfoPtr, closeSrcClient, handlePtr)
#define PIPE_MIG_3(handlePtr)
#define PIPE_MIG_END(handlePtr)

#endif /* MIG_DEBUG */

/*
 * ----------------------------------------------------------------------------
 *
 * FsrmtPipeMigrate --
 *
 *	This takes care of transfering references from one client to the other.
 *	A useful side-effect of this routine is	to properly set the type in
 *	the ioFileID, either FSIO_LCL_PIPE_STREAM or FSIO_RMT_PIPE_STREAM,
 *	so that the subsequent call to Fsrmt_IOMigOpen will set up
 *	the right I/O handle.
 *
 * Results:
 *	An error status if the I/O handle can't be set-up.
 *	Otherwise SUCCESS is returned, *flagsPtr may have the FS_RMT_SHARED
 *	bit set, and *sizePtr and *dataPtr are set to reference Fsio_DeviceState.
 *
 * Side effects:
 *	Sets the correct stream type on the ioFileID.
 *	Shifts client references from the srcClient to the destClient.
 *	Set up and return Fsio_DeviceState for use by the MigEnd routine.
 *
 * ----------------------------------------------------------------------------
 *
 */
/*ARGSUSED*/
ReturnStatus
FsrmtPipeMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr, sizePtr, dataPtr)
    Fsio_MigInfo	*migInfoPtr;	/* Migration state */
    int		dstClientID;	/* ID of target client */
    int		*flagsPtr;	/* In/Out Stream usage flags */
    int		*offsetPtr;	/* Return - new stream offset (not needed) */
    int		*sizePtr;	/* Return - sizeof(Fsio_DeviceState) */
    Address	*dataPtr;	/* Return - pointer to Fsio_DeviceState */
{
    register ReturnStatus		status;

    if (migInfoPtr->ioFileID.serverID == rpc_SpriteID) {
	/*
	 * The pipe was remote, which is why we were called, but is now local.
	 */
	migInfoPtr->ioFileID.type = FSIO_LCL_PIPE_STREAM;
	return(Fsio_PipeMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr,
		sizePtr, dataPtr));
    }
    migInfoPtr->ioFileID.type = FSIO_RMT_PIPE_STREAM;
    status = Fsrmt_NotifyOfMigration(migInfoPtr, flagsPtr, offsetPtr,
				 0, (Address)NIL);
    if (status != SUCCESS) {
	printf( "FsrmtPipeMigrate, server error <%x>\n",
	    status);
    } else {
	*dataPtr = (Address)NIL;
	*sizePtr = 0;
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FsrmtPipeVerify --
 *
 *	Verify that the remote client is known for the pipe, and return
 *	a locked pointer to the pipe's I/O handle.
 *
 * Results:
 *	A pointer to the I/O handle for the pipe, or NIL if
 *	the client is bad.
 *
 * Side effects:
 *	The handle is returned locked and with its refCount incremented.
 *	It should be released with Fsutil_HandleRelease.
 *
 *----------------------------------------------------------------------
 */

Fs_HandleHeader *
FsrmtPipeVerify(fileIDPtr, clientID, domainTypePtr)
    Fs_FileID	*fileIDPtr;	/* Client's I/O file ID */
    int		clientID;	/* Host ID of the client */
    int		*domainTypePtr;	/* Return - FS_LOCAL_DOMAIN */
{
    register Fsio_PipeIOHandle	*handlePtr;
    register Fsconsist_ClientInfo	*clientPtr;
    Boolean			found = FALSE;

    fileIDPtr->type = FSIO_LCL_PIPE_STREAM;
    handlePtr = Fsutil_HandleFetchType(Fsio_PipeIOHandle, fileIDPtr);
    if (handlePtr != (Fsio_PipeIOHandle *)NIL) {
	LIST_FORALL(&handlePtr->clientList, (List_Links *) clientPtr) {
	    if (clientPtr->clientID == clientID) {
		found = TRUE;
		break;
	    }
	}
	if (!found) {
	    Fsutil_HandleRelease(handlePtr, TRUE);
	    handlePtr = (Fsio_PipeIOHandle *)NIL;
	}
    }
    if (!found) {
	printf(
	    "FsrmtPipeVerify, client %d not known for pipe <%d,%d>\n",
	    clientID, fileIDPtr->major, fileIDPtr->minor);
    }
    if (domainTypePtr != (int *)NIL) {
	*domainTypePtr = FS_LOCAL_DOMAIN;
    }
    return((Fs_HandleHeader *)handlePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * FsrmtPipeReopen --
 *
 *	Reopen a remote pipe.  This sets up and conducts an 
 *	RPC_FS_REOPEN remote procedure call to re-open the remote pipe.
 *
 * Results:
 *	A  non-SUCCESS return code if the re-open failed.
 *
 * Side effects:
 *	If the reopen works we'll have a valid I/O handle.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsrmtPipeReopen(hdrPtr, clientID, inData, outSizePtr, outDataPtr)
    Fs_HandleHeader	*hdrPtr;
    int			clientID;		/* Should be rpc_SpriteID */
    ClientData		inData;			/* IGNORED */
    int			*outSizePtr;		/* IGNORED */
    ClientData		*outDataPtr;		/* IGNORED */
{
    register Fsrmt_IOHandle	*rmtHandlePtr;
    ReturnStatus		status;
    Fsio_PipeReopenParams		reopenParams;
    int				outSize;

    rmtHandlePtr = (Fsrmt_IOHandle *)hdrPtr;
    reopenParams.fileID = hdrPtr->fileID;
    reopenParams.fileID.type = FSIO_LCL_PIPE_STREAM;
    reopenParams.use = rmtHandlePtr->recovery.use;

    /*
     * Contact the server to do the reopen, and then notify waiters.
     */
    outSize = 0;
    status = FsrmtReopen(hdrPtr, sizeof(Fsio_PipeReopenParams),
		(Address)&reopenParams, &outSize, (Address)NIL);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FsrmtSetupPipeReopen --
 *
 *	Set up the data for an RPC to reopen a pipe handle.
 *
 * Results:
 *	Return status;
 *
 * Side effects:
 *	Data structure set up.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
FsrmtSetupPipeReopen(hdrPtr, paramsPtr)
    Fs_HandleHeader		*hdrPtr;
    Address			paramsPtr;
{
    Fsrmt_IOHandle		*rmtHandlePtr;
    Fsio_PipeReopenParams	*reopenParamsPtr;

    rmtHandlePtr = (Fsrmt_IOHandle *)hdrPtr;
    reopenParamsPtr = (Fsio_PipeReopenParams *)	paramsPtr;
    reopenParamsPtr->fileID = hdrPtr->fileID;
    reopenParamsPtr->fileID.type = FSIO_LCL_PIPE_STREAM;
    reopenParamsPtr->use = rmtHandlePtr->recovery.use;

    return SUCCESS;
}

/*
 *----------------------------------------------------------------------
 *
 * FsrmtFinishPipeReopen --
 *
 *	Do post-processing for a file handle after bulk reopen.
 *	There is none for a pipe.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
FsrmtFinishPipeReopen(hdrPtr, statePtr, status)
    Fs_HandleHeader		*hdrPtr;
    Address			statePtr;
    ReturnStatus		status;
{
    return;
}
@


9.1
log
@Changed file name to fsrmtPipe.c
Fixed includes to use <> rather than "", added functions prototypes, and
removed lint.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs.mendel/RCS/fsRmtPipe.c,v 1.1 90/01/16 17:11:35 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d244 57
@


9.1.1.1
log
@Initial branch for Sprite server.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fsrmt/fsrmtPipe.c,v 9.1 90/10/08 15:07:00 mendel Exp $ SPRITE (Berkeley)";
@


9.0
log
@Changing version numbers.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsrmt/RCS/fsRmtPipe.c,v 8.19 89/08/21 15:29:31 mendel Exp Locker: douglis $ SPRITE (Berkeley)";
d23 1
a23 1
#include "sprite.h"
d25 12
a36 12
#include "fs.h"
#include "fsutil.h"
#include "fsio.h"
#include "fsNameOps.h"
#include "fsconsist.h"
#include "fsStat.h"
#include "fsrmt.h"
#include "vm.h"
#include "proc.h"
#include "rpc.h"
#include "fsioPipe.h"

d118 1
a118 1
    FsMigInfo	*migInfoPtr;	/* Migration state */
@


8.19
log
@Break up fs into many modules.    
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.17 89/07/18 13:08:15 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
@


8.18
log
@Changed to use Fmt_Convert
@
text
@d2 1
a2 1
 * fsPipe.c --
d4 1
a4 1
 *	Routines for unnamed pipes.  An unnamed pipe has a fixed length
d8 8
a15 2
 * Copyright (C) 1985 Regents of the University of California
 * All rights reserved.
d24 1
d26 4
a29 7
#include "fsInt.h"
#include "fsPipe.h"
#include "fsOpTable.h"
#include "fsStream.h"
#include "fsMigrate.h"
#include "fsRecovery.h"
#include "fsClient.h"
d31 1
a31 1

d35 1
a35 12

/*
 * Monitor to synchronize access to the openInstance in GetFileID.
 */
static	Sync_Lock	pipeLock = Sync_LockInitStatic("Fs:pipeLock");
#define	LOCKPTR	&pipeLock

/*
 * Forward references.
 */
void GetFileID();
FsPipeIOHandle *FsPipeHandleInit();
a91 827
 *----------------------------------------------------------------------
 *
 * Fs_CreatePipe --
 *
 *      Create an unnamed pipe.  Pointers to streams for both ends of the pipe
 *	are returned in *inStreamPtrPtr and *outStreamPtrPtr.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Fs_CreatePipe(inStreamPtrPtr, outStreamPtrPtr)
    Fs_Stream **inStreamPtrPtr;		/* Return - in (reading) stream */
    Fs_Stream **outStreamPtrPtr;	/* Return - out (writing) stream */
{
    Fs_FileID		fileID;
    register FsPipeIOHandle	*handlePtr;
    register Fs_Stream		*streamPtr;

    /*
     * Set up the I/O handle for the pipe.  The installation puts
     * one reference on the I/O handle.
     */

    GetFileID(&fileID);
    handlePtr = FsPipeHandleInit(&fileID, FALSE);
    (void)FsIOClientOpen(&handlePtr->clientList, rpc_SpriteID, FS_READ, FALSE);
    (void)FsIOClientOpen(&handlePtr->clientList, rpc_SpriteID, FS_WRITE, FALSE);

    /*
     * Allocate and initialize the read, or "in", end of the stream.
     */
    streamPtr = FsStreamNewClient(rpc_SpriteID, rpc_SpriteID,
			    (FsHandleHeader *)handlePtr,
			    FS_READ | FS_CONSUME | FS_USER, "read-pipe");
    FsHandleUnlock(streamPtr);
    *inStreamPtrPtr = streamPtr;

    /*
     * Set up the writing end.  Note that we get a second reference to
     * the I/O handle by duping it.
     */
    FsHandleUnlock(handlePtr);
    (void)FsHandleDup((FsHandleHeader *)handlePtr);
    streamPtr = FsStreamNewClient(rpc_SpriteID, rpc_SpriteID,
			(FsHandleHeader *)handlePtr,
			FS_WRITE | FS_APPEND | FS_USER, "write-pipe");
    FsHandleUnlock(handlePtr);
    FsHandleUnlock(streamPtr);
    *outStreamPtrPtr = streamPtr;

    PIPE_CREATED(*inStreamPtrPtr, *outStreamPtrPtr);

    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * GetFileID --
 *
 *      Get a unique file ID for the pipe.  This is a monitor to synchronize
 *	access to the openInstance variable that gives us unique file
 *	ids for unnamed pipes.
 *
 * Results:
 *	Unique file ID.
 *
 * Side effects:
 *	Open instance incremented.
 *
 *----------------------------------------------------------------------
 */

ENTRY void
GetFileID(fileIDPtr)
    Fs_FileID	*fileIDPtr;
{
    static int openInstance = 0;

    LOCK_MONITOR;

    fileIDPtr->type = FS_LCL_PIPE_STREAM;
    fileIDPtr->serverID = rpc_SpriteID;
    fileIDPtr->major = 0;
    fileIDPtr->minor = openInstance;
    openInstance++;

    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * FsPipeHandleInit --
 *
 *	Initialize a handle for a pipe.
 *
 * Results:
 *	A pointer to the pipe handle.
 *
 * Side effects:
 *	Create and install a handle for the file.  It is returned locked
 *	and with its reference count incremented if SUCCESS is returned.
 *
 *----------------------------------------------------------------------
 */
FsPipeIOHandle *
FsPipeHandleInit(fileIDPtr, findIt)
    Fs_FileID	*fileIDPtr;	/* Pipe file ID */
    Boolean	findIt;		/* TRUE if we expect to find its handle */
{
    FsHandleHeader *hdrPtr;
    register FsPipeIOHandle *handlePtr;
    register Boolean found;

    found = FsHandleInstall(fileIDPtr, sizeof(FsPipeIOHandle), "pipe", &hdrPtr);
    handlePtr = (FsPipeIOHandle *)hdrPtr;
    if (!found) {
	if (findIt) {
	    panic( "FsPipeHandleInit, didn't find handle\n");
	}
	/*
	 * When a pipe is created, it has one read and one write
	 * reference on the handle.
	 */
	handlePtr->use.ref = 2;
	handlePtr->use.write = 1;
	handlePtr->use.exec = 0;
	List_Init(&handlePtr->clientList);
	handlePtr->flags = 0;
	handlePtr->firstByte = handlePtr->lastByte = -1;
	handlePtr->buffer = (Address)malloc(FS_BLOCK_SIZE);
	handlePtr->bufSize = FS_BLOCK_SIZE;
	List_Init(&handlePtr->readWaitList);
	List_Init(&handlePtr->writeWaitList);
	fsStats.object.pipes++;
    }
    return(handlePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * FsPipeClose --
 *
 *      Close a local pipe.  Other processes waiting on the pipe are
 *	unblocked and the pipe's buffer is freed when the last
 *	user goes away.
 *
 * Results:
 *      SUCCESS.
 *
 * Side effects:
 *      Unblock local waiting reader (or writer) waiting on the pipe.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsPipeClose(streamPtr, clientID, procID, flags, dataSize, closeData)
    Fs_Stream		*streamPtr;	/* Stream to a pipe */
    int			clientID;	/* Host ID of closing process */
    Proc_PID		procID;		/* Process closing */
    int			flags;		/* Flags from the stream being closed */
    int			dataSize;	/* Should be 0 */
    ClientData		closeData;	/* Should be NIL */
{
    register FsPipeIOHandle *handlePtr = 
	    (FsPipeIOHandle *)streamPtr->ioHandlePtr;
    Boolean cache = FALSE;

    if (!FsIOClientClose(&handlePtr->clientList, clientID, flags, &cache)) {
	printf( "FsPipeClose, unknown client %d\n", clientID);
	FsHandleUnlock(handlePtr);
    } else {
	/*
	 * Update the global/summary use counts for the file.
	 */
	handlePtr->use.ref--;
	if (flags & FS_WRITE) {
	    handlePtr->use.write--;
	}
	if (handlePtr->use.ref < 0 || handlePtr->use.write < 0) {
	    panic("FsPipeClose <%d,%d> use %d, write %d\n",
		      handlePtr->hdr.fileID.major, handlePtr->hdr.fileID.minor,
		      handlePtr->use.ref, handlePtr->use.write);
	}
	if ((flags & FS_WRITE) && handlePtr->use.write == 0) {
	    /*
	     * Notify reader that the writer has closed.
	     */
	    handlePtr->flags |= PIPE_WRITER_GONE;
	    FsFastWaitListNotify(&handlePtr->readWaitList);
	} else if ((flags & FS_READ) &&
		    handlePtr->use.ref == handlePtr->use.write) {
	    /*
	     * Update state and notify any blocked writers.  Their write
	     * will fail with no remaining readers.
	     */
	    handlePtr->flags |= PIPE_READER_GONE;
	    FsFastWaitListNotify(&handlePtr->writeWaitList);
	}
	PIPE_CLOSE(streamPtr, handlePtr);
	FsHandleRelease(handlePtr, TRUE);
	if (handlePtr->flags == (PIPE_WRITER_GONE|PIPE_READER_GONE)) {
	    free(handlePtr->buffer);
	    FsWaitListDelete(&handlePtr->readWaitList);
	    FsWaitListDelete(&handlePtr->writeWaitList);
	    FsHandleRemove(handlePtr);
	    fsStats.object.pipes--;
	}
    }
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FsPipeRead --
 *
 *      Read on a pipe.  Data is copied out of the pipe to satisfy the
 *	read.  If the pipe is empty this routine returns FS_WOULD_BLOCK.
 *	If the pipe writer is gone this returns SUCCESS and 0 bytes
 *	to simulate EOF.
 *
 * Results:
 *      SUCCESS unless there was an address error or I/O error.
 *
 * Side effects:
 *      Fill in the buffer.  Notifies the pipe's writeWaitList after
 *	removing data from the pipe.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsPipeRead(streamPtr, readPtr, waitPtr, replyPtr)
    Fs_Stream           *streamPtr;     /* Stream to read from */
    Fs_IOParam		*readPtr;	/* Read parameter block. */
    Sync_RemoteWaiter	*waitPtr;	/* Process info for remote waiting */
    Fs_IOReply		*replyPtr;	/* Signal to return, if any,
					 * plus the amount read. */
{
    ReturnStatus 	status = SUCCESS;
    register FsPipeIOHandle *handlePtr =
	    (FsPipeIOHandle *)streamPtr->ioHandlePtr;
    int 		toRead;
    int 		startOffset;
    int			startByte;
    int			endByte;

    FsHandleLock(handlePtr);

    if (handlePtr->firstByte == -1) {
	/*
	 * No data in the pipe.  If there is no writer left then
	 * return SUCCESS so the user process thinks of it as end of file,
	 * otherwise block waiting for input.
	 */
	replyPtr->length = 0;
	if (handlePtr->flags & PIPE_WRITER_GONE) {
	    status = SUCCESS;
	    goto exit;
	} else {
	    status = FS_WOULD_BLOCK;
	    goto exit;
	}
    }
    /*
     * Compute the number of bytes that we can read from the pipe.  
     */
    toRead = handlePtr->lastByte - handlePtr->firstByte + 1;
    if (toRead > readPtr->length) {
	toRead = readPtr->length;
    }

    /*
     * Compute offsets into the pipe buffer.  The offsets float out past
     * the size of the buffer, but we use masks to take of the top bits.
     * We can also compare these top bits to determine if the valid range
     * of the buffer wraps around the end of the pipe.
     */
    startByte = handlePtr->firstByte;
    startOffset = startByte & FS_BLOCK_OFFSET_MASK;
    endByte = handlePtr->firstByte + toRead - 1;

    if ((startByte & ~FS_BLOCK_OFFSET_MASK) ==
	(endByte & ~FS_BLOCK_OFFSET_MASK)) {
	/*
	 * Can do a straight copy, no wrap around necessary.
	 */
	if (readPtr->flags & FS_USER) {
	    if (Vm_CopyOut(toRead, handlePtr->buffer + startOffset, readPtr->buffer)
			  != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    }
	} else {
	    bcopy(handlePtr->buffer + startOffset, readPtr->buffer, toRead);
	}
    } else {
	int	numBytes;
	/*
	 * Have to wrap around in the block so do it in two copies.
	 */
	numBytes = FS_BLOCK_SIZE - startOffset;
	if (readPtr->flags & FS_USER) {
	    if (Vm_CopyOut(numBytes, handlePtr->buffer + startOffset, readPtr->buffer)
			  != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    } else if (Vm_CopyOut(toRead - numBytes, handlePtr->buffer,
				readPtr->buffer + numBytes) != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    }
	} else {
	    bcopy(handlePtr->buffer + startOffset, readPtr->buffer, numBytes);
	    bcopy(handlePtr->buffer, readPtr->buffer + numBytes, toRead - numBytes);
	}
    }

    /*
     * We just made space in the pipe so wake up blocked writers.
     */
    FsFastWaitListNotify(&handlePtr->writeWaitList);

    /*
     * Update the first byte and the parameters.
     */
    handlePtr->firstByte += toRead;
    if (handlePtr->firstByte > handlePtr->lastByte) {
	handlePtr->firstByte = -1;
	handlePtr->lastByte = -1;
    }
    replyPtr->length = toRead;
exit:
    if (status == FS_WOULD_BLOCK) {
	FsFastWaitListInsert(&handlePtr->readWaitList, waitPtr);
    }
    FsHandleUnlock(handlePtr);
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * FsPipeWrite --
 *
 *      Write on a pipe.  This will put as much data as possible into the
 *	pipe buffer, and then block the process (return would-block) if
 *	there is any left over data.  *lenPtr is updated to reflect how
 *	much data was written to the pipe.
 *
 * Results:
 *      SUCCESS unless there was an address error or I/O error.
 *
 * Side effects:
 *      Fill the pipe from the buffer.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
FsPipeWrite(streamPtr, writePtr, waitPtr, replyPtr)
    Fs_Stream           *streamPtr;     /* Stream to write to */
    Fs_IOParam		*writePtr;	/* Read parameter block */
    Sync_RemoteWaiter	*waitPtr;	/* Process info for remote waiting */
    Fs_IOReply		*replyPtr;	/* Signal to return, if any */
{
    register ReturnStatus 	status = SUCCESS;
    register FsPipeIOHandle	*handlePtr =
	    (FsPipeIOHandle *)streamPtr->ioHandlePtr;
    int 			startOffset;
    register int 		toWrite;
    int				startByte;
    int				endByte;

    FsHandleLock(handlePtr);

    if (handlePtr->flags & PIPE_READER_GONE) {
	replyPtr->length = 0;
	replyPtr->signal = SIG_PIPE;
	status = FS_BROKEN_PIPE;
	goto exit;
    }

    /*
     * Compute the number of bytes that will fit in the pipe.  Remember
     * that the pipe can only hold one block of data.
     */
    if (handlePtr->firstByte == -1) {
	toWrite = FS_BLOCK_SIZE;
    } else {
	toWrite = FS_BLOCK_SIZE - 
		    (handlePtr->lastByte - handlePtr->firstByte + 1);
    }
    if (toWrite == 0) {
	/*
	 * No room in the pipe.
	 */
	replyPtr->length = 0;
	status = FS_WOULD_BLOCK;
	goto exit;
    } else if (toWrite > writePtr->length) {
	toWrite = writePtr->length;
#ifdef notdef
    } else if ((writePtr->length > toWrite) &&
	       ((flags & FS_NON_BLOCKING) == 0)) {
	/*
	 * If there is more data to write we must block after writing the
	 * data that we can.  If the stream is non-blocking, however, we
	 * return a successful error code after writing what we can.
	 *
	 * Fs_Write takes care of returning the correct code.  We should
	 * be able to return SUCCESS if we return some data, and
	 * FS_WOULD_BLOCK if we return no data.  Fs_Write looks at the
	 * stream flags for us and "does the right thing" with partial writes.
	 */
	status = FS_WOULD_BLOCK;
#endif
    }
    /*
     * Determine where to start and stop writing.  Note that the firstByte
     * and lastByte offsets float out beyond the size of the pipe but
     * we use masks to clear off the extra high order bits.
     */
    startByte = handlePtr->lastByte + 1;
    startOffset = startByte & FS_BLOCK_OFFSET_MASK;
    endByte = handlePtr->lastByte + toWrite;

    if ((startByte & ~FS_BLOCK_OFFSET_MASK) ==
	(endByte & ~FS_BLOCK_OFFSET_MASK)) {
	/*
	 * Can do a straight copy, no wrap around necessary.
	 */
	if (writePtr->flags & FS_USER) {
	    if (Vm_CopyIn(toWrite, writePtr->buffer, handlePtr->buffer + startOffset)
			  != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    }
	} else {
	    bcopy(writePtr->buffer, handlePtr->buffer + startOffset, toWrite);
	}
    } else {
	int	numBytes;
	/*
	 * Have to wrap around in the block so do it in two copies.
	 */
	numBytes = FS_BLOCK_SIZE - startOffset;
	if (writePtr->flags & FS_USER) {
	    if (Vm_CopyIn(numBytes, writePtr->buffer, handlePtr->buffer + startOffset)
			  != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    } else if (Vm_CopyIn(toWrite - numBytes, writePtr->buffer + numBytes, 
			    handlePtr->buffer) != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    }
	} else {
	    bcopy(writePtr->buffer, handlePtr->buffer + startOffset, numBytes);
	    bcopy(writePtr->buffer + numBytes, handlePtr->buffer, toWrite - numBytes);
	}
    }

    /*
     * We just wrote to the pipe so wake up blocked readers.
     */
    FsFastWaitListNotify(&handlePtr->readWaitList);

    /*
     * Update first byte, last byte and the parameters.
     */
    if (handlePtr->firstByte == -1) {
	handlePtr->firstByte = 0;
    }
    handlePtr->lastByte = endByte;
    replyPtr->length = toWrite;
exit:
    if (status == FS_WOULD_BLOCK) {
	FsFastWaitListInsert(&handlePtr->writeWaitList, waitPtr);
    }
    FsHandleUnlock(handlePtr);
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * FsPipeIOControl --
 *
 *	Check the IOC_CLEAR_FLAG control, and allow the IOC_SET_FLAG control.
 *
 * Results:
 *      SUCCESS unless they try to clear the FS_APPEND flag.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsPipeIOControl(streamPtr, ioctlPtr, replyPtr)
    Fs_Stream *streamPtr;
    Fs_IOCParam *ioctlPtr;		/* I/O Control parameter block */
    Fs_IOReply *replyPtr;		/* Return length and signal */
{
    register FsPipeIOHandle *handlePtr =
	    (FsPipeIOHandle *)streamPtr->ioHandlePtr;
    register int command = ioctlPtr->command;
    ReturnStatus status = SUCCESS;

    switch(command) {
	case IOC_REPOSITION:
	    return(FS_BAD_SEEK);
	case IOC_GET_FLAGS:
	case IOC_SET_BITS:
	    return(SUCCESS);
	case IOC_CLEAR_BITS:
	case IOC_SET_FLAGS: {
	    /*
	     * Guard against turning off append mode in pipes.
	     */
	    int flags;
	    int size;
	    int inSize;

	    if (ioctlPtr->inBufSize != sizeof(int)) {
		status = GEN_INVALID_ARG;
	    } else if (ioctlPtr->format != mach_Format) {
		int fmtStatus;
		size = sizeof(int);
		inSize = ioctlPtr->inBufSize;
		fmtStatus = Fmt_Convert("w", ioctlPtr->format, &inSize,
				ioctlPtr->inBuffer, mach_Format, &size,
				(Address) &flags);
		if (fmtStatus != 0) {
		    printf("Format of ioctl failed <0x%x>\n", fmtStatus);
		    status = GEN_INVALID_ARG;
		}
		if (size != sizeof(int)) {
		    status = GEN_INVALID_ARG;
		}
	    } else {
		flags = *(int *)ioctlPtr->inBuffer;
	    }
	    if (status != SUCCESS) {
		return(status);
	    }
	    if ((command == IOC_SET_FLAGS && (flags & IOC_APPEND) == 0) ||
		(command == IOC_CLEAR_BITS && (flags & IOC_APPEND))) {
		return(GEN_INVALID_ARG);
	    }
	    return(SUCCESS);
	}
	case IOC_TRUNCATE:
	case IOC_LOCK:
	case IOC_UNLOCK:
	    return(GEN_NOT_IMPLEMENTED);
	case IOC_NUM_READABLE: {
	    int bytesAvailable = handlePtr->lastByte - handlePtr->firstByte;

	    if (ioctlPtr->outBufSize != sizeof(int)) {
		status = GEN_INVALID_ARG;
	    } else if (ioctlPtr->format != mach_Format) {
		int size = sizeof(int);
		int inSize = sizeof(int);
		int fmtStatus;
		fmtStatus = Fmt_Convert("w", mach_Format, &inSize,
				(Address) &bytesAvailable, ioctlPtr->format, 
				&size, (Address) ioctlPtr->outBuffer);
		if (fmtStatus != 0) {
		    printf("Format of ioctl failed <0x%x>\n", fmtStatus);
		    status = GEN_INVALID_ARG;
		}
		if (size != sizeof(int)) {
		    status = GEN_INVALID_ARG;
		}
	    } else {
		*(int *)ioctlPtr->outBuffer = bytesAvailable;
	    }
	    return(status);
	}
	case IOC_GET_OWNER:
	case IOC_SET_OWNER:
	case IOC_MAP:
	case IOC_PREFIX:
	    return(GEN_NOT_IMPLEMENTED);
	default:
	    return(GEN_INVALID_ARG);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * FsPipeSelect --
 *
 *	Select on a pipe.
 *
 * Results:
 *      SUCCESS unless there was an address error or I/O error.
 *
 * Side effects:
 *      Fill the pipe from the buffer.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
FsPipeSelect(hdrPtr, waitPtr, readPtr, writePtr, exceptPtr)
    FsHandleHeader *hdrPtr;	/* The handle of the file */
    Sync_RemoteWaiter *waitPtr;	/* Process info for waiting */
    int		*readPtr;	/* Read bit */
    int		*writePtr;	/* Write bit */
    int		*exceptPtr;	/* Exception bit */
{
    register FsPipeIOHandle *handlePtr = (FsPipeIOHandle *)hdrPtr;

    FsHandleLock(hdrPtr);
    *exceptPtr = 0;
    if (*writePtr) {
	/*
	 * Turn off writability if the pipe is full and there
	 * are still readers.  If there are no readers we allow
	 * writing but the next write will fail.
	 */
	if ((((handlePtr->firstByte + 1) % FS_BLOCK_SIZE) ==
	     handlePtr->lastByte) && 
	     ((handlePtr->flags & PIPE_READER_GONE) == 0)) {
	    if (waitPtr != (Sync_RemoteWaiter *)NIL) {
		FsFastWaitListInsert(&handlePtr->writeWaitList, waitPtr);
	    }
	    *writePtr = 0;
	}
    }
    if (*readPtr) {
	/*
	 * If there's data to be read then set the READABLE bit.
	 * If all the writers have died, then this process will never be 
	 * woken up again so lie and say the pipe is readble. The process
	 * discover there's no writer when it tries to read the pipe.
	 */
	if ((handlePtr->firstByte == -1) &&
	    ((handlePtr->flags & PIPE_WRITER_GONE) == 0)) {
	    *readPtr = 0;
	    if (waitPtr != (Sync_RemoteWaiter *)NIL) {
		FsFastWaitListInsert(&handlePtr->readWaitList, waitPtr);
	    }
        }
    }
    FsHandleUnlock(hdrPtr);
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FsPipeGetIOAttr --
 *
 *	Get the most up-to-date I/O attributes for a pipe.
 *
 * Results:
 *	SUCCESS
 *
 * Side effects:
 *      Updates the first and last byte indexes of the handle.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsPipeGetIOAttr(fileIDPtr, clientID, attrPtr)
    Fs_FileID			*fileIDPtr;	/* FileID of pipe */
    int 			clientID;	/* IGNORED */
    register Fs_Attributes	*attrPtr;	/* Attributes to update */
{
    FsPipeIOHandle *handlePtr;

    handlePtr = FsHandleFetchType(FsPipeIOHandle, fileIDPtr);
    if (handlePtr != (FsPipeIOHandle *)NIL) {
	attrPtr->serverID	= fileIDPtr->serverID;
	attrPtr->domain		= fileIDPtr->major;
	attrPtr->fileNumber	= fileIDPtr->minor;
	attrPtr->type		= FS_LOCAL_PIPE;
	attrPtr->size		= handlePtr->lastByte - handlePtr->firstByte +1;
	attrPtr->devServerID	= fileIDPtr->serverID;
	FsHandleUnlock(handlePtr);
    }
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * FsPipeSetIOAttr --
 *
 *	Set the I/O attributes for a pipe.  This doesn't do anything.
 *
 * Results:
 *	SUCCESS
 *
 * Side effects:
 *      Updates the first and last byte indexes of the handle.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsPipeSetIOAttr(fileIDPtr, attrPtr, flags)
    Fs_FileID		*fileIDPtr;	/* FileID of pipe */
    Fs_Attributes	*attrPtr;	/* Attributes to update */
    int			flags;		/* What attrs to set */
{
    return(SUCCESS);
}

/*
 * ----------------------------------------------------------------------------
 *
 * FsPipeRelease --
 *
 *	Release a reference on a Pipe I/O handle.
 *	
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Release the I/O handle.
 *
 * ----------------------------------------------------------------------------
 *
 */
/*ARGSUSED*/
ReturnStatus
FsPipeRelease(hdrPtr, flags)
    FsHandleHeader *hdrPtr;	/* File being released */
    int flags;			/* Use flags from the stream */
{
    panic("FsPipeRelease called\n");
    FsHandleRelease(hdrPtr, FALSE);
    return(SUCCESS);
}

/*
 * ----------------------------------------------------------------------------
 *
 * FsPipeMigrate --
 *
 *	This takes care of transfering references from one client to the other.
 *	A useful side-effect of this routine is	to properly set the type in
 *	the ioFileID, either FS_LCL_PIPE_STREAM or FS_RMT_PIPE_STREAM.
 *	In the latter case FsRmtPipeMigrate is called to do all the work.
 *
 * Results:
 *	An error status if the I/O handle can't be set-up.
 *	Otherwise SUCCESS is returned, *flagsPtr may have the FS_RMT_SHARED
 *	bit set, and *sizePtr and *dataPtr are set to reference FsDeviceState.
 *
 * Side effects:
 *	Sets the correct stream type on the ioFileID.
 *	Shifts client references from the srcClient to the destClient.
 *
 * ----------------------------------------------------------------------------
 *
 */
/*ARGSUSED*/
ReturnStatus
FsPipeMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr, sizePtr, dataPtr)
    FsMigInfo	*migInfoPtr;	/* Migration state */
    int		dstClientID;	/* ID of target client */
    int		*flagsPtr;	/* In/Out Stream usage flags */
    int		*offsetPtr;	/* Return - new stream offset (not needed) */
    int		*sizePtr;	/* Return - sizeof(FsDeviceState) */
    Address	*dataPtr;	/* Return - pointer to FsDeviceState */
{
    FsPipeIOHandle			*handlePtr;
    Boolean				closeSrcClient;

    if (migInfoPtr->ioFileID.serverID != rpc_SpriteID) {
	/*
	 * The pipe was local, which is usually true, but is now remote.
	 */
	migInfoPtr->ioFileID.type = FS_RMT_PIPE_STREAM;
	return(FsRmtPipeMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr,
		sizePtr, dataPtr));
    }
    migInfoPtr->ioFileID.type = FS_LCL_PIPE_STREAM;
    handlePtr = FsPipeHandleInit(&migInfoPtr->ioFileID, TRUE);

    PIPE_MIG_1(migInfoPtr, dstClientID);
    /*
     * At the stream level, add the new client to the set of clients
     * for the stream, and check for any cross-network stream sharing.
     */
    FsStreamMigClient(migInfoPtr, dstClientID, (FsHandleHeader *)handlePtr,
		    &closeSrcClient);
    PIPE_MIG_2(migInfoPtr, closeSrcClient, handlePtr);

    /*
     * Adjust use counts on the I/O handle to reflect any new sharing.
     */
    FsMigrateUseCounts(migInfoPtr->flags, closeSrcClient, &handlePtr->use);
    PIPE_MIG_3(handlePtr);

    /*
     * Move the client at the I/O handle level.
     */
    FsIOClientMigrate(&handlePtr->clientList, migInfoPtr->srcClientID,
			dstClientID, migInfoPtr->flags, closeSrcClient);

    *sizePtr = 0;
    *dataPtr = (Address)NIL;
    *flagsPtr = migInfoPtr->flags;
    *offsetPtr = migInfoPtr->offset;
    /*
     * We don't need this reference on the I/O handle; there is no change.
     */
    FsHandleRelease(handlePtr, TRUE);
    return(SUCCESS);
}

/*
d94 1
a94 1
 * FsRmtPipeMigrate --
d98 2
a99 2
 *	the ioFileID, either FS_LCL_PIPE_STREAM or FS_RMT_PIPE_STREAM,
 *	so that the subsequent call to FsRemoteIOMigEnd will set up
d105 1
a105 1
 *	bit set, and *sizePtr and *dataPtr are set to reference FsDeviceState.
d110 1
a110 1
 *	Set up and return FsDeviceState for use by the MigEnd routine.
d117 1
a117 1
FsRmtPipeMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr, sizePtr, dataPtr)
d122 2
a123 2
    int		*sizePtr;	/* Return - sizeof(FsDeviceState) */
    Address	*dataPtr;	/* Return - pointer to FsDeviceState */
d131 2
a132 2
	migInfoPtr->ioFileID.type = FS_LCL_PIPE_STREAM;
	return(FsPipeMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr,
d135 2
a136 2
    migInfoPtr->ioFileID.type = FS_RMT_PIPE_STREAM;
    status = FsNotifyOfMigration(migInfoPtr, flagsPtr, offsetPtr,
d139 1
a139 1
	printf( "FsRmtPipeMigrate, server error <%x>\n",
a148 42
 * ----------------------------------------------------------------------------
 *
 * FsPipeMigEnd --
 *
 *	Complete setup of a FS_LCL_PIPE_STREAM after migration (back) to the
 *	pipe I/O server.  FsPipeMigrate has done the work of shifting use
 *	counts at the stream and I/O handle level.  This routine has to
 *	increment the low level reference count on the pipe I/O handle
 *	to reflect the existence of a new stream to the I/O handle.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 *
 */
/*ARGSUSED*/
ReturnStatus
FsPipeMigEnd(migInfoPtr, size, data, hdrPtrPtr)
    FsMigInfo	*migInfoPtr;	/* Migration state */
    int		size;		/* Zero */
    ClientData	data;		/* NIL */
    FsHandleHeader **hdrPtrPtr;	/* Return - handle for the file */
{
    register FsPipeIOHandle *handlePtr;

    handlePtr = FsHandleFetchType(FsPipeIOHandle, &migInfoPtr->ioFileID);
    if (handlePtr == (FsPipeIOHandle *)NIL) {
	panic( "FsPipeMigEnd, no handle\n");
	return(FAILURE);
    } else {
	PIPE_MIG_END(handlePtr);
	FsHandleUnlock(handlePtr);
	*hdrPtrPtr = (FsHandleHeader *)handlePtr;
	return(SUCCESS);
    }
}

/*
d151 1
a151 1
 * FsRmtPipeVerify --
d162 1
a162 1
 *	It should be released with FsHandleRelease.
d167 2
a168 2
FsHandleHeader *
FsRmtPipeVerify(fileIDPtr, clientID, domainTypePtr)
d173 2
a174 2
    register FsPipeIOHandle	*handlePtr;
    register FsClientInfo	*clientPtr;
d177 3
a179 3
    fileIDPtr->type = FS_LCL_PIPE_STREAM;
    handlePtr = FsHandleFetchType(FsPipeIOHandle, fileIDPtr);
    if (handlePtr != (FsPipeIOHandle *)NIL) {
d187 2
a188 2
	    FsHandleRelease(handlePtr, TRUE);
	    handlePtr = (FsPipeIOHandle *)NIL;
d193 1
a193 1
	    "FsRmtPipeVerify, client %d not known for pipe <%d,%d>\n",
d199 1
a199 1
    return((FsHandleHeader *)handlePtr);
d205 1
a205 1
 * FsRmtPipeReopen --
d220 2
a221 2
FsRmtPipeReopen(hdrPtr, clientID, inData, outSizePtr, outDataPtr)
    FsHandleHeader	*hdrPtr;
d227 1
a227 1
    register FsRemoteIOHandle	*rmtHandlePtr;
d229 1
a229 1
    FsPipeReopenParams		reopenParams;
d232 1
a232 1
    rmtHandlePtr = (FsRemoteIOHandle *)hdrPtr;
d234 1
a234 1
    reopenParams.fileID.type = FS_LCL_PIPE_STREAM;
d241 1
a241 1
    status = FsSpriteReopen(hdrPtr, sizeof(FsPipeReopenParams),
a244 132

/*
 *----------------------------------------------------------------------
 *
 * FsPipeReopen --
 *
 *	Reopen a pipe for a client.  This executed on a server and will
 *	only work if it was a network partition that made us forget
 *	about the client.  If we've already removed the pipe handle
 *	then the clien't won't be able to recover.
 *
 * Results:
 *	A  non-SUCCESS return code if the re-open failed.
 *
 * Side effects:
 *	Adds the client to the set of client's for the pipe.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsPipeReopen(hdrPtr, clientID, inData, outSizePtr, outDataPtr)
    FsHandleHeader	*hdrPtr;		/* NIL */
    int			clientID;		/* Host ID of client */
    ClientData		inData;			/* sizeof FsPipeReopenParams */
    int			*outSizePtr;		/* Returns 0 */
    ClientData		*outDataPtr;		/* Returns NIL */
{
    register FsPipeIOHandle	*handlePtr;
    ReturnStatus		status;
    FsPipeReopenParams		*reopenParamsPtr;

    reopenParamsPtr = (FsPipeReopenParams *)inData;
    handlePtr = FsHandleFetchType(FsPipeIOHandle, &reopenParamsPtr->fileID);
    if (handlePtr == (FsPipeIOHandle *)NIL) {
	status = FAILURE;
    } else {
	FsIOClientStatus(&handlePtr->clientList, clientID,
				 &reopenParamsPtr->use);
	(void)FsIOClientReopen(&handlePtr->clientList, clientID,
				 &reopenParamsPtr->use);
	handlePtr->use.ref += reopenParamsPtr->use.ref;
	handlePtr->use.write += reopenParamsPtr->use.write;
	FsHandleRelease(handlePtr, TRUE);
	status = SUCCESS;
    }
    *outSizePtr = 0;
    *outDataPtr = (ClientData)NIL;
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FsPipeClientKill --
 *
 *	Clean up after a crashed client.  Note, this doesn't handle the
 *	obscure case of one end of a pipe being duplicated and then
 *	one of the sharers migrating to a host which crashes.  In this
 *	funny case we'll wrongly think that all users of one end of
 *	the pipe have crashed.
 *
 * Results:
 *      SUCCESS.
 *
 * Side effects:
 *      Removes the client (if applicable) from the pipe's set of clients.
 *	This will cause a FS_BROKEN_PIPE error unless the pipe is re-opened,
 *	which might happen in a network partition.  This unlocks the handle.
 *
 *----------------------------------------------------------------------
 */
void
FsPipeClientKill(hdrPtr, clientID)
    FsHandleHeader *hdrPtr;     /* Handle to clean up */
    int clientID;		/* Host assumed down */
{
    register FsPipeIOHandle *handlePtr = (FsPipeIOHandle *)hdrPtr;
    int refs, writes, execs;

    FsIOClientKill(&handlePtr->clientList, clientID, &refs, &writes, &execs);
    if (refs > 0) {
	if (writes) {
	    handlePtr->flags |= PIPE_WRITER_GONE;
	} else {
	    handlePtr->flags |= PIPE_READER_GONE;
	}
    }
    FsHandleUnlock(handlePtr);
}


/*
 *----------------------------------------------------------------------
 *
 * FsPipeScavenge --
 *
 *	Scavenge a pipe.  The handle might be usless if all its
 *	client's have crashed.
 *
 * Results:
 *      TRUE if the handle was removed.
 *
 * Side effects:
 *      Unlocks the pipe's handle.
 *
 *----------------------------------------------------------------------
 */
Boolean
FsPipeScavenge(hdrPtr)
    FsHandleHeader *hdrPtr;     /* Handle about to be deleted */
{
#ifdef notdef
    register FsPipeIOHandle *handlePtr = (FsPipeIOHandle *)hdrPtr;
    if (List_IsEmpty(&handlePtr->clientList) &&
	(handlePtr->flags == (PIPE_WRITER_GONE|PIPE_READER_GONE))) {
	/*
	 * Never scavenge pipe handles.  Regular recovery cleanup
	 * should invoke the pipe close routines and do proper cleanup.
	 */
	free(handlePtr->buffer);
	FsWaitListDelete(&handlePtr->readWaitList);
	FsWaitListDelete(&handlePtr->writeWaitList);
	FsHandleRemove(hdrPtr);
	fsStats.object.pipes--;
	return(TRUE);
    }
#endif notdef
    FsHandleUnlock(hdrPtr);
    return(FALSE);
}

@


8.17
log
@Added IOC_PREFIX ioctl
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.16 89/07/01 17:36:36 brent Exp $ SPRITE (Berkeley)";
a17 1

a30 1
#include "swapBuffer.h"
d629 1
d633 2
a634 1
	    } else if (ioctlPtr->byteOrder != mach_ByteOrder) {
d636 8
a643 3
		Swap_Buffer(ioctlPtr->inBuffer, ioctlPtr->inBufSize,
			    ioctlPtr->byteOrder,
			    mach_ByteOrder, "w", (Address)&flags, &size);
d668 1
a668 1
	    } else if (ioctlPtr->byteOrder != mach_ByteOrder) {
d670 9
a678 3
		Swap_Buffer((Address)&bytesAvailable, sizeof(int),
		    mach_ByteOrder, ioctlPtr->byteOrder, "w",
		    ioctlPtr->outBuffer, &size);
@


8.16
log
@Added pipe migration debugging that is enabled with -DMIG_DEBUG
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.15 89/06/22 16:30:36 brent Exp Locker: brent $ SPRITE (Berkeley)";
d679 1
@


8.15
log
@Updated reopen procedure to use FsIOClientStatus along
with FsIOClientReopen
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.14 89/06/21 12:30:40 brent Exp Locker: brent $ SPRITE (Berkeley)";
d46 53
d158 2
d291 1
a291 2
	    panic(
		      "FsPipeClose <%d,%d> use %d, write %d\n",
d310 1
d830 1
a830 1
    panic( "FsPipeRelease called\n");
d881 1
d888 2
d894 1
d1005 1
@


8.14
log
@Fixed Reopen procedure.  It must remember to
unlock its handle.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.13 89/06/16 12:06:54 brent Exp $ SPRITE (Berkeley)";
d1086 2
d1090 2
@


8.13
log
@Updated I/O Control interface
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.12 89/06/15 09:24:30 brent Exp $ SPRITE (Berkeley)";
d1088 1
@


8.12
log
@Updated read/write to use Fs_IOParam and Fs_IOReply
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.11 89/05/30 16:10:50 jhh Exp $ SPRITE (Berkeley)";
d553 1
a553 1
FsPipeIOControl(streamPtr, command, byteOrder, inBufPtr, outBufPtr)
d555 2
a556 4
    int command;
    int byteOrder;
    Fs_Buffer *inBufPtr;
    Fs_Buffer *outBufPtr;
d560 1
d576 4
a579 1
	    if (inBufPtr->size >= sizeof(int) && byteOrder != mach_ByteOrder) {
d581 2
a582 1
		Swap_Buffer(inBufPtr->addr, inBufPtr->size, byteOrder,
a586 2
	    } else if (inBufPtr->size != sizeof(int)) {
		status = GEN_INVALID_ARG;
d588 1
a588 1
		flags = *(int *)inBufPtr->addr;
d604 5
a608 3
	    int bytesAvailable;
	    bytesAvailable = handlePtr->lastByte - handlePtr->firstByte;
	    if (outBufPtr->size >= sizeof(int) && byteOrder != mach_ByteOrder) {
d611 2
a612 1
		    mach_ByteOrder, byteOrder, "w", outBufPtr->addr, &size);
a615 2
	    } else if (outBufPtr->size != sizeof(int)) {
		status = GEN_INVALID_ARG;
d617 1
a617 1
		*(int *)outBufPtr->addr = bytesAvailable;
@


8.11
log
@Removed call to Sync_LockRegister
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.10 89/05/09 13:10:39 brent Exp Locker: jhh $ SPRITE (Berkeley)";
d289 1
a289 1
FsPipeRead(streamPtr, flags, buffer, offsetPtr, lenPtr, waitPtr)
d291 4
a294 5
    int			flags;		/* FS_USER | FS_CONSUME */
    register Address    buffer;         /* Buffer to fill with file data */
    int                 *offsetPtr;     /* In/Out byte offset */
    int                 *lenPtr;        /* In/Out byte count */
    Sync_RemoteWaiter   *waitPtr;	 /* Process wait info */
d312 1
a312 1
	*lenPtr = 0;
d325 2
a326 2
    if (toRead > *lenPtr) {
	toRead = *lenPtr;
d344 2
a345 2
	if (flags & FS_USER) {
	    if (Vm_CopyOut(toRead, handlePtr->buffer + startOffset, buffer)
d350 1
a350 1
	    bcopy(handlePtr->buffer + startOffset, buffer, toRead);
d358 2
a359 2
	if (flags & FS_USER) {
	    if (Vm_CopyOut(numBytes, handlePtr->buffer + startOffset, buffer)
d363 1
a363 1
				buffer + numBytes) != SUCCESS) {
d367 2
a368 2
	    bcopy(handlePtr->buffer + startOffset, buffer, numBytes);
	    bcopy(handlePtr->buffer, buffer + numBytes, toRead - numBytes);
d385 1
a385 2
    *lenPtr = toRead;
    *offsetPtr += toRead;
d414 1
a414 1
FsPipeWrite(streamPtr, flags, buffer, offsetPtr, lenPtr, waitPtr)
d416 3
a418 7
    int			flags;		/* FS_NON_BLOCKING checked so the
					 * correct error code is returned, plus
					 * FS_USER for copying data. */
    register Address    buffer;         /* Buffer to add to the pipe */
    int                 *offsetPtr;     /* In/Out byte offset */
    int                 *lenPtr;        /* In/Out byte count */
    Sync_RemoteWaiter   *waitPtr;	 /* Process waiting info */
d431 2
a432 1
	*lenPtr = 0;
d451 1
a451 1
	*lenPtr = 0;
d454 5
a458 3
    } else if (toWrite > *lenPtr) {
	toWrite = *lenPtr;
    } else if ((*lenPtr > toWrite) && ((flags & FS_NON_BLOCKING) == 0)) {
d463 5
d470 1
d486 2
a487 2
	if (flags & FS_USER) {
	    if (Vm_CopyIn(toWrite, buffer, handlePtr->buffer + startOffset)
d492 1
a492 1
	    bcopy(buffer, handlePtr->buffer + startOffset, toWrite);
d500 2
a501 2
	if (flags & FS_USER) {
	    if (Vm_CopyIn(numBytes, buffer, handlePtr->buffer + startOffset)
d504 1
a504 1
	    } else if (Vm_CopyIn(toWrite - numBytes, buffer + numBytes, 
d509 2
a510 2
	    bcopy(buffer, handlePtr->buffer + startOffset, numBytes);
	    bcopy(buffer + numBytes, handlePtr->buffer, toWrite - numBytes);
d526 1
a526 2
    *lenPtr = toWrite;
    *offsetPtr += toWrite;
a1077 2
    register FsClientInfo	*clientPtr;
    Boolean			found;
d1084 2
a1085 17
	/*
	 * Loop through the client list to see if we know about the client.
	 */
	found = FALSE;
	LIST_FORALL(&handlePtr->clientList, (List_Links *)clientPtr) {
	    if (clientPtr->clientID == clientID) {
		found = TRUE;
		break;
	    }
	}
	if (!found) {
	    clientPtr = mnew(FsClientInfo);
	    clientPtr->clientID = clientID;
	    List_Insert((List_Links *) clientPtr,
		    LIST_ATFRONT(&handlePtr->clientList));
	}
	clientPtr->use = reopenParamsPtr->use;
d1154 1
a1155 1
#ifdef notdef
@


8.10
log
@Nuked the FsPipeScavenge routine because there is
no good reason that pipe handles should have to
be cleaned up this way.  Furthermore, this is a suspect
in a crash caused by a duplicate remove of a pipe handle.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.9 89/02/28 08:48:19 brent Exp $ SPRITE (Berkeley)";
a132 2

    Sync_LockRegister(&pipeLock);
@


8.9
log
@Changed object-specific select routines to handle NIL waitPtr information
so they can avoid setting up wait lists.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.8 89/02/14 10:56:15 jhh Exp Locker: brent $ SPRITE (Berkeley)";
d1172 1
d1175 5
a1184 3
    } else {
	FsHandleUnlock(hdrPtr);
	return(FALSE);
d1186 3
@


8.8
log
@Update Sync_Lock initialization and registration
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.7 89/02/06 17:38:32 brent Exp Locker: jhh $ SPRITE (Berkeley)";
d664 3
a666 1
	    FsFastWaitListInsert(&handlePtr->writeWaitList, waitPtr);
d679 4
a682 2
	   *readPtr = 0;
	    FsFastWaitListInsert(&handlePtr->readWaitList, waitPtr);
@


8.7
log
@Tidied up handle initialization
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.6 89/02/01 16:40:28 brent Exp $ SPRITE (Berkeley)";
d37 1
a37 1
static	Sync_Lock	pipeLock = SYNC_LOCK_INIT_STATIC();
d133 2
@


8.6
log
@fixed a typo
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.5 89/02/01 16:35:58 brent Exp $ SPRITE (Berkeley)";
d180 1
@


8.5
log
@Fixed the pipe scavenge routine
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.4 89/01/30 14:04:20 brent Exp $ SPRITE (Berkeley)";
d1170 1
a1170 1
	fsStats.object.pipes--
@


8.4
log
@Added object stats
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.3 89/01/30 09:22:18 brent Exp Locker: brent $ SPRITE (Berkeley)";
d1170 2
d1174 1
@


8.3
log
@Changed scavenge routine to a Boolean
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.2 89/01/06 11:19:23 jhh Exp $ SPRITE (Berkeley)";
d27 1
d187 1
d261 1
@


8.2
log
@new Sync_Lock definition
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.1 88/12/21 10:17:30 brent Exp Locker: jhh $ SPRITE (Berkeley)";
d1150 1
a1150 1
 *      SUCCESS.
d1157 1
a1157 1
void
@


8.1
log
@Double migration bug fix
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 7.0 88/11/11 15:31:07 brent Exp $ SPRITE (Berkeley)";
d36 1
a36 1
static	Sync_Lock	pipeLock = {0, 0};
@


8.0
log
@Changing version numbers.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 7.0 88/11/11 15:31:07 brent Exp Locker: douglis $ SPRITE (Berkeley)";
d801 1
d818 2
a819 1
    FsStreamMigClient(migInfoPtr, dstClientID, (FsHandleHeader *)handlePtr);
d823 1
a823 1
    FsMigrateUseCounts(migInfoPtr->flags, &handlePtr->use);
d829 1
a829 1
			dstClientID, migInfoPtr->flags);
@


7.0
log
@New version for conversion to new C library
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 6.17 88/10/20 15:48:20 brent Exp Locker: brent $ SPRITE (Berkeley)";
@


6.17
log
@Changed from MigStart to Release procedure to handle new structuring
of migration.  A callback is now made by the I/O server to the source
of migration when it is ok to release references on a stream, and perhaps
the underlying I/O handle.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 6.16 88/10/16 11:11:36 brent Exp $ SPRITE (Berkeley)";
d171 1
a171 1
	    Sys_Panic(SYS_FATAL, "FsPipeHandleInit, didn't find handle\n");
d182 1
a182 1
	handlePtr->buffer = Mem_Alloc(FS_BLOCK_SIZE);
d222 1
a222 1
	Sys_Panic(SYS_WARNING, "FsPipeClose, unknown client %d\n", clientID);
d233 1
a233 1
	    Sys_Panic(SYS_FATAL,
d255 1
a255 1
	    Mem_Free(handlePtr->buffer);
d347 1
a347 1
	    Byte_Copy(toRead, handlePtr->buffer + startOffset, buffer);
d364 2
a365 2
	    Byte_Copy(numBytes, handlePtr->buffer + startOffset, buffer);
	    Byte_Copy(toRead - numBytes, handlePtr->buffer, buffer + numBytes);
d485 1
a485 1
	    Byte_Copy(toWrite, buffer, handlePtr->buffer + startOffset);
d502 2
a503 2
	    Byte_Copy(numBytes, buffer, handlePtr->buffer + startOffset);
	    Byte_Copy(toWrite - numBytes, buffer + numBytes, handlePtr->buffer);
d763 1
a763 1
    Sys_Panic(SYS_FATAL, "FsPipeRelease called\n");
d888 1
a888 1
	Sys_Panic(SYS_WARNING, "FsRmtPipeMigrate, server error <%x>\n",
d929 1
a929 1
	Sys_Panic(SYS_FATAL, "FsPipeMigEnd, no handle\n");
d982 1
a982 1
	Sys_Panic(SYS_WARNING,
d1085 1
a1085 1
	    clientPtr = Mem_New(FsClientInfo);
@


6.16
log
@Removed RecoveryComplete call that is now made by top-level recovery routine
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 6.15 88/10/14 12:15:17 brent Exp Locker: brent $ SPRITE (Berkeley)";
d744 1
a744 1
 * FsDeviceMigStart --
d746 1
a746 3
 *	Begin migration of a FS_LCL_PIPE_STREAM.  There is no extra
 *	state that needs saving, but we do release a reference to the I/O
 *	handle.
d759 2
a760 2
FsPipeMigStart(hdrPtr, flags, clientID, migFlagsPtr)
    FsHandleHeader *hdrPtr;	/* File being encapsulated */
a761 2
    int clientID;		/* Host doing the encapsulation */
    int *migFlagsPtr;		/* Migration flags we may modify */
d763 2
a764 19
    register FsPipeIOHandle *handlePtr = (FsPipeIOHandle *)hdrPtr;
    int writes;
    
    if ((flags & FS_RMT_SHARED) == 0) {
	if (flags & FS_WRITE) {
	    /*
	     * Figure out if this client is migrating away the last writer.
	     */
	    FsHandleLock(handlePtr);
	    FsIOClientStatus(&handlePtr->clientList, clientID,
			     (int *) NIL, &writes, (int *) NIL);
	    if (writes == 1) {
		*migFlagsPtr |= FS_LAST_WRITER;
	    }
	    FsHandleRelease(hdrPtr, TRUE);
	} else {
	    FsHandleRelease(hdrPtr, FALSE);
	}
    }
d817 1
a817 3
    FsStreamMigClient(&migInfoPtr->streamID, migInfoPtr->srcClientID,
		    dstClientID, (FsHandleHeader *)handlePtr,
		    &migInfoPtr->offset, &migInfoPtr->flags);
d902 5
a906 3
 *	Complete setup of a FS_LCL_PIPE_STREAM after migration.
 *	The migrate routine has done most all the work.
 *	We just grab a reference on the I/O handle for the stream.
@


6.15
log
@FsFileID FsUserID change
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.14 88/10/11 15:59:15 brent Exp $ SPRITE (Berkeley)";
a1053 1
    FsRecoveryComplete(&rmtHandlePtr->recovery, status);
@


6.14
log
@Cleaned up migration code
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.13 88/10/10 11:25:49 douglis Exp $ SPRITE (Berkeley)";
d68 1
a68 1
    FsFileID		fileID;
d127 1
a127 1
    FsFileID	*fileIDPtr;
d160 1
a160 1
    FsFileID	*fileIDPtr;	/* Pipe file ID */
d697 1
a697 1
    FsFileID			*fileIDPtr;	/* FileID of pipe */
d734 1
a734 1
    FsFileID		*fileIDPtr;	/* FileID of pipe */
d980 1
a980 1
    FsFileID	*fileIDPtr;	/* Client's I/O file ID */
@


6.13
log
@Fixed bug with looking at streamPtr->flags instead of flags param.
Keep around reference counts for shadow streams.  Got rid of 
clientdata argument to *MigStart routines, and pass in migFlagsPtr
instead so LAST_WRITER can be set.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.12 88/10/05 12:10:48 brent Exp $ SPRITE (Berkeley)";
d85 2
a86 1
    streamPtr = FsStreamNew(rpc_SpriteID, (FsHandleHeader *)handlePtr,
a87 1
    (void)FsStreamClientOpen(&streamPtr->clientList, rpc_SpriteID, FS_READ);
d97 2
a98 1
    streamPtr = FsStreamNew(rpc_SpriteID, (FsHandleHeader *)handlePtr,
a99 1
    (void)FsStreamClientOpen(&streamPtr->clientList, rpc_SpriteID, FS_WRITE);
a821 4
    register Fs_Stream			*streamPtr;
    Boolean				found;
    Boolean				cache = FALSE;
    Boolean				keepReference = FALSE;
d833 1
d838 3
a840 24
    streamPtr = FsStreamFind(&migInfoPtr->streamID,
	(FsHandleHeader *)handlePtr, migInfoPtr->flags, (char *)NIL, &found);
    if ((streamPtr->flags & FS_RMT_SHARED) == 0) {
	streamPtr->offset = migInfoPtr->offset;
    }
    if ((migInfoPtr->flags & FS_RMT_SHARED) == 0) {
	(void)FsStreamClientClose(&streamPtr->clientList,
				migInfoPtr->srcClientID);
    } else if (migInfoPtr->flags & FS_NEW_STREAM) {
	keepReference = TRUE;
    }
    if (FsStreamClientOpen(&streamPtr->clientList, dstClientID,
	    migInfoPtr->flags)) {
	streamPtr->flags |= FS_RMT_SHARED;
#ifdef notdef
	migInfoPtr->flags |= FS_RMT_SHARED;
#endif
    }
    if (keepReference) {
	FsHandleUnlock(streamPtr);
    } else {
	FsHandleRelease(streamPtr, TRUE);
    }

d844 2
a845 30
     if ((migInfoPtr->flags & FS_NEW_STREAM) &&
	 (migInfoPtr->flags & FS_RMT_SHARED)) {
	/*
	 * The stream is becoming shared across the network so
	 * we need to increment the use counts on the I/O handle
	 * to reflect the additional client stream.
	 */
	handlePtr->use.ref++;
	if ((migInfoPtr->flags & FS_WRITE) &&
	    !(migInfoPtr->flags & FS_LAST_WRITER)) {
	    handlePtr->use.write++;
	}
    } else if ((migInfoPtr->flags & (FS_NEW_STREAM|FS_RMT_SHARED)) == 0) {
	/*
	 * The stream is no longer shared, and it is not new on the
	 * target client, so we have to decrement the use counts
	 * to reflect the fact that the original client's stream is not
	 * referencing the I/O handle.
	 */
	handlePtr->use.ref--;
	if (migInfoPtr->flags & FS_WRITE) {
	    handlePtr->use.write--;
	}
    } else if (migInfoPtr->flags & FS_LAST_WRITER) {
	/*
	 * The stream is still open for reading but no longer for writing
	 * on the source client.
	 */
	handlePtr->use.write--;
    }
d847 1
a847 4
     * Move the client at the I/O handle level.  We are careful to only
     * close the srcClient if its migration state indicates it isn't
     * shared.  We are careful to only open the dstClient if it getting
     * the stream for the first time.
d849 2
a850 21
    if ((migInfoPtr->flags & FS_RMT_SHARED) == 0) {
	found = FsIOClientClose(&handlePtr->clientList,
		    migInfoPtr->srcClientID, migInfoPtr->flags, &cache);
	if (!found) {
	    Sys_Panic(SYS_WARNING,
		"FsPipeMigrate, IO Client %d not found\n",
		migInfoPtr->srcClientID);
	}
    } else if (migInfoPtr->flags & FS_LAST_WRITER) {
	found = FsIOClientRemoveWriter(&handlePtr->clientList,
		    migInfoPtr->srcClientID);
	if (!found) {
	    Sys_Panic(SYS_WARNING,
		"FsPipeMigrate, IO Client %d not found\n",
		migInfoPtr->srcClientID);
	}
    }
    if (migInfoPtr->flags & FS_NEW_STREAM) {
	(void)FsIOClientOpen(&handlePtr->clientList, dstClientID,
		migInfoPtr->flags, FALSE);
    }
d854 2
a855 2
    *flagsPtr = streamPtr->flags;
    *offsetPtr = streamPtr->offset;
@


6.12
log
@Added domainTypePtr parameter to the clientVerify routine
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.11 88/09/28 13:32:14 brent Exp $ SPRITE (Berkeley)";
d22 1
d287 1
a287 1
    int			flags;		/* IGNORED */
d341 1
a341 1
	if (streamPtr->flags & FS_USER) {
d355 1
a355 1
	if (streamPtr->flags & FS_USER) {
d415 2
a416 1
					 * correct error code is returned. */
d479 1
a479 1
	if (streamPtr->flags & FS_USER) {
d493 1
a493 1
	if (streamPtr->flags & FS_USER) {
d761 1
a761 1
FsPipeMigStart(hdrPtr, flags, clientID, data)
d765 1
a765 1
    ClientData data;		/* Buffer we fill in */
d767 3
d771 14
a784 1
	FsHandleRelease(hdrPtr, FALSE);
d825 1
d849 2
d855 1
d857 1
d859 5
a863 1
    FsHandleRelease(streamPtr, TRUE);
d876 2
a877 1
	if (migInfoPtr->flags & FS_WRITE) {
d891 6
d907 8
@


6.11
log
@Added include for extern definitions
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.10 88/09/28 08:38:01 brent Exp $ SPRITE (Berkeley)";
d1011 1
a1011 1
FsRmtPipeVerify(fileIDPtr, clientID)
d1014 1
d1038 3
@


6.10
log
@Changed IOControl interface to take Fs_Buffer's instead of
separate size/address parameters.  Need to pass user space
flag along to get pseudo-devices right after migration!
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.9 88/09/23 13:39:05 brent Exp $ SPRITE (Berkeley)";
d30 1
@


6.9
log
@Update interface to recovery routines.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.8 88/09/22 09:04:10 brent Exp $ SPRITE (Berkeley)";
d544 1
a544 2
FsPipeIOControl(streamPtr, command, byteOrder, inBufSize, inBuffer, outBufSize,
	outBuffer)
d548 2
a549 4
    int inBufSize;
    Address inBuffer;
    int outBufSize;
    Address outBuffer;
d568 1
a568 1
	    if (byteOrder != mach_ByteOrder) {
d570 2
a571 2
		Swap_Buffer(inBuffer, inBufSize, byteOrder, mach_ByteOrder, "w",
			    (Address)&flags, &size);
d575 1
a575 1
	    } else if (inBufSize != sizeof(int)) {
d578 1
a578 1
		flags = *(int *)inBuffer;
d596 1
a596 1
	    if (byteOrder != mach_ByteOrder) {
d599 1
a599 1
		    mach_ByteOrder, byteOrder, "w", outBuffer, &size);
d603 1
a603 1
	    } else if (outBufSize != sizeof(int)) {
d606 1
a606 1
		*(int *)outBuffer = bytesAvailable;
@


6.8
log
@y
y
Changed I/O Control interface to take streamPtr instead of ioHandlePtr
so we can implement lock crash recovery based on stream ownership of locks.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.7 88/09/16 16:51:24 brent Exp $ SPRITE (Berkeley)";
d1084 1
a1084 1
    FsRecoveryWakeup(&rmtHandlePtr->recovery, status);
@


6.7
log
@Added procID to close procedure to support lock cleanup
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.6 88/09/13 11:27:26 brent Exp $ SPRITE (Berkeley)";
d544 1
a544 1
FsPipeIOControl(hdrPtr, command, byteOrder, inBufSize, inBuffer, outBufSize,
d546 1
a546 1
    FsHandleHeader *hdrPtr;
d554 2
a555 1
    register FsPipeIOHandle *handlePtr = (FsPipeIOHandle *)hdrPtr;
@


6.6
log
@Added byte swapping code to IOControls
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.5 88/09/08 17:30:30 brent Exp $ SPRITE (Berkeley)";
d207 1
a207 1
FsPipeClose(streamPtr, clientID, flags, dataSize, closeData)
d209 2
a210 1
    int			clientID;	/* Client closing */
@


6.5
log
@Fixed recovery wakeup call so that it is done after errors.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.4 88/09/07 16:52:42 brent Exp $ SPRITE (Berkeley)";
d543 1
a543 1
FsPipeIOControl(hdrPtr, command, inBufSize, inBuffer, outBufSize,
d547 1
d554 1
d562 1
d567 19
a585 2
	    register int *flagsPtr = (int *)inBuffer;
	    if ((*flagsPtr & IOC_APPEND) == 0) {
a589 8
	case IOC_CLEAR_BITS: {
	    register int *flagsPtr = (int *)inBuffer;
	    if (*flagsPtr & IOC_APPEND) {
		return(GEN_INVALID_ARG);
	    } else {
		return(SUCCESS);
	    }
	}
d595 1
a595 1
	    register int bytesAvailable;
d597 13
a609 2
	    *(int *)outBuffer = bytesAvailable;
	    return(SUCCESS);
@


6.4
log
@Moved name from stream to I/O handle.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.3 88/08/31 12:05:18 brent Exp $ SPRITE (Berkeley)";
d1054 1
a1054 1
     * Contact the server to do the reopen.
d1059 1
a1059 7

    if (status == SUCCESS) {
	/*
	 * Notify waiters that recovery is complete.
	 */
	FsRecoveryWakeup(&rmtHandlePtr->recovery);
    }
@


6.3
log
@Removed lint.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.2 88/08/26 11:10:34 brent Exp $ SPRITE (Berkeley)";
d84 1
a84 1
			    FS_READ | FS_CONSUME | FS_USER);
d96 1
a96 1
			FS_WRITE | FS_APPEND | FS_USER);
d165 1
a165 1
    found = FsHandleInstall(fileIDPtr, sizeof(FsPipeIOHandle), &hdrPtr);
d800 1
a800 1
		(FsHandleHeader *)handlePtr, migInfoPtr->flags, &found);
@


6.2
log
@Fixed close routine to correctly determine when reader left.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.1 88/08/12 12:31:00 brent Exp $ SPRITE (Berkeley)";
d77 2
a78 2
    FsIOClientOpen(&handlePtr->clientList, rpc_SpriteID, FS_READ, FALSE);
    FsIOClientOpen(&handlePtr->clientList, rpc_SpriteID, FS_WRITE, FALSE);
d85 1
a85 1
    FsStreamClientOpen(&streamPtr->clientList, rpc_SpriteID, FS_READ);
d97 1
a97 1
    FsStreamClientOpen(&streamPtr->clientList, rpc_SpriteID, FS_WRITE);
@


6.1
log
@Added flags argument to setIOAttr routine that specifies
what attributes to update.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.0 88/08/11 12:15:43 brent Stable $ SPRITE (Berkeley)";
d235 1
a235 1
	if (flags & FS_WRITE && handlePtr->use.write == 0) {
d241 2
a242 1
	} else if (handlePtr->use.ref == 0) {
@


6.0
log
@Changing version numbers.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 1.6 88/08/05 13:57:59 brent Exp $ SPRITE (Berkeley)";
d707 1
a707 1
FsPipeSetIOAttr(fileIDPtr, attrPtr)
d710 1
@


1.6
log
@removed lint.
Fixed non-blocking writes to pipes so they return SUCCESS if
they were able to get any bytes written.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 1.5 88/08/04 15:05:05 mlgray Exp $ SPRITE (Berkeley)";
@


1.5
log
@merging changes from fs into fs.new
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 1.5 88/07/22 12:42:30 douglis Exp $ SPRITE (Berkeley)";
d279 1
d410 2
a411 1
    int			flags;		/* IGNORED */
d417 2
a418 2
    ReturnStatus 	status = SUCCESS;
    register FsPipeIOHandle *handlePtr =
d420 4
a423 4
    int 		startOffset;
    int 		toWrite;
    int			startByte;
    int			endByte;
d452 1
a452 1
    } else if (*lenPtr > toWrite) {
d455 2
a456 1
	 * data that we can.
d708 2
a709 2
    FsFileID			*fileIDPtr;	/* FileID of pipe */
    register Fs_Attributes	*attrPtr;	/* Attributes to update */
@


1.4
log
@Plugged core leak
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 1.3 88/06/06 09:36:48 brent Exp $ SPRITE (Berkeley)";
d171 6
d222 4
d227 9
d241 1
a241 1
	} else {
d810 26
@


1.3
log
@Changed close interface to pass back the streamID so the server's
shadow streams can be closed too.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 1.2 88/04/19 10:34:28 brent Exp $ SPRITE (Berkeley)";
d233 2
d1145 2
@


1.2
log
@Changed interface to FsIOClient{Open,Close} to include cached property.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 1.1 88/04/11 10:09:00 brent Exp $ SPRITE (Berkeley)";
d201 2
a202 2
FsPipeClose(hdrPtr, clientID, flags, dataSize, closeData)
    FsHandleHeader	*hdrPtr;	/* Handle to close */
d208 2
a209 1
    register FsPipeIOHandle *handlePtr = (FsPipeIOHandle *)hdrPtr;
@


1.1
log
@Initial revision
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 1.1 88/04/04 10:38:14 brent Exp $ SPRITE (Berkeley)";
d77 2
a78 2
    (void)FsIOClientOpen(&handlePtr->clientList, rpc_SpriteID, FS_READ);
    (void)FsIOClientOpen(&handlePtr->clientList, rpc_SpriteID, FS_WRITE);
d209 1
a209 1
    Boolean notUsed;
d211 1
a211 1
    if (!FsIOClientClose(&handlePtr->clientList, clientID, flags, &notUsed)) {
d756 1
a756 1
    Boolean				wasCached;	/* IGNORED */
d796 1
a796 1
		    migInfoPtr->srcClientID, migInfoPtr->flags, &wasCached);
d805 1
a805 1
		migInfoPtr->flags);
@
