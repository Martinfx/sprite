head     9.7;
branch   ;
access   ;
symbols  ds3100:9.7 sun3:9.7 sun4nw:9.6 symm:9.6 spur:9.6 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.7
date     92.04.14.16.57.48;  author jhh;  state Exp;
branches ;
next     9.6;

9.6
date     91.09.10.18.40.50;  author rab;  state Exp;
branches ;
next     9.5;

9.5
date     90.11.29.15.46.23;  author shirriff;  state Exp;
branches ;
next     9.4;

9.4
date     90.10.19.15.47.19;  author jhh;  state Exp;
branches ;
next     9.3;

9.3
date     89.11.16.15.16.29;  author rab;  state Exp;
branches ;
next     9.2;

9.2
date     89.11.05.12.26.17;  author brent;  state Exp;
branches ;
next     9.1;

9.1
date     89.10.31.08.56.16;  author mendel;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.13.10;  author douglis;  state Stable;
branches ;
next     8.6;

8.6
date     89.06.08.09.09.41;  author mendel;  state Exp;
branches ;
next     8.5;

8.5
date     89.05.24.07.57.57;  author rab;  state Exp;
branches ;
next     8.4;

8.4
date     89.05.23.09.43.53;  author mendel;  state Exp;
branches ;
next     8.3;

8.3
date     89.03.15.17.34.19;  author mendel;  state Exp;
branches ;
next     8.2;

8.2
date     89.01.31.14.01.41;  author mendel;  state Exp;
branches ;
next     8.1;

8.1
date     88.12.12.14.51.21;  author nelson;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.27.12;  author douglis;  state Stable;
branches ;
next     6.3;

6.3
date     88.11.07.14.43.34;  author mlgray;  state Exp;
branches ;
next     6.2;

6.2
date     88.10.13.13.26.23;  author mendel;  state Exp;
branches ;
next     6.1;

6.1
date     88.09.06.09.06.38;  author mendel;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.20.25;  author brent;  state Stable;
branches ;
next     5.8;

5.8
date     88.06.27.10.45.58;  author mendel;  state Exp;
branches ;
next     5.7;

5.7
date     88.06.21.10.51.55;  author mendel;  state Exp;
branches ;
next     5.6;

5.6
date     88.06.20.09.49.54;  author brent;  state Exp;
branches ;
next     5.5;

5.5
date     88.05.05.17.58.28;  author brent;  state Exp;
branches ;
next     5.4;

5.4
date     87.12.12.16.37.55;  author nelson;  state Exp;
branches ;
next     5.3;

5.3
date     87.09.17.13.03.14;  author nelson;  state Exp;
branches ;
next     5.2;

5.2
date     87.09.17.12.02.47;  author nelson;  state Exp;
branches ;
next     5.1;

5.1
date     87.09.16.11.31.39;  author nelson;  state Exp;
branches ;
next     5.0;

5.0
date     87.08.11.10.46.13;  author sprite;  state Exp;
branches ;
next     ;


desc
@@


9.7
log
@Uses new Net_Address definition.
@
text
@/* 
 * netIE.c --
 *
 *	The main routines for the device driver for the Intel 82586 Ethernet 
 *	Controller.
 *
 *      This chip has several pecularities that have to be compensated for
 *      when using it.  First of all no element of the scatter-gather
 *      array which is passed into the output routine can be below a
 *      minimum size.  The minimum size is defined in the file netIEXmit.c
 *      and is called MIN_XMIT_BUFFER_SIZE.  Secondly none of the
 *      scatter-gather elements can begin on an odd boundary.  If they do,
 *      the chip drops the low order bit and sends one more byte than was
 *      specified.  There are warnings printed in each of these cases.
 *
 * TODO: Watch dogs to make sure that the chip does not get stuck.  Rumor has
 *	 it that because of bugs in the chip it can get stuck at any time for
 *	 no particular reason.
 *
 * Copyright 1985, 1988 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 *
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/net/sun3.md/netIE.c,v 9.6 91/09/10 18:40:50 rab Exp $ SPRITE (Berkeley)";
#endif

#include <sprite.h>
#include <sys.h>
#include <list.h>
#include <netIEInt.h>
#include <vm.h>
#include <vmMach.h>
#include <mach.h>
#include <machMon.h>
#include <assert.h>

static Net_EtherAddress BROADCAST_ADDR = {0xab,0x00,0x00,0x01,0x00,0x00};

/*
 *----------------------------------------------------------------------
 *
 * NetIEInit --
 *
 *	Initialize the Intel Ethernet chip.
 *
 * Results:
 *	SUCCESS if the Intel controller was found and initialized,
 *	FAILURE otherwise.
 *
 * Side effects:
 *	Initializes the chip.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
NetIEInit(interPtr)
    Net_Interface	*interPtr; 	/* Network interface. */
{
    Address 	ctrlAddr;	/* Kernel virtual address of controller. */
    int 	i;
    List_Links	*itemPtr;
    NetIEState	*statePtr;
    ReturnStatus 	status;

    DISABLE_INTR();

    /*
     * Check that our structures are the correct size.  Some of the sizes
     * are different on the sun4 due to padding and alignment, but that
     * has been taken into account.
     */
#ifdef sun4
    assert(sizeof(NetIESysConfPtr) == 12);
    assert(sizeof(NetIERecvFrameDesc) == 28);
    assert(sizeof(NetIERecvBufDesc) == 20);
#else
    assert(sizeof(NetIESysConfPtr) == 10);
    assert(sizeof(NetIERecvFrameDesc) == 26);
    assert(sizeof(NetIERecvBufDesc) == 18);
#endif
    assert(sizeof(NetIEIntSysConfPtr) == 8);
    assert(sizeof(NetIESCBStatus) == 2);
    assert(sizeof(NetIESCBCommand) == 2);
    assert(sizeof(NetIESCB) == 16);
    assert(sizeof(NetIECommandBlock) == 6);
    assert(sizeof(NetIENOPCB) == 6);
    assert(sizeof(NetIEIASetupCB) == 12);
    assert(sizeof(NetIEConfigureCB) == 18);
    assert(sizeof(NetIETransmitCB) == 16);
    assert(sizeof(NetIETransmitBufDesc) == 8);
    assert(sizeof(NetIEControlRegister) == 1);


    ctrlAddr = interPtr->ctrlAddr;
    /*
     * If the address is physical (not in kernel's virtual address space)
     * then we have to map it in.
     */
    if (interPtr->virtual == FALSE) {
	ctrlAddr = (Address) VmMach_MapInDevice(ctrlAddr, 1);
    }
    statePtr = (NetIEState *) malloc (sizeof(NetIEState));
    bzero((char *) statePtr, sizeof(NetIEState));

    statePtr->running = FALSE;

    /*
     * The onboard control register is at a pre-defined kernel virtual
     * address.  The virtual mapping is set up by the sun PROM monitor
     * and passed to us from the netInterface table.
     */

    statePtr->controlReg = 
	(volatile NetIEControlRegister *) ctrlAddr;

     {
	/*
	 * Poke the controller by resetting it.
	 */
	char zero = 0;
	ReturnStatus status;

	status = Mach_Probe(sizeof(char), &zero,
	    (char *)statePtr->controlReg);
	if (status != SUCCESS) {
	    /*
	     * Got a bus error.
	     */
	    free((char *) statePtr);
	    ENABLE_INTR();
	    return(FAILURE);
	}
    }
    Mach_SetHandler(interPtr->vector, Net_Intr, (ClientData) interPtr);
    /*
     * Initialize the transmission list.  
     */

    statePtr->xmitList = &statePtr->xmitListHdr;
    List_Init(statePtr->xmitList);

    statePtr->xmitFreeList = &statePtr->xmitFreeListHdr;
    List_Init(statePtr->xmitFreeList);

    netIEXmitFiller = (char *)VmMach_NetMemAlloc(NET_ETHER_MIN_BYTES);
    statePtr->netIEXmitTempBuffer = 
	    (char *)VmMach_NetMemAlloc(NET_ETHER_MAX_BYTES + 2);

    for (i = 0; i < NET_IE_NUM_XMIT_ELEMENTS; i++) {
	itemPtr = (List_Links *) VmMach_NetMemAlloc(sizeof(NetXmitElement)), 
	List_InitElement(itemPtr);
	List_Insert(itemPtr, LIST_ATREAR(statePtr->xmitFreeList));
    }

    /*
     * Get ethernet address out of the rom.  It is stored in a normal order
     * even though the chip is wired backwards because fortunately the chip
     * stores the ethernet address backwards from how we store it.  Therefore
     * two backwards makes one forwards, right?
     */

    Mach_GetEtherAddress(&statePtr->etherAddress);
    printf("%s Ethernet address %x:%x:%x:%x:%x:%x\n", 
	      interPtr->name,
	      statePtr->etherAddress.byte1 & 0xff,
	      statePtr->etherAddress.byte2 & 0xff,
	      statePtr->etherAddress.byte3 & 0xff,
	      statePtr->etherAddress.byte4 & 0xff,
	      statePtr->etherAddress.byte5 & 0xff,
	      statePtr->etherAddress.byte6 & 0xff);
    /*
     * Allocate space for the System Configuration Pointer.
     */

    VmMach_MapIntelPage((Address) (NET_IE_SYS_CONF_PTR_ADDR));
    statePtr->sysConfPtr = (NetIESysConfPtr *) NET_IE_SYS_CONF_PTR_ADDR;

    /*
     * Allocate space for all of the receive buffers. The buffers are 
     * allocated on an odd short word boundry so that packet data (after
     * the ethernet header) will start on a long word boundry. This 
     * eliminates unaligned word fetches from the RPC module which would
     * cause alignment traps on SPARC processors such as the sun4.
     */ 

#define	ALIGNMENT_PADDING	(sizeof(Net_EtherHdr)&0x3)
    for (i = 0; i < NET_IE_NUM_RECV_BUFFERS; i++) {
	statePtr->netIERecvBuffers[i] = 
		VmMach_NetMemAlloc(NET_IE_RECV_BUFFER_SIZE + ALIGNMENT_PADDING)
		    + ALIGNMENT_PADDING;
    }
#undef ALIGNMENT_PADDING

    interPtr->init	= NetIEInit;
    interPtr->output 	= NetIEOutput;
    interPtr->intr	= NetIEIntr;
    interPtr->ioctl	= NetIEIOControl;
    interPtr->reset 	= NetIERestart;
    interPtr->getStats	= NetIEGetStats;
    interPtr->netType	= NET_NETWORK_ETHER;
    interPtr->maxBytes	= NET_ETHER_MAX_BYTES - sizeof(Net_EtherHdr);
    interPtr->minBytes	= 0;
    interPtr->interfaceData = (ClientData) statePtr;
    status = Net_SetAddress(NET_ADDRESS_ETHER, 
		(Address) &statePtr->etherAddress,
		&interPtr->netAddress[NET_PROTO_RAW]);
    if (status != SUCCESS) {
	panic("NetIEInit: Net_SetAddress failed\n");
    }
    interPtr->broadcastAddress = netEtherBroadcastAddress;
    interPtr->flags |= NET_IFLAGS_BROADCAST;
    statePtr->interPtr = interPtr;

    /*
     * Reset the world.
     */

    NetIEReset(interPtr);

    /*
     * Unmap the extra page.
     */

    VmMach_UnmapIntelPage((Address) (NET_IE_SYS_CONF_PTR_ADDR));

    /*
     * Now we are running.
     */

    statePtr->running 	= TRUE;
    ENABLE_INTR();
    return (SUCCESS);
}


/*
 *----------------------------------------------------------------------
 *
 * NetIEDefaultConfig --
 *
 *	Set up the default configuration for the intel chip as specified
 *	in the intel manual.  The only difference from the Intel manual
 *	is the fifo length.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The global command block is modified.
 *
 *----------------------------------------------------------------------
 */

void
NetIEDefaultConfig(statePtr)
    NetIEState		*statePtr;
{
    NetIEConfigureCB	*confCBPtr;

    confCBPtr = (NetIEConfigureCB *) statePtr->cmdBlockPtr;
    bzero((Address) confCBPtr, sizeof(NetIEConfigureCB));
    NetBfShortSet(confCBPtr->cmdBlock.bits, CmdNumber, NET_IE_CONFIG);
    NetBfShortSet(confCBPtr->bits, ByteCount, 12);
    NetBfShortSet(confCBPtr->bits, FifoLimit, 12);
    NetBfShortSet(confCBPtr->bits, Preamble, 2);
    NetBfShortSet(confCBPtr->bits, AddrLen, 6);
    NetBfShortSet(confCBPtr->bits, AtLoc, 0);
    NetBfShortSet(confCBPtr->bits, InterFrameSpace, 96);
    NetBfShortSet(confCBPtr->bits, SlotTimeHigh , 512 >> 8);
    NetBfShortSet(confCBPtr->bits, MinFrameLength, 64);
    NetBfShortSet(confCBPtr->bits, NumRetries, 15);

/*
    confCBPtr->intLoopback = 1;
*/

    NetIEExecCommand((NetIECommandBlock *) confCBPtr, statePtr);
    return;
}


/*
 *----------------------------------------------------------------------
 *
 * NetIEReset --
 *
 *	Reset the interface.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All of the pointers in the interface structure are initialized.
 *
 *----------------------------------------------------------------------
 */

void
NetIEReset(interPtr)
    Net_Interface	*interPtr; 	/* Interface to reset. */
{
    NetIEIASetupCB	        *addressCommandPtr;
    NetIEMASetupCB	        *addressMACommandPtr;
    volatile NetIECommandBlock	*diagCmdPtr;
    NetIEState			*statePtr;

    /*
     * Nil out all pointers.
     */
    statePtr = (NetIEState *) interPtr->interfaceData;
    statePtr->intSysConfPtr = (NetIEIntSysConfPtr *) NIL;
    statePtr->scbPtr = (NetIESCB *) NIL;
    statePtr->recvFrDscHeadPtr = (NetIERecvFrameDesc *) NIL;
    statePtr->recvFrDscTailPtr = (NetIERecvFrameDesc *) NIL;
    statePtr->recvBufDscHeadPtr = (NetIERecvBufDesc *) NIL;
    statePtr->recvBufDscTailPtr = (NetIERecvBufDesc *) NIL;

    /* 
     * Reset the chip.
     */

    NET_IE_CHIP_RESET(statePtr);

    /*
     * Initialize memory.
     */

    NetIEMemInit(statePtr);

    /*
     * Allocate the system intermediate configuration pointer and the 
     * system control block.
     */

    statePtr->intSysConfPtr = (NetIEIntSysConfPtr *) NetIEMemAlloc(statePtr);
    if (statePtr->intSysConfPtr == (NetIEIntSysConfPtr *) NIL) {
	panic("Intel: No memory for the scp.\n");
    }

    statePtr->scbPtr = (NetIESCB *) NetIEMemAlloc(statePtr);
    if (statePtr->scbPtr == (NetIESCB *) NIL) {
	panic("Intel: No memory for the scb.\n");
    }


    while (TRUE) {
	/*
	 * Initialize the system configuration pointer.
	 */

	bzero((Address) statePtr->sysConfPtr, sizeof(NetIESysConfPtr));
	statePtr->sysConfPtr->intSysConfPtr = 
			NetIEAddrFromSUNAddr((int) statePtr->intSysConfPtr);

	/* 
	 * Initialize the intermediate system configuration pointer.
	 */

	bzero((Address) statePtr->intSysConfPtr, sizeof(NetIEIntSysConfPtr));
	statePtr->intSysConfPtr->busy = 1;
	statePtr->intSysConfPtr->base = 
			    NetIEAddrFromSUNAddr((int) statePtr->memBase);
	statePtr->intSysConfPtr->scbOffset = 
			    NetIEOffsetFromSUNAddr((int) statePtr->scbPtr,
				    statePtr);

	/*
	 * Initialize the system control block.
	 */

	bzero((Address) statePtr->scbPtr, sizeof(NetIESCB));

	/*
	 * Turn off the reset bit.
	 */

	NetBfByteSet(statePtr->controlReg, NoReset, 1);
	MACH_DELAY(200);

	/* 
	 * Get the attention of the chip so that it will initialize itself.
	 */

	NET_IE_CHANNEL_ATTENTION(statePtr);

	/* 
	 * Ensure that that the chip gets the intermediate initialization
	 * stuff and that the scb is updated.
	 */
	
	NET_IE_DELAY(!statePtr->intSysConfPtr->busy);
	NET_IE_DELAY(NetBfShortTest(statePtr->scbPtr->statusWord, 
	    CmdUnitNotActive, 1));

	/*
	 * Wait for an interrupt.
	 */

	NET_IE_DELAY(NetBfByteTest(statePtr->controlReg, IntrPending, 1));

	/*
	 * Make sure that the chip was initialized properly.
	 */

	if (statePtr->intSysConfPtr->busy || 
	    NetBfShortTest(statePtr->scbPtr->statusWord, CmdUnitNotActive, 0) ||
	    NetBfByteTest(statePtr->controlReg, IntrPending, 0)) {

	    printf("Warning: Could not initialize Intel chip.\n");
	}
	if (NetBfShortTest(statePtr->scbPtr->statusWord, CmdUnitStatus, 
		NET_IE_CUS_IDLE)) {
	    break;
	}

	printf("Warning: Intel cus not idle after reset\n");
	NET_IE_CHIP_RESET(statePtr);
    }

    /*
     * Allocate a single command block to be used by all commands.
     */

    statePtr->cmdBlockPtr = (NetIECommandBlock *) NetIEMemAlloc(statePtr);
    if (statePtr->cmdBlockPtr == (NetIECommandBlock *) NIL) {
	panic("NetIE: No memory for the command block.\n");
    }
    statePtr->scbPtr->cmdListOffset =
			NetIEOffsetFromSUNAddr((int) statePtr->cmdBlockPtr,
				statePtr);

    /*
     * Do a diagnose command on the interface.
     */

    diagCmdPtr = statePtr->cmdBlockPtr;
    bzero((Address) diagCmdPtr, sizeof(*diagCmdPtr));
    NetBfShortSet(diagCmdPtr->bits, CmdNumber,  NET_IE_DIAGNOSE);
    NetIEExecCommand(diagCmdPtr, statePtr);
    if (NetBfShortTest(diagCmdPtr->bits, CmdOK, 0)) {
	panic("Intel failed diagnostics.\n");
    }

    /*
     * Let the interface know its address.
     */

    addressCommandPtr = (NetIEIASetupCB *) statePtr->cmdBlockPtr;
    bzero((Address) addressCommandPtr, sizeof(NetIEIASetupCB));
    NetBfShortSet(addressCommandPtr->cmdBlock.bits, CmdNumber, NET_IE_IA_SETUP);
    addressCommandPtr->etherAddress = statePtr->etherAddress;
    NetIEExecCommand((NetIECommandBlock *) addressCommandPtr, statePtr);

    /*
     * Set the boot multicast address.
     */

    addressMACommandPtr = (NetIEMASetupCB *) statePtr->cmdBlockPtr;
    bzero((Address) addressCommandPtr, sizeof(NetIEMASetupCB));
    NetBfShortSet(addressCommandPtr->cmdBlock.bits, CmdNumber, NET_IE_MC_SETUP);
    addressMACommandPtr->count = 1;
    addressMACommandPtr->etherAddress = BROADCAST_ADDR;
    NetIEExecCommand((NetIECommandBlock *) addressMACommandPtr, statePtr);

    /*
     * Set up the default configuration values.
     */

    NetIEDefaultConfig(statePtr);

    /*
     * Set up the receive queues.
     */

    NetIERecvUnitInit(statePtr);

    /*
     * Enable interrupts and get out of loop back mode.  Make sure that don't
     * get out of loop back mode before because the Intel is supposed to
     * be unpredictable until we initialize things.
     */

    NetBfByteSet(statePtr->controlReg, IntrEnable, 1);
    NetBfByteSet(statePtr->controlReg, NoLoopback, 1);

    /*
     * Initialize the transmit queues and start transmitting if anything ready
     * to tranmit.
     */

    NetIEXmitInit(statePtr);
    interPtr->flags |= NET_IFLAGS_RUNNING;
    return;
}


/*
 *----------------------------------------------------------------------
 *
 * NetIERestart --
 *
 *	Reinitialize the Intel Ethernet chip.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
NetIERestart(interPtr)
    Net_Interface	*interPtr; 	/* Interface to restart. */
{
    NetIEState	*statePtr = (NetIEState *) interPtr->interfaceData;

    DISABLE_INTR();

    /*
     * Drop the current packet so the transmitting process doesn't hang.
     */
    NetIEXmitDrop(statePtr);

    /*
     * Allocate space for the System Configuration Pointer.
     */
    VmMach_MapIntelPage((Address) (NET_IE_SYS_CONF_PTR_ADDR));

    /*
     * Reset the world.
     */
    NetIEReset(interPtr);

    /*
     * Unmap the extra page.
     */
    VmMach_UnmapIntelPage((Address) (NET_IE_SYS_CONF_PTR_ADDR));

    ENABLE_INTR();
    return;
}


/*
 *----------------------------------------------------------------------
 *
 * NetIEIntr --
 *
 *	Process an interrupt from the Intel chip.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
NetIEIntr(interPtr, polling)
    Net_Interface	*interPtr;	/* Interface to process. */
    Boolean		polling;	/* TRUE if are being polled instead of
					 * processing an interrupt. */
{
    register	NetIEState	*statePtr;
    volatile register NetIESCB	*scbPtr;
    register	int		status;

    statePtr = (NetIEState *) interPtr->interfaceData;
    scbPtr = statePtr->scbPtr;
    /*
     * If we got a bus error then panic.
     */
    if (NetBfByteTest(statePtr->controlReg, BusError, 1)) {
	printf("Warning: Intel: Bus error on chip.\n");
	NetIERestart(interPtr);
	return;
    }

    /*
     * If interrupts aren't enabled or there is no interrupt pending, then
     * what are we doing here?
     */
    if (!(NetBfByteTest(statePtr->controlReg, IntrEnable, 1) && 
	NetBfByteTest(statePtr->controlReg, IntrPending, 1))) {
	/*
	 * I'm not sure why this is commented out. That's the way I found
	 * it.  JHH
	 */
#if 0
	if (!polling) {
	    printf("Intel: Spurious interrupt <%x>\n", 
		(unsigned int) (*((unsigned char *) statePtr->controlReg)));
	}
	return;
#endif 
    } 

    status = NET_IE_CHECK_STATUS(scbPtr->statusWord);
    if (status == 0) {
	if (!polling) {
	    printf("Intel: Spurious interrupt (2)\n");
	}
	return;
    }

    /*
     * Go ahead and ack the events that got us here.
     */
    NET_IE_CHECK_SCB_CMD_ACCEPT(scbPtr);
    NET_IE_ACK(scbPtr->cmdWord[0], status);
    NET_IE_CHANNEL_ATTENTION(statePtr);

    /*
     * If we got a packet, then process it.
     */
    if (NET_IE_RECEIVED(status)) {
	NetIERecvProcess(FALSE, statePtr);
    }

    /*
     * If a transmit command completed then process it.
     */
    if (NET_IE_TRANSMITTED(status)) {
	NetIEXmitDone(statePtr);
    }
    return;
}



/*
 *----------------------------------------------------------------------
 *
 * NetIEGetStats --
 *
 *	Return the statistics for the interface.
 *
 * Results:
 *	A pointer to the statistics structure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
NetIEGetStats(interPtr, statPtr)
    Net_Interface	*interPtr;		/* Current interface. */
    Net_Stats		*statPtr;		/* Statistics to return. */
{
    NetIEState	*statePtr;
    statePtr = (NetIEState *) interPtr->interfaceData;
    DISABLE_INTR();
    statPtr->ether = statePtr->stats;
    ENABLE_INTR();
    return SUCCESS;
}

/*
 *----------------------------------------------------------------------
 *
 * NetIEIOControl --
 *
 *	Perform ioctls for the adapter.  Right now we don't support any.
 *
 * Results:
 *	DEV_INVALID_ARG
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
ReturnStatus
NetIEIOControl(interPtr, ioctlPtr, replyPtr)
    Net_Interface *interPtr;	/* Interface on which to perform ioctl. */
    Fs_IOCParam *ioctlPtr;	/* Standard I/O Control parameter block */
    Fs_IOReply *replyPtr;	/* Size of outBuffer and returned signal */
{
    return DEV_INVALID_ARG;
}

/*
 *----------------------------------------------------------------------
 *
 * NetIEStatePrint --
 *
 *	Prints out the contents of a NetIEState..
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Stuff is printed.
 *
 *----------------------------------------------------------------------
 */

void
NetIEStatePrint(statePtr)
    NetIEState		*statePtr;
{
    printf("statePtr = 0x%x\n", statePtr);
    printf("membase = 0x%x\n", statePtr->memBase);
    printf("sysConfPtr = 0x%x\n", statePtr->sysConfPtr);
    printf("intSysConfPtr = 0x%x\n", statePtr->intSysConfPtr);
    printf("scbPtr = 0x%x\n", statePtr->scbPtr);
    printf("cmdBlockPtr = 0x%x\n", statePtr->cmdBlockPtr);
    printf("recvFrDscHeadPtr = 0x%x\n", statePtr->recvFrDscHeadPtr);
    printf("recvFrDscTailPtr = 0x%x\n", statePtr->recvFrDscTailPtr);
    printf("recvBufDscHeadPtr = 0x%x\n", statePtr->recvBufDscHeadPtr);
    printf("recvBufDscTailPtr = 0x%x\n", statePtr->recvBufDscTailPtr);
    printf("xmitList = 0x%x\n", statePtr->xmitList);
    printf("xmitFreeList = 0x%x\n", statePtr->xmitFreeList);
    printf("xmitCBPtr = 0x%x\n", statePtr->xmitCBPtr);
    printf("transmitting = %d\n", statePtr->transmitting);
    printf("running = %d\n", statePtr->running);
    printf("controlReg = 0x%x\n", statePtr->controlReg);
    printf("netIEXmitTempBuffer = 0x%x\n", statePtr->netIEXmitTempBuffer);
    printf("xmitBufAddr = 0x%x\n", statePtr->xmitBufAddr);
    printf("curScatGathPtr = 0x%x\n", statePtr->curScatGathPtr);
    printf("interPtr = 0x%x\n", statePtr->interPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * NetIEIntSysConfPtrPrint --
 *
 *	Prints the contents of a NetIEIntSysConfPtr.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Stuff is printed
 *
 *----------------------------------------------------------------------
 */

void
NetIEIntSysConfPtrPrint(confPtr) 
    volatile NetIEIntSysConfPtr	*confPtr;
{
    printf("busy = %d\n", (int) confPtr->busy);
    printf("scbOffset = 0x%x\n",  confPtr->scbOffset);
    printf("base = 0x%x\n", confPtr->base); 
}

/*
 *----------------------------------------------------------------------
 *
 * NetIESCBPrint --
 *
 *	description.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
NetIESCBPrint(scbPtr)
    volatile NetIESCB	*scbPtr;
{
    printf("status = 0x%x\n", * ((unsigned short *) scbPtr->statusWord));
    printf("cmd = 0x%x\n", * ((unsigned short *) scbPtr->cmdWord));
    printf("cmdListOffset = 0x%x\n",  scbPtr->cmdListOffset);
    printf("recvFrameAreaOffset = 0x%x\n",  scbPtr->recvFrameAreaOffset);
    printf("crcErrors = %d\n",  scbPtr->crcErrors);
    printf("alignErrors = %d\n",  scbPtr->alignErrors);
    printf("resourceErrors = %d\n",  scbPtr->resourceErrors);
    printf("overrunErrors = %d\n",  scbPtr->overrunErrors);
}

/*
 *----------------------------------------------------------------------
 *
 * NetIETransmitCBPrint --
 *
 *	Print the contents of a NetIETransmitCB.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	stuff is printed.
 *
 *----------------------------------------------------------------------
 */

void
NetIETransmitCBPrint(xmitCBPtr)
    NetIETransmitCB	*xmitCBPtr;
{
    char buffer[32];
    printf("xmitCBPtr = 0x%x\n", xmitCBPtr);
    printf("bits = 0x%x\n", xmitCBPtr->bits[0]);
    printf("nextCmdBlock = 0x%x\n", xmitCBPtr->nextCmdBlock);
    printf("bufDescOffset = 0x%x\n", xmitCBPtr->bufDescOffset);
    printf("etherAddress = %s\n", 
	Net_EtherAddrToString(&xmitCBPtr->destEtherAddr, buffer));
    printf("type = 0x%x\n", xmitCBPtr->type);
}

void
NetIERecvBufDescPrint(recvBufDescPtr)
    NetIERecvBufDesc	*recvBufDescPtr;
{
    printf("recvBufDescPtr = 0x%x\n", recvBufDescPtr);
    printf("bits1 = 0x%x\n", recvBufDescPtr->bits1[0]);
    printf("nextRBD = 0x%x\n", recvBufDescPtr->nextRBD);
    printf("bufAddr = 0x%x\n", recvBufDescPtr->bufAddr);
    printf("bits2 = 0x%x\n", recvBufDescPtr->bits2[0]);
    printf("realBufAddr = 0x%x\n", recvBufDescPtr->realBufAddr);
    printf("realNextRBD = 0x%x\n", recvBufDescPtr->realNextRBD);
}

void
NetIERecvFrameDescPrint(recvFrDescPtr) 
    NetIERecvFrameDesc 	*recvFrDescPtr;
{
    char	buffer[32];
    printf("NetIERecvFrameDesc = 0x%x\n", recvFrDescPtr);
    printf("bits = 0x%x\n", recvFrDescPtr->bits[0]);
    printf("nextRFD = 0x%x\n", recvFrDescPtr->nextRFD);
    printf("recvBufferDesc = 0x%x\n", recvFrDescPtr->recvBufferDesc);
    printf("destAddr = %s\n", 
	Net_EtherAddrToString(&recvFrDescPtr->destAddr, buffer));
    printf("srcAddr = %s\n", 
	Net_EtherAddrToString(&recvFrDescPtr->srcAddr, buffer));
    printf("type = 0x%x\n", recvFrDescPtr->type);
}

void
NetIETransmitBufDescPrint(xmitBufDescPtr)
    NetIETransmitBufDesc	*xmitBufDescPtr;
{
    printf("xmitBufDescPtr = 0x%x\n", xmitBufDescPtr);
    printf("bits = 0x%x\n", * (unsigned short *) xmitBufDescPtr);
    printf("nextTBD = 0x%x\n", xmitBufDescPtr->nextTBD);
    printf("bufAddr = 0x%x\n", xmitBufDescPtr->bufAddr);
}

@


9.6
log
@Fixed lint errors and removed tracing.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: /sprite/src/kernel/net/sun3.md/RCS/netIE.c,v 9.5 90/11/29 15:46:23 shirriff Exp Locker: rab $ SPRITE (Berkeley)";
d72 1
d213 7
a219 3
    NET_ETHER_ADDR_COPY(statePtr->etherAddress, 
	interPtr->netAddress[NET_PROTO_RAW].ether);
    interPtr->broadcastAddress.ether = netEtherBroadcastAddress.ether;
d820 1
a820 2
	Net_AddrToString((Net_Address *) &xmitCBPtr->destEtherAddr,
	NET_PROTO_RAW, NET_NETWORK_ETHER, buffer));
d847 1
a847 2
	Net_AddrToString((Net_Address *) &recvFrDescPtr->destAddr,
	NET_PROTO_RAW, NET_NETWORK_ETHER, buffer));
d849 1
a849 2
	Net_AddrToString((Net_Address *) &recvFrDescPtr->srcAddr,
	NET_PROTO_RAW, NET_NETWORK_ETHER, buffer));
@


9.5
log
@Made net module receive boot broadcasts so mop will work.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: /sprite/src/kernel/net/sun3.md/RCS/netIE.c,v 9.4 90/10/19 15:47:19 jhh Exp Locker: shirriff $ SPRITE (Berkeley)";
d616 1
a616 1
    NET_IE_ACK(scbPtr->cmdWord, status);
d779 2
a780 2
    printf("status = 0x%x\n", * ((unsigned short *) &scbPtr->statusWord));
    printf("cmd = 0x%x\n", * ((unsigned short *) &scbPtr->cmdWord));
@


9.4
log
@Rewrite to support multiple interfaces and the Ultranet
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: /sprite/src/kernel/net.jhh/sun3.md/RCS/netIE.c,v 9.6 90/09/20 21:13:39 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
d44 2
d307 1
d457 11
@


9.3
log
@Checked volatiles.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: /sprite/src/kernel/net/sun3.md/RCS/netIE.c,v 9.2 89/11/05 12:26:17 brent Exp Locker: rab $ SPRITE (Berkeley)";
d35 9
a43 24
#include "sprite.h"
#include "sys.h"
#include "list.h"
#include "vm.h"
#include "vmMach.h"
#include "mach.h"
#include "netIEInt.h"
#include "net.h"
#include "netInt.h"

/*
 * Define global variables.
 */

NetIEState	netIEState;
Address		netIERecvBuffers[NET_IE_NUM_RECV_BUFFERS];

/*
 * Define the header that the transmit list will point to. 
 */

static 	List_Links	xmitListHdr;
static 	List_Links	xmitFreeListHdr;

d53 2
a54 2
 *	TRUE if the Intel controller was found and initialized,
 *	FALSE otherwise.
d57 8
a64 10
 *	Initializes the netEtherFuncs record, as well as the chip.
 *
 *----------------------------------------------------------------------
 */

Boolean
NetIEInit(name, number, ctrlAddr)
    char 	*name;		/* Sprite name for controller. */	
    int 	number;		/* Unit number of device (not used). */
    unsigned int ctrlAddr;	/* Kernel virtual address of controller. */
d66 1
d69 1
d73 5
a77 3
#ifdef sun3
    Mach_SetHandler(27, Net_Intr, (ClientData) 0);
#endif
d79 7
a85 1
    Mach_SetHandler(6, Net_Intr, (ClientData) 0);
d87 25
a111 1
    netIEState.running = FALSE;
d119 2
a120 1
    netIEState.controlReg = (volatile NetIEControlRegister *) ctrlAddr;
d130 1
a130 1
	    (char *)netIEState.controlReg);
d135 1
d137 1
a137 1
	    return(FALSE);
d140 1
d145 2
a146 2
    netIEState.xmitList = &xmitListHdr;
    List_Init(netIEState.xmitList);
d148 2
a149 2
    netIEState.xmitFreeList = &xmitFreeListHdr;
    List_Init(netIEState.xmitFreeList);
d152 2
a153 1
    netIEXmitTempBuffer = (char *)VmMach_NetMemAlloc(NET_ETHER_MAX_BYTES + 2);
d158 1
a158 1
	List_Insert(itemPtr, LIST_ATREAR(netIEState.xmitFreeList));
d168 9
a176 8
    Mach_GetEtherAddress(&netIEState.etherAddress);
    printf("%s-%d Ethernet address %x:%x:%x:%x:%x:%x\n", name, number,
	      netIEState.etherAddress.byte1 & 0xff,
	      netIEState.etherAddress.byte2 & 0xff,
	      netIEState.etherAddress.byte3 & 0xff,
	      netIEState.etherAddress.byte4 & 0xff,
	      netIEState.etherAddress.byte5 & 0xff,
	      netIEState.etherAddress.byte6 & 0xff);
d182 1
a182 1
    netIEState.sysConfPtr = (NetIESysConfPtr *) NET_IE_SYS_CONF_PTR_ADDR;
d194 1
a194 1
	netIERecvBuffers[i] = 
d200 16
d220 1
a220 1
    NetIEReset();
d232 1
a232 6
    netIEState.running = TRUE;
    netEtherFuncs.init	 = NetIEInit;
    netEtherFuncs.output = NetIEOutput;
    netEtherFuncs.intr   = NetIEIntr;
    netEtherFuncs.reset  = NetIERestart;

d234 1
a234 1
    return (TRUE);
d257 2
a258 1
NetIEDefaultConfig()
d262 1
a262 1
    confCBPtr = (NetIEConfigureCB *) netIEState.cmdBlockPtr;
d264 10
a273 10
    confCBPtr->cmdBlock.cmdNumber = NET_IE_CONFIG;
    confCBPtr->byteCount = 12;
    confCBPtr->fifoLimit = 12;
    confCBPtr->preamble = 2;
    confCBPtr->addrLen = 6;
    confCBPtr->atLoc = 0;
    confCBPtr->interFrameSpace = 96;
    confCBPtr->slotTimeHigh = 512 >> 8;
    confCBPtr->minFrameLength = 64;
    confCBPtr->numRetries = 15;
d279 1
a279 1
    NetIEExecCommand((NetIECommandBlock *) confCBPtr);
d289 1
a289 1
 *	Reset the world.
d295 1
a295 1
 *	All of the pointers in the netIEState structure are initialized.
d301 2
a302 1
NetIEReset()
d306 1
d311 7
a317 7

    netIEState.intSysConfPtr = (NetIEIntSysConfPtr *) NIL;
    netIEState.scbPtr = (NetIESCB *) NIL;
    netIEState.recvFrDscHeadPtr = (NetIERecvFrameDesc *) NIL;
    netIEState.recvFrDscTailPtr = (NetIERecvFrameDesc *) NIL;
    netIEState.recvBufDscHeadPtr = (NetIERecvBufDesc *) NIL;
    netIEState.recvBufDscTailPtr = (NetIERecvBufDesc *) NIL;
d323 1
a323 1
    NET_IE_CHIP_RESET;
d329 1
a329 1
    NetIEMemInit();
d336 2
a337 2
    netIEState.intSysConfPtr = (NetIEIntSysConfPtr *) NetIEMemAlloc();
    if (netIEState.intSysConfPtr == (NetIEIntSysConfPtr *) NIL) {
d341 2
a342 2
    netIEState.scbPtr = (NetIESCB *) NetIEMemAlloc();
    if (netIEState.scbPtr == (NetIESCB *) NIL) {
d352 3
a354 3
	bzero((Address) netIEState.sysConfPtr, sizeof(NetIESysConfPtr));
	netIEState.sysConfPtr->intSysConfPtr = 
			NetIEAddrFromSUNAddr((int) netIEState.intSysConfPtr);
d360 7
a366 6
	bzero((Address) netIEState.intSysConfPtr, sizeof(NetIEIntSysConfPtr));
	netIEState.intSysConfPtr->busy = 1;
	netIEState.intSysConfPtr->base = 
			    NetIEAddrFromSUNAddr((int) netIEState.memBase);
	netIEState.intSysConfPtr->scbOffset = 
			    NetIEOffsetFromSUNAddr((int) netIEState.scbPtr);
d372 1
a372 1
	bzero((Address) netIEState.scbPtr, sizeof(NetIESCB));
d378 1
a378 1
	netIEState.controlReg->noReset = 1;
d385 1
a385 1
	NET_IE_CHANNEL_ATTENTION;
d392 3
a394 2
	NET_IE_DELAY(!netIEState.intSysConfPtr->busy);
	NET_IE_DELAY(netIEState.scbPtr->statusWord.cmdUnitNotActive);
d400 1
a400 1
	NET_IE_DELAY(netIEState.controlReg->intrPending);
d406 4
a409 3
	if (netIEState.intSysConfPtr->busy || 
	    !netIEState.scbPtr->statusWord.cmdUnitNotActive ||
	    !netIEState.controlReg->intrPending) {
d412 2
a413 1
	if (netIEState.scbPtr->statusWord.cmdUnitStatus == NET_IE_CUS_IDLE) {
d418 1
a418 1
	NET_IE_CHIP_RESET;
d425 2
a426 2
    netIEState.cmdBlockPtr = (NetIECommandBlock *) NetIEMemAlloc();
    if (netIEState.cmdBlockPtr == (NetIECommandBlock *) NIL) {
d429 3
a431 2
    netIEState.scbPtr->cmdListOffset =
			NetIEOffsetFromSUNAddr((int) netIEState.cmdBlockPtr);
d437 1
a437 1
    diagCmdPtr = netIEState.cmdBlockPtr;
d439 3
a441 3
    diagCmdPtr->cmdNumber = NET_IE_DIAGNOSE;
    NetIEExecCommand(diagCmdPtr);
    if (!diagCmdPtr->cmdOK) {
d449 1
a449 1
    addressCommandPtr = (NetIEIASetupCB *) netIEState.cmdBlockPtr;
d451 3
a453 3
    addressCommandPtr->cmdBlock.cmdNumber = NET_IE_IA_SETUP;
    addressCommandPtr->etherAddress = netIEState.etherAddress;
    NetIEExecCommand((NetIECommandBlock *) addressCommandPtr);
d459 1
a459 1
    NetIEDefaultConfig();
d465 1
a465 1
    NetIERecvUnitInit();
d473 2
a474 2
    netIEState.controlReg->intrEnable = 1;
    netIEState.controlReg->noLoopback = 1;
d481 2
a482 1
    NetIEXmitInit();
d503 2
a504 1
NetIERestart()
d506 1
d513 1
a513 1
    NetIEXmitDrop();
d523 1
a523 1
    NetIEReset();
a529 7
#ifdef not_needed
    /*
     * Restart transmission of packets.  Already done by NetIEReset.
     */
    NetIEXmitRestart();
#endif

d551 4
a554 3
NetIEIntr(polling)
    Boolean	polling;	/* TRUE if are being polled instead of
				 * processing an interrupt. */
d556 1
a556 1
    register	NetIEState	*netIEStatePtr;
d560 2
a561 3
    netIEStatePtr = &netIEState;
    scbPtr = netIEState.scbPtr;

d565 1
a565 1
    if (netIEStatePtr->controlReg->busError) {
d567 1
a567 1
	NetIERestart();
d575 2
a576 2
    if (!netIEStatePtr->controlReg->intrEnable || 
	!netIEStatePtr->controlReg->intrPending) {
d578 8
a585 1
	printf("Intel: Spurious interrupt <%x>\n", status);
d587 1
a587 1
	*/
d603 1
a603 1
    NET_IE_CHANNEL_ATTENTION;
d609 1
a609 1
	NetIERecvProcess(FALSE);
d616 1
a616 1
	NetIEXmitDone();
d620 227
@


9.2
log
@Fixed NetIERestart so the process transmitting the current
packet isn't wedged by a reset.
@
text
@d32 2
a33 2
static char rcsid[] = "$Header: /sprite/src/kernel/net/sun3.md/RCS/netIE.c,v 9.1 89/10/31 08:56:16 mendel Exp Locker: brent $ SPRITE (Berkeley)";
#endif not lint
a84 11
    Address	(*allocFunc)();

#ifdef sun2
    allocFunc = Vm_RawAlloc;
#endif
#ifdef sun3
    allocFunc = VmMach_NetMemAlloc;
#endif
#ifdef sun4
    allocFunc = VmMach_NetMemAlloc;
#endif
d88 1
a88 1
#if defined(sun2) || defined(sun3)
d92 1
a92 1
    Mach_SetHandler(6, Net_Intr, (ClientData)0);
d110 1
d131 2
a132 2
    netIEXmitFiller = (char *)allocFunc(NET_ETHER_MIN_BYTES);
    netIEXmitTempBuffer = (char *)allocFunc(NET_ETHER_MAX_BYTES + 2);
d135 1
a135 1
	itemPtr = (List_Links *) allocFunc(sizeof(NetXmitElement)), 
d173 2
a174 2
		allocFunc(NET_IE_RECV_BUFFER_SIZE + ALIGNMENT_PADDING) +
							ALIGNMENT_PADDING;
d246 1
d441 1
d494 1
d574 1
@


9.1
log
@Removed lint.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: /sprite/src/kernel/net/sun3.md/RCS/netIE.c,v 8.6 89/06/08 09:09:41 mendel Exp $ SPRITE (Berkeley)";
d475 5
d494 1
d496 1
a496 1
     * Restart transmission of packets.
d499 1
@


9.0
log
@Changing version numbers.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: /sprite/src/kernel/net/sun3.md/RCS/netIE.c,v 8.6 89/06/08 09:09:41 mendel Exp Locker: douglis $ SPRITE (Berkeley)";
d122 1
a122 1
	    (volatile char *)netIEState.controlReg);
d336 1
a336 1
			    NetIEAddrFromSUNAddr(netIEState.memBase);
@


8.6
log
@Modification to allow the sun4 to use the same VM mapping calls as the
sun3.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: /sprite/src/kernel/net/sun3.md/RCS/netIE.c,v 8.5 89/05/24 07:57:57 rab Exp $ SPRITE (Berkeley)";
@


8.5
log
@Changes to allow optimization.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: /sprite/src/kernel/net/sun3.md/RCS/netIE.c,v 8.4 89/05/23 09:43:53 mendel Exp $ SPRITE (Berkeley)";
d94 1
a94 1
    allocFunc = Vm_RawAlloc;
@


8.4
log
@Changed to register interrupt callback routines and use Mach_Probe rather
than setjmp/longjmp.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: /sprite/src/kernel/net/sun3.md/RCS/netIE.c,v 8.3 89/03/15 17:34:19 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d113 1
a113 1
    netIEState.controlReg = (NetIEControlRegister *) ctrlAddr;
d121 2
a122 1
	status = Mach_Probe(sizeof(char), &zero,(char *)netIEState.controlReg); 
d278 2
a279 2
    NetIEIASetupCB	*addressCommandPtr;
    NetIECommandBlock	*diagCmdPtr;
d519 1
a519 1
    register	NetIESCB	*scbPtr;
@


8.3
log
@Added alignement padding for sun4.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: /sprite/src/kernel/net/sun3.md/RCS/netIE.c,v 8.2 89/01/31 14:01:41 mendel Exp $ SPRITE (Berkeley)";
a58 6
#ifndef sun4
/*
 * Setup state for probing the existence of the device
 */
static Mach_SetJumpState setJumpState;
#endif
d99 6
d115 1
a115 1
#ifdef sun4
d119 10
a128 14
	*(char *)netIEState.controlReg = 0;
#else
    if (Mach_SetJump(&setJumpState) == SUCCESS) {
	/*
	 * Poke the controller by resetting it.
	 */
	*(char *)netIEState.controlReg = 0;
    } else {
	/*
	 * Got a bus error.
	 */
	Mach_UnsetJump();
	ENABLE_INTR();
	return(FALSE);
a129 2
    Mach_UnsetJump();
#endif
@


8.2
log
@Modifications for the sun4.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: /sprite/src/kernel/net/sun3.md/RCS/netIE.c,v 8.1 88/12/12 14:51:21 nelson Exp Locker: mendel $ SPRITE (Berkeley)";
d178 6
a183 2
     * Allocate space for all of the receive buffers.
     */
d185 1
d187 3
a189 1
	netIERecvBuffers[i] = allocFunc(NET_IE_RECV_BUFFER_SIZE);
d191 1
@


8.1
log
@Changed to allocate memory and remap packets into high memory on a sun3.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: /sprite/src/kernel/net/sun3.md/RCS/netIE.c,v 6.3 88/11/07 14:43:34 mlgray Exp $ SPRITE (Berkeley)";
d59 1
d64 1
a64 1

d99 3
d115 6
d135 1
a135 1

d324 1
a324 1
			NetIEAddrFrom68000Addr((int) netIEState.intSysConfPtr);
d333 1
a333 1
			    NetIEAddrFrom68000Addr(netIEState.memBase);
d335 1
a335 1
			    NetIEOffsetFrom68000Addr((int) netIEState.scbPtr);
d396 1
a396 1
			NetIEOffsetFrom68000Addr((int) netIEState.cmdBlockPtr);
@


8.0
log
@Changing version numbers.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: /sprite/src/kernel/net/sun3.md/RCS/netIE.c,v 6.3 88/11/07 14:43:34 mlgray Exp Locker: douglis $ SPRITE (Berkeley)";
d90 1
d92 7
d136 3
d140 1
a140 1
	itemPtr = (List_Links *) Vm_RawAlloc(sizeof(NetXmitElement)), 
d172 1
a172 1
	netIERecvBuffers[i] = Vm_RawAlloc(NET_IE_RECV_BUFFER_SIZE);
@


6.3
log
@Converted to new C library.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: /sprite/src/kernel/net/sun3.md/RCS/netIE.c,v 6.2 88/10/13 13:26:23 mendel Exp Locker: mlgray $ SPRITE (Berkeley)";
@


6.2
log
@Removed references to Byte_ routines.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: netIE.c,v 6.1 88/09/06 09:06:38 mendel Exp $ SPRITE (Berkeley)";
d142 1
a142 1
    Sys_Printf("%s-%d Ethernet address %x:%x:%x:%x:%x:%x\n", name, number,
d287 1
a287 1
	Sys_Panic(SYS_FATAL, "Intel: No memory for the scp.\n");
d292 1
a292 1
	Sys_Panic(SYS_FATAL, "Intel: No memory for the scb.\n");
d356 1
a356 1
	    Sys_Panic(SYS_WARNING, "Could not initialize Intel chip.\n");
d362 1
a362 1
	Sys_Panic(SYS_WARNING, "Intel cus not idle after reset\n");
d372 1
a372 1
	Sys_Panic(SYS_FATAL, "NetIE: No memory for the command block.\n");
d382 1
a382 1
    Byte_Zero(sizeof(*diagCmdPtr), (Address) diagCmdPtr);
d386 1
a386 1
	Sys_Panic(SYS_FATAL, "Intel failed diagnostics.\n");
d394 1
a394 1
    Byte_Zero(sizeof(NetIEIASetupCB), (Address) addressCommandPtr);
d505 1
a505 1
	Sys_Panic(SYS_WARNING, "Intel: Bus error on chip.\n");
d517 1
a517 1
	Sys_Printf("Intel: Spurious interrupt <%x>\n", status);
d525 1
a525 1
	    Sys_Printf("Intel: Spurious interrupt (2)\n");
@


6.1
log
@Lint.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: netIE.c,v 6.0 88/08/11 12:20:25 brent Stable $ SPRITE (Berkeley)";
a43 1
#include "byte.h"
d215 1
a215 1
    Byte_Zero(sizeof(NetIEConfigureCB), (Address) confCBPtr);
d301 1
a301 1
	Byte_Zero(sizeof(NetIESysConfPtr), (Address) netIEState.sysConfPtr);
d309 1
a309 1
	Byte_Zero(sizeof(NetIEIntSysConfPtr),(Address) netIEState.intSysConfPtr);
d320 1
a320 1
	Byte_Zero(sizeof(NetIESCB), (Address) netIEState.scbPtr);
@


6.0
log
@Changing version numbers.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: netIE.c,v 5.8 88/06/27 10:45:58 mendel Exp $ SPRITE (Berkeley)";
d154 1
a154 1
    VmMach_MapIntelPage((int) (NET_IE_SYS_CONF_PTR_ADDR));
d175 1
a175 1
    VmMach_UnmapIntelPage((int) (NET_IE_SYS_CONF_PTR_ADDR));
d454 1
a454 1
    VmMach_MapIntelPage((int) (NET_IE_SYS_CONF_PTR_ADDR));
d464 1
a464 1
    VmMach_UnmapIntelPage((int) (NET_IE_SYS_CONF_PTR_ADDR));
@


5.8
log
@Updated copyright notice and cleaned up comment typos.
@
text
@d32 1
a32 1
static char rcsid[] = "$Header: netIE.c,v 5.7 88/06/21 10:51:55 mendel Exp $ SPRITE (Berkeley)";
@


5.7
log
@Corrected NetIEInit to return true when it works.
@
text
@d20 9
a28 2
 * Copyright 1985 Regents of the University of California
 * All rights reserved.
d32 1
a32 1
static char rcsid[] = "$Header: netIE.c,v 5.6 88/06/20 09:49:54 brent Exp $ SPRITE (Berkeley)";
d41 1
a41 1
#include "netIE.h"
d85 3
a87 3
    char *name;
    int number;
    unsigned int ctrlAddr;
a447 3
    int 		i;
    List_Links		*itemPtr;
    NetXmitElement	*xmitElemPtr;
@


5.6
log
@Changed initialization procedure to handl auto-config.
@
text
@d25 1
a25 1
static char rcsid[] = "$Header: netIE.c,v 5.5 88/05/05 17:58:28 brent Exp $ SPRITE (Berkeley)";
d181 1
@


5.5
log
@Conversion to use Mach module
@
text
@d25 1
a25 1
static char rcsid[] = "$Header: netIE.c,v 5.4 87/12/12 16:37:55 nelson Exp $ SPRITE (Berkeley)";
d33 1
d53 5
d62 125
a418 101
}


/*
 *----------------------------------------------------------------------
 *
 * NetIEInit --
 *
 *	Initialize the Intel Ethernet chip.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
NetIEInit()
{
    int 	i;
    List_Links	*itemPtr;

    DISABLE_INTR();

    netIEState.running = FALSE;

    /*
     * Initialize the transmission list.  
     */

    netIEState.xmitList = &xmitListHdr;
    List_Init(netIEState.xmitList);

    netIEState.xmitFreeList = &xmitFreeListHdr;
    List_Init(netIEState.xmitFreeList);

    for (i = 0; i < NET_IE_NUM_XMIT_ELEMENTS; i++) {
	itemPtr = (List_Links *) Vm_RawAlloc(sizeof(NetXmitElement)), 
	List_InitElement(itemPtr);
	List_Insert(itemPtr, LIST_ATREAR(netIEState.xmitFreeList));
    }

    /*
     * The onboard control register is at this magic address.  This is set up
     * by the monitor.
     */

    netIEState.controlReg = (NetIEControlRegister *) NET_IE_CONTROL_REG_ADDR;

    /*
     * Get ethernet address out of the rom.  It is stored in a normal order
     * even though the chip is wired backwards because fortunately the chip
     * stores the ethernet address backwards from how we store it.  Therefore
     * two backwards makes one forwards, right?
     */

    Mach_GetEtherAddress(&netIEState.etherAddress);
    Sys_Printf("Ethernet address %x:%x:%x:%x:%x:%x\n",
	      netIEState.etherAddress.byte1 & 0xff,
	      netIEState.etherAddress.byte2 & 0xff,
	      netIEState.etherAddress.byte3 & 0xff,
	      netIEState.etherAddress.byte4 & 0xff,
	      netIEState.etherAddress.byte5 & 0xff,
	      netIEState.etherAddress.byte6 & 0xff);
    /*
     * Allocate space for the System Configuration Pointer.
     */

    VmMach_MapIntelPage((int) (NET_IE_SYS_CONF_PTR_ADDR));
    netIEState.sysConfPtr = (NetIESysConfPtr *) NET_IE_SYS_CONF_PTR_ADDR;

    /*
     * Allocate space for all of the receive buffers.
     */

    for (i = 0; i < NET_IE_NUM_RECV_BUFFERS; i++) {
	netIERecvBuffers[i] = Vm_RawAlloc(NET_IE_RECV_BUFFER_SIZE);
    }

    /*
     * Reset the world.
     */

    NetIEReset();

    /*
     * Unmap the extra page.
     */

    VmMach_UnmapIntelPage((int) (NET_IE_SYS_CONF_PTR_ADDR));

    /*
     * Now we are running.
     */

    netIEState.running = TRUE;

    ENABLE_INTR();
@


5.4
log
@Handles moving of hardware dependencies from vm to sun.
@
text
@d25 1
a25 1
static char rcsid[] = "$Header: netIE.c,v 5.3 87/09/17 13:03:14 nelson Exp $ SPRITE (Berkeley)";
a28 1
#include "machine.h"
d189 1
a189 1
	DELAY(200);
@


5.3
log
@Removed printfs about reinitializing chips.
@
text
@d25 1
a25 1
static char rcsid[] = "$Header: netIE.c,v 5.2 87/09/17 12:02:47 nelson Exp $ SPRITE (Berkeley)";
d33 1
a33 1
#include "vmSun.h"
d360 1
a360 1
    Vm_MapIntelPage((int) (NET_IE_SYS_CONF_PTR_ADDR));
d381 1
a381 1
    Vm_UnmapIntelPage((int) (NET_IE_SYS_CONF_PTR_ADDR));
d420 1
a420 1
    Vm_MapIntelPage((int) (NET_IE_SYS_CONF_PTR_ADDR));
d430 1
a430 1
    Vm_UnmapIntelPage((int) (NET_IE_SYS_CONF_PTR_ADDR));
@


5.2
log
@Added ability to reset 3Com and Intel chips.
@
text
@d25 1
a25 1
static char rcsid[] = "$Header: netIE.c,v 5.1 87/09/16 11:31:39 nelson Exp $ SPRITE (Berkeley)";
a413 2

    Sys_Printf("NetIERestart: Reinitializing Intel chip\n");
@


5.1
log
@Added ability to reinitialize the intel chiop.
@
text
@d25 1
a25 1
static char rcsid[] = "$Header: netIE.c,v 5.0 87/08/11 10:46:13 sprite Exp $ SPRITE (Berkeley)";
a419 11
     * Drop the current outgoing packet.
     */    
    if (netIECurScatGathPtr != (Net_ScatterGather *) NIL) {
	netIECurScatGathPtr->done = TRUE;
	if (netIECurScatGathPtr->conditionPtr != (Sync_Condition *) NIL) {
	    NetOutputWakeup(netIECurScatGathPtr->conditionPtr);
	}
	netIECurScatGathPtr = (Net_ScatterGather *) NIL;
    }

    /*
d434 5
a457 1

@


5.0
log
@First Sprite native copy
@
text
@d25 1
a25 1
static char rcsid[] = "$Header: netIE.c,v 4.4 87/06/12 14:51:10 nelson Exp $ SPRITE (Berkeley)";
d396 56
d481 3
a483 1
	Sys_Panic(SYS_FATAL, "Intel: Bus error on chip.\n");
@
