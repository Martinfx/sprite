head     9.42;
branch   ;
access   ;
symbols  ds3100:9.41 sun3:9.41 sun4nw:9.38 symm:9.38 spur:9.38 Summer89:9.0;
locks    ; strict;
comment  @ * @;


9.42
date     93.01.06.20.09.15;  author mgbaker;  state Exp;
branches ;
next     9.41;

9.41
date     92.08.10.17.58.50;  author mgbaker;  state Exp;
branches ;
next     9.40;

9.40
date     91.11.13.23.51.20;  author shirriff;  state Exp;
branches ;
next     9.39;

9.39
date     91.11.05.12.02.30;  author mgbaker;  state Exp;
branches ;
next     9.38;

9.38
date     91.10.18.01.23.05;  author dlong;  state Exp;
branches ;
next     9.37;

9.37
date     91.10.10.12.08.31;  author shirriff;  state Exp;
branches ;
next     9.36;

9.36
date     91.09.10.18.17.56;  author rab;  state Exp;
branches ;
next     9.35;

9.35
date     91.08.15.22.39.44;  author mgbaker;  state Exp;
branches ;
next     9.34;

9.34
date     91.08.12.22.15.28;  author shirriff;  state Exp;
branches ;
next     9.33;

9.33
date     91.08.12.15.02.25;  author shirriff;  state Exp;
branches ;
next     9.32;

9.32
date     91.08.09.16.05.15;  author shirriff;  state Exp;
branches ;
next     9.31;

9.31
date     91.08.02.18.42.57;  author mgbaker;  state Exp;
branches ;
next     9.30;

9.30
date     91.07.30.16.42.38;  author shirriff;  state Exp;
branches ;
next     9.29;

9.29
date     91.07.29.18.01.36;  author shirriff;  state Exp;
branches ;
next     9.28;

9.28
date     91.07.26.17.04.27;  author shirriff;  state Exp;
branches ;
next     9.27;

9.27
date     91.07.23.12.42.30;  author mendel;  state Exp;
branches ;
next     9.26;

9.26
date     91.03.29.17.57.37;  author shirriff;  state Exp;
branches ;
next     9.25;

9.25
date     90.12.13.15.01.04;  author mendel;  state Exp;
branches ;
next     9.24;

9.24
date     90.12.07.12.51.35;  author mgbaker;  state Exp;
branches ;
next     9.23;

9.23
date     90.11.09.12.01.06;  author mgbaker;  state Exp;
branches ;
next     9.22;

9.22
date     90.11.08.21.09.23;  author rab;  state Exp;
branches ;
next     9.21;

9.21
date     90.11.06.16.50.54;  author mendel;  state Exp;
branches ;
next     9.20;

9.20
date     90.10.12.14.56.03;  author mgbaker;  state Exp;
branches ;
next     9.19;

9.19
date     90.09.11.13.43.07;  author mendel;  state Exp;
branches ;
next     9.18;

9.18
date     90.09.11.10.49.43;  author mendel;  state Exp;
branches ;
next     9.17;

9.17
date     90.09.10.12.22.55;  author mendel;  state Exp;
branches ;
next     9.16;

9.16
date     90.07.31.21.32.25;  author shirriff;  state Exp;
branches 9.16.1.1;
next     9.15;

9.15
date     90.07.31.17.02.30;  author shirriff;  state Exp;
branches ;
next     9.14;

9.14
date     90.07.30.16.17.26;  author shirriff;  state Exp;
branches ;
next     9.13;

9.13
date     90.07.30.11.34.25;  author shirriff;  state Exp;
branches ;
next     9.12;

9.12
date     90.06.27.11.13.53;  author douglis;  state Exp;
branches ;
next     9.11;

9.11
date     90.03.26.12.14.48;  author mgbaker;  state Exp;
branches ;
next     9.10;

9.10
date     90.02.28.22.18.32;  author douglis;  state Exp;
branches ;
next     9.9;

9.9
date     90.02.22.23.28.36;  author douglis;  state Exp;
branches ;
next     9.8;

9.8
date     90.02.20.15.29.55;  author jhh;  state Exp;
branches ;
next     9.7;

9.7
date     90.01.11.10.49.23;  author mgbaker;  state Exp;
branches ;
next     9.6;

9.6
date     89.12.12.18.01.37;  author mgbaker;  state Exp;
branches ;
next     9.5;

9.5
date     89.11.30.12.04.00;  author mendel;  state Exp;
branches ;
next     9.4;

9.4
date     89.11.27.14.53.04;  author mgbaker;  state Exp;
branches ;
next     9.3;

9.3
date     89.10.24.13.37.22;  author mgbaker;  state Exp;
branches ;
next     9.2;

9.2
date     89.10.21.20.53.47;  author rab;  state Exp;
branches ;
next     9.1;

9.1
date     89.09.18.21.01.10;  author mgbaker;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.14.52.50;  author douglis;  state Stable;
branches ;
next     1.40;

1.40
date     89.08.31.12.44.14;  author douglis;  state Exp;
branches ;
next     1.39;

1.39
date     89.08.17.17.24.53;  author jhh;  state Exp;
branches ;
next     1.38;

1.38
date     89.08.17.15.17.54;  author mgbaker;  state Exp;
branches ;
next     1.37;

1.37
date     89.08.08.22.15.29;  author jhh;  state Exp;
branches ;
next     1.36;

1.36
date     89.07.20.16.59.20;  author mgbaker;  state Exp;
branches ;
next     1.35;

1.35
date     89.06.16.09.04.53;  author mendel;  state Exp;
branches ;
next     1.34;

1.34
date     89.05.21.18.24.21;  author mgbaker;  state Exp;
branches ;
next     1.33;

1.33
date     89.05.04.23.27.12;  author mgbaker;  state Exp;
branches ;
next     1.32;

1.32
date     89.05.02.23.25.54;  author mgbaker;  state Exp;
branches ;
next     1.31;

1.31
date     89.04.29.19.51.29;  author mgbaker;  state Exp;
branches ;
next     1.30;

1.30
date     89.04.24.00.21.14;  author mgbaker;  state Exp;
branches ;
next     1.29;

1.29
date     89.04.23.16.30.34;  author mgbaker;  state Exp;
branches ;
next     1.28;

1.28
date     89.04.19.23.19.59;  author mgbaker;  state Exp;
branches ;
next     1.27;

1.27
date     89.04.09.13.23.32;  author mgbaker;  state Exp;
branches ;
next     1.26;

1.26
date     89.04.06.20.33.50;  author mgbaker;  state Exp;
branches ;
next     1.25;

1.25
date     89.04.05.10.46.32;  author mgbaker;  state Exp;
branches ;
next     1.24;

1.24
date     89.04.01.13.02.20;  author mgbaker;  state Exp;
branches ;
next     1.23;

1.23
date     89.03.31.11.58.42;  author mgbaker;  state Exp;
branches ;
next     1.22;

1.22
date     89.03.30.23.23.53;  author mgbaker;  state Exp;
branches ;
next     1.21;

1.21
date     89.03.28.16.08.26;  author mgbaker;  state Exp;
branches ;
next     1.20;

1.20
date     89.03.26.20.16.32;  author mgbaker;  state Exp;
branches ;
next     1.19;

1.19
date     89.03.24.15.38.56;  author mgbaker;  state Exp;
branches ;
next     1.18;

1.18
date     89.03.22.14.07.15;  author mgbaker;  state Exp;
branches ;
next     1.17;

1.17
date     89.03.21.21.13.02;  author mgbaker;  state Exp;
branches ;
next     1.16;

1.16
date     89.03.19.01.21.42;  author mgbaker;  state Exp;
branches ;
next     1.15;

1.15
date     89.03.18.15.40.34;  author mgbaker;  state Exp;
branches ;
next     1.14;

1.14
date     89.03.17.14.51.47;  author mgbaker;  state Exp;
branches ;
next     1.13;

1.13
date     89.03.09.17.08.01;  author mgbaker;  state Exp;
branches ;
next     1.12;

1.12
date     89.03.06.12.01.20;  author mgbaker;  state Exp;
branches ;
next     1.11;

1.11
date     89.03.03.15.40.12;  author mgbaker;  state Exp;
branches ;
next     1.10;

1.10
date     89.03.02.00.20.05;  author mgbaker;  state Exp;
branches ;
next     1.9;

1.9
date     89.02.28.12.47.30;  author mgbaker;  state Exp;
branches ;
next     1.8;

1.8
date     89.02.24.21.57.12;  author mgbaker;  state Exp;
branches ;
next     1.7;

1.7
date     89.02.24.16.38.22;  author mgbaker;  state Exp;
branches ;
next     1.6;

1.6
date     89.01.29.17.21.06;  author mgbaker;  state Exp;
branches ;
next     1.5;

1.5
date     89.01.25.22.53.11;  author mgbaker;  state Exp;
branches ;
next     1.4;

1.4
date     89.01.23.17.54.47;  author mgbaker;  state Exp;
branches ;
next     1.3;

1.3
date     89.01.23.00.06.15;  author mgbaker;  state Exp;
branches ;
next     1.2;

1.2
date     89.01.22.23.45.15;  author mgbaker;  state Exp;
branches ;
next     1.1;

1.1
date     89.01.22.20.31.59;  author mgbaker;  state Exp;
branches ;
next     ;

9.16.1.1
date     90.08.07.18.09.11;  author mgbaker;  state Exp;
branches ;
next     ;


desc
@Checkpoint.  Traps work and interrupts remain enabled correctly.
>> I've #ifdef'd out the code where I start the timer and try to take
>> timer interrupts.  When I do that, interrupts get permanently disabled,
>> somehow.
@


9.42
log
@Can now run sparcstation kernel with no proprietary software floating point
emulation code.
@
text
@/* 
 * machCode.c --
 *
 *     C code for the mach module.
 *
 * Copyright (C) 1985 Regents of the University of California
 * All rights reserved.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/mach/sun4.md/machCode.c,v 9.46 93/01/06 17:03:41 mgbaker Exp $ SPRITE (Berkeley)";
#endif /* not lint */

#include <stddef.h>
#include <sprite.h>
#include <swapBuffer.h>
#include <machConst.h>
#include <machMon.h>
#include <machInt.h>
#include <mach.h>
#include <proc.h>
#include <prof.h>
#include <sys.h>
#include <sched.h>
#include <vm.h>
#include <vmMach.h>
#include <user/sun4.md/sys/machSignal.h>
#include <procUnixStubs.h>

#include <stdlib.h>
#include <stdio.h>
#include <bstring.h>
#include <compatInt.h>
#include <ctype.h>
#include <recov.h>

/*
 *  Number of processors in the system.
 */
#ifndef NUM_PROCESSORS
#define NUM_PROCESSORS 1
#endif NUM_PROCESSORS

int mach_NumProcessors = NUM_PROCESSORS;

/*
 * The following two variables should be in the initialized data space, but
 * marked as not initialized.  Then, when they are updated as part of booting,
 * their new values get preserved over a fast restart.
 */
int	storedDataSize = -1;
char	*mach_RestartTablePtr = (char *) NIL;

/*
 * TRUE if cpu was in kernel mode before the interrupt, FALSE if was in 
 * user mode.
 */
Boolean	mach_KernelMode;

/*
 * Sp saved into this before debugger call.
 */
int	machSavedRegisterState = 0;

/*
 *  Flag used by routines to determine if they are running at
 *  interrupt level.
 */
Boolean mach_AtInterruptLevel = FALSE;

/*
 * The machine type string is imported by the file system and
 * used when expanding $MACHINE in file names.
 */

char *mach_MachineType = "sun4";

/*
 * The byte ordering/alignment type used with Fmt_Convert and I/O control data.
 * For compatablity we set this to the old Swap_Buffer constant.
 */
Fmt_Format	mach_Format = FMT_SPARC_FORMAT;

/*
 *  Count of number of ``calls'' to enable interrupts minus number of calls
 *  to disable interrupts.  Kept on a per-processor basis.
 */
int mach_NumDisableInterrupts[NUM_PROCESSORS];
int *mach_NumDisableIntrsPtr = mach_NumDisableInterrupts;

extern int debugProcStubs;

/*
 * Machine dependent variables.
 */
Address	mach_KernStart;
Address	mach_CodeStart;
Address	mach_StackBottom;
int	mach_KernStackSize;
Address	mach_KernEnd;
Address	mach_FirstUserAddr;
Address	mach_LastUserAddr;
Address	mach_MaxUserStackAddr;
int	mach_LastUserStackPage;

Address	machTBRAddr;			/* address of trap table.  The value
					 * is set up and stored here in
					 * bootSysAsm.s.*/
#define	MACH_NUM_VECTORS	256	/* Number of interrupt vector slots */
Address	machVectorTable[MACH_NUM_VECTORS];	/* Table of autovector and
					 * vectored interrupt handlers. */
ClientData	machInterruptArgs[MACH_NUM_VECTORS];	/* Table of clientData
					 * args to pass interrupt handlers */
int	machMaxSysCall;			/* Hightest defined system call. */
int	machArgOffsets[SYS_NUM_SYSCALLS];/* For each system call, tells how
					 * much to add to the fp at the time
					 * of the call to get to the highest
					 * argument on the stack.  */
Address	machArgDispatch[SYS_NUM_SYSCALLS];/* For each system call, gives an
					 * address to branch to, in the
					 * middle of MachFetchArgs, to copy the
					 * right # of args from user space to
					 * the kernel's stack. */
ReturnStatus	(*(mach_NormalHandlers[SYS_NUM_SYSCALLS]))();
					/* For each system call, gives the
					 * address of the routine to handle
					 * the call for non-migrated processes.
				         */
ReturnStatus (*(mach_MigratedHandlers[SYS_NUM_SYSCALLS]))();
					/* For each system call, gives the
					 * address of the routine to handle
				         * the call for migrated processes. */
int	machKcallTableOffset;		/* Byte offset of the kcallTable field
					 * in a Proc_ControlBlock. */
int	machStatePtrOffset;		/* Byte offset of the machStatePtr
					 * field in a Proc_ControlBlock. */
int	machSpecialHandlingOffset;	/* Byte offset of the specialHandling
					 * field in a Proc_ControlBlock. */
int	machTmpRegsOffset;		/* Offset of overflow temp regs. */
int	machTmpRegsStore[2];		/* Temporary storage. */
int	machGenFlagsOffset;		/* offset of genFlags field in a
					 * Proc_ControlBlock. */
int	machForeignFlag;		/* Value of PROC_FOREIGN available
					 * in assembler. */
int	MachPIDOffset;			/* Byte offset of pid in PCB */
char	mach_DebugStack[0x2000];	/* The debugger stack. */
unsigned int	machDebugStackStart;	/* Contains address of base of debugger
					 * stack. */
int	machSignalStackSizeOnStack;	/* size of mach module sig stack */
int	machSigStackSize;		/* size of Sig_Stack structure */
int	machSigStackOffsetOnStack;	/* offset of sigStack field in
					 * MachSignalStack structure on the
					 * the user stack. */
int	machSigStackOffsetInMach;	/* offset to sigStack field in mach
					 * state structure. */
int	machSigContextSize;		/* size of Sig_Context structure */
int	machSigContextOffsetOnStack;	/* offset of sigContext field in
					 * MachSignalStack structure on the
					 * user stack. */
int	machSigContextOffsetInMach;	/* offset to sigContext field in mach
					 * state structure. */
int	machSigUserStateOffsetOnStack;	/* offset of machine-dependent field
					 * on the stack, called machContext,
					 * in the Sig_Context part of the
					 * MachSignalStack structure. */
int	machSigTrapInstOffsetOnStack;	/* offset of trapInst field in
					 * MachSignalStack on user stack. */
int	machSigNumOffsetInSig;		/* offset of sigNum field in
					 * Sig_Stack structure. */
int	machSigAddrOffsetInSig;		/* offset of sigAddr field in
					 * Sig_Stack structure. */
int	machSigCodeOffsetInSig;		/* offset of sigCode field in
					 * Sig_Stack structure. */
int	machSigPCOffsetOnStack;		/* offset of pcValue field in
					 * MachSignalStack on user stack. */
int	machLastSysCallOffset;		/* offset of lastSysCall field in
					 * Mach_State structure. */


Proc_ControlBlock *machFPUSaveProcPtr;	/* Set to the Proc_ControlBlock of the
					 * process we are saving the FPU
					 * state for in Mach_Context switch. */
int		machFPUSyncInst();     /* PC of stfsr instruction in 
					* context switch. */
int		machFPUDumpSyncInst(); /* PC of stfsr instruction in 
					* MachDumpFPUState. */
/*
 * Pointer to the state structure for the current process.
 */
Mach_State	*machCurStatePtr = (Mach_State *)NIL;

char	MachUnixAddr[] =
				"Unix addr %x\n"; 
char	MachUnixString[] =
				"Unix syscall %d\n"; 
char	MachUnixYesString[] =
				"syscall success\n"; 
char	MachUnixNoString[] =
				"syscall failure\n"; 
char	MachRunUserDeathString[] =
				"MachRunUserProc: killing process!\n"; 
char	MachHandleSignalDeathString[] =
				"MachHandleSignal: killing process!\n"; 
char	MachReturnFromSignalDeathString[] =
				"MachReturnFromSignal: killing process!\n"; 
char	MachReturnFromTrapDeathString[] =
				"MachReturnFromTrap: killing process!\n"; 
char	MachHandleWindowUnderflowDeathString[] =
				"MachHandleWindowUnderflow: killing process!\n";

/*
 * For testing correctness of defined offsets.
 */
#if 0
Mach_RegState		testMachRegState;
Mach_State		testMachState;
Proc_ControlBlock	testPCB;
MachSignalStack		testSignalStack;
Sig_Context		testContext;
Sig_Stack		testStack;
#endif
int			debugCounter = 0;		/* for debugging */
int			debugSpace[500];
Address			theAddrOfVmPtr = 0; 
Address			theAddrOfMachPtr = 0;
Address			oldAddrOfVmPtr = 0; 
Address			oldAddrOfMachPtr = 0;

					/*
					 * Make sure machRomVectorPtr is
					 * in the initialized data section.
					 * This is needed when transparent
					 * recovery is used.
					 */
MachMonRomVector	*machRomVectorPtr = (MachMonRomVector *) NIL;
MachMonBootParam	machMonBootParam;
#ifdef sun4c
unsigned char		*machInterruptReg;
unsigned int		machClockRate;
struct idprom		machIdProm = {0};
#endif
					/*
					 * Make sure these variables are
					 * in the initialized data section.
					 */
unsigned int		machNumWindows = 0;
unsigned int		machWimShift = 0;		/* # windows - 1 */

/*
 * Forward declarations.
 */
static void FlushTheWindows _ARGS_((int num));
static void HandleFPUException _ARGS_((Proc_ControlBlock *procPtr, 
				       Mach_State *machStatePtr));

static void CheckFastRestart _ARGS_((void));


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_Init --
 *
 *	Initialize some stuff.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
void
Mach_Init()
{
    int		i;
    extern	void	MachVectoredInterrupt();
    extern	void	MachHandleDebugTrap();
    int		offset;

    /*
     * Set exported machine dependent variables.
     */
    mach_KernStart = (Address)MACH_KERN_START;
    mach_KernEnd = (Address)MACH_KERN_END;
    mach_CodeStart = (Address)MACH_CODE_START;
    mach_StackBottom = (Address)MACH_STACK_BOTTOM;
    mach_KernStackSize = MACH_KERN_STACK_SIZE;
    mach_FirstUserAddr = (Address)MACH_FIRST_USER_ADDR;
    mach_LastUserAddr = (Address)MACH_LAST_USER_ADDR;
    mach_MaxUserStackAddr = (Address)MACH_MAX_USER_STACK_ADDR;
    mach_LastUserStackPage = MACH_LAST_USER_STACK_PAGE;

#define	CHECK_SIZE(c, d)		\
    if (sizeof (c) != d) {		\
	panic("Bad size for structure.  Redo machConst.h!\n");\
    }
	
#define	CHECK_OFFSETS(s, o)		\
    if (offsetof(Mach_State, s) != o) { \
	panic("Bad offset for registers.  Redo machConst.h!\n");\
    }
#define	CHECK_TRAP_REG_OFFSETS(s, o)	   \
    if (offsetof(Mach_RegState, s) != o) { \
	panic("Bad offset for trap registers.  Redo machConst.h!\n");\
    }


    CHECK_SIZE(Mach_RegState, MACH_SAVED_STATE_FRAME);
    CHECK_OFFSETS(trapRegs, MACH_TRAP_REGS_OFFSET);
    CHECK_OFFSETS(switchRegs, MACH_SWITCH_REGS_OFFSET);
    CHECK_OFFSETS(savedRegs[0][0], MACH_SAVED_REGS_OFFSET);
    CHECK_OFFSETS(savedMask, MACH_SAVED_MASK_OFFSET);
    CHECK_OFFSETS(savedSps[0], MACH_SAVED_SPS_OFFSET);
    CHECK_OFFSETS(kernStackStart, MACH_KSP_OFFSET);
    CHECK_OFFSETS(fpuStatus, MACH_FPU_STATUS_OFFSET)
    CHECK_TRAP_REG_OFFSETS(curPsr, MACH_LOCALS_OFFSET);
    CHECK_TRAP_REG_OFFSETS(ins[0], MACH_INS_OFFSET);
    CHECK_TRAP_REG_OFFSETS(globals[0], MACH_GLOBALS_OFFSET);
    CHECK_TRAP_REG_OFFSETS(fsr, MACH_FPU_FSR_OFFSET);
    CHECK_TRAP_REG_OFFSETS(numQueueEntries, MACH_FPU_QUEUE_COUNT);
    CHECK_TRAP_REG_OFFSETS(fregs[0], MACH_FPU_REGS_OFFSET);
    CHECK_TRAP_REG_OFFSETS(fqueue[0], MACH_FPU_QUEUE_OFFSET);

#ifdef sun4c
    if (romVectorPtr->v_romvec_version < 2) {
	if ((*(romVectorPtr->virtMemory))->address !=
		(unsigned) VMMACH_DEV_START_ADDR ||
		((unsigned) VMMACH_DEV_START_ADDR +
		(*(romVectorPtr->virtMemory))->size - 1)
		!= (unsigned) VMMACH_DEV_END_ADDR) {
	    panic("VMMACH_DEV_START_ADDR and VMMACH_DEV_END_ADDR are wrong.\n");
	}
    }
#endif /* sun4c */
#undef CHECK_SIZE
#undef CHECK_OFFSETS
    /*
     * Initialize some of the dispatching information.  The rest is initialized
     * by Mach_InitSysCall, below.
     */

    /*
     * Get offset of machStatePtr in proc control blocks.  This one is
     * subject to a different module, so it's easier not to use a constant.
     */
    machStatePtrOffset = offsetof(Proc_ControlBlock, machStatePtr);
    machKcallTableOffset = offsetof(Proc_ControlBlock, kcallTable);
    machSpecialHandlingOffset = offsetof(Proc_ControlBlock, specialHandling);

    if (MACH_UNIX_ERRNO_OFFSET != offsetof(Proc_ControlBlock, unixErrno)) {
	panic("MACH_UNIX_ERRNO_OFFSET is wrong!\n");
    }

    machMaxSysCall = -1;
    MachPIDOffset = offsetof(Proc_ControlBlock, processID);
    machGenFlagsOffset = offsetof(Proc_ControlBlock, genFlags);
    machForeignFlag = PROC_FOREIGN;

    /*
     * Initialize all the horrid offsets for dealing with getting stuff from
     * signal things in the mach state structure to signal things on the user
     * stack.
     */
    machSignalStackSizeOnStack = sizeof (MachSignalStack);
    if ((machSignalStackSizeOnStack & 0x7) != 0) {
	panic("MachSignalStack struct must be a multiple of double-words!\n");
    }

    machSigStackSize = sizeof (Sig_Stack);
    machSigStackOffsetOnStack = offsetof(MachSignalStack, sigStack);
    machSigStackOffsetInMach = offsetof(Mach_State, sigStack);  
    machSigContextSize = sizeof (Sig_Context);
    machSigContextOffsetOnStack = offsetof(MachSignalStack, sigContext);
    machSigContextOffsetInMach = offsetof(Mach_State, sigContext);
    machSigUserStateOffsetOnStack = offsetof(MachSignalStack, 
        sigContext.machContext.userState);
    machSigTrapInstOffsetOnStack = offsetof(MachSignalStack,
        sigContext.machContext.trapInst);
    machSigNumOffsetInSig = offsetof(Sig_Stack, sigNum);
    machSigAddrOffsetInSig = offsetof(Sig_Stack, sigAddr);
    machSigCodeOffsetInSig = offsetof(Sig_Stack, sigCode);
    machSigPCOffsetOnStack = offsetof(MachSignalStack, 
        sigContext.machContext.pcValue);

    machLastSysCallOffset = offsetof(Mach_State, lastSysCall);

    /*
     * base of the debugger stack
     */
    machDebugStackStart = (unsigned int) mach_DebugStack +
						sizeof (mach_DebugStack);

    /*
     * Initialize the interrupt vector table.
     */
    for (i = 0; i < MACH_NUM_VECTORS; i++) {
#ifndef sun4c
	if (i == 13 || i == 11 || i == 9 || i == 7 || i == 5 || i == 3 ||
		i == 2) {
	    machVectorTable[i] = (Address) MachVectoredInterrupt;
	    /*
	     * Set arg to vme vector address for this trap level.
	     * In the high bits of the address, we want MACH_VME_INTR_VECTOR.
	     * In bits 3 to 1 we want the VME bus level.  We want bit 0 to be
	     * 1.  So, for example, for interrupt level 13, we want to put
	     * VME level7 into bits 3 to 1 and then set bit 0 high.  But this
	     * is equivalent to putting the number 14 into bits 3 to 0 and then
	     * setting bit 0 high.  So this means adding 1 to the interrupt
	     * level and then setting bit 0 high.
	     */
	    machInterruptArgs[i] = (ClientData)
		    (MACH_VME_INTR_VECTOR | ((i + 1) | 1));
	} else { 
#endif
	    machVectorTable[i] = (Address) MachHandleDebugTrap;
	    machInterruptArgs[i] = (ClientData) 0;
#ifndef sun4c
	}
#endif
    }

    /* Temporary: for debugging net module and debugger: */
    mach_NumDisableInterrupts[0] = 1;

#ifdef sun4c
    if (romVectorPtr->v_romvec_version < 2) {
#endif
	/*
	 * Copy the boot parameter structure. The original location will get
	 * unmapped during vm initialization so we need to get our own copy.
	 */
	machMonBootParam = **(romVectorPtr->bootParam);
	offset = (unsigned int) *(romVectorPtr->bootParam) - 
		 (unsigned int) &(machMonBootParam);
	for (i = 0; i < 8; i++) {
	    if (machMonBootParam.argPtr[i] != (char *) 0 &&
	     machMonBootParam.argPtr[i] != (char *) NIL) {
		machMonBootParam.argPtr[i] -= offset;
	    }
	}
#ifdef sun4c
    } 
#endif
#ifndef sun4c
    /*
     * Clear out the line input buffer to the prom so we don't get extra
     * characters at the end of shorter reboot strings.
     */
    bzero((char *)(romVectorPtr->lineBuf), *romVectorPtr->lineSize);
#endif

#ifdef sun4c
    if (Mach_MonSearchProm("*", "clock-frequency",
	    (char *)&machClockRate,
	    sizeof machClockRate) != sizeof machClockRate) {
	panic("Clock rate not found.\n");
    }
    /*
     * Keep clock rate precision to 1 decimal place.
     */
    machClockRate /= 100000;
#ifdef NOTDEF		/* No need to print this stuff. */
    Mach_MonPrintf("PROM: Clock rate is %d.%dMHz\n",
	machClockRate / 10, machClockRate % 10);
#endif /* NOTDEF */

    if (Mach_MonSearchProm("interrupt-enable", "address",
	    (char *)&machInterruptReg,
	    sizeof machInterruptReg) != sizeof machInterruptReg) {
	panic("Interrupt register not found.\n");
    }
#ifdef NOTDEF		/* No need to print this stuff. */
    Mach_MonPrintf("PROM: Interrupt register is at %x\n", machInterruptReg);
#endif /* NOTDEF */

    /*
     * This gets turned on by the profiler init when it is called.
     */
    *Mach_InterruptReg &= ~MACH_ENABLE_LEVEL14_INTR;
#endif
    
    if (recov_Transparent) {
	CheckFastRestart();
    }

    return;
}


/*
 *----------------------------------------------------------------------
 *
 * CheckFastRestart --
 *
 *	Check if enough space was allocated for the fast restart.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static void
CheckFastRestart()
{
    char	*src, *dest;
    int		count;
    extern	int	edata;
    extern	int	etext();

    src =  (char *) &etext;
    dest = (char *) &edata;
    count = (unsigned int) dest - (unsigned int) src;
    if (count > MACH_RESTART_DATA_SIZE) {
	Mach_MonPrintf("Not enough restart space saved for kernel data.\n");
	Mach_MonAbort();
    }

    return;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_GetRestartTableSize --
 *
 *	Return the size allocated for the fast restart table area.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
int
Mach_GetRestartTableSize()
{
    return MACH_RESTART_TABLE_SIZE;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_InitFirstProc --
 *
 *	Initialize the machine state struct for the very first process.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Machine info allocated and stack start set up.
 *
 *----------------------------------------------------------------------
 */
void
Mach_InitFirstProc(procPtr)
    Proc_ControlBlock	*procPtr;
{
    procPtr->machStatePtr = (Mach_State *)Vm_RawAlloc(sizeof(Mach_State));
    bzero((char *)(procPtr->machStatePtr), sizeof (Mach_State));
    procPtr->machStatePtr->kernStackStart = mach_StackBottom;
    procPtr->machStatePtr->trapRegs = (Mach_RegState *) NIL;
    procPtr->machStatePtr->switchRegs = (Mach_RegState *) NIL;
    machCurStatePtr = procPtr->machStatePtr;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_SetupNewState --
 *
 *	Initialize the machine state for this process.  This includes 
 *	allocating and initializing a kernel stack.  Assumed that will
 *	be called when starting a process after a fork or restarting a
 *	process after a migration.
 *
 * Results:
 *	PROC_NO_STACKS if couldn't allocate a kernel stack.  SUCCESS otherwise.
 *
 * Side effects:
 *	Machine state in the destination process control block is overwritten.
 *
 *----------------------------------------------------------------------
 */ 
ReturnStatus
Mach_SetupNewState(procPtr, fromStatePtr, startFunc, startPC, user)
    Proc_ControlBlock	*procPtr;	/* Pointer to process control block
					 * to initialize state for. */
    Mach_State		*fromStatePtr;	/* State of parent on fork or from
					 * other machine on migration. */
    void		(*startFunc)();	/* Function to call when process first
					 * starts executing. */
    Address		startPC;	/* Address to pass as argument to 
					 * startFunc.  If NIL then the address
					 * is taken from *fromStatePtr's 
					 * exception stack. */
    Boolean		user;		/* TRUE if is a user process. */
{
    register	Mach_RegState	*stackPtr;
    register	Mach_State	*statePtr;

    /*
     * If it's a user process forking, we must make sure all its windows have
     * been saved to the stack so that when the register state and the stack
     * are copied to the new process, it will get the real stuff.
     */
    if (user) {
	Mach_DisableIntr();
	Mach_FlushWindowsToStack();
	Mach_EnableIntr();
    }
    if (procPtr->machStatePtr == (Mach_State *)NIL) {
	procPtr->machStatePtr = (Mach_State *)Vm_RawAlloc(sizeof(Mach_State));
    }
    bzero((char *) procPtr->machStatePtr, sizeof (Mach_State));
    statePtr = procPtr->machStatePtr;
    statePtr->trapRegs = (Mach_RegState *)NIL;
    /* 
     * Allocate a kernel stack for this process.
     */
    statePtr->kernStackStart = (Address) Vm_GetKernelStack(0);
    if (statePtr->kernStackStart == (Address)NIL) {
	return(PROC_NO_STACKS);
    }

    /*
     * Pointer to context switch register's save area is also a pointer
     * to the top of the stack, since the regs are saved there.
     * If this is a kernel process, we only need space MACH_SAVED_STATE_FRAME
     * + MACH_FULL_STACK_FRAME, but if it's a user process we need more:
     * (2 * MACH_SAVED_STATE_FRAME).  Both types of processes need the
     * first MACH_SAVED_STATE_FRAME for their context switch regs area.  A
     * kernel process then only needs space under that on its stack for its
     * first routine to store its arguments in its "caller's" stack frame, so
     * this extra space just fakes a caller's stack frame.  But for a user
     * process, we have trap regs.  And these trapRegs get stored under
     * the context switch regs on the kernel stack.
     */
    statePtr->switchRegs = (Mach_RegState *)((statePtr->kernStackStart) +
	    MACH_KERN_STACK_SIZE - (2 * MACH_SAVED_STATE_FRAME));
    statePtr->switchRegs = (Mach_RegState *)
	(((unsigned int)(statePtr->switchRegs)) & ~0x7);  /* should be okay already */
    /*
     * Initialize the stack so that it looks like it is in the middle of
     * Mach_ContextSwitch.
     */
    stackPtr = statePtr->switchRegs;	/* stack pointer is set from this. */
    /*
     * Fp is set to saved window area for window we'll return to.  The area for
     * the window of Mach_ContextSwitch is a Mach_RegState.  Below this on
     * the stack (at higher address than) is the saved window area of the
     * routine we'll return to from Mach_ContextSwitch.  So the fp must be
     * set to the top of this saved window area.
     */
    *((Address *)(((Address)stackPtr) + MACH_FP_OFFSET)) =
	    ((Address)stackPtr) + MACH_SAVED_STATE_FRAME;
    /*
     * We are to return to startFunc from Mach_ContextSwitch, but
     * Mach_ContextSwitch will do a return to retPC + 8, so we subtract
     * 8 from it here to get to the right place.
     */
    *((Address *)(((Address)stackPtr) + MACH_RETPC_OFFSET)) =
	    ((Address)startFunc) - 8;

    /*
     * Set the psr to restore to have traps enabled and interrupts off.
     */
    stackPtr->curPsr = MACH_HIGH_PRIO_PSR;
    /* 
     * Set up the state of the process.  User processes inherit from their
     * parent or the migrated process.  If the PC is not specified, take it
     * from the parent as well.
     */
    if (user) {
	/*
	 * Trap state regs are the same for child process.
	 */
	statePtr->trapRegs = (Mach_RegState *)
		(((Address) stackPtr) + MACH_SAVED_STATE_FRAME);
	bcopy((Address)fromStatePtr->trapRegs, (Address)statePtr->trapRegs,
		sizeof (Mach_RegState));
	/*
	 * Check to see if any register windows were saved to internal buffer
	 * in Mach_FlushWindowsToStack(), above.  If so, copy the buffer state
	 * to the new process, so that when it returns from the fork trap, it
	 * will copy out the saved windows to its stack.
	 */
	if (fromStatePtr->savedMask != 0) {
	    procPtr->specialHandling = 1;
	    statePtr->savedMask = fromStatePtr->savedMask;
	    bcopy((Address) fromStatePtr->savedRegs,
		    (Address) statePtr->savedRegs,
		    sizeof (fromStatePtr->savedRegs));
	    bcopy((Address) fromStatePtr->savedSps,
		    (Address) statePtr->savedSps,
		    sizeof (fromStatePtr->savedSps));
	}
    }
    if (startPC == (Address)NIL) {
	*((Address *)(((Address)stackPtr) + MACH_ARG0_OFFSET)) =
		(Address) fromStatePtr->trapRegs->pc;
    } else {
	/*
	 * The first argument to startFunc is supposed to be startPC.  But that
	 * would be in an in register in startFunc's window which is one before
	 * Mach_ContextSwitch's window.  But startFunc will do a save operation
	 * at the beginning so it will actually be executing in Mach_ContextS's
	 * window, so arg0 to startFunc must actually be arg0 that is restored
	 * at the end of Mach_ContextSwitch, so we have to put it in the in
	 * register area of Mach_RegState area on the stack.  Weird.
	 */
	*((Address *)(((Address)stackPtr) + MACH_ARG0_OFFSET)) = startPC;
    }
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * Mach_SetReturnVal --
 *
 *	Set the return value for a process from a system call.  Intended to
 *	be called by the routine that starts a user process after a fork.
 *	Interrupts must be off here!
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Register D0 is set in the user registers.
 *
 *----------------------------------------------------------------------
 */ 
void
Mach_SetReturnVal(procPtr, retVal, retVal2)
    Proc_ControlBlock	*procPtr;	/* Process to set return value for. */
    int			retVal;		/* Value for process to return. */
    int			retVal2;	/* 2nd Value for process to return. */
{
    if (procPtr->machStatePtr->trapRegs == (Mach_RegState *) NIL ||
	    procPtr->machStatePtr->trapRegs == (Mach_RegState *) 0) {
	return;
    }
    procPtr->machStatePtr->trapRegs->ins[0] = retVal;
    procPtr->machStatePtr->trapRegs->ins[1] = retVal2;
    return;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_StartUserProc --
 *
 *	Start a user process executing for the first time.
 *	Interrupts must be off here!
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Stack pointer and the program counter set for the process and
 *	the current process's image is replaced.
 *
 *----------------------------------------------------------------------
 */
void
Mach_StartUserProc(procPtr, entryPoint)
    Proc_ControlBlock	*procPtr;	/* Process control block for process
					 * to start. */
    Address		entryPoint;	/* Where process is to start
					 * executing. */
{
    register	Mach_State	*statePtr;

    statePtr = procPtr->machStatePtr;
    /*
     * MachRunUserProc will put the values from our trap regs into the actual
     * registers so that we'll be in shape to rett back to user mode.
     */
    Mach_DisableIntr();

    /*
     * Return from trap pc.
     */
    statePtr->trapRegs->pc = (unsigned int) entryPoint;
    statePtr->trapRegs->nextPc = (unsigned int) (entryPoint + 4);

    MachRunUserProc();
    /* THIS DOES NOT RETURN */
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_ExecUserProc --
 *
 *	Replace the calling user process's image with a new one.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Stack pointer set for the process.
 *
 *----------------------------------------------------------------------
 */
void
Mach_ExecUserProc(procPtr, userStackPtr, entryPoint)
    Proc_ControlBlock	*procPtr;		/* Process control block for
						 * process to exec. */
    Address		userStackPtr;		/* Stack pointer for when the
						 * user process resumes 
						 * execution. */
    Address		entryPoint;		/* Where the user process is
						 * to resume execution. */
{
    Mach_RegState	tmpTrapState;

     /*
      * We do not call DISABLE_INTR here because there's an implicit enable
      * of interrupts in MachRunUserProc().
      */
    Mach_DisableIntr();
    machCurStatePtr = procPtr->machStatePtr;
    /*
     * Since we're not returning, we can just use this space on our kernel
     * stack as trapRegs.  This is safe, since we only fill in the fp, tbr,
     * pc, and nextPc fields (in Mach_StartUserProc()) and these just touch
     * the saved-window section of our stack and won't mess up any of our
     * arguments.
     */
    procPtr->machStatePtr->trapRegs = &tmpTrapState;
    /*
     * The user stack pointer gets MACH_FULL_STACK_FRAME subtracted from it
     * so that the user stack has space for its first routine to store its
     * arguments in its caller's stack frame.  (So we create a fake caller's
     * stack frame this way.)
     */
    procPtr->machStatePtr->trapRegs->ins[MACH_FP_REG] = (unsigned int)
	    (userStackPtr - MACH_FULL_STACK_FRAME);
    procPtr->machStatePtr->trapRegs->curPsr = MACH_FIRST_USER_PSR;
    procPtr->machStatePtr->trapRegs->pc = (unsigned int) entryPoint;
    procPtr->machStatePtr->trapRegs->tbr = (unsigned int) machTBRAddr;
    /*
     * Initialized the floating point state.
     */
    procPtr->machStatePtr->fpuStatus = 0;
    /*
     * Return value is cleared for exec'ing user process.  This shouldn't
     * matter since a good exec won't return.
     */
    procPtr->machStatePtr->trapRegs->ins[0] = 0;
    Mach_StartUserProc(procPtr, entryPoint);
    /* THIS DOES NOT RETURN */
}

/*
 *----------------------------------------------------------------------
 *
 * Mach_FreeState --
 *
 *	Free up the machine state for the given process control block.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Free up the kernel stack.
 *
 *----------------------------------------------------------------------
 */
void
Mach_FreeState(procPtr)
    Proc_ControlBlock	*procPtr;	/* Process control block to free
					 * machine state for. */
{

    if (procPtr->machStatePtr->kernStackStart != (Address)NIL) {
	Vm_FreeKernelStack(procPtr->machStatePtr->kernStackStart);
	procPtr->machStatePtr->kernStackStart = (Address)NIL;
    }
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_GetDebugState --
 *
 *	Extract the appropriate fields from the machine state struct
 *	and store them into the debug struct.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Debug struct filled in from machine state struct.
 *
 *----------------------------------------------------------------------
 */ 
void
Mach_GetDebugState(procPtr, debugStatePtr)
    Proc_ControlBlock	*procPtr;
    Proc_DebugState	*debugStatePtr;
{
    register	Mach_State	*machStatePtr;

    machStatePtr = procPtr->machStatePtr;
    bcopy((Address)machStatePtr->trapRegs,
	      (Address)(&debugStatePtr->regState), sizeof(Mach_DebugState));
    return;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_SetDebugState --
 *
 *	Extract the appropriate fields from the debug struct
 *	and store them into the machine state struct.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Machine state struct filled in from the debug state struct.
 *
 *----------------------------------------------------------------------
 */ 
void
Mach_SetDebugState(procPtr, debugStatePtr)
    Proc_ControlBlock	*procPtr;
    Proc_DebugState	*debugStatePtr;
{
    register	Mach_State	*machStatePtr;

/* y, pc's g1-g7 all in's*/
    machStatePtr = procPtr->machStatePtr;
    machStatePtr->trapRegs->pc = debugStatePtr->regState.pc;
    machStatePtr->trapRegs->nextPc = debugStatePtr->regState.nextPc;
    machStatePtr->trapRegs->y = debugStatePtr->regState.y;
    bcopy((Address)debugStatePtr->regState.ins,
	    (Address)machStatePtr->trapRegs->ins, MACH_NUM_INS * sizeof (int));
    bcopy((Address)debugStatePtr->regState.globals,
	    (Address)machStatePtr->trapRegs->globals,
	    MACH_NUM_GLOBALS * sizeof (int));
    return;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_InitSyscall --
 *
 *	During initialization, this procedure is called once for each
 *	kernel call, in order to set up information used to dispatch
 *	the kernel call.  This procedure must be called once for each
 *	kernel call, in order starting at 0.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Initializes the dispatch tables for the kernel call.
 *
 *----------------------------------------------------------------------
 */
void
Mach_InitSyscall(callNum, numArgs, normalHandler, migratedHandler)
    int callNum;			/* Number of the system call. */
    int numArgs;			/* Number of one-word arguments passed
					 * into call on stack. */
    ReturnStatus (*normalHandler)();	/* Procedure to process kernel call
					 * when process isn't migrated. */
    ReturnStatus (*migratedHandler)();	/* Procedure to process kernel call
					 * for migrated processes. */
{
    machMaxSysCall++;
    if (machMaxSysCall != callNum) {
	printf("Warning: out-of-order kernel call initialization, call %d\n",
	       callNum);
    }
    if (machMaxSysCall >= SYS_NUM_SYSCALLS) {
	printf("Warning: too many kernel calls.\n");
	machMaxSysCall--;
	return;
    }
    if (numArgs > SYS_MAX_ARGS) {
	printf("Warning: too many arguments to kernel call %d\n", callNum);
	numArgs = SYS_MAX_ARGS;
    }
    /*
     * Offset of beginning of args on stack - offset from frame pointer.
     * Figure out offset  from fp of params past the sixth.
     * It copies from last arg to first
     * arg in that order, so we start offset at bottom of last arg.
     */
    /*
     * TURN THESE INTO PROPER CONSTANTS!
     */
    /*
     * We copy going towards higher addresses, rather than lower, as the sun3
     * does it.  So our offset is at top of extra parameters to copy, and not
     * below them (stack-wise speaking, not address-wise speaking).
     */
    machArgOffsets[machMaxSysCall] = MACH_SAVED_WINDOW_SIZE +
	    MACH_ACTUAL_HIDDEN_AND_INPUT_STORAGE;
	
    /*
     * Where to jump to in fetching routine to copy the right amount from
     * the stack.  The fewer args we have, the farther we jump...  Figure out
     * how many are in registers, then do rest from stack.  There's instructions
     * to copy 10 words worth, for now, since 6 words worth of arguments are
     * in the input registers.  If this number changes, change machTrap.s
     * and the jump offset below!
     */
    if (numArgs <= 6) {
	machArgDispatch[machMaxSysCall] =  (Address) MachFetchArgsEnd;
    } else {
	machArgDispatch[machMaxSysCall] = (10 - (numArgs - 6))*16 +
		((Address)MachFetchArgs);
    }
    mach_NormalHandlers[machMaxSysCall] = normalHandler;
    mach_MigratedHandlers[machMaxSysCall] = migratedHandler;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_SetHandler --
 *
 *	This is used both for autovectored devices and for regular interrupt
 *	routines for device interrupt levels.  For autovectored devices,
 *	the routine MachVectoredInterrupt will already have been installed
 *	for the auto-vectored interrupt levels.  Then this routine should be
 *	be called with the interrrupt vector for the device and its
 *	real interrupt handler.  For non-autovectored interrupt handlers, the
 *	handler should just be installed with a vector that is the
 *	device's interrupt level.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     The exception vector table is modified.
 *
 * ----------------------------------------------------------------------------
 */
void
Mach_SetHandler(vectorNumber, handler, clientData)
    int vectorNumber;		/* Vector number that the device generates */
    int (*handler)();		/* Interrupt handling procedure */
    ClientData	clientData;	/* ClientData for interrupt callback routine. */
{

    if (vectorNumber < 0 || vectorNumber > 255) {
	panic("Warning: Bad vector number %d\n", vectorNumber);
    } else {
	machVectorTable[vectorNumber] = (Address) handler;
	machInterruptArgs[vectorNumber] = (ClientData) clientData;
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 * Routines to set up and return from signal handlers.
 *
 * In order to call a handler four things must be done:
 *
 *	1) The current state of the process must be saved so that when
 *	   the handler returns a normal return to user space can occur.
 *	2) The user stack must be set up so that the signal number and the
 *	   the signal code are passed to the handler.
 *	3) Things must be set up so that when the handler returns it returns
 *	   back into the kernel so that state can be cleaned up.
 *	4) The trap stack that was created when the kernel was entered and is
 *	   used to return a process to user space must be modified so that
 *	   the signal handler is called instead of executing the
 *	   normal return.
 *
 * The last one is done by simply changing the program counter where the
 * user process will execute on return to be the address of the signal
 * handler and the user stack pointer to point to the proper place on
 * the user stack.  The first three of these are accomplished by 
 * setting up the user stack properly.  The top entry on the stack is the
 * return address where the handler will start executing upon return.  But 
 * this is just the address of a trap instruction that is stored on the stack
 * below.  Thus when a handler returns it will execute a trap instruction 
 * and drop back into the kernel. 
 */


/*
 * ----------------------------------------------------------------------------
 *
 * MachCallSigReturn --
 *
 *      Process a return from a signal handler.  Call the Sig_Return
 *	routine with appropriate args.
 *	
 * Results:
 *      None.
 *
 * Side effects:
 *	Whatever Sig_Return does.
 *
 * ----------------------------------------------------------------------------
 */
void
MachCallSigReturn()
{
    Proc_ControlBlock	*procPtr;
    Mach_State		*statePtr;
    Sig_Stack		*sigStackPtr;

    procPtr = Proc_GetCurrentProc();
    statePtr = procPtr->machStatePtr;

    sigStackPtr = &(statePtr->sigStack);
    sigStackPtr->contextPtr = &(statePtr->sigContext);

    /*
     * Take the proper action on return from a signal.
     */
    Sig_Return(procPtr, sigStackPtr);
}


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_ProcessorState --
 *
 *	Determines what state the processor is in.
 *
 * Results:
 *	MACH_USER	if was at user level
 *	MACH_KERNEL	if was at kernel level
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
/*ARGSUSED*/
Mach_ProcessorStates 
Mach_ProcessorState(processor)
    int processor;	/* processor number for which info is requested */
{
    if (mach_KernelMode) {
	return(MACH_KERNEL);
    } else {
	return(MACH_USER);
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_GetMachineArch --
 *
 *	Return the machine architecture (SYS_SUN2 or SYS_SUN3).
 *
 * Results:
 *	The machine architecture.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
int
Mach_GetMachineArch()
{
#       ifdef sun2
	return SYS_SUN2;
#       endif sun2

#       ifdef sun3
	return SYS_SUN3;
#       endif sun3

#	ifdef sun4
	return SYS_SUN4;
#	endif sun4
}

/*
 * ----------------------------------------------------------------------------
 *
 *  Mach_CheckSpecialHandling--
 *
 *	Forces a processor to check the special handling flag of a process.
 *	This should only be called on a multiprocessor.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
void
Mach_CheckSpecialHandling(pnum)
    int		pnum;		/* Processor number. */
{
    panic("Mach_CheckSpecialHandling called for processor %d\n",pnum);
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_GetNumProcessors() --
 *
 *	Return the number of processors in the system.  NOTE: This should
 *	really be in a machine-independent area of the mach module.  Note
 *	further: if this is used only as a system call, it should return
 *	a ReturnStatus!
 *
 * Results:
 *	The number of processors is returned.  
 *
 * Side effects:
 *	None
 *
 *----------------------------------------------------------------------
 */

int
Mach_GetNumProcessors()
{
	return (mach_NumProcessors);
}



/*
 *----------------------------------------------------------------------
 *
 * MachPageFault() -
 *
 *	Handle a page fault.
 *
 * Results:
 *	None
 *
 * Side effects:
 *	A page causing a memory access error is made valid.  If it's an
 *	illegal page fault in the kernel, we will call panic.
 *
 *----------------------------------------------------------------------
 */
void
MachPageFault(busErrorReg, addrErrorReg, trapPsr, pcValue)
    unsigned	int	busErrorReg;
    Address		addrErrorReg;
    unsigned	int	trapPsr;
    Address		pcValue;
{
    Proc_ControlBlock	*procPtr;
    Boolean		protError;
    Boolean		copyInProgress = FALSE;
    ReturnStatus	status;
    extern		int	VmMachQuickNDirtyCopy();
    extern		int	VmMachEndQuickCopy();

    /*
     * Are we in quick cross-context copy routine?  If so, we can't page fault
     * in it.
     */
    if ((pcValue >= (Address) VmMachQuickNDirtyCopy) &&
	    (pcValue < (Address) VmMachEndQuickCopy)) {
	/*
	 * This doesn't return to here.  It erases the fact that the
	 * page fault happened and makes the copy routine that
	 * got the page fault return FAILURE to its caller.  We must turn off
	 * interrupts before calling MachHandleBadQuickCopy().
	 */
	Mach_DisableIntr();
	MachHandleBadQuickCopy();
	Mach_EnableIntr();
    }
    /*
     * Are we poking at or peeking into memory-mapped devices?
     * We must check this before looking for the current process, since this
     * can happen during boot-time before we have set up processes.
     */
    if ((pcValue >= (Address) MachProbeStart)  &&
	    (pcValue < (Address) MachProbeEnd)) {
	/*
	 * This doesn't return to here.  It erases the fact that the
	 * page fault happened and makes the probe routine that
	 * got the page fault return FAILURE to its caller.  We must turn off
	 * interrupts before calling MachHandleBadProbe().
	 */
	Mach_DisableIntr();
	MachHandleBadProbe();
	Mach_EnableIntr();
    }
#ifdef sun4
    /*
     * On the sun4/200 with the Jaguar HBA we get VME timeout errors from 
     * the board. This code retries the error up to 100000 times before droping
     * into the code below which panics. 
     * These errors happen a lot with the RAID HPPI boards, so we disable
     * the printout.
     */
    {
	static timeoutRetryCount = 0;
	extern void MachVectoredInterruptLoad();

	if ((trapPsr & MACH_PS_BIT) && (busErrorReg&MACH_TIMEOUT_ERROR)) {
	    /*
	     * If the error occurred on a the load of the interrupt
	     * vector make the routine return.
	     */
	    if (pcValue == (Address) MachVectoredInterruptLoad) {
		/*
		 * This doesn't return to here.  It erases the fact that the
		 * page fault happened and makes the MachVectoredInterrupt
		 * routine that got the page fault return FAILURE 
		 * to its caller.  
		 */
		Mach_MonPrintf(
"MachPageFault: Bus timeout error on VME interrupt vector load pc:0x%x, addr:0x%x\n",
		     pcValue, addrErrorReg);
		MachHandleBadQuickCopy();
	    }
#if 0
	    Mach_MonPrintf(
 "MachPageFault: Bus timeout error retry %d at pc:0x%x, addr:0x%x\n",
		    timeoutRetryCount, pcValue, addrErrorReg);
#endif
	    if (timeoutRetryCount < 1000000) {
		timeoutRetryCount++;
		return;
	    }
	}
	timeoutRetryCount = 0;
    }
    /* We used to enable interrupts before we called this routine, but we
     * don't want them enabled if it is a VME bus timeout, so we enable them
     * now */
    Mach_EnableIntr();
#endif /* sun4 */

    procPtr = Proc_GetActualProc();
    if (procPtr == (Proc_ControlBlock *) NIL) {
	panic(
	"MachPageFault: Current process is NIL!!  Trap pc is 0x%x, addr 0x%x\n",
		(unsigned) pcValue, addrErrorReg);
    }
    /* process kernel page fault */
    if (trapPsr & MACH_PS_BIT) {		/* kernel mode before trap */
	if (!(procPtr->genFlags & PROC_USER)) {
	    /*
	     * This fault happened inside the kernel and it wasn't on behalf
	     * of a user process.  This is an error.
	     */
	    panic(
"MachPageFault: page fault in kernel process! pc:0x%x, addr:0x%x, Error:0x%x\n",
		    pcValue, addrErrorReg, busErrorReg);
	}
	/*
	 * A page fault on a user process while executing in
	 * the kernel.  This can happen when information is
	 * being copied back and forth between kernel and user state
	 * (indicated by particular values of the program counter).
	 */
	if ((pcValue >= (Address) Vm_CopyIn) &&
		(pcValue < (Address) VmMachCopyEnd)) {
	    copyInProgress = TRUE;
	} else if ((pcValue >= (Address) MachFetchArgs) &&
		(pcValue <= (Address) MachFetchArgsEnd)) {
	    copyInProgress = TRUE;
	} else if (procPtr->vmPtr->numMakeAcc == 0) {
	    /*
	     * ERROR: pc faulted in a bad place!
	     */
	    panic(
	    "MachPageFault: kernel page fault at illegal pc: 0x%x, addr 0x%x\n",
		    pcValue, addrErrorReg);
	}
	protError = (busErrorReg & MACH_PROT_ERROR);
	/*
	 * Try to fault in the page.
	 */
	status = Vm_PageIn(addrErrorReg, protError);
	if (status != SUCCESS) {
	    if (copyInProgress) {
		/*
		 * This doesn't return to here.  It erases the fact that the
		 * page fault happened and makes the copy routine that
		 * got the page fault return SYS_ARG_NO_ACCESS to its caller.
		 * We must turn off interrupts before calling
		 * MachHandleBadArgs().
		 */
		Mach_DisableIntr();
		MachHandleBadArgs();
		Mach_EnableIntr();
	    } else {
		/* kernel error */
		panic(
	    "MachPageFault: couldn't page in kernel page at 0x%x, pc 0x%x\n",
			addrErrorReg, pcValue);
	    }
	}
	return;
    }
    /* user page fault */
    protError = busErrorReg & MACH_PROT_ERROR;
    if (Vm_PageIn(addrErrorReg, protError) != SUCCESS) {
	printf(
    "MachPageFault: Bus error in user proc %x, PC = %x, addr = %x BR Reg %x\n",
#ifdef sun4c
		procPtr->processID, pcValue, addrErrorReg, busErrorReg);
#else
		procPtr->processID, pcValue, addrErrorReg, (short) busErrorReg);
#endif
	/* Kill user process */
	Sig_Send(SIG_ADDR_FAULT, SIG_ACCESS_VIOL, procPtr->processID, FALSE,
	       (Address)addrErrorReg);
	return;
    }
    return;
}


/*
 *----------------------------------------------------------------------
 *
 * MachUserAction() -
 *
 *	Check what sort of user-process action is needed.  We already know
 *	that some sort of action is needed, since the specialHandling flag
 *	should be checked before calling this routine.  The possible actions
 *	are to take a context switch, to push saved user windows from the mach
 *	state structure out to the user stack, or to set things up to handle
 *	pending signals.  We assume traps are enabled before this routine is
 *	called.
 *
 * Results:
 *	The return value 0 indicates we have no pending signal.
 *	The return value 1 indicates we have a pending Sprite signal.
 *	The return value 2 indicates we have a pending Unix signal.
 *
 * Side effects:
 *	The mach state structure may change, especially the mask that indicates
 *	which windows were saved into the internal buffer.
 *
 *----------------------------------------------------------------------
 */
int
MachUserAction()
{
    Proc_ControlBlock	*procPtr;
    Mach_State		*machStatePtr;
    Sig_Stack		*sigStackPtr;
    Address		pc;
    int			unixSignal;
    int			restarted=0;

    procPtr = Proc_GetCurrentProc();
    if (procPtr->unixProgress != PROC_PROGRESS_NOT_UNIX &&
            procPtr->unixProgress != PROC_PROGRESS_UNIX && debugProcStubs) {
        printf("UnixProgress = %d entering MachUserReturn\n",
		procPtr->unixProgress);
    }

HandleItAgain:
    if (procPtr->Prof_Scale != 0 && procPtr->Prof_PC != 0) {
	Prof_RecordPC(procPtr);
    }
    procPtr->specialHandling = 0;
    /*
     * Take a context switch if one is pending for this process.
     * If other stuff, such as flushing the windows to the stack needs to
     * be done, it will happen when the process is switched back in again.
     * We came from MachReturnFromTrap, where interrupts were off, so we
     * must turn them on.
     */
    Mach_EnableIntr();
    if (procPtr->schedFlags & SCHED_CONTEXT_SWITCH_PENDING) {
	Sched_LockAndSwitch();
    }

    machStatePtr = procPtr->machStatePtr;

    /*
     * Save the windows that were stored in internal buffers to the user stack.
     * The windows were saved to internal buffers due to the user stack not
     * being resident.  The overflow handler can't take page faults, but
     * we can.
     */
    if (machStatePtr->savedMask != 0) {
	int	i;

	for (i = 0; i < MACH_NUM_WINDOWS; i++) {
	    if ((1 << i) & machStatePtr->savedMask) {
		/*
		 * Clear the mask for this window.  We must turn off interrupts
		 * to do this, since changing the savedMask must be an
		 * atomic operation.  If it weren't, and an interrupt came
		 * in that caused us to save some other window to the stack
		 * after we have read the savedMask, we would overwrite the
		 * fact when storing the saved Mask...
		 */
		Mach_DisableIntr();
		machStatePtr->savedMask &= ~(1 << i);
		Mach_EnableIntr();
		/*
		 * Push the window to the stack.
		 */ 
		if (Vm_CopyOut(MACH_SAVED_WINDOW_SIZE,
			(Address)(machStatePtr->savedRegs[i]),
			(Address)(machStatePtr->savedSps[i])) != SUCCESS) {
		    printf("MachUserAction: pid 0x%x being killed: %s 0x%x.\n",
			    procPtr->processID, "bad stack pointer?",
			    machStatePtr->savedSps[i]);
		    Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
		}
	    }
	}
    }
    /*
     * We must check again here to see if the specialHandling flag has been
     * set again.  We've been taking interrupts this whole time, and the
     * Vm code above may have called deeply, so we may have saved further
     * user windows to internal buffers.  If we have, go back up to the
     * beginning of the routine, and do this all again.
     */

    /*
     * For now, we also flush all the windows to make sure the signal-handling
     * stuff below won't cause us to save windows to internal buffers.  This
     * is a slow thing to do, but it is currenlty unclear what to do if
     * the signal handler causes a window to get saved to an internal buffer.
     * It will have to call some sort of MachUserAction-type routine itself
     * in that case.
     */
    Mach_DisableIntr();
    Mach_FlushWindowsToStack();
    if (procPtr->specialHandling != 0) {
	goto HandleItAgain;
    }
    Mach_EnableIntr();
    /*
     * Check for floating point problems.
     */
    if (machStatePtr->fpuStatus & MACH_FPU_EXCEPTION_PENDING) {
	HandleFPUException(procPtr, machStatePtr);
    }
    /*
     * Now check for signal stuff. We must check again for floating
     * point exception because the Sig_Handle might do a context switch
     * during which the excpetion would get posted. 
     * 
     * Note: This is really wrong.  We should check for and process 
     * any floating point exceptions before  handling a signal. 
     * The problem here is by the time Sig_Handle returns we are
     * already committed to doing this signal.
     */
    sigStackPtr = &(machStatePtr->sigStack);
    sigStackPtr->contextPtr = &(machStatePtr->sigContext);
    if (procPtr->unixProgress == PROC_PROGRESS_RESTART ||
	    procPtr->unixProgress > 0) {
	/*
	 * If we received a normal signal, we want to restart
	 * the system call when we leave.
	 * If we received a migrate signal, we will get here on
	 * the new machine.
	 * We must also ensure that the argument registers are the
	 * same as when we came in.
	 */
	restarted = 1;
	if (debugProcStubs) {
	    printf("Restarting system call with progress %d\n",
		    procPtr->unixProgress);
	}
	procPtr->unixProgress = PROC_PROGRESS_UNIX;
    }
    if (Sig_Handle(procPtr, sigStackPtr, &pc)) {
	machStatePtr->sigContext.machContext.pcValue = pc;
	machStatePtr->sigContext.machContext.trapInst = MACH_SIG_TRAP_INSTR;
	/* leave interrupts disabled */
	if (machStatePtr->fpuStatus & MACH_FPU_EXCEPTION_PENDING) {
	    HandleFPUException(procPtr, machStatePtr);
	}
	Mach_DisableIntr();
	if (procPtr->unixProgress != PROC_PROGRESS_NOT_UNIX) {
	    /*
	     * We have to build a proper Unix signal stack.
	     */
	    int n[16];
	    struct sigcontext	unixContext;
	    procPtr->unixProgress = PROC_PROGRESS_UNIX;
	    if (Compat_SpriteSignalToUnix(sigStackPtr->sigNum,
		    &unixSignal) != SUCCESS) {
		printf("Signal %d invalid in SetupSigHandler\n",
			sigStackPtr->sigNum);
		return 0;
	    }

	    if (restarted) {
		if (debugProcStubs) {
		    printf("Moving PC to restart system call (doing signal\n");
		}
		machStatePtr->trapRegs->nextPc = machStatePtr->trapRegs->pc;
		machStatePtr->trapRegs->pc = machStatePtr->trapRegs->nextPc-4;
		/*
		 * We need to restore %o0 which got clobbered by
		 * the system call.
		 */
		machStatePtr->trapRegs->ins[0] = machStatePtr->savedArgI0;
	    }

	    if (debugProcStubs) {
		printf("Unix signal %d(%d) to %x\n", sigStackPtr->sigNum,
			unixSignal, procPtr->processID);
	    }
	    sigStackPtr->sigNum = unixSignal;
	    unixContext.sc_onstack = 0;
	    unixContext.sc_mask = machStatePtr->sigContext.oldHoldMask;
	    unixContext.sc_sp = machStatePtr->trapRegs->ins[6];
	    /*
	     * pc and npc are where to continue the interrupted routine.
	     */
	    if (debugProcStubs) {
		printf("PSR = %x\n", machStatePtr->trapRegs->curPsr);
	    }
	    unixContext.sc_pc = machStatePtr->trapRegs->pc;
	    unixContext.sc_npc = machStatePtr->trapRegs->nextPc;
	    if (debugProcStubs) {
		printf("trapRegs->pc=%x, trapRegs->npc=%x, context.pcValue=%x\n",
			machStatePtr->trapRegs->pc, machStatePtr->trapRegs->nextPc,
			machStatePtr->sigContext.machContext.pcValue);
	    }
	    unixContext.sc_psr = machStatePtr->trapRegs->curPsr;
	    unixContext.sc_g1 = machStatePtr->trapRegs->globals[1];
	    unixContext.sc_o0 = machStatePtr->trapRegs->ins[0];
	    /*
	     * machContext.pcValue is the address of the handler.
	     */
	    machStatePtr->trapRegs->pc = (unsigned int)
		    machStatePtr->sigContext.  machContext.pcValue;
	    machStatePtr->trapRegs->nextPc = (unsigned int)
		    machStatePtr->sigContext.machContext.pcValue+4;
	    if (debugProcStubs) {
		printf("new pc = %x\n", machStatePtr->trapRegs->nextPc);
	    }
	    /*
	     * Copy the window to the signal stack.
	     */
	    Vm_CopyIn(16*sizeof(int), (Address)unixContext.sc_sp, (Address)n);
	    if (debugProcStubs) {
		printf("Regs: %x %x %x, %x %x %x\n", n[0], n[1], n[2], n[8],
			n[9], n[10]);
	    }
	    machStatePtr->trapRegs->ins[6] += MACH_SAVED_WINDOW_SIZE;
	    unixContext.sc_wbcnt = 0;
	    sigStackPtr->contextPtr = (Sig_Context *)
		    (unixContext.sc_sp-sizeof(struct sigcontext));
	    if (Vm_CopyOut(MACH_SAVED_WINDOW_SIZE,
		    (Address)n,
		    (Address)unixContext.sc_sp - sizeof(struct sigcontext)
			    - 4*sizeof(int) - MACH_SAVED_WINDOW_SIZE) !=
			    SUCCESS) {
		return 0;
	    }
	    if (debugProcStubs) {
		printf("Copied window to %x\n",
			(Address)unixContext.sc_sp - sizeof(struct sigcontext)
				- 4*sizeof(int) - MACH_SAVED_WINDOW_SIZE);
	    }
	    /*
	     * Copy the sigStack and sigContext to the signal window.
	     */
	    if (Vm_CopyOut(4*sizeof(int), (Address)sigStackPtr,
		    (Address)unixContext.sc_sp - sizeof(struct sigcontext)
			    - 4*sizeof(int)) != SUCCESS) {
		return 0;
	    }
	    if (Vm_CopyOut(sizeof(struct sigcontext), (Address)&unixContext,
		    (Address)unixContext.sc_sp - sizeof(struct sigcontext))
			    != SUCCESS) {
		return 0;
	    }
	    return 2;
	} else {
	    return 1;
	}
    } else {
	if (procPtr->unixProgress == PROC_PROGRESS_MIG_RESTART ||
                    procPtr->unixProgress == PROC_PROGRESS_RESTART) {
	    restarted = 1;
	    if (debugProcStubs) {
		printf("No signal action, so we restarted call\n");
	    }
	    procPtr->unixProgress = PROC_PROGRESS_UNIX;
	} else if (restarted && debugProcStubs) {
	    printf("No signal, yet we restarted system call!\n");
	}
    }

    if (machStatePtr->fpuStatus & MACH_FPU_EXCEPTION_PENDING) {
	HandleFPUException(procPtr, machStatePtr);
    }
    /*
     * It is possible for Sig_Handle to mask the migration signal
     * if a process is not in a state where it can be migrated.
     * As soon as we return to user mode, though, we will allow migration.
     * Clear the bit anytime something's pending, for simplicity.
     */
    if (procPtr->sigPendingMask) {
	Sig_AllowMigration(procPtr);
    }

    if (restarted) {
	if (debugProcStubs) {
	    printf("Moving PC to restart system call (no signal\n");
	}
	machStatePtr->trapRegs->nextPc = machStatePtr->trapRegs->pc;
	machStatePtr->trapRegs->pc = machStatePtr->trapRegs->nextPc-4;
	/*
	 * We need to restore %o0 which got clobbered by
	 * the system call.
	 */
	machStatePtr->trapRegs->ins[0] = machStatePtr->savedArgI0;
	procPtr->unixProgress = PROC_PROGRESS_UNIX;
    }

    if (procPtr->unixProgress != PROC_PROGRESS_NOT_UNIX &&
            procPtr->unixProgress != PROC_PROGRESS_UNIX && debugProcStubs) {
        printf("UnixProgress = %d leaving MachUserReturn\n",
		procPtr->unixProgress);
    }

    /*
     * Go back to MachReturnFromTrap.  We are expected to have interrupts
     * off there.
     */
    Mach_DisableIntr();
	
    return 0;
}


/*
 *----------------------------------------------------------------------
 *
 * MachHandleTrap --
 *
 *	Handle an instruction trap, such as an illegal instruction trap,
 *	an unaligned address, or a floating point problem.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If it occured in the kernel, we panic.  If it occured in a user
 *	program, we take appropriate signal action.
 *
 *----------------------------------------------------------------------
 */
void
MachHandleTrap(trapType, pcValue, trapPsr)
    int			trapType;
    Address		pcValue;
    unsigned	int	trapPsr;
{
    Proc_ControlBlock	*procPtr;

    /*
     * Find the current process.  If we took a MACH_FP_EXCEP at one of the
     * marked FPU sync instructions, then we use the process saved
     * in machFPUSaveProcPtr.
     */
    procPtr = ((trapType == MACH_FP_EXCEP) && 
	       (pcValue == (Address) machFPUSyncInst)) ?
		   machFPUSaveProcPtr : Proc_GetCurrentProc();
    if ((procPtr == (Proc_ControlBlock *) NIL)) {
	    printf("%s: pc = 0x%x, trapType = %d\n",
		"MachHandleTrap", pcValue, trapType);
	    panic("Current process was NIL!\n");
    }
    /*
     * Handle kernel-mode traps.
     */
    if (trapPsr & MACH_PS_BIT) {
	switch (trapType) {
	case MACH_ILLEGAL_INSTR:
	    printf("%s %s\n", "MachHandleTrap: illegal",
		    "instruction trap in the kernel!");
	    break;
	case MACH_PRIV_INSTR:
	    printf("%s %s\n", "MachHandleTrap: privileged",
		    "instruction trap in the kernel!");
	    break;
	case MACH_MEM_ADDR_ALIGN:
	    printf("%s %s\n", "MachHandleTrap: unaligned",
		    "address trap in the kernel!");
	    break;
	case MACH_TAG_OVERFLOW:
	    printf("%s %s\n", "MachHandleTrap: tag",
		    "overflow trap in the kernel!");
	    break;
	case MACH_FP_EXCEP: {
#ifndef NO_FLOATING_POINT
	    /*
	     * We got a FP execption while running in kernel mode. If this
	     * exception occured at a known location we clear the
	     * exception and mark the Mach_State.
	     */
	    if (pcValue == (Address) machFPUDumpSyncInst) {
		/*
		 * Already doing a MachFPUDumpState.  Whoever's doing the
		 * dump should check the pending flag and set fpuStatus if
		 * it's set.
		 */
		procPtr->machStatePtr->fpuStatus |=
		    MACH_FPU_EXCEPTION_PENDING;
		return;
	    }
	    if (pcValue == (Address) machFPUSyncInst) {
		  MachFPUDumpState(procPtr->machStatePtr->trapRegs);
		  procPtr->machStatePtr->fpuStatus |= 
		      (procPtr->machStatePtr->trapRegs->fsr
					& MACH_FSR_TRAP_TYPE_MASK) |
			  MACH_FPU_EXCEPTION_PENDING;
		  procPtr->specialHandling = 1;
		  return;
	    } 
	    printf("%s. ",
	"MachHandleTrap: FPU exception from kernel process.");
	    break;
#else /* NO_FLOATING_POINT */
	    printf("Floating point op in kernel code: not supported in this\n");
	    panic("kernel due to copyright reasons.");
#endif /* NO_FLOATING_POINT */
	}
	case MACH_FP_DISABLED:
	    printf("%s %s\n", "MachHandleTrap: fp unit",
		    "disabled trap in the kernel!");
	    break;
	default:
	    printf("%s %s\n", "MachHandleTrap: hit default",
		    "in case statement - bad trap instruction called us!");
	    break;
	}
	panic("%s %s %s %x %s %x\n",
		"MachHandleTrap: the error occured in a",
		procPtr->genFlags & PROC_USER ? "user" : "kernel",
		"process, with procPtr =", (unsigned int) procPtr,
		"and pc =", pcValue);
    }
    /*
     * The trap occured in user-mode.
     */
    switch (trapType) {
    case MACH_ILLEGAL_INSTR:
	(void) Sig_Send(SIG_ILL_INST, SIG_ILL_INST_CODE, procPtr->processID,
		FALSE, pcValue);
	break;
    case MACH_PRIV_INSTR:
	(void) Sig_Send(SIG_ILL_INST, SIG_PRIV_INST, procPtr->processID,
		FALSE, pcValue);
	break;
    case MACH_MEM_ADDR_ALIGN:
	(void) Sig_Send(SIG_ADDR_FAULT, SIG_ADDR_ERROR, procPtr->processID,
		FALSE, (Address)0);
	break;
    case MACH_FP_EXCEP: {
         unsigned int fsr;
	 /*
	  * An FP exception from user mode.  Clear the exception and 
	  * mark it in the Mach_State struct.  
	  * 
	  */
	 MachFPUDumpState(procPtr->machStatePtr->trapRegs);
	 fsr = procPtr->machStatePtr->trapRegs->fsr;
	 if (!(procPtr->machStatePtr->fpuStatus & MACH_FPU_ACTIVE)) {
		 printf(
"FPU exception from process without MACH_FPU_ACTIVE, fsr = 0x%x\n",fsr);
	 }
	 procPtr->machStatePtr->fpuStatus |= (fsr & MACH_FSR_TRAP_TYPE_MASK) |
					    MACH_FPU_EXCEPTION_PENDING;
	 procPtr->specialHandling = 1;
	 break;
	}
    case MACH_FP_DISABLED: {
	register Mach_State 	*machStatePtr;

	Mach_FlushWindowsToStack();
	machStatePtr = procPtr->machStatePtr;
	/*
	 * Upon a user's first FPU disable trap we initialize and enable
	 * the FPU for him. 
	 */
	if (machStatePtr->fpuStatus & MACH_FPU_ACTIVE) {
	    panic("Double FPU_DISABLE trap.\n");
	}
	machStatePtr->fpuStatus = MACH_FPU_ACTIVE;
	/*
	 * Enable the FPU in the trap PSR.
	 */
	machStatePtr->trapRegs->curPsr |= MACH_ENABLE_FPP;
	/*
	 * Initialize the FPU registers. 
	 */
	machStatePtr->trapRegs->fsr = 0;
	bzero((Address) (machStatePtr->trapRegs->fregs), MACH_NUM_FPS*4);
	MachFPULoadState(machStatePtr->trapRegs);
	break;
	}
    case MACH_TAG_OVERFLOW:
	panic("%s %s\n", "MachHandleTrap: tag",
		"overflow trap in user process, but I don't deal with it yet.");
	break;
    default:
	panic("%s %s\n", "MachHandleTrap: hit default",
		"in case statement - bad trap instruction from user mode.");
	break;

    }
    return;
}


/*
 *----------------------------------------------------------------------
 *
 * FlushTheWindows --
 *
 *	A recursive C routine that will force window overflows and thereby
 *	flush the register windows to the stack.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The register windows are flushed.
 *
 *----------------------------------------------------------------------
 */
static void
FlushTheWindows(num)
    int	num; 
{
    num--;
    if (num > 0) {
	FlushTheWindows(num);
    }
    return;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_FlushWindowsToStack --
 *
 *	Calls a routine to flush the register windows to the stack.
 *	This routine can be caled from traps, or wherever.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The register windows are flushed.
 *
 *----------------------------------------------------------------------
 */
void
Mach_FlushWindowsToStack()
{
    /*
     * We want to do NWINDOWS - 1 saves and then restores to make sure all our
     * register windows have been saved to the stack.  Calling here does one
     * save, so we want to do NWINDOWS - 2 more calls and returns.
     */
    FlushTheWindows(MACH_NUM_WINDOWS - 2);
    return;
}


/*
 *----------------------------------------------------------------------
 *
 * MachUserDebug --
 *
 *	This will cause the current process to go into the debugger.  It can
 *	be called from trap handlers, etc.  It first checks to see if the
 *	current process is NIL.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The process gets a breakpoint signal.
 *
 *----------------------------------------------------------------------
 */
void
MachUserDebug()
{
    Proc_ControlBlock	*procPtr; 

    procPtr = Proc_GetCurrentProc();
    if (procPtr == (Proc_ControlBlock *) NIL) {
	panic("MachUserDebug: current process was NIL!\n");
    }
    Sig_Send(SIG_BREAKPOINT, SIG_NO_CODE, procPtr->processID, FALSE,
	    (Address)0);
    return;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_GetBootArgs --
 *
 *	Returns the arguments out of the boot parameter structure. 
 *
 * Results:
 *	Number of elements returned in argv.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Mach_GetBootArgs(argc, bufferSize, argv, buffer)
	int	argc;			/* Number of elements in argv */
	int	bufferSize;		/* Size of buffer */
	char	**argv;			/* Ptr to array of arg pointers */
	char	*buffer;		/* Storage for arguments */
{
#ifdef sun4c
    if (romVectorPtr->v_romvec_version < 2) {
#endif
	int		i;
	int		offset;
	bcopy(machMonBootParam.strings, buffer, 
	      (bufferSize < 100) ? bufferSize : 100);
	offset = (unsigned int) machMonBootParam.strings -(unsigned int) buffer;
	for(i = 0; i < argc; i++) {
	    if (machMonBootParam.argPtr[i] == (char *) 0 ||
		machMonBootParam.argPtr[i] == (char *) NIL) {
		break;
	    }
	    argv[i] = (char *) (machMonBootParam.argPtr[i] - (char *) offset);
	}
	return i;
#ifdef sun4c
    } else {
	char	*bufEndPtr = buffer + bufferSize - 1;
	char	*bufferPtr = buffer;
	int	argcsLeft = argc;
	char	*p;

	/*
	 * On version 2 and greater the bootstring is stored in 
	 * two null terminated strings.  We copy these strings
	 * into the argc,argv format needed by Mach_GetBootArgs.
	 */
	if (argc == 0) {
	    return 0;
	}
	p = *(romVectorPtr->bootpath);
	while (*p && isspace(*p)) { /* Skip any spaces. */
		p++;
	}
	*argv = bufferPtr;
	argv++; argcsLeft--;
	while (*p && (bufferPtr < bufEndPtr)) {
	    *bufferPtr++ = *p++;
	}
	*bufferPtr++ = 0;

	p = *(romVectorPtr->bootargs);
	while (*p && isspace(*p)) {  /* Skip any spaces. */
	    p++;
	}
	while ((bufferPtr < bufEndPtr) && (argcsLeft > 0) && *p) {
	    *argv = bufferPtr;
	    argv++; argcsLeft--;
	    while (*p && !isspace(*p) && (bufferPtr < bufEndPtr)) {
		*bufferPtr++ = *p++;
	    }
	    *bufferPtr++ = 0;
	    while (*p && isspace(*p)) {  /* Skip any spaces. */
		p++;
	    }
        }
	return argc - argcsLeft;
    }
#endif /* sun4c */
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_GetStackPointer --
 *
 *	This is a stub routine for the sun4.
 *
 * Results:
 *	Address.
 *
 * Side effects:
 *	It panics since it should never be called.  If it ends up being
 *	useful someday, change it so it doesn't panic.
 *
 *----------------------------------------------------------------------
 */
Address
Mach_GetStackPointer()
{
	panic("Mach_GetStackPointer");
	return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * HandleFPUException --
 *
 *	Handle any FPU exception present.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	FPU instruction emulated, process may be sent signal.
 *
 *----------------------------------------------------------------------
 */

static void
HandleFPUException(procPtr, machStatePtr)
    Proc_ControlBlock *procPtr;	/* Process control block of offending process*/
    Mach_State 	*machStatePtr;  /* Machine state of process. */
{    
    int		i;
    Mach_RegWindow	*curWindow;

    switch ((int) (machStatePtr->fpuStatus & MACH_FSR_TRAP_TYPE_MASK)) {
	case	MACH_FSR_IEEE_TRAP:
	case	MACH_FSR_UNFINISH_TRAP:
	case	MACH_FSR_UNIMPLEMENT_TRAP:
	    break;
	case	MACH_FSR_SEQ_ERRROR_TRAP: {
	    panic("Floating point sequence error, fsr = 0x%x\n",
		 machStatePtr->trapRegs->fsr);
	    break;
	}
	case	MACH_FSR_NO_TRAP:
	default: {
	    panic("Floating point exception with bad trap code, fsr = 0x%x\n", 
		    machStatePtr->trapRegs->fsr);
	    break;
	}
    }
    machStatePtr->fpuStatus &= 
		~(MACH_FPU_EXCEPTION_PENDING|MACH_FSR_TRAP_TYPE_MASK);
    /*
     * Emulate the evil instructions, and restore the result into the FPU.
     */
    curWindow = (Mach_RegWindow *)
		(machStatePtr->trapRegs->ins[MACH_FP_REG]);
    for (i = 0; i < machStatePtr->trapRegs->numQueueEntries; i++) {
#ifndef NO_FLOATING_POINT
	MachFPU_Emulate(procPtr->processID, 
		    machStatePtr->trapRegs->fqueue[i].address,
		    machStatePtr->trapRegs,
		    curWindow);
#else /* NO_FLOATING_POINT */
	printf(
	"Cannot emulate floating point operations in this kernel version\n");
	printf("Killing process 0x%x\n", procPtr->processID);
	(void) Sig_Send(SIG_ILL_INST, SIG_ILL_INST_CODE, procPtr->processID,
			FALSE, machStatePtr->trapRegs->pc);
#endif /* NO_FLOATING_POINT */
    }
    MachFPULoadState(machStatePtr->trapRegs);
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_SigreturnStub --
 *
 *	Return from a unix signal or long jump.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Changes control of execution.
 *
 *----------------------------------------------------------------------
 */
int
Mach_SigreturnStub(jmpBuf)
jmp_buf *jmpBuf;
{
    struct sigcontext context;
    Proc_ControlBlock	*procPtr = Proc_GetCurrentProc();
    Mach_State		*machStatePtr = procPtr->machStatePtr;

    if (Vm_CopyIn(9*sizeof(int), (Address)jmpBuf, (Address)&context) !=
	    SUCCESS) {
	printf("jmp_buf copy in failure\n");
	return -1;
    }
    if (debugProcStubs) {
	printf("Unix sigreturn: pc = %x, sp = %x, psr = %x\n", context.sc_pc,
		context.sc_sp, context.sc_psr&MACH_DISABLE_TRAP_BIT &
		~MACH_PS_BIT);
    }

    /*
     * Flush register windows to stack and maybe our problems will go away.
     */
    Mach_DisableIntr();
    Mach_FlushWindowsToStack();
    Mach_EnableIntr();

    machStatePtr->trapRegs->pc = context.sc_pc;
    machStatePtr->trapRegs->nextPc = context.sc_npc;

    machStatePtr->trapRegs->globals[1] = context.sc_g1;
    machStatePtr->trapRegs->ins[0] = context.sc_o0;
    machStatePtr->sigContext.oldHoldMask = context.sc_mask;
    machStatePtr->trapRegs->curPsr = (machStatePtr->trapRegs->curPsr&
	    ~MACH_PSR_SIG_RESTORE) | (context.sc_psr&MACH_PSR_SIG_RESTORE);
    machStatePtr->trapRegs->ins[6] = context.sc_sp;
    Sig_Return(procPtr, &machStatePtr->sigStack);
    return 0; /* Dummy */
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_FastBoot --
 *
 *	Do a fast reboot (using copied initialized heap data, etc.)
 *
 * Results:
 *	FAILURE if we're not set up to do a fast boot.  Otherwise, we don't
 *	return, but boot instead.
 *
 * Side effects:
 *	Will probably cause fast reboot.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
Mach_FastBoot()
{
    if (!recov_DoInitDataCopy) {
	printf("Can fast reboot: initialized data wasn't copied.");
	return FAILURE;
    }
    MachDoFastBoot();
    return FAILURE;		/* Should never get here. */
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_GetMachineType --
 *
 *	Get the machine type from the idprom.
 *
 * Results:
 *	The machine type.
 *
 * Side effects:
 *	Reads from PROM the first time.
 *
 *----------------------------------------------------------------------
 */
#ifdef sun4c
int
Mach_GetMachineType()
{
    if (machIdProm.id_format != IDFORM_1) {
	if (Mach_MonSearchProm("*", "idprom", (char *)&machIdProm,
		sizeof machIdProm) != sizeof machIdProm) {
	    panic("Where is the idprom?");
	}
    }
    return machIdProm.id_machine;
}
#endif /* sun4c */

/*
 *----------------------------------------------------------------------
 *
 * Mach_GetEtherAddress --
 *
 *	Get the ethernet address.
 *
 * Results:
 *	A pointer to the ethernet address.
 *
 * Side effects:
 *	Reads from PROM the first time.
 *
 *----------------------------------------------------------------------
 */
#ifdef sun4c
Net_EtherAddress *
Mach_GetEtherAddress(etherAddressPtr)
    Net_EtherAddress *etherAddressPtr;
{
    if (machIdProm.id_format != IDFORM_1) {
	if (Mach_MonSearchProm("*", "idprom", (char *)&machIdProm,
		sizeof machIdProm) != sizeof machIdProm) {
	    panic("Where is the idprom?");
	}
    }
    bcopy((char *)machIdProm.id_ether, (char *)etherAddressPtr,
	sizeof(Net_EtherAddress));
    return etherAddressPtr;	/* which copy should I return? */
}
#endif /* sun4c */
@


9.41
log
@Changes for transparent server recovery.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mgbaker/mach/sun4.md/machCode.c,v 1.1 92/04/30 12:38:46 mgbaker Exp $ SPRITE (Berkeley)";
d1323 1
a1323 1
     * the board. This code retries the error up to 10 times before droping
d1325 2
d1332 1
a1332 1
	if ((trapPsr & MACH_PS_BIT) && (busErrorReg == MACH_TIMEOUT_ERROR)) {
d1349 1
d1353 2
a1354 1
	    if (timeoutRetryCount < 10) {
d1361 4
d1828 1
d1856 4
d2196 1
d2201 7
@


9.40
log
@Added window flush to signal return, so we end up in the right window.
This is sort of a kludgy fix, but it seems to work.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/mach/sun4.md/machCode.c,v 9.39 91/11/05 12:02:30 mgbaker Exp $ SPRITE (Berkeley)";
d35 1
a44 1
int	storedDataSize = -1;	/* Not initialized. */
d47 8
d229 7
a235 1
MachMonRomVector	*machRomVectorPtr;
d242 6
a247 2
unsigned int		machNumWindows;
unsigned int		machWimShift;		/* # windows - 1 */
d256 1
d464 1
d467 1
d474 1
d476 1
d484 38
d530 22
d2189 1
d2191 1
a2191 1
}
d2245 29
@


9.39
log
@*** empty log message ***
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/mach/sun4.md/machCode.c,v 9.38 91/10/18 01:23:05 dlong Exp $ SPRITE (Berkeley)";
d2141 8
@


9.38
log
@sun4c/sun4c2 merge
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.34 91/08/12 22:15:28 shirriff Exp $ SPRITE (Berkeley)";
d445 1
a445 1
    printf("PROM: Clock rate is %d.%dMHz\n",
d453 1
a453 1
    printf("PROM: Interrupt register is at %x\n", machInterruptReg);
@


9.37
log
@Removed debugging message
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.36 91/09/10 18:17:56 rab Exp Locker: shirriff $ SPRITE (Berkeley)";
d34 2
d221 1
a221 1
Address			machRomVectorPtr;
d223 7
d274 1
a274 1
    mach_LastUserStackPage = (MACH_MAX_USER_STACK_ADDR - 1) / VMMACH_PAGE_SIZE;
d308 8
a315 6
    if ((*(romVectorPtr->virtMemory))->address !=
	    (unsigned) VMMACH_DEV_START_ADDR ||
	    ((unsigned) VMMACH_DEV_START_ADDR +
	    (*(romVectorPtr->virtMemory))->size - 1)
	    != (unsigned) VMMACH_DEV_END_ADDR) {
	panic("VMMACH_DEV_START_ADDR and VMMACH_DEV_END_ADDR are wrong.\n");
d408 15
a422 11
    /*
     * Copy the boot parameter structure. The original location will get
     * unmapped during vm initialization so we need to get our own copy.
     */
    machMonBootParam = **(romVectorPtr->bootParam);
    offset = (unsigned int) *(romVectorPtr->bootParam) - 
	     (unsigned int) &(machMonBootParam);
    for (i = 0; i < 8; i++) {
	if (machMonBootParam.argPtr[i] != (char *) 0 &&
	 machMonBootParam.argPtr[i] != (char *) NIL) {
	    machMonBootParam.argPtr[i] -= offset;
d424 3
a426 1
    }
d436 19
d569 1
a569 2
	(((unsigned int)(statePtr->switchRegs)) & ~0x7); /* should be okay already */

a1509 1

d1633 1
d1965 22
a1986 2
    int		i;
    int		offset;
d1988 38
a2025 12
    bcopy(machMonBootParam.strings, buffer, 
	  (bufferSize < 100) ? bufferSize : 100);
    offset = (unsigned int) machMonBootParam.strings - (unsigned int) buffer;
    for(i = 0; i < argc; i++) {
	if (machMonBootParam.argPtr[i] == (char *) 0 ||
	    machMonBootParam.argPtr[i] == (char *) NIL) {
	    break;
	}
	argv[i] = (char *) (machMonBootParam.argPtr[i] - (char *) offset);
    }
    return i;
}
d2153 61
@


9.36
log
@Fixed lint errors and removed tracing.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.35 91/08/15 22:39:44 mgbaker Exp Locker: rab $ SPRITE (Berkeley)";
d1595 1
a1595 1
	} else if (restarted) {
@


9.35
log
@Took out bogus comment.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.34 91/08/12 22:15:28 shirriff Exp Locker: mgbaker $ SPRITE (Berkeley)";
d295 2
a296 2
    CHECK_TRAP_REG_OFFSETS(fregs, MACH_FPU_REGS_OFFSET);
    CHECK_TRAP_REG_OFFSETS(fqueue, MACH_FPU_QUEUE_OFFSET);
d532 3
a534 2
    statePtr->switchRegs = ((unsigned int)(statePtr->switchRegs)) &
	    ~0x7;  /* should be okay already */
d1190 2
a1191 2
    if ((pcValue >= (Address) &MachProbeStart)  &&
	    (pcValue < (Address) &MachProbeEnd)) {
d1673 1
a1673 1
	       (pcValue == (Address) &machFPUSyncInst)) ?
d1707 1
a1707 1
	    if (pcValue == (Address) &machFPUDumpSyncInst) {
d1717 1
a1717 1
	    if (pcValue == (Address) &machFPUSyncInst) {
d1994 1
a1994 1
    switch (machStatePtr->fpuStatus & MACH_FSR_TRAP_TYPE_MASK) {
@


9.34
log
@Another fix to restarting system calls.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.33 91/08/12 15:02:25 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
a711 9
    /*
     * Ugh.  They set this to a different register set in the sun3 and
     * then set this reg differently in Mach_StartUserProc.  What should I
     * be doing?
     */
    /*
     * EEK -- Make sure there's enough space here for thing to have
     * stored its 6 input reg args in a caller's stack frame.
     */
@


9.33
log
@Fixed problem with unix signals and the restart flag.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.32 91/08/09 16:05:15 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d1499 1
@


9.32
log
@Changed signal handler to restart system call if it is interrupted
by a signal that doesn't do anything.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.31 91/08/02 18:42:57 mgbaker Exp Locker: shirriff $ SPRITE (Berkeley)";
d1493 1
a1493 1
	if (procPtr->unixProgress == PROC_PROGRESS_UNIX) {
@


9.31
log
@Put in a check for the correctness of an offset constant used in the
trap handlers.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.30 91/07/30 16:42:38 shirriff Exp $ SPRITE (Berkeley)";
d1363 1
d1477 5
a1481 7
	machStatePtr->trapRegs->nextPc = machStatePtr->trapRegs->pc;
	machStatePtr->trapRegs->pc = machStatePtr->trapRegs->nextPc-4;
	/*
	 * We need to restore %o0 which got clobbered by
	 * the system call.
	 */
	machStatePtr->trapRegs->ins[0] = machStatePtr->savedArgI0;
d1483 1
d1506 13
d1594 11
d1617 14
@


9.30
log
@Fixed debugging printfs.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.29 91/07/29 18:01:36 shirriff Exp $ SPRITE (Berkeley)";
d42 1
d322 2
a323 2
    if ( MACH_PROC_REGS_OFFSET != offsetof(Proc_ControlBlock, extraField)) {
	panic("MACH_PROC_REGS_OFFSET is wrong!\n");
@


9.29
log
@Removed debugging printfs
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.28 91/07/26 17:04:27 shirriff Exp $ SPRITE (Berkeley)";
d531 2
a532 1
    (unsigned int) (statePtr->switchRegs) &= ~0x7;/* should be okay already */
d1505 1
a1505 1
	    if (procDebugStubs) {
d1516 1
a1516 1
	    if (procDebugStubs) {
d1521 1
a1521 1
	    if (procDebugStubs) {
d1536 1
a1536 1
	    if (procDebugStubs) {
d1543 1
a1543 1
	    if (procDebugStubs) {
d1558 1
a1558 1
	    if (procDebugStubs) {
d1595 1
a1595 1
            procPtr->unixProgress != PROC_PROGRESS_UNIX && procDebugStubs) {
@


9.28
log
@Large install for unix compatibility
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.27 91/07/23 12:42:30 mendel Exp $ SPRITE (Berkeley)";
d1504 4
a1507 2
	    printf("Unix signal %d(%d) to %x\n", sigStackPtr->sigNum,
		    unixSignal, procPtr->processID);
d1515 3
a1517 1
	    printf("PSR = %x\n", machStatePtr->trapRegs->curPsr);
d1520 5
a1524 3
	    printf("trapRegs->pc=%x, trapRegs->npc=%x, context.pcValue=%x\n",
		    machStatePtr->trapRegs->pc, machStatePtr->trapRegs->nextPc,
		    machStatePtr->sigContext.machContext.pcValue);
d1535 3
a1537 1
	    printf("new pc = %x\n", machStatePtr->trapRegs->nextPc);
d1542 4
a1545 2
	    printf("Regs: %x %x %x, %x %x %x\n", n[0], n[1], n[2], n[8],
		    n[9], n[10]);
d1557 5
a1561 3
	    printf("Copied window to %x\n",
		    (Address)unixContext.sc_sp - sizeof(struct sigcontext)
			    - 4*sizeof(int) - MACH_SAVED_WINDOW_SIZE);
a1574 1
	    printf("Unix copies done\n");
d1594 1
a1594 1
            procPtr->unixProgress != PROC_PROGRESS_UNIX) {
@


9.27
log
@Added code to handle VME bus timeouts on interrupt vector loads.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.26 91/03/29 17:57:37 shirriff Exp $ SPRITE (Berkeley)";
d14 15
a28 12
#include "stddef.h"
#include "sprite.h"
#include "swapBuffer.h"
#include "machConst.h"
#include "machMon.h"
#include "machInt.h"
#include "mach.h"
#include "proc.h"
#include "sys.h"
#include "sched.h"
#include "vm.h"
#include "vmMach.h"
d30 1
d33 1
d80 2
d128 2
d320 5
d1343 3
a1345 2
 *	The return value TRUE indicates we have a pending signal.  FALSE
 *	indicates that we do not.
d1360 1
d1363 6
d1454 1
a1454 1
     * point exception becaue the Sig_Handle might do a context switch
d1464 19
d1491 77
a1567 1
	return TRUE;
d1582 6
d1594 1
a1594 1
    return FALSE;
d1922 2
a1982 1

d1988 1
a1988 2
 *	Procedure to map from Unix sigreturn system call to Sprite.
 *	On the suns, this is used for returning from a longjmp.
d1991 1
a1991 1
 *	Error code is returned upon error.  Otherwise SUCCESS is returned.
d1994 1
a1994 1
 *	Side effects associated with the system call.
d2000 1
a2000 1
    jmp_buf *jmpBuf;
d2002 25
a2026 3

    printf("Mach_Sigreturn not implemented\n");
    return -1;
@


9.26
log
@Made changes to return 2 values.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.25 90/12/13 15:01:04 mendel Exp Locker: shirriff $ SPRITE (Berkeley)";
d1129 1
d1202 2
d1205 19
a1225 3
		Mach_MonPrintf(
"MachPageFault: Bus timeout error retry %d at pc:0x%x, addr:0x%x\n",
		    timeoutRetryCount, pcValue, addrErrorReg);
@


9.25
log
@Fixed problem with floating/debugger combination crashing system.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.24 90/12/07 12:51:35 mgbaker Exp $ SPRITE (Berkeley)";
d172 8
d610 1
a610 1
Mach_SetReturnVal(procPtr, retVal)
d613 1
d620 1
d1838 25
@


9.24
log
@*** empty log message ***
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.23 90/11/09 12:01:06 mgbaker Exp $ SPRITE (Berkeley)";
d208 2
d1399 1
a1399 34
	int		i;
	Mach_RegWindow	*curWindow;
	switch (machStatePtr->fpuStatus & MACH_FSR_TRAP_TYPE_MASK) {
	    case	MACH_FSR_IEEE_TRAP:
	    case	MACH_FSR_UNFINISH_TRAP:
	    case	MACH_FSR_UNIMPLEMENT_TRAP:
		break;
	    case	MACH_FSR_SEQ_ERRROR_TRAP: {
		panic("Floating point sequence error, fsr = 0x%x\n",
		     machStatePtr->trapRegs->fsr);
		break;
	    }
	    case	MACH_FSR_NO_TRAP:
	    default: {
		panic(
"Floating point exception with bad trap code, fsr = 0x%x\n", 
		    machStatePtr->trapRegs->fsr);
		break;
	    }
	}
	machStatePtr->fpuStatus &= ~MACH_FPU_EXCEPTION_PENDING;
	/*
	 * Emulate the evil instructions, and restore the result into the FPU.
	 */
	curWindow = (Mach_RegWindow *)
		    (machStatePtr->trapRegs->ins[MACH_FP_REG]);
	for (i = 0; i < machStatePtr->trapRegs->numQueueEntries; i++) {
	    MachFPU_Emulate(procPtr->processID, 
			machStatePtr->trapRegs->fqueue[i].address,
			machStatePtr->trapRegs,
			curWindow);
	}
	MachFPULoadState(machStatePtr->trapRegs);

d1402 8
a1409 1
     * Now check for signal stuff.
d1417 3
d1423 3
a1505 1
	    unsigned int fsr;
d1524 2
a1525 1
		      (fsr & MACH_FSR_TRAP_TYPE_MASK) |
d1578 2
a1579 2
 	 procPtr->machStatePtr->fpuStatus |= (fsr & MACH_FSR_TRAP_TYPE_MASK) |
 					    MACH_FPU_EXCEPTION_PENDING;
d1770 58
@


9.23
log
@Fixed a comment.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.22 90/11/08 21:09:23 rab Exp Locker: mgbaker $ SPRITE (Berkeley)";
d1181 1
a1181 1
#ifndef sun4c
@


9.22
log
@Record pc for user level profiling during special handling.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.21 90/11/06 16:50:54 mendel Exp Locker: rab $ SPRITE (Berkeley)";
d909 8
a916 1
 *	Put a device driver interrupt handling routine into the autovector.
@


9.21
log
@Added retry for VME timeout errors.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.20 90/10/12 14:56:03 mgbaker Exp Locker: mendel $ SPRITE (Berkeley)";
d1310 3
@


9.20
log
@prototyping.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.19 90/09/11 13:43:07 mendel Exp Locker: mgbaker $ SPRITE (Berkeley)";
d1174 21
@


9.19
log
@Fixed lint caused by prototyping.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.18 90/09/11 10:49:43 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d101 1
a101 1
Address	machArgDispatch[SYS_NUM_SYSCALLS];	/* For each system call, gives an
d204 5
a208 2
extern	void	MachFlushWindowsToStack();
    
d475 1
a475 1
	MachFlushWindowsToStack();
d549 1
a549 1
	 * in MachFlushWindowsToStack(), above.  If so, copy the buffer state
d1110 1
a1110 22
/*
 *----------------------------------------------------------------------
 *
 * MachIntrNotHandledYet() -
 *
 *	I don't handle this level of interrupt yet.
 *
 * Results:
 *	None
 *
 * Side effects:
 *	None
 *
 *----------------------------------------------------------------------
 */
void
MachIntrNotHandledYet()
{
    printf("Received an interrupt I don't handle yet.\n");
    return;
}

a1128 1
#ifdef sun4c
a1129 3
#else
    unsigned	char	busErrorReg;
#endif
d1162 2
a1163 2
    if ((pcValue >= (Address) &Mach_ProbeStart)  &&
	    (pcValue < (Address) &Mach_ProbeEnd)) {
d1357 1
a1357 1
    MachFlushWindowsToStack();
d1573 1
a1573 1
	MachFlushWindowsToStack();
a1608 90
#ifdef sun4c
/*
 *----------------------------------------------------------------------
 *
 * Mach_PrintInterruptReg --
 *
 *	For debugging - print the contents of the interrupt register
 *	on the sun4c.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
Mach_PrintInterruptReg()
{
    unsigned char	interReg;

    interReg = *Mach_InterruptReg;
    Mach_MonPrintf("Interrupt register: 0x%x\n", interReg);
    return;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_PrintBusErrorRegs --
 *
 *	For debugging - print the contents of the bus error registers
 *	on the sun4c.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
Mach_PrintBusErrorRegs()
{
    unsigned int	busErrorReg;

    busErrorReg = MachGetSyncErrorReg();
    Mach_MonPrintf("Sync error register: 0x%x\n", busErrorReg);
    busErrorReg = MachGetSyncErrorAddrReg();
    Mach_MonPrintf("Sync error addr register: 0x%x\n", busErrorReg);
    busErrorReg = MachGetASyncErrorReg();
    Mach_MonPrintf("ASync error register: 0x%x\n", busErrorReg);
    busErrorReg = MachGetASyncErrorAddrReg();
    Mach_MonPrintf("ASync error addr register: 0x%x\n", busErrorReg);
    return;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_PrintSystemEnableReg --
 *
 *	For debugging - print the contents of the system enable register
 *	on the sun4c.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
Mach_PrintSystemEnableReg()
{
    unsigned char	systemEnableReg;

    systemEnableReg = MachGetSystemEnableReg();
    Mach_MonPrintf("System enable register: 0x%x\n", systemEnableReg);
    return;
}
#endif /* sun4c */

 

d1640 1
a1640 1
 * MachFlushWindowsToStack --
d1654 1
a1654 1
MachFlushWindowsToStack()
d1735 22
@


9.18
log
@Removed lint.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.17 90/09/10 12:22:55 mendel Exp $ SPRITE (Berkeley)";
d27 2
@


9.17
log
@Changed routine MachHandleWeirdoInstruction to be named MachHandleTrap.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.16 90/07/31 21:32:25 shirriff Exp Locker: mendel $ SPRITE (Berkeley)";
d25 1
d1351 1
a1351 1
			machStatePtr->savedSps[i]) != SUCCESS) {
@


9.16
log
@Oops.  I used the wrong error register.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.15 90/07/31 17:02:30 shirriff Exp $ SPRITE (Berkeley)";
d1455 1
a1455 1
 * MachHandleWeirdoInstruction --
d1470 1
a1470 1
MachHandleWeirdoInstruction(trapType, pcValue, trapPsr)
d1487 1
a1487 1
		"MachHandleWeirdoInstruction", pcValue, trapType);
d1496 1
a1496 1
	    printf("%s %s\n", "MachHandleWeirdoInstruction: illegal",
d1500 1
a1500 1
	    printf("%s %s\n", "MachHandleWeirdoInstruction: privileged",
d1504 1
a1504 1
	    printf("%s %s\n", "MachHandleWeirdoInstruction: unaligned",
d1508 1
a1508 1
	    printf("%s %s\n", "MachHandleWeirdoInstruction: tag",
d1537 1
a1537 1
	"MachHandleWeirdoInstruction: FPU exception from kernel process.");
d1541 1
a1541 1
	    printf("%s %s\n", "MachHandleWeirdoInstruction: fp unit",
d1545 1
a1545 1
	    printf("%s %s\n", "MachHandleWeirdoInstruction: hit default",
d1550 1
a1550 1
		"MachHandleWeirdoInstruction: the error occured in a",
d1615 1
a1615 1
	panic("%s %s\n", "MachHandleWeirdoInstruction: tag",
d1619 1
a1619 1
	panic("%s %s\n", "MachHandleWeirdoInstruction: hit default",
@


9.16.1.1
log
@Contains asplos statistics-gathering code.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach.mgb/sun4.md/RCS/machCode.c,v 1.1 90/06/29 17:39:39 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
a24 1
#include "vmMachInt.h"
a84 43
/*
 * Temporary data structures for getting asplos statistics.
 */
unsigned int	machSysOverflows[SYS_NUM_SYSCALLS];
					/* For each system call, tells how
					 * many window overflows occurred.
					 */
unsigned int	machSysUnderflows[SYS_NUM_SYSCALLS];
					/* For each system call, tells how
					 * many window underflows occurred.
					 */
unsigned int	userFromUserOverflows = 0;
unsigned int	userFromKernelOverflows = 0;
unsigned int	kernelOverflows = 0;
unsigned int	userUnderflows = 0;
unsigned int	kernelUnderflows = 0;
unsigned int	interruptOverflows = 0;
unsigned int	interruptUnderflows = 0;
unsigned int	contextSwitchOverflows = 0;
unsigned int	contextSwitchUnderflows = 0;
unsigned int	pageValidOverflows = 0;
unsigned int	pageValidUnderflows = 0;
unsigned int	slowOverflows = 0;
unsigned int	slowUnderflows = 0;
unsigned int	inTrapOverflows = 0;
unsigned int	inTrapUnderflows = 0;
unsigned int	bufferOverflows = 0;
unsigned int	faultUnderflows = 0;
unsigned int	faultInTrapUnderflows = 0;
Boolean		mach_inContextSwitch = FALSE;
Boolean		mach_inPageValid = FALSE;
Boolean		mach_inSysCall = FALSE;
int		mach_whichSysCall = -1;
Boolean		hadToFault = FALSE;
Boolean		itWasUser = FALSE;
unsigned int	numInterrupts;


Mach_Stats	 mach_Stats;




d93 1
a93 1
int	machMaxSysCall;			/* Highest defined system call. */
d147 2
d321 1
a328 9
     * Initialization of temporary data structures for asplos paper statistics.
     */
    for (i = 0; i < SYS_NUM_SYSCALLS; i++) {
	machSysOverflows[i] = 0;
	machSysUnderflows[i] = 0;
    }
    bzero(&mach_Stats, sizeof (mach_Stats));

    /*
a1160 5
     * Set temporary data structures for asplos statistics.
     */
    mach_inPageValid = TRUE;

    /*
a1172 4
	/*
	 * Set temporary data structures for asplos statistics.
	 */
	mach_inPageValid = FALSE;
a1189 4
	/*
	 * Set temporary data structures for asplos statistics.
	 */
	mach_inPageValid = FALSE;
a1202 4
	     * Set temporary data structures for asplos statistics.
	     */
	    mach_inPageValid = FALSE;
	    /*
a1223 4
	     * Set temporary data structures for asplos statistics.
	     */
	    mach_inPageValid = FALSE;
	    /*
a1244 4
		/*
		 * Set temporary data structures for asplos statistics.
		 */
		mach_inPageValid = FALSE;
a1247 4
		/*
		 * Set temporary data structures for asplos statistics.
		 */
		mach_inPageValid = FALSE;
a1253 4
	/*
	 * Set temporary data structures for asplos statistics.
	 */
	mach_inPageValid = FALSE;
d1267 2
a1268 5
	Sig_Send(SIG_ADDR_FAULT, SIG_ACCESS_VIOL, procPtr->processID, FALSE);
	/*
	 * Set temporary data structures for asplos statistics.
	 */
	mach_inPageValid = FALSE;
a1270 4
    /*
     * Set temporary data structures for asplos statistics.
     */
    mach_inPageValid = FALSE;
d1561 1
a1561 1
		FALSE);
d1564 2
a1565 1
	(void) Sig_Send(SIG_ILL_INST, SIG_PRIV_INST, procPtr->processID, FALSE);
d1569 1
a1569 1
		FALSE);
d1801 2
a1802 1
    Sig_Send(SIG_BREAKPOINT, SIG_NO_CODE, procPtr->processID, FALSE);
a1843 85
}



/*
 *----------------------------------------------------------------------
 *
 * Mach_GetStats --
 *
 *	Gather the statistics that show window overflow and underflow
 *	behavior.  This is temporary for the asplos paper.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
Mach_GetStats()
{
    extern	unsigned int	vm_contextFlushes;
    extern	unsigned int	vm_segmentFlushes;
    extern	unsigned int	vm_pageFlushes;
    extern	unsigned int	vm_byteRangeFlushes;
    extern	unsigned int    vm_contextContextFlushes;
    extern	unsigned int    vm_contextSegmentFlushes;
    extern	unsigned int    vm_contextPageFlushes;
    extern	unsigned int    vm_pageContextFlushes;
    extern	unsigned int    vm_pageSegmentFlushes;
    extern	unsigned int    vm_pagePageFlushes;
    extern	unsigned int    vm_interruptContextFlushes;
    extern	unsigned int    vm_interruptSegmentFlushes;
    extern	unsigned int    vm_interruptPageFlushes;
    extern	unsigned int    vm_sysContextFlushes[];
    extern	unsigned int    vm_sysSegmentFlushes[];
    extern	unsigned int    vm_sysPageFlushes[];




    mach_Stats.userFromUserOverflows = userFromUserOverflows;
    mach_Stats.userFromKernelOverflows = userFromKernelOverflows;
    mach_Stats.kernelOverflows = kernelOverflows;
    mach_Stats.userUnderflows =  userUnderflows;
    mach_Stats.kernelUnderflows = kernelUnderflows;
    mach_Stats.interruptOverflows = interruptOverflows;
    mach_Stats.interruptUnderflows = interruptUnderflows;
    mach_Stats.contextSwitchOverflows = contextSwitchOverflows;
    mach_Stats.contextSwitchUnderflows = contextSwitchUnderflows;
    mach_Stats.pageValidOverflows = pageValidOverflows;
    mach_Stats.pageValidUnderflows = pageValidUnderflows;
    mach_Stats.slowOverflows = slowOverflows;
    mach_Stats.slowUnderflows = slowUnderflows;
    mach_Stats.inTrapOverflows = inTrapOverflows;
    mach_Stats.inTrapUnderflows = inTrapUnderflows;
    mach_Stats.bufferOverflows = bufferOverflows;
    mach_Stats.faultUnderflows = faultUnderflows;
    bcopy(machSysOverflows, mach_Stats.machSysOverflows,
	    sizeof (int) * SYS_NUM_SYSCALLS);
    bcopy(machSysUnderflows, mach_Stats.machSysUnderflows,
	    sizeof (int) * SYS_NUM_SYSCALLS);
    mach_Stats.contextFlushes = vm_contextFlushes;
    mach_Stats.segmentFlushes = vm_segmentFlushes;
    mach_Stats.pageFlushes = vm_pageFlushes;
    mach_Stats.byteRangeFlushes = vm_byteRangeFlushes;
    mach_Stats.contextContextFlushes = vm_contextContextFlushes;
    mach_Stats.contextSegmentFlushes = vm_contextSegmentFlushes;
    mach_Stats.contextPageFlushes = vm_contextPageFlushes; 
    mach_Stats.pageContextFlushes = vm_pageContextFlushes; 
    mach_Stats.pageSegmentFlushes = vm_pageSegmentFlushes; 
    mach_Stats.pagePageFlushes = vm_pagePageFlushes; 
    mach_Stats.interruptContextFlushes = vm_interruptContextFlushes;
    mach_Stats.interruptSegmentFlushes = vm_interruptSegmentFlushes;
    mach_Stats.interruptPageFlushes = vm_interruptPageFlushes;
    bcopy(vm_sysContextFlushes, mach_Stats.sysContextFlushes,
	    sizeof (int) * SYS_NUM_SYSCALLS);
    bcopy(vm_sysSegmentFlushes, mach_Stats.sysSegmentFlushes,
	    sizeof (int) * SYS_NUM_SYSCALLS);
    bcopy(vm_sysPageFlushes, mach_Stats.sysPageFlushes,
	    sizeof (int) * SYS_NUM_SYSCALLS);
    mach_Stats.numInterrupts = numInterrupts;
    return;
@


9.15
log
@Added sigAddr offset.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.14 90/07/30 16:17:26 shirriff Exp $ SPRITE (Berkeley)";
d1268 1
a1268 1
	       (Address)busErrorReg);
@


9.14
log
@Fixed typos.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.13 90/07/30 11:34:25 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d147 2
d321 1
@


9.13
log
@Address field to Sig_Send.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.12 90/06/27 11:13:53 douglis Exp Locker: shirriff $ SPRITE (Berkeley)";
d1265 1
a1265 1
	       addrErrReg);
d1566 1
a1566 1
		FALSE, busErrReg);
@


9.12
log
@reenable migration if any signal is pending.  before, it checked
via an "and" with SIG_MIG_TRAP rather than sigBitMasks[SIG_MIG_TRAP].
(guess that worked only because it checked against 9 instead of 8...)
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.11 90/03/26 12:14:48 mgbaker Exp Locker: douglis $ SPRITE (Berkeley)";
a24 1
#include "vmMachInt.h"
d1264 2
a1265 1
	Sig_Send(SIG_ADDR_FAULT, SIG_ACCESS_VIOL, procPtr->processID, FALSE);
d1558 1
a1558 1
		FALSE);
d1561 2
a1562 1
	(void) Sig_Send(SIG_ILL_INST, SIG_PRIV_INST, procPtr->processID, FALSE);
d1566 1
a1566 1
		FALSE);
d1798 2
a1799 1
    Sig_Send(SIG_BREAKPOINT, SIG_NO_CODE, procPtr->processID, FALSE);
@


9.11
log
@Added ability to kill processes set up for debugging due to bad
stacks in underflow handler code.
.`
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.10 90/02/28 22:18:32 douglis Exp $ SPRITE (Berkeley)";
d1433 1
d1435 1
a1435 1
    if (procPtr->sigPendingMask & SIG_MIGRATE_TRAP) {
@


9.10
log
@deal with exception in MachFPUDumpState.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach.fd/sun4.md/RCS/machCode.c,v 9.10 90/02/25 18:22:28 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
a1838 1

@


9.9
log
@reenable migration if migration pending after Sig_Handle called.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach.fd/sun4.md/RCS/machCode.c,v 9.8 90/02/20 15:29:55 jhh Exp Locker: douglis $ SPRITE (Berkeley)";
d161 2
d1474 3
a1476 2
     * Find the current process.  If we took a MACH_FP_EXCEP at machFPUSyncInst
     * we used the process saved in machFPUSaveProcPtr.
d1479 2
a1480 2
	       (pcValue == (Address) &machFPUSyncInst)) ? machFPUSaveProcPtr :
							  Proc_GetCurrentProc();
d1510 2
a1511 2
	     * We got a FP execption will running in kernel mode. This is
	     * exception occured at machFPUSyncInst we clear the
d1514 10
a1525 1
		  fsr = procPtr->machStatePtr->trapRegs->fsr;
d1527 2
a1528 2
				(fsr & MACH_FSR_TRAP_TYPE_MASK) |
					     MACH_FPU_EXCEPTION_PENDING;
d1531 2
a1532 2
	    } else {
		   printf("%s. ",
a1533 1
	    }
d1579 2
a1580 2
	 procPtr->machStatePtr->fpuStatus |= (fsr & MACH_FSR_TRAP_TYPE_MASK) |
					    MACH_FPU_EXCEPTION_PENDING;
@


9.8
log
@changed to Fmt constant
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.7 90/01/11 10:49:23 mgbaker Exp Locker: jhh $ SPRITE (Berkeley)";
d1427 9
@


9.7
log
@*** empty log message ***
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.6 89/12/12 18:01:37 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d64 1
a64 1
Fmt_Format	mach_Format = SWAP_SPARC_TYPE;
@


9.6
log
@Took out lots of debugging.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.5 89/11/30 12:04:00 mendel Exp Locker: mgbaker $ SPRITE (Berkeley)";
d119 4
d294 2
@


9.5
log
@Mary checking this in for Mendel.  I'm about to strip out debugging stuff
but this version works on the sun4c finally so I want to keep it for
reference.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.4 89/11/27 14:53:04 mgbaker Exp $ SPRITE (Berkeley)";
a1149 4
#ifdef sun4c
    MachFlushWindowsToStack();
#endif

a1336 5
#ifdef sun4c
		    if (machStatePtr->savedRegs[i][14] < 0x1a000000) {
			panic("Gotcha PID 0x%x\n",procPtr->processID);
		    }
#endif
a1344 9
#ifdef sun4c
		machStatePtr->savedSps[i] = 0;
		{ 
			register int j;
			for (j = 0; j < 16; j++) {
			   machStatePtr->savedRegs[i][j] = 1;
			}
		}
#endif
@


9.4
log
@Notdef'ing debug stuff.
floating point additions to state structure.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach.mendel/sun4.md/RCS/machCode.c,v 9.3 89/10/24 13:37:22 mgbaker Exp Locker: mendel $ SPRITE (Berkeley)";
d1150 4
d1340 6
a1345 1
		 */
d1354 9
@


9.3
log
@Fixed lint.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.2 89/10/21 20:53:47 rab Exp Locker: mgbaker $ SPRITE (Berkeley)";
d148 2
a150 3
#ifdef FP_ENABLED
unsigned int	machSavedFsr;		/* saved %fsr on fp exception trap */
#endif FP_ENABLED
d152 5
d248 1
d256 1
d260 4
d316 2
a523 2
	Proc_ControlBlock	*curProcPtr;	/* Pointer to current proc */

a536 5
	curProcPtr = Proc_GetCurrentProc();
	if (curProcPtr->machStatePtr != fromStatePtr) {
	    panic("%s %s\n", "Mach_SetupNewState: Forking process must",
		    "be current process!");
	}
d703 4
d768 1
a768 1
	      (Address)(&debugStatePtr->regState), sizeof(Mach_RegState));
d1370 37
d1408 1
d1456 9
a1464 3
    procPtr = Proc_GetCurrentProc();
    if (procPtr == (Proc_ControlBlock *) NIL) {
	printf("%s: pc = 0x%x, trapType = %d\n",
d1466 1
a1466 1
	panic("Current process was NIL!\n");
d1489 19
a1507 6
	case MACH_FP_EXCEP:
	    printf("%s %s\n", "MachHandleWeirdoInstruction: fp",
		    "exception trap in the kernel!");
#ifdef FP_ENABLED
	    printf("%fsr is 0x%x\n", machSavedFsr);
#endif FP_ENABLED
d1509 1
d1540 18
a1557 9
    case MACH_FP_EXCEP:
#ifdef FP_ENABLED
	printf("%s.  %fsr was 0x%x\n",
		"MachHandleWeirdoInstruction: fp exception from user process.",
		machSavedFsr);
#endif FP_ENABLED
    (void) Sig_Send(SIG_ARITH_FAULT, SIG_ILL_INST_CODE, procPtr->processID,
		FALSE);
	break;
d1559 1
a1559 3
	Mach_State 	*machStatePtr;
	int		curSp;
	Mach_RegWindow	*curWindow;
a1560 3
	/* 
	 * Insure the user's registers are memory resident.
	 */
d1564 2
a1565 1
	 * See if the user's window was saved to the internal buffers.
d1567 14
a1580 14
	curSp = machStatePtr->trapRegs->ins[MACH_FP_REG];
	curWindow = (Mach_RegWindow *) curSp;
	if (machStatePtr->savedMask != 0) {
	    int	i;
	    for (i = 0; i < MACH_NUM_WINDOWS; i++) {
		if (((1 << i) & machStatePtr->savedMask) &&
		    (machStatePtr->savedSps[i] == curSp))  {
		    curWindow = (Mach_RegWindow *)
				    &(machStatePtr->savedRegs[i][0]);
		}
	    }
	}
	MachFPU_Emulate(procPtr->processID,pcValue, machStatePtr->trapRegs, 
			curWindow,  &machStatePtr->fpuState);
@


9.2
log
@Started de-linting.  Replaced test structures with offsetof macro.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.1 89/09/18 21:01:10 mgbaker Exp Locker: rab $ SPRITE (Berkeley)";
d247 1
a247 1
    CHECK_OFFSETS(savedRegs[0], MACH_SAVED_REGS_OFFSET);
d256 5
a260 3
    if ((*(romVectorPtr->virtMemory))->address != VMMACH_DEV_START_ADDR ||
	    (VMMACH_DEV_START_ADDR + (*(romVectorPtr->virtMemory))->size - 1)
	    != VMMACH_DEV_END_ADDR) {
d362 1
a362 1
    bzero(romVectorPtr->lineBuf, *romVectorPtr->lineSize);
d397 1
a397 1
    bzero((char *)procPtr->machStatePtr, sizeof (Mach_State));
d477 2
a478 2
    ((Address) statePtr->switchRegs) = (statePtr->kernStackStart) +
	    MACH_KERN_STACK_SIZE - (2 * MACH_SAVED_STATE_FRAME);
d517 2
a518 2
	(Address) (statePtr->trapRegs) =
		((Address) stackPtr) + MACH_SAVED_STATE_FRAME;
d628 2
a629 2
    (Address) statePtr->trapRegs->pc = (Address)entryPoint;
    (Address) statePtr->trapRegs->nextPc = (Address)entryPoint + 4;
d692 2
a693 2
    (Address) procPtr->machStatePtr->trapRegs->ins[MACH_FP_REG] =
	    userStackPtr - MACH_FULL_STACK_FRAME;
d695 2
a696 2
    (Address) procPtr->machStatePtr->trapRegs->pc = entryPoint;
    (Address) procPtr->machStatePtr->trapRegs->tbr = machTBRAddr;
d701 1
a701 1
    (Address) procPtr->machStatePtr->trapRegs->ins[0] = 0;
d1145 2
a1146 2
    if ((pcValue >= (Address) &VmMachQuickNDirtyCopy) &&
	    (pcValue < (Address) &VmMachEndQuickCopy)) {
d1329 1
a1329 1
			(Address)&(machStatePtr->savedRegs[i]),
d1524 1
d1526 16
d1552 17
d1585 17
d1611 1
a1611 1
#endif
d1613 19
a1631 14
void
MachTestContexts()
{
    int	i;
    int	j;

    for (i = 0; i < VMMACH_NUM_CONTEXTS; i++) {
	VmMachSetUserContext(i);
	j = i;
    }
    return;
}

void
d1633 1
a1633 1
int	num; 
d1642 1
d1644 14
a1657 3
 * We want to do NWINDOWS - 1 saves and then restores to make sure all our
 * register windows have been saved to the stack.  Calling here does one save,
 * so we want to do NWINDOWS - 2 more calls and returns.
d1662 5
d1671 18
a1698 1

d1701 1
@


9.1
log
@Checked in by shirriff for mgbaker.
@
text
@d11 2
a12 2
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 9.0 89/09/12 14:52:50 douglis Stable Locker: mgbaker $ SPRITE (Berkeley)";
#endif not lint
d14 1
d172 1
d179 1
d236 1
a236 2
    if ((unsigned int)(&(testMachState.s)) - \
	    (unsigned int)(&testMachState) != o) {\
d239 2
a240 3
#define	CHECK_TRAP_REG_OFFSETS(s, o)		\
    if ((unsigned int)(&(testMachRegState.s)) -	\
	(unsigned int)(&testMachRegState) != o) {\
d247 1
a247 1
    CHECK_OFFSETS(savedRegs, MACH_SAVED_REGS_OFFSET);
d249 1
a249 1
    CHECK_OFFSETS(savedSps, MACH_SAVED_SPS_OFFSET);
d252 2
a253 2
    CHECK_TRAP_REG_OFFSETS(ins, MACH_INS_OFFSET);
    CHECK_TRAP_REG_OFFSETS(globals, MACH_GLOBALS_OFFSET);
d273 3
a275 6
    machStatePtrOffset = (unsigned int)(&(testPCB.machStatePtr)) -
	    (unsigned int)(&testPCB);
    machKcallTableOffset = (unsigned int)(&(testPCB.kcallTable)) -
	    (unsigned int)(&testPCB);
    machSpecialHandlingOffset = (unsigned int)(&(testPCB.specialHandling)) -
	    (unsigned int)(&testPCB);
d277 1
a277 2
    MachPIDOffset = (unsigned int)(&(testPCB.processID)) -
	    (unsigned int)(&testPCB);
d290 2
a291 5
    machSigStackOffsetOnStack = (unsigned int)(&(testSignalStack.sigStack)) -
	    (unsigned int)(&testSignalStack);
    machSigStackOffsetInMach = (unsigned int)(&(testMachState.sigStack)) -
	    (unsigned int)(&testMachState);
  
d293 10
a302 21
    machSigContextOffsetOnStack = (unsigned int)(&(testSignalStack.sigContext))-
	    (unsigned int)(&testSignalStack);
    machSigContextOffsetInMach = (unsigned int)(&(testMachState.sigContext)) -
	    (unsigned int)(&testMachState);

    machSigUserStateOffsetOnStack =
	    (unsigned int) (&(testSignalStack.sigContext.machContext.userState))
	    - (unsigned int)(&testSignalStack);
    
    machSigTrapInstOffsetOnStack =
	    (unsigned int) (&(testSignalStack.sigContext.machContext.trapInst))
	    - (unsigned int)(&testSignalStack);

    machSigNumOffsetInSig = (unsigned int) (&(testStack.sigNum)) -
	    (unsigned int)(&testStack);
    machSigCodeOffsetInSig = (unsigned int) (&(testStack.sigCode)) -
	    (unsigned int)(&testStack);
 
    machSigPCOffsetOnStack =
	    (unsigned int)(&(testSignalStack.sigContext.machContext.pcValue)) -
	    (unsigned int)(&testSignalStack);
@


9.0
log
@Changing version numbers.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.40 89/08/31 12:44:14 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d1153 2
d1157 16
a1228 3
	 *
	 * Since this is called from trap handlers only, we know interrupts
	 * are off here.  The Vm system needs them on?
@


1.40
log
@changed panics to warnings during syscall init
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.39 89/08/17 17:24:53 jhh Exp Locker: douglis $ SPRITE (Berkeley)";
@


1.39
log
@now uses Fmt_Convert
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.37 89/08/08 22:15:29 jhh Exp Locker: mgbaker $ SPRITE (Berkeley)";
d846 2
a847 1
	panic("out-of-order kernel call initialization");
d850 3
a852 1
	panic("too many kernel calls");
d855 2
a856 1
	panic("too many arguments to kernel call");
@


1.38
log
@tmp checkin
@
text
@d60 2
a61 1
 * The byte ordering/alignment type used with Swap_Buffer and I/O control data.
d63 1
a63 1
int	mach_ByteOrder = SWAP_SPARC_TYPE;
@


1.37
log
@checking in Mary's changes
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.36 89/07/20 16:59:20 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
a357 1
#ifdef NOTDEF
d371 1
a630 1
    int		status;
@


1.36
log
@Checkin before changing interrupt stuff
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.35 89/06/16 09:04:53 mendel Exp $ SPRITE (Berkeley)";
d183 1
a185 12
/*
 * For debugging stuff, put values into a circular buffer.  After each value,
 * stamp a special mark, which gets overwritten by next value, so we
 * always know where the end of the list is.
 */
#define	DEBUG_ADD(thing)	\
    debugSpace[debugCounter++] = (int)(thing);	\
    if (debugCounter >= 500) {	\
	debugCounter = 0;	\
    }				\
    debugSpace[debugCounter] = (int)(0x11100111);

d253 7
d330 1
d347 1
d350 1
d352 1
d358 1
d377 9
d1136 3
d1140 1
d1160 2
a1161 1
	 * got the page fault return FAILURE to its caller.
d1163 1
d1165 1
d1180 3
a1182 2
	    panic("MachPageFault: page fault in kernel process! pc is 0x%x\n",
		    (unsigned) pcValue);
a1210 1
	Mach_EnableIntr();
a1211 1
	Mach_DisableIntr();
d1218 2
d1221 1
d1223 1
a1234 1
    Mach_EnableIntr();
d1236 5
a1240 1
	printf("MachPageFault: Bus error in user proc %x, PC = %x, addr = %x BR Reg %x\n",
d1242 1
a1244 1
	Mach_DisableIntr();
a1246 1
    Mach_DisableIntr();
d1519 38
@


1.35
log
@Many changes and bug fixes.  Added floating point support. Moved kernel
down in memory.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.34 89/05/21 18:24:21 mgbaker Exp $ SPRITE (Berkeley)";
d1385 3
a1387 1
	panic("MachHandleWeirdoInstruction: current process was NIL!\n");
@


1.34
log
@checkin before spring cleaning
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.33 89/05/04 23:27:12 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d183 2
d222 1
d358 21
a378 2
    return;
}
d1451 1
a1451 3
	/* fall through */
    case MACH_FP_DISABLED:
	(void) Sig_Send(SIG_ARITH_FAULT, SIG_ILL_INST_CODE, procPtr->processID,
d1454 29
d1545 40
@


1.33
log
@Twenty-third Kernel.  Can read and write disks and tape now.  New interrupt
handler interface, device mapping and probing, etc.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.32 89/05/02 23:25:54 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d147 4
d1342 1
a1342 1
 *	an unaligned address on an instruction 
d1387 7
d1424 7
@


1.32
log
@New interrupts, device interface, etc.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.31 89/04/29 19:51:29 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d330 10
a339 1
	    /* set arg to vme vector address for this trap level */
d341 1
a341 1
		    (MACH_VME_INTR_VECTOR || ((i + 1) || 1));
a1109 6
    procPtr = Proc_GetActualProc();
    if (procPtr == (Proc_ControlBlock *) NIL) {
	panic(
	"MachPageFault: Current process is NIL!!  Trap pc is 0x%x, addr 0x%x\n",
		(unsigned) pcValue, addrErrorReg);
    }
d1112 2
d1123 6
@


1.31
log
@Caching of kernel stacks now works.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.30 89/04/24 00:21:14 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d87 5
d213 4
d323 16
a859 1

d861 4
a864 3
Mach_SetHandler(vectorNumber, handler)
    int vectorNumber;	/* Vector number that the device generates */
    int (*handler)();	/* Interrupt handling procedure */
a865 2
#ifdef NOTDEF
    int	*vecTablePtr;
d867 2
a868 3
    if (vectorNumber < 64 || vectorNumber > 255) {
	printf("%d: ", vectorNumber);
	printf("Warning: Bad vector number\n");
d870 2
a871 2
	vecTablePtr = (int *) MachGetVBR();
	vecTablePtr[vectorNumber] = (int)handler;
d873 1
a873 4
#else
    panic("Mach_SetHandler called\n");
#endif NOTDEF
}
a1050 25

/*
 *----------------------------------------------------------------------
 *
 * MachNoLevel0Interrupt() -
 *
 *	Although there's a level 0 interrupt slot, there's supposedly no
 *	such thing as a level 0 interrupt, according to the sparc
 *	architecture manual, so complain.
 *
 * Results:
 *	None
 *
 * Side effects:
 *	None
 *
 *----------------------------------------------------------------------
 */
void
MachNoLevel0Interrupt()
{
    printf("Received a level 0 interrupt.  There's no such thing!\n");
    return;
}

d1103 2
a1104 1
	panic("MachPageFault: Current process is NIL!!  Trap pc is 0x%x, addr 0x%x\n",
d1107 12
d1145 2
a1146 1
	    panic("MachPageFault: kernel page fault at illegal pc: 0x%x, addr 0x%x\n",
@


1.30
log
@Cleaned up MachUserAction a bit.
Got rid of race conditions with savedMask in MachUserAction.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.29 89/04/23 16:30:34 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
a1240 2
	DEBUG_ADD(0x88888888);
	DEBUG_ADD(procPtr->processID);
a1242 2
		DEBUG_ADD(i);
		DEBUG_ADD(machStatePtr->savedSps[i]);
a1286 2
	DEBUG_ADD(0x87878787);
	DEBUG_ADD(procPtr->processID);
@


1.29
log
@Fixed bug that caused some exec'd processes to have a bad tbr register.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.28 89/04/19 23:19:59 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
a344 4
#ifdef NOTDEF
    procPtr->machStatePtr->setJumpStatePtr = (Mach_SetJumpState *)NIL;
    /* also set stack end? */
#endif NOTDEF
a395 3
#ifdef NOTDEF
	procPtr->machStatePtr->setJumpStatePtr = (Mach_SetJumpState *)NIL;
#endif NOTDEF
a575 3
#ifdef NOTDEF
    Mach_MonPrintf("Mach_StartUserProc: calling MachRunUserProc with procPtr 0x%x and entryPoint 0x%x\n", procPtr, entryPoint);
#endif NOTDEF
a681 48
 * Mach_CopyState --
 *
 *	Copy the state from the given state structure to the machine
 *	state structure for the destination process control block.  Intended
 *	to be used by the debugger to modify the state.The only fields
 *	that can be modified are the following:
 *
 *	    1) user stack pointer
 *	    2) all trap registers except for the stack pointer because the
 *	       stack pointer in the trap registers is the kernel stack pointer.
 *	    3) the PC, VOR and status register in the exception stack.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Machine state in the destination process control block is overwritten.
 *
 *----------------------------------------------------------------------
 */ 
void
Mach_CopyState(statePtr, destProcPtr)
    Mach_State		*statePtr;	/* Pointer to state to copy from. */
    Proc_ControlBlock	*destProcPtr;	/* Process control block to copy
					 * state to. */
{
#ifdef NOTDEF
    register	Mach_State	*destStatePtr;

    destStatePtr = destProcPtr->machStatePtr;
    destStatePtr->userState.userStackPtr =
				statePtr->userState.userStackPtr;
    bcopy((Address)statePtr->userState.trapRegs,
	      (Address)destStatePtr->userState.trapRegs,
	      sizeof(int) * (MACH_NUM_GPRS - 1));
    destStatePtr->userState.excStackPtr->pc = 
				    statePtr->userState.excStackPtr->pc;
    destStatePtr->userState.excStackPtr->statusReg = 
				statePtr->userState.excStackPtr->statusReg;
#else
    panic("Mach_CopyState called.\n");
#endif NOTDEF
}


/*
 *----------------------------------------------------------------------
 *
a744 29


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_GetUserStackPtr --
 *
 *	Return the user stack pointer from the machine state struct for the
 *	given process.
 *
 * Results:
 *	The value of the user stack pointer when the process trapped.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
Address
Mach_GetUserStackPtr(procPtr)
    Proc_ControlBlock	*procPtr;
{
#ifdef NOTDEF
    return(procPtr->machStatePtr->userState.userStackPtr);
#else
    panic("Mach_GetUserStackPtr called.\n");
#endif NOTDEF
}

a950 27
#ifdef NOTDEF

/*
 * ----------------------------------------------------------------------------
 *
 * Mach_UnsetJump --
 *
 *	Clear out the pointer to the saved state from a set jump.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	setJumpStatePtr field of proc table for current process is nil'd out.
 *
 * ----------------------------------------------------------------------------
 */
void
Mach_UnsetJump()
{
    Proc_ControlBlock	*procPtr;

    procPtr = Proc_GetCurrentProc();
    procPtr->machStatePtr->setJumpStatePtr = (Mach_SetJumpState *) NIL;
}
#endif NOTDEF

d1222 2
d1229 1
a1229 4
    /*
     * Should I flush windows to the stack before or after dealing with
     * a signal?  I'm not sure I understand the choices.  I'll do it first.
     */
d1231 1
d1233 4
a1236 4
     * This is a while, since the Vm code may make it necessary to save
     * further windows that weren't set when we got here.  At least I think
     * that might happen.  I should test it to see if Vm ever calls that
     * deeply, but this is safer in case someone changes that code.
d1238 1
a1238 1
    while (machStatePtr->savedMask != 0) {
d1247 9
a1255 1
		/* clear the mask for this window */
d1257 1
d1259 1
a1259 3
		 * Push the window to the stack.  Should I re-verify the stack
		 * pointer?  I don't think I need to, since it's stored in
		 * kernel space and I verified it before storing it.
d1272 16
d1296 1
d1298 1
a1298 7
     * Now check for signal stuff.  We disable interrupts because we don't
     * want the signal stuff in our process state to be overwritten by another
     * signal until we have a chance to copy it out to the user stack and to
     * jump to the signal pc without its being overwritten.  Note that we do
     * not use the DISABLE_INTR macro, because it increments the nesting
     * depth of interrupts and we don't want this since there is an implicit
     * enable interrupts on rett.
d1309 4
@


1.28
log
@Consistent buggy state.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.27 89/04/09 13:23:32 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d84 3
a632 7
#ifdef NOTDEF
    /* A user proc can exec a user proc, so this is a bad test! */

    if (procPtr->machStatePtr->trapRegs != (Mach_RegState *) NIL) {
	panic("Mach_ExecUserProc: machStatePtr->trapRegs was NOT NIL!\n");
    }
#endif NOTDEF
d635 4
a638 3
     * stack as trapRegs.  This is safe, since we only fill in the fp, pc, and
     * nextPc fields (in Mach_StartUserProc()) and these just touch the saved-
     * window section of our stack and won't mess up any of our arguments.
d651 1
a1219 3
/* FOR DEBUGGING */
    extern	Boolean	dbgPanic;
/* END FOR DEBUGGING */
a1281 6
/* FOR DEBUGGING */
    DEBUG_ADD(0x77777777);
    DEBUG_ADD(addrErrorReg);
    DEBUG_ADD(pcValue);
    DEBUG_ADD(busErrorReg);
/* END FOR DEBUGGING */
a1285 6
/* FOR DEBUGGING */
	DEBUG_ADD(0x77777777);
	DEBUG_ADD(addrErrorReg);
	DEBUG_ADD(pcValue);
	DEBUG_ADD(busErrorReg);
/* END FOR DEBUGGING */
a1287 4
/* FOR_DEBUGGING */
	dbgPanic = TRUE;
	asm("ta 1");
/* END FOR_DEBUGGING */
d1541 14
@


1.27
log
@Seems to have fixed some interrupt problems, but now there's seg fault
problems that don't print anything, so I'm removing some printf's to
see what happens and I'm removing and changing some stuff that gets
put into the debug buffer.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.26 89/04/06 20:33:50 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d85 1
a85 1
int	machArgOffsets[SYS_NUM_SYSCALLS];	/* For each system call, tells how
d109 1
d144 11
d183 1
a183 1

d263 2
d391 1
d393 1
d572 1
d1222 3
d1263 1
a1263 13
	 */
	if (addrErrorReg == (Address) NIL) {
	    if (copyInProgress) {
		/* sun3 just returns MACH_USER_ERROR here */
#ifndef NOTDEF
		Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
#endif NOTDEF

	    } else {
		panic("MachPageFault: kernel tried to fault NIL address at pc 0x%x.\n", pcValue);
	    }
	}
	/*
d1272 6
a1277 4
		/* sun3 just returns MACH_USER_ERROR here */
#ifndef NOTDEF
		Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
#endif NOTDEF
d1287 6
d1297 7
a1303 2
	printf(
    "MachPageFault: Bus error in user proc %x, PC = %x, addr = %x BR Reg %x\n",
d1305 4
a1309 1
	DEBUG_ADD(0xcccccccc);
d1351 1
d1376 2
d1380 2
d1392 3
d1400 8
d1427 1
d1482 4
a1489 1

a1501 1
	DEBUG_ADD(0xeeeeeeee);
a1505 1
	DEBUG_ADD(0xeeeeeeee);
a1508 1
	DEBUG_ADD(0xdddddddd);
d1512 4
d1526 36
@


1.26
log
@Paranoia checkin.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.25 89/04/05 10:46:32 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d563 1
d565 1
a742 1
#ifdef NOTDEF
d746 3
a748 11
    bcopy((Address)machStatePtr->userState.trapRegs,
	      (Address)debugStatePtr->regState.regs,
	      sizeof(machStatePtr->userState.trapRegs));
    debugStatePtr->regState.regs[SP] = 
			(int)machStatePtr->userState.userStackPtr;
    debugStatePtr->regState.pc = machStatePtr->userState.excStackPtr->pc;
    debugStatePtr->regState.statusReg  =
			machStatePtr->userState.excStackPtr->statusReg;
#else
    panic("Mach_GetDebugState called.\n");
#endif NOTDEF
a772 1
#ifdef NOTDEF
d775 1
d777 9
a785 14
    bcopy((Address)debugStatePtr->regState.regs,
	      (Address)machStatePtr->userState.trapRegs,
	      sizeof(machStatePtr->userState.trapRegs) - sizeof(int));
    machStatePtr->userState.userStackPtr = 
				(Address)debugStatePtr->regState.regs[SP];
    machStatePtr->userState.excStackPtr->pc = 
				debugStatePtr->regState.pc;
    if (!(debugStatePtr->regState.statusReg & MACH_SR_SUPSTATE)) {
	machStatePtr->userState.excStackPtr->statusReg = 
				debugStatePtr->regState.statusReg;
    }
#else
    panic("Mach_SetDebugState called.\n");
#endif NOTDEF
d1255 5
d1261 1
d1279 1
d1285 1
d1287 2
d1290 1
d1333 1
d1373 1
a1373 1
     * not user the DISABLE_INTR macro, because it increments the nesting
a1378 1
    Mach_DisableIntr();
d1383 1
d1386 1
a1386 1
    Mach_EnableIntr();
d1458 1
d1463 1
d1467 1
@


1.25
log
@Can fork and exec user processes and run csh.
There's still an intermittent problem that causes a watchdog reset.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.24 89/04/01 13:02:20 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d563 1
a563 2
    Mach_MonPrintf("Mach_StartUserProc: calling MachRunUserProc - procPtr 0x%x, entryPoint = 0x%x\n", procPtr, entryPoint);
 
a639 1
    Mach_MonPrintf("Mach_ExecUserProc: calling Mach_StartUserProc - userStackPointer 0x%x\n", userStackPtr);
@


1.24
log
@Contains some changes for forking user processes.  Strangely enough, though,
forking kernel processes and exec'ing first user process still work,
even though the code changes affect them!
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.23 89/03/31 11:58:42 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d450 1
a450 1
		((Address) stackPtr) - MACH_SAVED_STATE_FRAME;
d563 1
a563 3
    Mach_MonPrintf("Mach_StartUserProc, entryPoint is 0x%x\n", entryPoint);
    Mach_MonPrintf("fp arg is 0x%x\n", procPtr->machStatePtr->trapRegs->ins[MACH_FP_REG]);
    Mach_MonPrintf("Mach_StartUserProc calling MachRunUserProc\n");
d612 3
a614 1
    Mach_MonPrintf("Mach_ExecUserProc called with userStackPtr 0x%x\n", userStackPtr);
d618 1
a625 1
    Mach_MonPrintf("Current sp, new trapRegs is 0x%x\n", procPtr->machStatePtr->trapRegs);
a633 1
    Mach_MonPrintf("fp stored at 0x%x\n", &(procPtr->machStatePtr->trapRegs->ins[MACH_FP_REG]));
d641 1
a641 2
    Mach_MonPrintf("procPtr is 0x%x\n", procPtr);
    Mach_MonPrintf("procPtr->machStatePtr is 0x%x\n", procPtr->machStatePtr);
d666 1
d898 1
a898 1
	machArgDispatch[machMaxSysCall] = (10 - numArgs - 6)*16 +
a1285 14
    printf("Page fault in user process, pc 0x%x, addr 0x%x, busError 0x%x\n",
	    pcValue, addrErrorReg, (short) busErrorReg);
    {
	unsigned	int	pte;
	unsigned	int	context;
	unsigned	int	the_seg;

	pte = VmMachGetPageMap(addrErrorReg);
	printf("pte is at first 0x%x\n", pte);
	context = VmMachGetContextReg();
	printf("context is at first 0x%x\n", context);
	the_seg = VmMachGetSegMap(addrErrorReg);
	printf("the_seg is at first 0x%x\n", the_seg);
    }
a1292 12
    }
    {
	unsigned	int	pte;
	unsigned	int	context;
	unsigned	int	the_seg;

	pte = VmMachGetPageMap(addrErrorReg);
	printf("Returning okay, pte = 0x%x.\n", pte);
	context = VmMachGetContextReg();
	printf("context is now 0x%x\n", context);
	the_seg = VmMachGetSegMap(addrErrorReg);
	printf("the_seg is now 0x%x\n", the_seg);
@


1.23
log
@Eighteenth Kernel:  it executes a signal.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.22 89/03/30 23:23:53 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d371 8
d399 9
d410 1
a410 2
	    MACH_KERN_STACK_SIZE - MACH_FULL_STACK_FRAME -
	    MACH_SAVED_STATE_FRAME;
d444 2
d449 2
d453 21
d553 2
a554 5
     * Fake set of trap regs on top of the stack and call MachReturnFromTrap
     * from MachRunUserProc?  Or set them specially in MachRunUserProc and
     * just call rett?  I think I'll assume the latter.  That way I just
     * put the values I want in the state register and store them directly
     * into real registers in MachRunUserProc().
d561 1
a561 4
    (Address) statePtr->trapRegs->nextPc = (Address)entryPoint + 4;	/* correct? */
#ifdef NOTDEF
    MachUserReturn(procPtr);
#endif NOTDEF
d566 1
a566 1
#ifdef NOTDEF
a567 3
#else
    MachRunUserProc(entryPoint, procPtr->machStatePtr->trapRegs->ins[MACH_FP_REG]);
#endif NOTDEF
a617 2
    procPtr->machStatePtr->trapRegs = &tmpTrapState;
    Mach_MonPrintf("Current sp, new trapRegs is 0x%x\n", procPtr->machStatePtr->trapRegs);
d619 1
a619 1
     * Since we're not returning, we can just user the space on our kernel
d624 10
a633 1
    (Address) procPtr->machStatePtr->trapRegs->ins[MACH_FP_REG] = userStackPtr;
d635 7
@


1.22
log
@Paranoia checkin.  Lots of new signal code.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.21 89/03/28 16:08:26 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
a1333 2
	DEBUG_ADD(0xbbbbbbbb);
	DEBUG_ADD(machStatePtr->savedMask);
@


1.21
log
@User printf's work now!  And the debugger returns without havoc since
I'm now starting the base of the debugger stack on the correct side
of its array!
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.20 89/03/26 20:16:32 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d112 25
d149 9
a157 6
int		debugCounter = 0;		/* for debugging */
int		debugSpace[500];
Address		theAddrOfVmPtr = 0; 
Address		theAddrOfMachPtr = 0;
Address		oldAddrOfVmPtr = 0; 
Address		oldAddrOfMachPtr = 0;
d252 42
a293 1
    /* base of the debugger stack */
a896 81
#ifdef NOTDEF

/*
 * ----------------------------------------------------------------------------
 *
 * MachUserReturn --
 *
 *      Take the proper action to return from a user exception.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Interrupts disabled.
 *
 * ----------------------------------------------------------------------------
 */
void
MachUserReturn(procPtr)
    register	Proc_ControlBlock	*procPtr;
{
    SignalStack			sigStack;
    Address			pc;


    if (procPtr->Prof_Scale != 0 && procPtr->Prof_PC != 0) {
	Prof_RecordPC(procPtr);
    }

    /* 
     * Take a context switch if one is pending for this process.
     */
    if (procPtr->schedFlags & SCHED_CONTEXT_SWITCH_PENDING) {
	Sched_LockAndSwitch();
    }

    /*
     * Check for signals.  Interrupts are disabled because we have to 
     * make sure that we don't miss a signal.  Interrupts will be reenabled
     * automatically upon the rte.  
     */
    while (TRUE) {
	/*
	 * Disable interrupts.  Note that we don't use the DISABLE_INTR macro
	 * because it increments the nesting depth of interrupts which we don't
	 * want because there is an implicit enable interrupts on rte.
	 */
	Mach_DisableIntr();
	if (!Sig_Pending(procPtr)) {
	    break;
	}
	Mach_EnableIntr();
	sigStack.sigStack.contextPtr = &sigStack.sigContext;
	if (Sig_Handle(procPtr, &sigStack.sigStack, &pc)) {
	    SetupSigHandler(procPtr, &sigStack, pc);
	    Mach_DisableIntr();
	    break;
	}
    }
    
    if ((procPtr->genFlags & PROC_SINGLE_STEP_FLAG) ||
	(procPtr->schedFlags & SCHED_CONTEXT_SWITCH_PENDING)) {
	/*
	 * Set the trace trap bit if we are supposed to single-step this
	 * process or a context switch is pending.  We check for a context
	 * switch pending here even though we just checked above just in
	 * case we got preempted while dealing with signals.
	 */
	procPtr->machStatePtr->userState.excStackPtr->statusReg |= 
							MACH_SR_TRACEMODE;
    }

    /*
     * It is possible for Sig_Handle to mask the migration signal
     * if a process is not in a state where it can be migrated.
     * As soon as we return to user mode, though, we will allow migration.
     */
    Sig_AllowMigration(procPtr);

}

d931 1
a931 1
 * SetupSigHandler --
d933 3
a935 2
 *      Save machine state on the users stack and set up the exception stack
 *	so that the user will call the signal handler on return. In order to
d940 1
a940 1
 *      Signal stack set up and saved.
d945 1
a945 4
SetupSigHandler(procPtr, sigStackPtr, pc)
    register	Proc_ControlBlock	*procPtr;
    register	SignalStack		*sigStackPtr;
    Address				pc;
d947 3
a949 4
    register	Mach_State	*statePtr;
    Address			usp;
    int				excStackSize;
    Mach_ExcStack		*excStackPtr;
d951 1
d953 3
a955 75
    usp = statePtr->userState.userStackPtr - sizeof(SignalStack);
    sigStackPtr->sigStack.contextPtr =
	(Sig_Context *)(usp + (unsigned int)(&sigStackPtr->sigContext) -
			      (unsigned int)sigStackPtr);
    sigStackPtr->sigContext.machContext.trapInst = 0x4e424e42;
    sigStackPtr->retAddr =
	usp + (unsigned int)(&sigStackPtr->sigContext.machContext.trapInst) -
	      (unsigned int)sigStackPtr;
    /*
     * Copy the exception stack onto the signal stack.
     */
    excStackSize = Mach_GetExcStackSize(statePtr->userState.excStackPtr);
    bcopy((Address)statePtr->userState.excStackPtr,
	      (Address)&(sigStackPtr->sigContext.machContext.excStack),
	      excStackSize);
    /*
     * Copy the user state onto the signal stack.
     */
    bcopy((Address)&statePtr->userState,
	      (Address)&(sigStackPtr->sigContext.machContext.userState),
	      sizeof(Mach_UserState));
    /*
     * Copy the stack out to user space.
     */
    if (Vm_CopyOut(sizeof(SignalStack), (Address)sigStackPtr, 
			(Address)usp) != SUCCESS) {
        printf("Warning: HandleSig: No room on stack for signal, PID=%x.\n",
                  procPtr->processID);
        Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
    }
    /*
     * We need to make a short stack to allow the process to start executing.
     * The current exception stack is at least as big, maybe bigger than we
     * need.  Since we saved the true exception stack above, we can just
     * overwrite the current stack with a short stack and point the stack
     * pointer at it.
     */
    if (statePtr->userState.excStackPtr !=
			(Mach_ExcStack *)statePtr->userState.trapRegs[SP]) {
	panic("Mach_HandleSig: SP != excStackPtr\n");
    }
    statePtr->userState.userStackPtr = usp;
    excStackPtr = (Mach_ExcStack *) ((Address)statePtr->userState.excStackPtr + 
				     excStackSize - MACH_SHORT_SIZE);
    statePtr->userState.trapRegs[SP] = (int)excStackPtr;
    excStackPtr->statusReg = 0;
    excStackPtr->vor.stackFormat = MACH_SHORT;
    excStackPtr->pc = (int)pc;
}


/*
 * ----------------------------------------------------------------------------
 *
 * ReturnFromSigHandler --
 *
 *      Process a return from a signal handler.
 *	
 * Results:
 *      None.
 *
 * Side effects:
 *      Signal stack struct and size filled in the machine struct for the
 *	given process.
 *
 * ----------------------------------------------------------------------------
 */
void
ReturnFromSigHandler(procPtr)
    register	Proc_ControlBlock	*procPtr;
{
    register	Mach_State	*statePtr;
    int				curSize;
    int				oldSize;
    SignalStack			sigStack;
a956 12
    statePtr = procPtr->machStatePtr;
    /*
     * Copy the signal stack in.
     */
    if (Vm_CopyIn(sizeof(Sig_Stack) + sizeof(Sig_Context),
		  (Address) (statePtr->userState.userStackPtr), 
		  (Address) &sigStack.sigStack) != SUCCESS) {
	printf("%s Mach_Code: Stack too small to extract trap info, PID=%x.\n",
		"Warning:", procPtr->processID);
	Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
    }
    sigStack.sigStack.contextPtr = &sigStack.sigContext;
d960 2
a961 37
    Sig_Return(procPtr, &sigStack.sigStack);
    /*
     * Restore user state.  Be careful not to clobber the stack
     * pointer.
     */
    statePtr->userState.userStackPtr = 
		    sigStack.sigContext.machContext.userState.userStackPtr;
    bcopy((Address)sigStack.sigContext.machContext.userState.trapRegs,
	      (Address)statePtr->userState.trapRegs,
	      sizeof(int) * (MACH_NUM_GPRS - 1));

    /*
     * Verify that the exception stack is OK.
     */
    curSize = Mach_GetExcStackSize(statePtr->userState.excStackPtr);
    oldSize = Mach_GetExcStackSize(&sigStack.sigContext.machContext.excStack);
    if (oldSize == -1) {
	printf("Mach_Code: Bad signal stack type.\n");
	Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
    }
    if (sigStack.sigContext.machContext.excStack.statusReg & MACH_SR_SUPSTATE) {
	printf("Mach_Code: User set kernel bit on signal stack\n");
	Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
    }
    /*
     * Copy the exception stack in.
     */
    bcopy((Address)&sigStack.sigContext.machContext.excStack,
	      (Address)&statePtr->sigExcStack, oldSize);
    statePtr->sigExcStackSize = oldSize;
    /*
     * Set the restored stack pointer to point to where the
     * old exception stack is to be restored to.
     */
    statePtr->userState.trapRegs[SP] += curSize - oldSize;
}
#endif NOTDEF
d1158 2
a1159 1
 *	A page causing a memory access error is made valid.
d1163 1
a1163 1
int
d1215 5
a1219 1
		return MACH_USER_ERROR;
d1227 4
a1230 2
		/* user error */
		return MACH_USER_ERROR;
d1238 1
a1238 1
	return MACH_OK;
a1260 1
#ifdef NOTDEF
a1261 4
#else
	/* Can I do this here temporarily this way? */
	Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
#endif NOTDEF
d1275 1
a1275 1
    return(MACH_OK);
d1307 1
a1307 2
    Sig_Stack		sigStack;
    Sig_Context		sigContext;
d1354 7
a1360 1
     * Now check for signal stuff.
d1362 8
a1369 3
    sigStack.contextPtr = &sigContext;
    if (Sig_Handle(procPtr, &sigStack, &pc)) {
	panic("MachUserAction: can't do signal stuff yet!\n");
d1371 1
d1373 91
@


1.20
log
@Seventeenth Kernel.  It executes its first system call: Sys_Shutdown().
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.19 89/03/24 15:38:56 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d110 2
d223 4
@


1.19
log
@Trying to get user procs to work.  I've just changed some stack-checking
code.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.18 89/03/22 14:07:15 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d1363 12
d1389 4
a1392 1
	int	pte;
d1395 4
d1460 2
@


1.18
log
@User process starts and gets successful page fault on its stack.
I don't think it's returning to the user process correctly, though.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.17 89/03/21 21:13:02 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d302 1
d453 3
a455 5
Mach_MonPrintf("Mach_StartUserProc, proc_RunningP's[0] is now 0x%x\n", proc_RunningProcesses[0]);
Mach_MonPrintf("entryPoint is 0x%x\n", entryPoint);
Mach_MonPrintf("procPtr->machStatePtr is 0x%x\n", procPtr->machStatePtr);
Mach_MonPrintf("trapRegs is now 0x%x\n", procPtr->machStatePtr->trapRegs);
Mach_MonPrintf("Mach_StartUserProc calling MachRunUserProc\n");
d505 3
a507 3
     Mach_DisableIntr();
     machCurStatePtr = procPtr->machStatePtr;
Mach_MonPrintf("Mach_ExecUserProc called with userStackPtr 0x%x\n", userStackPtr);
d512 1
a512 1
Mach_MonPrintf("Current sp, new trapRegs is 0x%x\n", procPtr->machStatePtr->trapRegs);
d520 3
a522 6
Mach_MonPrintf("fp stored at 0x%x\n", &(procPtr->machStatePtr->trapRegs->ins[MACH_FP_REG]));
Mach_MonPrintf("procPtr is 0x%x\n", procPtr);
Mach_MonPrintf("proc_RunningProc[0] is 0x%x\n", proc_RunningProcesses[0]);
Mach_MonPrintf("procPtr->machStatePtr is 0x%x\n", procPtr->machStatePtr);
Mach_MonPrintf("machCurStatePtr is 0x%x\n", machCurStatePtr);
Mach_MonPrintf("addr of trapRegs is 0x%x\n", &(procPtr->machStatePtr->trapRegs));
a826 331
 * MachTrap --
 *
 *      The trap handler routine.  This deals with supervisor mode and 
 *	non-supervisor mode traps differently.  The only allowed supervisor
 *	mode traps are a breakpoint trap to force a context switch and a
 *	bus error in the middle of a cross address space copy. All other
 *	traps go into the debugger.  However, all types of user traps are 
 *	processed here, except for system calls, which don't pass through
 *	this procedure unless special action (like a context switch) is
 *	needed at the end of the call.
 *
 * Results:
 *      MACH_KERN_ERROR if the debugger should be called after this routine 
 *	returns, MACH_USER_ERROR if a copy to/from user space caused an 
 *	unrecoverable bus error, and MACH_OK if everything worked out ok.
 *
 * Side effects:
 *      None.
 *
 * ----------------------------------------------------------------------------
 */
int
MachTrap(trapStack)
    Mach_TrapStack	trapStack;	/* The stack at the time of the trap.*/
{
    register	Proc_ControlBlock	*procPtr;
    ReturnStatus			status;

    procPtr = Proc_GetActualProc();
    /*
     * Process kernel traps.
     */
    if (trapStack.excStack.statusReg & MACH_SR_SUPSTATE) {
	switch (trapStack.trapType) {
	    case MACH_TRACE_TRAP:
		/*
		 * If the trace trap occured on a user trap instruction, then
		 * the trace trap will be taken on the first instruction of 
		 * the trap handler.  When this trace trap occurs,
		 * instead of the saved status register being in user mode and 
		 * having the trace trap bit set, the status register will 
		 * be in kernel mode with no trace trap bit set.
		 * In this case we just ignore the trace trap because it 
		 * will reoccur when the user process continues.
		 */
		if (!(trapStack.excStack.statusReg & MACH_SR_TRACEMODE)) {
		    return(MACH_OK);
		}

		/*
		 * In the normal case enter the debugger with a breakpoint
		 * trap.
		 */
		return(MACH_KERN_ERROR);

	    case MACH_BUS_ERROR:

		if (trapStack.busErrorReg.timeOut) {
		    /*
		     * Allow for refresh memory time just like Unix.
		     */
		    MACH_DELAY(2000);
		}

		/*
		 * Check to see if is a parity error.
		 */

#ifndef sun3
		if (trapStack.busErrorReg.parErrU || trapStack.busErrorReg.parErrL) {
		    panic("Parity error!!!\n");
		    return(MACH_KERN_ERROR);
		}

		if (trapStack.busErrorReg.busErr) {
		    panic("System bus error\n");
		    return(MACH_KERN_ERROR);
		}
#endif

		if (procPtr == (Proc_ControlBlock *)NIL) {
		    panic("MachTrap: Current process is NIL!! Trap PC 0x%x\n",
			   (unsigned) trapStack.excStack.pc);
		}

		if (procPtr->genFlags & PROC_USER) {
		    Boolean	protError;
		    Boolean	copyInProgress = FALSE;

		    /*
		     * A page fault on a user process while executing in
		     * the kernel.  This can happen when information is
		     * being copied back and forth between kernel and
		     * user state (indicated by particular values of the
		     * program counter), after a pointer is made accessible by 
		     * Vm_MakeAccessible (indicated by numMakeAcc > 0) or
		     * after someone did a set jump in the kernel and tried
		     * to access a user process.
		     */

		    if ((((unsigned) trapStack.excStack.pc) >= (unsigned) Vm_CopyIn)
			    && (((unsigned) trapStack.excStack.pc)
				< (unsigned) VmMachCopyEnd)) {
			copyInProgress = TRUE;
		    } else if ((((unsigned) trapStack.excStack.pc)
				>= (unsigned) MachFetchArgs)
			    && (((unsigned) trapStack.excStack.pc)
				<= (unsigned) MachFetchArgsEnd)) {
			copyInProgress = TRUE;
		    } else if ((procPtr->vmPtr->numMakeAcc == 0)
			&& (procPtr->machStatePtr->setJumpStatePtr
			== (Mach_SetJumpState *) NIL)) {
			return(MACH_KERN_ERROR);
		    }

		    protError = 
#ifdef sun3
				!trapStack.busErrorReg.pageInvalid;
#else
				trapStack.busErrorReg.resident;
#endif
		    /*
		     * Try to fault in the page.
		     */
		    status = Vm_PageIn(
		      (Address)trapStack.excStack.tail.addrBusErr.faultAddr,
				  protError);
		    if (status != SUCCESS) {
			if (copyInProgress) {
			    return(MACH_USER_ERROR);
			} else {
			    /*
			     * Real kernel error.  Take a long jump if
			     * possible.
			     */
			    if (procPtr->machStatePtr->setJumpStatePtr != 
						(Mach_SetJumpState *) NIL) {
				Mach_LongJump(
				    procPtr->machStatePtr->setJumpStatePtr);
			    }
			    return(MACH_KERN_ERROR);
			}
		    } else {
			return(MACH_OK);
		    }
		} else {
		    /*
		     * Happened to a kernel process.  Take a long jump if 
		     * possible.
		     */
		    if (procPtr->machStatePtr->setJumpStatePtr !=
						(Mach_SetJumpState *) NIL) {
			Mach_LongJump(procPtr->machStatePtr->setJumpStatePtr);
		    }
		    return(MACH_KERN_ERROR);
		}
	    case MACH_SPURIOUS_INT:
		/*
		 * Ignore this for now because otherwise we can't debug mint
		 */
		if (!dbg_BeingDebugged) {
		    printf("MachTrap: Spurious interrupt\n");
		}
		return(MACH_OK);

	    default:
		return(MACH_KERN_ERROR);
	}
    } 

    /*
     * Process user traps.  
     */

    /* 
     * Take a context switch if one is pending for this process.
     */

    if (procPtr->schedFlags & SCHED_CONTEXT_SWITCH_PENDING) {
	Sched_LockAndSwitch();
    }
    /*
     * Now clear out the trace trap bit out of the status register.  This is
     * a precaution to take care of cases such as when a bus error occurs on 
     * the instruction that we are trying to trace such that the trace trap bit
     * is set but we didn't get a trace trap exception.
     */
    trapStack.excStack.statusReg &= ~MACH_SR_TRACEMODE;

    switch (trapStack.trapType) {
	case MACH_BUS_ERROR: {
	    Boolean	protError;
	    if (trapStack.busErrorReg.timeOut) {
		/*
		 * Allow for refresh memory time just like Unix.
		 */

		MACH_DELAY(2000);
	    }

	    /*
	     * Check for parity error.
	     */

#ifndef sun3
	    if (trapStack.busErrorReg.parErrU || trapStack.busErrorReg.parErrL) {
		panic("Parity error!!!\n");
		return(MACH_KERN_ERROR);
	    }
#endif

	    /*
	     * Take a page fault. It is assumed that if the resident bit
	     * is set in the bus error register then this is a protection
	     * error.
	     */
	protError =
#ifdef sun3
		    !trapStack.busErrorReg.pageInvalid;
#else
		    trapStack.busErrorReg.resident;
#endif
	if (Vm_PageIn((Address)trapStack.excStack.tail.addrBusErr.faultAddr, 
		      protError) != SUCCESS) {
		printf(
		    "MachTrap: Bus error in user proc %X, PC = %x, addr = %x BR Reg %x\n",
			    procPtr->processID, 
			    trapStack.excStack.pc,
			    trapStack.excStack.tail.addrBusErr.faultAddr,
			    *(short *)&trapStack.busErrorReg);
		(void) Sig_Send(SIG_ADDR_FAULT, SIG_ACCESS_VIOL, 
				procPtr->processID, FALSE);
	    }
	    break;
	}
	case MACH_SYSCALL_TRAP:
	    /*
	     * It used to be that all system calls passed through here, but
	     * the code was optimized to avoid calling either this procedure
	     * or Sys_SysCall in the normal case.  Control only passes through
	     * here if, at the end of a system call, it's discovered that
	     * special action must be taken.  The call has already been
	     * executed by the time things arrive here.  This code does
	     * nothing... the action will all be taken by the call to
	     * MachUserReturn below.
	     */

	    break;
		
	case MACH_BRKPT_TRAP:
	    Proc_Lock(procPtr);
	    if (procPtr->genFlags & PROC_DEBUG_ON_EXEC) {
	    	procPtr->genFlags &= ~PROC_DEBUG_ON_EXEC;
		(void) Sig_SendProc(procPtr, SIG_DEBUG, SIG_NO_CODE);
	    } else {
		(void) Sig_SendProc(procPtr, SIG_BREAKPOINT, SIG_NO_CODE);
	    }
	    Proc_Unlock(procPtr);
	    break;

	case MACH_SIG_RET_TRAP: {
	    /*
	     * We got a return from signal trap.
	     */
	    ReturnFromSigHandler(procPtr);
	    return(MACH_SIG_RETURN);
	}

	case MACH_ADDRESS_ERROR:
	    (void) Sig_Send(SIG_ADDR_FAULT, SIG_ADDR_ERROR,
			    procPtr->processID, FALSE);
	    break;
	case MACH_ILLEGAL_INST:
	    (void) Sig_Send(SIG_ILL_INST, SIG_ILL_INST_CODE,
			    procPtr->processID, FALSE);
	    break;
	case MACH_ZERO_DIV:
	    (void) Sig_Send(SIG_ARITH_FAULT, SIG_ZERO_DIV,
			    procPtr->processID, FALSE);
	    break;
	case MACH_CHK_INST:
	    (void) Sig_Send(SIG_ILL_INST, SIG_CHK,
			    procPtr->processID, FALSE);
	    break;
	case MACH_TRAPV:
	    (void) Sig_Send(SIG_ILL_INST, SIG_TRAPV,
			    procPtr->processID, FALSE);
	    break;
	case MACH_PRIV_VIOLATION:
	    (void) Sig_Send(SIG_ILL_INST, SIG_PRIV_INST,
			    procPtr->processID, FALSE);
	    break;
	case MACH_TRACE_TRAP: 
	    /*
	     * Involuntary context switch trace traps have already been taken
	     * care of above.  Here the only time we pay attention to a
	     * trace trap is if the debugger is trying to single step the 
	     * user process.
	     */
	    if (procPtr->genFlags & PROC_SINGLE_STEP_FLAG) {
		procPtr->genFlags &= ~PROC_SINGLE_STEP_FLAG;
		(void) Sig_Send(SIG_TRACE_TRAP, SIG_NO_CODE,
				procPtr->processID, FALSE);
	    }
	    break;

	case MACH_EMU1010:
	    (void) Sig_Send(SIG_ILL_INST, SIG_EMU1010,
			    procPtr->processID, FALSE);
	    break;
	case MACH_EMU1111:
	    (void) Sig_Send(SIG_ILL_INST, SIG_EMU1111,
			    procPtr->processID, FALSE);
	    break;
	case MACH_BAD_TRAP:
	    (void) Sig_Send(SIG_ILL_INST, SIG_BAD_TRAP,
			    procPtr->processID, FALSE);

	    break;
	default:
	    return(MACH_KERN_ERROR);
    } 

    MachUserReturn(procPtr);
    return(MACH_OK);
}


/*
 * ----------------------------------------------------------------------------
 *
d1088 1
a1088 43


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_GetExcStackSize --
 *
 *      Return the size of the trap stack.  This can vary depending on whether
 *	are on a Sun-3 or a Sun-2.
 *
 * Results:
 *      Trap stack size.
 *
 * Side effects:
 *      None.
 *
 * ----------------------------------------------------------------------------
 */
int
Mach_GetExcStackSize(excStackPtr)
    Mach_ExcStack	*excStackPtr;
{
    switch (excStackPtr->vor.stackFormat) {
	case MACH_SHORT:
	    return(MACH_SHORT_SIZE);
	case MACH_THROWAWAY:
	    return(MACH_THROWAWAY_SIZE);
	case MACH_INST_EXCEPT:
	    return(MACH_INST_EXCEPT_SIZE);
	case MACH_MC68010_BUS_FAULT:
	    return(MACH_MC68010_BUS_FAULT_SIZE);
	case MACH_COPROC_MID_INSTR:
	    return(MACH_COPROC_MID_INSTR_SIZE);
	case MACH_SHORT_BUS_FAULT:
	    return(MACH_SHORT_BUS_FAULT_SIZE);
	case MACH_LONG_BUS_FAULT:
	    return(MACH_LONG_BUS_FAULT_SIZE);
	default:
	    printf("Warning: Mach_GetTrapStackSize: Bad stack format.\n");
	    return(-1);
    }
}
#endif NOTDEF
d1376 5
a1380 1
    printf("Returning okay.\n");
@


1.17
log
@These are bad versions.  It gets an inexplicable fault in MachRunUserProc.
I'm saving them so I can debug this later.  I have a work-around in the
meantime.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.16 89/03/19 01:21:42 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d432 1
d453 1
d457 1
d459 3
d492 1
a1677 5
    DEBUG_ADD(0x11111111);
    DEBUG_ADD(busErrorReg);
    DEBUG_ADD(addrErrorReg);
    DEBUG_ADD(trapPsr);
    DEBUG_ADD(pcValue);
a1684 1
	DEBUG_ADD(0x1);
d1716 1
a1716 2
	DEBUG_ADD(0x11);
	if (addrErrorReg == NIL) {
a1724 1
	    DEBUG_ADD(0x111);
a1725 1
		DEBUG_ADD(0x1111);
a1728 1
		DEBUG_ADD(0x1112);
a1734 7
	DEBUG_ADD(0x3333);
	{
	    int	goo;
	    goo = VmMachGetPageMap(addrErrorReg);
	    DEBUG_ADD(goo);
	    DEBUG_ADD(0x3333);
	}
a1736 1
    DEBUG_ADD(0x2);
d1738 2
a1741 1
	DEBUG_ADD(0x22);
d1753 1
a1753 1
    DEBUG_ADD(0x21);
@


1.16
log
@More stuff.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.14 89/03/17 14:51:47 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d360 1
a360 1
		fromStatePtr->trapRegs->pc;
d445 3
a447 2
    statePtr->trapRegs->pc = (Address)entryPoint;
    statePtr->trapRegs->npc = (Address)entryPoint + 4;	/* correct? */
d449 1
d451 4
d485 1
d495 25
a519 1
    procPtr->machStatePtr->trapRegs->ins[MACH_FP_REG] = userStackPtr;
d1671 5
d1678 2
a1679 2
	panic("MachPageFault: Current process is NIL!!  Trap pc is 0x%x\n",
		(unsigned) pcValue);
d1683 1
d1708 2
a1709 2
	    panic("MachPageFault: kernel page fault at illegal pc: 0x%x\n",
		    pcValue);
d1715 8
d1725 1
d1727 1
d1731 1
d1734 2
a1735 2
	    "MachPageFault: couldn't to page in kernel page at 0x%x, pc 0x%x\n",
			pcValue, addrErrorReg);
d1738 7
d1747 1
d1751 1
d1763 1
@


1.15
log
@Kernel processes work again, with a lot of user support.
@
text
@d352 5
a356 9
#ifdef NOTDEF
	statePtr->userState.userStackPtr =
		fromStatePtr->userState.userStackPtr;
	bcopy((Address)fromStatePtr->userState.trapRegs,
		  (Address)statePtr->userState.trapRegs,
		  sizeof(statePtr->userState.trapRegs));
#else
	panic("Tried to start a user process.  We're not ready yet!\n");
#endif /* NOTDEF */
d359 2
a360 5
#ifdef NOTDEF
	stackPtr->startPC = (Address)fromStatePtr->userState.excStackPtr->pc;
#else
	panic("In Mach_SetupNewState, startPC was NIL.\n");
#endif /* NOTDEF */
d383 1
d413 1
a431 1
    register	Mach_ExcStack	*excStackPtr;
d434 13
a446 7
    excStackPtr = (Mach_ExcStack *)
        (statePtr->kernStackStart + MACH_BARE_STACK_OFFSET - MACH_SHORT_SIZE);
    statePtr->userState.excStackPtr = excStackPtr;
    statePtr->userState.trapRegs[SP] = (int)excStackPtr;
    excStackPtr->statusReg = 0;
    excStackPtr->pc = (int)entryPoint;
    excStackPtr->vor.stackFormat = MACH_SHORT;
d473 1
a473 1
    Address		userStackPtr;	/* Stack pointer for when the
d479 10
a488 2
#ifdef NOTDEF
    procPtr->machStatePtr->userState.userStackPtr = userStackPtr;
a490 3
#else
    panic("Mach_ExecUserProc called\n");
#endif NOTDEF
@


1.14
log
@Interrim checkin.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.13 89/03/09 17:08:01 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d18 1
d22 3
d84 11
a94 4
#define	MAXCALLS	120
#define	MAXARGS		2

ReturnStatus	(*(mach_NormalHandlers[MAXCALLS]))();
d99 1
a99 1
ReturnStatus (*(mach_MigratedHandlers[MAXCALLS]))();
d103 8
d119 3
a121 4
Mach_RegState	regStateHolder;
Mach_State	stateHolder;
Proc_ControlBlock	dumb;
int		machMachProcOffset = 0;		/* set to offset in pcb */
a123 1
char		mach_DebugStack[0x2000];	/* debugger stack */
a162 3
    /* Temporary: for debugging net module and debugger: */
    mach_NumDisableInterrupts[0] = 1;

d182 2
a183 1
    if ((unsigned int)(&(stateHolder.s)) - (unsigned int)(&stateHolder) != o) {\
d187 2
a188 2
    if ((unsigned int)(&(regStateHolder.s)) -	\
	(unsigned int)(&regStateHolder) != o) {\
d195 3
d206 5
d214 10
a223 2
    machMachProcOffset = (unsigned int)(&(dumb.machStatePtr)) -
	    (unsigned int)(&dumb);
a435 1
#ifdef NOTDEF
a450 3
#else
    panic("Mach_StartUserProc called.\n");
#endif NOTDEF
a507 1
#ifdef NOTDEF
a511 3
#else
    panic("Mach_FreeState called.\n");
#endif NOTDEF
d705 1
a705 1
    if (machMaxSysCall >= MAXCALLS) {
d708 1
a708 1
    if (numArgs > MAXARGS) {
d737 1
a737 1
	machArgDispatch[machMaxSysCall] =  MachFetchArgsEnd;
d740 1
a740 1
		(Address)((unsigned int)MachFetchArgs);
a1561 9
#ifdef NOTDEF
void
MachHandleTestCounter()
{
    Mach_MonPrintf("timer reached 1000\n");
    return;
}
#endif NOTDEF

d1631 3
d1660 1
a1660 1
		(pcValue < = MachFetchArgsEnd)) {
d1696 3
d1770 3
a1772 2
		if (Vm_CopyOut(size, (Address)&(machStatePtr->savedRegs[i]),
			machStatePtr->savedSps[i]) != SUCCESS
d1782 1
a1782 1
    if (Sig_Handle(procPtr, &sigStack, &pc))a {
@


1.13
log
@Keyboard interrupts work.  Checking in before I've made too many
further changes.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.12 89/03/06 12:01:20 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d180 1
d286 2
a287 1
	    MACH_KERN_STACK_SIZE - MACH_FULL_STACK_FRAME - MACH_FULL_TRAP_FRAME;
d302 1
a302 1
	    ((Address)stackPtr) + MACH_FULL_TRAP_FRAME;
a677 1
#ifdef NOTDEF
d688 31
a718 3
    machArgOffsets[machMaxSysCall] = 8 + numArgs*4;
    machArgDispatch[machMaxSysCall] = 
		(16-numArgs)*2 + (Address) ((unsigned int)MachFetchArgs);
a720 1
#endif NOTDEF
d722 1
d1592 173
@


1.12
log
@Sixteenth Kernel.  Kernel processes work and play tag over a monitor
lock.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.11 89/03/03 15:40:12 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d113 3
a115 1
 * For debugging stuff, put values into a circular buffer.
d118 1
d122 1
a122 1
    debugSpace[debugCounter++] = (int)(thing);
@


1.11
log
@Fifteenth Kernel.  Initializes all kernel procs and gets to idle loop.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.10 89/03/02 00:20:05 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
a260 4
    DEBUG_ADD(0x111);
    DEBUG_ADD(procPtr);
    DEBUG_ADD(startFunc);

d282 1
a282 2
	    MACH_KERN_STACK_SIZE - MACH_SAVED_WINDOW_SIZE -
	    MACH_SAVED_WINDOW_SIZE - sizeof (Mach_RegState);
a283 2
    DEBUG_ADD(statePtr->switchRegs);
    DEBUG_ADD(&(statePtr->switchRegs));
d297 1
a297 2
	    ((Address)stackPtr) + sizeof (Mach_RegState);
    DEBUG_ADD(*((Address *)(((Address)stackPtr) + MACH_FP_OFFSET)));
a304 1
    DEBUG_ADD(*((Address *)(((Address)stackPtr) + MACH_RETPC_OFFSET)));
a342 1
	DEBUG_ADD(*((Address *)(((Address)stackPtr) + MACH_ARG0_OFFSET)));
a343 1
    DEBUG_ADD(0x222);
@


1.10
log
@Kernel procs exist now, but it deadlocks.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.9 89/02/28 12:47:30 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d107 4
d286 2
a287 2
	    MACH_KERN_STACK_SIZE -
	    sizeof (Mach_RegState) - MACH_SAVED_WINDOW_SIZE;
d345 5
a349 3
	 * Mach_ContextSwitch's window.  So we have to put it in the in register
	 * area of the saved window area beneath the Mach_RegState area on the
	 * stack.
d351 2
a352 3
	*((Address *)(((Address)stackPtr) + sizeof (Mach_RegState) +
		MACH_ARG0_OFFSET)) = startPC;
	DEBUG_ADD(*((Address *)(((Address)stackPtr) + sizeof (Mach_RegState) + MACH_ARG0_OFFSET)));
@


1.9
log
@Added more interrupt-handling support
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.8 89/02/24 21:57:12 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d102 2
d108 12
d161 1
a161 1
    if ((int)(&(stateHolder.s)) - (int)(&stateHolder) != o) {\
d165 2
a166 1
    if ((int)(&(regStateHolder.s)) - (int)(&regStateHolder) != o) {\
d172 1
d179 6
d212 2
d254 1
a254 2
#ifdef NOTDEF
    register	KernelStack	*stackPtr;
d257 4
d263 1
d265 1
a266 1

d268 1
d272 1
a272 1
    statePtr->kernStackStart = Vm_GetKernelStack(0);
a276 3
    statePtr->switchRegs[SP] = (int)(statePtr->kernStackStart + 
			             MACH_KERN_STACK_SIZE - 
				     sizeof(KernelStack));
d278 10
d291 24
a314 7
    stackPtr = (KernelStack *)(statePtr->switchRegs[SP]);
    stackPtr->magicNumber = MAGIC;
    stackPtr->userStackPtr = mach_MaxUserStackAddr;
    stackPtr->statusReg = MACH_SR_HIGHPRIO;
    stackPtr->startFunc =  startFunc;
    stackPtr->fill1 = 0;
    stackPtr->fill2 = 0;
d321 1
d327 3
d332 1
d334 3
d338 10
a347 1
	stackPtr->startPC = startPC;
d349 1
a350 3
#else
    panic("Mach_SetUpNewState called.\n");
#endif NOTDEF
d374 6
a379 5
#ifdef NOTDEF
    procPtr->machStatePtr->userState.trapRegs[D0] = retVal;
#else
    panic("Mach_SetReturnVal called.\n");
#endif NOTDEF
@


1.8
log
@Fourteenth Kernel.  Debugger works, uses mem module and stdlib.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.7 89/02/24 16:38:22 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d15 1
d19 2
d56 5
d80 12
d93 5
d167 23
d191 500
d692 2
a693 2
panic(s)
char	*s;
d695 155
a849 3
    Mach_MonPrintf(s);
    for (; ;) {
	;
d851 144
d996 308
d1306 46
d1353 93
d1449 47
@


1.7
log
@Thirteenth Kernel.  sun4 finishes vm init now.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.6 89/01/29 17:21:06 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d79 1
@


1.6
log
@Tenth Kernel.  Net module works for receiving, and I seem to set up
state and enter the debugger from a debugger trap correctly.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.5 89/01/25 22:53:11 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d141 1
d151 1
@


1.5
log
@Ninth Kernel.  Timer interrupts and overflow and underflow traps still
are all it does functionally, but now I save and restore state in a fancy
way that will allow nested interrupts, avoids duplicating saved state,
and works the same way for the debugger.  See README and the code for
details.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.4 89/01/23 17:54:47 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d35 5
d99 3
@


1.4
log
@Eigth Kernel.  It now takes interrupts and traps correctly.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.3 89/01/23 00:06:15 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d68 1
a68 2
 * Temporarily, for implementing and testing interrupts, I'm saving trap
 * state into the following buffer.
d70 4
a73 2
Mach_RegState	stateHolder;
Mach_RegState	*temporaryTrapState = &stateHolder;
d107 3
a109 3
#define	CHECK_OFFSETS1(s, o)		\
    if ((int)(&(stateHolder.s)) - (int)(&stateHolder) != o) {\
	panic("Bad offset for trap registers.  Redo machConst.h!\n");\
d111 2
a112 1
#define	CHECK_OFFSETS2(s, o)		\
d114 1
a114 1
	panic("Bad offset for psr register.  Redo machConst.h!\n");\
d116 3
a118 3
#define	CHECK_OFFSETS3(s, o)		\
    if ((int)(&(stateHolder.s)) - (int)(&stateHolder) != o) {\
	panic("Bad offset for y register.  Redo machConst.h!\n");\
a119 8
#define	CHECK_OFFSETS4(s, o)		\
    if ((int)(&(stateHolder.s)) - (int)(&stateHolder) != o) {\
	panic("Bad offset for tbr register.  Redo machConst.h!\n");\
    }
#define	CHECK_OFFSETS5(s, o)		\
    if ((int)(&(stateHolder.s)) - (int)(&stateHolder) != o) {\
	panic("Bad offset for wim register.  Redo machConst.h!\n");\
    }
d121 7
a127 9
    CHECK_OFFSETS1(regs, MACH_TRAP_REGS_OFFSET);
    CHECK_OFFSETS2(psr, MACH_PSR_OFFSET);
    CHECK_OFFSETS3(y, MACH_Y_OFFSET);
    CHECK_OFFSETS4(tbr, MACH_TBR_OFFSET);
    CHECK_OFFSETS5(wim, MACH_WIM_OFFSET);
#ifdef NOTDEF
    CHECK_OFFSETS(curPC, MACH_PC_OFFSET);
    CHECK_OFFSETS(nextPC, MACH_NEXT_PC_OFFSET);
#endif /* NOTDEF */
@


1.3
log
@Seventh kernel.  Clock interrupt level is now at 10.  Interrupts work for
>> what I have, but I'm not printing anything, which didn't work before,
>> so I must try that again.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.2 89/01/22 23:45:15 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
a153 1
#ifdef NOTDEF
a154 1
#endif NOTDEF
@


1.2
log
@Interrupts seem to work again, but I've got lots of debugging
code in here.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun4.md/RCS/machCode.c,v 1.1 89/01/22 20:31:59 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
a73 3
int	saveBuffer[1000];
int	saveCounter = 0;
int	saveStart = 0;
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun2.md/RCS/machCode.c,v 8.3 89/01/13 09:37:57 douglis Exp $ SPRITE (Berkeley)";
a72 6
/*
 * Temporarily, for counting clock interrupts, I'm saving a counter in
 * this integer.
 */
int	counterHolder;
int	*temporaryClockCounter = &counterHolder;
d74 3
@
