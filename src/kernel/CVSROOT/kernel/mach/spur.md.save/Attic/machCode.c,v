head     8.11;
branch   ;
access   ;
symbols  symm:8.11 spur:8.11 newlib:8.0;
locks    ; strict;
comment  @ * @;


8.11
date     90.06.21.12.39.01;  author jhh;  state Exp;
branches ;
next     8.10;

8.10
date     90.02.20.15.30.58;  author jhh;  state Exp;
branches ;
next     8.9;

8.9
date     90.02.12.09.05.22;  author david;  state Exp;
branches ;
next     8.8;

8.8
date     89.09.12.14.39.06;  author jhh;  state Exp;
branches ;
next     8.7;

8.7
date     89.08.31.12.44.19;  author douglis;  state Exp;
branches ;
next     8.6;

8.6
date     89.08.17.17.25.31;  author jhh;  state Exp;
branches ;
next     8.5;

8.5
date     89.06.19.14.01.50;  author jhh;  state Exp;
branches ;
next     8.4;

8.4
date     89.03.15.17.45.20;  author mendel;  state Exp;
branches ;
next     8.3;

8.3
date     89.02.06.09.03.51;  author brent;  state Exp;
branches ;
next     8.2;

8.2
date     89.01.11.09.47.11;  author mendel;  state Exp;
branches ;
next     8.1;

8.1
date     88.11.30.10.36.50;  author mendel;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.06.21;  author douglis;  state Stable;
branches ;
next     1.27;

1.27
date     88.11.11.15.36.14;  author mendel;  state Exp;
branches ;
next     1.26;

1.26
date     88.10.20.09.20.40;  author mendel;  state Exp;
branches ;
next     1.25;

1.25
date     88.10.13.13.29.00;  author mendel;  state Exp;
branches ;
next     1.24;

1.24
date     88.09.19.11.08.43;  author mendel;  state Exp;
branches ;
next     1.23;

1.23
date     88.09.13.16.49.49;  author brent;  state Exp;
branches ;
next     1.22;

1.22
date     88.09.13.10.35.28;  author mendel;  state Exp;
branches ;
next     1.21;

1.21
date     88.09.02.11.53.00;  author nelson;  state Exp;
branches ;
next     1.20;

1.20
date     88.08.29.13.52.49;  author mendel;  state Exp;
branches ;
next     1.19;

1.19
date     88.08.27.18.58.48;  author nelson;  state Exp;
branches ;
next     1.18;

1.18
date     88.08.27.17.26.25;  author nelson;  state Exp;
branches ;
next     1.17;

1.17
date     88.08.27.14.26.44;  author nelson;  state Exp;
branches ;
next     1.16;

1.16
date     88.08.26.11.55.20;  author nelson;  state Exp;
branches ;
next     1.15;

1.15
date     88.08.23.11.45.14;  author nelson;  state Exp;
branches ;
next     1.14;

1.14
date     88.08.23.10.19.44;  author mendel;  state Exp;
branches ;
next     1.13;

1.13
date     88.08.18.18.43.48;  author nelson;  state Exp;
branches ;
next     1.12;

1.12
date     88.08.17.11.58.05;  author mendel;  state Exp;
branches ;
next     1.11;

1.11
date     88.08.09.18.38.56;  author nelson;  state Exp;
branches ;
next     1.10;

1.10
date     88.08.01.15.04.13;  author mendel;  state Exp;
branches ;
next     1.9;

1.9
date     88.07.31.22.48.07;  author mendel;  state Exp;
branches ;
next     1.8;

1.8
date     88.07.29.11.33.50;  author nelson;  state Exp;
branches ;
next     1.7;

1.7
date     88.07.29.11.26.42;  author nelson;  state Exp;
branches ;
next     1.6;

1.6
date     88.07.23.12.51.09;  author nelson;  state Exp;
branches ;
next     1.5;

1.5
date     88.07.20.18.29.57;  author nelson;  state Exp;
branches ;
next     1.4;

1.4
date     88.07.16.15.41.06;  author nelson;  state Exp;
branches ;
next     1.3;

1.3
date     88.07.15.12.25.27;  author nelson;  state Exp;
branches ;
next     1.2;

1.2
date     88.07.13.15.55.53;  author mendel;  state Exp;
branches ;
next     1.1;

1.1
date     88.07.12.14.46.02;  author brent;  state Exp;
branches ;
next     ;


desc
@Machine dependent initializations
@


8.11
log
@*** empty log message ***
@
text
@/* 
 * machCode.c --
 *
 *     C code for the mach module.
 *
 * Copyright (C) 1985 Regents of the University of California
 * All rights reserved.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/mach/spur.md/RCS/machCode.c,v 8.10 90/02/20 15:30:58 jhh Exp $ SPRITE (Berkeley)";
#endif not lint

#include "sprite.h"
#include "machCCRegs.h"
#include "machConst.h"
#include "machInt.h"
#include "mach.h"
#include "sync.h"
#include "dbg.h"
#include "proc.h"
#include "sched.h"
#include "vm.h"
#include "vmMachInt.h"
#include "sig.h"
#include "sigMach.h"
#include "swapBuffer.h"
#include "dev/ccdev.h"
#include "machConfig.h"
#include "devCC.h"


int mach_NumProcessors = 1;

/*
 * Master control processor.
 */

extern int machMasterProcessor;

/*
 * Start per processor data. 
 */

/*
 * TRUE if cpu was in kernel mode before the interrupt, FALSE if was in 
 * user mode.
 */
Boolean	mach_KernelMode[MACH_MAX_NUM_PROCESSORS];


/*
 *  Flag used by routines to determine if they are running at
 *  interrupt level.
 */
Boolean mach_AtInterruptLevel[MACH_MAX_NUM_PROCESSORS];

/*
 *  Count of number of ``calls'' to enable interrupts minus number of calls
 *  to disable interrupts.  Kept on a per-processor basis.
 */
int mach_NumDisableInterrupts[MACH_MAX_NUM_PROCESSORS];
int *mach_NumDisableIntrsPtr = mach_NumDisableInterrupts;

/*
 * The machine type string is imported by the file system and
 * used when expanding $MACHINE in file names.
 */
char *mach_MachineType = "spur";

/*
 * The byte ordering/alignment type used by Fmt_Convert for I/O control data.
 */
Fmt_Format mach_Format = FMT_SPUR_FORMAT;


/* 
 * Pointer to the state structure for the current process.
 * Allocated in low memory. This structure is indexed by NuBus slot id so
 * there is current process for each board in the system.
 */
extern Mach_State	*machCurStatePtrs[];

/*
 * Debugger state.
 */
Mach_RegState	machDebugState[MACH_MAX_NUM_PROCESSORS];
extern Mach_RegState *machDebugStatePtrs[];
int machDebugSignal[MACH_MAX_NUM_PROCESSORS];

/*
 * Cache controller state.
 */
CCdev	machCCState[MACH_MAX_NUM_PROCESSORS];

/*
 * State of each processor in the system.
 */

Mach_ProcessorStatus	mach_ProcessorStatus[MACH_MAX_NUM_PROCESSORS];

/*
 * Machine dependent variables.
 */
Address	mach_KernStart;
Address	mach_CodeStart;
Address	mach_StackBottom;
int	mach_KernStackSize;
int	mach_SpecialStackSize;
Address	mach_KernEnd;
Address	mach_FirstUserAddr;
Address	mach_LastUserAddr;
Address	mach_MaxUserStackAddr;
int	mach_LastUserStackPage;

Mach_InstCountInfo mach_InstCount[MACH_MAX_INST_COUNT];
Boolean	mach_DoInstCounts = FALSE;

unsigned int	mach_CycleTime = MACH_CYCLE_TIME;

static int machDbgInterruptNumber;
static int machCheckSpecialInterruptNum;
/*
 * The variables and tables below are used by the assembler routine
 * in loMem.s that dispatches kernel calls.  All of this information
 * is shared with loMem.s;  if you change any of this, be sure to
 * change the assembler to match.
 */

#define MAXCALLS 120
#define MAXARGS  12

extern	int machMaxSysCall;		/* Highest defined system call. */
int machNumArgs[MAXCALLS];		/* For each system call, gives the
					 * number of arguments. */
ReturnStatus (*(mach_NormalHandlers[MAXCALLS]))();
					/* For each system call, gives the
					 * address of the routine to handle
					 * the call for non-migrated processes.
					 */
ReturnStatus (*(mach_MigratedHandlers[MAXCALLS]))();
					/* For each system call, gives the
					 * address of the routine to handle
					 * the call for migrated processes. */
extern int machKcallTableOffset;	/* Byte offset of the kcallTable field
					 * in a Proc_ControlBlock. */
extern int machStatePtrOffset;		/* Byte offset of the machStatePtr
					 * field in a Proc_ControlBlock. */
extern int machSpecialHandlingOffset;	/* Byte offset of the special handling
					 * flag in the proc table. */
extern int machTrapTableOffset;		/* The offset of the trap table
					 * within the special user page. */


extern int machDebugSlave;

/*
 * Interrupt table struct.
 */
void	(*(interruptHandlers[MACH_NUM_INTR_TYPES]))();
void	InterruptError();

void	MachFetchArgStart();
void	MachFetchArgEnd();

/*
 * Foward routine declaration.
 */
static void EnterDebugger();
static void doNothing();

#ifdef	PATCH_IBUFFER
#endif


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_Init --
 *
 *	Initialize the mach module.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The exception vector table is initialized.
 *
 * ----------------------------------------------------------------------------
 */
void
Mach_Init()
{
    int	i;
    /*
     * Set exported machine dependent variables.
     */
    mach_KernStart = (Address)MACH_KERN_START;
    mach_KernEnd = (Address)MACH_KERN_END;
    mach_CodeStart = (Address)MACH_CODE_START;
    mach_StackBottom = (Address)MACH_STACK_BOTTOM;
    mach_KernStackSize = MACH_KERN_STACK_SIZE;
    mach_SpecialStackSize = MACH_SPECIAL_STACK_SIZE;
    mach_FirstUserAddr = (Address)MACH_FIRST_USER_ADDR;
    mach_LastUserAddr = (Address)MACH_LAST_USER_ADDR;
    mach_MaxUserStackAddr = (Address)MACH_MAX_USER_STACK_ADDR;
    mach_LastUserStackPage = MACH_LAST_USER_STACK_PAGE;

    /* 
     * Initialize the trap handler offset.
     */
    machTrapTableOffset = (int) ((Mach_SpecPage *) 0)->trapTable;
    /*
     * Initialize some of the dispatching information.  The rest is
     * initialized by Mach_InitSysCall below.
     */
    machMaxSysCall = -1;
    machKcallTableOffset = (int) &((Proc_ControlBlock *) 0)->kcallTable;
    machStatePtrOffset = (int) &((Proc_ControlBlock *) 0)->machStatePtr;
    machSpecialHandlingOffset = (int) &((Proc_ControlBlock *) 0)->specialHandling;
    /*
     * Initialize the machine configuation.
     */
    Mach_ConfigInit();
    /*
     * For each processor
     */
    for (i = 0; i < MACH_MAX_NUM_PROCESSORS; i++) { 
	/*
	 * We start off with interrupts disabled.
	 */
	mach_NumDisableInterrupts[i] = 1;
	/*
	 * But not at interrupt level.
	 */
	mach_AtInterruptLevel[i] = 0;
	/*
	 * Initialized the debugStatePtrs. 
	 */
	machDebugStatePtrs[i] = &(machDebugState[i]);
	/*
  	 * Initialize the status. 
	 */

	 mach_ProcessorStatus[i] = MACH_UNINITIALIZED_STATUS;
    }

    /*
     * The processor that executes this code is the master processor.
     */
    machMasterProcessor = Mach_GetProcessorNumber();
    mach_ProcessorStatus[Mach_GetProcessorNumber()] = MACH_ACTIVE_STATUS;

    /*
     * Initialize the interrupt handler table.
     */
    for (i = 0; i < MACH_NUM_INTR_TYPES; i++) {
	interruptHandlers[i] = InterruptError;
    }
    /*
     * Turn off all timers (unless we're trying to do instruction counts.)
     */
    if (mach_DoInstCounts) {
	Mach_Write8bitCCReg(MACH_MODE_REG /* | MACH_MODE_T0_ENABLE */, 
	    MACH_MODE_PERF_COUNTER_MASK & MACH_MODE_PERF_COUNTER_SYS);
    } else {
	Mach_Write8bitCCReg(MACH_MODE_REG,0);
    }
    bzero(mach_InstCount, sizeof(mach_InstCount));
    /*
     * Clear the interrupt mask register and any pending interrupts.
     */
    Mach_Write32bitCCReg((unsigned int)MACH_INTR_MASK_0,(unsigned int)0);
    Mach_Write32bitCCReg((unsigned int)MACH_INTR_STATUS_0,(unsigned int)-1);

    /*
     * Start the refresh timer.
     */
    Mach_RefreshStart();

    /*
     * Set up the debugger interrupt.
     */
    machDbgInterruptNumber = MACH_EXT_INTERRUPT_ANY;
    Mach_AllocExtIntrNumber(EnterDebugger,&machDbgInterruptNumber);
    machDbgInterruptMask = (1 << machDbgInterruptNumber);
    Mach_SetNonmaskableIntr(machDbgInterruptMask);
    /*
     * Initialize the cross processor communication.
     */
    Mach_CPC_Init();
    /*
     * Initialize the check special handling interrupt.
     */
    machCheckSpecialInterruptNum = MACH_EXT_INTERRUPT_ANY;
    Mach_AllocExtIntrNumber(doNothing,&machCheckSpecialInterruptNum);

    Mach_MonInit();
#define	CHECK_OFFSETS
#ifdef CHECK_OFFSETS
    /* 
     * Check of values of _OFFSETS in machConst.h used by assembly code in 
     * loMem.s to index into C structures.
     */
#define	C(s,o)	if ((int)&(((Mach_State*)0x0)->userState.trapRegState.s)!= o){\
			panic( "Bad offset %d != %d\n", \
			(int)&(((Mach_State*)0x0)->userState.trapRegState.s)\
			,o); \
		}

    C(regs,MACH_TRAP_REGS_OFFSET); C(kpsw,MACH_TRAP_KPSW_OFFSET);
    C(curPC,MACH_TRAP_CUR_PC_OFFSET); C(nextPC, MACH_TRAP_NEXT_PC_OFFSET);
    C(insert,MACH_TRAP_INSERT_OFFSET); C(swp, MACH_TRAP_SWP_OFFSET);
    C(cwp, MACH_TRAP_CWP_OFFSET);

#undef C
#define	C2(s,o)	if ((int)&(((Mach_State*)0x0)->userState.s)!= o){\
			panic( "Bad offset %d != %d\n", \
			(int)&(((Mach_State*)0x0)->userState.s),o); \
		}
    C2(specPageAddr, MACH_SPEC_PAGE_ADDR_OFFSET); 
    C2(swpBaseAddr, MACH_SWP_BASE_ADDR_OFFSET);
    C2(swpMaxAddr, MACH_SWP_MAX_ADDR_OFFSET);
    C2(minSWP,MACH_MIN_SWP_OFFSET); C2(maxSWP,MACH_MAX_SWP_OFFSET);
    C2(newCurPC,MACH_NEW_CUR_PC_OFFSET); C2(sigNum,MACH_SIG_NUM_OFFSET); 
    C2(sigCode, MACH_SIG_CODE_OFFSET); 
    C2(oldHoldMask,MACH_OLD_HOLD_MASK_OFFSET );
    C2(faultAddr,MACH_FAULT_ADDR_OFFSET);
#undef C2
#define	C3(s,o)	if ((int)&(((Mach_State*)0x0)->s)!= o){\
			panic( "Bad offset %d != %d\n", \
			(int)&(((Mach_State*)0x0)->s),o); \
			}
    C3(kernStackStart, MACH_KERN_STACK_START_OFFSET);
    C3(kernStackEnd, MACH_KERN_STACK_END_OFFSET);
#undef C3
#define	C4(s,o)	if ((int)&(((Mach_State*)0x0)->switchRegState.s)!= o){\
			panic( "Bad offset %d != %d\n", \
			(int)&(((Mach_State*)0x0)->switchRegState.s),o); \
		}
    C4(regs,MACH_SWITCH_REGS_OFFSET); C4(kpsw,MACH_SWITCH_KPSW_OFFSET);
    C4(upsw,MACH_SWITCH_UPSW_OFFSET); C4(curPC, MACH_SWITCH_CUR_PC_OFFSET);
    C4(nextPC, MACH_SWITCH_NEXT_PC_OFFSET); 
    C4(insert, MACH_SWITCH_INSERT_OFFSET);
    C4(swp, MACH_SWITCH_SWP_OFFSET); C4(cwp, MACH_SWITCH_CWP_OFFSET);
#undef C4
#endif

}


/*
 *----------------------------------------------------------------------
 *
 * InterruptError --
 *
 *	Handle a non-handled interrupt type.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
InterruptError(statusRegPtr)
    unsigned 	int	*statusRegPtr;
{
    panic( "InterruptError: Bogus interrupt, ISR=0x%x\n",
			 *statusRegPtr);
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_InitFirstProc --
 *
 *	Initialize the machine state struct for the very first process.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Machine info allocated and stack start set up.
 *
 *----------------------------------------------------------------------
 */
void
Mach_InitFirstProc(procPtr)
    Proc_ControlBlock	*procPtr;
{
    procPtr->machStatePtr = (Mach_State *)Vm_RawAlloc(sizeof(Mach_State));
    bzero((char *)procPtr->machStatePtr, sizeof(Mach_State));
    procPtr->machStatePtr->kernStackStart = mach_StackBottom;
    procPtr->machStatePtr->kernStackEnd = mach_StackBottom + 
					  mach_SpecialStackSize;
    machCurStatePtrs[Mach_GetProcessorNumber()] = procPtr->machStatePtr;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_SetupNewState --
 *
 *	Initialize the machine state for this process.  This includes 
 *	allocating and initializing a kernel stack.  Assumed that will
 *	be called when starting a process after a fork or restarting a
 *	process after a migration.
 *
 * Results:
 *	PROC_NO_STACKS if couldn't allocate a kernel stack.  SUCCESS otherwise.
 *
 * Side effects:
 *	Machine state in the destination process control block is overwritten.
 *
 *----------------------------------------------------------------------
 */ 
/*ARGSUSED*/
ReturnStatus
Mach_SetupNewState(procPtr, parStatePtr, startFunc, startPC, user)
    Proc_ControlBlock	*procPtr;	/* Pointer to process control block
					 * to initialize state for. */
    Mach_State		*parStatePtr;	/* State of parent on fork or from
					 * other machine on migration. */
    void		(*startFunc)();	/* Function to call when process first
					 * starts executing. */
    Address		startPC;	/* Address to pass as argument to 
					 * startFunc.  If NIL then the address
					 * is taken from *parStatePtr's 
					 * exception stack. */
    Boolean		user;		/* TRUE if is a user process. */
{
    register	Mach_State	*statePtr;

    if (procPtr->machStatePtr == (Mach_State *)NIL) {
	procPtr->machStatePtr = (Mach_State *)Vm_RawAlloc(sizeof(Mach_State));
    }

   statePtr = procPtr->machStatePtr;
   bzero((char *)statePtr, sizeof(Mach_State));
    /*
     * Allocate a kernel stack for this process.
     */
    statePtr->kernStackStart = Vm_GetKernelStack(2);
    if (statePtr->kernStackStart == (Address)NIL) {
	return(PROC_NO_STACKS);
    }
    statePtr->kernStackEnd = statePtr->kernStackStart + mach_KernStackSize;
    /*
     * Set up the switch regs so that things start out like we were in
     * the middle of a context switch.  When we context switch in this process
     * it will restore its state from the regs.  The restore of state
     * restores up through the parents window.  Thus when we start running
     * we will have access to our parents r26 through r31 as r10 through
     * r15.  MachContextSwitch will return to the value stored in the curPC 
     * field so we set the value of the function to start executing in this 
     * field.  When it returns it will go back one window (which will be the
     * exact window of switchRegState.regs) and start executing in the start
     * function.  The start function will expect as an argument the PC of
     * where to start the process for real.  Thus in order to set up the 
     * first arg we have to put a value in MACH_INPUT_REG1.
     */
    statePtr->switchRegState.regs[MACH_SPILL_SP][0] = (int)statePtr->kernStackEnd;
    statePtr->switchRegState.kpsw = (
#ifdef WITH_IBUFFER
#ifdef WITH_PREFETCH
				     MACH_KPSW_PREFETCH_ENA |
#endif
				     MACH_KPSW_IBUFFER_ENA |
#endif
				     MACH_KPSW_VIRT_DFETCH_ENA |
				     MACH_KPSW_VIRT_IFETCH_ENA |
				     MACH_KPSW_ALL_TRAPS_ENA |
				     MACH_KPSW_FAULT_TRAP_ENA |
				     MACH_KPSW_ERROR_TRAP_ENA |
				     MACH_KPSW_INTR_TRAP_ENA);
    /*
     * Clear the upsw so the kernel doesn't take random user traps.
     */
    statePtr->switchRegState.upsw = 0;
    /*
     * MachContextSwitch does a "return curPC,$8" so the starting address
     * should be startFunc - 8.
     */
    statePtr->switchRegState.curPC = (Address)((unsigned int)startFunc) - 8;
    /*
     * Start the cwp such that when MachContextSwitch returns it won't
     * cause an underflow.  Note that we want the second window so we set
     * the cwp to 8 since the window number is shifted over by 2 bits.
     */
    statePtr->switchRegState.cwp = 8;
    statePtr->switchRegState.swp = statePtr->kernStackStart;
    if (startPC == (Address)NIL) {
	/*
	 * User processes inherit from their parent.  The parameter that
	 * is passed to the start function is ignored.  What is important
	 * is the first and next PCs in the trap register state which will
	 * be restored before the process is started running in user mode.
	 */
	bcopy((Address)&parStatePtr->userState.trapRegState,
	      (Address)&statePtr->userState.trapRegState,
	      sizeof(statePtr->userState.trapRegState));
	/* 
	 * User processes also inherit saved window state from their
	 * parent.
	 */
	statePtr->userState.specPageAddr = parStatePtr->userState.specPageAddr;
	statePtr->userState.swpBaseAddr = parStatePtr->userState.swpBaseAddr;
	statePtr->userState.swpMaxAddr = parStatePtr->userState.swpMaxAddr;
	statePtr->userState.minSWP = parStatePtr->userState.minSWP;
	statePtr->userState.maxSWP = parStatePtr->userState.maxSWP;
    } else {
	/*
	 * Kernel processes start executing at startPC.
	 */
	statePtr->switchRegState.regs[MACH_INPUT_REG1][0] = (int)startPC;
	statePtr->userState.minSWP = 0;
	statePtr->userState.maxSWP = 0;
    }
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * Mach_SetReturnVal --
 *
 *	Set the return value for a process from a system call.  Intended to
 *	be called by the routine that starts a user process after a fork.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Register D0 is set in the user registers.
 *
 *----------------------------------------------------------------------
 */ 
void
Mach_SetReturnVal(procPtr, retVal)
    Proc_ControlBlock	*procPtr;	/* Process to set return value for. */
    int			retVal;		/* Value for process to return. */
{
    procPtr->machStatePtr->userState.trapRegState.regs[MACH_RETURN_VAL_REG][0] = retVal;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_StartUserProc --
 *
 *	Start a user process executing for the first time.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Stack pointer and the program counter set for the process and
 *	the current process's image is replaced.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
void
Mach_StartUserProc(procPtr, entryPoint)
    Proc_ControlBlock	*procPtr;	/* Process control block for process
					 * to start. */
    Address		entryPoint;	/* Where process is to start
					 * executing. */
{
    register	Mach_State	*statePtr;

    /*
     * Allocate memory for the saved window stack.
     */
    statePtr = procPtr->machStatePtr;
    if (Vm_PinUserMem(VM_READWRITE_ACCESS, 
			statePtr->userState.maxSWP - statePtr->userState.minSWP,
	                statePtr->userState.minSWP) != SUCCESS) {
	panic( "Mach_StartUserProc: Couldn't pin pages.\n");
    }

    MachRunUserProc();
    /* THIS DOES NOT RETURN */
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_ExecUserProc --
 *
 *	Replace the calling user process's image with a new one.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Stack pointer set for the process.
 *
 *----------------------------------------------------------------------
 */
void
Mach_ExecUserProc(procPtr, userStackPtr, entryPoint)
    Proc_ControlBlock	*procPtr;		/* Process control block for
						 * process to exec. */
    Address		userStackPtr;	/* Stack pointer for when the
						 * user process resumes 
						 * execution. */
    Address		entryPoint;		/* Where the user process is
						 * to resume execution. */
{
    register	Mach_RegState	*regStatePtr;
    register	Mach_State	*statePtr;

    statePtr = procPtr->machStatePtr;
    /*
     * Free up the old saved window stack.
     */
    if (statePtr->userState.maxSWP != 0) {
	Vm_UnpinUserMem(statePtr->userState.maxSWP - statePtr->userState.minSWP,
		              statePtr->userState.minSWP);
    }
    /*
     * Allocate a new saved window stack.
     */
    statePtr->userState.specPageAddr = (Address)MACH_SAVED_WINDOW_STACK_BASE;
    statePtr->userState.swpBaseAddr = statePtr->userState.specPageAddr +
							    VMMACH_PAGE_SIZE;
    statePtr->userState.swpMaxAddr = (Address) (MACH_SAVED_WINDOW_STACK_BASE +
						MACH_SW_STACK_SIZE);
    statePtr->userState.minSWP = statePtr->userState.swpBaseAddr;
    statePtr->userState.maxSWP = statePtr->userState.swpBaseAddr +
							    VMMACH_PAGE_SIZE;
    if (Vm_PinUserMem(VM_READWRITE_ACCESS, VMMACH_PAGE_SIZE,
	                statePtr->userState.minSWP) != SUCCESS) {
	panic( "Mach_ExecUserProc: Couldn't pin stack.\n");
    }

    regStatePtr = &statePtr->userState.trapRegState;
    regStatePtr->regs[MACH_SPILL_SP][0] = (int)userStackPtr;
    regStatePtr->curPC = entryPoint;
    regStatePtr->nextPC = (Address)0;
    regStatePtr->upsw = 0;
    regStatePtr->kpsw = (
#ifdef WITH_IBUFFER
#ifdef WITH_PREFETCH
			 MACH_KPSW_PREFETCH_ENA | 
#endif
			 MACH_KPSW_IBUFFER_ENA |
#endif
			 MACH_KPSW_VIRT_DFETCH_ENA |
			 MACH_KPSW_VIRT_IFETCH_ENA |
			 MACH_KPSW_INTR_TRAP_ENA |
			 MACH_KPSW_FAULT_TRAP_ENA |
			 MACH_KPSW_ERROR_TRAP_ENA |
			 MACH_KPSW_USE_CUR_PC);
    /*
     * Start the cwp off at 4 so that when we restore state we will restore
     * window 3.  This will start the user process off with a cwp of 3 and
     * an swp of minSWP + 2.  Since we allocate more memory for a saved window
     * stack when the swp points to minSWP + 1, by setting the swp to 
     * minSWP + 2 we know that if the swp == minSWP + 1 that there is in 
     * fact another page of windows below the swp.  
     */
    regStatePtr->cwp = 4 << 2;
    regStatePtr->swp = statePtr->userState.swpBaseAddr + 
						2 * MACH_SAVED_WINDOW_SIZE;
    MachRunUserProc();
    /* THIS DOES NOT RETURN */
}

/*
 *----------------------------------------------------------------------
 *
 * Mach_FreeState --
 *
 *	Free up the machine state for the given process control block.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Free up the kernel stack.
 *
 *----------------------------------------------------------------------
 */
void
Mach_FreeState(procPtr)
    Proc_ControlBlock	*procPtr;	/* Process control block to free
					 * machine state for. */
{
    if (procPtr->machStatePtr->kernStackStart != (Address)NIL) {
	Vm_FreeKernelStack(procPtr->machStatePtr->kernStackStart);
	procPtr->machStatePtr->kernStackStart = (Address)NIL;
    }
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_CopyState --
 *
 *	Copy the state from the given state structure to the machine
 *	state structure for the destination process control block.  Intended
 *	to be used by the debugger to modify the state.  Can modify all 
 *	fields in the trap reg state struct except for the MACH_SPILL_SP reg
 *	because that is the kernel's stack pointer.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Machine state in the destination process control block is overwritten.
 *
 *----------------------------------------------------------------------
 */ 
void
Mach_CopyState(statePtr, destProcPtr)
    Mach_State		*statePtr;	/* Pointer to state to copy from. */
    Proc_ControlBlock	*destProcPtr;	/* Process control block to copy
					 * state to. */
{
    bcopy((Address)&statePtr->userState.trapRegState,
	  (Address)&destProcPtr->machStatePtr->userState.trapRegState,
	  sizeof(Mach_RegState));
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_GetDebugState --
 *
 *	Extract the appropriate fields from the machine state struct
 *	and store them into the debug struct.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Debug struct filled in from machine state struct.
 *
 *----------------------------------------------------------------------
 */ 
void
Mach_GetDebugState(procPtr, debugStatePtr)
    Proc_ControlBlock	*procPtr;
    Proc_DebugState	*debugStatePtr;
{
    bcopy((Address)&procPtr->machStatePtr->userState.trapRegState,
	  (Address)&debugStatePtr->regState, sizeof(Mach_RegState));
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_SetDebugState --
 *
 *	Extract the appropriate fields from the debug struct
 *	and store them into the machine state struct.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Machine state struct filled in from the debug state struct.
 *
 *----------------------------------------------------------------------
 */ 
void
Mach_SetDebugState(procPtr, debugStatePtr)
    Proc_ControlBlock	*procPtr;
    Proc_DebugState	*debugStatePtr;
{
    register	Mach_State	*statePtr;
    int				origKpsw;

/*
 * Bits in the KPSW that the user may set or reset.
 */
#define	USER_KPSW_BITS (MACH_KPSW_PREFETCH_ENA|MACH_KPSW_IBUFFER_ENA\
				|MACH_KPSW_USE_CUR_PC)

    statePtr = procPtr->machStatePtr;
    origKpsw = (statePtr->userState.trapRegState.kpsw & ~USER_KPSW_BITS) | 
			(debugStatePtr->regState.kpsw & USER_KPSW_BITS);
    bcopy((Address)&debugStatePtr->regState,
	 (Address)&statePtr->userState.trapRegState, sizeof(Mach_RegState));
    statePtr->userState.trapRegState.kpsw = origKpsw;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_GetStackPointer --
 *
 *	Return the stack pointer value from the mach state struct.
 *
 * Results:
 *	Stack pointer value.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
Address
Mach_GetStackPointer()
{
    Proc_ControlBlock	*procPtr;

    procPtr = Proc_GetCurrentProc();
    return((Address)procPtr->machStatePtr->userState.trapRegState.regs[MACH_SPILL_SP][0]);
}

/*
 *----------------------------------------------------------------------
 *
 * Mach_InitSyscall --
 *
 *	During initialization, this procedure is called once for each
 *	kernel call, in order to set up information used to dispatch
 *	the kernel call.  This procedure must be called once for each
 *	kernel call, in order starting at 0.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Initializes the dispatch tables for the kernel call.
 *
 *----------------------------------------------------------------------
 */
void
Mach_InitSyscall(callNum, numArgs, normalHandler, migratedHandler)
    int callNum;			/* Number of the system call. */
    int numArgs;			/* Number of one-word arguments passed
					 * into call on stack. */
    ReturnStatus (*normalHandler)();	/* Procedure to process kernel call
					 * when process isn't migrated. */
    ReturnStatus (*migratedHandler)();	/* Procedure to process kernel call
					 * for migrated processes. */
{
    machMaxSysCall++;
    if (machMaxSysCall != callNum) {
	printf("Warning: out-of-order kernel call initialization, call %d\n",
	       callNum);
    }
    if (machMaxSysCall >= MAXCALLS) {
	printf("Mach_InitSyscall: too many kernel calls\n",
	       machMaxSysCall);
	machMaxSysCall--;
	return;
    }
    if (numArgs > MAXARGS) {
	printf("Mach_InitSyscall: too many arguments (%d) to kernel call <%d>\n",
		numArgs, callNum);
	numArgs = MAXARGS;
    }
    machNumArgs[machMaxSysCall] = numArgs;
    mach_NormalHandlers[machMaxSysCall] = normalHandler;
    mach_MigratedHandlers[machMaxSysCall] = migratedHandler;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_SetHandler --
 *
 *	Put a device driver interrupt handling routine into the interrupt
 *	vector.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     The exception vector table is modified.
 *
 * ----------------------------------------------------------------------------
 */
void
Mach_SetHandler(intrMask, handler)
    unsigned int intrMask;	/* Interrupt status register mask bits.  If
				 * a bit is set then handler will be called
				 * when the interrupt status register has the
				 * corresponding bit set. */
    void	 (*handler)();	/* Interrupt handling procedure */
{
    int			intrType;
    unsigned	int	mask;

    intrType = 0;
    mask = 1;
    while (intrType < MACH_NUM_INTR_TYPES) {
	if (mask & intrMask) {
	    interruptHandlers[intrType] = handler;
	}
	mask = mask << 1;
	intrType++;
    }
    machIntrMask |= intrMask;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_AllocExtIntrNumber --
 *
 *      Allocate an external interrupt number and register the specified
 *	function under that number.
 *
 * Results:
 *     SUCCESS or FAILURE if allocation fails.
 *
 * Side effects:
 *     None.
 *
 * ----------------------------------------------------------------------------
 */
ReturnStatus
Mach_AllocExtIntrNumber(handler,intrNumberPtr)
    void          	(*handler)();  	/* Interrupt handling procedure */
    unsigned int	*intrNumberPtr;	/* IN/OUT - Desired interrupt number
					 * and return value location.
					 */
{
    unsigned int intrType;
    unsigned int intrMask;

    intrType = *intrNumberPtr;

    if (intrType == MACH_EXT_INTERRUPT_ANY) {
	/* 
	 * If intrNumber is MACH_EXT_INTERRUPT_ANY, allocate the first available
	 * interrupt number.
	 */
	for (intrType = 0; intrType <= MACH_MAX_EXT_INTERRUPT; intrType++) {
	    if (interruptHandlers[intrType] == InterruptError) {
		break;
	    }
	}
        *intrNumberPtr = intrType;
    }
    /*
     * Validate the interrupt number.
     */
    if (intrType > MACH_MAX_EXT_INTERRUPT) {
	return (FAILURE);
    }
    intrMask = (1 << intrType);

    Mach_SetHandler(intrMask, handler);
    return (SUCCESS);
}


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_SetNonmaskableIntr --
 *
 *      Add the non-maskable interrupt mask to the given value.  This will
 *	define which interrupts are non-maskable.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     None.
 *
 * ----------------------------------------------------------------------------
 */
void
Mach_SetNonmaskableIntr(mask)
    unsigned 	int	mask;
{
    machNonmaskableIntrMask |= mask;
    machIntrMask |= mask;
}

static unsigned int globStatusReg;

/*
 * ----------------------------------------------------------------------------
 *
 * MachInterrupt --
 *
 *	Call the proper routine to handle an interrupt.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
void
MachInterrupt(intrStatusReg, kpsw)
    unsigned	int	intrStatusReg;	/* The interrupt status register. */
    unsigned	int	kpsw;		/* The kernel's psw. */
{
    register unsigned	int	intrMask;
    register int		intrType;
    unsigned	int	statusReg;
    int 	oldmode;

#ifdef spur
    /* Re-enable the performance counters */
    Dev_CCSetCounters(COUNTERS_RESTORE);
#endif

    globStatusReg = intrStatusReg;
    mach_KernelMode[Mach_GetProcessorNumber()] = !(kpsw & MACH_KPSW_PREV_MODE);
    /*
     * Do any nonmaskable interrupts first.
     */ 
    if (intrStatusReg & machNonmaskableIntrMask) { 
	if (intrStatusReg & machDbgInterruptMask) {
	    EnterDebugger(&intrStatusReg);
	}
	if (intrStatusReg & (1 << mach_CpcInterruptNumber)) {
	    machExecuteCall(&intrStatusReg);
	}
#ifndef FAST_REFRESH
	Mach_RefreshInterrupt(); 
#endif
	intrStatusReg &= ~machNonmaskableIntrMask;
    }
    if (read_physical_word(0x40000) & 0x4) {
	Mach_RefreshInterrupt();
    }
    if (intrStatusReg == 0) {
	return;
    }	
    if (Mach_AtInterruptLevel() || 
	mach_NumDisableInterrupts[Mach_GetProcessorNumber()] > 0) {
	panic( "Maskable interrupt while interrupts disabled\n");
    }
    mach_AtInterruptLevel[Mach_GetProcessorNumber()] = TRUE;
    intrType = 0;
    intrMask = 1;
    statusReg = intrStatusReg;
    while (statusReg != 0) {
	if (statusReg & intrMask) {
	    (interruptHandlers[intrType])(&statusReg);
	    statusReg &= ~intrMask;
	}
	intrMask = intrMask << 1;
	intrType++;
    }
    mach_AtInterruptLevel[Mach_GetProcessorNumber()] = FALSE;

#ifdef spur
    /* Restore the performance counters */
    Dev_CCSetCounters(COUNTERS_RESTORE_LAST);
#endif

}


/*
 * ----------------------------------------------------------------------------
 *
 * MachUserError --
 *
 *      Process the user process's error.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 * ----------------------------------------------------------------------------
 */
int
MachUserError(errorType)
    int	errorType;
{
    register	Proc_ControlBlock	*procPtr;

    procPtr = Proc_GetCurrentProc();

    switch (errorType) {
	case MACH_USER_BAD_SWP:
	    /*
	     * This error is fatal to a user process so make the process
	     * exit.
	     */
	    Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
	    break;
	case MACH_USER_FPU_EXCEPT:
	    Sig_Send(SIG_ILL_INST, SIG_FPU_EXCEPT, procPtr->processID, FALSE);
	    break;
	case MACH_USER_ILLEGAL:
	    Sig_Send(SIG_ILL_INST, SIG_ILL_INST_CODE, procPtr->processID,
		     FALSE);
	    break;
	case MACH_USER_FIXNUM:
	    Sig_Send(SIG_ILL_INST, SIG_FIXNUM, procPtr->processID, FALSE);
	    break;
	case MACH_USER_OVERFLOW:
	    Sig_Send(SIG_ILL_INST, SIG_OVERFLOW, procPtr->processID, FALSE);
	    break;
	case MACH_BAD_TRAP_TYPE:
	    Sig_Send(SIG_ILL_INST, SIG_BAD_TRAP, procPtr->processID,
		     FALSE);
	    break;
	case MACH_BAD_SYS_CALL:
	    Sig_Send(SIG_ILL_INST, SIG_BAD_SYS_CALL, procPtr->processID,
		     FALSE);
	    break;
	case MACH_BREAKPOINT:
		/*
 		 * Breakpoint and signal step trap should return to the
		 * current (traping) PC.
		 */
	    procPtr->machStatePtr->userState.trapRegState.kpsw |= 
					MACH_KPSW_USE_CUR_PC;
	    Sig_Send(SIG_BREAKPOINT, SIG_NO_CODE, procPtr->processID, FALSE);
	    break;
	case MACH_SINGLE_STEP:
	    procPtr->machStatePtr->userState.trapRegState.kpsw |= 
					MACH_KPSW_USE_CUR_PC;
	    Sig_Send(SIG_TRACE_TRAP, SIG_NO_CODE, procPtr->processID, FALSE);
	    break;
	default:
	    panic( "MachUserError: Unknown user error %d\n",
				 errorType);
    }
    return(MACH_NORM_RETURN);
}


/*
 * ----------------------------------------------------------------------------
 *
 * MachVMDataFault --
 *
 *      Handle a virtual memory fault on the data of an instruction.
 *
 * Results:
 *      MACH_NORM_RETURN:	Were able to handle the fault or was a 
 *				user process
 *	MACH_FAILED_ARG_FETCH:	Couldn't handle the fault but it occured during
 *				the argument fetch for a system call.
 *	MACH_FAILED_COPY:	Couldn't handle the fault but it occured during
 *				a copy-in or copy-out operation.
 *	MACH_KERN_ACCESS_VIOL:	Was a kernel access violation.
 *
 * Side effects:
 *      None.
 *
 * ----------------------------------------------------------------------------
 */
int
MachVMDataFault(faultType, PC, destAddr, kpsw)
    int		faultType;	/* The type of the VM fault */
    Address	PC;		/* PC of the fault. */
    Address	destAddr;	/* Value of dest/src of store/load instruction*/
    int		kpsw;		/* The KPSW at the time of the fault. */
{
    Proc_ControlBlock	*procPtr;

    procPtr = Proc_GetCurrentProc();

    if (procPtr == (Proc_ControlBlock *)NIL ||
	(procPtr->genFlags & PROC_KERNEL)) {
	return(MACH_KERN_ACCESS_VIOL);
    }

    if (faultType & MACH_VM_FAULT_REF_BIT) {
	VmMach_SetRefBit(destAddr);
    } else if (faultType & MACH_VM_FAULT_DIRTY_BIT) {
	VmMach_SetModBit(destAddr);
    } else if (faultType & (MACH_VM_FAULT_PROTECTION | 
			    MACH_VM_FAULT_PAGE_FAULT)) {
	/*
	 * We have to handle a protection fault or a page fault.  First try
	 * the PC.
	 */
	if (Vm_PageIn(destAddr, faultType & MACH_VM_FAULT_PROTECTION) !=
								SUCCESS) {
	    if (kpsw & MACH_KPSW_PREV_MODE) {
		procPtr->machStatePtr->userState.faultAddr = destAddr;
		(void)Sig_Send(SIG_ADDR_FAULT, SIG_ACCESS_VIOL,
			       procPtr->processID, FALSE);
		printf("Process 0x%x fault %d at 0x%x fault address 0x%x\n",
			procPtr->processID, faultType,(unsigned)PC, destAddr);
	    } else {
		if (PC >= (Address)((unsigned int)((int (*)())MachFetchArgStart)) &&
	            PC < (Address)((unsigned int)((int (*)())MachFetchArgEnd))) {
		    return(MACH_FAILED_ARG_FETCH);
		} else if (PC >= (Address)((unsigned int)((int (*)())VmMachDoCopy)) &&
	                   PC < (Address)((unsigned int)((int (*)())VmMachCopyEnd))) {
		    return(MACH_FAILED_COPY);
		} else {
		    return(MACH_KERN_ACCESS_VIOL);
		}
	    }
	}
    }
    return(MACH_NORM_RETURN);
}


/*
 * ----------------------------------------------------------------------------
 *
 * MachVMPCFault --
 *
 *      Handle a Virtual memory fault on the program counter.
 *
 * Results:
 *	MACH_NORM_RETURN:	Handled the fault.
 *	MACH_KERN_ACCESS_VIOL:	Tried to take the fault from kernel mode.
 *	MACH_USER_ACCESS_VIOL:	Couldn't handle the fault and came from user
 *				mode.
 *
 * Side effects:
 *      None.
 *
 * ----------------------------------------------------------------------------
 */
int
MachVMPCFault(faultType, PC, kpsw)
    int		faultType;	/* The type of the VM fault */
    Address	PC;		/* The address of the instruction that caused
				 * the fault. */
    int		kpsw;		/* The KPSW at the time of the fault. */
{
    Proc_ControlBlock	*procPtr;
    extern int	etext;

    if ((kpsw & MACH_KPSW_PREV_MODE) == 0) {
	if (PC > (Address)&etext || PC < (Address)VMMACH_PAGE_SIZE) {
	    return(MACH_KERN_ACCESS_VIOL);
	} else {
	    return(MACH_NORM_RETURN);
	}
    } else {
	/*
  	 * Can't fault on kernel PC. 
	 */
	if (PC < (Address)&etext && PC > (Address)VMMACH_PAGE_SIZE) {
	    return(MACH_NORM_RETURN);
	}
	if (faultType & MACH_VM_FAULT_REF_BIT) {
	    VmMach_SetRefBit(PC);
	    return(MACH_NORM_RETURN);
	} else if (faultType & MACH_VM_FAULT_PAGE_FAULT) {
	    /* 
	     * Take a page fault on this address.
	     */
	    if (Vm_PageIn(PC, FALSE) != SUCCESS) {
		procPtr = Proc_GetCurrentProc();
		procPtr->machStatePtr->userState.faultAddr = PC;
		(void)Sig_Send(SIG_ADDR_FAULT, SIG_ACCESS_VIOL,
			       procPtr->processID, FALSE);
		printf("Process 0x%x fault on PC at 0x%x\n",
			procPtr->processID,(unsigned int)PC);
		return(MACH_USER_ACCESS_VIOL);
	    } else {
		return(MACH_NORM_RETURN);
	    }
	} else {
	    return(MACH_NORM_RETURN);
	}
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 * MachUserAction --
 *
 *      Determine what type of action to take for the user process.
 *
 * Results:
 *      TRUE if need to call a signal handler and FALSE otherwise.
 *
 * Side effects:
 *      Machine state struct may be modified.
 *
 * ----------------------------------------------------------------------------
 */
Boolean
MachUserAction()
{
    register	Mach_State		*statePtr;
    register	Proc_ControlBlock	*procPtr;
    Sig_Stack				sigStack;
    Sig_Context				sigContext;
    Address				pc;
    Address				usp;

    procPtr = Proc_GetCurrentProc();
    procPtr->specialHandling = 0;
    /* 
     * Take a context switch if one is pending for this process.
     */
    if (procPtr->schedFlags & SCHED_CONTEXT_SWITCH_PENDING) {
	Sched_LockAndSwitch();
    }
    sigStack.contextPtr = &sigContext;
    if (Sig_Handle(procPtr, &sigStack, &pc)) {
	statePtr = procPtr->machStatePtr;
	statePtr->userState.newCurPC = pc;
	statePtr->userState.sigNum = sigStack.sigNum;
	statePtr->userState.sigCode = sigStack.sigCode;
	statePtr->userState.trapRegState.regs[MACH_SPILL_SP][0] -=
							sizeof(sigContext);
	usp = (Address)statePtr->userState.trapRegState.regs[MACH_SPILL_SP][0];
	sigContext.machContext.faultAddr = statePtr->userState.faultAddr;
	/*
	 * Copy out the signal context stuff minus the trap state.
	 */
	if (Vm_CopyOut(sizeof(sigContext) - sizeof(Mach_RegState),
		       (Address)&sigContext, usp) != SUCCESS) {
	    Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
	}
	/*
	 * Copy out the trap register state.
	 */
	usp += (unsigned)&sigContext.machContext.regState -
	       (unsigned)&sigContext;
	if (Vm_CopyOut(sizeof(Mach_RegState),
		       (Address)&statePtr->userState.trapRegState,
		       usp) != SUCCESS) {
	    Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
	}
	return(TRUE);
    } else {
	return(FALSE);
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 * MachGetWinMem --
 *
 *      Get more window memory for the current process.
 *
 * Results:
 *      
 *
 * Side effects:
 *      Machine state struct may be modified.
 *
 * ----------------------------------------------------------------------------
 */
void
MachGetWinMem()
{
    register Mach_State	*statePtr;
    Address		swp;
    Proc_ControlBlock	*procPtr;

    procPtr = Proc_GetCurrentProc();
    statePtr = procPtr->machStatePtr;

    swp = statePtr->userState.trapRegState.swp;
    if (swp <= statePtr->userState.minSWP + MACH_SAVED_WINDOW_SIZE) {
	/*
	 * Allocate more memory at the low end.
	 */
	if (statePtr->userState.minSWP <= statePtr->userState.swpBaseAddr) {
	    /*
	     * We are already at the bottom of the stack so we can't allocated
	     * any more memory.
	     */
	    Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
	}
	if (statePtr->userState.maxSWP - statePtr->userState.minSWP > 
							VMMACH_PAGE_SIZE) {
	    /*
	     * Free the highest page because we never want more than two
	     * full pages at once.
	     */
	    statePtr->userState.maxSWP -= VMMACH_PAGE_SIZE;
	    Vm_UnpinUserMem(VMMACH_PAGE_SIZE, statePtr->userState.maxSWP);
	}
	statePtr->userState.minSWP -= VMMACH_PAGE_SIZE;
	if (Vm_PinUserMem(VM_READWRITE_ACCESS, VMMACH_PAGE_SIZE, 
				statePtr->userState.minSWP) != SUCCESS) {
	    printf("Warning: MachGetWinMem: Low pin failed\n");
	    Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
	}
    } else if (swp > statePtr->userState.maxSWP - 2 * MACH_SAVED_REG_SET_SIZE){
	/*
	 * Need to allocate more at the high end.
	 */
	if (swp > statePtr->userState.maxSWP - MACH_SAVED_REG_SET_SIZE) {
	    panic( "MachGetWinMem: SWP too big.\n");
	}
	if (statePtr->userState.maxSWP - statePtr->userState.minSWP >
							VMMACH_PAGE_SIZE) {
	    /*
	     * Free the lowest page because we never want more than two
	     * full pages at once.
	     */
	    Vm_UnpinUserMem(VMMACH_PAGE_SIZE, statePtr->userState.minSWP);
	    statePtr->userState.minSWP += VMMACH_PAGE_SIZE;
	}
	if (statePtr->userState.maxSWP + VMMACH_PAGE_SIZE >=
					statePtr->userState.swpMaxAddr) {
	    /*
	     * We are already at the top of the stack so we can't allocated
	     * any more memory.
	     */
	    Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
	}

	if (Vm_PinUserMem(VM_READWRITE_ACCESS, VMMACH_PAGE_SIZE, 
				statePtr->userState.maxSWP) != SUCCESS) {
	    printf("Warning: MachGetWinMem: High pin failed\n");
	    Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
	}
	statePtr->userState.maxSWP += VMMACH_PAGE_SIZE;
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 * MachSigReturn --
 *
 *      Handle a return from signal trap.
 *
 * Results:
 *	MACH_NORM_RETURN. 
 *
 * Side effects:
 *      Machine state struct may be modified.
 *
 * ----------------------------------------------------------------------------
 */
int
MachSigReturn()
{
    register Mach_State	*statePtr;
    Sig_Stack		sigStack;
    Sig_Context		sigContext;
    Proc_ControlBlock	*procPtr;
    Address		usp;
    int			savedKPSW;

    procPtr = Proc_GetCurrentProc();
    statePtr = procPtr->machStatePtr;
    usp = (Address)statePtr->userState.trapRegState.regs[MACH_SPILL_SP][0];
    /*
     * Copy in the normal context stuff.
     */
    if (Vm_CopyIn(sizeof(sigContext) - sizeof(Mach_RegState), usp,
	    (Address)&sigContext) != SUCCESS) {
	Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
    }
    /*
     * Now copy in the register state.
     */
    savedKPSW = statePtr->userState.trapRegState.kpsw & ~MACH_KPSW_USE_CUR_PC;
    usp += (unsigned)&sigContext.machContext.regState -
	   (unsigned)&sigContext;
    if (Vm_CopyIn(sizeof(Mach_RegState), usp,
	          (Address)&statePtr->userState.trapRegState) != SUCCESS) {
	Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
    }
    statePtr->userState.trapRegState.regs[MACH_SPILL_SP][0] +=
							sizeof(sigContext);
    
    statePtr->userState.trapRegState.kpsw = savedKPSW |
	    (statePtr->userState.trapRegState.kpsw & MACH_KPSW_USE_CUR_PC);
    sigStack.contextPtr = &sigContext;
    Sig_Return(Proc_GetCurrentProc(), &sigStack);
    return(MACH_NORM_RETURN);
}


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_ProcessorState --
 *
 *	Determines what state the processor is in.
 *
 * Results:
 *	MACH_USER	if was at user level
 *	MACH_KERNEL	if was at kernel level
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
/*ARGSUSED*/
Mach_ProcessorStates 
Mach_ProcessorState(processor)
    int processor;	/* processor number for which info is requested */
{
    if (mach_KernelMode[processor]) {
	return(MACH_KERNEL);
    } else {
	return(MACH_USER);
    }
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_GetMachineType --
 *
 *	Returns the machine type, 0 for SPUR prototype.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
int
Mach_GetMachineType()
{
	return (0);
}

/*
 *----------------------------------------------------------------------
 *
 * Mach_GetMachineArch --
 *
 *	Returns the machine architecure, SPUR.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
int
Mach_GetMachineArch()
{
    return (SYS_SPUR);
}

static	ReturnStatus	PinSWP();

/*
 *----------------------------------------------------------------------
 *
 * MachUserContextSwitch --
 *
 *	Perform a user level context switch.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
int
MachUserContextSwitch(specPageAddr, swpMaxAddr, newSWP)
    register	Address	specPageAddr;	/* The address of the new special page.
					 * The base of the saved window stack
					 * is specPageAddr + VMMACH_PAGE_SIZE.*/
    Address		swpMaxAddr;	/* The new max address of the saved 
					 * window stack. */
    Address		newSWP;		/* The value of the new swp. */
{
    register	Mach_SpecPage	*specPagePtr;
    register	Mach_State	*statePtr;
    register	Address		swpBaseAddr;
    Address			minSWP;
    Address			maxSWP;
    Proc_ControlBlock		*procPtr;
    ReturnStatus		status = SUCCESS;
    int				savedKPSW;

    procPtr = Proc_GetCurrentProc();
    statePtr = procPtr->machStatePtr;

    /*
     * Page align the spec page addr and then add one page to it to point
     * to the actual base of the saved window stack.
     */
    specPageAddr = (Address)((unsigned)specPageAddr & ~(VMMACH_PAGE_SIZE - 1));
    swpBaseAddr = specPageAddr + VMMACH_PAGE_SIZE;

    status = PinSWP(swpBaseAddr, swpMaxAddr, newSWP, &minSWP, &maxSWP);
    if (status != SUCCESS) {
	goto done;
    }

    /*
     * Copy the current state out onto the current stack.
     */
    specPagePtr = (Mach_SpecPage *)statePtr->userState.specPageAddr;
    if (Vm_CopyOut(sizeof(Mach_RegState),
		   (Address)&statePtr->userState.trapRegState,
		   (Address)&specPagePtr->switchState.regState) != SUCCESS) {
	status = SYS_ARG_NOACCESS;
	Vm_UnpinUserMem(maxSWP - minSWP, minSWP);
	goto done;
    }
    /*
     * Put out the current bounds of the saved window stack.  We don't have
     * to use copy-out here because we know that *specPagePtr points to a valid
     * page because otherwise we wouldn't have gotten this far.
     */
    specPagePtr->switchState.specPageAddr = statePtr->userState.specPageAddr;
    specPagePtr->switchState.swpMaxAddr = statePtr->userState.swpMaxAddr;

    /*
     * Copy in the new state.
     */
    specPagePtr = (Mach_SpecPage *)specPageAddr;
    savedKPSW = statePtr->userState.trapRegState.kpsw;
    if (Vm_CopyIn(sizeof(Mach_RegState),
		  (Address)&specPagePtr->switchState.regState,
		  (Address)&statePtr->userState.trapRegState) != SUCCESS) {
	status = SYS_ARG_NOACCESS;
	Vm_UnpinUserMem(maxSWP - minSWP, minSWP);
	goto done;
    }
    statePtr->userState.trapRegState.kpsw = savedKPSW | 
	    (statePtr->userState.trapRegState.kpsw & MACH_KPSW_USE_CUR_PC);
    /*
     * Free up the old stack and store the pointers to the new one.
     */
    Vm_UnpinUserMem(statePtr->userState.maxSWP - statePtr->userState.minSWP,
		    statePtr->userState.minSWP);
    statePtr->userState.specPageAddr = specPageAddr;
    statePtr->userState.swpBaseAddr = swpBaseAddr;
    statePtr->userState.swpMaxAddr = swpMaxAddr;
    statePtr->userState.minSWP = minSWP;
    statePtr->userState.maxSWP = maxSWP;

done:
    statePtr->userState.trapRegState.regs[MACH_RETURN_VAL_REG][0] = status;
    return(MACH_NORM_RETURN);
}


/*
 *----------------------------------------------------------------------
 *
 * PinSWP --
 *
 *	Pin down new saved window stack.
 *
 * Results:
 *	SYS_ARG_NOACCESS if couldn't wire down the saved window stack,
 *	SUCCESS otherwise.
 *
 * Side effects:
 *	*minSWPPtr and *maxSWPPtr are set to point to the minimum
 *	and maximum address that we pinned.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
PinSWP(swpBaseAddr, swpMaxAddr, swp, minSWPPtr, maxSWPPtr)
    register	Address	swpBaseAddr;
    register	Address	swpMaxAddr;
    register	Address	swp;
    register	Address	*minSWPPtr;
    register	Address	*maxSWPPtr;
{
    if (swp < swpBaseAddr || swp >= swpMaxAddr) {
	return(SYS_ARG_NOACCESS);
    }

    /*
     * Compute the new minimum and maximum addresses for the saved window
     * stack.
     */
    *minSWPPtr = (Address) ((unsigned)(swp - MACH_SAVED_WINDOW_SIZE) &
				      ~(VMMACH_PAGE_SIZE - 1));
    *maxSWPPtr = swp + 2 * MACH_SAVED_REG_SET_SIZE + VMMACH_PAGE_SIZE -
						    MACH_SAVED_WINDOW_SIZE;
    *maxSWPPtr = (Address) ((unsigned)*maxSWPPtr & ~(VMMACH_PAGE_SIZE - 1));
    if (*minSWPPtr < swpBaseAddr || *maxSWPPtr > swpMaxAddr) {
	return(SYS_ARG_NOACCESS);
    }
    /*
     * Pin down the new stack.
     */
    if (Vm_PinUserMem(VM_READWRITE_ACCESS, *maxSWPPtr - *minSWPPtr,
		      *minSWPPtr) != SUCCESS) {
	return(SYS_ARG_NOACCESS);
    }
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * MachSaveUserState --
 *
 *	Save the current user processes state into the special page.
 *
 * Results:
 *	MACH_NORM_RETURN
 *
 * Side effects:
 *	The user's special page saved state is modified.
 *
 *----------------------------------------------------------------------
 */
int
MachSaveUserState()
{
    register	Mach_State	*statePtr;
    Proc_ControlBlock		*procPtr;
    Mach_SpecPage		*specPagePtr;

    procPtr = Proc_GetCurrentProc();
    statePtr = procPtr->machStatePtr;
    specPagePtr = (Mach_SpecPage *)statePtr->userState.specPageAddr;

    if (Vm_CopyOut(sizeof(Mach_RegState),
		        (Address)&statePtr->userState.trapRegState,
		    (Address)&specPagePtr->savedState.regState) != SUCCESS) {
	panic( "MachSaveUserState: Save failed\n");
    }
    /*
     * Put out the current bounds of the saved window stack.  We don't have
     * to use copy-out here because we know that *specPagePtr points to a valid
     * page because otherwise we wouldn't have gotten this far.
     */
    specPagePtr->savedState.specPageAddr = (Address)specPagePtr;
    specPagePtr->savedState.swpMaxAddr = statePtr->userState.swpMaxAddr;

    return(MACH_NORM_RETURN);
}

/*
 *----------------------------------------------------------------------
 *
 * MachRestoreUserState --
 *
 *	Restore the current user processes state from the special page.
 *
 * Results:
 *	MACH_NORM_RETURN
 *
 * Side effects:
 *	The user's special page saved state is modified.
 *
 *----------------------------------------------------------------------
 */
int
MachRestoreUserState()
{
    register	Mach_State	*statePtr;
    register	Mach_SpecPage	*specPagePtr;
    Proc_ControlBlock		*procPtr;
    int				savedKPSW;
    Address			minSWP;
    Address			maxSWP;
    ReturnStatus		status;

    procPtr = Proc_GetCurrentProc();
    statePtr = procPtr->machStatePtr;
    specPagePtr = (Mach_SpecPage *)statePtr->userState.specPageAddr;

    savedKPSW = statePtr->userState.trapRegState.kpsw;
    /*
     * Copy in the state to restore.  Note that once we can copy in the
     * state we know that we can get the rest without a copy-in because
     * the page must be valid if the copy-in succeeds.
     */
    if (Vm_CopyIn(sizeof(Mach_RegState),
		  (Address)&specPagePtr->savedState.regState,
		  (Address)&statePtr->userState.trapRegState) != SUCCESS) {
	panic( "MachRestoreUserState: Restore failed\n");
    }
    statePtr->userState.specPageAddr =
		    (Address)((unsigned)specPagePtr->savedState.specPageAddr & 
					~(VMMACH_PAGE_SIZE - 1));
    statePtr->userState.swpBaseAddr = 
			statePtr->userState.specPageAddr + VMMACH_PAGE_SIZE;
    statePtr->userState.swpMaxAddr = specPagePtr->savedState.swpMaxAddr;

    statePtr->userState.trapRegState.kpsw = savedKPSW | 
	    (statePtr->userState.trapRegState.kpsw & MACH_KPSW_USE_CUR_PC);
    status = PinSWP(statePtr->userState.swpBaseAddr, 
		    statePtr->userState.swpMaxAddr, 
		    statePtr->userState.trapRegState.swp, &minSWP, &maxSWP);
    if (status != SUCCESS) {
	Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
    }
    Vm_UnpinUserMem(statePtr->userState.maxSWP - statePtr->userState.minSWP,
		    statePtr->userState.minSWP);
    statePtr->userState.minSWP = minSWP;
    statePtr->userState.maxSWP = maxSWP;

    return(MACH_NORM_RETURN);
}

/*
 *----------------------------------------------------------------------
 *
 * MachUserTestAndSet --
 *
 *	User level test and set.  This is a hack for now until they figure
 *	out how to do a real test and set at user level in hardware
 *	(won't work with interrupts enable).
 *
 * Results:
 *	MACH_NORM_RETURN
 *
 * Side effects:
 *	The given pointer is test and set and the user's return val reg
 *	is set to the value returned by test and set.
 *
 *----------------------------------------------------------------------
 */
int
MachUserTestAndSet(tasAddr)
    Address	tasAddr;	/* Address to test and set. */
{
    ReturnStatus	status;
    Proc_ControlBlock	*procPtr;
    Mach_State		*statePtr;

    procPtr = Proc_GetCurrentProc();
    statePtr = procPtr->machStatePtr;

    status = Vm_PinUserMem(VM_READWRITE_ACCESS, 4, tasAddr);
    if (status == SUCCESS) {
	statePtr->userState.trapRegState.regs[27][0] = Mach_TestAndSet(tasAddr);
    }
    statePtr->userState.trapRegState.regs[28][0] = status;
    Vm_UnpinUserMem(4, tasAddr);
    return(MACH_NORM_RETURN);
}


/*
 *----------------------------------------------------------------------
 *
 * MachEnterKernelDebugger --
 *
 *	Enter the kernel debugger. This routine is called when a processor
 * 	hits a break_point trap or single step trap or is signaled into the
 *	debugger by another processor.
 *
 * Results:
 *
 * Side effects:
 *
 *----------------------------------------------------------------------
 */

void 
MachEnterKernelDebugger(signal, statePtr)
    int			signal;		/* Signal causing the trap. */
    Mach_RegState	*statePtr;	/* State of the processor. */
{
    static	int	debuggerSemaphore = 0;	
    Boolean	firstInDebugger;	/* Is this the first processor to
					 * enter debugger. */
    int		pnum;

    /*
     * If we are already in  debugger then ignore the interrupt.
     */
    if (mach_ProcessorStatus[Mach_GetProcessorNumber()] == MACH_IN_DEBUGGER_STATUS) {
	return;
    }
    /*
     * See if this is the first processor to enter the debugger.
     */
    firstInDebugger = (Boolean) (Mach_TestAndSet(&debuggerSemaphore) == 0);

    /*
     * Update our register state.
     */
    machDebugSignal[Mach_GetProcessorNumber()] = signal;
    DevCCReadBytesFromRegs(0,DEV_CC_MAX_OFFSET, 
			&(machCCState[Mach_GetProcessorNumber()]));
    /*
     * Mark our state as in the debugger.
     */
    mach_ProcessorStatus[Mach_GetProcessorNumber()] = MACH_IN_DEBUGGER_STATUS;

    /*
     * If we are the first processor, signal the rest of the processors.
     */
    if (firstInDebugger) {
	for (pnum = 0; pnum < mach_NumProcessors; pnum++) {
	    if (mach_ProcessorStatus[pnum] == MACH_ACTIVE_STATUS) {
		Mach_SignalProcessor(pnum, machDbgInterruptNumber);
	    }
	}
    }
    /*
     * If we are the master processor, wait a little while for the rest of
     * the procesors to enter the debugger and then wait kdbx.
     */
    if (Mach_GetProcessorNumber() == machMasterProcessor) {
	Boolean	allInDebugger = FALSE;
	int	count = 0;
	for (count = 0; !allInDebugger && (count < 10); count++) {
	    MACH_DELAY(100);
	    allInDebugger = TRUE;
	    for (pnum = 0; pnum < mach_NumProcessors; pnum++) {
		if (mach_ProcessorStatus[pnum] == MACH_ACTIVE_STATUS) {
		    allInDebugger = FALSE;
		}
	    }
	    REFRESH_CPU();
	}
	/*
	 * Mark processor that wont enter debugger as hung.
	 */
	if (!allInDebugger) {
	   for (pnum = 0; pnum < mach_NumProcessors; pnum++) {
		if (mach_ProcessorStatus[pnum] == MACH_ACTIVE_STATUS) {
		    printf("Warning: Processor %d wont enter debugger.\n",
				pnum);
		    mach_ProcessorStatus[pnum] = MACH_HUNG_STATUS;
		}
	    }
	}
	Dbg_Main(signal,statePtr);
	/*
	 * Clear the debugger semaphore.
	 */
	debuggerSemaphore = 0;
    } else {
	/*
	 * If we are not the master processor, spin waiting for the
	 * master to change our state. We must continue to refresh the
	 * dynamic registers during the wait.
	 */
	register Mach_ProcessorStatus	* volatile spinWaitPtr;
	register int	count;

	spinWaitPtr = &(mach_ProcessorStatus[Mach_GetProcessorNumber()]);
	count = 0;
	while (*spinWaitPtr == MACH_IN_DEBUGGER_STATUS) {
		count++;
		if (count > 10000) {
		    count = 0;
		    REFRESH_CPU();
		}
	}
    }
   mach_ProcessorStatus[Mach_GetProcessorNumber()] = MACH_ACTIVE_STATUS;
}


/*
 *----------------------------------------------------------------------
 *
 * MachContinueProcessors --
 *
 *	Continue all processors in the debugger.
 *
 * Results:
 *
 * Side effects:
 *
 *----------------------------------------------------------------------
 */

void 
MachContinueProcessors()
{
    int		pnum;

    /*
     * If not master process, then do nothing.
     */
    if (Mach_GetProcessorNumber() != machMasterProcessor) {
	return;
    }
    /*
     * Slave processors in the debugger spin waiting for there state to
     * change.
     */
    for (pnum = 0; pnum < mach_NumProcessors; pnum++) {
	if (mach_ProcessorStatus[pnum] == MACH_IN_DEBUGGER_STATUS) {
		mach_ProcessorStatus[pnum] = MACH_CONTINUING_STATUS;
	}
    }
}


/*
 *----------------------------------------------------------------------
 *
 * EnterDebugger --
 *
 *	Called when a processor receives a enter debugger signal.
 *
 * Results:
 *
 * Side effects:
 *
 *----------------------------------------------------------------------
 */

static void 
EnterDebugger(statusRegPtr)
    unsigned int	*statusRegPtr;
{
    DBG_CALL;
}

/*
 * Start of First process for each processor.
 */
Mach_State *machFirstProcState[MACH_MAX_NUM_PROCESSORS];


/*
 *----------------------------------------------------------------------
 *
 * Mach_SpinUpProcessor(pnum) --
 *
 *	Start up processor pnum
 *
 * Results:
 *
 * Side effects:
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Mach_SpinUpProcessor(pnum,procPtr)
    int			pnum;		/* Processor number. */
    Proc_ControlBlock	*procPtr;	/* Initial processor for processor. */
{
    ReturnStatus	status;
    Mach_Board		board;
    int			i;
    /*
     * Verify that the specified processor is in the system.
     */
    status = Mach_FindBoardDescription(MACH_CONFIG_CPU_BOARD,pnum,FALSE,
					&board);
    if (status != SUCCESS) {
	printf("Warning: Trying to spin up nonexistant processor (%d)\n",
		pnum);
	return(status);
    }

    if (mach_ProcessorStatus[pnum] != MACH_UNINITIALIZED_STATUS) {
	printf("Warning: Trying to spin up running processor (%d)\n",pnum);
	return (FAILURE);
    }

    /* 
     * Set up the first process for processor and assign processor number.
     */
    machFirstProcState[pnum] = procPtr->machStatePtr;
    proc_RunningProcesses[pnum] = procPtr;
    machCurStatePtrs[pnum] = procPtr->machStatePtr;
    /*
     * Wake up the processor. 
     */
    status = Mach_SignalProcessor(pnum, MACH_SPINUP_INTERRUPT_NUM);
    if (status != SUCCESS) {
	printf("Warning: Can't signal to wake up processor %d\n",pnum);
	return (status);
    }
    return (SUCCESS);
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_GetNumProcessor() --
 *
 *	Return the number of processors in the system.
 *
 * Results:
 *
 * Side effects:
 *
 *----------------------------------------------------------------------
 */

int
Mach_GetNumProcessors()
{
	return (mach_NumProcessors);
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_InitSlaveProcessor() --
 *
 *	Initialized the machine state of a slave (non-master) processor.
 *
 * Results:
 *
 * Side effects:
 *
 *----------------------------------------------------------------------
 */

void 
Mach_InitSlaveProcessor()
{
    /*
     * Turn off all timers (unless we're trying to do instruction counts.)
     */
    if (mach_DoInstCounts) {
	Mach_Write8bitCCReg(MACH_MODE_REG /* | MACH_MODE_T0_ENABLE */, 
	    MACH_MODE_PERF_COUNTER_MASK & MACH_MODE_PERF_COUNTER_SYS);
    } else {
	Mach_Write8bitCCReg(MACH_MODE_REG,0);
    }
    /*
     * Clear the interrupt mask register and any pending interrupts.
     */
    Mach_Write32bitCCReg((unsigned int)MACH_INTR_MASK_0,(unsigned int)0);
    Mach_Write32bitCCReg((unsigned int)MACH_INTR_STATUS_0,(unsigned int)-1);
    /*
     * Start refersh interrupt.
     */
    Mach_RefreshStart();
    /*
     * Set status to active.
     */
    mach_ProcessorStatus[Mach_GetProcessorNumber()] = MACH_ACTIVE_STATUS;
    /*
     * Increment the number of active processors.  This code assumes that
     * processors are started one at a time so we don't need protection on
     * the mach_NumProcessors variable.
     */
     /* mach_NumProcessors += 1; */
    if (mach_NumProcessors < Mach_GetProcessorNumber()+1) {
    	mach_NumProcessors = Mach_GetProcessorNumber()+1;
    }

}

static void doNothing()
{
	return;
}

/*
 *----------------------------------------------------------------------
 *
 * Mach_CheckSpecialHandling() --
 *
 *	Force the specified processor to check it special handling flag
 *	of the executing process.
 *
 * Results:
 *
 * Side effects:
 *
 *----------------------------------------------------------------------
 */

Mach_CheckSpecialHandling(processorNum)
    int	processorNum;	/* Processor number to act on. */
{ 
    Mach_SignalProcessor(processorNum, machCheckSpecialInterruptNum);

}


#ifdef PATCH_IBUFFER

#define	IBUF_TRACE
#ifdef IBUF_TRACE

#define	TRACE_BUF_SIZE 128
static int	trace_end = 0;
static struct ibuf_trace {
    int	   r10;	
    int	   r16;
    int	   r26;
    int	   choice;	
} ibuf_trace[TRACE_BUF_SIZE];
#endif
/*
 * Some ipatch stats.
 */
struct ipatch_stats {
    int		numCalls;	/* Number calls to PatchIbuffer */
    int		numUserCalls;	/* Number calls to patch user Ibuffer. */
    int		numCallsWithIbuffer;	/* Number calls with ibuffer enabled. */
    int		numUserCallsWithIbuffer;/* Number calls with ibuffer enabled.*/
    int		numR10zero;		/* Number r10 == zero. */
    int		numR26zero;		/* Number r26 == zero. */
    int		numR10fault;		/* Number r10 not valid. */
    int		numR16fault;		/* Number r16 not valid. */
    int		numR26fault;		/* Number r26 not valid. */
    int		numGoodInst;		/* Number of harmless inst. */
    int		numSeq;			/* Number r10 and r16 sequential. */
    int		numR10notCall;		/* Number of r10 not call inst. */
    int		numR26notCall;		/* Number of r26 not call inst. */
} ipatch_stats;

int	ipatch_last = 0;

/*
 *----------------------------------------------------------------------
 *
 * MachPatchIbuffer() --
 *
 *	Return the correct current PC after an interrupt.  When the
 *	ibuffer is enabled, the current PC of an interrupt is written in
 *	one of two places.  This routine returns the correct curPC.
 *
 * Results: 
 *	The correct current PC of a trap.
 *
 * Side effects:
 *
 *----------------------------------------------------------------------
 */
int 
MachPatchIbuffer(kpsw,r10,r16,r26)
    int	kpsw;		/* The kpsw at trap time. */
    int	r10;		/* R10 of the trap window. */
    int	r16;		/* R16 of the trap window. */
    int	r26;		/* R26 of the trap window. */
{
    register unsigned int	nextInst, nextOPCode;
    register unsigned int	curInst, curOPCode;
    int		r10notvalid = 0;
    ipatch_stats.numCalls++;
    /*
     * If the ibuffer is not enabled then the current PC is always in
     * R10.
     */
    if (!(kpsw & MACH_KPSW_IBUFFER_ENA)) {
	ipatch_last = 1;
	return r10;
    }
    ipatch_stats.numCallsWithIbuffer++;

    /*
     * If the ibuffer is enabled then the current PC is either in R10 or
     * R16.  If r10 is 0 then current PC must be in R26.  If R26 is also
     * zero something is very wrong.
     */
    if (r10 == 0) {
	if (r26 == 0) {
	    panic("No current pc in MachPatchIbuffer.");
	} else {
	    ipatch_stats.numR10zero++;
	    ipatch_last = 2;
	    return r26;
	}
    }
    /*
     * If R10 is not zero but R26 is zero then R10 be the correct current PC.
     */
    if (r26 == 0) {
	ipatch_stats.numR26zero++;
	ipatch_last =  3;
	return r10;
    }
    /*
     * If R10 doesn't point to a validate address, it can't be the correct
     * current PC. (This doesn't work for multiprocessors!!!)
     * THIS is also not true for uniprocessors.
     */

    if (!Vm_ValidateRange(r10,4)) {
	ipatch_stats.numR10fault++;
	r10notvalid = 1;
    }

	/*
 	 * If r16 is not valid we must assume that the pc was put in the 
	 * correct place.
	 */
    if (!Vm_ValidateRange(r16,4)) {
	ipatch_stats.numR16fault++;
	ipatch_last = 4;
	return r10;
    }
    /*
     * If current PC is only messed up when the next pc instruction is one
     * of the follow:
     *	1) a call
     *	2) a return
     *  3) a return_trap
     *	4) a wr_special	of cwp
     * If it is not one of this instructions then r10 is the current PC.
     */
    nextInst = (* (unsigned int *) r16);
    nextOPCode = nextInst >> 25;
    if (!(((nextOPCode >= 0x70) && (nextOPCode <= 0x77)) || 	/* A call */
	(nextOPCode == 0x58)		       ||	/* A return */
	(nextOPCode == 0x59)				/* A return_trap */
		)) {		/* Should also check wr_special cwp. */
	ipatch_stats.numGoodInst++;
	ipatch_last = 5;
	return r10;
    }
    /*
     * If the r26 is not accessible then r10 must be the current PC.
     */
    if (!Vm_ValidateRange(r26,4)) {
	ipatch_stats.numR26fault++;
	ipatch_last = 6;
	return r10;
    }
    if ((r10&~3)+4 == (r16&~3)) {
	ipatch_stats.numSeq;
	ipatch_last = 7;
	return r10;
    }
    /*
     * Check the instruction pointed to by r10. If this instruction is
     * call instruction we assume that the trap wrote the current PC into
     * r26. This follows because the instruction before a call or return
     * is never a call.
     */
    if (!r10notvalid) {
	    curInst = (* (unsigned int *) r10);
	    curOPCode = curInst >> 25;
	    if (!((curOPCode >= 0x70) && (curOPCode <= 0x77))) { 
		/* Not a call inst. */
		ipatch_stats.numR10notCall++;
		ipatch_last = 8;
		return r10;
	    }
     }
    curInst = (* (unsigned int *) r26);
    curOPCode = curInst >> 25;
    if (((curOPCode >= 0x70) && (curOPCode <= 0x77))) { /* Is a call inst. */
	panic("Both current PCs are calls in  MachPatchIbuffer.");
    }
    ipatch_stats.numR26notCall++;
    ipatch_last = 9;
    return r26;
}

/*
 *----------------------------------------------------------------------
 *
 * MachPatchUserModeIbuffer() --
 *
 *	Patch the current PC in the Mach_State structure of the currently
 *	executing process.
 *
 * Results: 
 *	None.
 * Side effects:
 *
 *----------------------------------------------------------------------
 */

int 
MachPatchUserModeIbuffer(kpsw)
    unsigned int	kpsw;		/* Trap KPSW */
{
    Mach_State	*statePtr;
    int errorCurPC;
#ifdef IBUF_TRACE
    int		index;
#endif

    ipatch_stats.numUserCalls++;
    /*
     * If the ibuffer is not enabled then no patch is necessary.
     */
    statePtr = machCurStatePtrs[Mach_GetProcessorNumber()];
    if ((kpsw & MACH_KPSW_IBUFFER_ENA)) {
	ipatch_stats.numUserCallsWithIbuffer++;
	/*
	 * The trapping R26 was stuffed into trapRegState.aligner by 
	 * SaveState.
	 */
	errorCurPC =  * (int *) &(statePtr->userState.trapRegState.aligner);
#ifdef IBUF_TRACE
	index = trace_end++;
	trace_end = trace_end % TRACE_BUF_SIZE;
	ibuf_trace[index].r10 = (int) statePtr->userState.trapRegState.curPC;
	ibuf_trace[index].r16 = (int) statePtr->userState.trapRegState.nextPC;
	ibuf_trace[index].r26 = errorCurPC;
	ibuf_trace[index].choice = (int)
#endif
	statePtr->userState.trapRegState.curPC = (Address)
	    MachPatchIbuffer(kpsw, statePtr->userState.trapRegState.curPC,
				    statePtr->userState.trapRegState.nextPC,
				    errorCurPC);
    }
    return (int) statePtr->userState.trapRegState.curPC;

}


/*
 *----------------------------------------------------------------------
 *
 * MachPatchIbufferOnFault() --
 *
 *	Return the correct current PC after an fault.  When the
 *	ibuffer is enabled, the current PC of an fault is written in
 *	one of two places.  This routine returns the correct curPC.
 *
 * Results: 
 *	The correct current PC of a trap.
 *
 * Side effects:
 *
 *----------------------------------------------------------------------
 */
int 
MachPatchIbufferOnFault(kpsw,r10,r16,r26)
    int	kpsw;		/* The kpsw at trap time. */
    int	r10;		/* R10 of the trap window. */
    int	r16;		/* R16 of the trap window. */
    int	r26;		/* R26 of the trap window. */
{
    register unsigned int	nextInst, nextOPCode;
    register unsigned int	curInst, curOPCode;
    ipatch_stats.numCalls++;
    /*
     * If the ibuffer is not enabled then the current PC is always in
     * R10.
     */
    if (!(kpsw & MACH_KPSW_IBUFFER_ENA)) {
	return r10;
    }
    ipatch_stats.numCallsWithIbuffer++;

    /*
     * If the ibuffer is enabled then the current PC is either in R10 or
     * R16.  If r10 is 0 then current PC probably is in R26.  If R26 is also
     * zero something is  wrong.
     */
    if (r10 == 0) {
	if (r26 == 0) {
	    return r10;
	} else {
	    return r26;
	}
    }
    /*
     * If R10 is not zero but R26 is zero then R10 be the correct current PC.
     */
    if (r26 == 0) {
	return r10;
    }
    /*
     * If the next PC is not accessable, then assume trap put PC in correct
     * registers. 

    if (!Vm_ValidateRange(r16,4)) {
	return r10;
    }
    /*
     * If current PC is only messed up when the next pc instruction is one
     * of the follow:
     *	1) a call
     *	2) a return
     *  3) a 
     *	4) a wr_special	of cwp
     * If it is not one of this instructions then r10 is the current PC.
     */
    nextInst = (* (unsigned int *) r16);
    nextOPCode = nextInst >> 25;
    if (!(((nextOPCode >= 0x70) && (nextOPCode <= 0x77)) || 	/* A call */
	(nextOPCode == 0x58)		       ||	/* A return */
	(nextOPCode == 0x59)				/* A return_trap */
		)) {		/* Should also check wr_special cwp. */
	ipatch_stats.numGoodInst++;
	return r10;
    }
    if ((r16&~3) == ((r10&~3) + 4)) {
	return r10;
    } 
    if ((r16&~3) == ((r26&~3) + 4)) {
	return r26;
    }
    return r10;
}

/*
 *----------------------------------------------------------------------
 *
 * MachPatchUserModeIbufferOnFault() --
 *
 *	Patch the current PC in the Mach_State structure of the currently
 *	executing process.
 *
 * Results: 
 *	None.
 * Side effects:
 *
 *----------------------------------------------------------------------
 */

int 
MachPatchUserModeIbufferOnFault(kpsw)
    unsigned int	kpsw;		/* Trap KPSW */
{
    Mach_State	*statePtr;
    int errorCurPC;
#ifdef IBUF_TRACE
    int		index;
#endif

    ipatch_stats.numUserCalls++;
    /*
     * If the ibuffer is not enabled then no patch is necessary.
     */
    statePtr = machCurStatePtrs[Mach_GetProcessorNumber()];
    if ((kpsw & MACH_KPSW_IBUFFER_ENA)) {
	ipatch_stats.numUserCallsWithIbuffer++;
	/*
	 * The trapping R26 was stuffed into trapRegState.aligner by 
	 * SaveState.
	 */
	errorCurPC =  * (int *) &(statePtr->userState.trapRegState.aligner);
#ifdef IBUF_TRACE
	index = trace_end++;
	trace_end = trace_end % TRACE_BUF_SIZE;
	ibuf_trace[index].r10 = (int) statePtr->userState.trapRegState.curPC;
	ibuf_trace[index].r16 = (int) statePtr->userState.trapRegState.nextPC;
	ibuf_trace[index].r26 = errorCurPC;
	ibuf_trace[index].choice = (int)
#endif
	statePtr->userState.trapRegState.curPC = (Address)
	    MachPatchIbuffer(kpsw, statePtr->userState.trapRegState.curPC,
				    statePtr->userState.trapRegState.nextPC,
				    errorCurPC);
    }
    return (int) statePtr->userState.trapRegState.curPC;

}
#endif

/*
 *----------------------------------------------------------------------
 *
 * Mach_GetDebugStateInfo --
 *
 *	Returns a pointer to the debug state for the given processor.
 *
 * Results:
 *	If processor number is valid returns pointer to debug state.
 *	Returns NIL otherwise.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Mach_RegState *
Mach_GetDebugStateInfo(pNum)
    int		pNum;		/* processor number */
{
    if (pNum < 0 || pNum >= Mach_GetNumProcessors()) {
	return (Mach_RegState *) NIL;
    } 
    return &machDebugState[pNum];
}


/*
 *----------------------------------------------------------------------
 *
 * MachSlaveDebug --
 *
	print out debugging information for starting slave processor
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
MachSlaveDebug(index)
    int	index;
{
    static char *msgs[] = {
	"message 0",
	"message 1",
    };

    printf(msgs[index]);
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_GetInstCountInfo --
 *
 *	Returns instruction count and timing information. We have
 *	to convert the Timer_Ticks into Time.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
Mach_GetInstCountInfo(infoPtr)
    Mach_InstCountInfo 	*infoPtr;  	/* buffer for converted info */
{
    int		i;

    bzero(infoPtr, sizeof(mach_InstCount));
    for (i = 0; i < MACH_MAX_INST_COUNT; i++) {
	infoPtr[i] = mach_InstCount[i];
	Timer_TicksToTime(mach_InstCount[i].totalTime.ticks,
		&infoPtr[i].totalTime.time);
    }
}
@


8.10
log
@changed to Fmt constant
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/spur.md/RCS/machCode.c,v 8.9 90/02/12 09:05:22 david Exp Locker: jhh $ SPRITE (Berkeley)";
d1021 1
a1021 1
    oldmode = Dev_CCIdleCounters(TRUE, dev_CurrentCounterMode);
d1067 1
a1067 1
    oldmode = Dev_CCIdleCounters(TRUE, oldmode);
@


8.9
log
@Added code to turn on SPUR performance counters during interrupts.
This allows us to measure the performance of interrupts that
occur while the system is running in the idle loop.

@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/spur.md/RCS/machCode.c,v 8.8 89/09/12 14:39:06 jhh Exp Locker: david $ SPRITE (Berkeley)";
a72 1
 * For compatablity we set this to the old Swap_Buffer constant.
d74 1
a74 1
Fmt_Format mach_Format = SWAP_SPUR_TYPE;
@


8.8
log
@removed typo introduced in last revision
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/spur.md/RCS/machCode.c,v 8.7 89/08/31 12:44:19 douglis Exp Locker: jhh $ SPRITE (Berkeley)";
d30 1
d1018 1
d1020 5
d1065 6
@


8.7
log
@changed panics to warnings during syscall init
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/spur.md/RCS/machCode.c,v 8.6 89/08/17 17:25:31 jhh Exp Locker: douglis $ SPRITE (Berkeley)";
a852 1
    machMaxSysCall++;
@


8.6
log
@now uses Fmt_Convert
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/spur.md/RCS/machCode.c,v 8.5 89/06/19 14:01:50 jhh Exp $ SPRITE (Berkeley)";
d854 1
d856 2
a857 1
	panic( "out-of-order kernel call initialization");
d860 4
a863 1
	panic( "too many kernel calls");
d866 3
a868 1
	panic( "too many arguments to kernel call");
@


8.5
log
@Cleaning up locked files
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/spur.md/RCS/machCode.c,v 8.4 89/03/15 17:45:20 mendel Exp $ SPRITE (Berkeley)";
a26 1
#include "mem.h"
d71 2
a72 1
 * The byte ordering/alignment type used by Swap_Buffer for I/O control data.
d74 1
a74 1
int mach_ByteOrder = SWAP_SPUR_TYPE;
d109 1
d116 3
d154 3
d203 1
d261 1
a261 1
     * Turn off all timers.
d263 7
a269 1
    Mach_Write8bitCCReg(MACH_MODE_REG,0);
d398 2
a399 1
    procPtr->machStatePtr->kernStackEnd = mach_StackBottom + mach_KernStackSize;
d1037 1
a1037 1
	panic( "Non-maskable interrupt while interrupts disabled\n");
d2118 1
a2118 1
     * Turn off all timers.
d2120 6
a2125 1
    Mach_Write8bitCCReg(MACH_MODE_REG,0);
d2575 60
@


8.4
log
@Correct fault printf.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/spur.md/RCS/machCode.c,v 8.3 89/02/06 09:03:51 brent Exp $ SPRITE (Berkeley)";
d283 2
a284 1
    
d1009 3
a1011 1
	/* Mach_RefreshInterrupt(); */
d1916 1
a1916 1
	kdb(signal,statePtr);
d2184 1
d2187 1
d2192 1
a2192 1

d2226 1
d2241 1
d2250 1
d2269 2
d2289 1
d2297 1
d2301 2
d2317 1
d2327 1
d2527 27
@


8.3
log
@Changed malloc to Vm_RawAlloc, because procPtr->machState is never freed.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/spur.md/RCS/machCode.c,v 8.2 89/01/11 09:47:11 mendel Exp Locker: brent $ SPRITE (Berkeley)";
d1165 1
a1165 1
			faultType,procPtr->processID, (unsigned)PC, destAddr);
@


8.2
log
@Changed special handling to use special maskable interrupt. Added fast
refresh code.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/spur.md/RCS/machCode.c,v 8.1 88/11/30 10:36:50 mendel Exp $ SPRITE (Berkeley)";
d380 1
a380 1
    procPtr->machStatePtr = (struct Mach_State *)malloc(sizeof(Mach_State));
d424 1
a424 1
	procPtr->machStatePtr = (Mach_State *)malloc(sizeof(Mach_State));
@


8.1
log
@Added Mach_CheckSpecialHandling() routine.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/spur.md/RCS/machCode.c,v 8.0 88/11/11 18:06:21 douglis Stable Locker: mendel $ SPRITE (Berkeley)";
d118 1
d163 1
d233 3
d237 1
d244 1
d278 6
d476 1
a476 1
     * cause an overflow.  Note that we want the second window so we set
a997 1

d1005 4
a1008 1
	Mach_RefreshInterrupt();
d1011 3
d1164 2
d1236 2
d1549 3
a1551 2
    register	Address	specPageAddr;	/* The new base of the saved window 
					 * stack. */
d1596 1
a1596 1
    specPagePtr->switchState.swpBaseAddr = statePtr->userState.specPageAddr;
d1717 1
a1717 1
    specPagePtr->savedState.swpBaseAddr = (Address)specPagePtr;
d1765 1
a1765 1
		    (Address)((unsigned)specPagePtr->savedState.swpBaseAddr & 
d1822 1
d2047 2
d2052 1
a2052 1
    status = Mach_SignalProcessor(pnum, MACH_SPINUP_INTERRUPT);
d2064 21
d2116 9
d2128 1
a2128 1
static ClientData doNothing()
d2130 1
a2130 1
	return (ClientData) 0;
d2151 1
a2151 2
	ReturnStatus status;
	ClientData   returnValue;
a2152 7
	status = Mach_CallProcessor(processorNum, doNothing, (ClientData) 0,
				    TRUE, &returnValue);
	if (status != SUCCESS) {
		printf(
	"Warning: Can't perfom check of special handling flag for processor %d",
		processorNum);
	}
d2154 1
@


8.0
log
@Changing version numbers.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/spur.md/RCS/machCode.c,v 1.27 88/11/11 15:36:14 mendel Exp Locker: douglis $ SPRITE (Berkeley)";
d2072 34
a2105 1
Mach_CheckSpecialHandling() { }
@


1.27
log
@Changes for multiprocessor, ibuffer, and new libc.a.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/spur.md/RCS/machCode.c,v 1.26 88/10/20 09:20:40 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
@


1.26
log
@Added support for multiple processors.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/spur.md/RCS/machCode.c,v 1.25 88/10/13 13:29:00 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
a18 1
#include "sys.h"
d29 2
a31 6
/*
 *  Number of processors in the system.
 */
#ifndef NUM_PROCESSORS
#define NUM_PROCESSORS		1
#endif NUM_PROCESSORS
d33 1
a33 1
int mach_NumProcessors = NUM_PROCESSORS;
d39 1
a39 1
int mach_MasterProcessor = 0;
d49 1
a49 1
Boolean	mach_KernelMode[NUM_PROCESSORS];
d56 1
a56 1
Boolean mach_AtInterruptLevel[NUM_PROCESSORS];
d62 1
a62 1
int mach_NumDisableInterrupts[NUM_PROCESSORS];
d87 3
a89 1
Mach_RegState	machDebugState[NUM_PROCESSORS];
d94 1
a94 1
int	machCCState[64][NUM_PROCESSORS];
d97 1
a97 1
 * Map NuBus slot ID to a processor number.
d100 1
a100 1
int	mach_SlotIdMap[16];
d117 1
d158 8
a185 1

d212 4
d218 1
a218 1
    for (i = 0; i < NUM_PROCESSORS; i++) { 
d227 4
d237 1
a237 1
    mach_MasterProcessor = Mach_GetProcessorNumber();
d260 11
d278 1
a278 1
			Sys_Panic(SYS_FATAL, "Bad offset %d != %d\n", \
d290 1
a290 1
			Sys_Panic(SYS_FATAL, "Bad offset %d != %d\n", \
d303 1
a303 1
			Sys_Panic(SYS_FATAL, "Bad offset %d != %d\n", \
d310 1
a310 1
			Sys_Panic(SYS_FATAL, "Bad offset %d != %d\n", \
d343 1
a343 1
    Sys_Panic(SYS_FATAL, "InterruptError: Bogus interrupt, ISR=0x%x\n",
d367 2
a368 1
    procPtr->machStatePtr = (struct Mach_State *)Mem_Alloc(sizeof(Mach_State));
d411 1
a411 1
	procPtr->machStatePtr = (Mach_State *)Mem_Alloc(sizeof(Mach_State));
d414 2
a415 1
    statePtr = procPtr->machStatePtr;
d556 1
a556 1
	Sys_Panic(SYS_FATAL, "Mach_StartUserProc: Couldn't pin pages.\n");
d613 1
a613 1
	Sys_Panic(SYS_FATAL, "Mach_ExecUserProc: Couldn't pin stack.\n");
d620 1
d826 1
a826 1
	Sys_Panic(SYS_FATAL, "out-of-order kernel call initialization");
d829 1
a829 1
	Sys_Panic(SYS_FATAL, "too many kernel calls");
d832 1
a832 1
	Sys_Panic(SYS_FATAL, "too many arguments to kernel call");
d990 3
d1001 1
a1001 1
	Sys_Panic(SYS_FATAL, "Non-maskable interrupt while interrupts disabled\n");
d1086 1
a1086 1
	    Sys_Panic(SYS_FATAL, "MachUserError: Unknown user error %d\n",
d1343 1
a1343 1
	    Sys_Panic(SYS_WARNING, "MachGetWinMem: Low pin failed\n");
d1351 1
a1351 1
	    Sys_Panic(SYS_FATAL, "MachGetWinMem: SWP too big.\n");
d1373 1
a1373 1
	    Sys_Panic(SYS_WARNING, "MachGetWinMem: High pin failed\n");
d1687 1
a1687 1
	Sys_Panic(SYS_FATAL, "MachSaveUserState: Save failed\n");
d1739 1
a1739 1
	Sys_Panic(SYS_FATAL, "MachRestoreUserState: Restore failed\n");
d1800 630
@


1.25
log
@Clear upsw when starting a process.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.24 88/09/19 11:08:43 mendel Exp $ SPRITE (Berkeley)";
a28 1
#include "byte.h"
d38 2
d41 10
d54 1
a54 1
Boolean	mach_KernelMode;
a55 1
int mach_NumProcessors = NUM_PROCESSORS;
d61 1
a61 1
Boolean mach_AtInterruptLevel = FALSE;
d64 7
d81 8
d90 1
a90 2
 *  Count of number of ``calls'' to enable interrupts minus number of calls
 *  to disable interrupts.  Kept on a per-processor basis.
d92 1
a92 2
int mach_NumDisableInterrupts[NUM_PROCESSORS];
int *mach_NumDisableIntrsPtr = mach_NumDisableInterrupts;
d95 11
a149 4
/* 
 * Pointer to the state structure for the current process.
 */
extern Mach_State	*machCurStatePtr;
a151 10
 * Debugger state.
 */
Mach_RegState	machDebugState;

/*
 * Cache controller state.
 */
int	machCCState[64];

/*
d207 1
a207 1
     * We start off with interrupts disabled.
d209 12
a220 1
    mach_NumDisableInterrupts[0] = 1;
d222 5
d346 1
a346 1
    machCurStatePtr = procPtr->machStatePtr;
d701 2
a702 3
    Byte_Copy(sizeof(Mach_RegState), 
	      (Address)&procPtr->machStatePtr->userState.trapRegState,
	      (Address)&debugStatePtr->regState);
d739 2
a740 3
    Byte_Copy(sizeof(Mach_RegState), 
	      (Address)&debugStatePtr->regState,
	      (Address)&statePtr->userState.trapRegState);
d911 1
a911 1
 *      Set the non-maskable interrupt mask to the given value.  This will
d926 1
a926 1
    machNonmaskableIntrMask = mask;
d957 1
a957 1
    mach_KernelMode = !(kpsw & MACH_KPSW_PREV_MODE);
d969 2
a970 1
    if (mach_AtInterruptLevel || mach_NumDisableInterrupts[0] > 0) {
d973 1
a973 1
    mach_AtInterruptLevel = TRUE;
d985 1
a985 1
    mach_AtInterruptLevel = FALSE;
d1428 1
a1428 1
    if (mach_KernelMode) {
a1432 22
}


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_GetSlotId --
 *
 * Return the NuBus slot id of the processor.
 *
 * Results:
 *     The slot id.
 *
 * Side effects:
 *     None.
 *
 * ----------------------------------------------------------------------------
 */
unsigned int
Mach_GetSlotId()
{
    return (Mach_Read8bitCCReg(MACH_SLOT_ID_REG));
@


1.24
log
@Mods to read ibuffer.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.23 88/09/13 16:49:49 brent Exp $ SPRITE (Berkeley)";
d391 4
d1124 1
a1126 1
	extern int	etext;
d1133 6
@


1.23
log
@Added mach_ByteOrder
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.22 88/09/13 10:35:28 mendel Exp $ SPRITE (Berkeley)";
d377 5
a381 1
    statePtr->switchRegState.kpsw = (MACH_KPSW_PREFETCH_ENA |
d383 1
d554 5
a558 1
    regStatePtr->kpsw = (MACH_KPSW_PREFETCH_ENA | 
d560 1
d691 6
d698 2
a699 1
    origKpsw = statePtr->userState.trapRegState.kpsw;
@


1.22
log
@Aligned save regs array on Mach_RegState to be on 64bit boundry to allow
st_64's to it.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.21 88/09/02 11:53:00 nelson Exp $ SPRITE (Berkeley)";
d30 1
d58 5
@


1.21
log
@In progress addition of LISP support.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.20 88/08/29 13:52:49 mendel Exp $ SPRITE (Berkeley)";
d204 51
@


1.20
log
@Added debugger support.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.19 88/08/27 18:58:48 nelson Exp $ SPRITE (Berkeley)";
d108 2
d168 4
d350 9
a358 2
	statePtr->userState.minSWP = 0;
	statePtr->userState.maxSWP = 0;
a420 4
    statePtr = procPtr->machStatePtr;
    statePtr->userState.minSWP = (Address)MACH_SAVED_WINDOW_STACK_BASE;
    statePtr->userState.maxSWP = (Address)(MACH_SAVED_WINDOW_STACK_BASE + 
					   VMMACH_PAGE_SIZE);
d424 7
a430 2
    (void)Vm_PinUserMem(VM_READWRITE_ACCESS, VMMACH_PAGE_SIZE,
	          (Address)MACH_SAVED_WINDOW_STACK_BASE);
d469 1
a469 2
	(void)Vm_UnpinUserMem(statePtr->userState.maxSWP - 
					statePtr->userState.minSWP,
d475 12
a486 5
    statePtr->userState.minSWP = (Address)MACH_SAVED_WINDOW_STACK_BASE;
    statePtr->userState.maxSWP = (Address)(MACH_SAVED_WINDOW_STACK_BASE + 
					   VMMACH_PAGE_SIZE);
    (void)Vm_PinUserMem(VM_READWRITE_ACCESS, VMMACH_PAGE_SIZE,
	          (Address)MACH_SAVED_WINDOW_STACK_BASE);
d509 2
a510 2
    regStatePtr->swp = (Address)(MACH_SAVED_WINDOW_STACK_BASE + 
				 2 * MACH_SAVED_WINDOW_SIZE);
d1175 1
a1175 1
	if (statePtr->userState.minSWP <= (Address)MACH_SAVED_WINDOW_STACK_BASE) {
d1189 1
a1189 1
	    (void)Vm_UnpinUserMem(VMMACH_PAGE_SIZE, statePtr->userState.maxSWP);
d1192 6
a1197 4
	(void)Vm_PinUserMem(VM_READWRITE_ACCESS,
		   statePtr->userState.maxSWP - statePtr->userState.minSWP, 
		   statePtr->userState.minSWP);
    } else if (swp >= statePtr->userState.maxSWP - 2 * MACH_SAVED_REG_SET_SIZE) {
d1210 1
a1210 1
	    (void)Vm_UnpinUserMem(VMMACH_PAGE_SIZE, statePtr->userState.minSWP);
d1213 14
a1227 3
	(void)Vm_PinUserMem(VM_READWRITE_ACCESS,
		   statePtr->userState.maxSWP - statePtr->userState.minSWP, 
		   statePtr->userState.minSWP);
d1379 293
@


1.19
log
@Fixed lint errors.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.18 88/08/27 17:26:25 nelson Exp $ SPRITE (Berkeley)";
d909 6
d916 5
@


1.18
log
@Made signal returns return to the proper PC.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.17 88/08/27 14:26:44 nelson Exp $ SPRITE (Berkeley)";
d29 1
d191 2
a192 2
    Mach_Write32bitCCReg(MACH_INTR_MASK_0,0);
    Mach_Write32bitCCReg(MACH_INTR_STATUS_0,-1);
d398 1
d415 2
a416 2
    Vm_PinUserMem(VM_READWRITE_ACCESS, VMMACH_PAGE_SIZE,
	          MACH_SAVED_WINDOW_STACK_BASE);
d455 3
a457 2
	Vm_UnpinUserMem(statePtr->userState.maxSWP - statePtr->userState.minSWP,
		        statePtr->userState.minSWP);
d465 1
a465 1
    Vm_PinUserMem(VM_READWRITE_ACCESS, VMMACH_PAGE_SIZE,
d739 1
a739 1
    int          	(*handler)();  	/* Interrupt handling procedure */
d1158 1
a1158 1
	    Vm_UnpinUserMem(VMMACH_PAGE_SIZE, statePtr->userState.maxSWP);
d1161 1
a1161 1
	Vm_PinUserMem(VM_READWRITE_ACCESS,
d1177 1
a1177 1
	    Vm_UnpinUserMem(VMMACH_PAGE_SIZE, statePtr->userState.minSWP);
d1181 1
a1181 1
	Vm_PinUserMem(VM_READWRITE_ACCESS,
@


1.17
log
@Changed around the way signals are handled so that the state is aved
on the user's stack when a signal handler is called.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.16 88/08/26 11:55:20 nelson Exp $ SPRITE (Berkeley)";
d1223 1
a1223 1
    savedKPSW = statePtr->userState.trapRegState.kpsw;
d1232 3
a1234 1
    statePtr->userState.trapRegState.kpsw = savedKPSW;
@


1.16
log
@Fixed lint error.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.15 88/08/23 11:45:14 nelson Exp $ SPRITE (Berkeley)";
d27 1
a27 1
#include "sigSpur.h"
d868 1
a868 1
void
d912 1
d966 1
d1030 1
d1067 1
d1083 4
d1088 1
a1088 1
	 * Store the signal context onto the user's spill stack.
d1090 2
a1091 5
	statePtr->userState.trapRegState.regs[MACH_SPILL_SP][0] -=
							sizeof(sigContext);
	if (Vm_CopyOut(sizeof(sigContext), (Address)&sigContext,
	   (Address)statePtr->userState.trapRegState.regs[MACH_SPILL_SP][0]) !=
								SUCCESS) {
d1094 10
d1207 2
d1212 5
a1216 2
    if (Vm_CopyIn(sizeof(sigContext), 
	    (Address)statePtr->userState.trapRegState.regs[MACH_SPILL_SP][0],
d1220 10
d1232 1
@


1.15
log
@Fixed lint complaints.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.14 88/08/23 10:19:44 mendel Exp $ SPRITE (Berkeley)";
d268 1
d270 1
a270 1
Mach_SetupNewState(procPtr, parStatePtr, startFunc, startPC)
d281 1
d571 3
d598 9
@


1.14
log
@Various bug fixes in window overflow/underflow and signal routines.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.13 88/08/18 18:43:48 nelson Exp $ SPRITE (Berkeley)";
d323 1
a323 1
    statePtr->switchRegState.curPC = ((Address)startFunc) - 8;
d954 2
a955 2
		if ((unsigned)PC >= (unsigned)MachFetchArgStart &&
	            (unsigned)PC < (unsigned)MachFetchArgEnd) {
d957 2
a958 2
		} else if ((unsigned)PC >= (unsigned)VmMachDoCopy &&
	                   (unsigned)PC < (unsigned)VmMachCopyEnd) {
d1004 16
a1019 13
    }
    if (faultType & MACH_VM_FAULT_REF_BIT) {
	VmMach_SetRefBit(PC);
	return(MACH_NORM_RETURN);
    } else if (faultType & MACH_VM_FAULT_PAGE_FAULT) {
	/* 
	 * Take a page fault on this address.
	 */
	if (Vm_PageIn(PC, FALSE) != SUCCESS) {
	    procPtr = Proc_GetCurrentProc();
	    (void)Sig_Send(SIG_ADDR_FAULT, SIG_ACCESS_VIOL,
			   procPtr->processID, FALSE);
	    return(MACH_USER_ACCESS_VIOL);
@


1.13
log
@Got simple user processes working.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.12 88/08/17 11:58:05 mendel Exp $ SPRITE (Berkeley)";
d1129 1
a1129 1
    } else if (swp > statePtr->userState.maxSWP - 2 * MACH_SAVED_WINDOW_SIZE) {
d1133 1
a1133 1
	if (swp > statePtr->userState.maxSWP - 1 * MACH_SAVED_WINDOW_SIZE) {
@


1.12
log
@Changed to special refresh timer and added proper calls to pin
user memory.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.11 88/08/09 18:38:56 nelson Exp $ SPRITE (Berkeley)";
d105 2
d172 1
d291 1
a291 1
    statePtr->kernStackStart = Vm_GetKernelStack(1);
d934 1
a934 1
	procPtr->genFlags & PROC_KERNEL) {
d999 1
a999 1
	if (PC > (Address)&etext || PC < (Address)MACH_CODE_START) {
@


1.11
log
@Middle of spur port.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.10 88/08/01 15:04:13 mendel Exp $ SPRITE (Berkeley)";
d189 5
d408 2
a409 3
    Vm_PinUserMem(VM_READWRITE_ACCESS,
	       statePtr->userState.maxSWP - statePtr->userState.minSWP, 
	       statePtr->userState.minSWP);
d457 2
a458 3
    Vm_PinUserMem(VM_READWRITE_ACCESS,
	       statePtr->userState.maxSWP - statePtr->userState.minSWP, 
	       statePtr->userState.minSWP);
d480 1
a480 1
    regStatePtr->cwp = 4;
d775 1
d808 2
a809 3
     * Do any nonmaskable interrupts first being careful to restore 
     * mach_AtInterruptLevel to original value when done.
    */ 
d811 2
a812 15
         int 	old_AtInterruptLevel = mach_AtInterruptLevel;
         mach_AtInterruptLevel = TRUE;
         intrType = 0;
         intrMask = 1;
         statusReg = intrStatusReg & machNonmaskableIntrMask;
         while (statusReg != 0) {
	     if (statusReg & intrMask) {
	         (interruptHandlers[intrType])(&statusReg);
	         statusReg &= ~intrMask;
	      }
	      intrMask = intrMask << 1;
	      intrType++;
          }
          mach_AtInterruptLevel = old_AtInterruptLevel;
          intrStatusReg &= ~machNonmaskableIntrMask;
d930 2
a931 1
    if (procPtr->genFlags & PROC_KERNEL) {
@


1.10
log
@Fixed bug in Mach_AllocExtIntrNumber.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.9 88/07/31 22:48:07 mendel Exp $ SPRITE (Berkeley)";
d333 2
d340 2
d367 1
a367 1
    procPtr->machStatePtr->userState.trapRegState.regs[MACH_RETURN_VAL_REG][1] = retVal;
d443 13
a455 2
    Vm_UnpinUserMem(statePtr->userState.maxSWP - statePtr->userState.minSWP,
		 statePtr->userState.minSWP);
d458 1
a458 1
    regStatePtr->regs[MACH_SPILL_SP][1] = (int)userStackPtr;
d611 1
a611 1
    return((Address)procPtr->machStatePtr->userState.trapRegState.regs[MACH_SPILL_SP][1]);
d827 3
d911 1
a911 1
 * MachVMFault --
d913 1
a913 1
 *      Handle a Virtual memory fault.
d916 7
a922 1
 *      None.
d930 1
a930 1
MachVMFault(faultType, PC, isDestAddr, destAddr, kpsw)
d932 1
a932 4
    Address	PC;		/* The address of the instruction that caused
				 * the fault. */
    Boolean	isDestAddr;	/* TRUE if faulting instruction was a load or
				 * a store and thus destAddr has a value. */
a937 3
#ifdef spurboot
    return(MACH_KERN_ACCESS_VIOL);
#else
d940 2
a941 5
    if (faultType & MACH_VM_FAULT_REF_BIT) {
	VmMach_SetRefBit(PC);
	if (isDestAddr) {
	    VmMach_SetRefBit(destAddr);
	}
a942 7
    if (faultType & MACH_VM_FAULT_DIRTY_BIT) {
	if (!isDestAddr) {
	    Sys_Panic(SYS_FATAL, "MachVMFault: PC dirty??\n");
	} else {
	    VmMach_SetModBit(destAddr);
	}
    }
d944 6
a949 7
    if (faultType & (MACH_VM_FAULT_PROTECTION | MACH_VM_FAULT_PAGE_FAULT)) {
	Boolean		userFault;
	extern unsigned	etext;

	return(MACH_KERN_ACCESS_VIOL);

	userFault = kpsw & MACH_KPSW_PREV_MODE;
a953 41
	if (PC < (Address)VMMACH_SEG_SIZE) {
	    /*
	     * The PC falls into the system segment.  If it is above
	     * the end of the text or if it is inside the text part but 
	     * it caused a fault (i.e. there is no data address) then this
	     * is an error.
	     */
	    if (PC >= (Address)&etext || !isDestAddr) {
		if (userFault) {
		    (void)Sig_Send(SIG_ADDR_FAULT, SIG_ACCESS_VIOL,
                                   procPtr->processID, FALSE);
		    return(MACH_NORM_RETURN);
		} else {
		    return(MACH_KERN_ACCESS_VIOL);
		}
	    }
	} else {
	    /*
	     * The PC falls into one of the user segments.  If this is
	     * a kernel process then this is in an error.
	     */
	    if (!userFault) {
		return(MACH_KERN_ACCESS_VIOL);
	    }
	    /* Take a page fault on this address.  Since all of the user
	     * segments are readable this can't possibly be a protection
	     * fault if the page is valid.
	     */
	    if (Vm_PageIn(PC, FALSE) != SUCCESS) {
		(void)Sig_Send(SIG_ADDR_FAULT, SIG_ACCESS_VIOL,
			       procPtr->processID, FALSE);
		return(MACH_NORM_RETURN);
	    }
	}
	/*
	 * Now we have handled the program counter's page so handle the 
	 * data address if there is one.
	 */
	if (!isDestAddr) {
	    return(MACH_NORM_RETURN);
	}
d956 1
a956 1
	    if (userFault) {
a958 1
		return(MACH_NORM_RETURN);
d972 1
a972 1
#endif
d979 54
d1068 10
a1077 1
	statePtr->userState.oldHoldMask = sigContext.oldHoldMask;
d1175 1
a1175 2
MachSigReturn(oldHoldMask)
    unsigned	int	oldHoldMask;
d1177 4
a1180 2
    Sig_Stack	sigStack;
    Sig_Context	sigContext;
d1182 9
a1191 1
    sigContext.oldHoldMask = oldHoldMask;
@


1.9
log
@Changed Mach_SetupNewState to set curPC of new process to startFunc - 8
to allow MachContextSwitch's "return r10,$8" to jump to the correct 
place.
Modified MachInterrupt not to trash mach_AtInterruptLevel when processing
at nonmaskable interrupt during a maskable interrupt.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.8 88/07/29 11:33:50 nelson Exp $ SPRITE (Berkeley)";
d721 1
@


1.8
log
@*** empty log message ***
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.7 88/07/29 11:26:42 nelson Exp $ SPRITE (Berkeley)";
d184 5
d208 1
a208 1
InterruptError(statusRegPtr, kpsw)
a209 1
    unsigned	int	kpsw;
d211 2
a212 2
    Sys_Panic(SYS_FATAL, "InterruptError: Bogus interrupt, ISR=%x KPSW=%x\n",
			 *statusRegPtr, kpsw);
a310 1
    statePtr->switchRegState.curPC = (Address)startFunc;
d312 5
d780 2
a781 2
    unsigned	int	intrMask;
    int			intrType;
d785 1
d787 24
a810 1
    mach_KernelMode = !(kpsw & MACH_KPSW_PREV_MODE);
@


1.7
log
@SPUR port in progress.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.6 88/07/23 12:51:09 nelson Exp $ SPRITE (Berkeley)";
d897 1
a897 1
	    Sys_Panic(SYS_PANIC, "MachVMFault: PC dirty??\n");
@


1.6
log
@Successfully use non-maskable timer to refresh wells.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.5 88/07/20 18:29:57 nelson Exp $ SPRITE (Berkeley)";
d116 5
d290 7
a296 7
     * r15.  MachContextSwitch will return to the value stored in r10 so
     * we set the value of the function to start executing at in r26.  When
     * it returns it will go back one window (which will be the exact window
     * of switchRegState.regs) and start executing in the start function.
     * The start function will expect as an argument the PC of where to start
     * the process for real.  Thus in order to set up the first arg we
     * have to put a value in MACH_INPUT_REG1.
d298 1
a298 1
    statePtr->switchRegState.regs[MACH_SPILL_SP][1] = (int)statePtr->kernStackEnd;
d305 3
a307 2
				     MACH_KPSW_ERROR_TRAP_ENA);
    statePtr->switchRegState.regs[26][1] = (int)startFunc;
d310 2
a311 1
     * cause an overflow.
d313 1
a313 1
    statePtr->switchRegState.cwp = 2;
d329 1
a329 1
	statePtr->switchRegState.regs[MACH_INPUT_REG1][1] = (int)startPC;
d520 48
a881 2
    return(MACH_KERN_ACCESS_VIOL);
#ifdef real_kernel
d884 3
d896 4
a899 3
	VmMach_SetDirtyBit(PC);
	if (isDestAddr) {
	    VmMach_SetDirtyBit(destAddr);
d905 1
d907 2
d921 1
a921 1
	    if (PC >= (Address)&endText || !isDestAddr) {
d1174 2
a1176 2
	return (Mach_Read8bitCCReg(MACH_SLOT_ID_REG));
}
@


1.5
log
@Initial spur boot
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.4 88/07/16 15:41:06 nelson Exp $ SPRITE (Berkeley)";
a123 5
/*
 * The address where the UART is mapped.
 */
Address	mach_UARTAddr = (Address)VMMACH_UART_ADDR;

d175 4
d315 3
a317 3
	Byte_Copy(sizeof(statePtr->userState.trapRegState),
		  (Address)&parStatePtr->userState.trapRegState,
		  (Address)&statePtr->userState.trapRegState);
d384 1
a384 1
    Vm_UserMap(VM_READWRITE_ACCESS,
d424 1
a424 1
    Vm_UserUnmap(statePtr->userState.maxSWP - statePtr->userState.minSWP,
d506 3
a508 3
    Byte_Copy(sizeof(Mach_RegState),
	      (Address)&statePtr->userState.trapRegState,
	      (Address)&destProcPtr->machStatePtr->userState.trapRegState);
d616 1
d675 25
d721 2
d827 2
d914 1
d1008 1
a1008 1
	    Vm_UserUnmap(VMMACH_PAGE_SIZE, statePtr->userState.maxSWP);
d1011 1
a1011 1
	Vm_UserMap(VM_READWRITE_ACCESS,
d1027 1
a1027 1
	    Vm_UserUnmap(VMMACH_PAGE_SIZE, statePtr->userState.minSWP);
d1031 1
a1031 1
	Vm_UserMap(VM_READWRITE_ACCESS,
d1157 1
a1157 1
	return (SYS_SPUR);
@


1.4
log
@Added the UART mapping and the refresh and single step traps and made the
debugger be entered with all traps enabled but interrupts off.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.3 88/07/15 12:25:27 nelson Exp $ SPRITE (Berkeley)";
d385 3
a387 1
    Vm_UserMap(statePtr->userState.minSWP, statePtr->userState.maxSWP);
d425 2
a426 1
    Vm_UserUnmap(statePtr->userState.minSWP, statePtr->userState.maxSWP);
a976 2
	    Vm_UserUnmap(statePtr->userState.minSWP + VMMACH_PAGE_SIZE,
			 statePtr->userState.maxSWP);
d978 1
d981 3
a983 1
	Vm_UserMap(statePtr->userState.minSWP, statePtr->userState.maxSWP);
d997 1
a997 2
	    Vm_UserUnmap(statePtr->userState.minSWP,
			 statePtr->userState.minSWP + VMMACH_PAGE_SIZE);
d1001 3
a1003 1
	Vm_UserMap(statePtr->userState.minSWP, statePtr->userState.maxSWP);
@


1.3
log
@*** empty log message ***
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.2 88/07/13 15:55:53 mendel Exp $ SPRITE (Berkeley)";
d123 5
@


1.2
log
@Changed mach_CycleTime to be an unsigned int to remove floating point from
kernel.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 1.1 88/07/12 14:46:02 brent Exp $ SPRITE (Berkeley)";
d595 1
a595 1
    int		 (*handler)();	/* Interrupt handling procedure */
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 5.13 88/05/05 17:55:10 nelson Exp $ SPRITE (Berkeley)";
d77 1
a77 1
double	mach_CycleTime = MACH_CYCLE_TIME;
@
