head     9.19;
branch   ;
access   ;
symbols  ds3100:9.19 sun3:9.19 sun4nw:9.19 symm:9.19 spur:9.19 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.19
date     91.10.10.12.08.22;  author shirriff;  state Exp;
branches ;
next     9.18;

9.18
date     91.09.10.18.17.12;  author rab;  state Exp;
branches ;
next     9.17;

9.17
date     91.08.13.22.27.34;  author shirriff;  state Exp;
branches ;
next     9.16;

9.16
date     91.08.12.22.15.25;  author shirriff;  state Exp;
branches ;
next     9.15;

9.15
date     91.08.09.16.06.57;  author shirriff;  state Exp;
branches ;
next     9.14;

9.14
date     91.08.09.16.05.45;  author shirriff;  state Exp;
branches ;
next     9.13;

9.13
date     91.07.30.16.41.03;  author shirriff;  state Exp;
branches ;
next     9.12;

9.12
date     91.07.26.17.03.18;  author shirriff;  state Exp;
branches ;
next     9.11;

9.11
date     91.04.08.12.58.52;  author shirriff;  state Exp;
branches ;
next     9.10;

9.10
date     91.03.30.15.14.06;  author shirriff;  state Exp;
branches ;
next     9.9;

9.9
date     91.03.29.17.54.05;  author shirriff;  state Exp;
branches ;
next     9.8;

9.8
date     90.12.07.23.40.58;  author rab;  state Exp;
branches ;
next     9.7;

9.7
date     90.10.03.13.52.47;  author mgbaker;  state Exp;
branches ;
next     9.6;

9.6
date     90.09.11.19.06.18;  author mendel;  state Exp;
branches ;
next     9.5;

9.5
date     90.07.30.16.17.16;  author shirriff;  state Exp;
branches ;
next     9.4;

9.4
date     90.07.30.11.34.19;  author shirriff;  state Exp;
branches ;
next     9.3;

9.3
date     90.02.20.15.27.21;  author jhh;  state Exp;
branches ;
next     9.2;

9.2
date     89.10.30.20.48.53;  author rab;  state Exp;
branches ;
next     9.1;

9.1
date     89.10.12.12.37.57;  author shirriff;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.14.52.09;  author douglis;  state Stable;
branches ;
next     8.16;

8.16
date     89.09.11.23.43.35;  author rab;  state Exp;
branches ;
next     8.15;

8.15
date     89.08.31.12.44.10;  author douglis;  state Exp;
branches ;
next     8.14;

8.14
date     89.08.17.17.24.29;  author jhh;  state Exp;
branches ;
next     8.13;

8.13
date     89.08.03.23.10.55;  author rab;  state Exp;
branches ;
next     8.12;

8.12
date     89.08.01.20.40.26;  author jhh;  state Exp;
branches ;
next     8.11;

8.11
date     89.07.26.09.23.14;  author ouster;  state Exp;
branches ;
next     8.10;

8.10
date     89.07.20.07.07.00;  author rab;  state Exp;
branches ;
next     8.9;

8.9
date     89.06.16.13.06.24;  author rab;  state Exp;
branches ;
next     8.8;

8.8
date     89.05.24.02.03.59;  author rab;  state Exp;
branches ;
next     8.7;

8.7
date     89.05.23.09.43.28;  author mendel;  state Exp;
branches ;
next     8.6;

8.6
date     89.03.15.18.04.42;  author jhh;  state Exp;
branches ;
next     8.5;

8.5
date     89.03.02.17.13.25;  author rab;  state Exp;
branches ;
next     8.4;

8.4
date     89.02.06.09.02.23;  author brent;  state Exp;
branches ;
next     8.3;

8.3
date     89.01.13.09.37.57;  author douglis;  state Exp;
branches ;
next     8.2;

8.2
date     88.12.04.14.03.19;  author ouster;  state Exp;
branches ;
next     8.1;

8.1
date     88.11.18.15.26.59;  author jhh;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.04.45;  author douglis;  state Stable;
branches ;
next     6.8;

6.8
date     88.11.07.14.36.28;  author mlgray;  state Exp;
branches ;
next     6.7;

6.7
date     88.11.07.14.14.13;  author mlgray;  state Exp;
branches ;
next     6.6;

6.6
date     88.10.28.14.35.27;  author mendel;  state Exp;
branches ;
next     6.5;

6.5
date     88.10.17.16.42.28;  author mendel;  state Exp;
branches ;
next     6.4;

6.4
date     88.09.13.16.50.40;  author brent;  state Exp;
branches ;
next     6.3;

6.3
date     88.08.27.19.33.25;  author nelson;  state Exp;
branches ;
next     6.2;

6.2
date     88.08.25.12.21.48;  author nelson;  state Exp;
branches ;
next     6.1;

6.1
date     88.08.24.17.52.18;  author nelson;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.10.00;  author brent;  state Stable;
branches ;
next     5.21;

5.21
date     88.07.26.11.02.14;  author douglis;  state Exp;
branches ;
next     5.20;

5.20
date     88.07.17.19.37.45;  author nelson;  state Exp;
branches 5.20.1.1 5.20.2.1;
next     5.19;

5.19
date     88.07.17.18.45.05;  author brent;  state Exp;
branches ;
next     5.18;

5.18
date     88.07.07.15.25.47;  author nelson;  state Exp;
branches ;
next     5.17;

5.17
date     88.07.07.15.14.41;  author nelson;  state Exp;
branches ;
next     5.16;

5.16
date     88.07.07.11.14.17;  author douglis;  state Exp;
branches ;
next     5.15;

5.15
date     88.06.25.20.01.56;  author ouster;  state Exp;
branches ;
next     5.14;

5.14
date     88.06.17.15.53.36;  author nelson;  state Exp;
branches ;
next     5.13;

5.13
date     88.05.05.17.55.10;  author nelson;  state Exp;
branches ;
next     5.12;

5.12
date     88.05.04.16.40.13;  author nelson;  state Exp;
branches ;
next     5.11;

5.11
date     88.05.04.15.53.08;  author nelson;  state Exp;
branches ;
next     5.10;

5.10
date     88.04.13.11.25.21;  author ouster;  state Exp;
branches ;
next     5.9;

5.9
date     88.03.30.11.22.02;  author ouster;  state Exp;
branches ;
next     5.8;

5.8
date     88.03.30.11.05.42;  author ouster;  state Exp;
branches ;
next     5.7;

5.7
date     88.03.28.13.02.22;  author douglis;  state Exp;
branches ;
next     5.6;

5.6
date     88.02.08.10.38.31;  author nelson;  state Exp;
branches ;
next     5.5;

5.5
date     87.12.15.15.28.23;  author nelson;  state Exp;
branches ;
next     5.4;

5.4
date     87.12.12.16.30.50;  author nelson;  state Exp;
branches ;
next     5.3;

5.3
date     87.12.11.14.19.07;  author nelson;  state Exp;
branches ;
next     5.2;

5.2
date     87.10.22.15.01.24;  author nelson;  state Exp;
branches ;
next     5.1;

5.1
date     87.08.21.13.17.24;  author nelson;  state Exp;
branches ;
next     5.0;

5.0
date     87.08.11.10.50.33;  author sprite;  state Exp;
branches ;
next     ;

5.20.1.1
date     88.07.25.22.11.24;  author douglis;  state Exp;
branches ;
next     ;

5.20.2.1
date     88.07.26.10.30.53;  author douglis;  state Exp;
branches ;
next     ;


desc
@@


9.19
log
@Removed debugging message.
@
text
@/* 
 * machCode.c --
 *
 *     C code for the mach module.
 *
 * Copyright 1989 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.18 91/09/10 18:17:12 rab Exp Locker: shirriff $ SPRITE (Berkeley)";
#endif /* not lint */

#include <sprite.h>
#include <assert.h>
#include <stddef.h>
#include <stdio.h>

#include <machConst.h>
#include <machMon.h>
#include <machInt.h>
#include <mach.h>
#include <sys.h>
#include <sync.h>
#include <dbg.h>
#include <proc.h>
#include <procMigrate.h>
#include <prof.h>
#include <sched.h>
#include <vm.h>
#include <vmMach.h>
#include <sig.h>
#include <swapBuffer.h>
#include <user/sigMach.h>
#include <user/sun3.md/sys/machSignal.h>
#include <procUnixStubs.h>
#include <compatInt.h>
#include <sigUnixStubs.h>

int	machLastSP, machPOP;

/*
 *  Number of processors in the system.
 */
#ifndef NUM_PROCESSORS
#define NUM_PROCESSORS 1
#endif /* NUM_PROCESSORS */

int mach_NumProcessors = NUM_PROCESSORS;

/*
 * TRUE if cpu was in kernel mode before the interrupt, FALSE if was in 
 * user mode.
 */
Boolean	mach_KernelMode;

/*
 *  Flag used by routines to determine if they are running at
 *  interrupt level.
 */
Boolean mach_AtInterruptLevel = FALSE;

extern int debugProcStubs;

/*
 * The machine type string is imported by the file system and
 * used when expanding $MACHINE in file names.
 */

#ifdef sun3
char *mach_MachineType = "sun3";
#endif
#ifdef sun2
char *mach_MachineType = "sun2";
#endif

extern int debugProcStubs;

/*
 * The byte ordering/alignment type used with Fmt_Convert and I/O control data
 */
Fmt_Format mach_Format = FMT_68K_FORMAT;

/*
 *  Count of number of ``calls'' to enable interrupts minus number of calls
 *  to disable interrupts.  Kept on a per-processor basis.
 */
int mach_NumDisableInterrupts[NUM_PROCESSORS];
int *mach_NumDisableIntrsPtr = mach_NumDisableInterrupts;

/*
 * The format that the kernel stack has to be in to start a process off.
 */
typedef struct {
    int		magicNumber;		/* Magic number used to determine if
					 * the stack has been corrupted. */
    Address	userStackPtr;		/* The user's stack pointer. */
    short	statusReg;		/* The status register. */
    void	(*startFunc)();		/* Function to call when process
					 * first starts executing. */
    int		retPC;			/* Return PC that will be sitting on the
					 * stack when startFunc is called. */
    Address	startPC;		/* PC to start executing at.  Is passed
					 * as an argument to startFunc. */
    int		fill1;			/* Filler for the debugger. */
    int		fill2;			/* Filler for the debugger. */
} KernelStack;

/*
 * The format of a signal stack that is pushed onto a user's stack when
 * a signal is handled.
 */
typedef struct {
    Address	retAddr;
    Sig_Stack	sigStack;
    Sig_Context	sigContext;
} SignalStack;

typedef struct UnixSignalStack {
    int sigNum;
    int sigCode;
    struct sigcontext *sigContextPtr;
    int sigAddr;
    struct sigcontext sigContext;
} UnixSignalStack;

/*
 * Machine dependent variables.
 */
Address	mach_KernStart;
Address	mach_CodeStart;
Address	mach_StackBottom;
int	mach_KernStackSize;
Address	mach_KernEnd;
Address	mach_FirstUserAddr;
Address	mach_LastUserAddr;
Address	mach_MaxUserStackAddr;
int	mach_LastUserStackPage;

extern	int		MachGetVBR();
MachVectorTable		*machVectorTablePtr;
int			((*machInterruptRoutines[256])());
ClientData		machInterruptArgs[256];


/*
 * The variables and tables below are used by the assembler routine
 * in machTrap.s that dispatches kernel calls.  All of this information
 * is shared with machTrap.s;  if you change any of this, be sure to
 * change the assembler to match.
 */

#define MAXCALLS 120
#define MAXARGS  16

int machMaxSysCall;			/* Highest defined system call. */
int machArgOffsets[MAXCALLS];		/* For each system call, tells how much
					 * to add to the sp at the time of the
					 * call to get to the highest argument
					 * on the stack. */
Address machArgDispatch[MAXCALLS];	/* For each system call, gives an
					 * address to branch to, in the middle
					 * of MachFetchArgs, to copy the right
					 * # of args from user space to the
					 * kernel's stack. */
ReturnStatus (*(mach_NormalHandlers[MAXCALLS]))();
					/* For each system call, gives the
					 * address of the routine to handle
					 * the call for non-migrated processes.
					 */
ReturnStatus (*(mach_MigratedHandlers[MAXCALLS]))();
					/* For each system call, gives the
					 * address of the routine to handle
					 * the call for migrated processes. */
int machKcallTableOffset;		/* Byte offset of the kcallTable field
					 * in a Proc_ControlBlock. */
int machStatePtrOffset;			/* Byte offset of the machStatePtr
					 * field in a Proc_ControlBlock. */
int machSpecialHandlingOffset;		/* Byte offset of the specialHandling
					 * field in a Proc_ControlBlock. */
/* 
 * Pointer to the state structure for the current process.
 */
Mach_State	*machCurStatePtr = (Mach_State *)NIL;

MachMonBootParam	machMonBootParam;

static void SetupSigHandler _ARGS_((register Proc_ControlBlock *procPtr, register SignalStack *sigStackPtr, Address pc));
static void ReturnFromSigHandler _ARGS_((register Proc_ControlBlock *procPtr));


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_Init --
 *
 *	Initialize the exception vector table and some of the dispatching
 *	tables.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The exception vector table is initialized.
 *
 * ----------------------------------------------------------------------------
 */
void
Mach_Init()
{
    int	*vecTablePtr;
    int	*protoVecTablePtr;
    int	i;
    int	offset;

    /*
     * Set exported machine dependent variables.
     */
    mach_KernStart = (Address)MACH_KERN_START;
    mach_KernEnd = (Address)MACH_KERN_END;
    mach_CodeStart = (Address)MACH_CODE_START;
    mach_StackBottom = (Address)MACH_STACK_BOTTOM;
    mach_KernStackSize = MACH_KERN_STACK_SIZE;
    mach_FirstUserAddr = (Address)MACH_FIRST_USER_ADDR;
    mach_LastUserAddr = (Address)MACH_LAST_USER_ADDR;
    mach_MaxUserStackAddr = (Address)MACH_MAX_USER_STACK_ADDR;
    mach_LastUserStackPage = (MACH_MAX_USER_STACK_ADDR - 1) / VMMACH_PAGE_SIZE;

    /*
     * Copy the boot parameter structure. The original location will get
     * unmapped during vm initialization so we need to get our own copy.
     */
    machMonBootParam = **(romVectorPtr->bootParam);
    offset = (int) *(romVectorPtr->bootParam) - (int) &(machMonBootParam);
    for (i = 0; i < 8; i++) {
	if (machMonBootParam.argPtr[i] != (char *) 0 &&
	 machMonBootParam.argPtr[i] != (char *) NIL) {
	    machMonBootParam.argPtr[i] -= offset;
	}
    }
    /*
     * Clear out the line input buffer to the prom so we don't get extra
     * characters at the end of shorter reboot strings.
     */
    bzero((Address) romVectorPtr->lineBuf, *romVectorPtr->lineSize);
    /*
     * Initialize the vector table.
     */
    vecTablePtr = (int *) MachGetVBR();
    machVectorTablePtr = (MachVectorTable *) vecTablePtr;
    protoVecTablePtr = (int *) &machProtoVectorTable;
    for (i = 0; i < MACH_NUM_EXCEPTIONS; i++) {
	if (*protoVecTablePtr != 0) {
	     *vecTablePtr = *protoVecTablePtr;
	}

	vecTablePtr++;
	protoVecTablePtr++;
    }

#ifdef sun3
    /*
     * Initialize the autovector interrupt slots.
     */
    for (i = MACH_NUM_EXCEPTIONS ; i<256 ; i++) {
	extern int MachBrkptTrap();

	*vecTablePtr = (int)MachBrkptTrap;
	vecTablePtr++;
    }
#endif sun3
#ifndef sun3
    /*
     * Put the vectors at the base of the kernel if are on a Sun-2 only.  On
     * a Sun-3 they can stay where they are.  The vectors on the Sun-2 can
     * be moved this easily because virtual address 0 which is where the
     * vector table is at, points to the same physical page as virtual address 
     * mach_KernStart.
     */
    MachSetVBR(mach_KernStart);
    machVectorTablePtr = (MachVectorTable *) mach_KernStart;
#endif

    /*
     * Initialize some of the dispatching information.  The rest is
     * initialized by Mach_InitSysCall below.
     */
    machMaxSysCall = -1;
    machKcallTableOffset = (int) &((Proc_ControlBlock *) 0)->kcallTable;
    machStatePtrOffset = (int) &((Proc_ControlBlock *) 0)->machStatePtr;
    machSpecialHandlingOffset = (int) 
				&((Proc_ControlBlock *) 0)->specialHandling;

    /*
     * We start off with interrupts disabled.
     */
    mach_NumDisableInterrupts[0] = 1;
}



/*
 *----------------------------------------------------------------------
 *
 * Mach_InitFirstProc --
 *
 *	Initialize the machine state struct for the very first process.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Machine info allocated and stack start set up.
 *
 *----------------------------------------------------------------------
 */
void
Mach_InitFirstProc(procPtr)
    Proc_ControlBlock	*procPtr;
{

    assert(offsetof(Proc_ControlBlock, unixErrno) == MACH_UNIX_ERRNO_OFFSET);
    procPtr->machStatePtr = (Mach_State *)Vm_RawAlloc(sizeof(Mach_State));
    bzero((Address) procPtr->machStatePtr, sizeof(*procPtr->machStatePtr));
    procPtr->machStatePtr->kernStackStart = mach_StackBottom;
    machCurStatePtr = procPtr->machStatePtr;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_SetupNewState --
 *
 *	Initialize the machine state for this process.  This includes 
 *	allocating and initializing a kernel stack.  Assumed that will
 *	be called when starting a process after a fork or restarting a
 *	process after a migration.
 *
 * Results:
 *	PROC_NO_STACKS if couldn't allocate a kernel stack.  SUCCESS otherwise.
 *
 * Side effects:
 *	Machine state in the destination process control block is overwritten.
 *
 *----------------------------------------------------------------------
 */ 
ReturnStatus
Mach_SetupNewState(procPtr, fromStatePtr, startFunc, startPC, user)
    Proc_ControlBlock	*procPtr;	/* Pointer to process control block
					 * to initialize state for. */
    Mach_State		*fromStatePtr;	/* State of parent on fork or from
					 * other machine on migration. */
    void		(*startFunc)();	/* Function to call when process first
					 * starts executing. */
    Address		startPC;	/* Address to pass as argument to 
					 * startFunc.  If NIL then the address
					 * is taken from *fromStatePtr's 
					 * exception stack. */
    Boolean		user;		/* TRUE if is a user process. */
{
    register	KernelStack	*stackPtr;
    register	Mach_State	*statePtr;

    if (procPtr->machStatePtr == (Mach_State *)NIL) {
	procPtr->machStatePtr = (Mach_State *)Vm_RawAlloc(sizeof(Mach_State));
    }
    bzero((Address) procPtr->machStatePtr, sizeof(*procPtr->machStatePtr));
    statePtr = procPtr->machStatePtr;
    /* 
     * Allocate a kernel stack for this process.
     */
    statePtr->kernStackStart = Vm_GetKernelStack(0);
    if (statePtr->kernStackStart == (Address)NIL) {
	return(PROC_NO_STACKS);
    }

    statePtr->switchRegs[SP] = (int)(statePtr->kernStackStart + 
			             MACH_KERN_STACK_SIZE - 
				     sizeof(KernelStack));

    /*
     * Initialize the stack so that it looks like it is in the middle of
     * Mach_ContextSwitch.
     */
    stackPtr = (KernelStack *)(statePtr->switchRegs[SP]);
    stackPtr->magicNumber = MAGIC;
    stackPtr->userStackPtr = mach_MaxUserStackAddr;
    stackPtr->statusReg = MACH_SR_HIGHPRIO;
    stackPtr->startFunc =  startFunc;
    stackPtr->fill1 = 0;
    stackPtr->fill2 = 0;
    /* 
     * Set up the state of the process.  User processes inherit from their
     * parent or the migrated process.  If the PC is not specified, take it
     * from the parent as well.
     */
    if (user) {
	statePtr->userState.userStackPtr =
		fromStatePtr->userState.userStackPtr;
	bcopy((Address)fromStatePtr->userState.trapRegs,
		  (Address)statePtr->userState.trapRegs,
		  sizeof(statePtr->userState.trapRegs));
#ifdef sun3
	bcopy((Address)fromStatePtr->userState.trapFpRegs,
		  (Address)statePtr->userState.trapFpRegs,
		  sizeof(statePtr->userState.trapFpRegs));
	bcopy((Address)fromStatePtr->userState.trapFpCtrlRegs,
		  (Address)statePtr->userState.trapFpCtrlRegs,
		  sizeof(statePtr->userState.trapFpCtrlRegs));
	bcopy((Address) &fromStatePtr->userState.trapFpuState,
		  (Address) &statePtr->userState.trapFpuState,
		  sizeof(statePtr->userState.trapFpuState));
#endif
    }
    if (startPC == (Address)NIL) {
	stackPtr->startPC = (Address)fromStatePtr->userState.excStackPtr->pc;
    } else {
	stackPtr->startPC = startPC;
    }
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * Mach_SetReturnVal --
 *
 *	Set the return value for a process from a system call.  Intended to
 *	be called by the routine that starts a user process after a fork.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Register D0 is set in the user registers.
 *
 *----------------------------------------------------------------------
 */ 
void
Mach_SetReturnVal(procPtr, retVal, retVal2)
    Proc_ControlBlock	*procPtr;	/* Process to set return value for. */
    int			retVal;		/* Value for process to return. */
    int			retVal2;	/* Second return value. */
{
    procPtr->machStatePtr->userState.trapRegs[D0] = retVal;
    procPtr->machStatePtr->userState.trapRegs[D1] = retVal2;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_StartUserProc --
 *
 *	Start a user process executing for the first time.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Stack pointer and the program counter set for the process and
 *	the current process's image is replaced.
 *
 *----------------------------------------------------------------------
 */
void
Mach_StartUserProc(procPtr, entryPoint)
    Proc_ControlBlock	*procPtr;	/* Process control block for process
					 * to start. */
    Address		entryPoint;	/* Where process is to start
					 * executing. */
{
    register	Mach_State	*statePtr;
    register	Mach_ExcStack	*excStackPtr;

    statePtr = procPtr->machStatePtr;
    excStackPtr = (Mach_ExcStack *)
        (statePtr->kernStackStart + MACH_BARE_STACK_OFFSET - MACH_SHORT_SIZE);
    statePtr->userState.excStackPtr = excStackPtr;
    statePtr->userState.trapRegs[SP] = (int)excStackPtr;
    excStackPtr->statusReg = 0;
    excStackPtr->pc = (int)entryPoint;
    excStackPtr->vor.stackFormat = MACH_SHORT;
    MachUserReturn(procPtr);
    MachRunUserProc();
    /* THIS DOES NOT RETURN */
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_ExecUserProc --
 *
 *	Replace the calling user process's image with a new one.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Stack pointer set for the process.
 *
 *----------------------------------------------------------------------
 */
void
Mach_ExecUserProc(procPtr, userStackPtr, entryPoint)
    Proc_ControlBlock	*procPtr;		/* Process control block for
						 * process to exec. */
    Address		userStackPtr;	/* Stack pointer for when the
						 * user process resumes 
						 * execution. */
    Address		entryPoint;		/* Where the user process is
						 * to resume execution. */
{
    procPtr->machStatePtr->userState.userStackPtr = userStackPtr;
    Mach_StartUserProc(procPtr, entryPoint);
    /* THIS DOES NOT RETURN */
}

/*
 *----------------------------------------------------------------------
 *
 * Mach_FreeState --
 *
 *	Free up the machine state for the given process control block.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Free up the kernel stack.
 *
 *----------------------------------------------------------------------
 */
void
Mach_FreeState(procPtr)
    Proc_ControlBlock	*procPtr;	/* Process control block to free
					 * machine state for. */
{
    if (procPtr->machStatePtr->kernStackStart != (Address)NIL) {
	Vm_FreeKernelStack(procPtr->machStatePtr->kernStackStart);
	procPtr->machStatePtr->kernStackStart = (Address)NIL;
    }
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_CopyState --
 *
 *	Copy the state from the given state structure to the machine
 *	state structure for the destination process control block.  Intended
 *	to be used by the debugger to modify the state.The only fields
 *	that can be modified are the following:
 *
 *	    1) user stack pointer
 *	    2) all trap registers except for the stack pointer because the
 *	       stack pointer in the trap registers is the kernel stack pointer.
 *	    3) the PC, VOR and status register in the exception stack.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Machine state in the destination process control block is overwritten.
 *
 *----------------------------------------------------------------------
 */ 
void
Mach_CopyState(statePtr, destProcPtr)
    Mach_State		*statePtr;	/* Pointer to state to copy from. */
    Proc_ControlBlock	*destProcPtr;	/* Process control block to copy
					 * state to. */
{
    register	Mach_State	*destStatePtr;

    destStatePtr = destProcPtr->machStatePtr;
    destStatePtr->userState.userStackPtr =
				statePtr->userState.userStackPtr;
    bcopy((Address)statePtr->userState.trapRegs,
	      (Address)destStatePtr->userState.trapRegs,
	      sizeof(int) * (MACH_NUM_GPRS - 1));
#ifdef sun3
    bcopy((Address)statePtr->userState.trapFpRegs,
	      (Address)destStatePtr->userState.trapFpRegs,
	      sizeof(statePtr->userState.trapFpRegs));
    bcopy((Address)statePtr->userState.trapFpCtrlRegs,
	      (Address)destStatePtr->userState.trapFpCtrlRegs,
	      sizeof(statePtr->userState.trapFpCtrlRegs));
    bcopy((Address) &statePtr->userState.trapFpuState,
	      (Address) &destStatePtr->userState.trapFpuState,
	      sizeof(statePtr->userState.trapFpuState));
#endif
    destStatePtr->userState.excStackPtr->pc = 
				    statePtr->userState.excStackPtr->pc;
    destStatePtr->userState.excStackPtr->statusReg = 
				statePtr->userState.excStackPtr->statusReg;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_GetDebugState --
 *
 *	Extract the appropriate fields from the machine state struct
 *	and store them into the debug struct.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Debug struct filled in from machine state struct.
 *
 *----------------------------------------------------------------------
 */ 
void
Mach_GetDebugState(procPtr, debugStatePtr)
    Proc_ControlBlock	*procPtr;
    Proc_DebugState	*debugStatePtr;
{
    register	Mach_State	*machStatePtr;

    machStatePtr = procPtr->machStatePtr;
    bcopy((Address)machStatePtr->userState.trapRegs,
	      (Address)debugStatePtr->regState.regs,
	      sizeof(machStatePtr->userState.trapRegs));
    debugStatePtr->regState.regs[SP] = 
			(int)machStatePtr->userState.userStackPtr;
    debugStatePtr->regState.pc = machStatePtr->userState.excStackPtr->pc;
    debugStatePtr->regState.statusReg  =
			machStatePtr->userState.excStackPtr->statusReg;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_SetDebugState --
 *
 *	Extract the appropriate fields from the debug struct
 *	and store them into the machine state struct.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Machine state struct filled in from the debug state struct.
 *
 *----------------------------------------------------------------------
 */ 
void
Mach_SetDebugState(procPtr, debugStatePtr)
    Proc_ControlBlock	*procPtr;
    Proc_DebugState	*debugStatePtr;
{
    register	Mach_State	*machStatePtr;

    machStatePtr = procPtr->machStatePtr;
    bcopy((Address)debugStatePtr->regState.regs,
	      (Address)machStatePtr->userState.trapRegs,
	      sizeof(machStatePtr->userState.trapRegs) - sizeof(int));
    machStatePtr->userState.userStackPtr = 
				(Address)debugStatePtr->regState.regs[SP];
    machStatePtr->userState.excStackPtr->pc = 
				debugStatePtr->regState.pc;
    if (!(debugStatePtr->regState.statusReg & MACH_SR_SUPSTATE)) {
	machStatePtr->userState.excStackPtr->statusReg = 
				debugStatePtr->regState.statusReg;
    }
}



/*
 * ----------------------------------------------------------------------------
 *
 * Mach_GetUserStackPtr --
 *
 *	Return the user stack pointer from the machine state struct for the
 *	given process.
 *
 * Results:
 *	The value of the user stack pointer when the process trapped.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
Address
Mach_GetUserStackPtr(procPtr)
    Proc_ControlBlock	*procPtr;
{
    return(procPtr->machStatePtr->userState.userStackPtr);
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_InitSyscall --
 *
 *	During initialization, this procedure is called once for each
 *	kernel call, in order to set up information used to dispatch
 *	the kernel call.  This procedure must be called once for each
 *	kernel call, in order starting at 0.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Initializes the dispatch tables for the kernel call.
 *
 *----------------------------------------------------------------------
 */
void
Mach_InitSyscall(callNum, numArgs, normalHandler, migratedHandler)
    int callNum;			/* Number of the system call. */
    int numArgs;			/* Number of one-word arguments passed
					 * into call on stack. */
    ReturnStatus (*normalHandler)();	/* Procedure to process kernel call
					 * when process isn't migrated. */
    ReturnStatus (*migratedHandler)();	/* Procedure to process kernel call
					 * for migrated processes. */
{
    machMaxSysCall++;
    if (machMaxSysCall != callNum) {
	printf("Warning: out-of-order kernel call initialization, call %d\n",
	       callNum);
    }
    if (machMaxSysCall >= MAXCALLS) {
	printf("Mach_InitSyscall: too many kernel calls\n",
	       machMaxSysCall);
	machMaxSysCall--;
	return;
    }
    if (numArgs > MAXARGS) {
	printf("Mach_InitSyscall: too many arguments (%d) to kernel call <%d>\n",
		numArgs, callNum);
	numArgs = MAXARGS;
    }

    /*
     * MachArgOffsets and machArgDispatch below are used in MachSyscallTrap
     * to do a very quick dispatch to copy arguments from the user stack
     * to the kernel stack.  machArgOffsets is used to locate the first
     * argument on the user's stack, and machArgDispatch is used to branch
     * into the middle of an unwound loop to do the copy.  See the
     * argument-copying code in MachSyscallTrap for more details.
     */

    machArgOffsets[machMaxSysCall] = 8 + numArgs*4;
    machArgDispatch[machMaxSysCall] = 
		(16-numArgs)*2 + (Address) MachFetchArgs;
    mach_NormalHandlers[machMaxSysCall] = normalHandler;
    mach_MigratedHandlers[machMaxSysCall] = migratedHandler;
}

/*
 * ----------------------------------------------------------------------------
 *
 * Mach_SetHandler --
 *
 *	Put a device driver interrupt handling routine into the autovector.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     The exception vector table is modified.
 *
 * ----------------------------------------------------------------------------
 */

void
Mach_SetHandler(vectorNumber, handler, clientData)
    int vectorNumber;	/* Vector number that the device generates */
    int (*handler)();	/* Interrupt handling procedure */
    ClientData	clientData; /* ClientData for interrupt callback routine. */
{
    int	*vecTablePtr;
    extern int	MachVectoredInterrupt();
    /*
     * Don't let the caller override a vector than can't be generated with
     * an interrupt. Only vectors 24 thru 30 and 64 thru 255 can be 
     * generated.
     */
    if ((vectorNumber < 25) ||
	((vectorNumber > 30) && (vectorNumber < 64)) || 
	(vectorNumber > 255)) {
	panic("Warning: Bad vector number %d\n",vectorNumber);
    } else {
	machInterruptRoutines[vectorNumber] = handler;
	machInterruptArgs[vectorNumber] = clientData;
	vecTablePtr = (int *) MachGetVBR();
	vecTablePtr[vectorNumber] = (int)MachVectoredInterrupt;
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 * MachTrap --
 *
 *      The trap handler routine.  This deals with supervisor mode and 
 *	non-supervisor mode traps differently.  The only allowed supervisor
 *	mode traps are a breakpoint trap to force a context switch and a
 *	bus error in the middle of a cross address space copy. All other
 *	traps go into the debugger.  However, all types of user traps are 
 *	processed here, except for system calls, which don't pass through
 *	this procedure unless special action (like a context switch) is
 *	needed at the end of the call.
 *
 * Results:
 *      MACH_KERN_ERROR if the debugger should be called after this routine 
 *	returns, MACH_USER_ERROR if a copy to/from user space caused an 
 *	unrecoverable bus error, and MACH_OK if everything worked out ok.
 *
 * Side effects:
 *      None.
 *
 * ----------------------------------------------------------------------------
 */
int
MachTrap(trapStack)
    Mach_TrapStack	trapStack;	/* The stack at the time of the trap.*/
{
    register	Proc_ControlBlock	*procPtr;
    ReturnStatus			status;

    procPtr = Proc_GetActualProc();
    /*
     * Process kernel traps.
     */
    if (trapStack.excStack.statusReg & MACH_SR_SUPSTATE) {
	switch (trapStack.trapType) {
	    case MACH_TRACE_TRAP:
		/*
		 * If the trace trap occured on a user trap instruction, then
		 * the trace trap will be taken on the first instruction of 
		 * the trap handler.  When this trace trap occurs,
		 * instead of the saved status register being in user mode and 
		 * having the trace trap bit set, the status register will 
		 * be in kernel mode with no trace trap bit set.
		 * In this case we just ignore the trace trap because it 
		 * will reoccur when the user process continues.
		 */
		if (!(trapStack.excStack.statusReg & MACH_SR_TRACEMODE)) {
		    return(MACH_OK);
		}

		/*
		 * In the normal case enter the debugger with a breakpoint
		 * trap.
		 */
		return(MACH_KERN_ERROR);

	    case MACH_BUS_ERROR:

		if (trapStack.busErrorReg.timeOut) {
		    /*
		     * Allow for refresh memory time just like Unix.
		     */
		    MACH_DELAY(2000);
		}

		/*
		 * Check to see if is a parity error.
		 */

#ifndef sun3
		if (trapStack.busErrorReg.parErrU || trapStack.busErrorReg.parErrL) {
		    panic("Parity error!!!\n");
		    return(MACH_KERN_ERROR);
		}

		if (trapStack.busErrorReg.busErr) {
		    panic("System bus error\n");
		    return(MACH_KERN_ERROR);
		}
#endif

		if (procPtr == (Proc_ControlBlock *)NIL) {
		    panic("MachTrap: Current process is NIL!! Trap PC 0x%x\n",
			   (unsigned) trapStack.excStack.pc);
		}

		if (procPtr->genFlags & PROC_USER) {
		    Boolean	protError;
		    Boolean	copyInProgress = FALSE;

		    /*
		     * A page fault on a user process while executing in
		     * the kernel.  This can happen when information is
		     * being copied back and forth between kernel and
		     * user state (indicated by particular values of the
		     * program counter), after a pointer is made accessible by 
		     * Vm_MakeAccessible (indicated by numMakeAcc > 0) or
		     * after someone did a Mach_Probe() in the kernel and tried
		     * to access a user process.
		     */

		    if ((((Address) trapStack.excStack.pc) >=
		        (Address) Vm_CopyIn)
			    && (((Address) trapStack.excStack.pc)
				< (Address) VmMachCopyEnd)) {
			copyInProgress = TRUE;
		    } else if ((((Address) trapStack.excStack.pc)
				>= (Address) MachFetchArgs2)
			    && (((Address) trapStack.excStack.pc)
				<= (Address) MachFetchArgsEnd2)) {
			copyInProgress = TRUE;
		    } else if ((((Address) trapStack.excStack.pc)
				>= (Address) MachFetchArgs)
			    && (((Address) trapStack.excStack.pc)
				<= (Address) MachFetchArgsEnd)) {
			copyInProgress = TRUE;
		    } else if ((((Address) trapStack.excStack.pc)
				>= (Address) MachProbeStart)
			    && (((Address) trapStack.excStack.pc)
				<= (Address) MachProbeEnd)) {
			return(MACH_USER_ERROR);
		    } else if (procPtr->vmPtr->numMakeAcc == 0) {
			return(MACH_KERN_ERROR);
		    }

		    protError = 
#ifdef sun3
				!trapStack.busErrorReg.pageInvalid;
#else
				trapStack.busErrorReg.resident;
#endif
		    /*
		     * Try to fault in the page.
		     */
		    status = Vm_PageIn(
		      (Address)trapStack.excStack.tail.addrBusErr.faultAddr,
				  protError);
		    if (status != SUCCESS) {
			if (copyInProgress) {
			    return(MACH_USER_ERROR);
			} else {
			    /*
			     * Real kernel error. 
			     */
			    return(MACH_KERN_ERROR);
			}
		    } else {
			return(MACH_OK);
		    }
		} else {
		    /*
		     * Happened to a kernel process.  If the error happen 
		     * in Mach_Probe() return MACH_USER_ERROR to force 
		     * Mach_Probe() to return FAILURE.
		     */
		    if ((((Address) trapStack.excStack.pc)
				>= (Address) MachProbeStart)
			  && (((Address) trapStack.excStack.pc)
				<= (Address) MachProbeEnd)) {
			return(MACH_USER_ERROR);
		    } else { 
			return(MACH_KERN_ERROR);
		    }
		}
	    case MACH_SPURIOUS_INT:
		/*
		 * Ignore this for now because otherwise we can't debug mint
		 */
		if (!dbg_BeingDebugged) {
		    printf("MachTrap: Spurious interrupt\n");
		}
		return(MACH_OK);

	    default:
		return(MACH_KERN_ERROR);
	}
    } 

    /*
     * Process user traps.  
     */

    /* 
     * Take a context switch if one is pending for this process.
     */

    if (procPtr->schedFlags & SCHED_CONTEXT_SWITCH_PENDING) {
	Sched_LockAndSwitch();
    }
    /*
     * Now clear out the trace trap bit out of the status register.  This is
     * a precaution to take care of cases such as when a bus error occurs on 
     * the instruction that we are trying to trace such that the trace trap bit
     * is set but we didn't get a trace trap exception.
     */
    trapStack.excStack.statusReg &= ~MACH_SR_TRACEMODE;

    switch (trapStack.trapType) {
	case MACH_BUS_ERROR: {
	    Boolean	protError;
	    if (trapStack.busErrorReg.timeOut) {
		/*
		 * Allow for refresh memory time just like Unix.
		 */

		MACH_DELAY(2000);
	    }

	    /*
	     * Check for parity error.
	     */

#ifndef sun3
	    if (trapStack.busErrorReg.parErrU || trapStack.busErrorReg.parErrL) {
		panic("Parity error!!!\n");
		return(MACH_KERN_ERROR);
	    }
#endif

	    /*
	     * Take a page fault. It is assumed that if the resident bit
	     * is set in the bus error register then this is a protection
	     * error.
	     */
	protError =
#ifdef sun3
		    !trapStack.busErrorReg.pageInvalid;
#else
		    trapStack.busErrorReg.resident;
#endif
	if (Vm_PageIn((Address)trapStack.excStack.tail.addrBusErr.faultAddr, 
		      protError) != SUCCESS) {
		printf(
		    "MachTrap: Bus error in user proc %X, PC = %x, addr = %x BR Reg %x\n",
			    procPtr->processID, 
			    trapStack.excStack.pc,
			    trapStack.excStack.tail.addrBusErr.faultAddr,
			    *(int *)&trapStack.busErrorReg);
		(void) Sig_Send(SIG_ADDR_FAULT, SIG_ACCESS_VIOL, 
				procPtr->processID, FALSE,
			(Address)trapStack.excStack.tail.addrBusErr.faultAddr);
	    }
	    break;
	}
	case MACH_UNIX_SYSCALL_TRAP:
	case MACH_SYSCALL_TRAP:
	    /*
	     * It used to be that all system calls passed through here, but
	     * the code was optimized to avoid calling either this procedure
	     * or Sys_SysCall in the normal case.  Control only passes through
	     * here if, at the end of a system call, it's discovered that
	     * special action must be taken.  The call has already been
	     * executed by the time things arrive here.  This code does
	     * nothing... the action will all be taken by the call to
	     * MachUserReturn below.
	     */

	    break;
		
	case MACH_BRKPT_TRAP:
	    Proc_Lock(procPtr);
	    if (procPtr->genFlags & PROC_DEBUG_ON_EXEC) {
	    	procPtr->genFlags &= ~PROC_DEBUG_ON_EXEC;
		(void) Sig_SendProc(procPtr, SIG_DEBUG, SIG_NO_CODE,
			(Address)0);
	    } else {
		(void) Sig_SendProc(procPtr, SIG_BREAKPOINT, SIG_NO_CODE,
			(Address)0);
	    }
	    Proc_Unlock(procPtr);
	    break;

	case MACH_SIG_RET_TRAP: {
	    /*
	     * We got a return from signal trap.
	     */
	    ReturnFromSigHandler(procPtr);
	    return(MACH_SIG_RETURN);
	}

	case MACH_ADDRESS_ERROR:
	    (void) Sig_Send(SIG_ADDR_FAULT, SIG_ADDR_ERROR,
			    procPtr->processID, FALSE,
			 (Address)trapStack.excStack.tail.addrBusErr.faultAddr);
	    break;
	case MACH_ILLEGAL_INST:
	    printf("Illegal instruction in %x at %x\n", procPtr->processID,
		    trapStack.excStack.pc);
	    (void) Sig_Send(SIG_ILL_INST, SIG_ILL_INST_CODE,
			    procPtr->processID, FALSE,
			   (Address)trapStack.excStack.pc);
	    break;
	case MACH_ZERO_DIV:
	    (void) Sig_Send(SIG_ARITH_FAULT, SIG_ZERO_DIV,
			    procPtr->processID, FALSE,
			     (Address)trapStack.excStack.pc);
	    break;
	case MACH_CHK_INST:
	    (void) Sig_Send(SIG_ILL_INST, SIG_CHK,
			    procPtr->processID, FALSE,
			     (Address)trapStack.excStack.pc);
	    break;
	case MACH_TRAPV:
	    (void) Sig_Send(SIG_ILL_INST, SIG_TRAPV,
			    procPtr->processID, FALSE,
			     (Address)trapStack.excStack.pc);
	    break;
	case MACH_PRIV_VIOLATION:
	    (void) Sig_Send(SIG_ILL_INST, SIG_PRIV_INST,
			    procPtr->processID, FALSE,
			     (Address)trapStack.excStack.pc);
	    break;
	case MACH_TRACE_TRAP: 
	    /*
	     * Involuntary context switch trace traps have already been taken
	     * care of above.  Here the only time we pay attention to a
	     * trace trap is if the debugger is trying to single step the 
	     * user process.
	     */
	    if (procPtr->genFlags & PROC_SINGLE_STEP_FLAG) {
		procPtr->genFlags &= ~PROC_SINGLE_STEP_FLAG;
		(void) Sig_Send(SIG_TRACE_TRAP, SIG_NO_CODE,
				procPtr->processID, FALSE,
				 (Address)trapStack.excStack.pc);
	    }
	    break;

	case MACH_EMU1010:
	    (void) Sig_Send(SIG_ILL_INST, SIG_EMU1010,
			    procPtr->processID, FALSE,
			     (Address)trapStack.excStack.pc);
	    break;
	case MACH_EMU1111:
	    (void) Sig_Send(SIG_ILL_INST, SIG_EMU1111,
			    procPtr->processID, FALSE,
			     (Address)trapStack.excStack.pc);
	    break;
	case MACH_BAD_TRAP:
	    (void) Sig_Send(SIG_ILL_INST, SIG_BAD_TRAP,
			    procPtr->processID, FALSE,
			     (Address)trapStack.excStack.pc);
	    break;
#ifdef sun3
	case MACH_FP_UNORDERED_COND:
	    (void) Sig_Send(SIG_ARITH_FAULT, SIG_FP_UNORDERED_COND,
			    procPtr->processID, FALSE,
			     (Address)trapStack.excStack.pc);
	case MACH_FP_INEXACT_RESULT:
	    (void) Sig_Send(SIG_ARITH_FAULT, SIG_FP_INEXACT_RESULT,
			    procPtr->processID, FALSE,
			     (Address)trapStack.excStack.pc);
	case MACH_FP_ZERO_DIV:
	    (void) Sig_Send(SIG_ARITH_FAULT, SIG_FP_ZERO_DIV,
			    procPtr->processID, FALSE,
			     (Address)trapStack.excStack.pc);
	case MACH_FP_UNDERFLOW:
	    (void) Sig_Send(SIG_ARITH_FAULT, SIG_FP_UNDERFLOW,
			    procPtr->processID, FALSE,
			     (Address)trapStack.excStack.pc);
	case MACH_FP_OPERAND_ERROR:
	    (void) Sig_Send(SIG_ARITH_FAULT, SIG_FP_OPERAND_ERROR,
			    procPtr->processID, FALSE,
			     (Address)trapStack.excStack.pc);
	case MACH_FP_OVERFLOW:
	    (void) Sig_Send(SIG_ARITH_FAULT, SIG_FP_OVERFLOW,
			    procPtr->processID, FALSE,
			     (Address)trapStack.excStack.pc);
	case MACH_FP_NAN:
	    (void) Sig_Send(SIG_ARITH_FAULT, SIG_FP_NAN,
			    procPtr->processID, FALSE,
			     (Address)trapStack.excStack.pc);
#endif
	default:
	    return(MACH_KERN_ERROR);
    } 

    MachUserReturn(procPtr);
    return(MACH_OK);
}


/*
 * ----------------------------------------------------------------------------
 *
 * MachUserReturn --
 *
 *      Take the proper action to return from a user exception.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Interrupts disabled.
 *
 * ----------------------------------------------------------------------------
 */
void
MachUserReturn(procPtr)
    register	Proc_ControlBlock	*procPtr;
{
    SignalStack			sigStack;
    Address			pc;
    int				restarted=0;

    if (procPtr->unixProgress != PROC_PROGRESS_NOT_UNIX &&
	    procPtr->unixProgress != PROC_PROGRESS_UNIX && debugProcStubs) {
	printf("UnixProgress = %d entering MachUserReturn\n",
		procPtr->unixProgress);
    }

    if (procPtr->Prof_Scale != 0 && procPtr->Prof_PC != 0) {
	Prof_RecordPC(procPtr);
    }

    /* 
     * Take a context switch if one is pending for this process.
     */
    if (procPtr->schedFlags & SCHED_CONTEXT_SWITCH_PENDING) {
	Sched_LockAndSwitch();
    }

    /*
     * Check for signals.  Interrupts are disabled because we have to 
     * make sure that we don't miss a signal.  Interrupts will be reenabled
     * automatically upon the rte.  
     */
    while (TRUE) {
	/*
	 * Disable interrupts.  Note that we don't use the DISABLE_INTR macro
	 * because it increments the nesting depth of interrupts which we don't
	 * want because there is an implicit enable interrupts on rte.
	 */
	Mach_DisableIntr();
	if (!Sig_Pending(procPtr)) {
	    break;
	}
	Mach_EnableIntr();
	sigStack.sigStack.contextPtr = &sigStack.sigContext;
	if (procPtr->unixProgress == PROC_PROGRESS_RESTART ||
		procPtr->unixProgress > 0) {
	    /*
	     * If we received a normal signal, we want to restart
	     * the system call when we leave.
	     * If we received a migrate signal, we will get here on
	     * the new machine.
	     * We must also ensure that the argument registers are the
	     * same as when we came in.
	     */
	    restarted = 1;
	    if (debugProcStubs) {
		printf("Restarting system call with progress %d\n",
			procPtr->unixProgress);
	    }
	    procPtr->unixProgress = PROC_PROGRESS_UNIX;
	}
	if (Sig_Handle(procPtr, &sigStack.sigStack, &pc)) {
	    if (procPtr->unixProgress != PROC_PROGRESS_NOT_UNIX) {
		procPtr->unixProgress = PROC_PROGRESS_UNIX;
	    }
	    SetupSigHandler(procPtr, &sigStack, pc);
	    Mach_DisableIntr();
	    break;
	} else {
	    if (procPtr->unixProgress == PROC_PROGRESS_MIG_RESTART ||
		    procPtr->unixProgress == PROC_PROGRESS_RESTART) {
		restarted = 1;
		if (debugProcStubs) {
		    printf("No signal action, so we restarted call\n");
		}
		procPtr->unixProgress = PROC_PROGRESS_UNIX;
	    } else if (restarted && debugProcStubs) {
		printf("No signal, yet we restarted system call!\n");
	    }
	}
    }

    if ((procPtr->genFlags & PROC_SINGLE_STEP_FLAG) ||
	(procPtr->schedFlags & SCHED_CONTEXT_SWITCH_PENDING)) {
	/*
	 * Set the trace trap bit if we are supposed to single-step this
	 * process or a context switch is pending.  We check for a context
	 * switch pending here even though we just checked above just in
	 * case we got preempted while dealing with signals.
	 */
	procPtr->machStatePtr->userState.excStackPtr->statusReg |= 
							MACH_SR_TRACEMODE;
    }

    /*
     * It is possible for Sig_Handle to mask the migration signal
     * if a process is not in a state where it can be migrated.
     * As soon as we return to user mode, though, we will allow migration.
     */
    Sig_AllowMigration(procPtr);

    if (restarted) {
	if (debugProcStubs) {
	    printf("Moving the PC to restart the system call\n");
	}
	procPtr->machStatePtr->userState.excStackPtr->pc -= 4;
    }

    if (procPtr->unixProgress != PROC_PROGRESS_NOT_UNIX &&
            procPtr->unixProgress != PROC_PROGRESS_UNIX && debugProcStubs) {
        printf("UnixProgress = %d leaving MachUserReturn\n",
                procPtr->unixProgress);
    }

}


/*
 * ----------------------------------------------------------------------------
 *
 * Routines to set up and return from signal handlers.
 *
 * In order to call a handler four things must be done:
 *
 *	1) The current state of the process must be saved so that when
 *	   the handler returns a normal return to user space can occur.
 *	2) The user stack must be set up so that the signal number and the
 *	   the signal code are passed to the handler.
 *	3) Things must be set up so that when the handler returns it returns
 *	   back into the kernel so that state can be cleaned up.
 *	4) The trap stack that was created when the kernel was entered and is
 *	   used to return a process to user space must be modified so that
 *	   the signal handler is called instead of executing the
 *	   normal return.
 *
 * The last one is done by simply changing the program counter where the
 * user process will execute on return to be the address of the signal
 * handler and the user stack pointer to point to the proper place on
 * the user stack.  The first three of these are accomplished by 
 * setting up the user stack properly.  The top entry on the stack is the
 * return address where the handler will start executing upon return.  But 
 * this is just the address of a trap instruction that is stored on the stack
 * below.  Thus when a handler returns it will execute a trap instruction 
 * and drop back into the kernel. 
 */


/*
 * ----------------------------------------------------------------------------
 *
 * SetupSigHandler --
 *
 *      Save machine state on the users stack and set up the exception stack
 *	so that the user will call the signal handler on return. In order to
 * Results:
 *      None.
 *
 * Side effects:
 *      Signal stack set up and saved.
 *
 * ----------------------------------------------------------------------------
 */
static void
SetupSigHandler(procPtr, sigStackPtr, pc)
    register	Proc_ControlBlock	*procPtr;
    register	SignalStack		*sigStackPtr;
    Address				pc;
{
    register	Mach_State	*statePtr;
    Address			usp;
    int				excStackSize;
    Mach_ExcStack		*excStackPtr;
    struct UnixSignalStack	unixSigStack;
    int				unixSignal;

    statePtr = procPtr->machStatePtr;
    excStackSize = Mach_GetExcStackSize(statePtr->userState.excStackPtr);

    if (procPtr->unixProgress != PROC_PROGRESS_NOT_UNIX) {
	usp = (Address)statePtr->userState.userStackPtr -
		sizeof(UnixSignalStack);
	if (Compat_SpriteSignalToUnix(sigStackPtr->sigStack.sigNum, &unixSignal)
		!= SUCCESS) {
	    printf("Signal %d invalid in SetupSigHandler\n",
		    sigStackPtr->sigStack.sigNum);
	    return;
	}
	if (debugProcStubs) {
	    printf("Unix signal %d(%d) to %x\n", unixSignal,
		    sigStackPtr->sigStack.sigNum, procPtr->processID);
	}
	unixSigStack.sigNum = unixSignal;
	unixSigStack.sigCode = sigStackPtr->sigStack.sigCode;
	unixSigStack.sigContextPtr = (struct sigcontext *)(usp + 4*sizeof(int));
	unixSigStack.sigAddr = sigStackPtr->sigStack.sigAddr;
	unixSigStack.sigContext.sc_onstack = 0;
	unixSigStack.sigContext.sc_mask = 0;
	unixSigStack.sigContext.sc_sp = (int) statePtr->userState.userStackPtr;
	unixSigStack.sigContext.sc_pc =
		(int) statePtr->userState.excStackPtr->pc;
	unixSigStack.sigContext.sc_ps =
		(int) statePtr->userState.excStackPtr->statusReg;
	if (debugProcStubs) {
	    printf("sp = %x, pc = %x, ps = %x, len = %d to %x, exPc = %x\n",
		    statePtr->userState.userStackPtr, pc,
		    unixSigStack.sigContext.sc_ps, sizeof(UnixSignalStack),
		    (Address)usp, statePtr->userState.excStackPtr->pc);
	}
	/*
	 * Copy the stack out to user space.
	 */
	if (Vm_CopyOut(sizeof(UnixSignalStack), (Address)&unixSigStack, 
			    (Address)usp) != SUCCESS) {
	    printf("Warning: HandleSig: No room on stack for signal, PID=%x.\n",
		      procPtr->processID);
	    Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
	}
    } else {
	if (procPtr->unixProgress != PROC_PROGRESS_NOT_UNIX &&
		debugProcStubs) {
	    printf("Warning: process %x has unixProgress = %x\n",
		    procPtr->processID, procPtr->unixProgress);
	}
	usp = statePtr->userState.userStackPtr - sizeof(SignalStack);
	sigStackPtr->sigStack.contextPtr =
	    (Sig_Context *)(usp + (unsigned int)(&sigStackPtr->sigContext) -
				  (unsigned int)sigStackPtr);
	/*
	 * We put the instruction TRAP 2 in trapInst, and then set
	 * the return address to point to that instruction.
	 * TRAP 2 does a ReturnFromSigHandler.
	 */
	sigStackPtr->sigContext.machContext.trapInst = 0x4e424e42;
	sigStackPtr->retAddr =
	    usp + (unsigned int)(&sigStackPtr->sigContext.machContext.trapInst) -
		  (unsigned int)sigStackPtr;
	/*
	 * Copy the exception stack onto the signal stack.
	 */
	bcopy((Address)statePtr->userState.excStackPtr,
		  (Address)&(sigStackPtr->sigContext.machContext.excStack),
		  excStackSize);
	/*
	 * Copy the user state onto the signal stack.
	 */
	bcopy((Address)&statePtr->userState,
		  (Address)&(sigStackPtr->sigContext.machContext.userState),
		  sizeof(Mach_UserState));
	/*
	 * Copy the stack out to user space.
	 */
	if (Vm_CopyOut(sizeof(SignalStack), (Address)sigStackPtr, 
			    (Address)usp) != SUCCESS) {
	    printf("Warning: HandleSig: No room on stack for signal, PID=%x.\n",
		      procPtr->processID);
	    Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
	}
    }
    /*
     * We need to make a short stack to allow the process to start executing.
     * The current exception stack is at least as big, maybe bigger than we
     * need.  Since we saved the true exception stack above, we can just
     * overwrite the current stack with a short stack and point the stack
     * pointer at it.
     */
    if (statePtr->userState.excStackPtr !=
			(Mach_ExcStack *)statePtr->userState.trapRegs[SP]) {
	panic("Mach_HandleSig: SP != excStackPtr\n");
    }
    statePtr->userState.userStackPtr = usp;
    excStackPtr = (Mach_ExcStack *) ((Address)statePtr->userState.excStackPtr + 
				     excStackSize - MACH_SHORT_SIZE);
    statePtr->userState.trapRegs[SP] = (int)excStackPtr;
    excStackPtr->statusReg = 0;
    excStackPtr->vor.stackFormat = MACH_SHORT;
    excStackPtr->pc = (int)pc;
}


/*
 * ----------------------------------------------------------------------------
 *
 * ReturnFromSigHandler --
 *
 *      Process a return from a signal handler.
 *	
 * Results:
 *      None.
 *
 * Side effects:
 *      Signal stack struct and size filled in the machine struct for the
 *	given process.
 *
 * ----------------------------------------------------------------------------
 */
static void
ReturnFromSigHandler(procPtr)
    register	Proc_ControlBlock	*procPtr;
{
    register	Mach_State	*statePtr;
    int				curSize;
    int				oldSize;
    SignalStack			sigStack;

    statePtr = procPtr->machStatePtr;
    if (procPtr->unixProgress == PROC_PROGRESS_UNIX) {
	/*
	 * Unix dynamic linking does a trap#2 for no apparent reason.
	 */
	return;
    }
    /*
     * Copy the signal stack in.
     */
    if (Vm_CopyIn(sizeof(Sig_Stack) + sizeof(Sig_Context),
		  (Address) (statePtr->userState.userStackPtr), 
		  (Address) &sigStack.sigStack) != SUCCESS) {
	printf("%s Mach_Code: Stack too small to extract trap info, PID=%x.\n",
		"Warning:", procPtr->processID);
	Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
    }
    sigStack.sigStack.contextPtr = &sigStack.sigContext;
    /*
     * Take the proper action on return from a signal.
     */
    Sig_Return(procPtr, &sigStack.sigStack);
    /*
     * Restore user state.  Be careful not to clobber the stack
     * pointer.
     */
    statePtr->userState.userStackPtr = 
		    sigStack.sigContext.machContext.userState.userStackPtr;
    bcopy((Address)sigStack.sigContext.machContext.userState.trapRegs,
	      (Address)statePtr->userState.trapRegs,
	      sizeof(int) * (MACH_NUM_GPRS - 1));
#ifdef sun3
    bcopy((Address)sigStack.sigContext.machContext.userState.trapFpRegs,
	      (Address)statePtr->userState.trapFpRegs,
	      sizeof(statePtr->userState.trapFpRegs));
    bcopy((Address)sigStack.sigContext.machContext.userState.trapFpCtrlRegs,
	      (Address)statePtr->userState.trapFpCtrlRegs,
	      sizeof(statePtr->userState.trapFpCtrlRegs));
    bcopy((Address) &sigStack.sigContext.machContext.userState.trapFpuState,
	      (Address) &statePtr->userState.trapFpuState,
	      sizeof(statePtr->userState.trapFpuState));
#endif

    /*
     * Verify that the exception stack is OK.
     */
    curSize = Mach_GetExcStackSize(statePtr->userState.excStackPtr);
    oldSize = Mach_GetExcStackSize(&sigStack.sigContext.machContext.excStack);
    if (oldSize == -1) {
	printf("Mach_Code: Bad signal stack type.\n");
	Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
    }
    if (sigStack.sigContext.machContext.excStack.statusReg & MACH_SR_SUPSTATE) {
	printf("Mach_Code: User set kernel bit on signal stack\n");
	Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
    }
    /*
     * Copy the exception stack in.
     */
    bcopy((Address)&sigStack.sigContext.machContext.excStack,
	      (Address)&statePtr->sigExcStack, oldSize);
    statePtr->sigExcStackSize = oldSize;
    /*
     * Set the restored stack pointer to point to where the
     * old exception stack is to be restored to.
     */
    statePtr->userState.trapRegs[SP] += curSize - oldSize;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_GetExcStackSize --
 *
 *      Return the size of the trap stack.  This can vary depending on whether
 *	are on a Sun-3 or a Sun-2.
 *
 * Results:
 *      Trap stack size.
 *
 * Side effects:
 *      None.
 *
 * ----------------------------------------------------------------------------
 */
int
Mach_GetExcStackSize(excStackPtr)
    Mach_ExcStack	*excStackPtr;
{
    switch (excStackPtr->vor.stackFormat) {
	case MACH_SHORT:
	    return(MACH_SHORT_SIZE);
	case MACH_THROWAWAY:
	    return(MACH_THROWAWAY_SIZE);
	case MACH_INST_EXCEPT:
	    return(MACH_INST_EXCEPT_SIZE);
	case MACH_MC68010_BUS_FAULT:
	    return(MACH_MC68010_BUS_FAULT_SIZE);
	case MACH_COPROC_MID_INSTR:
	    return(MACH_COPROC_MID_INSTR_SIZE);
	case MACH_SHORT_BUS_FAULT:
	    return(MACH_SHORT_BUS_FAULT_SIZE);
	case MACH_LONG_BUS_FAULT:
	    return(MACH_LONG_BUS_FAULT_SIZE);
	default:
	    printf("Warning: Mach_GetTrapStackSize: Bad stack format.\n");
	    return(-1);
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_ProcessorState --
 *
 *	Determines what state the processor is in.
 *
 * Results:
 *	MACH_USER	if was at user level
 *	MACH_KERNEL	if was at kernel level
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
/*ARGSUSED*/
Mach_ProcessorStates 
Mach_ProcessorState(processor)
    int processor;	/* processor number for which info is requested */
{
    if (mach_KernelMode) {
	return(MACH_KERNEL);
    } else {
	return(MACH_USER);
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_GetMachineArch --
 *
 *	Return the machine architecture (SYS_SUN2 or SYS_SUN3).
 *
 * Results:
 *	The machine architecture.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
int
Mach_GetMachineArch()
{
#       ifdef sun2
	return SYS_SUN2;
#       endif sun2

#       ifdef sun3
	return SYS_SUN3;
#       endif sun3
}

/*
 * ----------------------------------------------------------------------------
 *
 *  Mach_CheckSpecialHandling--
 *
 *	Forces a processor to check the special handling flag of a process.
 *	This should only be called on a multiprocessor.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
void
Mach_CheckSpecialHandling(pnum)
    int		pnum;		/* Processor number. */
{
    panic("Mach_CheckSpecialHandling called for processor %d\n",pnum);
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_GetNumProcessors() --
 *
 *	Return the number of processors in the system.  NOTE: This should
 *	really be in a machine-independent area of the mach module.  Note
 *	further: if this is used only as a system call, it should return
 *	a ReturnStatus!
 *
 * Results:
 *	The number of processors is returned.  
 *
 * Side effects:
 *	None
 *
 *----------------------------------------------------------------------
 */

int
Mach_GetNumProcessors()
{
	return (mach_NumProcessors);
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_GetBootArgs --
 *
 *	Returns the arguments out of the boot parameter structure. 
 *
 * Results:
 *	Number of elements returned in argv.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Mach_GetBootArgs(argc, bufferSize, argv, buffer)
	int	argc;			/* Number of elements in argv */
	int	bufferSize;		/* Size of buffer */
	char	**argv;			/* Ptr to array of arg pointers */
	char	*buffer;		/* Storage for arguments */
{
    int		i;
    int		offset;

    bcopy(machMonBootParam.strings, buffer, 
	  (bufferSize < 100) ? bufferSize : 100);
    offset = (int) machMonBootParam.strings - (int) buffer;
    for(i = 0; i < argc; i++) {
	if (machMonBootParam.argPtr[i] == (char *) 0 ||
	    machMonBootParam.argPtr[i] == (char *) NIL) {
	    break;
	}
	argv[i] = (char *) (machMonBootParam.argPtr[i] - (char *) offset);
    }
    return i;
}


/*
 *----------------------------------------------------------------------
 *
 * Mach_SigreturnStub --
 *
 *	Procedure to map from Unix sigreturn system call to Sprite.
 *	This is used for returning from longjmps and signals.
 *
 * Results:
 *	Error code is returned upon error.  Otherwise SUCCESS is returned.
 *
 * Side effects:
 *	Changes the stack, pc, etc. to the specified values.
 *
 *----------------------------------------------------------------------
 */
int
Mach_SigreturnStub()
{

    Proc_ControlBlock *procPtr = Proc_GetActualProc();
    Mach_ExcStack *excStackPtr;
    int excStackSize;
    int bufVals[5];
    int *jmpBuf;

    Vm_CopyIn(sizeof(int), procPtr->machStatePtr->userState.userStackPtr,
	    (Address)&jmpBuf);
    if (Vm_CopyIn(5*sizeof(int), (Address)jmpBuf, (Address)bufVals) !=
	    SUCCESS) {
	printf("JmpBuf copy in failure\n");
	return -1;
    }
    if (Sig_SigsetmaskStub(bufVals[1])<0) {
	printf("Sig_SigsetmaskStub error in Sigreturn on %x\n", bufVals[1]);
    }
    if (debugProcStubs) {
	printf("saved usp = %x, SP= %x, exSp = %x\n",
		procPtr->machStatePtr->userState.userStackPtr, 
		procPtr->machStatePtr->userState.trapRegs[SP],
		procPtr->machStatePtr->userState.excStackPtr);
	printf("Mach_SigreturnStub(%x from %x): %x, %x, %x, %x, %x\n", jmpBuf,
		procPtr->machStatePtr->userState.userStackPtr,
		bufVals[0], bufVals[1],
		bufVals[2], bufVals[3], bufVals[4]);
    }
    procPtr->machStatePtr->userState.userStackPtr = (Address)bufVals[2];

    /*
     * We need to make a short stack to allow the process to start executing.
     * The current exception stack is at least as big, maybe bigger than we
     * need.  Since we saved the true exception stack above, we can just
     * overwrite the current stack with a short stack and point the stack
     * pointer at it.
     */
    excStackSize = Mach_GetExcStackSize(procPtr->machStatePtr->
	    userState.excStackPtr);
    excStackPtr = (Mach_ExcStack *) ((Address)procPtr->machStatePtr
	    ->userState.excStackPtr + excStackSize - MACH_SHORT_SIZE);
    procPtr->machStatePtr->userState.trapRegs[SP] = (int)excStackPtr;
    excStackPtr->statusReg = bufVals[4]&0xf;
    if (debugProcStubs) {
	printf("Sigreturn statusReg = %x, pc = %x\n", bufVals[4]&0xf,
		bufVals[3]);
    }
    excStackPtr->vor.stackFormat = MACH_SHORT;
    excStackPtr->pc = (int)bufVals[3];
    if (debugProcStubs) {
	printf("New usp = %x, SP= %x, exSp = %x\n",
		procPtr->machStatePtr->userState.userStackPtr, 
		procPtr->machStatePtr->userState.trapRegs[SP],
		procPtr->machStatePtr->userState.excStackPtr);
    }
    return procPtr->machStatePtr->userState.trapRegs[D0];
}
@


9.18
log
@Fixed lint errors and removed tracing.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.17 91/08/13 22:27:34 shirriff Exp Locker: rab $ SPRITE (Berkeley)";
d1282 1
a1282 1
	    } else if (restarted) {
@


9.17
log
@Fix to signal handler because it was incorrectly using unix signals.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.16 91/08/12 22:15:25 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d763 1
a763 1
		(16-numArgs)*2 + (Address) ((unsigned int)MachFetchArgs);
@


9.16
log
@Fix to restarting system calls.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.15 91/08/09 16:06:57 shirriff Exp $ SPRITE (Berkeley)";
d1268 3
a1270 1
	    procPtr->unixProgress = PROC_PROGRESS_UNIX;
@


9.15
log
@Fixes to previous checkin.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.13 91/07/30 16:41:03 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d1268 1
d1382 1
a1382 1
    if (procPtr->unixProgress == PROC_PROGRESS_UNIX) {
@


9.14
log
@Changed signal handler to restart system call if it is interrupted by a signal that doesn't do anything.,
@
text
@d1214 1
a1214 1
    int				restarted;
a1265 1
			procPtr->machStatePtr->userState.excStackPtr->pc);
@


9.13
log
@Disabled debugging printfs.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.12 91/07/26 17:03:18 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d1214 1
d1260 1
d1262 2
a1263 2
		printf("Restarting signal; old pc = %x\n",
			procPtr->machStatePtr->userState.excStackPtr->pc);
d1265 1
a1265 3
	    procPtr->machStatePtr->userState.excStackPtr->pc -= 4;
	    if (debugProcStubs) {
		printf("Restarting signal; new pc = %x\n",
a1266 2
	    }
	    procPtr->unixProgress = PROC_PROGRESS_UNIX;
d1272 11
d1304 7
@


9.12
log
@Large install for unix compatibility
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.11 91/04/08 12:58:52 shirriff Exp $ SPRITE (Berkeley)";
d69 2
d1259 4
a1262 2
	    printf("Restarting signal; old pc = %x\n",
		    procPtr->machStatePtr->userState.excStackPtr->pc);
d1264 4
a1267 2
	    printf("Restarting signal; new pc = %x\n",
		    procPtr->machStatePtr->userState.excStackPtr->pc);
d1297 1
a1297 1
            procPtr->unixProgress != PROC_PROGRESS_UNIX) {
d1375 4
a1378 2
	printf("Unix signal %d(%d) to %x\n", unixSignal,
		sigStackPtr->sigStack.sigNum, procPtr->processID);
d1390 6
a1395 4
	printf("sp = %x, pc = %x, ps = %x, len = %d to %x, exPc = %x\n",
		statePtr->userState.userStackPtr, pc,
		unixSigStack.sigContext.sc_ps, sizeof(UnixSignalStack),
		(Address)usp, statePtr->userState.excStackPtr->pc);
d1406 2
a1407 1
	if (procPtr->unixProgress != -1) {
d1786 10
a1795 8
    printf("saved usp = %x, SP= %x, exSp = %x\n",
	    procPtr->machStatePtr->userState.userStackPtr, 
	    procPtr->machStatePtr->userState.trapRegs[SP],
	    procPtr->machStatePtr->userState.excStackPtr);
    printf("Mach_SigreturnStub(%x from %x): %x, %x, %x, %x, %x\n", jmpBuf,
	    procPtr->machStatePtr->userState.userStackPtr,
	    bufVals[0], bufVals[1],
	    bufVals[2], bufVals[3], bufVals[4]);
d1811 4
a1814 1
    printf("Sigreturn statusReg = %x, pc = %x\n", bufVals[4]&0xf, bufVals[3]);
d1817 6
a1822 4
    printf("New usp = %x, SP= %x, exSp = %x\n",
	    procPtr->machStatePtr->userState.userStackPtr, 
	    procPtr->machStatePtr->userState.trapRegs[SP],
	    procPtr->machStatePtr->userState.excStackPtr);
@


9.11
log
@Changes for Unix signals and return values.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.10 91/03/30 15:14:06 shirriff Exp $ SPRITE (Berkeley)";
d23 1
d41 4
d81 2
a122 11
/*
 * The format of a Unix signal stack.
 */
typedef struct sigcontext {
    int sc_onstack;
    int sc_mask;
    int sc_sp;
    int sc_pc;
    int sc_ps;
} sigcontext;

d1213 5
d1247 17
d1290 6
d1360 1
a1360 1
    if (procPtr->unixProgress == 0x11beef22) {
d1373 1
a1373 1
	unixSigStack.sigContextPtr = (sigcontext *)(usp + 4*sizeof(int));
d1482 6
@


9.10
log
@Changes for unix compatibility signals.
Fixed a typo.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.9 91/03/29 17:54:05 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d921 5
d1100 2
a1336 2
	printf("This is a Unix signal to %x.  Things should be different.\n",
		procPtr->processID);
d1345 2
d1354 2
a1355 1
	unixSigStack.sigContext.sc_pc = (int) pc;
d1358 1
a1358 1
	printf("sp = %x, pc = %x, ps = %x, len = %d to %x\n",
d1361 1
a1361 1
		(Address)usp);
d1715 1
a1715 1
 *	On the suns, this is used for returning from a longjmp.
d1721 1
a1721 1
 *	Side effects associated with the system call.
d1745 4
a1748 2
    procPtr->machStatePtr->userState.userStackPtr = (Address)bufVals[2];
    procPtr->specialHandling = 1;
d1753 1
d1768 1
d1771 4
@


9.9
log
@I made a bunch of changes for Unix compatibility.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.8 90/12/07 23:40:58 rab Exp Locker: shirriff $ SPRITE (Berkeley)";
d1334 1
a1334 1
	if (Compat_SpriteSigToUnix(sigStackPtr->sigStack.sigNum, &unixSignal)
d1348 3
a1350 2
	unixSigStack.sigContext.sc_ps = 0;
	printf("sp = %x, pc = %x, len = %d to %x\n",
d1352 2
a1353 1
		sizeof(UnixSignalStack), (Address)usp);
d1373 3
a1375 1
	 * Instruction = TRAP 2 ; TRAP 2 (?)
d1724 1
a1724 1
    int bufVals[4];
d1729 1
a1729 1
    if (Vm_CopyIn(4*sizeof(int), (Address)jmpBuf, (Address)bufVals) !=
d1739 4
d1756 1
a1756 1
    excStackPtr->statusReg = 0;
@


9.8
log
@Unix compatiblity
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.7 90/10/03 13:52:47 mgbaker Exp Locker: rab $ SPRITE (Berkeley)";
d117 19
d449 1
a449 1
Mach_SetReturnVal(procPtr, retVal)
d452 1
d455 1
d1053 1
d1323 2
a1326 11
    usp = statePtr->userState.userStackPtr - sizeof(SignalStack);
    sigStackPtr->sigStack.contextPtr =
	(Sig_Context *)(usp + (unsigned int)(&sigStackPtr->sigContext) -
			      (unsigned int)sigStackPtr);
    sigStackPtr->sigContext.machContext.trapInst = 0x4e424e42;
    sigStackPtr->retAddr =
	usp + (unsigned int)(&sigStackPtr->sigContext.machContext.trapInst) -
	      (unsigned int)sigStackPtr;
    /*
     * Copy the exception stack onto the signal stack.
     */
d1328 70
a1397 17
    bcopy((Address)statePtr->userState.excStackPtr,
	      (Address)&(sigStackPtr->sigContext.machContext.excStack),
	      excStackSize);
    /*
     * Copy the user state onto the signal stack.
     */
    bcopy((Address)&statePtr->userState,
	      (Address)&(sigStackPtr->sigContext.machContext.userState),
	      sizeof(Mach_UserState));
    /*
     * Copy the stack out to user space.
     */
    if (Vm_CopyOut(sizeof(SignalStack), (Address)sigStackPtr, 
			(Address)usp) != SUCCESS) {
        printf("Warning: HandleSig: No room on stack for signal, PID=%x.\n",
                  procPtr->processID);
        Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
d1696 57
@


9.7
log
@Prototyping.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.6 90/09/11 19:06:18 mendel Exp Locker: mgbaker $ SPRITE (Berkeley)";
d20 3
a22 2
#include "sprite.h"
#include "assert.h"
d24 16
a39 16
#include "machConst.h"
#include "machMon.h"
#include "machInt.h"
#include "mach.h"
#include "sys.h"
#include "sync.h"
#include "dbg.h"
#include "proc.h"
#include "procMigrate.h"
#include "prof.h"
#include "sched.h"
#include "vm.h"
#include "vmMach.h"
#include "sig.h"
#include "swapBuffer.h"
#include "user/sigMach.h"
d310 2
d1223 1
a1223 1
    
@


9.6
log
@Corrected problem caused by prototypes.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.5 90/07/30 16:17:16 shirriff Exp $ SPRITE (Berkeley)";
d176 3
a178 5
void	SetupSigHandler();
void	ReturnFromSigHandler();
void	MachUserReturn();
void MachProbeStart();
void MachProbeEnd();
d1288 1
a1288 1
void
d1367 1
a1367 1
void
@


9.5
log
@Fixed typo.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.4 90/07/30 11:34:19 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d35 1
d1027 1
a1027 1
				trapStack.excStack.tail.addrBusErr.faultAddr);
d1069 1
a1069 1
			    trapStack.excStack.tail.addrBusErr.faultAddr);
d1074 1
a1074 1
			    trapStack.excStack.pc);
d1079 1
a1079 1
			    trapStack.excStack.pc);
d1084 1
a1084 1
			    trapStack.excStack.pc);
d1089 1
a1089 1
			    trapStack.excStack.pc);
d1094 1
a1094 1
			    trapStack.excStack.pc);
d1107 1
a1107 1
				trapStack.excStack.pc);
d1114 1
a1114 1
			    trapStack.excStack.pc);
d1119 1
a1119 1
			    trapStack.excStack.pc);
d1124 1
a1124 1
			    trapStack.excStack.pc);
d1130 1
a1130 1
			    trapStack.excStack.pc);
d1134 1
a1134 1
			    trapStack.excStack.pc);
d1138 1
a1138 1
			    trapStack.excStack.pc);
d1142 1
a1142 1
			    trapStack.excStack.pc);
d1146 1
a1146 1
			    trapStack.excStack.pc);
d1150 1
a1150 1
			    trapStack.excStack.pc);
d1154 1
a1154 1
			    trapStack.excStack.pc);
@


9.4
log
@Address field to Sig_Send.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.3 90/02/20 15:27:21 jhh Exp Locker: shirriff $ SPRITE (Berkeley)";
d1026 1
a1026 1
				trapStack.execStack.tail.addrBusErr.faultAddr);
d1068 1
a1068 1
			    trapStack.execStack.tail.addrBusErr.faultAddr);
@


9.3
log
@changed to Fmt constant
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.2 89/10/30 20:48:53 rab Exp Locker: jhh $ SPRITE (Berkeley)";
a34 1
#include "vmMachInt.h"
d1025 2
a1026 1
				procPtr->processID, FALSE);
d1048 2
a1049 1
		(void) Sig_SendProc(procPtr, SIG_DEBUG, SIG_NO_CODE);
d1051 2
a1052 1
		(void) Sig_SendProc(procPtr, SIG_BREAKPOINT, SIG_NO_CODE);
d1067 2
a1068 1
			    procPtr->processID, FALSE);
d1072 2
a1073 1
			    procPtr->processID, FALSE);
d1077 2
a1078 1
			    procPtr->processID, FALSE);
d1082 2
a1083 1
			    procPtr->processID, FALSE);
d1087 2
a1088 1
			    procPtr->processID, FALSE);
d1092 2
a1093 1
			    procPtr->processID, FALSE);
d1105 2
a1106 1
				procPtr->processID, FALSE);
d1112 2
a1113 1
			    procPtr->processID, FALSE);
d1117 2
a1118 1
			    procPtr->processID, FALSE);
d1122 2
a1123 1
			    procPtr->processID, FALSE);
d1128 2
a1129 1
			    procPtr->processID, FALSE);
d1132 2
a1133 1
			    procPtr->processID, FALSE);
d1136 2
a1137 1
			    procPtr->processID, FALSE);
d1140 2
a1141 1
			    procPtr->processID, FALSE);
d1144 2
a1145 1
			    procPtr->processID, FALSE);
d1148 2
a1149 1
			    procPtr->processID, FALSE);
d1152 2
a1153 1
		            procPtr->processID, FALSE);
@


9.2
log
@fixed lint stuff.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.1 89/10/12 12:37:57 shirriff Exp Locker: rab $ SPRITE (Berkeley)";
a76 1
 * For compatablity we set this to the old Swap_Buffer constant.
d78 1
a78 1
Fmt_Format mach_Format = SWAP_SUN_TYPE;
@


9.1
log
@Fixed printing of bus error register.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 9.0 89/09/12 14:52:09 douglis Stable Locker: shirriff $ SPRITE (Berkeley)";
d32 1
d236 1
a236 1
    bzero(romVectorPtr->lineBuf, *romVectorPtr->lineSize);
d313 1
a313 1
    bzero(procPtr->machStatePtr, sizeof(*procPtr->machStatePtr));
d357 1
a357 1
    bzero(procPtr->machStatePtr, sizeof(*procPtr->machStatePtr));
d894 4
a897 3
		    if ((((unsigned) trapStack.excStack.pc) >= (unsigned) Vm_CopyIn)
			    && (((unsigned) trapStack.excStack.pc)
				< (unsigned) VmMachCopyEnd)) {
d899 4
a902 4
		    } else if ((((unsigned) trapStack.excStack.pc)
				>= (unsigned) MachFetchArgs)
			    && (((unsigned) trapStack.excStack.pc)
				<= (unsigned) MachFetchArgsEnd)) {
d904 4
a907 4
		    } else if ((((unsigned) trapStack.excStack.pc)
				>= (unsigned) MachProbeStart)
			    && (((unsigned) trapStack.excStack.pc)
				<= (unsigned) MachProbeEnd)) {
d943 4
a946 4
		    if ((((unsigned) trapStack.excStack.pc)
				>= (unsigned) MachProbeStart)
			  && (((unsigned) trapStack.excStack.pc)
				<= (unsigned) MachProbeEnd)) {
@


9.0
log
@Changing version numbers.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 8.16 89/09/11 23:43:35 rab Exp Locker: douglis $ SPRITE (Berkeley)";
d1023 1
a1023 1
			    *(short *)&trapStack.busErrorReg);
@


8.16
log
@Changes to fix floating point migration.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 8.15 89/08/31 12:44:10 douglis Exp Locker: rab $ SPRITE (Berkeley)";
@


8.15
log
@changed panics to warnings during syscall init
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 8.14 89/08/17 17:24:29 jhh Exp Locker: douglis $ SPRITE (Berkeley)";
d21 2
a368 3
#ifdef sun3
    statePtr->switchFpuState[0] = 0;      /* set fpu to null state */
#endif
d399 2
a400 2
	bcopy((Address)fromStatePtr->userState.trapFpuState,
		  (Address)statePtr->userState.trapFpuState,
d578 2
a579 2
    bcopy((Address)statePtr->userState.trapFpuState,
	      (Address)destStatePtr->userState.trapFpuState,
d1389 2
a1390 2
    bcopy((Address)sigStack.sigContext.machContext.userState.trapFpuState,
	      (Address)statePtr->userState.trapFpuState,
@


8.14
log
@now uses Fmt_Convert
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 8.13 89/08/03 23:10:55 rab Exp Locker: jhh $ SPRITE (Berkeley)";
d718 2
a719 1
	panic("out-of-order kernel call initialization");
d722 4
a725 1
	panic("Mach_InitSyscall: too many (%d) kernel calls", machMaxSysCall);
d728 1
a728 1
	panic("Mach_InitSyscall: too many arguments (%d) to kernel call <%d>",
d730 1
@


8.13
log
@Deleted include of "mem.h", which no longer exists.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 8.12 89/08/01 20:40:26 jhh Exp Locker: rab $ SPRITE (Berkeley)";
d73 2
a74 1
 * The byte ordering/alignment type used with Swap_Buffer and I/O control data
d76 1
a76 1
int mach_ByteOrder = SWAP_SUN_TYPE;
@


8.12
log
@something changed somewhere and now we have to include sigMach.h
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 8.11 89/07/26 09:23:14 ouster Exp Locker: jhh $ SPRITE (Berkeley)";
a33 2
#include "mem.h"
#include "machMon.h"
@


8.11
log
@Added more documentation for argument copying during system calls.
No code changes.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 8.10 89/07/20 07:07:00 rab Exp $ SPRITE (Berkeley)";
d37 1
@


8.10
log
@Fixed support for mc68881
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 8.9 89/06/16 13:06:24 rab Exp Locker: rab $ SPRITE (Berkeley)";
d727 10
@


8.9
log
@*** empty log message ***
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 8.8 89/05/24 02:03:59 rab Exp Locker: rab $ SPRITE (Berkeley)";
d310 1
d354 1
d393 11
a472 1

d572 11
d1368 11
@


8.8
log
@Changes to support floating point.
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun3.md/RCS/machCode.c,v 8.7 89/05/23 09:43:28 mendel Exp Locker: rab $ SPRITE (Berkeley)";
d366 1
a366 1
    statePtr->fpuState[0] = 0;      /* set fpu to null state */
d698 1
a698 1
	panic("too many kernel calls");
d701 2
a702 1
	panic("too many arguments to kernel call");
@


8.7
log
@1) Replaced setjmp/longjmp with Mach_Probe. 2) Changed interrupt callback
interface to allow modules to register callbacks. 
@
text
@d17 2
a18 2
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun2.md/RCS/machCode.c,v 8.6 89/03/15 18:04:42 jhh Exp $ SPRITE (Berkeley)";
#endif not lint
d45 1
a45 1
#endif NUM_PROCESSORS
a352 1

d365 4
a1072 1

d1074 23
@


8.6
log
@code to deal with boot parameters
@
text
@d6 8
a13 2
 * Copyright (C) 1985 Regents of the University of California
 * All rights reserved.
d17 1
a17 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun2.md/RCS/machCode.c,v 8.5 89/03/02 17:13:25 rab Exp Locker: jhh $ SPRITE (Berkeley)";
d128 2
d131 1
d177 2
a178 1

d226 1
a226 1
	    machMonBootParam.argPtr[i] -= (char *) offset;
a285 1

a310 1
    procPtr->machStatePtr->setJumpStatePtr = (Mach_SetJumpState *)NIL;
a351 1
	procPtr->machStatePtr->setJumpStatePtr = (Mach_SetJumpState *)NIL;
d724 1
a724 1
Mach_SetHandler(vectorNumber, handler)
d727 1
d730 10
a739 4

    if (vectorNumber < 64 || vectorNumber > 255) {
	printf("%d: ", vectorNumber);
	printf("Warning: Bad vector number\n");
d741 2
d744 1
a744 1
	vecTablePtr[vectorNumber] = (int)handler;
d848 1
a848 1
		     * after someone did a set jump in the kernel and tried
d861 6
a866 3
		    } else if ((procPtr->vmPtr->numMakeAcc == 0)
			&& (procPtr->machStatePtr->setJumpStatePtr
			== (Mach_SetJumpState *) NIL)) {
d887 1
a887 2
			     * Real kernel error.  Take a long jump if
			     * possible.
a888 5
			    if (procPtr->machStatePtr->setJumpStatePtr != 
						(Mach_SetJumpState *) NIL) {
				Mach_LongJump(
				    procPtr->machStatePtr->setJumpStatePtr);
			    }
d896 3
a898 2
		     * Happened to a kernel process.  Take a long jump if 
		     * possible.
d900 7
a906 3
		    if (procPtr->machStatePtr->setJumpStatePtr !=
						(Mach_SetJumpState *) NIL) {
			Mach_LongJump(procPtr->machStatePtr->setJumpStatePtr);
a907 1
		    return(MACH_KERN_ERROR);
a1414 25
}


/*
 * ----------------------------------------------------------------------------
 *
 * Mach_UnsetJump --
 *
 *	Clear out the pointer to the saved state from a set jump.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	setJumpStatePtr field of proc table for current process is nil'd out.
 *
 * ----------------------------------------------------------------------------
 */
void
Mach_UnsetJump()
{
    Proc_ControlBlock	*procPtr;

    procPtr = Proc_GetCurrentProc();
    procPtr->machStatePtr->setJumpStatePtr = (Mach_SetJumpState *) NIL;
@


8.5
log
@*** empty log message ***
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun2.md/RCS/machCode.c,v 8.4 89/02/06 09:02:23 brent Exp Locker: rab $ SPRITE (Berkeley)";
d16 1
d163 2
d192 1
d208 17
d276 1
d1501 40
@


8.4
log
@Changed malloc to Vm_RawAlloc, because procPtr->machState is never freed.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun2.md/RCS/machCode.c,v 8.3 89/01/13 09:37:57 douglis Exp Locker: brent $ SPRITE (Berkeley)";
d89 1
a89 1
    					 * stack when startFunc is called. */
d1063 5
@


8.3
log
@added Mach_GetNumProcessors procedure.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun2.md/RCS/machCode.c,v 8.2 88/12/04 14:03:19 ouster Exp Locker: douglis $ SPRITE (Berkeley)";
d278 1
a278 1
    procPtr->machStatePtr = (struct Mach_State *)malloc(sizeof(Mach_State));
d321 1
a321 1
	procPtr->machStatePtr = (Mach_State *)malloc(sizeof(Mach_State));
@


8.2
log
@Don't include byte.h anymore:  not needed.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun2.md/RCS/machCode.c,v 8.1 88/11/18 15:26:59 jhh Exp $ SPRITE (Berkeley)";
d1447 26
@


8.1
log
@changed CallTrapHandler macro so it uses specialHandling field of pcb,
rather than sched_DoContextSwitch
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun2.md/RCS/machCode.c,v 8.0 88/11/11 18:04:45 douglis Stable Locker: jhh $ SPRITE (Berkeley)";
a28 1
#include "byte.h"
@


8.0
log
@Changing version numbers.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun2.md/RCS/machCode.c,v 6.8 88/11/07 14:36:28 mlgray Exp Locker: douglis $ SPRITE (Berkeley)";
d60 1
a60 1
#ifdef SUN3
d63 1
a63 1
#ifdef SUN2
d156 2
d219 1
a219 1
#ifdef SUN3
d229 2
a230 2
#endif SUN3
#ifndef SUN3
d249 2
d783 1
a783 1
#ifndef SUN3
d831 1
a831 1
#ifdef SUN3
d919 1
a919 1
#ifndef SUN3
d932 1
a932 1
#ifdef SUN3
d1418 1
a1418 1
#       ifdef SUN2
d1420 1
a1420 1
#       endif SUN2
d1422 1
a1422 1
#       ifdef SUN3
d1424 1
a1424 1
#       endif SUN3
@


6.8
log
@More converting to new C library.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun2.md/RCS/machCode.c,v 6.7 88/11/07 14:14:13 mlgray Exp Locker: mlgray $ SPRITE (Berkeley)";
@


6.7
log
@Converting to new C library.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun2.md/RCS/machCode.c,v 6.6 88/10/28 14:35:27 mendel Exp Locker: mlgray $ SPRITE (Berkeley)";
d275 1
a275 1
    procPtr->machStatePtr = (struct Mach_State *)Mem_Alloc(sizeof(Mach_State));
d318 1
a318 1
	procPtr->machStatePtr = (Mach_State *)Mem_Alloc(sizeof(Mach_State));
@


6.6
log
@Added routine Mach_CheckSpecialHandling.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/kernel/mach/sun2.md/RCS/machCode.c,v 6.5 88/10/17 16:42:28 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d353 3
a355 3
	Byte_Copy(sizeof(statePtr->userState.trapRegs),
		  (Address)fromStatePtr->userState.trapRegs,
		  (Address)statePtr->userState.trapRegs);
d522 3
a524 3
    Byte_Copy(sizeof(int) * (MACH_NUM_GPRS - 1),
	      (Address)statePtr->userState.trapRegs,
	      (Address)destStatePtr->userState.trapRegs);
d556 3
a558 3
    Byte_Copy(sizeof(machStatePtr->userState.trapRegs),
	      (Address)machStatePtr->userState.trapRegs,
	      (Address)debugStatePtr->regState.regs);
d591 3
a593 3
    Byte_Copy(sizeof(machStatePtr->userState.trapRegs) - sizeof(int),
	      (Address)debugStatePtr->regState.regs,
	      (Address)machStatePtr->userState.trapRegs);
d660 1
a660 1
	Sys_Panic(SYS_FATAL, "out-of-order kernel call initialization");
d663 1
a663 1
	Sys_Panic(SYS_FATAL, "too many kernel calls");
d666 1
a666 1
	Sys_Panic(SYS_FATAL, "too many arguments to kernel call");
d699 2
a700 2
	Sys_Printf("%d: ", vectorNumber);
	Sys_Panic(SYS_WARNING, "Bad vector number\n");
d781 1
a781 1
		    Sys_Panic(SYS_FATAL, "Parity error!!!\n");
d786 1
a786 1
		    Sys_Panic(SYS_FATAL, "System bus error\n");
d792 1
a792 2
		    Sys_Panic(SYS_FATAL, 
			   "MachTrap: Current process is NIL!! Trap PC 0x%x\n",
d872 1
a872 1
		    Sys_Printf("MachTrap: Spurious interrupt\n");
d917 1
a917 1
		Sys_Panic(SYS_FATAL, "Parity error!!!\n");
d935 1
a935 1
		Sys_Printf(
d1183 3
a1185 2
    Byte_Copy(excStackSize, (Address)statePtr->userState.excStackPtr,
	      (Address)&(sigStackPtr->sigContext.machContext.excStack));
d1189 3
a1191 2
    Byte_Copy(sizeof(Mach_UserState), (Address)&statePtr->userState,
	      (Address)&(sigStackPtr->sigContext.machContext.userState));
d1197 1
a1197 2
        Sys_Panic(SYS_WARNING,
                  "HandleSig: No room on stack for signal, PID=%x.\n",
d1210 1
a1210 1
	Sys_Panic(SYS_FATAL, "Mach_HandleSig: SP != excStackPtr\n");
d1254 2
a1255 3
	Sys_Panic(SYS_WARNING,
	  "Mach_Code: Stack too small to extract trap info, PID=%x.\n",
	  procPtr->processID);
d1269 3
a1271 3
    Byte_Copy(sizeof(int) * (MACH_NUM_GPRS - 1),
	      (Address)sigStack.sigContext.machContext.userState.trapRegs,
	      (Address)statePtr->userState.trapRegs);
d1279 1
a1279 1
	Sys_Printf("Mach_Code: Bad signal stack type.\n");
d1283 1
a1283 1
	Sys_Printf("Mach_Code: User set kernel bit on signal stack\n");
d1289 2
a1290 2
    Byte_Copy(oldSize, (Address)&sigStack.sigContext.machContext.excStack,
	      (Address)&statePtr->sigExcStack);
d1336 1
a1336 1
	    Sys_Panic(SYS_WARNING, "Mach_GetTrapStackSize: Bad stack format.\n");
@


6.5
log
@Print PC of trap when current process is nill.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 6.4 88/09/13 16:50:40 brent Exp $ SPRITE (Berkeley)";
d1422 23
@


6.4
log
@Added mach_ByteOrder
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 6.3 88/08/27 19:33:25 nelson Exp $ SPRITE (Berkeley)";
d793 2
a794 1
			      "MachTrap: Current process is NIL!!\n");
@


6.3
log
@Fixed lint errors.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 6.2 88/08/25 12:21:48 nelson Exp $ SPRITE (Berkeley)";
d30 1
d66 5
@


6.2
log
@Changed the user state around so that the debugger can get at appropriate
info.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 6.1 88/08/24 17:52:18 nelson Exp $ SPRITE (Berkeley)";
d29 1
d517 2
a518 2
	      statePtr->userState.trapRegs,
	      destStatePtr->userState.trapRegs);
@


6.1
log
@Changed to handle rename of user state register stuff.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 5.21 88/07/26 11:02:14 douglis Exp $ SPRITE (Berkeley)";
d344 5
a348 5
	statePtr->userState.regState.userStackPtr =
		fromStatePtr->userState.regState.userStackPtr;
	Byte_Copy(sizeof(statePtr->userState.regState.trapRegs),
		  (Address)fromStatePtr->userState.regState.trapRegs,
		  (Address)statePtr->userState.regState.trapRegs);
d379 1
a379 1
    procPtr->machStatePtr->userState.regState.trapRegs[D0] = retVal;
d413 1
a413 1
    statePtr->userState.regState.trapRegs[SP] = (int)excStackPtr;
d449 1
a449 1
    procPtr->machStatePtr->userState.regState.userStackPtr = userStackPtr;
d513 2
a514 2
    destStatePtr->userState.regState.userStackPtr =
				statePtr->userState.regState.userStackPtr;
d516 2
a517 2
	      statePtr->userState.regState.trapRegs,
	      destStatePtr->userState.regState.trapRegs);
d549 8
a556 6
    Byte_Copy(sizeof(machStatePtr->userState.regState.trapRegs),
	      (Address)machStatePtr->userState.regState.trapRegs,
	      (Address)debugStatePtr->genRegs);
    debugStatePtr->genRegs[SP] = (int)machStatePtr->userState.regState.userStackPtr;
    debugStatePtr->progCounter = machStatePtr->userState.excStackPtr->pc;
    debugStatePtr->statusReg   = machStatePtr->userState.excStackPtr->statusReg;
d584 11
a594 6
    Byte_Copy(sizeof(machStatePtr->userState.regState.trapRegs) - sizeof(int),
	      (Address)debugStatePtr->genRegs,
	      (Address)machStatePtr->userState.regState.trapRegs);
    machStatePtr->userState.regState.userStackPtr = (Address)debugStatePtr->genRegs[SP];
    machStatePtr->userState.excStackPtr->pc = debugStatePtr->progCounter;
    machStatePtr->userState.excStackPtr->statusReg = debugStatePtr->statusReg;
d619 1
a619 1
    return(procPtr->machStatePtr->userState.regState.userStackPtr);
d1164 1
a1164 1
    usp = statePtr->userState.regState.userStackPtr - sizeof(SignalStack);
d1201 1
a1201 1
			(Mach_ExcStack *)statePtr->userState.regState.trapRegs[SP]) {
d1204 1
a1204 1
    statePtr->userState.regState.userStackPtr = usp;
d1207 1
a1207 1
    statePtr->userState.regState.trapRegs[SP] = (int)excStackPtr;
d1244 1
a1244 1
		  (Address) (statePtr->userState.regState.userStackPtr), 
d1260 2
a1261 2
    statePtr->userState.regState.userStackPtr = 
		    sigStack.sigContext.machContext.userState.regState.userStackPtr;
d1263 2
a1264 2
	      (Address)sigStack.sigContext.machContext.userState.regState.trapRegs,
	      (Address)statePtr->userState.regState.trapRegs);
d1289 1
a1289 1
    statePtr->userState.regState.trapRegs[SP] += curSize - oldSize;
@


6.0
log
@Changing version numbers.
@
text
@d30 2
d39 2
a46 2
int mach_NumProcessors = NUM_PROCESSORS;

d344 5
a348 5
	statePtr->userState.userStackPtr =
		fromStatePtr->userState.userStackPtr;
	Byte_Copy(sizeof(statePtr->userState.trapRegs),
		  (Address)fromStatePtr->userState.trapRegs,
		  (Address)statePtr->userState.trapRegs);
d379 1
a379 1
    procPtr->machStatePtr->userState.trapRegs[D0] = retVal;
d413 1
a413 1
    statePtr->userState.trapRegs[SP] = (int)excStackPtr;
d449 1
a449 1
    procPtr->machStatePtr->userState.userStackPtr = userStackPtr;
d513 2
a514 2
    destStatePtr->userState.userStackPtr =
				statePtr->userState.userStackPtr;
d516 2
a517 2
	      statePtr->userState.trapRegs,
	      destStatePtr->userState.trapRegs);
d549 2
a550 2
    Byte_Copy(sizeof(machStatePtr->userState.trapRegs),
	      (Address)machStatePtr->userState.trapRegs,
d552 1
a552 1
    debugStatePtr->genRegs[SP] = (int)machStatePtr->userState.userStackPtr;
d582 1
a582 1
    Byte_Copy(sizeof(machStatePtr->userState.trapRegs) - sizeof(int),
d584 2
a585 2
	      (Address)machStatePtr->userState.trapRegs);
    machStatePtr->userState.userStackPtr = (Address)debugStatePtr->genRegs[SP];
d612 1
a612 1
    return(procPtr->machStatePtr->userState.userStackPtr);
d1157 1
a1157 1
    usp = statePtr->userState.userStackPtr - sizeof(SignalStack);
d1194 1
a1194 1
			(Mach_ExcStack *)statePtr->userState.trapRegs[SP]) {
d1197 1
a1197 1
    statePtr->userState.userStackPtr = usp;
d1200 1
a1200 1
    statePtr->userState.trapRegs[SP] = (int)excStackPtr;
d1237 1
a1237 1
		  (Address) (statePtr->userState.userStackPtr), 
d1253 2
a1254 2
    statePtr->userState.userStackPtr = 
		    sigStack.sigContext.machContext.userState.userStackPtr;
d1256 2
a1257 2
	      (Address)sigStack.sigContext.machContext.userState.trapRegs,
	      (Address)statePtr->userState.trapRegs);
d1282 1
a1282 1
    statePtr->userState.trapRegs[SP] += curSize - oldSize;
@


5.21
log
@call Sig_AllowMigration from MachUserReturn since Sig_Handle may
have temporarily masked migration.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 5.20.2.1 88/07/26 10:30:53 douglis Exp $ SPRITE (Berkeley)";
@


5.20
log
@Added the call to retrieve the user stack pointer out of the mach state
struct.  This required saving the user's stack pointer even on system
call traps.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 5.18 88/07/07 15:25:47 nelson Exp $ SPRITE (Berkeley)";
d416 1
d1075 1
a1075 1

d1087 8
@


5.20.2.1
log
@calls Sig_AllowMigration from MachUserReturn.  
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 5.20 88/07/17 19:37:45 nelson Exp $ SPRITE (Berkeley)";
a415 1

d1074 1
a1074 1
    
a1085 8

    /*
     * It is possible for Sig_Handle to mask the migration signal
     * if a process is not in a state where it can be migrated.
     * As soon as we return to user mode, though, we will allow migration.
     */
    Sig_AllowMigration(procPtr);

@


5.20.1.1
log
@interim state for process migration testing.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 5.20 88/07/17 19:37:45 nelson Exp $ SPRITE (Berkeley)";
a415 7

    /*
     * The first time a process runs, it holds the SIG_MIGRATE_TRAP signal.
     * After that point the signal must be handled.
     */
    Sig_AllowMigration(procPtr);

d1074 1
a1074 1
    
@


5.19
log
@Added the machine type string.
@
text
@d587 25
@


5.18
log
@Fixed lint errors.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 5.17 88/07/07 15:14:41 nelson Exp $ SPRITE (Berkeley)";
d50 12
@


5.17
log
@Changed around signal interface a little bit.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 5.16 88/07/07 11:14:17 douglis Exp $ SPRITE (Berkeley)";
a166 1
    KernelStack	stack;
a530 1
    int				i;
a563 1
    int				i;
d615 2
a616 1
    machArgDispatch[machMaxSysCall] = (16-numArgs)*2 + (Address) MachFetchArgs;
@


5.16
log
@separated starting address from user/kernel distinction for process
startup, in order to allow the same routines to be used for fork
and migration
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 5.15 88/06/25 20:01:56 ouster Exp $ SPRITE (Berkeley)";
d83 1
d1032 1
d1112 4
a1115 1
    sigStackPtr->sigStack.trapInst = 0x4e424e42;
d1117 2
a1118 1
	    usp + ((int)(&sigStackPtr->sigStack.trapInst) - (int)sigStackPtr);
d1124 1
a1124 1
	      (Address)&(sigStackPtr->sigStack.excStack));
d1129 1
a1129 1
	      (Address)&(sigStackPtr->sigStack.userState));
d1190 1
a1190 1
    if (Vm_CopyIn(sizeof(Sig_Stack),
d1198 1
d1208 1
a1208 1
			sigStack.sigStack.userState.userStackPtr;
d1210 1
a1210 1
	      (Address)sigStack.sigStack.userState.trapRegs,
d1217 1
a1217 1
    oldSize = Mach_GetExcStackSize(&sigStack.sigStack.excStack);
d1222 1
a1222 1
    if (sigStack.sigStack.excStack.statusReg & MACH_SR_SUPSTATE) {
d1229 1
a1229 1
    Byte_Copy(oldSize, (Address)&sigStack.sigStack.excStack,
@


5.15
log
@Don't pass arg to Proc_GetActualProc.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 5.14 88/06/17 15:53:36 nelson Exp $ SPRITE (Berkeley)";
d280 1
a280 1
Mach_SetupNewState(procPtr, parStatePtr, startFunc, startPC)
d283 1
a283 1
    Mach_State		*parStatePtr;	/* State of parent on fork or from
d289 1
a289 1
					 * is taken from *parStatePtr's 
d291 1
d302 1
a302 1
    /*
d326 2
a327 1
     * parent and kernel processes start executing at startPC.
d329 3
a331 2
    if (startPC == (Address)NIL) {
	statePtr->userState.userStackPtr = parStatePtr->userState.userStackPtr;
d333 1
a333 1
		  (Address)parStatePtr->userState.trapRegs,
d335 3
a337 1
	stackPtr->startPC = (Address)parStatePtr->userState.excStackPtr->pc;
@


5.14
log
@Changed interface to stack allocation.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 5.13 88/05/05 17:55:10 nelson Exp $ SPRITE (Berkeley)";
d681 1
a681 1
    procPtr = Proc_GetActualProc(0);
@


5.13
log
@Handles move of functionality from sys to mach.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: machCode.c,v 5.12 88/05/04 16:40:13 nelson Exp $ SPRITE (Berkeley)";
d304 1
a304 1
    statePtr->kernStackStart = Vm_GetKernelStack();
d1323 27
@


5.12
log
@Comments.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: excCode.c,v 5.10 88/04/13 11:25:21 ouster Exp $ SPRITE (Berkeley)";
d28 1
a28 1
#include "sunMon.h"
d31 28
d226 5
d256 1
d297 1
d681 1
a681 1
    procPtr = Proc_GetActualProc(Sys_GetProcessorNumber());
d763 2
a764 2
			&& (procPtr->setJumpStatePtr
			== (Sys_SetJumpState *) NIL)) {
d788 4
a791 3
			    if (procPtr->setJumpStatePtr != 
						(Sys_SetJumpState *) NIL) {
				Sys_LongJump(procPtr->setJumpStatePtr);
d803 3
a805 2
		    if (procPtr->setJumpStatePtr != (Sys_SetJumpState *) NIL) {
			Sys_LongJump(procPtr->setJumpStatePtr);
d1268 55
@


5.11
log
@New trap handling code with machine state struct per proc.
@
text
@d35 1
a35 1
					   the stack has been corrupted. */
d39 1
a39 1
					   first starts executing. */
d173 1
a173 1
	extern int Mach_BrkptTrap();
d175 1
a175 1
	*vecTablePtr = (int)Mach_BrkptTrap;
d238 1
a238 1
 *	None.
d249 2
a250 3
    Mach_State		*parStatePtr;	/* State of parent on fork or from other
					 * machine on migration to copy to
					 * new state. */
d253 1
a253 1
    Address		startPC;	/* Address pass as argument to 
d290 1
a290 1
     * parent and kernel processes start executing at clientData.
d380 1
a380 1
 *	Stack pointer and set for the process.
d952 1
a952 1
 *      Code to return to the trap handler.
d1015 1
a1015 1
 * In to call a handler four things must be done:
d1018 1
a1018 1
 *	   the handler returns the normal return to user space can occur.
d1032 5
a1036 28
 * setting up the user stack properly.  When a handler is called the 
 * user stack looks like the following:
 *
 *     		-----------------------
 *     		| Address of trap inst |<----- New user stack pointer.
 *     		-----------------------
 *     		| Signal number       |
 *     		-----------------------
 *     		| Signal code         |
 *     		-----------------------
 *     		| Trap stack          |
 *     		-----------------------
 *     		| Old hold mask       |
 *     		-----------------------
 *     		| trap instruction    |
 *     		-----------------------
 *     		| Original user stack |<----- Old user stack pointer
 *     		|                     |
 *
 *
 * Thus the top entry on the stack is the return address where the handler
 * will start executing upon return.  But this is just the address of a
 * trap instruction that is stored on the stack below.  Thus when
 * a handler returns it will execute a trap instruction and drop back
 * into the kernel.  Following the return address are the signal number and
 * signal code which are the arguments to the handler.  Following this is
 * the saved state of the process which is the trap stack and the old mask
 * of held signals.
@


5.10
log
@Changes to make system calls much faster.
@
text
@d2 1
a2 1
 * excCode.c --
d4 1
a4 2
 *     Contains actual declarations for some global variables, the 
 *     exception vector initialization routines, and the trap handler.
d11 1
a11 1
static char rcsid[] = "$Header: excCode.c,v 5.9 88/03/30 11:22:02 ouster Exp $ SPRITE (Berkeley)";
d15 3
a17 2
#include "exc.h"
#include "excInt.h"
a19 1
#include "machine.h"
a26 1
#include "sunSR.h"
d31 1
a31 1
 * Declare global variables.
d33 14
d48 8
a55 1
int	exc_Type;
d57 12
a68 2
extern	int ExcGetVBR();
Exc_VectorTable	*exc_VectorTablePtr;
d70 3
d75 2
a76 2
 * in excTrap.s that dispatches kernel calls.  All of this information
 * is shared with excTrap.s;  if you change any of this, be sure to
d83 2
a84 2
int excMaxSysCall;			/* Highest defined system call. */
int excArgOffsets[MAXCALLS];		/* For each system call, tells how much
d88 1
a88 1
Address excArgDispatch[MAXCALLS];	/* For each system call, gives an
d90 1
a90 1
					 * of ExcFetchArgs, to copy the right
d93 1
a93 1
ReturnStatus (*(exc_NormalHandlers[MAXCALLS]))();
d98 1
a98 1
ReturnStatus (*(exc_MigratedHandlers[MAXCALLS]))();
d102 1
a102 1
int excKcallTableOffset;		/* Byte offset of the kcallTable field
d104 11
a114 2
int excStateOffset;			/* Byte offset of the genRegs field
					 * in a Proc_ControlBlock. */
d119 1
a119 1
 * Exc_Init --
a131 1

d133 1
a133 1
Exc_Init()
d138 1
d140 20
a159 4
    vecTablePtr = (int *) ExcGetVBR();
    exc_VectorTablePtr = (Exc_VectorTable *) vecTablePtr;
    protoVecTablePtr = (int *) &exc_ProtoVectorTable;
    for (i = 0; i < EXC_NUM_EXCEPTIONS; i++) {
d172 2
a173 2
    for (i = EXC_NUM_EXCEPTIONS ; i<256 ; i++) {
	extern int Exc_BrkptTrap();
d175 1
a175 1
	*vecTablePtr = (int)Exc_BrkptTrap;
d187 2
a188 2
    ExcSetVBR(mach_KernStart);
    exc_VectorTablePtr = (Exc_VectorTable *) mach_KernStart;
d193 1
a193 1
     * initialized by Exc_InitSysCall below.
d195 4
d200 24
a223 3
    excMaxSysCall = -1;
    excKcallTableOffset = (int) &((Proc_ControlBlock *) 0)->kcallTable;
    excStateOffset = (int) ((Proc_ControlBlock *) 0)->genRegs;
d225 1
d230 1
a230 1
 * Exc_InitSyscall --
d232 312
a556 1

d558 1
a558 1
Exc_InitSyscall(callNum, numArgs, normalHandler, migratedHandler)
d567 2
a568 2
    excMaxSysCall++;
    if (excMaxSysCall != callNum) {
d571 1
a571 1
    if (excMaxSysCall >= MAXCALLS) {
d577 4
a580 4
    excArgOffsets[excMaxSysCall] = 8 + numArgs*4;
    excArgDispatch[excMaxSysCall] = (16-numArgs)*2 + (Address) ExcFetchArgs;
    exc_NormalHandlers[excMaxSysCall] = normalHandler;
    exc_MigratedHandlers[excMaxSysCall] = migratedHandler;
d586 1
a586 1
 * Exc_SetHandler --
d600 1
a600 1
Exc_SetHandler(vectorNumber, handler)
d610 1
a610 1
	vecTablePtr = (int *) ExcGetVBR();
d619 1
a619 1
 * Exc_Trap --
d631 3
a633 3
 *      EXC_KERN_ERROR if the debugger should be called after this routine 
 *	returns, EXC_USER_ERROR if a copy to/from user space caused an 
 *	unrecoverable bus error, and EXC_OK if everything worked out ok.
a639 1

d641 2
a642 2
Exc_Trap(trapStack)
    Exc_TrapStack	trapStack;
a647 1

d651 1
a651 2

    if (trapStack.excStack.statusReg & SUN_SR_SUPSTATE) {
d653 1
a653 1
	    case EXC_TRACE_TRAP:
d664 2
a665 2
		if (!(trapStack.excStack.statusReg & SUN_SR_TRACEMODE)) {
		    return(EXC_OK);
d672 1
a672 1
		return(EXC_KERN_ERROR);
d674 1
a674 1
	    case EXC_BUS_ERROR:
d680 1
a680 1
		    DELAY(2000);
d688 1
a688 2
		if (trapStack.busErrorReg.parErrU ||
		    trapStack.busErrorReg.parErrL) {
d690 1
a690 1
		    return(EXC_KERN_ERROR);
d695 1
a695 1
		    return(EXC_KERN_ERROR);
d699 3
a701 9
		/*
		 * Mousetrap.
		 */
		if (procPtr == (Proc_ControlBlock *) NIL) {
		    Mon_Printf("Exc_Trap: PC = %x, addr = %x BR Reg %x\n",
			    trapStack.excStack.pc,
			    trapStack.excStack.tail.addrBusErr.faultAddr,
			    *(short *) &trapStack.busErrorReg);
		    Sys_Panic(SYS_FATAL, "Exc_Trap: current process is nil.\n");
d719 1
a719 2
		    if ((((unsigned) trapStack.excStack.pc)
				>= (unsigned) Vm_CopyIn)
a722 2
		    } else if (procPtr->vmPtr->vmFlags & VM_COPY_IN_PROGRESS) {
			copyInProgress = TRUE;
d724 1
a724 1
				>= (unsigned) ExcFetchArgs)
d726 1
a726 1
				<= (unsigned) ExcFetchArgsEnd)) {
d731 1
a731 1
			return(EXC_KERN_ERROR);
d748 1
a748 24
			    /*
			     * Info was being copied to/from user space.
			     * Return an error to the copying process.  The
			     * size of the trap stack is put into saved reg
			     * D0 so the trap handler knows how much stack
			     to blow away.
			     */
			    switch (trapStack.excStack.vor.stackFormat) {
				case EXC_MC68010_BUS_FAULT:
				    trapStack.genRegs[D0] = 
				    		EXC_MC68010_BUS_FAULT_SIZE;
				    break;
				case EXC_SHORT_BUS_FAULT:
				    trapStack.genRegs[D0] = 
						EXC_SHORT_BUS_FAULT_SIZE;
				    break;
				case EXC_LONG_BUS_FAULT:
				    trapStack.genRegs[D0] = 
						EXC_LONG_BUS_FAULT_SIZE;
				    break;
				default:
				    Sys_Panic(SYS_FATAL, "Exc_Trap: Bad stack format.\n");
			    }
			    return(EXC_USER_ERROR);
d758 1
a758 1
			    return(EXC_KERN_ERROR);
d761 1
a761 1
			return(EXC_OK);
d771 1
a771 1
		    return(EXC_KERN_ERROR);
d773 1
a773 1
	    case EXC_SPURIOUS_INT:
d778 1
a778 1
		    Sys_Printf("Exc_Trap: Spurious interrupt\n");
d780 1
a780 1
		return(EXC_OK);
d783 1
a783 1
		return(EXC_KERN_ERROR);
d804 1
a804 1
    trapStack.excStack.statusReg &= ~SUN_SR_TRACEMODE;
d807 1
a807 1
	case EXC_BUS_ERROR: {
d814 1
a814 1
		DELAY(2000);
d822 1
a822 2
	    if (trapStack.busErrorReg.parErrU ||
	        trapStack.busErrorReg.parErrL) {
d824 1
a824 1
		return(EXC_KERN_ERROR);
d842 1
a842 1
		    "Exc_Trap: Bus error in user proc %X, PC = %x, addr = %x BR Reg %x\n",
d846 1
a846 1
			    *(short *) &trapStack.busErrorReg);
d852 1
a852 1
	case EXC_SYSCALL_TRAP:
d861 1
a861 1
	     * ExcUserReturn below.
d866 1
a866 1
	case EXC_BRKPT_TRAP:
d877 1
a877 1
	case EXC_SIG_RET_TRAP: {
d879 1
a879 5
	     * We got a return from signal trap.  The old exception stack
	     * that caused the signal in the first place is retrieved from
	     * the user stack.  Then the stack pointer (SP) and two
	     * registers a0 and d0 are set up so that the trap handler
	     * code can restore the old exception stack.
d881 2
a882 33

	    Address		oldStackAddr;
	    Exc_TrapStack	*oldStackPtr;
	    int			curSize;
	    int			oldSize;

	    Sig_Return(procPtr, &trapStack, &oldStackAddr);

	    oldStackPtr = (Exc_TrapStack *) Mem_Alloc(sizeof(Exc_TrapStack));
	    if (Vm_CopyIn(sizeof(Exc_TrapStack), oldStackAddr,
			  (Address) oldStackPtr) != SUCCESS) {
		Sys_Printf("Sig_Return: Bad signal stack.\n");
		Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
	    }

	    curSize = Exc_GetTrapStackSize(&trapStack);
	    oldSize = Exc_GetTrapStackSize(oldStackPtr);
	    if (oldSize == -1) {
		Sys_Printf("Exc_Code: Bad signal stack type.\n");
		Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
	    }
	    /*
	     * Make sure that the user didn't set the supervisor bit in
	     * the status register.
	     */
	    if (trapStack.excStack.statusReg & SUN_SR_SUPSTATE) {
		Sys_Printf("Exc_Code: User set kernel bit on signal stack\n");
		Proc_ExitInt(PROC_TERM_DESTROYED, PROC_BAD_STACK, 0);
	    }
	    trapStack.genRegs[A1] = (int)&trapStack + curSize - oldSize;
	    trapStack.genRegs[D0] = oldSize;
	    trapStack.genRegs[A0] = (int) oldStackPtr;
	    return(EXC_SIG_RETURN);
d885 1
a885 1
	case EXC_ADDRESS_ERROR:
d889 1
a889 1
	case EXC_ILLEGAL_INST:
d893 1
a893 1
	case EXC_ZERO_DIV:
d897 1
a897 1
	case EXC_CHK_INST:
d901 1
a901 1
	case EXC_TRAPV:
d905 1
a905 1
	case EXC_PRIV_VIOLATION:
d909 1
a909 1
	case EXC_TRACE_TRAP: 
d923 1
a923 1
	case EXC_EMU1010:
d927 1
a927 1
	case EXC_EMU1111:
d931 1
a931 1
	case EXC_BAD_TRAP:
d937 1
a937 1
	    return(EXC_KERN_ERROR);
d940 2
a941 1
    return(ExcUserReturn(procPtr, &trapStack));
d948 1
a948 1
 * ExcUserReturn --
d960 2
a961 3

int
ExcUserReturn(procPtr, trapStackPtr)
a962 1
    register	Exc_TrapStack		*trapStackPtr;
d964 2
a965 2
    register	Boolean	gotSig = FALSE;
    int			newPC;
d985 2
a986 2
	Sys_DisableIntr();
	if (!Sig_Pending(procPtr) || gotSig) {
d989 6
a994 2
	Sys_EnableIntr();
	gotSig = Sig_Handle(trapStackPtr, &newPC);
d996 1
a996 1
    
d1005 2
a1006 1
	trapStackPtr->excStack.statusReg |= SUN_SR_TRACEMODE;
d1008 1
d1010 52
a1061 8
    if (gotSig) {
	/*
	 * We need to create a simple stack so that the rte will return
	 * to the user program correctly.  The current stack may be
	 * from an address error and hence too big.  newSP is set so
	 * that it is at the bottom of the current trap stack.
	 */
	int	newSP;
d1063 52
a1114 7
	trapStackPtr->excStack.pc = newPC;
	newSP = (int)trapStackPtr + Exc_GetTrapStackSize(trapStackPtr) -
		EXC_SHORT_STACK;
	trapStackPtr->genRegs[SP] = newSP;
	return(newSP);
    } else {
	return(EXC_OK);
d1116 18
d1140 1
a1140 1
 * ExcSigReturn --
d1142 2
a1143 4
 *      We are returning from a signal handler.  The trap stack has been
 *	restored so all that we have to do is to do normal user return
 *	time processing.
 *
d1145 1
a1145 1
 *      Code to return to the trap handler.
d1148 2
a1149 1
 *      Signal stack freed from proc table.
d1153 8
d1162 1
a1162 5
int
ExcSigReturn(sigStackPtr, trapStack)
    Address		sigStackPtr;
    Exc_TrapStack	trapStack;
{
d1164 1
a1164 1
     * Turn interrupts back on since they were disabled.
d1166 21
a1186 1
    Sys_EnableIntr();
d1188 24
a1211 4
    Mem_Free(sigStackPtr);

    return(ExcUserReturn(Proc_GetActualProc(Sys_GetProcessorNumber()), 
	   &trapStack));
d1218 1
a1218 1
 * Exc_GetTrapStackSize --
a1230 3

#define	BASE_SIZE	(sizeof(Exc_TrapStack) - sizeof(Exc_ExcStack))

d1232 2
a1233 2
Exc_GetTrapStackSize(trapStackPtr)
    Exc_TrapStack	*trapStackPtr;
d1235 15
a1249 15
    switch (trapStackPtr->excStack.vor.stackFormat) {
	case EXC_SHORT:
	    return(BASE_SIZE + EXC_SHORT_SIZE);
	case EXC_THROWAWAY:
	    return(BASE_SIZE + EXC_THROWAWAY_SIZE);
	case EXC_INST_EXCEPT:
	    return(BASE_SIZE + EXC_INST_EXCEPT_SIZE);
	case EXC_MC68010_BUS_FAULT:
	    return(BASE_SIZE + EXC_MC68010_BUS_FAULT_SIZE);
	case EXC_COPROC_MID_INSTR:
	    return(BASE_SIZE + EXC_COPROC_MID_INSTR_SIZE);
	case EXC_SHORT_BUS_FAULT:
	    return(BASE_SIZE + EXC_SHORT_BUS_FAULT_SIZE);
	case EXC_LONG_BUS_FAULT:
	    return(BASE_SIZE + EXC_LONG_BUS_FAULT_SIZE);
d1251 1
a1251 1
	    Sys_Panic(SYS_WARNING, "Exc_GetTrapStackSize: Bad stack format.\n");
@


5.9
log
@Take out debugging statement.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: excCode.c,v 5.8 88/03/30 11:05:42 ouster Exp $ SPRITE (Berkeley)";
d17 1
d26 1
d41 33
d80 2
a81 1
 *     Initialize the exception vector table.
d84 1
a84 1
 *     None.
d87 1
a87 1
 *     The exception vector table is initialized.
d134 8
d145 45
d232 3
a234 1
 *	processed here.
a322 1
		    extern	int Vm_CopyEnd();
d338 1
a338 1
				< (unsigned) Vm_CopyEnd)) {
d342 5
d497 8
a504 1
	     * Perform a system call.
d506 1
a506 5
	     if (Sys_SysCall(&trapStack) != SUCCESS) {
		Sys_Printf("Bad system call\n");
		(void) Sig_Send(SIG_ILL_INST, SIG_BAD_SYS_CALL,
				procPtr->processID, FALSE);
	    }
@


5.8
log
@Performance improvements in Vm_CopyIn/Out:  eliminate extra level
of call.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: excCode.c,v 5.7 88/03/28 13:02:22 douglis Exp $ SPRITE (Berkeley)";
a248 1
			Sys_Printf("Page fault during copy\n");
@


5.7
log
@Changed PROC_SINGLE_STEP to PROC_SINGLE_STEP_FLAG to avoid conflict
with user enumerated type.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: excCode.c,v 5.6 88/02/08 10:38:31 nelson Exp $ SPRITE (Berkeley)";
d231 3
d235 5
a239 4
		     * Is a page fault on a user process while executing in
		     * the kernel.  This can happen on calls to 
		     * Vm_Copy{In,Out} (indicated by the VM_COPY_IN_PROGRESS
		     * flag), after a pointer is made accessible by 
d244 12
a255 3
		    if (!(procPtr->vmPtr->vmFlags & VM_COPY_IN_PROGRESS) &&
			procPtr->vmPtr->numMakeAcc == 0 &&
			procPtr->setJumpStatePtr == (Sys_SetJumpState *) NIL) {
d258 1
d272 1
a272 1
			if (procPtr->vmPtr->vmFlags & VM_COPY_IN_PROGRESS) {
d274 5
a278 4
			     * A Vm_Copy{In,Out} is in progress so return
			     * an error to the copying process.  The size of the
			     * trap stack is put into saved reg D0 so the trap
			     * handler knows how much stack to blow away.
@


5.6
log
@Check for context switch pending when exit trap handler.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: excCode.c,v 5.5 87/12/15 15:28:23 nelson Exp $ SPRITE (Berkeley)";
d482 2
a483 2
	    if (procPtr->genFlags & PROC_SINGLE_STEP) {
		procPtr->genFlags &= ~PROC_SINGLE_STEP;
d560 1
a560 1
    if ((procPtr->genFlags & PROC_SINGLE_STEP) ||
@


5.5
log
@Added a check to see if a set jump had occured before bailing to the kernel
debugger on a page fault in kernel mode.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: excCode.c,v 5.4 87/12/12 16:30:50 nelson Exp $ SPRITE (Berkeley)";
d528 2
a529 2
    Proc_ControlBlock	*procPtr;
    Exc_TrapStack	*trapStackPtr;
d531 2
a532 2
    Boolean	gotSig = FALSE;
    int		newPC;
d534 7
d560 8
a567 1
    if (procPtr->genFlags & PROC_SINGLE_STEP) {
@


5.4
log
@More work on moving rest of machine dependencies here.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: excCode.c,v 5.3 87/12/11 14:19:07 nelson Exp $ SPRITE (Berkeley)";
d235 4
a238 2
		     * flag) or after a pointer is made accessible by 
		     * Vm_MakeAccessible (indicated by numMakeAcc > 0).
d241 2
a242 1
			procPtr->vmPtr->numMakeAcc == 0) {
@


5.3
log
@Changed to use new machine dependent name format.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: excCode.c,v 5.2 87/10/22 15:01:24 nelson Exp $ SPRITE (Berkeley)";
d28 1
d222 4
d234 3
a236 2
		     * Vm_Copy{In,Out} or after a pointer is made accessible
		     * by Vm_MakeAccessible.
d238 4
d248 3
a250 3
			/*
			 * Try to fault in the page.
			 */
@


5.2
log
@Changed use of vmFlags field in proc table to conform to new structure.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: excCode.c,v 5.1 87/08/21 13:17:24 nelson Exp $ SPRITE (Berkeley)";
d91 1
a91 1
     * MACH_KERNEL_START.
d93 2
a94 2
    ExcSetVBR(MACH_KERNEL_START);
    exc_VectorTablePtr = (Exc_VectorTable *) MACH_KERNEL_START;
d225 1
d232 1
d234 1
a234 1
		    if (!trapStack.busErrorReg.pageInvalid)
d236 1
a236 1
		    if (trapStack.busErrorReg.resident)
a237 1
			    {
a238 5
			 * Page is resident, must be a protection error.
			 */
			status = FAILURE;
		    } else {
			/*
d241 3
a243 3
			status = 
			Vm_PageIn(trapStack.excStack.tail.addrBusErr.faultAddr);
		    }
d327 2
a328 1
	case EXC_BUS_ERROR:
d354 1
a354 1

d356 1
a356 1
	    if (!trapStack.busErrorReg.pageInvalid ||
d358 1
a358 1
	    if (trapStack.busErrorReg.resident ||
d360 2
a361 2
	        Vm_PageIn(trapStack.excStack.tail.addrBusErr.faultAddr) != 
								SUCCESS) {
d372 1
a372 1

@


5.1
log
@Fixed bug with handling failed cross-address-space copies on Sun-3s.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: excCode.c,v 5.0 87/08/11 10:50:33 sprite Exp $ SPRITE (Berkeley)";
d249 1
a249 1
			if (procPtr->vmFlags & VM_COPY_IN_PROGRESS) {
@


5.0
log
@First Sprite native copy
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: excCode.c,v 4.6 87/07/09 10:29:13 nelson Exp $ SPRITE (Berkeley)";
d252 3
a254 1
			     * an error to the copying process.
d256 16
d627 1
a627 1
	    return(BASE_SIZE + 8);
d629 1
a629 1
	    return(BASE_SIZE + 8);
d631 1
a631 1
	    return(BASE_SIZE + 12);
d633 1
a633 1
	    return(BASE_SIZE + 58);
d635 1
a635 1
	    return(BASE_SIZE + 20);
d637 1
a637 1
	    return(BASE_SIZE + 32);
d639 1
a639 1
	    return(BASE_SIZE + 92);
@
