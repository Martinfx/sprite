head     9.12;
branch   ;
access   ;
symbols  ds3100:9.11 sun3:9.11 sun4nw:9.10 symm:9.10 spur:9.10 sprited:9.10.1 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.12
date     92.12.13.18.21.30;  author mgbaker;  state Exp;
branches ;
next     9.11;

9.11
date     92.08.10.22.58.59;  author mgbaker;  state Exp;
branches ;
next     9.10;

9.10
date     91.03.15.15.40.57;  author ouster;  state Exp;
branches 9.10.1.1;
next     9.9;

9.9
date     90.10.09.11.59.01;  author jhh;  state Exp;
branches ;
next     9.8;

9.8
date     90.10.02.16.29.10;  author mgbaker;  state Exp;
branches ;
next     9.7;

9.7
date     90.04.03.14.41.38;  author mgbaker;  state Exp;
branches ;
next     9.6;

9.6
date     90.03.29.12.46.05;  author mgbaker;  state Exp;
branches ;
next     9.5;

9.5
date     90.03.22.12.13.34;  author mgbaker;  state Exp;
branches ;
next     9.4;

9.4
date     90.03.22.11.56.11;  author mgbaker;  state Exp;
branches ;
next     9.3;

9.3
date     89.11.26.11.14.15;  author jhh;  state Exp;
branches ;
next     9.2;

9.2
date     89.10.30.11.16.34;  author shirriff;  state Exp;
branches ;
next     9.1;

9.1
date     89.10.03.12.56.15;  author brent;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.18.01;  author douglis;  state Stable;
branches ;
next     8.6;

8.6
date     89.06.08.09.40.23;  author brent;  state Exp;
branches ;
next     8.5;

8.5
date     89.06.05.12.33.30;  author brent;  state Exp;
branches ;
next     8.4;

8.4
date     89.01.05.15.45.34;  author mendel;  state Exp;
branches ;
next     8.3;

8.3
date     88.12.04.15.29.24;  author ouster;  state Exp;
branches ;
next     8.2;

8.2
date     88.11.22.19.35.04;  author jhh;  state Exp;
branches ;
next     8.1;

8.1
date     88.11.16.09.41.40;  author douglis;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.35.21;  author douglis;  state Stable;
branches ;
next     6.4;

6.4
date     88.11.11.17.56.12;  author brent;  state Exp;
branches ;
next     6.3;

6.3
date     88.10.28.19.23.41;  author mlgray;  state Exp;
branches ;
next     6.2;

6.2
date     88.09.06.08.13.55;  author mlgray;  state Exp;
branches ;
next     6.1;

6.1
date     88.08.26.18.26.10;  author mlgray;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.25.01;  author brent;  state Stable;
branches ;
next     5.19;

5.19
date     88.08.05.18.22.44;  author mlgray;  state Exp;
branches ;
next     5.18;

5.18
date     88.08.01.17.11.05;  author mlgray;  state Exp;
branches ;
next     5.17;

5.17
date     88.05.10.14.06.53;  author brent;  state Exp;
branches ;
next     5.16;

5.16
date     88.04.11.08.20.28;  author brent;  state Exp;
branches ;
next     5.15;

5.15
date     88.03.04.14.38.32;  author brent;  state Exp;
branches ;
next     5.14;

5.14
date     87.12.14.09.58.54;  author brent;  state Exp;
branches ;
next     5.13;

5.13
date     87.12.10.15.49.18;  author brent;  state Exp;
branches ;
next     5.12;

5.12
date     87.12.02.13.10.59;  author brent;  state Exp;
branches ;
next     5.11;

5.11
date     87.11.17.15.11.00;  author brent;  state Exp;
branches ;
next     5.10;

5.10
date     87.10.13.10.56.37;  author brent;  state Exp;
branches ;
next     5.9;

5.9
date     87.10.06.11.08.35;  author brent;  state Exp;
branches ;
next     5.8;

5.8
date     87.10.05.15.45.10;  author brent;  state Exp;
branches ;
next     5.7;

5.7
date     87.10.05.10.48.59;  author brent;  state Exp;
branches ;
next     5.6;

5.6
date     87.10.04.15.56.09;  author brent;  state Exp;
branches ;
next     5.5;

5.5
date     87.09.29.16.05.11;  author brent;  state Exp;
branches ;
next     5.4;

5.4
date     87.09.23.15.21.03;  author brent;  state Exp;
branches ;
next     5.3;

5.3
date     87.09.11.09.57.39;  author brent;  state Exp;
branches ;
next     5.2;

5.2
date     87.09.11.09.48.19;  author brent;  state Exp;
branches ;
next     5.1;

5.1
date     87.09.09.10.47.53;  author brent;  state Exp;
branches ;
next     5.0;

5.0
date     87.08.11.10.48.35;  author sprite;  state Exp;
branches ;
next     ;

9.10.1.1
date     91.10.27.22.37.55;  author kupfer;  state Exp;
branches ;
next     ;


desc
@@


9.12
log
@Code for server-driven recovery.
@
text
@/*
 * rpcClient.c --
 *
 *      The client side of the RPC protocol.  The routines here are in
 *      this file because they synchronize with each other using a master
 *      lock.  RpcDoCall is the send-receive-timeout loop and
 *      RpcClientDispatch is the interrupt time routine that gets packets
 *      and hands them up to RpcDoCall.
 *
 * Copyright 1986 Regents of the University of California
 * All rights reserved.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/rpc/rpcClient.c,v 9.11 92/08/10 22:58:59 mgbaker Exp $ SPRITE (Berkeley)";
#endif /* not lint */


#include <sprite.h>
#include <stdio.h>
#include <rpc.h>
#include <rpcInt.h>
#include <rpcClient.h>
#include <rpcServer.h>
#include <rpcTrace.h>
#include <dbg.h>
#include <proc.h>
#include <sys.h>

#include <recov.h>


/*
 * For debugging servers.  We allow client's to retry forever instead
 * of timing out.  This is exported and settable via Fs_Command
 */
Boolean rpc_NoTimeouts = FALSE;

/*
 * A histogram is kept of the elapsed time of each different kind of RPC.
 */
Rpc_Histogram *rpcCallTime[RPC_LAST_COMMAND+1];
Boolean rpcCallTiming = FALSE;

#ifdef DEBUG
#define DEBUGSIZE 1000
#define INC(ctr) { (ctr) = ((ctr) == DEBUGSIZE-1) ? 0 : (ctr)+1; }
typedef struct {
    RpcClientChannel	*chanPtr;
    char		*action;
    int			pNum;
    int			serverID;
    int			chanNum;
    int			state;
} dbgElem;

static dbgElem	dbgArray[DEBUGSIZE];
static int 		dbgCtr;

#define CHAN_TRACE(zchanPtr, serverID, string) \
{ \
	dbgElem *ptr = &dbgArray[dbgCtr]; \
	INC(dbgCtr); \
	ptr->chanPtr = zchanPtr; \
	ptr->action = string; \
	ptr->chanNum = zchanPtr->index; \
	ptr->serverID = serverID; \
	ptr->pNum = Mach_GetProcessorNumber(); \
	ptr->state = zchanPtr->state; \
}

#else
#define CHAN_TRACE(zchanPtr, serverID, string)
#endif

/* Variables to control nack back-off on client. */
int	rpcNackRetryWait;
int	rpcMaxNackWait;
/*
 * This variable determines whether we use client policy of ramping down
 * channels for neg acks.  The default is to use backoff.
 */
Boolean	rpcChannelNegAcks = FALSE;


/*
 *----------------------------------------------------------------------
 *
 * RpcDoCall --
 *
 *	The send-receive-timeout loop on the client for a remote procedure call.
 *
 * Results:
 *	The return code from the remote procedure or an error code
 *	related to the RPC protocol, or SUCCESS.
 *
 * Side effects:
 *	The remote procedure call itself.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
RpcDoCall(serverID, chanPtr, storagePtr, command, srvBootIDPtr, notActivePtr,
	recovTypePtr)
    int serverID;		/* The Sprite host that will execute the
				 * service procedure */
    register RpcClientChannel *chanPtr;	/* The channel for the RPC */
    Rpc_Storage *storagePtr;	/* Pointers to caller's buffers */
    int command;		/* Only used to filter trace records */
    unsigned	int *srvBootIDPtr;	/* Return, boot time stamp of server. */
    int *notActivePtr;		/* Return, RPC_NOT_ACTIVE flag from server.
				 * These last two return parameters are later
				 * passed to the recovery module. */
    unsigned int *recovTypePtr;	/* Wether rpc packet comes from fast booted
				 * server or server doing special recovery. */
{
    register RpcHdr *rpcHdrPtr;	/* Pointer to received message header */
    register RpcConst *constPtr;/* Timeout parameter block */
    register ReturnStatus error;/* General error return status */
    register unsigned int wait;	/* Wait interval for timeouts */
    int numAcks;		/* Count of acks received.  Used to catch the
				 * case where the server process hangs and
				 * the server dispatcher acks us forever */
    register int numTries;	/* Number of times we sent the message while
				 * getting no reply. */
    register unsigned int lastFragMask = 0;	/* Previous state of our
						 * fragment reassembly */
    Boolean	seemsHung = FALSE;	/* Used to control warning msgs */

    /*
     * This code is locked with MASTER_LOCK in order to synchronize
     * with the RpcClientDispatch routine.  Inside the critical
     * section we sleep on the channel's wait condition to which
     * RpcClientDispatch broadcasts when it gets input.  Furthermore,
     * we place a call back procedure in the timer queue that will
     * also notify that condition upon timeout.
     */
    MASTER_LOCK(&chanPtr->mutex);

    /*
     * Send the request off to the server.  We update the server hint from
     * the channel's return message header.  ie. take the last server
     * hint received from the server.
     */

    *srvBootIDPtr = 0;
    rpcCltStat.requests++;
    chanPtr->requestRpcHdr.serverHint =	chanPtr->replyRpcHdr.serverHint;
    chanPtr->state |= CHAN_WAITING;
    error = RpcOutput(serverID, (RpcHdr *) &chanPtr->requestRpcHdr,
		      &chanPtr->request, chanPtr->fragment,
		      (unsigned int) (chanPtr->fragsDelivered),
		      &chanPtr->mutex);
    /*
     * Set up the initial wait interval.  The wait could depend on
     * characteristics of the RPC, or of the other host.
     * For now we just wait longer if the packet will be fragmented.
     */
    constPtr = chanPtr->constPtr;
    if ((storagePtr->requestDataSize + storagePtr->requestParamSize >
	    RPC_MAX_FRAG_SIZE) ||
	(storagePtr->replyDataSize + storagePtr->replyParamSize >
	    RPC_MAX_FRAG_SIZE)) {
	wait = constPtr->fragRetryWait;
    } else {
	wait = constPtr->retryWait;
    }

    /*
     * Loop waiting for input and re-sending if need be.  As well as
     * getting a reply from the server we screen out junk and react to
     * explicit acks.  This times out after a number of times around the
     * loop with no input.
     */
    numTries = 0;
    numAcks = 0;
    do {

	/*
	 * Wait until we get a poke from the timeout routine or there
	 * is input available.  Input may have arrived before we get
	 * here because the channel mutex is released while Rpc_Output
	 * waits for the packet to be sent by the network interface.
	 */
	if (! (chanPtr->state & CHAN_INPUT)) {
	    chanPtr->timeoutItem.routine = Rpc_Timeout;
	    chanPtr->timeoutItem.interval = wait;
	    chanPtr->timeoutItem.clientData = (ClientData)chanPtr;
	    chanPtr->state |= CHAN_TIMEOUT | CHAN_WAITING;
	    CHAN_TRACE(chanPtr, serverID, "about to schedule");
	    Timer_ScheduleRoutine(&chanPtr->timeoutItem, TRUE);
	    do {
		/*
		 * Wait ignoring signals.
		 */
		Sync_MasterWait(&chanPtr->waitCondition,
				&chanPtr->mutex, FALSE);
	    } while (((chanPtr->state & CHAN_INPUT) == 0) &&
		     (chanPtr->state & CHAN_TIMEOUT));
	    CHAN_TRACE(chanPtr, serverID, "woken up");
	}
	if (chanPtr->state & CHAN_INPUT) {
	    /*
	     * Got some input.  The dispatch routine has copied the
	     * packet into the areas refered to by the reply BufferSet.
	     *
	     * NB: We have to completely process this message before we
	     * can accept another message on this channel.  There is no
	     * mechanism to queue messages.
	     */
	    chanPtr->state &= ~CHAN_INPUT;
	    rpcHdrPtr = &chanPtr->replyRpcHdr;
	    *recovTypePtr = 0;
	    if (rpcHdrPtr->flags & RPC_FAST) {
		*recovTypePtr |= RECOV_FAST_BOOT;
	    }
	    if (rpcHdrPtr->flags & RPC_SERVER_RECOV) {
		*recovTypePtr |= RECOV_SERVER_DRIVEN;
	    }
	    /*
	     * Pick off the boot timestamp and active state of the server so
	     * the recovery module can pay attention to traffic.
	     */
	    *notActivePtr = rpcHdrPtr->flags & RPC_NOT_ACTIVE;
	    *srvBootIDPtr = rpcHdrPtr->bootID;
#ifdef TIMESTAMP
	    RPC_TRACE(rpcHdrPtr, RPC_CLIENT_D, "input");
#endif /* TIMESTAMP */
	    if (rpcHdrPtr->ID != chanPtr->requestRpcHdr.ID) {
		/*
		 * Note old message.
		 */
		rpcCltStat.oldInputs++;

	    } else if (rpcHdrPtr->flags & RPC_NACK) {
		rpcCltStat.nacks++;
		/*
		 * Try out different nack-handling policies.  
		 * We can either back off as in an ACK, or try to ramp
		 * down the number of channels.
		 */
		if (serverID != RPC_BROADCAST_SERVER_ID) {
		    numTries = 0;
		    if (!rpcChannelNegAcks) {
			if (wait < rpcNackRetryWait) {
			    wait = rpcNackRetryWait;
			} else {
			    Net_HostPrint(serverID,
			    "Client backing off again from negative ack.\n");
			    wait *= 2;
			    rpcCltStat.reNacks++;
			}
			if (wait > rpcMaxNackWait) {
			    Net_HostPrint(serverID,
			    "Client setting max backoff from negative ack.\n");
			    wait = rpcMaxNackWait;
			    rpcCltStat.maxNacks++;
			}
		    } else {
			/* Return error to cause ramping down of channels. */
			error = RPC_NACK_ERROR; 
		    }
		}
	    } else if (rpcHdrPtr->flags & RPC_REPLY) {
		/*
		 * Our reply, check for an error code and break from the
		 * receive loop.  The command field is overloaded with the
		 * return error code.
		 */
		if (rpcHdrPtr->flags & RPC_ERROR) {
		    error = (ReturnStatus)rpcHdrPtr->command;
		    if (error == 0) {
			rpcCltStat.nullErrors++;
			error = RPC_NULL_ERROR;
		    } else {
			rpcCltStat.errors++;
		    }
		} else {
		    rpcCltStat.replies++;
		}
		/*
		 * Copy back the return buffer size (it's set by ClientDispatch)
		 * to reflect what really came back.
		 */
		storagePtr->replyDataSize = chanPtr->actualDataSize;
		storagePtr->replyParamSize = chanPtr->actualParamSize;
		break;
	    } else if (rpcHdrPtr->flags & RPC_ACK) {
		numAcks++;
		rpcCltStat.acks++;
		if (numAcks <= constPtr->maxAcks) {
		    /*
		     * An ack from the server indicating that a server
		     * process is working on our request.  We increase
		     * our waiting time to decrease the change that we'll
		     * timeout again before receiving the reply.
		     * NOTE: We don't pay attention to acks if we are
		     * broadcasting.  This makes the broadcaster too vulnerable
		     * to errant servers.  In particular, diskless clients
		     * often wedge trying to handle a prefix request, send
		     * the real server a lot of acks, and slow it's boot down.
		     */
		    if (serverID != RPC_BROADCAST_SERVER_ID) {
			numTries = 0;
			wait *= 2;
			if (wait > constPtr->maxAckWait) {
			    wait = constPtr->maxAckWait;
			}
		    }
		} else {
		    char name[100];
		    /*
		     * Too many acks.  It is very likely that the server
		     * process is hung on some lock.  We hang too in
		     * order to facilitate debugging.
		     */
		    rpcCltStat.tooManyAcks++;
		    if (!seemsHung) {
			Net_SpriteIDToName(serverID, 100, name);
			if (name == (char *)NIL) {
			    printf("RpcDoCall: <%s> RPC to host <%d> is hung\n",
				rpcService[command].name, serverID);
			} else {
			    printf("RpcDoCall: <%s> RPC to %s is hung\n",
				rpcService[command].name, name);
			}
			seemsHung = TRUE;
		    }
		    numAcks = 0;
		}
	    } else {
		/*
		 * Unexpected kind of input
		 */
		rpcCltStat.badInput++;
		printf("Warning: Rpc_Call: Unexpected input.\n");
		error = RPC_INTERNAL_ERROR;
	    }
	} else {
	    /*
	     * Have not received a complete message yet.  Update the
	     * server hint and then re-send the request or send a partial
	     * acknowledgment.
	     */
	    chanPtr->requestRpcHdr.serverHint =
		chanPtr->replyRpcHdr.serverHint;
	    rpcCltStat.timeouts++;
	    /*
	     * Back off upon timeout because we may be talking to a slow host
	     */
	    wait *= 2;
	    if (wait > constPtr->maxTimeoutWait) {
		wait = constPtr->maxTimeoutWait;
	    }
	    if ((chanPtr->state & CHAN_FRAGMENTING) == 0) {
		/*
		 * Not receiving fragments.  Check for timeout, and resend
		 * the request.
		 */
		numTries++;
		if (numTries < constPtr->maxTries ||
		    (rpc_NoTimeouts && serverID != RPC_BROADCAST_SERVER_ID)) {
		    rpcCltStat.resends++;
		    chanPtr->requestRpcHdr.flags |= RPC_PLSACK;
		    error = RpcOutput(serverID, 
				      (RpcHdr *) &chanPtr->requestRpcHdr,
				      &chanPtr->request, chanPtr->fragment,
				      (unsigned int) (chanPtr->fragsDelivered),
				      &chanPtr->mutex);
		} else {
		    rpcCltStat.aborts++;
		    error = RPC_TIMEOUT;
		}
	    } else {
		/*
		 * We are getting a fragmented response.  The client dispatcher
		 * has set the fragsReceived field to reflect the state
		 * of fragment reassembly.  We check that and will abort
		 * if we timeout too many times with no new fragments.
		 * Otherwise we return a partial acknowledgment.
		 */
		if (lastFragMask < chanPtr->fragsReceived) {
		    lastFragMask = chanPtr->fragsReceived;
		    numTries = 0;
		} else {
		    numTries++;
		}
		if (numTries >= constPtr->maxTries &&
		    (!rpc_NoTimeouts||(serverID == RPC_BROADCAST_SERVER_ID))) {
		    rpcCltStat.aborts++;
		    error = RPC_TIMEOUT;
		} else {
		    chanPtr->requestRpcHdr.flags = RPC_SERVER |RPC_ACK |
						    RPC_LASTFRAG;
		    chanPtr->requestRpcHdr.fragMask = chanPtr->fragsReceived;
		    rpcCltStat.sentPartial++;
		    error = RpcOutput(serverID, 
				      (RpcHdr *) &chanPtr->requestRpcHdr,
				      &chanPtr->request, chanPtr->fragment,
				      (unsigned int) (chanPtr->fragsDelivered),
				      &chanPtr->mutex);
		}
	    }
	}
    } while (error == SUCCESS);
    chanPtr->state &= ~CHAN_WAITING;
    if (seemsHung) {
	if (error == SUCCESS) {
	    printf("<%s> RPC ok\n", rpcService[command].name);
	} else {
	    printf("<%s> RPC exit 0x%x\n", rpcService[command].name, error);
	}
    }
    MASTER_UNLOCK(&chanPtr->mutex);
    return(error);
}

/*
 *----------------------------------------------------------------------
 *
 * RpcClientDispatch --
 *
 *      Dispatch a message to a client channel.  The channel has buffer
 *      space for the packet header and also specifies the buffer areas
 *      for the RPC return parameters and data.  We notify the owner of
 *      the channel that is has input via the condition variable in the
 *      channel.
 *
 * Sprite Id:
 *	This routine has the side effect of initializing the Sprite ID
 *	of the host from information in the RPC packet header.  This is
 *	for diskless clients of the filesystem that have no other way
 *	to determine their Sprite ID.  The routine RpcValidateClient
 *	on the server side initializes the clientID field for us.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The message is copied into the buffers specified by the channel
 *	and the channel is notified of input.
 *
 *----------------------------------------------------------------------
 */
void
RpcClientDispatch(chanPtr, rpcHdrPtr)
    register RpcClientChannel *chanPtr;	/* The channel the packet is for */
    register RpcHdr *rpcHdrPtr;		/* The Rpc header as it sits in the
					 * network module's buffer.  The data
					 * in the message follows this. */
{
    register int size;	/* The amount of data in the message */
    /*
     * Acquire the channel mutex for multiprocessor synchronization.
     * Deadlock occurs here when doing RPCs to oneself and the client
     * resends and then the server acknowledges.
     */
#if (MACH_MAX_NUM_PROCESSORS == 1) /* uniprocessor implementation */
    if (chanPtr->mutex.value != 0) {
	printf("Warning:  Rpc to myself?\n");
	return;
    } else {
	MASTER_LOCK(&chanPtr->mutex);
    }
#else	/* Multiprocessor implementation. */
    MASTER_LOCK(&chanPtr->mutex);
#endif
    
    /*
     * Discover our own Sprite ID from the packet header.
     */
    if (rpc_SpriteID == 0) {
	rpc_SpriteID = rpcHdrPtr->clientID;
	printf("RPC setting SpriteID to %d.\n", rpc_SpriteID);
    } else if (rpc_SpriteID != rpcHdrPtr->clientID) {
	printf("RpcClientDispatch: clientID changed from (%d) to (%d).\n",
				       rpc_SpriteID, rpcHdrPtr->clientID);
    }

    /*
     * See if this is a close request from the server - the server host is
     * trying to recycle the server process that is bound to this
     * channel.  If the channel is not busy now it implies we have completed
     * the RPC the server is inquiring about.  We return an ack to the
     * server and unbind the server process from us.  During this the
     * channel is marked busy so that while we are returning the ack,
     * another process doesn't come along, allocate the channel, and try
     * to use the same buffers as us.
     */
    if (rpcHdrPtr->flags & RPC_CLOSE) {
	RpcChanClose(chanPtr, rpcHdrPtr);
	goto unlock;
    }

    /*
     * Verify the transaction Id.  Doing this now after checking for
     * close messages means we still ack close requests even if
     * we have already recycled the channel.
     */
    if (rpcHdrPtr->ID != chanPtr->requestRpcHdr.ID) {
	rpcCltStat.badId++;
	goto unlock;
    }

    /*
     * Filter out partial acks.
     */
    if ((rpcHdrPtr->fragMask != 0) && (rpcHdrPtr->flags & RPC_ACK)) {
	if (chanPtr->fragsDelivered != rpcHdrPtr->fragMask) {
	    /*
	     * Because we may get several partial acks, we just update
	     * fragsDelivered so the next resend is smarter.  Eventually
	     * we'll get all the fragments delivered and then these
	     * acks will get passed up to RpcDoCall().
	     */
	    chanPtr->fragsDelivered = rpcHdrPtr->fragMask;
	    rpcCltStat.recvPartial++;
	    goto unlock;
	}
	/*
	 * Apparently we've gotten everything through to the
	 * server.  Our last transmission was a keep-alive
	 * of just the last fragment.  We FALL THROUGH to
	 * pass the server's ack up to the process level, RpcDoCall();
	 */
    }

    /*
     * See if the channel is available for input.  Currently there
     * is no queueing of packets so we drop this packet if the process
     * is still working on the last packet it got.
     */
    if ((chanPtr->state & CHAN_WAITING) == 0) {
	rpcCltStat.chanBusy++;
	goto unlock;
    }
    /*
     * Note for RpcDoCall the actual size of the returned information.
     */
    size = rpcHdrPtr->paramSize + rpcHdrPtr->paramOffset;
    if (chanPtr->actualParamSize < size) {
	chanPtr->actualParamSize = size;
    }
    size = rpcHdrPtr->dataSize + rpcHdrPtr->dataOffset;
    if (chanPtr->actualDataSize < size) {
	chanPtr->actualDataSize = size;
    }

    if (rpcHdrPtr->numFrags != 0) {
	if ((chanPtr->state & CHAN_FRAGMENTING) == 0) {
	    /*
	     * The first fragment of a fragmented reply.
	     */
	    RpcScatter(rpcHdrPtr, &chanPtr->reply);
	    chanPtr->fragsReceived = rpcHdrPtr->fragMask;
	    chanPtr->state |= CHAN_FRAGMENTING;
	    goto unlock;
	} else if (chanPtr->fragsReceived & rpcHdrPtr->fragMask) {
	    /*
	     * Duplicate fragment.
	     */
	    rpcCltStat.dupFrag++;
	    goto unlock;
	} else {
	    /*
	     * More fragments.
	     */
	    RpcScatter(rpcHdrPtr, &chanPtr->reply);
	    chanPtr->fragsReceived |= rpcHdrPtr->fragMask;
	    if (chanPtr->fragsReceived !=
	       rpcCompleteMask[rpcHdrPtr->numFrags]) {
		goto unlock;
	    } else {
		/*
		 * Now the packet is complete.
		 */
		chanPtr->state &= ~CHAN_FRAGMENTING;
	    }
	}
    } else {
	/*
	 * Unfragmented message.
	 * Copy the complete message out of the network's buffers.
	 */
	RpcScatter(rpcHdrPtr, &chanPtr->reply);
    }
	
    /*
     * Remove the channel from the timeout queue and
     * notify the waiting channel that it has input.
     */
    chanPtr->state &= ~CHAN_WAITING;
    chanPtr->state |= CHAN_INPUT;

    if (chanPtr->state & CHAN_TIMEOUT) {
	chanPtr->state &= ~CHAN_TIMEOUT;
	CHAN_TRACE(chanPtr, chanPtr->serverID, "about to deschedule");
	(void)Timer_DescheduleRoutine(&chanPtr->timeoutItem);
    }
    Sync_MasterBroadcast(&chanPtr->waitCondition);

unlock:
#ifdef TIMESTAMP
    RPC_TRACE(rpcHdrPtr, RPC_CLIENT_a, "client");
#endif /* TIMESTAMP */

    MASTER_UNLOCK(&chanPtr->mutex);
}

/*
 *----------------------------------------------------------------------
 *
 * Rpc_Timeout --
 *
 *	Called when a channel times out.  This notifies the waiting condition
 *	of the channel so the process can wake up and take action upon
 *	the timeout.  The mutex on the channel is aquired for multiprocessor
 *	synchronization.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The channel contition is notified.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
void
Rpc_Timeout(time, data)
    Timer_Ticks time;	/* The time we timed out at. */
    ClientData data;	/* Our private data is the channel pointer */
{
    RpcClientChannel *chanPtr;	/* The channel to notify */

    chanPtr = (RpcClientChannel *)data;

    /*
     * This is called from the timeout queue at interrupt time.
     * We acquire the master lock (as a formality in a uniprocessor)
     * and use the form of broadcast designed for master locks.
     */
    MASTER_LOCK(&chanPtr->mutex);
    chanPtr->state &= ~CHAN_TIMEOUT;
    CHAN_TRACE(chanPtr, chanPtr->serverID, "Timeout");
    Sync_MasterBroadcast(&chanPtr->waitCondition);
    MASTER_UNLOCK(&chanPtr->mutex);
}
@


9.11
log
@Changes for transparent server recovery.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/rpc/rpcClient.c,v 9.10 91/03/15 15:40:57 ouster Exp $ SPRITE (Berkeley)";
d30 1
d32 1
d104 1
a104 1
	fastBootPtr)
d114 2
a115 2
    Boolean	*fastBootPtr;	/* Wether rpc packet comes from fast booted
				 * server. */
d213 7
a219 2
	    *fastBootPtr = rpcHdrPtr->flags & RPC_FAST;

@


9.10
log
@Eliminate problem with "x hanging my broadcast";  I forget the
exact reason for this change, but I think that the problem was
that a broadcast generated a lot of acks from different machines,
which summed to exceed the limit.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 9.9 90/10/09 11:59:01 jhh Exp Locker: ouster $ SPRITE (Berkeley)";
d101 2
a102 1
RpcDoCall(serverID, chanPtr, storagePtr, command, srvBootIDPtr, notActivePtr)
d112 2
d211 1
a228 8
		/*
		 * NOTE: for now we must handle a NACK before an ACK because
		 * I'm OR'ing in an ACK with the NACK so that old kernels on
		 * clients won't freak if they receive a NACK.  This backwards
		 * compatibility should be removed later.  The changes that go
		 * with it are setting the serverHint in RpcSrvInitHdr() and
		 * the OR'ing itself of the ACK with the NACK in rpcServer.c.
		 */
@


9.10.1.1
log
@Initial branch for Sprite server.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 9.10 91/03/15 15:40:57 ouster Exp $ SPRITE (Berkeley)";
@


9.9
log
@new net module
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 9.8 90/10/02 16:29:10 mgbaker Exp Locker: jhh $ SPRITE (Berkeley)";
d312 1
a312 3
		     * order to facilitate debugging, except in the case
		     * of broadcasts.  We only broadcast for prefixes
		     * so far, and can tolerate failure.
d315 1
a315 11
		    if (serverID == RPC_BROADCAST_SERVER_ID) {
			Net_SpriteIDToName(rpcHdrPtr->serverID, 100, name);
			if (*name == '\0') {
			    printf("RpcDoCall: <%d> hanging my broadcast\n",
				    rpcHdrPtr->serverID);
			} else {
			    printf("RpcDoCall: %s hanging my broadcast\n",
				name);
			}
			error = RPC_TIMEOUT;
		    } else if (!seemsHung) {
@


9.8
log
@More prototyping garbage.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 9.7 90/04/03 14:41:38 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d145 1
a145 1
    error = RpcOutput(serverID, &chanPtr->requestRpcHdr,
d308 1
a308 1
		    char *name;
d318 2
a319 2
			Net_SpriteIDToName(rpcHdrPtr->serverID, &name);
			if (name == (char *)NIL) {
d328 1
a328 1
			Net_SpriteIDToName(serverID, &name);
d374 2
a375 1
		    error = RpcOutput(serverID, &chanPtr->requestRpcHdr,
d406 2
a407 1
		    error = RpcOutput(serverID, &chanPtr->requestRpcHdr,
@


9.7
log
@Fixed synchronization problem on servers with negative acknowledgement
buffers.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 9.6 90/03/29 12:46:05 mgbaker Exp $ SPRITE (Berkeley)";
d19 10
a28 9
#include "sprite.h"
#include "rpc.h"
#include "rpcInt.h"
#include "rpcClient.h"
#include "rpcServer.h"
#include "rpcTrace.h"
#include "dbg.h"
#include "proc.h"
#include "sys.h"
@


9.6
log
@New negative ack stuff.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 9.5 90/03/22 12:13:34 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d224 8
@


9.5
log
@After merge with rpc.mgb.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 9.3 89/11/26 11:14:15 jhh Exp $ SPRITE (Berkeley)";
d73 7
a79 9
#ifdef NEG_ACK
#define NACK_RETRY_POLICY	1
#define	NACK_CHANNEL_POLICY	2
int	nackPolicy = NACK_RETRY_POLICY;
int	nackRetryWait;
int	maxNackWait;
#define RPC_NACK_ERROR	0x3000b		/* move to status.h after testing */

/* Use policy of ramping down channels for neg acks? Default is use backoff */
a80 1
#endif NEG_ACK
d222 1
a222 1
#ifdef NEG_ACK
a223 1
#ifdef NOTDEF
a224 1
#endif NOTDEF
d232 3
a234 3
		    if (nackPolicy == NACK_RETRY_POLICY) {
			if (wait < nackRetryWait) {
			    wait = nackRetryWait;
d236 2
d239 1
d241 5
a245 2
			if (wait > maxNackWait) {
			    wait = maxNackWait;
d248 1
a248 1
			/* Assume NACK_CHANNELS_POLICY */
a251 2
		printf("Client received negative acknowledgement.\n");
#endif NEG_ACK
@


9.4
log
@Prepare for merge.
@
text
@d73 12
d225 28
d337 1
a337 1
		printf("Warning: Rpc_Call: Unexpected input.");
@


9.3
log
@Added debug trace to channel allocation.
Fixed handling of explicit acknowledgments
so they properly synchronize with channel allocation.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 9.2 89/10/30 11:16:34 shirriff Exp $ SPRITE (Berkeley)";
@


9.2
log
@Lint fixes.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 9.1 89/10/03 12:56:15 brent Exp Locker: shirriff $ SPRITE (Berkeley)";
d42 31
d166 3
a168 3
	 * is input available.  We know there is none available yet
	 * because the MASTER_LOCK is shutting out the dispatcher.
	 * (Well, maybe not.  Check beforehand.)
d175 1
d185 1
a185 4
	} else {
#ifdef DEBUG_CHAN_MUTEX
	    printf("RPC Channel already had input.\n");
#endif 
d450 1
a450 28
	if ((chanPtr->state & CHAN_BUSY) == 0) {
	    register RpcHdr *requestRpcHdrPtr;

	    chanPtr->state |= CHAN_BUSY;
	    rpcCltStat.close++;
	    requestRpcHdrPtr = &chanPtr->requestRpcHdr;
	    requestRpcHdrPtr->flags = RPC_ACK | RPC_CLOSE | RPC_SERVER;
	    requestRpcHdrPtr->delay = rpcMyDelay;
	    requestRpcHdrPtr->clientID = rpc_SpriteID;
	    requestRpcHdrPtr->serverID = rpcHdrPtr->serverID;
	    requestRpcHdrPtr->channel = rpcHdrPtr->channel;
	    requestRpcHdrPtr->serverHint = rpcHdrPtr->serverHint;
	    requestRpcHdrPtr->ID = rpcHdrPtr->ID;
	    requestRpcHdrPtr->numFrags = 0;
	    requestRpcHdrPtr->fragMask = 0;
	    requestRpcHdrPtr->paramSize = 0;
	    requestRpcHdrPtr->dataSize = 0;
	    chanPtr->request.paramBuffer.bufAddr = (Address)NIL;
	    chanPtr->request.paramBuffer.length = 0;
	    chanPtr->request.dataBuffer.bufAddr = (Address)NIL;
	    chanPtr->request.dataBuffer.length = 0;
	    (void)RpcOutput(rpcHdrPtr->serverID, &chanPtr->requestRpcHdr,
						 &chanPtr->request,
						 (RpcBufferSet *)NIL, 0,
						 (Sync_Semaphore *)NIL);

	    chanPtr->state &= ~CHAN_BUSY;
	}
d556 1
d604 1
@


9.1
log
@Changed RpcDoCall to use channel-specific timeout parameters.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 8.6 89/06/08 09:40:23 brent Exp $ SPRITE (Berkeley)";
d554 1
a554 1
	Timer_DescheduleRoutine(&chanPtr->timeoutItem);
@


9.0
log
@Changing version numbers.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 8.6 89/06/08 09:40:23 brent Exp Locker: douglis $ SPRITE (Berkeley)";
a28 46
/*
 * Constant parameters for the protocol.  The RpcConst structure keeps
 * the complete set of constants.  Some (patchable) variables are defined
 * here that define initial values, see Rpc_Init.
 */
RpcConst rpc;
/*
 * rpcRetryMsec
 *	This is the initial waiting period for the reciept of a packet.
 * rpcMaxAckMsec:
 *	This is the maximum waiting period for the reciept of a packet,
 *	given that we've already gotten an acknowledgment.
 * rpcMaxTimeoutMsec:
 *	This is the maximum waiting period for the reciept of a packet,
 *	given that we've been timing out.
 * rpcMaxTries:
 *	This is the number of times the client will resend without
 *	getting an acknowledgment from a server.  After this
 *	many attempts it will time out the rpc attempt.
 * rpcMaxAcks:
 *	This is number of acknowledgments a client will accept from
 *	a server.  If the server proccess on the other machine goes into
 *	a loop then the server machine dispatcher will continue to
 *	sending us "i'm busy" acks forever.
 */
int	rpcRetryMsec = 100;	/* rpc.retryWait is rpcRetryMsec times
				 * 1 millisecond (see Rpc_Init).
				 * This can be as low as 30 for echoes and
				 * get time, but needs to be large because
				 * reads and writes take a while */
int	rpcMaxAckMsec = 5000;	/* rpc.maxAckWait = rpcMaxAckMsec msec.
				 * The wait period doubles each retry when
				 * receiving acks up to this maximum.  */

int	rpcMaxTimeoutMsec = 1000; /* rpc.maxTimeoutWait = rpcMaxTimeoutMsec
				 * The wait period doubles each retry when
				 * not recieving packets up to this maximum. */

int	rpcMaxTries = 8;	/* Number of times to re-send before aborting.
				 * If the initial timeout is .1 sec, and it
				 * doubles until 1 sec, 8 retries means a
				 * total timeout period of about 6 seconds. */
int	rpcMaxAcks = 10;	/* Watchdog against lots of acks from a server.
				 * This limit causes a warning message to be
				 * printed every rpcMaxAcks, and if the RPC
				 * is a broadcast it gets aborted. */
d72 1
d102 1
a102 2
    chanPtr->requestRpcHdr.serverHint =
	chanPtr->replyRpcHdr.serverHint;
d113 1
d118 1
a118 1
	wait = 5 * rpc.retryWait;
d120 1
a120 1
	wait = rpc.retryWait;
d211 1
a211 1
		if (numAcks <= rpc.maxAcks) {
d226 2
a227 2
			if (wait > rpc.maxAckWait) {
			    wait = rpc.maxAckWait;
d284 2
a285 2
	    if (wait > rpc.maxTimeoutWait) {
		wait = rpc.maxTimeoutWait;
d293 1
a293 1
		if (numTries <= rpc.maxTries ||
d319 1
a319 1
		if (numTries > rpc.maxTries &&
@


8.6
log
@Removed lint
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 8.5 89/06/05 12:33:30 brent Exp $ SPRITE (Berkeley)";
@


8.5
log
@Changed client to set CHAN_WAITING *before* outputing
a packet.  With a synchronous packet output the reply
might arrive very early and be discarded if the WAITING
bit were not already set.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 8.4 89/01/05 15:45:34 mendel Exp $ SPRITE (Berkeley)";
d490 1
a490 1
						 (int *)NIL);
@


8.4
log
@Change for multiprocessor.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 8.3 88/12/04 15:29:24 ouster Exp $ SPRITE (Berkeley)";
d149 1
@


8.3
log
@Stop using obsolete header files.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 8.2 88/11/22 19:35:04 jhh Exp Locker: ouster $ SPRITE (Berkeley)";
d432 1
d439 3
@


8.2
log
@new semaphore definition
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 8.1 88/11/16 09:41:40 douglis Exp Locker: jhh $ SPRITE (Berkeley)";
a25 2
#include "mem.h"
#include "byte.h"
@


8.1
log
@
check for CHAN_INPUT before scheduling the timeout, since we may
have released the master lock and permitted the input to arrive.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 8.0 88/11/11 18:35:21 douglis Stable Locker: douglis $ SPRITE (Berkeley)";
d139 1
a139 1
    MASTER_LOCK(chanPtr->mutex);
d390 1
a390 1
    MASTER_UNLOCK(chanPtr->mutex);
d434 1
a434 1
    if (chanPtr->mutex != 0) {
d438 1
a438 1
	MASTER_LOCK(chanPtr->mutex);
d605 1
a605 1
    MASTER_UNLOCK(chanPtr->mutex);
d641 1
a641 1
    MASTER_LOCK(chanPtr->mutex);
d644 1
a644 1
    MASTER_UNLOCK(chanPtr->mutex);
@


8.0
log
@Changing version numbers.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 6.4 88/11/11 17:56:12 brent Exp Locker: douglis $ SPRITE (Berkeley)";
d183 1
d185 11
a195 10
	chanPtr->timeoutItem.routine = Rpc_Timeout;
	chanPtr->timeoutItem.interval = wait;
	chanPtr->timeoutItem.clientData = (ClientData)chanPtr;
	chanPtr->state |= CHAN_TIMEOUT | CHAN_WAITING;
	Timer_ScheduleRoutine(&chanPtr->timeoutItem, TRUE);
	do {
	    /*
	     * Wait ignoring signals.
	     */
	    Sync_MasterWait(&chanPtr->waitCondition,
d197 7
a203 3
	} while (((chanPtr->state & CHAN_INPUT) == 0) &&
		  (chanPtr->state & CHAN_TIMEOUT));

@


6.4
log
@more verbose debugging msgs.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 6.3 88/10/28 19:23:41 mlgray Exp $ SPRITE (Berkeley)";
@


6.3
log
@Conversion to new C library.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcClient.c,v 6.2 88/09/06 08:13:55 mlgray Exp Locker: mlgray $ SPRITE (Berkeley)";
d23 1
d283 1
a283 2
			    printf(
			    "Warning: RpcDoCall: <%d> hanging my broadcast\n",
d286 1
a286 2
			    printf(
			    "Warning: RpcDoCall: %s hanging my broadcast\n",
d290 1
a290 1
		    } else {
d293 2
a294 3
			    printf(
			    "Warning: RpcDoCall: <%d> seems hung, RPC %d\n",
				serverID, command);
d296 2
a297 3
			    printf(
				"Warning: RpcDoCall: %s seems hung, RPC %d\n",
				name, command);
a299 1
			numAcks = 0;
d301 1
d379 1
a379 1
	    printf("RPC %d ok\n", command);
d381 1
a381 1
	    printf("RPC %d exit 0x%x\n", command, error);
@


6.2
log
@Removed lint
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 6.1 88/08/26 18:26:10 mlgray Exp $ SPRITE (Berkeley)";
a149 1
#ifdef RPC_TEST_BYTE_SWAP
a150 7
		      &chanPtr->swapRequestRpcHdr,
		      &chanPtr->request, &chanPtr->swapRequest,
		      chanPtr->fragment,
		      (unsigned int) (chanPtr->fragsDelivered),
		      &chanPtr->mutex);
#else /* RPC_TEST_BYTE_SWAP */
    error = RpcOutput(serverID, &chanPtr->requestRpcHdr,
a153 1
#endif /* RPC_TEST_BYTE_SWAP */
d282 2
a283 2
			    Sys_Panic(SYS_WARNING,
				"RpcDoCall: <%d> hanging my broadcast\n",
d286 3
a288 2
			    Sys_Panic(SYS_WARNING,
				"RpcDoCall: %s hanging my broadcast\n", name);
d294 2
a295 2
			    Sys_Panic(SYS_WARNING,
				"RpcDoCall: <%d> seems hung, RPC %d\n",
d298 2
a299 2
			    Sys_Panic(SYS_WARNING,
				"RpcDoCall: %s seems hung, RPC %d\n",
d311 1
a311 1
		Sys_Panic(SYS_WARNING, "Rpc_Call: Unexpected input.");
a339 1
#ifdef RPC_TEST_BYTE_SWAP
a340 8
				      &chanPtr->swapRequestRpcHdr,
				      &chanPtr->request,
				      &chanPtr->swapRequest,
				      chanPtr->fragment,
				      (unsigned int) (chanPtr->fragsDelivered),
				      &chanPtr->mutex);
#else /* RPC_TEST_BYTE_SWAP */
		    error = RpcOutput(serverID, &chanPtr->requestRpcHdr,
a343 1
#endif /* RPC_TEST_BYTE_SWAP */
a370 1
#ifdef RPC_TEST_BYTE_SWAP
a371 7
				      &chanPtr->swapRequestRpcHdr,
				      &chanPtr->request, &chanPtr->swapRequest,
				      chanPtr->fragment,
				      (unsigned int) (chanPtr->fragsDelivered),
				      &chanPtr->mutex);
#else /* RPC_TEST_BYTE_SWAP */
		    error = RpcOutput(serverID, &chanPtr->requestRpcHdr,
a374 1
#endif /* RPC_TEST_BYTE_SWAP */
d382 1
a382 1
	    Sys_Printf("RPC %d ok\n", command);
d384 1
a384 1
	    Sys_Printf("RPC %d exit 0x%x\n", command, error);
d432 1
a432 1
	Sys_Panic(SYS_WARNING, "Rpc to myself?\n");
d443 1
a443 1
	Sys_Printf("RPC setting SpriteID to %d.\n", rpc_SpriteID);
d445 1
a445 1
	Sys_Printf("RpcClientDispatch: clientID changed from (%d) to (%d).\n",
a480 5
#ifdef RPC_TEST_BYTE_SWAP
	    chanPtr->swapRequest.paramBuffer.bufAddr = (Address)NIL;
	    chanPtr->swapRequest.paramBuffer.length = 0;
	    chanPtr->swapRequest.dataBuffer.bufAddr = (Address)NIL;
	    chanPtr->swapRequest.dataBuffer.length = 0;
a481 1
						 &chanPtr->swapRequestRpcHdr,
a482 1
						 &chanPtr->swapRequest,
a484 6
#else /* RPC_TEST_BYTE_SWAP */
	    (void)RpcOutput(rpcHdrPtr->serverID, &chanPtr->requestRpcHdr,
						 &chanPtr->request,
						 (RpcBufferSet *)NIL, 0,
						 (int *)NIL);
#endif /* RPC_TEST_BYTE_SWAP */
@


6.1
log
@Fixed some lint errors.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 6.0 88/08/11 12:25:01 brent Stable $ SPRITE (Berkeley)";
d113 1
a113 1
    int *srvBootIDPtr;		/* Return, boot time stamp of server. */
@


6.0
log
@Changing version numbers.
@
text
@d1 1
a1 1
/* 
d15 2
a16 2
static char rcsid[] = "$Header: rpcClient.c,v 5.19 88/08/05 18:22:44 mlgray Exp $ SPRITE (Berkeley)";
#endif not lint
d155 3
a157 2
		      chanPtr->fragsDelivered, &chanPtr->mutex);
#else RPC_TEST_BYTE_SWAP
d160 3
a162 2
		      chanPtr->fragsDelivered, &chanPtr->mutex);
#endif RPC_TEST_BYTE_SWAP
d226 1
a226 1
#endif TIMESTAMP
d291 1
a291 1
			    Sys_Panic(SYS_WARNING, 
d295 1
a295 1
			    Sys_Panic(SYS_WARNING, 
d302 1
a302 1
			    Sys_Panic(SYS_WARNING, 
d306 1
a306 1
			    Sys_Panic(SYS_WARNING, 
d354 3
a356 2
				      chanPtr->fragsDelivered, &chanPtr->mutex);
#else RPC_TEST_BYTE_SWAP
d359 3
a361 2
				      chanPtr->fragsDelivered, &chanPtr->mutex);
#endif RPC_TEST_BYTE_SWAP
d394 1
a394 1
				      chanPtr->fragsDelivered,
d396 1
a396 1
#else RPC_TEST_BYTE_SWAP
d399 1
a399 1
				      chanPtr->fragsDelivered,
d401 1
a401 1
#endif RPC_TEST_BYTE_SWAP
d519 1
a519 1
#else RPC_TEST_BYTE_SWAP
d524 1
a524 1
#endif RPC_TEST_BYTE_SWAP
d610 1
a610 1
		/* 
d640 1
a640 1
#endif TIMESTAMP
@


5.19
log
@rpc_NoTimeouts back to FALSE.  It was TRUE for testing.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.18 88/08/01 17:11:05 mlgray Exp $ SPRITE (Berkeley)";
@


5.18
log
@Doing byte-swapping.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.17 88/05/10 14:06:53 brent Exp $ SPRITE (Berkeley)";
d81 1
a81 1
Boolean rpc_NoTimeouts = TRUE;
@


5.17
log
@Fixed retransmission so only one fragment is sent as a keep-alive
after the server process has started work on a request.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.16 88/04/11 08:20:28 brent Exp $ SPRITE (Berkeley)";
d81 1
a81 1
Boolean rpc_NoTimeouts = FALSE;
d150 1
d152 6
d160 1
d346 1
d348 7
d357 1
d385 1
d387 7
d397 1
d504 5
d510 1
d512 1
d515 6
@


5.16
log
@Added print statement regarding (seemingly) hung RPCs
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.15 88/03/04 14:38:32 brent Exp $ SPRITE (Berkeley)";
d499 1
a499 5
     * Filter out partial acks here. Rpc_Call could process them, but that
     * might result in a lot of retransmissions - one for every partial
     * ack that a server sends us.  It sends us one everytime it gets a
     * duplicate fragment, for example.  Instead we just update
     * fragsDelivered so the next resend is smarter.
d501 18
a518 5
    if ((rpcHdrPtr->fragMask != 0) && 
	(rpcHdrPtr->flags & RPC_ACK)) { 
	chanPtr->fragsDelivered = rpcHdrPtr->fragMask;
	rpcCltStat.recvPartial++;
	goto unlock;
@


5.15
log
@Changed around the protocol constants, embedded them into a structure.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.14 87/12/14 09:58:54 brent Exp $ SPRITE (Berkeley)";
d128 1
d300 1
d377 7
@


5.14
log
@Patched RpcDoCall so that it ignores acknowledgments during broadcasts.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.13 87/12/10 15:49:18 brent Exp $ SPRITE (Berkeley)";
d31 7
a37 2
 * There are a set of parameters used during RPC:
 * rpcRetryWait (rpcRetryFactor):
d39 6
a44 4
 *	rpcRetryWait is rpcRetryFactor milliseconds long.
 * rpcMaxWait (rpcMaxFactor):
 *	This is the maximum waiting period for the reciept of a packet.
 *	rpcMaxWait is rpcMaxFactor milliseconds long.
d55 1
a55 2
unsigned int	rpcRetryWait;	/* Initial wait interval in ticks */
int	rpcRetryFactor = 100;	/* rpcRetryWait is rpcRetryFactor times
d60 3
a62 5
unsigned int	rpcMaxWait;	/* Maximum wait interval in ticks */
int	rpcMaxFactor = 5000;	/* rpcMaxWait is rpcMaxFactor times
				 * 1 millisecond.  The wait period doubles
				 * each retry (when receiving acks or not),
				 * up to this maximum.  */
d64 4
d70 1
a70 1
				 * doubles until 5 sec, 5 retries means a
d72 4
a77 7
 * Watchdog against lots of acknowledgments from a server.  This limit causes
 * a warning message to be printed every rpcMaxAcks, and if the RPC is
 * a broadcast it gets aborted.
 */
int	rpcMaxAcks = 10;

/*
d161 1
a161 1
	wait = 5 * rpcRetryWait;
d163 1
a163 1
	wait = rpcRetryWait;
d187 3
a191 8
	/*
	 *	Wait ignoring signals.
	 *
	    if (Sig_Pending(Proc_GetCurrentProc(Sys_GetProcessorNumber()))) {
		error = FAILURE;
		goto exit;
	    }
	*/
d248 1
a248 1
		if (numAcks <= rpcMaxAcks) {
d263 2
a264 2
			if (wait > rpcMaxWait) {
			    wait = rpcMaxWait;
d292 2
a293 1
				"RpcDoCall: <%d> seems hung\n", serverID);
d296 2
a297 1
				"RpcDoCall: %s seems hung\n", name);
d323 2
a324 2
	    if (wait > rpcMaxWait) {
		wait = rpcMaxWait;
d332 1
a332 1
		if (numTries <= rpcMaxTries ||
d357 1
a357 1
		if (numTries > rpcMaxTries &&
@


5.13
log
@Wasn't setting up the close/ask packet correctly now that
a client acks old transactions.  Was relying on serverID,
for example, still being correct.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.12 87/12/02 13:10:59 brent Exp $ SPRITE (Berkeley)";
d254 5
d260 6
a265 4
		    numTries = 0;
		    wait *= 2;
		    if (wait > rpcMaxWait) {
			wait = rpcMaxWait;
@


5.12
log
@Changed the client dispatch routine so it will handle close
messages for old transactions.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.11 87/11/17 15:11:00 brent Exp $ SPRITE (Berkeley)";
d448 5
@


5.11
log
@Upped the number of client retries.  The file server seems to get loaded
and un-responsive under heavy client paging traffic.  This should be
tested/verified.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.10 87/10/13 10:56:37 brent Exp $ SPRITE (Berkeley)";
a417 7
     * Verify the transaction Id.
     */
    if (rpcHdrPtr->ID != chanPtr->requestRpcHdr.ID) {
	rpcCltStat.badId++;
	goto unlock;
    }
    /*
d422 1
a422 1
	Sys_Printf("Setting SpriteID to %d.\n", rpc_SpriteID);
d427 1
a428 13
     * Filter out partial acks here. Rpc_Call could process them, but that
     * might result in a lot of retransmissions - one for every partial
     * ack that a server sends us.  It sends us one everytime it gets a
     * duplicate fragment, for example.  Instead we just update
     * fragsDelivered so the next resend is smarter.
     */
    if ((rpcHdrPtr->fragMask != 0) && 
	(rpcHdrPtr->flags & RPC_ACK)) { 
	chanPtr->fragsDelivered = rpcHdrPtr->fragMask;
	rpcCltStat.recvPartial++;
	goto unlock;
    }
    /*
d431 4
a434 4
     * channel.  If the channel is not busy now we return an ack to the
     * server and unbind the server process from us.  Otherwise, the
     * channel is marked busy, and no master lock is released by
     * RpcOutput.  This ensures that, while we are returning the ack,
d462 24
@


5.10
log
@Added return parameters to RpcDoCall that are later passed
to the recovery module.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.9 87/10/06 11:08:35 brent Exp $ SPRITE (Berkeley)";
d60 1
a60 1
int	rpcMaxTries = 5;	/* Number of times to re-send before aborting.
d63 1
a63 1
				 * total timeout period of about 3 seconds. */
@


5.9
log
@Fiddled with re-try constants.  Trying to find a compromise between 
short timeouts and reliability.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.8 87/10/05 15:45:10 brent Exp $ SPRITE (Berkeley)";
d102 1
a102 1
RpcDoCall(serverID, chanPtr, storagePtr, command, srvBootIDPtr)
d108 4
a111 2
    int *srvBootIDPtr;		/* Return, boot time stamp of server.  Used
				 * to trigger recovery actions by our caller */
d205 1
d207 6
a212 1
	    rpcHdrPtr = &chanPtr->replyRpcHdr;
a226 1
		*srvBootIDPtr = rpcHdrPtr->bootID;
a247 1
		*srvBootIDPtr = rpcHdrPtr->bootID;
@


5.8
log
@Tuned maxRetries so that the total timeout period is about 10 seconds.
This depends on the initial wait (.1 sec), and the doubling of this
wait each time, up to 5 sec.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.7 87/10/05 10:48:59 brent Exp $ SPRITE (Berkeley)";
d60 1
a60 1
int	rpcMaxTries = 7;	/* Number of times to re-send before aborting.
d62 2
a63 2
				 * doubles until 5 sec, 7 retries means a
				 * total timeout period of about 10 seconds. */
@


5.7
log
@
Fiddled with constants.  Longer timeouts, shorter "lots of acks" limit,
turned off histograms by default.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.6 87/10/04 15:56:09 brent Exp $ SPRITE (Berkeley)";
d56 3
a58 1
				 * 1 millisecond */
d60 4
a63 1
int	rpcMaxTries = 8;	/* Number of times to re-send before aborting */
d70 1
a70 1
int	rpcMaxAcks = 12;
@


5.6
log
@Added a back-off when timing out so that fast machines don't
pound on slow ones too bad.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.5 87/09/29 16:05:11 brent Exp $ SPRITE (Berkeley)";
d58 1
a58 1
int	rpcMaxTries = 6;	/* Number of times to re-send before aborting */
d61 3
a63 3
 * Watchdog against lots of acknowledgments from a server.  Now we hang
 * in order to figure out what's wrong on the server.  This counter causes
 * a warning message to be printed every rpcMaxAcks.
d65 1
a65 1
int	rpcMaxAcks = 20;
d77 1
a77 1
Boolean rpcCallTiming = TRUE;
@


5.5
log
@Fixed "Hung Broadcast" error to print out offending host.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.4 87/09/23 15:21:03 brent Exp $ SPRITE (Berkeley)";
d69 1
a69 1
 * of timing out.
d71 1
a71 1
Boolean rpcNoTimeouts = FALSE;
d142 2
a143 2
     * characteristics of the RPC.  For now we just wait longer if
     * the packet will be fragmented.
d299 7
d313 1
a313 1
		    (rpcNoTimeouts && serverID != RPC_BROADCAST_SERVER_ID)) {
d338 1
a338 1
		    (!rpcNoTimeouts || (serverID == RPC_BROADCAST_SERVER_ID))) {
@


5.4
log
@Prevented hanging with broadcasts.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.3 87/09/11 09:57:39 brent Exp $ SPRITE (Berkeley)";
d260 9
a268 2
			Sys_Panic(SYS_WARNING,
			    "RpcDoCall: lots of acks to a Broadcast\n");
@


5.3
log
@type
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.2 87/09/11 09:48:19 brent Exp $ SPRITE (Berkeley)";
d252 5
a256 3
		     * Too many acks.  This is a check against a looping
		     * server process.  In that case the dispatcher on
		     * the server machine will send us acks forever.
d259 4
a262 4
		    Net_SpriteIDToName(serverID, &name);
		    if (name == (char *)NIL) {
			Sys_Panic(SYS_WARNING, 
			    "RpcDoCall: <%d> seems hung\n", serverID);
d264 9
a272 2
			Sys_Panic(SYS_WARNING, 
			    "RpcDoCall: %s seems hung\n", name);
a273 1
		    numAcks = 0;
@


5.2
log
@Added hook to RpcDoCall to return the server's boot time stamp
so Rpc_Call can interface to RpcHostAlive
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.1 87/09/09 10:47:53 brent Exp $ SPRITE (Berkeley)";
d260 1
a260 1
			    "RpcDoCall: <%d> seems hung\n", spriteID);
@


5.1
log
@Cleaned up some lint
@
text
@d8 1
a8 1
 *      and handes them up to RpcDoCall.
d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 5.0 87/08/11 10:48:35 sprite Exp $ SPRITE (Berkeley)";
d58 1
a58 1
int	rpcMaxTries = 5;	/* Number of times to re-send before aborting */
d61 3
a63 2
 * Temporary guard.  Only accept a maximum number of Acknowledgments from
 * the server.  This prevents us from hanging if the server loops.
d97 1
a97 1
RpcDoCall(serverID, chanPtr, storagePtr, command)
d103 2
d133 1
d178 2
d214 1
d236 1
d250 1
d257 8
a264 1
		    Sys_Panic(SYS_WARNING, "RpcDoCall: lots of acks\n");
d505 1
@


5.0
log
@First Sprite native copy
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: rpcClient.c,v 4.3 87/06/17 09:48:02 brent Exp $ SPRITE (Berkeley)";
a112 1
    int	loopCount;
a315 1
exit:
@
