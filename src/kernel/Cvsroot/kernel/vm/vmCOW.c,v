head     9.7;
branch   ;
access   ;
symbols  ds3100:9.7 sun3:9.7 sun4nw:9.7 symm:9.7 spur:9.7 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.7
date     91.09.10.18.29.26;  author rab;  state Exp;
branches ;
next     9.6;

9.6
date     91.06.27.17.41.50;  author mgbaker;  state Exp;
branches ;
next     9.5;

9.5
date     91.06.27.12.13.53;  author mgbaker;  state Exp;
branches ;
next     9.4;

9.4
date     90.09.12.13.36.28;  author shirriff;  state Exp;
branches ;
next     9.3;

9.3
date     90.09.11.10.44.36;  author shirriff;  state Exp;
branches ;
next     9.2;

9.2
date     89.10.22.23.07.56;  author shirriff;  state Exp;
branches ;
next     9.1;

9.1
date     89.09.18.17.27.12;  author shirriff;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.22.47;  author douglis;  state Stable;
branches ;
next     8.8;

8.8
date     89.09.07.14.24.54;  author shirriff;  state Exp;
branches ;
next     8.7;

8.7
date     89.06.15.17.07.04;  author mendel;  state Exp;
branches ;
next     8.6;

8.6
date     89.05.24.01.03.57;  author rab;  state Exp;
branches ;
next     8.5;

8.5
date     89.04.30.17.50.21;  author mgbaker;  state Exp;
branches ;
next     8.4;

8.4
date     89.04.28.16.14.30;  author douglis;  state Exp;
branches ;
next     8.3;

8.3
date     89.04.28.15.04.30;  author mgbaker;  state Exp;
branches ;
next     8.2;

8.2
date     89.04.21.14.20.19;  author douglis;  state Exp;
branches ;
next     8.1;

8.1
date     88.12.04.15.50.28;  author ouster;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.42.11;  author douglis;  state Stable;
branches ;
next     6.2;

6.2
date     88.10.28.18.18.22;  author mlgray;  state Exp;
branches ;
next     6.1;

6.1
date     88.08.15.18.12.52;  author nelson;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.29.27;  author brent;  state Stable;
branches ;
next     1.14;

1.14
date     88.07.17.17.19.23;  author nelson;  state Exp;
branches ;
next     1.13;

1.13
date     88.07.12.19.53.04;  author nelson;  state Exp;
branches ;
next     1.12;

1.12
date     88.05.04.17.25.51;  author nelson;  state Exp;
branches ;
next     1.11;

1.11
date     88.02.08.15.58.15;  author nelson;  state Exp;
branches ;
next     1.10;

1.10
date     88.02.03.14.15.54;  author nelson;  state Exp;
branches ;
next     1.9;

1.9
date     88.01.17.18.21.07;  author nelson;  state Exp;
branches ;
next     1.8;

1.8
date     88.01.08.15.52.07;  author nelson;  state Exp;
branches ;
next     1.7;

1.7
date     88.01.04.14.00.12;  author nelson;  state Exp;
branches ;
next     1.6;

1.6
date     87.12.17.18.45.35;  author nelson;  state Exp;
branches ;
next     1.5;

1.5
date     87.12.15.15.20.05;  author nelson;  state Exp;
branches ;
next     1.4;

1.4
date     87.12.12.16.26.02;  author nelson;  state Exp;
branches ;
next     1.3;

1.3
date     87.12.11.13.26.33;  author nelson;  state Exp;
branches ;
next     1.2;

1.2
date     87.11.20.18.29.36;  author nelson;  state Exp;
branches ;
next     1.1;

1.1
date     87.11.18.21.52.39;  author nelson;  state Exp;
branches ;
next     ;


desc
@Copy-on-write.
@


9.7
log
@Fixed lint errors and removed tracing.
@
text
@/* 
 * vmCOW.c --
 *
 * This file contains routines that implement copy-on-write.
 *
 * Copy-on-write (COW) is implemented by linking all related instances of a
 * segment in a list. "Related instances" means all segments related by a fork
 * of some initial segment, including children, grandchildren, etc.  Each page
 * in each related segment is marked either OK (meaning the page is no longer
 * involved in any COW activity), COW or COR (meaning it's copy-on-reference).
 * COR pages have no associated backing store or main-memory contents yet, but
 * the PTE for each COR page names the segment from which this page is to be 
 * copied by setting the page frame number equal to the segment number of the
 * source of the page.  Pages are marked COW and COR through the use of the
 * bits in the PTE.
 *
 * When a COR page is referenced, the routine VmCOR is called.  The source of
 * the page is found through the page frame number and a copy of the page is 
 * made.  The source is left COW.  When a COW page (call it A) is written then
 * the routine VmCOW is called.  Another page (call it B) is found by
 * traversing the list of segments.  Page A is then copied to page B and A is
 * marked OK (no longer COW).  If there are any other pages that were COR off 
 * of A besides B, then B is marked COW and each of the other pages is marked
 * COR off of B.  Otherwise B is marked OK.
 *
 * During a fork the routine VmSegFork is called.  The newly created segment
 * is added to the list of related segments which contains the new segment's
 * parent.  For each page that is COR in the parent, the child is marked COR
 * off of the same page.  For each page that is marked COW in the parent,
 * the child is marked COR off of the parent.  For each parent page that is
 * resident or on swap space, the child is marked COR off of the parent.
 * All other pages (zero fill or demand load from the file system) are set up
 * to be the same for the child.
 *
 * When a segment or a portion of a segment which contains COW pages is
 * deleted then all of the COW pages must be duplicated.  This is done
 * by calling the routine VmCOWDeleteFromSeg.  For each COW
 * page (call it A), if there is segment which is COR off of A, then A is
 * copied to B.  If A is resident this is done by remapping the page in A
 * onto B.  Otherwise the swap space behind A is copied to B's backing store.
 * 
 * When a segment is migrated, a copy of it has to be made.  This is done by
 * calling the routine VmCOWCopy.  For each COR page a COR fault is simulated.
 * For each COW page a COW fault is simulated.
 *
 * SYNCHRONIZATION
 *
 * The routines in this file are designed to be called by routines in 
 * vmPage.c and vmSeg.c.  Whenever any of these routines are called  it is
 * assumed that the page tables for the segment have had their user count
 * incremented so that it is safe to grab a pointer to the page tables outside.
 * of the monitor lock. Also only one operation can occur to a
 * copy-on-write chain at one time.  This is assured by embedding a lock into 
 * a common data structure that all  segments in a copy-on-write chain 
 * reference (VmCOWInfo).  Since only one operation can happen at a time and 
 * the pages tables are safe this greatly simplifies the code.
 *
 * CLEANUP
 *
 * There are several cases in which the COW chain must be cleaned up.  The
 * cases and how they are handled are:
 *
 * 1) After a COW or a COR fault occurs for page A, there may be no more pages
 *    that are COR off of A.  However, there is no way of knowing this without
 *    searching the entire chain.  In this case A is left COW and then if
 *    a subsequent COW fault occurs on A, A will be marked OK.
 * 2) After a COW or COR fault there may be no more COR or COW pages in the
 *    faulting segment.  In this case the segment is deleted from the list.
 * 3) After a COR fault, COW fault, or a segment is deleted there may be
 *    only one segement left in the list.  In this case all pages are marked
 *    OK in the segment, the segment is removed from the chain and the
 *    VmCOWInfo struct is freed.
 *
 * Copyright (C) 1985 Regents of the University of California
 * All rights reserved.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmCOW.c,v 9.6 91/06/27 17:41:50 mgbaker Exp Locker: rab $ SPRITE (Berkeley)";
#endif not lint

#include <sprite.h>
#include <vmStat.h>
#include <vm.h>
#include <vmInt.h>
#include <user/vm.h>
#include <sync.h>
#include <dbg.h>
#include <list.h>
#include <lock.h>
#include <sys.h>
#include <stdlib.h>
#include <stdio.h>
#include <bstring.h>

#ifdef sun4
/*
 * Due to the cache flushing necessitated by all the mapping games, COW
 * seems to be a lose on the sun4 right now.
 */
Boolean	vm_CanCOW = FALSE;
#else
Boolean	vm_CanCOW = TRUE;
#endif /* sun4 */

static void DoFork _ARGS_((register Vm_Segment *srcSegPtr,
	register Vm_Segment *destSegPtr));
static void GiveAwayPage _ARGS_((register Vm_Segment *srcSegPtr, int virtPage,
	register Vm_PTE *srcPTEPtr, register Vm_Segment *destSegPtr,
	Boolean others));
static void ReleaseCOW  _ARGS_((Vm_PTE *ptePtr));
static Boolean COWStart _ARGS_((register Vm_Segment *segPtr,
	register VmCOWInfo **cowInfoPtrPtr));
static Vm_Segment *FindNewMasterSeg _ARGS_((register Vm_Segment *segPtr,
	int page, Boolean *othersPtr));
static Boolean IsResident _ARGS_((Vm_PTE *ptePtr));
static void COWEnd _ARGS_((register Vm_Segment *segPtr,
	VmCOWInfo **cowInfoPtrPtr));
static void SetPTE _ARGS_((Vm_VirtAddr *virtAddrPtr, Vm_PTE pte));
static void CopyPage _ARGS_((unsigned int srcPF, unsigned int destPF));
static ReturnStatus COR _ARGS_((register Vm_VirtAddr *virtAddrPtr,
	register Vm_PTE *ptePtr));
static void COW _ARGS_((register Vm_VirtAddr *virtAddrPtr,
	register Vm_PTE *ptePtr, Boolean isResident, Boolean deletePage));
static unsigned int GetMasterPF();
static void SeeIfLastCOR _ARGS_((register Vm_Segment *mastSegPtr,
	int page));


/*
 *----------------------------------------------------------------------
 *
 * VmSegFork --
 *
 *	Make a copy-on-reference copy of the given segment.  It is assumed
 *	that this routine is called with the source segment's page table
 *	in use count incremented.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Memory may be allocated for COW info struct.
 *
 *----------------------------------------------------------------------
 */
void
VmSegFork(srcSegPtr, destSegPtr)
    Vm_Segment	*srcSegPtr;
    Vm_Segment	*destSegPtr;
{
    VmCOWInfo	*cowInfoPtr;

    cowInfoPtr = (VmCOWInfo *)malloc(sizeof(VmCOWInfo));
    (void)COWStart(srcSegPtr, &cowInfoPtr);
    if (cowInfoPtr != (VmCOWInfo *)NIL) {
	free((Address)cowInfoPtr);
    }
    DoFork(srcSegPtr, destSegPtr);
}


/*
 *----------------------------------------------------------------------
 *
 * DoFork --
 *
 *	Make the dest segment copy-on-reference off of the src segment.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Source and destination page tables modified to set up things
 *	as copy-on-write and copy-on-reference.  Also number of COW and COR
 *	pages in each segment is modified.
 *
 *----------------------------------------------------------------------
 */
static void
DoFork(srcSegPtr, destSegPtr)
    register	Vm_Segment	*srcSegPtr;
    register	Vm_Segment	*destSegPtr;
{	
    register	Vm_PTE	*destPTEPtr;
    register	Vm_PTE	*srcPTEPtr;
    register	int	virtPage;
    register	int	lastPage;
    register	int	numCORPages = 0;
    register	int	numCOWPages = 0;
    register	Vm_PTE	corPTE;
    Vm_VirtAddr		virtAddr;
    VmCOWInfo		*cowInfoPtr;

    LOCK_MONITOR;

    corPTE = VM_VIRT_RES_BIT | VM_COR_BIT | srcSegPtr->segNum;

    if (srcSegPtr->type == VM_HEAP) {
	virtPage = srcSegPtr->offset;
	lastPage = virtPage + srcSegPtr->numPages - 1;
	srcPTEPtr = srcSegPtr->ptPtr;
	destPTEPtr = destSegPtr->ptPtr;
    } else {
	virtPage = mach_LastUserStackPage - srcSegPtr->numPages + 1;
	lastPage = mach_LastUserStackPage;
	srcPTEPtr = VmGetPTEPtr(srcSegPtr, virtPage);
	destPTEPtr = VmGetPTEPtr(destSegPtr, virtPage);
    }

    virtAddr.segPtr = srcSegPtr;
    virtAddr.flags = 0;
    virtAddr.sharedPtr = (Vm_SegProcList *)NIL;
    for (; virtPage <= lastPage;
	 virtPage++, VmIncPTEPtr(srcPTEPtr, 1), VmIncPTEPtr(destPTEPtr, 1)) {
	if (!(*srcPTEPtr & VM_VIRT_RES_BIT)) {
	    *destPTEPtr = 0;
	    continue;
	}
	while (*srcPTEPtr & VM_IN_PROGRESS_BIT) {
	    (void)Sync_Wait(&srcSegPtr->condition, FALSE);
	}
	if (*srcPTEPtr & VM_COW_BIT) {
	    /*
	     * This page is already copy-on-write.  Make child copy-on-ref
	     * off of the parent segment.
	     */
	    *destPTEPtr = corPTE;
	    numCORPages++;
	} else if (*srcPTEPtr & VM_COR_BIT) {
	    /*
	     * This page is already copy-on-reference.  Make the child be
	     * copy-on-ref on the same segment.
	     */
	    *destPTEPtr = *srcPTEPtr;
	    numCORPages++;
	} else if (*srcPTEPtr & (VM_PHYS_RES_BIT | VM_ON_SWAP_BIT)) {
	    /*
	     * Need to make the src copy-on-write and the dest copy-on-ref.
	     */
	    *srcPTEPtr |= VM_COW_BIT;
	    if (*srcPTEPtr & VM_PHYS_RES_BIT) {
		virtAddr.page = virtPage;
		virtAddr.sharedPtr = (Vm_SegProcList *)NIL;
		VmMach_SetPageProt(&virtAddr, *srcPTEPtr);
	    }
	    numCOWPages++;
	    *destPTEPtr = corPTE;
	    numCORPages++;
	} else {
	    /*
	     * Just a normal everyday pte (zerofill or load from FS).
	     */
	    *destPTEPtr = *srcPTEPtr;
	}
    }

    cowInfoPtr = srcSegPtr->cowInfoPtr;
    if (numCORPages > 0) {
	if (srcSegPtr->type == VM_HEAP) {
	    vmStat.numCOWHeapPages += numCOWPages;
	    vmStat.numCORHeapPages += numCORPages;
	} else {
	    vmStat.numCOWStkPages += numCOWPages;
	    vmStat.numCORStkPages += numCORPages;
	}
	srcSegPtr->numCOWPages += numCOWPages;
	destSegPtr->numCORPages = numCORPages;
	/*
	 * Insert the child into the COW list for the parent segment.
	 */
	destSegPtr->cowInfoPtr = cowInfoPtr;
	List_Insert((List_Links *)destSegPtr, 
		    LIST_ATREAR(&cowInfoPtr->cowList));
	cowInfoPtr->numSegs++;
    }
    cowInfoPtr->copyInProgress = 0;
    Sync_Broadcast(&cowInfoPtr->condition);

    UNLOCK_MONITOR;
}


/*
 *----------------------------------------------------------------------
 *
 * VmCOWCopySeg --
 *
 *	Make a copy of the given segment.  This includes handling all
 *	copy-on-write and copy-on-reference pages.  This segment will
 *	be removed from its copy-on-write chain.  It is assumed that the
 *	calling segment has the in-use count of its page tables incremented.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Memory for a COW info struct may be freed.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
VmCOWCopySeg(segPtr)
    register	Vm_Segment	*segPtr;
{
    register	Vm_PTE		*ptePtr;
    VmCOWInfo			*cowInfoPtr;
    Vm_VirtAddr			virtAddr;
    int				firstPage;
    int				lastPage;
    ReturnStatus		status = SUCCESS;

    cowInfoPtr = (VmCOWInfo *)NIL;
    if (!COWStart(segPtr, &cowInfoPtr)) {
	return(SUCCESS);
    }
    if (segPtr->type == VM_STACK) {
	firstPage = mach_LastUserStackPage - segPtr->numPages + 1;
    } else {
	firstPage = segPtr->offset;
    }
    lastPage = firstPage + segPtr->numPages - 1;
    virtAddr.segPtr = segPtr;
    virtAddr.flags = 0;
    virtAddr.sharedPtr = (Vm_SegProcList *)NIL;
    for (virtAddr.page = firstPage, ptePtr = VmGetPTEPtr(segPtr, firstPage);
	 virtAddr.page <= lastPage;
	 virtAddr.page++, VmIncPTEPtr(ptePtr, 1)) {
	if (*ptePtr & VM_COW_BIT) {
	    COW(&virtAddr, ptePtr, IsResident(ptePtr), FALSE);
	    VmPageValidate(&virtAddr);
	} else if (*ptePtr & VM_COR_BIT) {
	    status = COR(&virtAddr, ptePtr);
	    if (status != SUCCESS) {
		break;
	    }
	}
    }

    cowInfoPtr = (VmCOWInfo *)NIL;
    COWEnd(segPtr, &cowInfoPtr);
    if (cowInfoPtr != (VmCOWInfo *)NIL) {
	free((Address)cowInfoPtr);
    }
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * VmCOWDeleteFromSeg --
 *
 *	Invalidate all cow or cor pages from the given range of pages in
 *	the given segment.  It is assumed that this routine is called with
 *	the segment's page tables in use count incremented.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All cow or cor pages in the given range of pages are invalidated.
 *
 *----------------------------------------------------------------------
 */
void
VmCOWDeleteFromSeg(segPtr, firstPage, lastPage)
    register	Vm_Segment	*segPtr;
    register	int		firstPage;	/* First page to delete. -1
						 * if want the lowest possible
						 * page. */
    register	int		lastPage;	/* Last page to delete. -1
						 * if want the highest possible
						 * page. */
{
    register	Vm_PTE		*ptePtr;
    VmCOWInfo			*cowInfoPtr;
    Vm_VirtAddr			virtAddr;

    if (firstPage == -1) {
	/*
	 * Caller wants to invalidate all pages for this segment.  This
	 * is only done when the segment is deleted.
	 */
	if (segPtr->type == VM_STACK) {
	    firstPage = mach_LastUserStackPage - segPtr->numPages + 1;
	} else {
	    firstPage = segPtr->offset;
	}
	lastPage = firstPage + segPtr->numPages - 1;
    }
    cowInfoPtr = (VmCOWInfo *)NIL;
    if (!COWStart(segPtr, &cowInfoPtr)) {
	return;
    }
    virtAddr.segPtr = segPtr;
    virtAddr.flags = 0;
    virtAddr.sharedPtr = (Vm_SegProcList *)NIL;
    for (ptePtr = VmGetPTEPtr(segPtr, firstPage);
	 firstPage <= lastPage;
	 firstPage++, VmIncPTEPtr(ptePtr, 1)) {
	if (*ptePtr & VM_COW_BIT) {
	    virtAddr.page = firstPage;
	    COW(&virtAddr, ptePtr, IsResident(ptePtr), TRUE);
	} else if (*ptePtr & VM_COR_BIT) {
	    segPtr->numCORPages--;
	    if (segPtr->numCORPages < 0) {
		panic("VmCOWDeleteFromSeg: numCORPages < 0\n");
	    }
	}
    }

    cowInfoPtr = (VmCOWInfo *)NIL;
    COWEnd(segPtr, &cowInfoPtr);
    if (cowInfoPtr != (VmCOWInfo *)NIL) {
	free((Address)cowInfoPtr);
    }
}


/*
 *----------------------------------------------------------------------
 *
 * COWStart --
 *
 *	Mark the segment as copy-on-write in progress.  After this routine
 *	is called all future copy-on-writes are blocked until released
 *	by a call to COWEnd.
 *
 * Results:
 *	If the segment is not currently involved in a copy-on-write chain and
 *	*cowInfoPtrPtr is NIL then this routine returns FALSE.  Otherwise
 *	it returns TRUE.
 *
 * Side effects:
 *	Copy-in-progress flag is set.  Also if there is no copy-on-write
 *	chain yet and *cowInfoPtrPtr is not equal to NIL, then a new
 *	one is created and *cowInfoPtrPtr is set to NIL.
 *
 *----------------------------------------------------------------------
 */
static Boolean
COWStart(segPtr, cowInfoPtrPtr)
    register	Vm_Segment	*segPtr;	/* Segment to begin COW for.*/
    register	VmCOWInfo	**cowInfoPtrPtr;/* Pointer to pointer to
						 * COW info struct that can
						 * be used if no struct yet
						 * exists. */ 
{
    register	VmCOWInfo	*cowInfoPtr;

    LOCK_MONITOR;

again:

    if (segPtr->cowInfoPtr == (VmCOWInfo *)NIL) {
	cowInfoPtr = *cowInfoPtrPtr;
	if (cowInfoPtr == (VmCOWInfo *)NIL) {
	    UNLOCK_MONITOR;
	    return(FALSE);
	}
	segPtr->cowInfoPtr = cowInfoPtr;
	cowInfoPtr->copyInProgress = TRUE;
	List_Init(&cowInfoPtr->cowList);
	List_Insert((List_Links *)segPtr, LIST_ATREAR(&cowInfoPtr->cowList));
	cowInfoPtr->numSegs = 1;
	*cowInfoPtrPtr = (VmCOWInfo *)NIL;
    } else {
	cowInfoPtr = segPtr->cowInfoPtr;
	if (cowInfoPtr->copyInProgress) {
	    (void)Sync_Wait(&cowInfoPtr->condition, FALSE);
	    goto again;
	} else {
	    cowInfoPtr->copyInProgress = TRUE;
	}
    }

    UNLOCK_MONITOR;
    return(TRUE);
}


/*
 *----------------------------------------------------------------------
 *
 * COWEnd --
 *
 *	Clean up after a copy-on-write or copy-on-ref has happened.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	*cowInfoPtrPtr is set to point to COW info struct to free if there
 *	are no segments left COW.
 *
 *----------------------------------------------------------------------
 */
static void
COWEnd(segPtr, cowInfoPtrPtr)
    register	Vm_Segment	*segPtr;	 /* Segment that was involved
						  * in the COW or COR. */
    VmCOWInfo			**cowInfoPtrPtr; /* Set to point to a COW
						  * info struct to free. */
{
    register	VmCOWInfo	*cowInfoPtr;


    LOCK_MONITOR;

    cowInfoPtr = segPtr->cowInfoPtr;
    cowInfoPtr->copyInProgress = FALSE;
    Sync_Broadcast(&cowInfoPtr->condition);
    if (segPtr->numCOWPages == 0 && segPtr->numCORPages == 0) {
	List_Remove((List_Links *)segPtr);
	segPtr->cowInfoPtr = (VmCOWInfo *)NIL;
	cowInfoPtr->numSegs--;
    }
    if (cowInfoPtr->numSegs == 0) {
	*cowInfoPtrPtr = cowInfoPtr;
    } else if (cowInfoPtr->numSegs == 1) {
	register Vm_Segment	*cowSegPtr;
	register Vm_PTE		*ptePtr;
	int			firstPage;
	int			lastPage;
	register int		i;
	/*
	 * Only one segment left.  Return this segment back to normal
	 * protection and clean up.
	 */
	*cowInfoPtrPtr = cowInfoPtr;
	cowSegPtr = (Vm_Segment *)List_First(&cowInfoPtr->cowList);
	cowSegPtr->cowInfoPtr = (VmCOWInfo *)NIL;
	if (cowSegPtr->type == VM_STACK) {
	    firstPage = mach_LastUserStackPage - cowSegPtr->numPages + 1;
	} else {
	    firstPage = cowSegPtr->offset;
	}
	lastPage = firstPage + cowSegPtr->numPages - 1;
	for (ptePtr = VmGetPTEPtr(cowSegPtr, firstPage),
		i = cowSegPtr->numPages;
	     i > 0;
	     i--, VmIncPTEPtr(ptePtr, 1)) {
	    *ptePtr &= ~(VM_COW_BIT | VM_COR_BIT);
	}
	VmMach_SetSegProt(cowSegPtr, firstPage, lastPage, TRUE);
	cowSegPtr->numCORPages = 0;
	cowSegPtr->numCOWPages = 0;
    }

    UNLOCK_MONITOR;
}


/*
 *----------------------------------------------------------------------
 *
 * FindNewMasterSeg --
 *
 *	Find a segment that is sharing the given page copy-on-reference.
 *
 * Results:
 *	Pointer to segment that is sharing the given page copy-on-reference.
 *
 * Side effects:
 *	All segments that are now dependent on the new master have their page
 *	table entries set to point to the new master segment.
 *
 *----------------------------------------------------------------------
 */
static Vm_Segment *
FindNewMasterSeg(segPtr, page, othersPtr)
    register	Vm_Segment	*segPtr;	/* Current master. */
    int				page;		/* Virtual page. */
    Boolean			*othersPtr;	/* Set to TRUE if there are
						 * other COW children. */
{
    register	List_Links	*cowList;
    register	Vm_Segment	*newSegPtr;
    register	Vm_PTE		*ptePtr;
    Vm_Segment			*mastSegPtr = (Vm_Segment *)NIL;

    *othersPtr = FALSE;
    cowList = &segPtr->cowInfoPtr->cowList;
    newSegPtr = (Vm_Segment *)List_Next((List_Links  *)segPtr);
    while (!List_IsAtEnd(cowList, (List_Links *)newSegPtr)) {
	/*
	 * Make sure the page exists in this segment, then check the PTE.
	 */
	if (page - newSegPtr->offset < newSegPtr->ptSize) {
	    ptePtr = VmGetPTEPtr(newSegPtr, page);
	    if ((*ptePtr & VM_COR_BIT) &&
		Vm_GetPageFrame(*ptePtr) == segPtr->segNum) {
		if (mastSegPtr != (Vm_Segment *)NIL) {
		    *ptePtr &= ~VM_PAGE_FRAME_FIELD;
		    *ptePtr |= mastSegPtr->segNum;
		    *othersPtr = TRUE;
		} else {
		    mastSegPtr = newSegPtr;
		}
	    }
	}
	newSegPtr = (Vm_Segment *)List_Next((List_Links  *)newSegPtr);
    }
    return(mastSegPtr);
}


/*
 *----------------------------------------------------------------------
 *
 * IsResident --
 *
 *	Determine if the page is resident in the given page table entry.
 *
 * Results:
 *	TRUE if the page is resident. 
 *
 * Side effects:
 *	Page locked down if resident.
 *
 *----------------------------------------------------------------------
 */
static Boolean
IsResident(ptePtr)
    Vm_PTE	*ptePtr;
{
    Boolean	retVal;

    LOCK_MONITOR;

    if (*ptePtr & VM_PHYS_RES_BIT) {
	VmLockPageInt(Vm_GetPageFrame(*ptePtr));
	retVal = TRUE;
    } else {
	retVal = FALSE;
    }

    UNLOCK_MONITOR;

    return(retVal);
}


/*
 *----------------------------------------------------------------------
 *
 * VmCOR --
 *
 *	Handle a copy-on-reference fault.  If the virtual address is not
 *	truly COR then don't do anything.  It is assumed that the given
 *	segment's page tables have had their in-use count incremented.
 *
 * Results:
 *	Status from VmPageServerRead if had to read from swap space.  
 *	Otherwise SUCCESS.
 *
 * Side effects:
 *	Page table for current segment is modified.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
VmCOR(virtAddrPtr)
    register	Vm_VirtAddr	*virtAddrPtr;
{
    register	Vm_PTE		*ptePtr;
    VmCOWInfo			*cowInfoPtr;
    ReturnStatus		status;

    if (virtAddrPtr->segPtr->type == VM_HEAP) {
	vmStat.numCORHeapFaults++;
    } else {
	vmStat.numCORStkFaults++;
    }
    cowInfoPtr = (VmCOWInfo *)NIL;
    if (!COWStart(virtAddrPtr->segPtr, &cowInfoPtr)) {
	vmStat.quickCORFaults++;
	return(SUCCESS);
    }
    ptePtr = VmGetAddrPTEPtr(virtAddrPtr, virtAddrPtr->page);
    if (!(*ptePtr & VM_COR_BIT)) {
	vmStat.quickCORFaults++;
	status = SUCCESS;
    } else {
	status = COR(virtAddrPtr, ptePtr);
    }

    cowInfoPtr = (VmCOWInfo *)NIL;
    COWEnd(virtAddrPtr->segPtr, &cowInfoPtr);
    if (cowInfoPtr != (VmCOWInfo *)NIL) {
	free((Address)cowInfoPtr);
    }

    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * COR --
 *
 *	Handle a copy-on-reference fault.
 *
 * Results:
 *	Status from VmPageServerRead if had to read from swap space.  
 *	Otherwise SUCCESS.
 *
 * Side effects:
 *	Page table for current segment is modified.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
COR(virtAddrPtr, ptePtr)
    register	Vm_VirtAddr	*virtAddrPtr;
    register	Vm_PTE		*ptePtr;
{
    register	Vm_Segment	*mastSegPtr;
    unsigned	int		virtFrameNum;
    unsigned	int		mastVirtPF;
    ReturnStatus		status;
    int				corCheckBit;

    mastSegPtr = VmGetSegPtr((int) (Vm_GetPageFrame(*ptePtr)));
    virtFrameNum = VmPageAllocate(virtAddrPtr, VM_CAN_BLOCK);
    mastVirtPF = GetMasterPF(mastSegPtr, virtAddrPtr->page);
    if (mastVirtPF != 0) {
	/*
	 * The page is resident in memory so copy it.
	 */
	CopyPage(mastVirtPF, virtFrameNum);
	VmUnlockPage(mastVirtPF);
    } else {
	/*
	 * Load the page off of swap space.
	 */
	Vm_VirtAddr	virtAddr;

	virtAddr.segPtr = mastSegPtr;
	virtAddr.page = virtAddrPtr->page;
	virtAddr.flags = 0;
	virtAddr.sharedPtr = virtAddrPtr->sharedPtr;
	status = VmPageServerRead(&virtAddr, virtFrameNum);
	if (status != SUCCESS) {
	    printf("Warning: VmCOR: Couldn't read page, status <%x>\n", status);
	    VmPageFree(virtFrameNum);
	    return(status);
	}
    }

    virtAddrPtr->segPtr->numCORPages--;
    if (virtAddrPtr->segPtr->numCORPages < 0) {
	panic("COR: numCORPages < 0\n");
    }
    if (vmCORReadOnly) {
	corCheckBit = VM_COR_CHECK_BIT | VM_READ_ONLY_PROT;
    } else {
	corCheckBit = 0;
    }

    SetPTE(virtAddrPtr, (Vm_PTE)(VM_VIRT_RES_BIT | VM_PHYS_RES_BIT | 
			 VM_REFERENCED_BIT | VM_MODIFIED_BIT | corCheckBit |
			 virtFrameNum));
    VmUnlockPage(virtFrameNum);
    SeeIfLastCOR(mastSegPtr, virtAddrPtr->page);
    return(SUCCESS);
}


/*
 *----------------------------------------------------------------------
 *
 * GetMasterPF --
 *
 *	Return the page frame from the master segment's page table
 *	entry.  0 if the page is not resident.
 *
 * Results:
 *	The page frame from the masters PTE.  0 if not resident.
 *	Otherwise SUCCESS.
 *
 * Side effects:
 *	Page frame returned locked if resident.
 *
 *----------------------------------------------------------------------
 */
static unsigned int
GetMasterPF(mastSegPtr, virtPage)
    Vm_Segment	*mastSegPtr;
    int		virtPage;
{
    unsigned	int	pf;
    register	Vm_PTE	*mastPTEPtr;

    LOCK_MONITOR;

    mastPTEPtr = VmGetPTEPtr(mastSegPtr, virtPage);
    if (*mastPTEPtr & VM_PHYS_RES_BIT) {
	pf = Vm_GetPageFrame(*mastPTEPtr);
	VmLockPageInt(pf);
    } else {
	pf = 0;
    }

    UNLOCK_MONITOR;

    return(pf);
}


/*
 *----------------------------------------------------------------------
 *
 * SeeIfLastCOR --
 *
 *	See if there are any more segments that are COR off of the given 
 *	page in the given segment.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If there are no other pages COR of the given page in the given segment
 *	then the page is made no longer COW.
 *
 *----------------------------------------------------------------------
 */
static void
SeeIfLastCOR(mastSegPtr, page)
    register	Vm_Segment	*mastSegPtr;
    int				page;
{
    register	List_Links	*cowList;
    register	Vm_Segment	*childSegPtr;
    register	Vm_PTE		*ptePtr;
    Vm_VirtAddr			virtAddr;

    LOCK_MONITOR;

    cowList = &mastSegPtr->cowInfoPtr->cowList;
    childSegPtr = (Vm_Segment *)List_Next((List_Links *)mastSegPtr);
    while (!List_IsAtEnd(cowList, (List_Links *)childSegPtr)) {
	/*
	 * Make sure the page exists in this segment, then check the PTE.
	 */
	if (page - childSegPtr->offset < childSegPtr->ptSize) {
	    ptePtr = VmGetPTEPtr(childSegPtr, page);
	    if ((*ptePtr & VM_COR_BIT) &&
		Vm_GetPageFrame(*ptePtr) == mastSegPtr->segNum) {
		UNLOCK_MONITOR;
		return;
	    }
	}
	childSegPtr = (Vm_Segment *)List_Next((List_Links *)childSegPtr);
    }

    /*
     * No more pages are COR off of the master.  Make the page no longer
     * copy-on-write.
     */
    ptePtr = VmGetPTEPtr(mastSegPtr, page);
    *ptePtr &= ~VM_COW_BIT;
    mastSegPtr->numCOWPages--;
    if (mastSegPtr->numCOWPages == 0 && mastSegPtr->numCORPages == 0) {
	/*
	 * If there are no more COW or COR pages then remove ourselves
	 * from the list.  We know that we are only called by the routine
	 * COR() which means that there is guaranteed to be at least one
	 * segment left in the list.  Therefore there is no need to worry
	 * about freeing up the cow info struct.
	 */
	List_Remove((List_Links *)mastSegPtr);
	mastSegPtr->cowInfoPtr->numSegs--;
	mastSegPtr->cowInfoPtr = (VmCOWInfo *)NIL;
    }
    if (*ptePtr & VM_PHYS_RES_BIT) {
	virtAddr.segPtr = mastSegPtr;
	virtAddr.page = page;
	virtAddr.sharedPtr = (Vm_SegProcList *)NIL;
	VmMach_SetPageProt(&virtAddr, *ptePtr);
    }

    UNLOCK_MONITOR;
}


/*
 *----------------------------------------------------------------------
 *
 * VmCOW --
 *
 *	Handle a copy-on-write fault.  If the current virtual address is
 *	not truly COW then we don't do anything.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Page table for the given virtual address is modified and the page
 *	table of the new master (if any) is modified.
 *
 *----------------------------------------------------------------------
 */
void
VmCOW(virtAddrPtr)
    register	Vm_VirtAddr	*virtAddrPtr;
{
    register	Vm_PTE		*ptePtr;
    VmCOWInfo			*cowInfoPtr;

    if (virtAddrPtr->segPtr->type == VM_HEAP) {
	vmStat.numCOWHeapFaults++;
    } else {
	vmStat.numCOWStkFaults++;
    }
    cowInfoPtr = (VmCOWInfo *)NIL;
    if (!COWStart(virtAddrPtr->segPtr, &cowInfoPtr)) {
	vmStat.quickCOWFaults++;
	return;
    }
    ptePtr = VmGetAddrPTEPtr(virtAddrPtr, virtAddrPtr->page);
    if (!(*ptePtr & VM_COW_BIT)) {
	vmStat.quickCOWFaults++;
    } else if (IsResident(ptePtr)) {
	COW(virtAddrPtr, ptePtr, TRUE, FALSE);
    }

    cowInfoPtr = (VmCOWInfo *)NIL;
    COWEnd(virtAddrPtr->segPtr, &cowInfoPtr);
    if (cowInfoPtr != (VmCOWInfo *)NIL) {
	free((Address)cowInfoPtr);
    }
}


/*
 *----------------------------------------------------------------------
 *
 * COW --
 *
 *	Handle a copy-on-write fault.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static void
COW(virtAddrPtr, ptePtr, isResident, deletePage)
    register	Vm_VirtAddr	*virtAddrPtr;	/* Virtual address to copy.*/
    register	Vm_PTE		*ptePtr;	/* Pointer to the page table
						 * entry. */
    Boolean			isResident;	/* TRUE => The page is resident
						 *	   in memory and locked
						 *	   down. */
    Boolean			deletePage;	/* TRUE => Delete the page
						 *         after copying. */
{
    register	Vm_Segment	*mastSegPtr;
    Vm_VirtAddr			virtAddr;
    Boolean			others;
    unsigned int		virtFrameNum;
    Vm_PTE			pte;

    mastSegPtr = FindNewMasterSeg(virtAddrPtr->segPtr, virtAddrPtr->page,
				  &others);
    if (mastSegPtr != (Vm_Segment *)NIL) {
	mastSegPtr->numCORPages--;
	if (mastSegPtr->numCORPages < 0) {
	    panic("COW: numCORPages < 0\n");
	}
	if (others) {
	    mastSegPtr->numCOWPages++;
	}
	virtAddr.segPtr = mastSegPtr;
	virtAddr.page = virtAddrPtr->page;
	virtAddr.flags = 0;
	virtAddr.sharedPtr = (Vm_SegProcList *)NIL;
	if (isResident) {
	    /*
	     * The page is resident and locked down by our caller. 
	     */
	    if (deletePage) {
		/*
		 * This page is being invalidated. In this case just give
		 * away the page, no need to copy it.
		 */
		GiveAwayPage(virtAddrPtr->segPtr, virtAddrPtr->page, ptePtr,
			     mastSegPtr, others);
	    } else {
		/*
		 * Copy the page.
		 */
		virtFrameNum = VmPageAllocate(&virtAddr, VM_CAN_BLOCK);
		CopyPage(Vm_GetPageFrame(*ptePtr), virtFrameNum);
		pte = VM_VIRT_RES_BIT | VM_PHYS_RES_BIT | 
		      VM_REFERENCED_BIT | VM_MODIFIED_BIT | virtFrameNum;
		if (others) {
		    pte |= VM_COW_BIT;
		}
		SetPTE(&virtAddr, pte);
		VmUnlockPage(virtFrameNum);
		VmUnlockPage(Vm_GetPageFrame(*ptePtr));
	    }
	} else {
	    /*
	     * The page is on swap space.
	     */
	    (void)VmCopySwapPage(virtAddrPtr->segPtr, 
				virtAddrPtr->page, mastSegPtr);
	    pte = VM_VIRT_RES_BIT | VM_ON_SWAP_BIT;
	    if (others) {
		pte |= VM_COW_BIT;
	    }
	    SetPTE(&virtAddr, pte);
	}
	if (mastSegPtr->numCOWPages == 0 && mastSegPtr->numCORPages == 0) {
	    mastSegPtr->cowInfoPtr->numSegs--;
	    List_Remove((List_Links *)mastSegPtr);
	    mastSegPtr->cowInfoPtr = (VmCOWInfo *)NIL;
	}
    } else {
	vmStat.quickCOWFaults++;
    }

    /*
     * Change from copy-on-write back to normal if it has not already been
     * done by some other routine.
     */
    if (*ptePtr & VM_COW_BIT) {
	ReleaseCOW(ptePtr);
    }
    virtAddrPtr->segPtr->numCOWPages--;
    if (virtAddrPtr->segPtr->numCOWPages < 0) {
	panic("COW: numCOWPages < 0\n");
    }
}



/*
 *----------------------------------------------------------------------
 *
 * GiveAwayPage --
 *
 *	Transfer a page from one segment to another.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Source segments page table has the page zapped and the
 *	destination page table takes over ownership of the page.
 *
 *----------------------------------------------------------------------
 */
static void
GiveAwayPage(srcSegPtr, virtPage, srcPTEPtr, destSegPtr, others)
    register	Vm_Segment	*srcSegPtr;	/* Segment to take page from.*/
    int				virtPage;	/* Virtual page to give away.*/
    register	Vm_PTE		*srcPTEPtr;	/* PTE for the segment to take
						 * the page away from. */
    register	Vm_Segment	*destSegPtr;	/* Segment to give page to. */
    Boolean			others;		/* TRUE => other segments that
						 * are copy-on-write on 
						 * the destination segment. */
{
    Vm_VirtAddr		virtAddr;
    register	Vm_PTE	*destPTEPtr;
    unsigned	int	pageFrame;
    Boolean		referenced;
    Boolean		modified;

    LOCK_MONITOR;

    srcSegPtr->resPages--;
    destSegPtr->resPages++;
    virtAddr.segPtr = srcSegPtr;
    virtAddr.page = virtPage;
    virtAddr.flags = 0;
    virtAddr.sharedPtr = (Vm_SegProcList *)NIL;
    pageFrame = Vm_GetPageFrame(*srcPTEPtr);
    destPTEPtr = VmGetPTEPtr(destSegPtr, virtPage);
    *destPTEPtr = *srcPTEPtr & ~VM_COW_BIT;
    *srcPTEPtr = 0;
    VmMach_GetRefModBits(&virtAddr, pageFrame, &referenced, &modified);
    if (referenced) {
	*destPTEPtr |= VM_REFERENCED_BIT;
    }
    if (modified) {
	*destPTEPtr |= VM_MODIFIED_BIT;
    }
    VmMach_PageInvalidate(&virtAddr, pageFrame, FALSE);
    if (others) {
	*destPTEPtr |= VM_COW_BIT;
    }
    VmPageSwitch(Vm_GetPageFrame(*destPTEPtr), destSegPtr);
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * SetPTE --
 *
 *	Set the given pte at the given virtual address.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static void
SetPTE(virtAddrPtr, pte)
    Vm_VirtAddr	*virtAddrPtr;
    Vm_PTE	pte;
{
    Vm_PTE	*ptePtr;

    LOCK_MONITOR;

    ptePtr = VmGetAddrPTEPtr(virtAddrPtr, virtAddrPtr->page);
    *ptePtr = pte;
    if (pte & VM_PHYS_RES_BIT) {
	virtAddrPtr->segPtr->resPages++;
    }

    UNLOCK_MONITOR;
}


/*
 *----------------------------------------------------------------------
 *
 * CopyPage --
 *
 *	Copy the given page frame to the given destination.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static void
CopyPage(srcPF, destPF)
    unsigned	int	srcPF;
    unsigned	int	destPF;
{
    register	Address	srcMappedAddr;
    register	Address	destMappedAddr;

    srcMappedAddr = VmMapPage(srcPF);
    destMappedAddr = VmMapPage(destPF);
    bcopy(srcMappedAddr, destMappedAddr, vm_PageSize);
    VmUnmapPage(srcMappedAddr);
    VmUnmapPage(destMappedAddr);
}


/*
 *----------------------------------------------------------------------
 *
 * ReleaseCOW --
 *
 *	Make the page no longer copy-on-write.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static void
ReleaseCOW(ptePtr)
    Vm_PTE	*ptePtr;
{
    LOCK_MONITOR;

    *ptePtr &= ~VM_COW_BIT;

    UNLOCK_MONITOR;
}
@


9.6
log
@New counter
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmCOW.c,v 9.5 91/06/27 12:13:53 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
a85 1
#include <vmTrace.h>
a94 3
#ifdef SOSP91
#include <fsStat.h>
#endif SOSP91
a532 7
	if (vm_Tracing) {
	    Vm_TraceClearCOW	clearCOW;

	    clearCOW.segNum = cowSegPtr->segNum;
	    VmStoreTraceRec(VM_TRACE_CLEAR_COW_REC, sizeof(clearCOW),
			    (Address)&clearCOW, TRUE);
	}
a735 3
#ifdef SOSP91
	Boolean	isForeign = FALSE;
#endif SOSP91
a745 13
#ifdef SOSP91
	fs_MoreStats.CORPageServerRead++;
	if (proc_RunningProcesses[0] != (Proc_ControlBlock *) NIL) {
	    if ((proc_RunningProcesses[0]->state == PROC_MIGRATED) ||
		    (proc_RunningProcesses[0]->genFlags &
		    (PROC_FOREIGN | PROC_MIGRATING))) {
		isForeign = TRUE;
	    }
	}
	if (isForeign) {
	    fs_MoreStats.CORPageServerReadM++;
	}
#endif SOSP91
a863 12
    if (vm_Tracing) {
	Vm_TracePTEChange	pteChange;

	pteChange.changeType = VM_TRACE_LAST_COR;
	pteChange.softPTE = TRUE;
	pteChange.segNum = mastSegPtr->segNum;
	pteChange.pageNum = page;
	pteChange.beforePTE = *ptePtr;
	pteChange.afterPTE = *ptePtr & ~VM_COW_BIT;
	VmStoreTraceRec(VM_TRACE_PTE_CHANGE_REC, sizeof(pteChange),
			(Address)&pteChange, TRUE);
    }
a968 3
#ifdef SOSP91
    Boolean	isForeign = FALSE;
#endif SOSP91
a1015 13
#ifdef SOSP91
	    if (proc_RunningProcesses[0] != (Proc_ControlBlock *) NIL) {
		if ((proc_RunningProcesses[0]->state == PROC_MIGRATED) ||
			(proc_RunningProcesses[0]->genFlags &
			(PROC_FOREIGN | PROC_MIGRATING))) {
		    isForeign = TRUE;
		}
	    }
	    fs_MoreStats.COWCopySwapPage++;
	    if (isForeign) {
		fs_MoreStats.COWCopySwapPageM++;
	    }
#endif SOSP91
a1035 12
	if (vm_Tracing) {
	    Vm_TracePTEChange	pteChange;

	    pteChange.changeType = VM_TRACE_COW_TO_NORMAL;
	    pteChange.softPTE = TRUE;
	    pteChange.segNum = virtAddrPtr->segPtr->segNum;
	    pteChange.pageNum = virtAddrPtr->page;
	    pteChange.beforePTE = *ptePtr;
	    pteChange.afterPTE = *ptePtr & ~VM_COW_BIT;
	    VmStoreTraceRec(VM_TRACE_PTE_CHANGE_REC, sizeof(pteChange),
			    (Address)&pteChange, TRUE);
	}
a1089 12
    if (vm_Tracing) {
	Vm_TracePTEChange	pteChange;

	pteChange.changeType = VM_TRACE_GIVEN_FROM_MASTER;
	pteChange.softPTE = TRUE;
	pteChange.segNum = srcSegPtr->segNum;
	pteChange.pageNum = virtPage;
	pteChange.beforePTE = *srcPTEPtr;
	pteChange.afterPTE = 0;
	VmStoreTraceRec(VM_TRACE_PTE_CHANGE_REC, sizeof(pteChange),
			(Address)&pteChange, TRUE);
    }
d1103 1
a1103 14
    if (vm_Tracing) {
	Vm_TracePTEChange	pteChange;

	pteChange.changeType = VM_TRACE_TAKEN_BY_SLAVE;
	pteChange.softPTE = TRUE;
	pteChange.segNum = destSegPtr->segNum;
	pteChange.pageNum = virtPage;
	pteChange.beforePTE = 0;
	pteChange.afterPTE = *destPTEPtr;
	VmStoreTraceRec(VM_TRACE_PTE_CHANGE_REC, sizeof(pteChange),
			(Address)&pteChange, TRUE);
    }

    UNLOCK_MONITOR;
a1130 12
    if (vm_Tracing) {
	Vm_TracePTEChange	pteChange;

	pteChange.changeType = VM_TRACE_COW_COR_CHANGE;
	pteChange.softPTE = TRUE;
	pteChange.segNum = virtAddrPtr->segPtr->segNum;
	pteChange.pageNum = virtAddrPtr->page;
	pteChange.beforePTE = *ptePtr;
	pteChange.afterPTE = pte;
	VmStoreTraceRec(VM_TRACE_PTE_CHANGE_REC, sizeof(pteChange),
			(Address)&pteChange, TRUE);
    }
@


9.5
log
@New counters
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmCOW.c,v 9.4 90/09/12 13:36:28 shirriff Exp $ SPRITE (Berkeley)";
d1008 3
d1058 13
@


9.4
log
@Changed includes from quotes to angles.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmCOW.c,v 9.3 90/09/11 10:44:36 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d96 3
d747 3
d760 13
@


9.3
log
@Added function prototyping.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm.ken/RCS/vmCOW.c,v 9.2 89/10/22 23:07:56 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d82 14
a95 14
#include "sprite.h"
#include "vmStat.h"
#include "vm.h"
#include "vmInt.h"
#include "vmTrace.h"
#include "user/vm.h"
#include "sync.h"
#include "dbg.h"
#include "list.h"
#include "lock.h"
#include "sys.h"
#include "stdlib.h"
#include "stdio.h"
#include "bstring.h"
@


9.2
log
@Put in initializations for sharedPtr
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmCOW.c,v 9.1 89/09/18 17:27:12 shirriff Exp $ SPRITE (Berkeley)";
a83 1
#include "vmMach.h"
d94 2
d107 19
a125 11
static void	    DoFork();
static void	    GiveAwayPage();
static void	    ReleaseCOW();
static Boolean	    COWStart();
static Vm_Segment   *FindNewMasterSeg();
static Boolean      IsResident();
static void	    COWEnd();
static void	    SetPTE();
static void	    CopyPage();
static ReturnStatus COR();
static void	    COW();
d127 2
a128 1
static void	    SeeIfLastCOR();
@


9.1
log
@Changed NULL to NIL.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmCOW.c,v 8.8 89/09/07 14:24:54 shirriff Exp $ SPRITE (Berkeley)";
d235 1
d891 1
@


9.0
log
@Changing version numbers.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmCOW.c,v 8.8 89/09/07 14:24:54 shirriff Exp Locker: douglis $ SPRITE (Berkeley)";
d204 1
a204 1
    virtAddr.sharedPtr = (Vm_SegProcList *)NULL;
d315 1
a315 1
    virtAddr.sharedPtr = (Vm_SegProcList *)NULL;
d388 1
a388 1
    virtAddr.sharedPtr = (Vm_SegProcList *)NULL;
d991 1
a991 1
	virtAddr.sharedPtr = (Vm_SegProcList *)NULL;
d1106 1
a1106 1
    virtAddr.sharedPtr = (Vm_SegProcList *)NULL;
@


8.8
log
@Changes for shared memory.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /c/src/kernel/vm.ken/RCS/vmCOW.c,v 1.2 89/08/15 12:01:47 shirriff Exp $ SPRITE (Berkeley)";
@


8.7
log
@Fixed lint
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmCOW.c,v 8.6 89/05/24 01:03:57 rab Exp $ SPRITE (Berkeley)";
d204 1
d315 1
d388 1
d678 1
a678 1
    ptePtr = VmGetPTEPtr(virtAddrPtr->segPtr, virtAddrPtr->page);
d741 1
d931 1
a931 1
    ptePtr = VmGetPTEPtr(virtAddrPtr->segPtr, virtAddrPtr->page);
d991 1
d1106 1
d1175 1
a1175 1
    ptePtr = VmGetPTEPtr(virtAddrPtr->segPtr, virtAddrPtr->page);
@


8.6
log
@Added forward references for static functions.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmCOW.c,v 8.5 89/04/30 17:50:21 mgbaker Exp Locker: rab $ SPRITE (Berkeley)";
d565 1
a565 1
Vm_Segment *
@


8.5
log
@Kernel 22 for sun4: User-level caching works, but only with COW turned off.
However, it appears that COW may be a lose on the sun4 with the current way all
the mapping games are done.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmCOW.c,v 8.4 89/04/28 16:14:30 douglis Exp Locker: mgbaker $ SPRITE (Berkeley)";
d106 13
a118 13
void		DoFork();
void		GiveAwayPage();
void		ReleaseCOW();
Boolean		COWStart();
Vm_Segment	*FindNewMasterSeg();
Boolean		IsResident();
void		COWEnd();
void		SetPTE();
void		CopyPage();
ReturnStatus	COR();
void		COW();
unsigned int	GetMasterPF();
void		SeeIfLastCOR();
d171 1
a171 1
ENTRY static void
d429 1
a429 1
ENTRY static Boolean
d486 1
a486 1
ENTRY static void
d618 1
a618 1
ENTRY static Boolean
d709 1
a709 1
ReturnStatus
d782 1
a782 1
ENTRY unsigned int
d823 1
a823 1
ENTRY void
d1077 1
a1077 1
ENTRY static void
d1160 1
a1160 1
ENTRY static void
d1237 1
a1237 1
ENTRY void
@


8.4
log
@fixed bug with segments being grown, causing references past the
end of page table arrays when the child segment isn't also grown.
This bug manifested itself via bus errors in routines going through
the coremap, and possibly by causing bad COW/COR reference counts.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmCOW.c,v 8.3 89/04/28 15:04:30 mgbaker Exp Locker: douglis $ SPRITE (Berkeley)";
d96 7
d104 1
@


8.3
log
@removed special sun4 vm_CanCOW=FALSE.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmCOW.c,v 8.2 89/04/21 14:20:19 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d573 14
a586 9
	ptePtr = VmGetPTEPtr(newSegPtr, page);
	if ((*ptePtr & VM_COR_BIT) &&
	    Vm_GetPageFrame(*ptePtr) == segPtr->segNum) {
	    if (mastSegPtr != (Vm_Segment *)NIL) {
		*ptePtr &= ~VM_PAGE_FRAME_FIELD;
		*ptePtr |= mastSegPtr->segNum;
		*othersPtr = TRUE;
	    } else {
		mastSegPtr = newSegPtr;
d830 10
a839 5
	ptePtr = VmGetPTEPtr(childSegPtr, page);
	if ((*ptePtr & VM_COR_BIT) &&
	    Vm_GetPageFrame(*ptePtr) == mastSegPtr->segNum) {
	    UNLOCK_MONITOR;
	    return;
@


8.2
log
@mary's change for sun4 vm_CanCow = FALSE.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmCOW.c,v 8.1 88/12/04 15:50:28 ouster Exp Locker: mgbaker $ SPRITE (Berkeley)";
a95 3
#ifdef sun4
Boolean	vm_CanCOW = FALSE;
#else
a96 1
#endif sun4
@


8.1
log
@Stop using obsolete header files.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmCOW.c,v 8.0 88/11/11 18:42:11 douglis Stable Locker: ouster $ SPRITE (Berkeley)";
d96 3
d100 1
@


8.0
log
@Changing version numbers.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmCOW.c,v 6.2 88/10/28 18:18:22 mlgray Exp Locker: douglis $ SPRITE (Berkeley)";
d94 1
a94 2
#include "byte.h"
#include "mem.h"
@


6.2
log
@Converted to new C library.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: /sprite/src/kernel/vm/RCS/vmCOW.c,v 6.1 88/08/15 18:12:52 nelson Exp Locker: mlgray $ SPRITE (Berkeley)";
@


6.1
log
@Fixed lint errors and added some more tracing stuff for David Wood.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: vmCOW.c,v 1.14 88/07/17 17:19:23 nelson Exp $ SPRITE (Berkeley)";
d138 1
a138 1
    cowInfoPtr = (VmCOWInfo *)Mem_Alloc(sizeof(VmCOWInfo));
d141 1
a141 1
	Mem_Free((Address)cowInfoPtr);
d324 1
a324 1
	Mem_Free((Address)cowInfoPtr);
d388 1
a388 1
		Sys_Panic(SYS_FATAL, "VmCOWDeleteFromSeg: numCORPages < 0\n");
d396 1
a396 1
	Mem_Free((Address)cowInfoPtr);
d674 1
a674 1
	Mem_Free((Address)cowInfoPtr);
d728 1
a728 2
	    Sys_Panic(SYS_WARNING, "VmCOR: Couldn't read page, status <%x>\n",
				   status);
d736 1
a736 1
	Sys_Panic(SYS_FATAL, "COR: numCORPages < 0\n");
d920 1
a920 1
	Mem_Free((Address)cowInfoPtr);
d962 1
a962 1
	    Sys_Panic(SYS_FATAL, "COW: numCORPages < 0\n");
d1038 1
a1038 1
	Sys_Panic(SYS_FATAL, "COW: numCOWPages < 0\n");
d1199 1
a1199 1
    Byte_Copy(vm_PageSize, srcMappedAddr, destMappedAddr);
@


6.0
log
@Changing version numbers.
@
text
@d518 1
a518 1
			    &clearCOW, TRUE);
@


1.14
log
@Fixed a bug in VmCOWCopySeg.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: vmCOW.c,v 1.13 88/07/12 19:53:04 nelson Exp $ SPRITE (Berkeley)";
@


1.13
log
@Lint error fixes and more tracing.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: vmCOW.c,v 1.12 88/05/04 17:25:51 nelson Exp $ SPRITE (Berkeley)";
d295 4
a304 4
    cowInfoPtr = (VmCOWInfo *)NIL;
    if (!COWStart(segPtr, &cowInfoPtr)) {
	return(SUCCESS);
    }
d312 1
@


1.12
log
@Removed calls to old machine header files.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: vmCOW.c,v 1.11 88/02/08 15:58:15 nelson Exp $ SPRITE (Berkeley)";
d87 1
d271 1
a271 1
 *	Make of the copy of the given segment.  This includes handling all
d512 7
a678 2
Boolean	cowStop = FALSE;

a706 4
    if (cowStop && virtAddrPtr->page == 
	virtAddrPtr->segPtr->offset + virtAddrPtr->segPtr->numPages - 1) {
	Sys_Panic(SYS_FATAL, "COR stop\n");
    }
d743 1
d840 12
a956 4
    if (cowStop && virtAddrPtr->page == 
	virtAddrPtr->segPtr->offset + virtAddrPtr->segPtr->numPages - 1) {
	Sys_Panic(SYS_FATAL, "COW stop\n");
    }
d1000 2
a1001 1
	    VmCopySwapPage(virtAddrPtr->segPtr, virtAddrPtr->page, mastSegPtr);
d1022 12
d1087 12
d1112 2
d1115 10
d1153 12
@


1.11
log
@Fixed bug where it was leaving the copy in progress flag set
when it should have reset things.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: vmCOW.c,v 1.10 88/02/03 14:15:54 nelson Exp $ SPRITE (Berkeley)";
a94 1
#include "machine.h"
@


1.10
log
@Now COR fault handler checks to see if the master seg has no more children
copy-on-write off of it.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: vmCOW.c,v 1.9 88/01/17 18:21:07 nelson Exp $ SPRITE (Berkeley)";
d168 1
a168 1
{
d293 1
a293 1
    ReturnStatus		status;
d315 1
a315 1
		return(status);
d325 1
a325 1
    return(SUCCESS);
d658 3
a660 1
	return(SUCCESS);
a662 2
    status = COR(virtAddrPtr, ptePtr);

d728 1
d899 2
a900 1
	return;
a901 6

    if (!IsResident(ptePtr)) {
	return;
    }

    COW(virtAddrPtr, ptePtr, TRUE, FALSE);
@


1.9
log
@Only sets page protection for pages that have the resident bit set.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: vmCOW.c,v 1.8 88/01/08 15:52:07 nelson Exp $ SPRITE (Berkeley)";
d111 1
d745 1
d788 70
@


1.8
log
@Added prefetch.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: vmCOW.c,v 1.7 88/01/04 14:00:12 nelson Exp $ SPRITE (Berkeley)";
a222 1
	    virtAddr.page = virtPage;
d224 4
a227 1
	    VmMach_SetPageProt(&virtAddr, *srcPTEPtr);
@


1.7
log
@Added ability to measure the number of copy-on-ref pages that eventually
got modified.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: vmCOW.c,v 1.6 87/12/17 18:45:35 nelson Exp $ SPRITE (Berkeley)";
d239 7
a245 2
	vmStat.numCOWPages += numCOWPages;
	vmStat.numCORPages += numCORPages;
d642 5
a646 1
    vmStat.numCORFaults++;
d704 1
a704 1
    virtFrameNum = VmPageAllocate(virtAddrPtr, TRUE);
d811 5
a815 1
    vmStat.numCOWFaults++;
d905 1
a905 1
		virtFrameNum = VmPageAllocate(&virtAddr, TRUE);
@


1.6
log
@Fixed bug in keeping track of resident pages.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: vmCOW.c,v 1.5 87/12/15 15:20:05 nelson Exp $ SPRITE (Berkeley)";
d688 1
d724 5
d730 2
a731 1
			 VM_REFERENCED_BIT | VM_MODIFIED_BIT | virtFrameNum));
@


1.5
log
@Comments.
@
text
@d79 1
a79 1
static char rcsid[] = "$Header: vmCOW.c,v 1.4 87/12/12 16:26:02 nelson Exp $ SPRITE (Berkeley)";
a722 1
    virtAddrPtr->segPtr->resPages++;
a891 1
		mastSegPtr->resPages++;
d966 2
d1017 3
@


1.4
log
@More work on moving out machine dependent stuff.
@
text
@d8 1
a8 1
 * of some initial segment, including childre, grandchildren, etc.  Each page
d15 1
a15 4
 * protection bits in the PTE.  If the page is COW, the protection is set to
 * VM_UR_PROT.  If the page is COR, then the protection is set to VM_KRW_PROT.
 * If the page is neither, then the protection is VM_URW_PROT.  Note that
 * only heap and stack segments are ever copy-on-write.
d50 3
a52 2
 * assumed that the segment cannot have ranges of virtual addresses validated
 * or invalidated from the segment.  Also only one operation can occur to a
d55 2
a56 3
 * reference (VmCOWInfo).  Since only one operation can happen at a time and a
 * segment's virtual address space cannot be mucked with, this greatly 
 * simplifies the code.
d79 1
a79 1
static char rcsid[] = "$Header: vmCOW.c,v 1.3 87/12/11 13:26:33 nelson Exp $ SPRITE (Berkeley)";
d119 2
a120 1
 *	that this routine is called with the source segment not expandable.
d126 1
a126 1
 *	None.
d266 1
a266 1
 *	calling segment cannot be expanded.
d272 1
a272 1
 *	None.
d328 1
a328 3
 *	the segment not expandable.  It does not modify the protection
 *	in the page table under the assumption that the caller will clean
 *	things up in the page table.
d457 72
d537 2
a538 1
 *	None.
a613 72
 * COWEnd --
 *
 *	Clean up after a copy-on-write or copy-on-ref has happened.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	*cowInfoPtrPtr is set to point to COW info struct to free if there
 *	are no segments left COW.
 *
 *----------------------------------------------------------------------
 */
ENTRY static void
COWEnd(segPtr, cowInfoPtrPtr)
    register	Vm_Segment	*segPtr;	 /* Segment that was involved
						  * in the COW or COR. */
    VmCOWInfo			**cowInfoPtrPtr; /* Set to point to a COW
						  * info struct to free. */
{
    register	VmCOWInfo	*cowInfoPtr;


    LOCK_MONITOR;

    cowInfoPtr = segPtr->cowInfoPtr;
    cowInfoPtr->copyInProgress = FALSE;
    Sync_Broadcast(&cowInfoPtr->condition);
    if (segPtr->numCOWPages == 0 && segPtr->numCORPages == 0) {
	List_Remove((List_Links *)segPtr);
	segPtr->cowInfoPtr = (VmCOWInfo *)NIL;
	cowInfoPtr->numSegs--;
    }
    if (cowInfoPtr->numSegs == 0) {
	*cowInfoPtrPtr = cowInfoPtr;
    } else if (cowInfoPtr->numSegs == 1) {
	register Vm_Segment	*cowSegPtr;
	register Vm_PTE		*ptePtr;
	int			firstPage;
	int			lastPage;
	register int		i;
	/*
	 * Only one segment left.  Return this segment back to normal
	 * protection and clean up.
	 */
	*cowInfoPtrPtr = cowInfoPtr;
	cowSegPtr = (Vm_Segment *)List_First(&cowInfoPtr->cowList);
	cowSegPtr->cowInfoPtr = (VmCOWInfo *)NIL;
	if (cowSegPtr->type == VM_STACK) {
	    firstPage = mach_LastUserStackPage - cowSegPtr->numPages + 1;
	} else {
	    firstPage = cowSegPtr->offset;
	}
	lastPage = firstPage + cowSegPtr->numPages - 1;
	for (ptePtr = VmGetPTEPtr(cowSegPtr, firstPage),
		i = cowSegPtr->numPages;
	     i > 0;
	     i--, VmIncPTEPtr(ptePtr, 1)) {
	    *ptePtr &= ~(VM_COW_BIT | VM_COR_BIT);
	}
	VmMach_SetSegProt(cowSegPtr, firstPage, lastPage, TRUE);
	cowSegPtr->numCORPages = 0;
	cowSegPtr->numCOWPages = 0;
    }

    UNLOCK_MONITOR;
}


/*
 *----------------------------------------------------------------------
 *
d618 1
a618 1
 *	segment is not-expandable.
d736 1
a736 1
 *	Return the page frame from the master segments page table
d1012 1
@


1.3
log
@New VM system where put machine dependent VM stuff into the SUN module.
@
text
@d82 1
a82 1
static char rcsid[] = "$Header: vmCOW.c,v 1.2 87/11/20 18:29:36 nelson Exp $ SPRITE (Berkeley)";
d100 1
a100 1
Boolean	vm_CanCOW = FALSE;
d491 1
a491 1
	    VmGetPageFrame(*ptePtr) == segPtr->segNum) {
d530 1
a530 1
	VmLockPageInt(VmGetPageFrame(*ptePtr));
d696 1
a696 1
    mastSegPtr = VmGetSegPtr((int) (VmGetPageFrame(*ptePtr)));
d763 1
a763 1
	pf = VmGetPageFrame(*mastPTEPtr);
d890 1
a890 1
		CopyPage(VmGetPageFrame(*ptePtr), virtFrameNum);
d899 1
a899 1
		VmUnlockPage(VmGetPageFrame(*ptePtr));
d974 1
a974 1
    pageFrame = VmGetPageFrame(*srcPTEPtr);
d976 1
a976 1
    *destPTEPtr = *srcPTEPtr;
d989 1
a989 1
    VmPageSwitch(VmGetPageFrame(*destPTEPtr), destSegPtr);
@


1.2
log
@More copy-on-write stuff
@
text
@d82 1
a82 1
static char rcsid[] = "$Header: vmCOW.c,v 1.1 87/11/18 21:52:39 nelson Exp $ SPRITE (Berkeley)";
d87 1
a87 1
#include "vmMachInt.h"
a93 1
#include "machine.h"
d97 2
d100 1
a100 1
Boolean	vm_CanCOW = TRUE;
d104 1
d113 1
a113 1
int		GetMasterPF();
a114 3
Vm_PTE	resPTE;
Vm_PTE	swapPTE;

a118 30
 * VmCOWInit --
 *
 *	Initialize copy-on-write.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Page table entry setup.
 *
 *----------------------------------------------------------------------
 */
void
VmCOWInit()
{
    resPTE = vm_ZeroPTE;
    resPTE.validPage = 1;
    resPTE.resident = 1;
    resPTE.referenced = 1;
    resPTE.modified = 1;
    resPTE.protection = VM_URW_PROT;
    swapPTE = vm_ZeroPTE;
    swapPTE.validPage = 1;
    swapPTE.onSwap = 1;
}


/*
 *----------------------------------------------------------------------
 *
d176 2
a177 1
    VmVirtAddr		virtAddr;
a178 1
    Vm_PTE		corPTE;
d182 1
a182 4
    corPTE = vm_ZeroPTE;
    corPTE.validPage = 1;
    corPTE.protection = VM_KRW_PROT;
    corPTE.pfNum = srcSegPtr->segNum;
d190 2
a191 2
	virtPage = MACH_LAST_USER_STACK_PAGE - srcSegPtr->numPages + 1;
	lastPage = MACH_LAST_USER_STACK_PAGE;
d200 2
a201 2
	if (!srcPTEPtr->validPage) {
	    *destPTEPtr = vm_ZeroPTE;
d204 1
a204 1
	while (srcPTEPtr->inProgress) {
d207 1
a207 17
	if (srcPTEPtr->protection == VM_URW_PROT) {
	    if (srcPTEPtr->resident || srcPTEPtr->onSwap) {
		/*
		 * Need to make the src copy-on-write and the dest copy-on-ref.
		 */
		virtAddr.page = virtPage;
		VmSetPageProtInt(&virtAddr, srcPTEPtr, VM_UR_PROT);
		numCOWPages++;
		*destPTEPtr = corPTE;
		numCORPages++;
	    } else {
		/*
		 * Just a normal everyday pte (zerofill or load from FS).
		 */
		*destPTEPtr = *srcPTEPtr;
	    }
	} else if (srcPTEPtr->protection == VM_UR_PROT) {
d214 1
a214 1
	} else {
d221 15
d278 1
a278 1
void
d284 1
a284 1
    VmVirtAddr			virtAddr;
d287 1
d290 1
a290 1
	firstPage = MACH_LAST_USER_STACK_PAGE - segPtr->numPages + 1;
d297 1
a297 1
	return;
d304 1
a304 10
	if (!ptePtr->validPage || ptePtr->protection == VM_URW_PROT) {
	    /*
	     * Page isn't valid or it is not COW or COR.
	     */
	    continue;
	}
	if (ptePtr->protection == VM_UR_PROT) {
	    /*
	     * This page is copy-on-write.
	     */
d306 5
a310 5
	} else {
	    /*
	     * This page is copy-on-reference.
	     */
	    COR(&virtAddr, ptePtr);
d319 1
a351 1
    register	Vm_Segment	*mastSegPtr;
d354 1
a354 1
    VmVirtAddr			virtAddr;
d362 1
a362 1
	    firstPage = MACH_LAST_USER_STACK_PAGE - segPtr->numPages + 1;
d377 1
a377 10
	if (!ptePtr->validPage || ptePtr->protection == VM_URW_PROT) {
	    /*
	     * Page isn't valid or it is not COW or COR.
	     */
	    continue;
	}
	if (ptePtr->protection == VM_UR_PROT) {
	    /*
	     * Page is copy-on-write.
	     */
d380 1
a380 4
	} else {
	    /*
	     * Page is copy-on-reference.
	     */
d382 3
d490 2
a491 2
	if (ptePtr->validPage && ptePtr->protection == VM_KRW_PROT &&
	    ptePtr->pfNum == segPtr->segNum) {
d493 2
a494 1
		ptePtr->pfNum = mastSegPtr->segNum;
d529 2
a530 2
    if (ptePtr->resident) {
	VmLockPageInt(VmPhysToVirtPage(ptePtr->pfNum));
a540 1

d567 1
d581 5
a585 3
	Vm_Segment	*cowSegPtr;
	int		firstPage;

d594 1
a594 1
	    firstPage = MACH_LAST_USER_STACK_PAGE - cowSegPtr->numPages + 1;
d598 8
a605 3
	VmSetSegProtInt(cowSegPtr, firstPage, 
			firstPage + cowSegPtr->numPages - 1,
		        VM_URW_PROT, TRUE);
d634 1
a634 1
    register	VmVirtAddr	*virtAddrPtr;
d647 1
a647 1
    if (ptePtr->protection != VM_KRW_PROT) {
d663 1
d684 1
a684 1
    register	VmVirtAddr	*virtAddrPtr;
d688 2
a689 2
    int				virtFrameNum;
    int				mastVirtPF;
a690 1
    Vm_PTE			pte;
d692 5
a696 1
    mastSegPtr = VmGetSegPtr(ptePtr->pfNum);
d699 1
a699 1
    if (mastVirtPF > 0) {
d709 1
a709 1
	VmVirtAddr	virtAddr;
d723 6
a728 3
    pte = resPTE;
    pte.pfNum = VmVirtToPhysPage(virtFrameNum);
    SetPTE(virtAddrPtr, pte);
d751 1
a751 1
ENTRY int
d756 1
a756 1
    int			pf;
d762 2
a763 2
    if (mastPTEPtr->resident) {
	pf = VmPhysToVirtPage(mastPTEPtr->pfNum);
d794 1
a794 1
    register	VmVirtAddr	*virtAddrPtr;
a797 2
    register	Vm_Segment	*mastSegPtr;
    Boolean			others;
d806 1
a806 1
    if (ptePtr->protection != VM_UR_PROT) {
d842 1
a842 1
    register	VmVirtAddr	*virtAddrPtr;	/* Virtual address to copy.*/
d852 1
a852 1
    VmVirtAddr			virtAddr;
d854 1
a854 1
    int				virtFrameNum;
d857 4
d865 3
d883 1
a883 1
		GiveAwayPage(virtAddrPtr->segPtr, virtAddrPtr->page,
d890 7
a896 4
		CopyPage(VmPhysToVirtPage(ptePtr->pfNum), virtFrameNum);
		pte = resPTE;
		pte.pfNum = VmVirtToPhysPage(virtFrameNum);
		pte.protection = others ? VM_UR_PROT : VM_URW_PROT;
d899 1
a899 1
		VmUnlockPage(VmPhysToVirtPage(ptePtr->pfNum));
d906 4
a909 2
	    pte = swapPTE;
	    pte.protection = others ? VM_UR_PROT : VM_URW_PROT;
d922 2
a923 2
     * Change callers protection back to normal if the pte is not being 
     * deleted.  No need to waste our time otherwise.
d925 2
a926 6
    if (!deletePage) {
	/*
	 * Change callers protection back to normal if the pte is still valid.
	 * No need to waste our time otherwise.
	 */
	VmSetPageProt(virtAddrPtr, ptePtr, VM_URW_PROT);
d929 3
d953 1
a953 1
GiveAwayPage(srcSegPtr, virtPage, destSegPtr, others)
d956 2
d963 5
a967 2
    VmVirtAddr	virtAddr;
    Vm_PTE	pte;
d974 7
a980 5
    pte = VmGetPTE(&virtAddr);
    VmPageInvalidateInt(&virtAddr);
    virtAddr.segPtr = destSegPtr;
    if (!others) {
	pte.protection = VM_URW_PROT;
d982 8
a989 2
    VmSetPTE(&virtAddr, pte, TRUE);
    VmPageSwitch(VmPhysToVirtPage(pte.pfNum), destSegPtr);
d1011 1
a1011 1
    VmVirtAddr	*virtAddrPtr;
d1014 1
d1017 2
a1018 1
    VmSetPTE(virtAddrPtr, pte, pte.resident);
d1041 2
a1042 2
    int	srcPF;
    int	destPF;
d1049 1
a1049 1
    Byte_Copy(VM_PAGE_SIZE, srcMappedAddr, destMappedAddr);
d1052 27
@


1.1
log
@Initial revision
@
text
@d4 73
a76 2
 *      This file contains routines that implement copy-on-write.
 *	
d82 1
a82 1
static char rcsid[] = "$Header: vmPage.c,v 5.6 87/10/27 17:07:52 nelson Exp $ SPRITE (Berkeley)";
d109 3
d113 2
a114 1
Vm_PTE	cowPTE;
d135 9
a143 6
    cowPTE = vm_ZeroPTE;
    cowPTE.protection = VM_UR_PROT;
    cowPTE.validPage = 1;
    cowPTE.resident = 1;
    cowPTE.referenced = 1;
    cowPTE.modified = 1;
a184 2
 *	It is assumed that this routine is called with the source segment 
 *	not expandable.
d203 4
a206 2
    int			lastPage;
    int			destPage;
a207 1
    Boolean		isCOW = FALSE;
d209 1
a209 1
    int			i;
d213 5
d219 2
a220 2
	virtAddr.page = srcSegPtr->offset;
	lastPage = srcSegPtr->offset + srcSegPtr->numPages - 1;
d224 1
a224 1
	virtAddr.page = MACH_LAST_USER_STACK_PAGE - srcSegPtr->numPages + 1;
d226 2
a227 2
	srcPTEPtr = VmGetPTEPtr(srcSegPtr, virtAddr.page);
	destPTEPtr = VmGetDupPTEPtr(srcSegPtr, destSegPtr, virtAddr.page);
d230 4
a233 5
    for (virtAddr.segPtr = srcSegPtr;
	 virtAddr.page <= lastPage;
	 virtAddr.page++, VmIncPTEPtr(srcPTEPtr, 1), 
			  VmIncPTEPtr(destPTEPtr, 1)) {
	*destPTEPtr = vm_ZeroPTE;
d235 1
d241 17
a257 2
	destPTEPtr->validPage = 1;
	if (srcPTEPtr->protection == VM_UR_PROT) {
d262 3
a264 6
	    destPTEPtr->pfNum =  (unsigned int)srcSegPtr->segNum;
	    destPTEPtr->protection = VM_KRW_PROT;
	    destSegPtr->numCORPages++;
	    vmStat.numCORPages++;
	    isCOW = TRUE;
	} else if (srcPTEPtr->protection != VM_URW_PROT) {
a268 21
	    destPTEPtr->pfNum = srcPTEPtr->pfNum;
	    destPTEPtr->protection = VM_KRW_PROT;
	    destSegPtr->numCORPages++;
	    vmStat.numCORPages++;
	    isCOW = TRUE;
	} else if (srcPTEPtr->resident || srcPTEPtr->onSwap) {
	    /*
	     * Need to make the src copy-on-write and the dest copy-on-ref.
	     */
	    srcSegPtr->numCOWPages++;
	    vmStat.numCOWPages++;
	    VmSetPageProtInt(&virtAddr, srcPTEPtr, VM_UR_PROT);
	    destPTEPtr->pfNum = (unsigned int)srcSegPtr->segNum;
	    destPTEPtr->protection = VM_KRW_PROT;
	    destSegPtr->numCORPages++;
	    vmStat.numCORPages++;
	    isCOW = TRUE;
	} else {
	    /*
	     * Just a normal everyday pte (zerofill or load from FS).
	     */
d270 1
d275 5
a279 1
    if (isCOW) {
d298 1
a298 1
 * VmCOWDeleteFromSeg --
d300 4
a303 2
 *	Invalidate all cow or cor pages from the given range of pages in
 *	the given segment.
d309 1
a309 1
 *	All cow or cor pages in the given range of pages are invalidated.
d314 1
a314 1
VmCOWDeleteFromSeg(segPtr, firstPage, lastPage)
a315 6
    int				firstPage;	/* First page to delete. -1
						 * if want the lowest possible
						 * page. */
    int				lastPage;	/* Last page to delete. -1
						 * if want the highest possible
						 * page. */
a316 2
    register	Vm_Segment	*mastSegPtr;
    register	Vm_PTE		*mastPTEPtr;
d320 2
d323 4
a326 10
    if (firstPage == -1) {
	/*
	 * Caller wants to invalidate all page for this segment.
	 */
	if (segPtr->type == VM_STACK) {
	    firstPage = MACH_LAST_USER_STACK_PAGE - segPtr->numPages + 1;
	} else {
	    firstPage = segPtr->offset;
	}
	lastPage = firstPage + segPtr->numPages - 1;
d328 1
d333 2
a334 1
    virtAddr.page = firstPage;
a344 1
	    Boolean	others;
d348 1
a348 37
	    mastSegPtr = FindNewMasterSeg(segPtr, virtAddr.page, &others);
	    if (mastSegPtr != (Vm_Segment *)NIL) {
		if (IsResident(ptePtr)) {
		    /*
		     * Resident page.  Give it away to the new master.
		     */
		    GiveAwayPage(segPtr, virtAddr.page, mastSegPtr, others);
		    *ptePtr = vm_ZeroPTE;
		} else {
		    /*
		     * The page is on swap.  Copy it.  Note that we
		     * update the software page table entry here and then
		     * change the protection in hardware so that the page 
		     * can be faulted in.
		     */
		    vmStat.swapPagesCopied++;
		    VmCopySwapPage(segPtr, virtAddr.page, mastSegPtr);
		    mastPTEPtr = VmGetPTEPtr(mastSegPtr, virtAddr.page);
		    mastPTEPtr->onSwap = 1;
		    mastPTEPtr->pfNum = 0;
		    virtAddr.segPtr = mastSegPtr;
		    VmSetPageProt(&virtAddr, mastPTEPtr, 
				  others ? VM_UR_PROT : VM_URW_PROT);
		}
		mastSegPtr->numCORPages--;
		if (others) {
		    mastSegPtr->numCOWPages++;
		} else {
		    if (mastSegPtr->numCORPages == 0 && 
		        mastSegPtr->numCOWPages == 0) {
			mastSegPtr->cowInfoPtr->numSegs--;
			List_Remove((List_Links *)mastSegPtr);
			mastSegPtr->cowInfoPtr = (VmCOWInfo *)NIL;
		    }
		}
	    }
	    segPtr->numCOWPages--;
d353 1
a353 1
	    segPtr->numCORPages--;
d357 1
d368 1
a368 1
 * GiveAwayPage --
d370 5
a374 1
 *	Transfer a page from one segment to another.
d380 1
a380 2
 *	Source segments page table has the page zapped and the
 *	destination page table takes over ownership of the page.
d384 9
a392 6
ENTRY static void
GiveAwayPage(srcSegPtr, virtPage, destSegPtr, others)
    register	Vm_Segment	*srcSegPtr;
    int				virtPage;
    register	Vm_Segment	*destSegPtr;
    Boolean			others;
d394 4
a397 2
    VmVirtAddr	virtAddr;
    Vm_PTE	pte;
d399 40
a438 1
    LOCK_MONITOR;
d440 4
a443 8
    virtAddr.segPtr = srcSegPtr;
    virtAddr.page = virtPage;

    pte = VmGetPTE(&virtAddr);
    VmPageInvalidateInt(&virtAddr);
    virtAddr.segPtr = destSegPtr;
    if (!others) {
	pte.protection = VM_URW_PROT;
a444 6
    VmSetPTE(&virtAddr, pte);
    VmPageSwitch(VmPhysToVirtPage(pte.pfNum), destSegPtr);
    srcSegPtr->resPages--;
    destSegPtr->resPages++;

    UNLOCK_MONITOR;
d455 1
a455 1
 *	by a call to VmCOWDeleteFromSeg.
d529 2
a530 2
    Boolean			*othersPtr;	/* TRUE if there are other
						 * COW children. */
d664 2
a665 1
 *	truly COR then don't do anything.
d681 1
a681 4
    register	Vm_PTE		*mastPTEPtr;
    register	Vm_Segment	*mastSegPtr;
    Vm_Segment			*segPtr;
    int				virtFrameNum;
a682 2
    VmCOWInfo			*cowInfoPtr;
    VmVirtAddr			virtAddr;
a684 1
    segPtr = virtAddrPtr->segPtr;
d686 1
a686 1
    if (!COWStart(segPtr, &cowInfoPtr)) {
d688 1
a688 1
	return;
d690 1
a690 1
    ptePtr = VmGetPTEPtr(segPtr, virtAddrPtr->page);
d693 1
a693 1
	return;
d695 41
a736 1
    mastPTEPtr = VmGetPTEPtr(mastSegPtr, virtAddrPtr->page);
d738 2
a739 1
    if (IsResident(mastPTEPtr)) {
d743 2
a744 2
	CopyPage(VmPhysToVirtPage(mastPTEPtr->pfNum), virtFrameNum);
	VmUnlockPage(VmPhysToVirtPage(mastPTEPtr->pfNum));
d749 2
d753 1
d762 4
a765 9
    segPtr->numCORPages--;
    /*
     * Change the protection and such for this page.  Note that we don't
     * validate the page.  That is our callers job.
     */
    ptePtr->protection = VM_URW_PROT;
    ptePtr->pfNum = VmVirtToPhysPage(virtFrameNum);
    ptePtr->modified = 1;
    ptePtr->resident = 1;
d767 2
d770 34
a803 4
    cowInfoPtr = (VmCOWInfo *)NIL;
    COWEnd(segPtr, &cowInfoPtr);
    if (cowInfoPtr != (VmCOWInfo *)NIL) {
	Mem_Free((Address)cowInfoPtr);
d806 3
a808 1
    return(SUCCESS);
a832 1
    register	Vm_Segment	*segPtr;
d834 1
a835 2
    VmVirtAddr			virtAddr;
    VmCOWInfo			*cowInfoPtr;
d838 1
a838 2
    vmStat.numCOWFaults;
    segPtr = virtAddrPtr->segPtr;
d840 2
a841 2
    if (!COWStart(segPtr, &cowInfoPtr)) {
	vmStat.quickCOWFaults;
d844 1
a844 1
    ptePtr = VmGetPTEPtr(segPtr, virtAddrPtr->page);
d846 1
a846 1
	vmStat.quickCOWFaults;
d849 1
d854 44
a897 1
    mastSegPtr = FindNewMasterSeg(segPtr, virtAddrPtr->page, &others);
a898 6
	int	virtFrameNum;
	Vm_PTE	pte;

	/*
	 * Copy the page to the new master.
	 */
a899 6
	virtAddr.segPtr = mastSegPtr;
	virtAddr.page = virtAddrPtr->page;
	virtFrameNum = VmPageAllocate(&virtAddr, TRUE);
	CopyPage(VmPhysToVirtPage(ptePtr->pfNum), virtFrameNum);
	pte = cowPTE;
	pte.pfNum = VmVirtToPhysPage(virtFrameNum);
a901 2
	} else {
	    pte.protection = VM_URW_PROT;
d903 26
a928 12
	/*
	 * Atomically update the page table entry for the copy-on-write 
	 * child.  This has to be done under the monitor because the child
	 * could be executing as we modify its protection.
	 */
	SetPTE(&virtAddr, pte);
	VmUnlockPage(virtFrameNum);
	if (!others) {
	    if (mastSegPtr->numCORPages == 0 && mastSegPtr->numCOWPages == 0) {
		mastSegPtr->cowInfoPtr->numSegs--;
		List_Remove((List_Links *)mastSegPtr);
		mastSegPtr->cowInfoPtr = (VmCOWInfo *)NIL;
d930 8
d939 5
d945 1
a945 1
	vmStat.quickCOWFaults;
d949 2
a950 1
     * Change callers protection back to normal.
d952 6
a957 7
    VmSetPageProt(virtAddrPtr, ptePtr, VM_URW_PROT);
    segPtr->numCOWPages--;

    cowInfoPtr = (VmCOWInfo *)NIL;
    COWEnd(segPtr, &cowInfoPtr);
    if (cowInfoPtr != (VmCOWInfo *)NIL) {
	Mem_Free((Address)cowInfoPtr);
d959 1
d962 1
d967 45
d1031 1
a1031 1
    VmSetPTE(virtAddrPtr, pte);
@
