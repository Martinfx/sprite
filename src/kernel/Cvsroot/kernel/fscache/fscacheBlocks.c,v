head     9.29;
branch   ;
access   ;
symbols  ds3100:9.29 sun3:9.29 sprited:9.23.1 sun4nw:9.25 symm:9.25 spur:9.25 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.29
date     92.10.26.13.55.15;  author mgbaker;  state Exp;
branches ;
next     9.28;

9.28
date     92.06.01.15.29.30;  author kupfer;  state Exp;
branches ;
next     9.27;

9.27
date     92.05.07.17.01.19;  author kupfer;  state Exp;
branches ;
next     9.26;

9.26
date     92.03.06.11.54.09;  author mgbaker;  state Exp;
branches ;
next     9.25;

9.25
date     91.09.10.18.24.53;  author rab;  state Exp;
branches ;
next     9.24;

9.24
date     91.08.16.10.58.21;  author jhh;  state Exp;
branches ;
next     9.23;

9.23
date     91.06.27.12.34.40;  author mendel;  state Exp;
branches 9.23.1.1;
next     9.22;

9.22
date     91.03.09.17.35.28;  author kupfer;  state Exp;
branches ;
next     9.21;

9.21
date     91.01.26.15.32.43;  author mgbaker;  state Exp;
branches ;
next     9.20;

9.20
date     90.12.07.10.12.12;  author mendel;  state Exp;
branches ;
next     9.19;

9.19
date     90.10.19.15.42.12;  author mendel;  state Exp;
branches ;
next     9.18;

9.18
date     90.10.10.16.37.17;  author kupfer;  state Exp;
branches ;
next     9.17;

9.17
date     90.10.08.16.19.43;  author mendel;  state Exp;
branches ;
next     9.16;

9.16
date     90.07.20.15.26.59;  author shirriff;  state Exp;
branches ;
next     9.15;

9.15
date     90.05.18.12.10.00;  author shirriff;  state Exp;
branches ;
next     9.14;

9.14
date     90.05.14.13.18.40;  author douglis;  state Exp;
branches ;
next     9.13;

9.13
date     90.05.03.19.23.20;  author douglis;  state Exp;
branches ;
next     9.12;

9.12
date     90.05.03.19.18.39;  author mendel;  state Exp;
branches ;
next     9.11;

9.11
date     90.03.26.09.49.31;  author brent;  state Exp;
branches ;
next     9.10;

9.10
date     90.03.13.16.32.43;  author brent;  state Exp;
branches ;
next     9.9;

9.9
date     90.02.15.09.26.56;  author brent;  state Exp;
branches ;
next     9.8;

9.8
date     90.02.14.08.49.02;  author brent;  state Exp;
branches ;
next     9.7;

9.7
date     90.02.13.16.51.09;  author brent;  state Exp;
branches ;
next     9.6;

9.6
date     89.12.14.13.09.25;  author brent;  state Exp;
branches ;
next     9.5;

9.5
date     89.12.11.17.36.06;  author brent;  state Exp;
branches ;
next     9.4;

9.4
date     89.11.07.10.40.19;  author shirriff;  state Exp;
branches ;
next     9.3;

9.3
date     89.10.26.13.54.12;  author brent;  state Exp;
branches ;
next     9.2;

9.2
date     89.10.08.15.52.32;  author mendel;  state Exp;
branches ;
next     9.1;

9.1
date     89.09.18.13.51.59;  author brent;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.03.53;  author douglis;  state Stable;
branches ;
next     8.17;

8.17
date     89.08.21.15.23.38;  author mendel;  state Exp;
branches ;
next     8.16;

8.16
date     89.08.10.15.47.54;  author mendel;  state Exp;
branches ;
next     8.15;

8.15
date     89.06.15.09.05.59;  author brent;  state Exp;
branches ;
next     8.14;

8.14
date     89.06.12.09.19.51;  author brent;  state Exp;
branches ;
next     8.13;

8.13
date     89.05.30.16.10.28;  author jhh;  state Exp;
branches ;
next     8.12;

8.12
date     89.03.18.13.30.42;  author mgbaker;  state Exp;
branches ;
next     8.11;

8.11
date     89.03.03.08.12.24;  author brent;  state Exp;
branches ;
next     8.10;

8.10
date     89.02.19.22.03.00;  author jhh;  state Exp;
branches ;
next     8.9;

8.9
date     89.02.09.08.37.09;  author brent;  state Exp;
branches ;
next     8.8;

8.8
date     89.02.04.12.23.04;  author brent;  state Exp;
branches ;
next     8.7;

8.7
date     89.01.30.17.37.58;  author brent;  state Exp;
branches ;
next     8.6;

8.6
date     89.01.30.14.01.31;  author brent;  state Exp;
branches ;
next     8.5;

8.5
date     89.01.06.11.18.20;  author jhh;  state Exp;
branches ;
next     8.4;

8.4
date     89.01.04.08.49.57;  author brent;  state Exp;
branches ;
next     8.3;

8.3
date     88.12.07.11.36.02;  author brent;  state Exp;
branches ;
next     8.2;

8.2
date     88.11.30.15.10.49;  author brent;  state Exp;
branches ;
next     8.1;

8.1
date     88.11.26.11.34.47;  author brent;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.17.37;  author douglis;  state Stable;
branches ;
next     7.0;

7.0
date     88.11.11.15.29.10;  author brent;  state Exp;
branches ;
next     6.6;

6.6
date     88.09.14.12.35.36;  author nelson;  state Exp;
branches ;
next     6.5;

6.5
date     88.09.08.19.09.39;  author brent;  state Exp;
branches ;
next     6.4;

6.4
date     88.09.08.17.56.44;  author brent;  state Exp;
branches ;
next     6.3;

6.3
date     88.09.07.21.18.26;  author nelson;  state Exp;
branches ;
next     6.2;

6.2
date     88.08.31.12.03.53;  author brent;  state Exp;
branches ;
next     6.1;

6.1
date     88.08.18.17.58.12;  author brent;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.14.27;  author brent;  state Stable;
branches ;
next     1.7;

1.7
date     88.06.16.10.21.43;  author brent;  state Exp;
branches ;
next     1.6;

1.6
date     88.06.15.17.20.06;  author brent;  state Exp;
branches ;
next     1.5;

1.5
date     88.06.06.09.33.37;  author brent;  state Exp;
branches ;
next     1.4;

1.4
date     88.06.04.12.08.38;  author brent;  state Exp;
branches ;
next     1.3;

1.3
date     88.06.01.16.57.37;  author brent;  state Exp;
branches ;
next     1.2;

1.2
date     88.05.05.17.32.25;  author brent;  state Exp;
branches ;
next     1.1;

1.1
date     88.04.04.10.29.06;  author brent;  state Exp;
branches ;
next     ;

9.23.1.1
date     91.11.15.15.16.39;  author kupfer;  state Exp;
branches ;
next     ;


desc
@block cache manager
@


9.29
log
@New code to support recovery that ignores files without dirty cache blocks.
@
text
@/* 
 * fscacheBlocks.c --
 *
 *	Routines to manage the <file-id, block #> cache.
 *
 * Copyright 1987 Regents of the University of California.
 * All rights reserved.
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fscache/fscacheBlocks.c,v 9.28 92/06/01 15:29:30 kupfer Exp $ SPRITE (Berkeley)";
#endif not lint

#include	<sprite.h>
#include	<fs.h>
#include	<fsutil.h>
#include	<fscache.h>
#include	<fscacheBlocks.h>
#include	<fsStat.h>
#include	<fsNameOps.h>
#include	<fsdm.h>
#include	<fsio.h>
#include	<hash.h>
#include	<vm.h>
#include 	<vmMach.h>
#include	<proc.h>
#include	<sys.h>
#include	<rpc.h>
#include	<recov.h>


/*
 * There are numerous points of synchronization in this module.  The CacheInfo
 * struct in the handle, the block info struct and several global conditions
 * and variables are used.
 *
 *     1) Synchronization between a block being fetched and a block having
 *	  good data in it.  The FSCACHE_IO_IN_PROGRESS flag is used for this.
 *	  If this flag is set in the call to Fscache_FetchBlock then the fetch
 *	  will block until the block becomes unreferenced.  Thus if the block
 *	  is already being used the user won't get their data stomped on.
 *        Whenever Fscache_FetchBlock returns a block it sets the 
 *	  FSCACHE_IO_IN_PROGRESS flag in the block.  This flag will be cleared
 *	  whenever the block is released with Fscache_UnlockBlock or the
 *	  function Fscache_IODone is called.  While this flag is set in the
 *	  block all future fetches will block until the flag is cleared.
 *
 *     2) Synchronization for changing where a block lives on disk.  When a
 *	  block cleaner is writing out a block and Fscache_UnlockBlock is
 *	  called with a new location for the block, it blocks until the
 *	  block cleaner finishes.  The flag FSCACHE_BLOCK_BEING_WRITTEN in the
 *	  cache block struct indicates this.
 *
 *     3) Waiting for blocks from a file to be written back.  This is done by
 *	  waiting for the dirty list for the file to go empty.
 *
 *     4) Waiting for blocks from the whole cache to be written back.  We
 *	  keep track of the number of cache backends starts and wake the
 *	  waiting process when this number goes to zero.
 *
 *     5) Synchronizing informing the server when there are no longer any
 *	  dirty blocks in the cache for a file.  When the last dirty block
 *	  for a file is written the write is tagged saying that it is the
 *	  last dirty block.  However the server is also told when a file is
 *	  closed if no dirty blocks are left.  Since all writes out of the
 *	  cache are unsynchronized there is a race between the close and the
 *	  delayed write back.  This is solved by using the following 
 *	  synchronization.  When a file is closed the function 
 *	  Fscache_PreventWriteBacks is called.  This function will not return
 *	  until there are no block cleaners active on the file.  When it
 *	  returns it sets the FSCACHE_CLOSE_IN_PROGRESS flag in the cacheInfo
 *	  struct in the file handle and it returns the number of dirty blocks.
 *	  All subsequent block writes are blocked until the function
 *	  Fscache_AllowWriteBacks is called.  Thus the number of dirty blocks
 *	  in the cache for the file is accurate on close because no dirty
 *	  blocks can be written out while the file is being closed.
 *	  Likewise when a block cleaner writes out the last dirty block for
 *	  a file and it tells the server on the write that its the last
 *	  dirty block the server knows that it can believe the block cleaner
 *	  if the file is closed.  This is because if its closed then it must
 *	  have been closed when the  block cleaner did the write
 *	  (all closes are prohibited during the write) and thus there
 *	  is no way that more dirty blocks can be put into the cache.
 *	  If its open then the server ignores what the block cleaner
 *	  says because it will get told again when the file is closed.
 */

/*
 * Monitor lock.
 */
static Sync_Lock	cacheLock = Sync_LockInitStatic("Fs:blockCacheLock");
#define	LOCKPTR	&cacheLock

/*
 * Condition variables.
 */
Sync_Condition	cleanBlockCondition;	/* Condition that block 
						 * allocator waits on when all 
						 * blocks are dirty. */
Sync_Condition	writeBackComplete; 	/* Condition to wait on when 
						 * are waiting for the write 
						 * back of blocks in the cache 
						 * to complete. */
Sync_Condition	closeCondition;		/* Condition to wait on when
						 * are waiting for the block
						 * cleaner to finish to write
						 * out blocks for this file. */
static unsigned int filewriteBackTime;		/* Write back all blocks in
						 * the cache file 
						 * descriptors that were
						 * dirtied before this 
						 * time. */
static int	numBackendsActive;		/* Number of backend write back
					         * processes currently active.
				                 */
/*
 * Pointer to LRU list that is used for block allocation.
 */
static	List_Links	lruListHdr;
#define	lruList		(&lruListHdr)

/*
 * There are two free lists.  The first contains blocks that are in pages that
 * only contain free blocks.  The second contains blocks that are in pages that
 * contain non-free blocks.  When the physical pages size <= the block size then
 * the second list will always be empty.
 */
static	List_Links	totFreeListHdr;
#define	totFreeList	(&totFreeListHdr)
static	List_Links	partFreeListHdr;
#define	partFreeList	(&partFreeListHdr)

/*
 * Pointer to list of unmapped blocks.
 */
static	List_Links	unmappedListHdr;
#define	unmappedList	(&unmappedListHdr)

/*
 * List of Fscache_Backend's that could have file in the cache.
 * This list is kept so CacheWriteBack has a list of all the
 * backends that could have files in the cache. 
 */
static	List_Links	backendListHdr;
#define	backendList 	(&backendListHdr)

/*
 * Writes and reads can block on a full cache.  This list records the
 * processes that are blocked on this condition.
 */
List_Links fscacheFullWaitListHdr;
List_Links *fscacheFullWaitList = &fscacheFullWaitListHdr;

/*
 * Hash tables for blocks.
 */
static	Hash_Table	blockHashTableStruct;
static	Hash_Table	*blockHashTable = &blockHashTableStruct;

/*
 * The key to use for the block hash and a macro to set it.  The fact
 * that the key includes a pointer into the I/O handle for the block
 * means that this handle has to be kept around until there are no
 * blocks left in the cache.
 */
typedef	struct {
    Fscache_FileInfo *cacheInfoPtr;
    int		blockNumber;
} BlockHashKey;
#define	SET_BLOCK_HASH_KEY(blockHashKey, ZcacheInfoPtr, fileBlock) \
    (blockHashKey).cacheInfoPtr = ZcacheInfoPtr; \
    (blockHashKey).blockNumber = fileBlock;

/*
 * Miscellaneous variables.
 */
static	Address	blockCacheStart;	/* The address of the beginning of the
				   	   block cache. */
static	Address	blockCacheEnd;		/* The maximum virtual address for the 
					 * cache.*/
static	int	pageSize;		/* The size of a physical page. */
static	int	blocksPerPage;		/* Number of blocks in a page. */

static  int	numAvailBlocks;		/* Number of cache block available for 
					 * use without waiting. */
static  int	minNumAvailBlocks;	/* Minimum number of cache blocks to
					 * keep available. */

/*
 * Macros for large page sizes.
 *
 *	GET_OTHER_BLOCK		Return a pointer to the other block in
 *				the page given a pointer to one of the blocks.
 *	PAGE_IS_8K		Return true if the VM page size is 8K.
 */
#define GET_OTHER_BLOCK(blockPtr) \
    (((int) blockPtr->blockAddr & (pageSize - 1)) != 0) ?  \
		blockPtr - 1 : blockPtr + 1

#define	PAGE_IS_8K	(pageSize == 8192)

/*
 * External symbols.
 */

int	fscache_MaxBlockCleaners = FSCACHE_MAX_CLEANER_PROCS;

/*
 * Internal functions.
 */
static void CacheFileInvalidate _ARGS_((Fscache_FileInfo *cacheInfoPtr, 
			int firstBlock, int lastBlock));
static void DeleteBlockFromDirtyList _ARGS_((Fscache_Block *blockPtr));
static void StartFileSync _ARGS_((Fscache_FileInfo *cacheInfoPtr));
static void CacheWriteBack _ARGS_((unsigned int writeBackTime, 
			int *blocksSkippedPtr, Boolean writeTmpFiles));
static Boolean CreateBlock _ARGS_((Boolean retBlock,
			Fscache_Block **blockPtrPtr));
static Boolean DestroyBlock _ARGS_((Boolean retOnePage, int *pageNumPtr));
static Fscache_Block *FetchBlock _ARGS_((Boolean canWait, Boolean cantBlock));
	    /*
	     * Second parameter below is for ASPLOS measurements and can be
	     * removed after all that's over.  Mary 2/14/92
	     */
static void StartBackendWriteback _ARGS_((Fscache_Backend *backendPtr, Boolean fileFsynced));
static void PutOnFreeList _ARGS_((Fscache_Block *blockPtr));
static void PutFileOnDirtyList _ARGS_((Fscache_FileInfo *cacheInfoPtr,
			time_t oldestDirtyBlockTime));
static void PutBlockOnDirtyList _ARGS_((Fscache_Block *blockPtr, 
			Boolean onFront));
static Hash_Entry *GetUnlockedBlock _ARGS_((BlockHashKey *blockHashKeyPtr, 
			int blockNum));
static void DeleteBlock _ARGS_((Fscache_Block *blockPtr));


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_Init --
 *
 * 	Initialize the cache.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Hash tables initialized and memory allocated for the cache.
 *
 * ----------------------------------------------------------------------------
 */
void
Fscache_Init(blockHashSize)
    int	blockHashSize;	/* The number of hash table entries to put in the
			   block hash table for starters. */
{
    register	Address		blockAddr;
    Address			listStart;
    register	Fscache_Block	*blockPtr;
    register	int		i;

    Vm_FsCacheSize(&blockCacheStart, &blockCacheEnd);
    pageSize = Vm_GetPageSize();
    blocksPerPage = pageSize / FS_BLOCK_SIZE;
    /*
     * Currently the cache code only handles the case for 
     * (pageSize != FS_BLOCK_SIZE) when the block size is 4K and 
     * the page size 8K.
     */
    if (!((pageSize == FS_BLOCK_SIZE) ||
	  ((FS_BLOCK_SIZE == 4096) && PAGE_IS_8K))) {
	panic("Bad pagesize (%d) for file cache code\n", pageSize);
    }
    fs_Stats.blockCache.maxNumBlocks = 
			(blockCacheEnd - blockCacheStart + 1) / FS_BLOCK_SIZE;

    fs_Stats.blockCache.minCacheBlocks = FSCACHE_MIN_BLOCKS;
    fs_Stats.blockCache.maxCacheBlocks = fs_Stats.blockCache.maxNumBlocks;

    /*
     * Allocate space for the cache block list.
     */
    listStart = Vm_RawAlloc((int)fs_Stats.blockCache.maxNumBlocks *
			    sizeof(Fscache_Block));
    blockPtr = (Fscache_Block *) listStart;

    /*
     * Initialize the hash table.
     */
    Hash_Init(blockHashTable, blockHashSize, Hash_Size(sizeof(BlockHashKey)));

    /*
     * Initialize all lists.
     */
    List_Init(lruList);
    List_Init(totFreeList);
    List_Init(partFreeList);
    List_Init(backendList);
    List_Init(unmappedList);
    List_Init(fscacheFullWaitList);

    for (i = 0, blockAddr = blockCacheStart, 
		blockPtr = (Fscache_Block *)listStart;
	 i < fs_Stats.blockCache.maxNumBlocks; 
	 i++, blockPtr++, blockAddr += FS_BLOCK_SIZE) {
	blockPtr->flags = FSCACHE_NOT_MAPPED;
	blockPtr->blockAddr = blockAddr;
	blockPtr->refCount = 0;
	List_Insert(&blockPtr->useLinks, LIST_ATREAR(unmappedList));
    }
#ifdef sun4
    {
	/*
	 * Hack that allows VM to be backward compat with old block cache
	 * code.  This should have been removed by the time you see it.
	 */
	extern Boolean vmMachCanStealFileCachePmegs;
	vmMachCanStealFileCachePmegs = TRUE;
    }
#endif
    /*
     * Give enough blocks memory so that the minimum cache size requirement
     * is met.
     */
    fs_Stats.blockCache.numCacheBlocks = 0;
    while (fs_Stats.blockCache.numCacheBlocks < 
					fs_Stats.blockCache.minCacheBlocks) {
	if (!CreateBlock(FALSE, (Fscache_Block **) NIL)) {
	    printf("Fscacahe_Init: Couldn't create block\n");
	    fs_Stats.blockCache.minCacheBlocks = 
					fs_Stats.blockCache.numCacheBlocks;
	}
    }
    minNumAvailBlocks = fs_Stats.blockCache.minCacheBlocks/2;
    printf("FS Cache has %d %d-Kbyte blocks (%d max)\n",
	    fs_Stats.blockCache.minCacheBlocks, FS_BLOCK_SIZE / 1024,
	    fs_Stats.blockCache.maxNumBlocks);

}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_FileInfoInit --
 *
 * 	Initialize the cache information for a file.  Called when setting
 *	up a handle for a file that uses the block cache.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Set up the fields of the Fscache_FileInfo struct. First file may
 *	cause the backend to be initialized.
 *	
 * ----------------------------------------------------------------------------
 */
void
Fscache_FileInfoInit(cacheInfoPtr, hdrPtr, version, cacheable, attrPtr, 
		backendPtr)
    register Fscache_FileInfo *cacheInfoPtr;	/* Information to initialize. */
    Fs_HandleHeader	     *hdrPtr;		/* Back pointer to handle */
    int			     version;		/* Used to check consistency */
    Boolean		     cacheable;		/* TRUE if server says we can
						 * cache */
    Fscache_Attributes	     *attrPtr;		/* File attributes */
    Fscache_Backend	     *backendPtr;	/* Cache backend for
						 * this file. */
{
    List_InitElement(&cacheInfoPtr->links);
    List_Init(&cacheInfoPtr->dirtyList);
    List_Init(&cacheInfoPtr->blockList);
    List_Init(&cacheInfoPtr->indList);
    cacheInfoPtr->flags = (cacheable ? 0 : FSCACHE_FILE_NOT_CACHEABLE);
    cacheInfoPtr->version = version;
    cacheInfoPtr->hdrPtr = hdrPtr;
    cacheInfoPtr->blocksWritten = 0;
    cacheInfoPtr->noDirtyBlocks.waiting = 0;
    cacheInfoPtr->blocksInCache = 0;
    cacheInfoPtr->numDirtyBlocks = 0;
    cacheInfoPtr->lastTimeTried = 0;
    cacheInfoPtr->oldestDirtyBlockTime = Fsutil_TimeInSeconds();
    cacheInfoPtr->attr = *attrPtr;
    cacheInfoPtr->backendPtr = backendPtr;
    Sync_LockInitDynamic(&cacheInfoPtr->lock, "Fs:perFileCacheLock");
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_InfoSyncLockCleanup --
 *
 * 	Clean up Sync_Lock tracing for the cache lock.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Set up the fields of the Fscache_FileInfo struct.
 *
 * ----------------------------------------------------------------------------
 */
/*ARGSUSED*/
void
Fscache_InfoSyncLockCleanup(cacheInfoPtr)
    Fscache_FileInfo *cacheInfoPtr;
{
    Sync_LockClear(&cacheInfoPtr->lock);
}



/*
 *----------------------------------------------------------------------
 *
 * Fscache_RegisterBackend --
 *
 *	Allocate and initialize the Fscache_Backend data structure for a 
 *	cache backend.
 *
 * Results:
 *	The malloc'ed cache backend.
 *
 * Side effects:
 *	The backend is added to the backendList.
 *
 *----------------------------------------------------------------------
 */

Fscache_Backend *
Fscache_RegisterBackend(ioProcsPtr, clientData, flags)
    Fscache_BackendRoutines   *ioProcsPtr;
    ClientData	clientData;
    int	     flags;	/* Backend flags. */
{
    Fscache_Backend	*backendPtr;

    LOCK_MONITOR;

    backendPtr = (Fscache_Backend *) malloc(sizeof(Fscache_Backend));
    bzero((char *) backendPtr, sizeof(Fscache_Backend));

    List_Init((List_Links *)backendPtr);
    backendPtr->clientData = clientData;
    backendPtr->flags = flags;
    List_Init((List_Links *)&(backendPtr->dirtyListHdr));
    backendPtr->ioProcs = *ioProcsPtr;

    List_Insert((List_Links *)backendPtr, LIST_ATREAR(backendList));
    UNLOCK_MONITOR;
    return backendPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Fscache_UnregisterBackend --
 *
 *	Deallocate a Fscache_Backend data structure allocated with
 *	Fscache_RegisterBackend.
 *
 * Results:
 *
 * Side effects:
 *	Backend is removed from the list of active backends and its memory
 *	is freed.
 *
 *----------------------------------------------------------------------
 */

void
Fscache_UnregisterBackend(backendPtr)
    Fscache_Backend	*backendPtr; /* Backend to deallocate. */
{

    LOCK_MONITOR;

    if (!List_IsEmpty(&(backendPtr->dirtyListHdr))) {
	UNLOCK_MONITOR;
	panic("Fscache_UnregisterBackend: Backend has dirty files.\n");
	return;
    }
    List_Remove((List_Links *)backendPtr);
    /*
     * Until we get a better grip on the file handle code we can't free
     * the backendPtr because the cacheInfoPtr in the handle may still
     * point at it.  
     *
     * THIS IS A MEMORY LEAK - 48 bytes per backend unregistered. 
     * Currently this only happens when an LFS file system is 
     * unattached.
     */

#ifdef notdef
#ifndef CLEAN
    /*
     * NIL out these fields in hope in catching any bad code that
     * trys to use them.
     */
    backendPtr->clientData = (ClientData) NIL;
    backendPtr->ioProcs.allocate = (ReturnStatus (*)()) NIL;
    backendPtr->ioProcs.blockRead = (ReturnStatus (*)()) NIL;
    backendPtr->ioProcs.blockWrite = (ReturnStatus (*)()) NIL;
    backendPtr->ioProcs.reallocBlock = (void (*)()) NIL;
    backendPtr->ioProcs.startWriteBack = (ReturnStatus (*)()) NIL;
#endif /* not CLEAN */

    free((char *) backendPtr);
#endif /* notdef */

    UNLOCK_MONITOR;
    return;
}



/*
 * ----------------------------------------------------------------------------
 *
 *	Functions for external block access.  Includes functions to fetch,
 *	release and truncate cache blocks.
 *
 * ----------------------------------------------------------------------------
 */

/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_FetchBlock --
 *
 *	Return in *blockPtrPtr a pointer to a block in the 
 *	cache that corresponds to virtual block blockNum in the file 
 *	identified by *cacheInfoPtr.  If the block for the file is not in the 
 *	cache then *foundPtr is set to FALSE and if allocate is 
 *	TRUE, then a clean block is returned.  Otherwise a pointer to the 
 *	actual data block is returned and *foundPtr is set to TRUE.
 *	The block that is returned is locked down in the cache (i.e. it cannot
 *	be replaced) until it is unlocked by Fscache_UnlockBlock.  If the block
 *	isn't found or the FSCACHE_IO_IN_PROGRESS flag is given then the block
 *	is marked as IO in progress and must be either unlocked by 
 *	Fscache_UnlockBlock or marked as IO done by Fscache_IODone.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	New block may be allocated out of the block cache, block that 
 *	is returned is locked, and the block may be set as IO in progress.
 *
 * ----------------------------------------------------------------------------
 *
 */
static Fscache_Block *lostBlockPtr;

ENTRY void
Fscache_FetchBlock(cacheInfoPtr, blockNum, flags, blockPtrPtr, foundPtr)
    register Fscache_FileInfo *cacheInfoPtr; /* Pointer to the cache state 
				   * for the file. */
    int		 blockNum;	/* Virtual block number in the file. */
    int		 flags;		/* FSCACHE_DONT_BLOCK |
				 * FSCACHE_CANT_BLOCK |
				 * FSCACHE_READ_AHEAD_BLOCK |
				 * FSCACHE_IO_IN_PROGRESS
				 * plus the type of block */
    Fscache_Block **blockPtrPtr; /* Where pointer to cache block information
				 * structure is returned. The structure
				 * contains the virtual address of the 
				 * actual cache block. */
    Boolean	*foundPtr;	/* TRUE if the block is present in the
				 * cache, FALSE if not. */
{
    BlockHashKey		blockHashKey;
    register	Hash_Entry	*hashEntryPtr;
    register	Fscache_Block	*blockPtr;
    Fscache_Block		*otherBlockPtr;
    Fscache_Block		*newBlockPtr;
    time_t			refTime;
    Boolean		cantBlock = (flags & FSCACHE_CANT_BLOCK);
    Boolean		dontBlock = (flags & FSCACHE_DONT_BLOCK);

    LOCK_MONITOR;

    *blockPtrPtr = (Fscache_Block *)NIL;
    SET_BLOCK_HASH_KEY(blockHashKey, cacheInfoPtr, blockNum);

    do {
	/*
	 * Keep re-hashing until we get a block.  If we ever have to
	 * wait in this loop then the hash table can change out from
	 * under us, so we always rehash.
	 */
	hashEntryPtr = Hash_Find(blockHashTable, (Address) &blockHashKey);
	blockPtr = (Fscache_Block *) Hash_GetValue(hashEntryPtr);
	if (blockPtr != (Fscache_Block *) NIL) {
	    Boolean	blockBusy;
	    *foundPtr = TRUE;
	    if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
		UNLOCK_MONITOR;
		panic("Fscache_FetchBlock hashing error\n");
		*foundPtr = FALSE;
		return;
	    }
	    blockBusy = ((blockPtr->refCount > 0) || 
		    (blockPtr->flags & (FSCACHE_IO_IN_PROGRESS|
					FSCACHE_BLOCK_BEING_WRITTEN)));
	    if ( ((flags & FSCACHE_IO_IN_PROGRESS) && blockBusy) ||
		  (blockPtr->flags & FSCACHE_IO_IN_PROGRESS)) {
		if (!dontBlock) {
		    /*
		     * Wait until it becomes unlocked, or return
		     * found = TRUE and block = NIL if caller can't block.
		     */
		    (void)Sync_Wait(&blockPtr->ioDone, FALSE);
		}
		blockPtr = (Fscache_Block *)NIL;
	    } else {
		blockPtr->refCount++;
		if (blockPtr->refCount == 1) {
		    VmMach_LockCachePage(blockPtr->blockAddr);
		    if (!(blockPtr->flags & FSCACHE_BLOCK_DIRTY)) {
			numAvailBlocks--;
			if (numAvailBlocks < 0) {
			    panic("Fscache_FetchBlock numAvailBlocks < 0\n");
			}
		    }
		}
		if (flags & FSCACHE_IO_IN_PROGRESS) {
		    blockPtr->flags |= FSCACHE_IO_IN_PROGRESS;
		}
	    }
	} else {
	    /*
	     * Have to allocate a block.  If there is a free block use it, or
	     * take a block off of the lru list, or make a new one.
	     */
	    *foundPtr = FALSE;
	    if ((numAvailBlocks > minNumAvailBlocks) || cantBlock) {
		/*
		 * If we have enought blocks available take a free one.
		 */
		if (!List_IsEmpty(partFreeList)) {
		    /*
		     * Use partially free blocks first.
		     */
		    fs_Stats.blockCache.numFreeBlocks--;
		    fs_Stats.blockCache.partFree++;
		    blockPtr = USE_LINKS_TO_BLOCK(List_First(partFreeList));
		    List_Remove(&blockPtr->useLinks);
		} else if (!List_IsEmpty(totFreeList)) {
		    /*
		     * Can't find a partially free block so use a totally free
		     * block.
		     */
		    fs_Stats.blockCache.numFreeBlocks--;
		    fs_Stats.blockCache.totFree++;
		    blockPtr = USE_LINKS_TO_BLOCK(List_First(totFreeList));
		    List_Remove(&blockPtr->useLinks);
		    if (PAGE_IS_8K) {
			otherBlockPtr = GET_OTHER_BLOCK(blockPtr);
			List_Move(&otherBlockPtr->useLinks,
				      LIST_ATREAR(partFreeList));
		    }
		}
	    }
	    if (blockPtr == (Fscache_Block *) NIL) {
		/*
		 * Can't find any free blocks so have to use one of our blocks
		 * or create new ones.
		 */
		if (fs_Stats.blockCache.numCacheBlocks >= 
				    fs_Stats.blockCache.maxCacheBlocks) {
		    /*
		     * We can't have anymore blocks so reuse one of our own.
		     */
		    blockPtr = FetchBlock(!dontBlock, cantBlock);
		    if ((blockPtr == (Fscache_Block *) NIL) && cantBlock) {
			goto getBlock;
		    }
		} else {
		    /*
		     * Grow the cache if VM has an older page than we have.
		     */
		    refTime = Vm_GetRefTime();
		    blockPtr = USE_LINKS_TO_BLOCK(List_First(lruList));
		    if (blockPtr->timeReferenced > refTime) {
		getBlock:
			if (!CreateBlock(TRUE, &newBlockPtr)) {
			    blockPtr = FetchBlock(!dontBlock, cantBlock);
			} else {
			    fs_Stats.blockCache.unmapped++;
			    blockPtr = newBlockPtr;
			}
		    } else {
			/*
			 * We have an older block than VM's oldest page so reuse
			 * the block.
			 */
			blockPtr = FetchBlock(!dontBlock, cantBlock);
		    }
		}
	    }
	    /*
	     * If blockPtr is NIL we waited for room in the cache or
	     * for a busy cache block.  Now we'll retry all the various
	     * ploys to get a free block.
	     */
	}
    } while ((blockPtr == (Fscache_Block *)NIL) && !dontBlock);

    if ((*foundPtr == FALSE) && (blockPtr != (Fscache_Block *)NIL)) {
	cacheInfoPtr->blocksInCache++;
	blockPtr->cacheInfoPtr = cacheInfoPtr;
	blockPtr->refCount = 1;
	VmMach_LockCachePage(blockPtr->blockAddr);
	blockPtr->flags = flags & (FSCACHE_DATA_BLOCK | FSCACHE_IND_BLOCK |
				   FSCACHE_DESC_BLOCK | FSCACHE_DIR_BLOCK |
				   FSCACHE_READ_AHEAD_BLOCK);
	blockPtr->flags |= FSCACHE_IO_IN_PROGRESS;
	blockPtr->fileNum = cacheInfoPtr->hdrPtr->fileID.minor;
	blockPtr->blockNum = blockNum;
	blockPtr->blockSize = -1;
	blockPtr->timeDirtied = 0;
	blockPtr->timeReferenced = Fsutil_TimeInSeconds();
	*blockPtrPtr = blockPtr;
	if (Hash_GetValue(hashEntryPtr) != (char *)NIL) {
	    lostBlockPtr = (Fscache_Block *)Hash_GetValue(hashEntryPtr);
	    UNLOCK_MONITOR;
	    panic("Fscache_FetchBlock: hashEntryPtr->value changed\n");
	    LOCK_MONITOR;
	}
	Hash_SetValue(hashEntryPtr, blockPtr);
	List_Insert(&(blockPtr->useLinks), LIST_ATREAR(lruList));
	List_InitElement(&blockPtr->fileLinks);
	if (flags & FSCACHE_IND_BLOCK) {
	    List_Insert(&blockPtr->fileLinks, LIST_ATREAR(&cacheInfoPtr->indList));
	} else {
	    List_Insert(&blockPtr->fileLinks,LIST_ATREAR(&cacheInfoPtr->blockList));
	}
	numAvailBlocks--;
	if (numAvailBlocks < 0) {
	    panic("Fscache_FetchBlock numAvailBlocks < 0.\n");
	}
    }
    *blockPtrPtr = blockPtr;
    UNLOCK_MONITOR;
    return;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_IODone --
 *
 *	Remove the IO-in-progress flag from the cache block flags field.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The IO-in-progress flag is removed from the cache block flags field.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fscache_IODone(blockPtr)
    Fscache_Block *blockPtr;	/* Pointer to block information for block.*/
{
    LOCK_MONITOR;

    Sync_Broadcast(&blockPtr->ioDone);
    blockPtr->flags &= ~FSCACHE_IO_IN_PROGRESS;

    UNLOCK_MONITOR;
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_UnlockBlock --
 *
 *	Release the lock on the cache block pointed to by blockPtr.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The lock count of the block is decremented.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fscache_UnlockBlock(blockPtr, timeDirtied, diskBlock, blockSize, flags)
    Fscache_Block *blockPtr;	/* Pointer to block information for block
				   that is to be released. */
    time_t	 timeDirtied;	/* Time in seconds that the block was 
				   dirtied. */
    int		 diskBlock;	/* If not -1 is the block on disk where this
				   block resides.  For remote blocks this 
				   should be the same as blockPtr->blockNum.*/
    int		 blockSize;	/* The number of valid bytes in this block. */
    int		 flags;		/* FSCACHE_DELETE_BLOCK | FSCACHE_CLEAR_READ_AHEAD |
				 * FSCACHE_BLOCK_UNNEEDED | FSCACHE_DONT_WRITE_THRU
				 * FSCACHE_WRITE_TO_DISK | FSCACHE_BLOCK_BEING_CLEANED*/
{
    LOCK_MONITOR;

    if (blockPtr->flags & FSCACHE_BLOCK_FREE) {
	panic("Checking in free block\n");
    }

    if (blockPtr->flags & FSCACHE_IO_IN_PROGRESS) {
	Sync_Broadcast(&blockPtr->ioDone);
	blockPtr->flags &= ~FSCACHE_IO_IN_PROGRESS;
    }

    if (flags & FSCACHE_DELETE_BLOCK) {
	/*
	 * The caller is deleting this block from the cache.  Decrement the
	 * lock count and then invalidate the block.
	 */
	blockPtr->refCount--;
	if (blockPtr->refCount == 0) { 
	    VmMach_UnlockCachePage(blockPtr->blockAddr);
	    if (!(blockPtr->flags & 
			(FSCACHE_BLOCK_DIRTY|FSCACHE_BLOCK_BEING_WRITTEN))) {
		numAvailBlocks++;
		if (! List_IsEmpty(fscacheFullWaitList)) {
		    Fsutil_WaitListNotify(fscacheFullWaitList);
		}
		Sync_Broadcast(&cleanBlockCondition);
	    }
	}
	CacheFileInvalidate(blockPtr->cacheInfoPtr, blockPtr->blockNum, 
			    blockPtr->blockNum);
	UNLOCK_MONITOR;
	return;
    }

    if (flags & FSCACHE_CLEAR_READ_AHEAD) {
	blockPtr->flags &= ~FSCACHE_READ_AHEAD_BLOCK;
    }
    if (timeDirtied != 0) {
	if (flags & FSCACHE_BLOCK_BEING_CLEANED) {
	    blockPtr->cacheInfoPtr->flags |= FSCACHE_FILE_BEING_CLEANED;
	    blockPtr->flags |= FSCACHE_BLOCK_BEING_CLEANED;
	}
	if (!(blockPtr->flags & FSCACHE_BLOCK_DIRTY)) {
	    /*
	     * Increment the count of dirty blocks if the block isn't marked
	     * as dirty.  The block cleaner will decrement the count 
	     * after it cleans a block.
	     */
	    blockPtr->flags |= FSCACHE_BLOCK_DIRTY;
	    blockPtr->timeDirtied = timeDirtied;
	    if (!(blockPtr->flags & FSCACHE_BLOCK_BEING_WRITTEN)) { 
		blockPtr->cacheInfoPtr->numDirtyBlocks++;
		PutBlockOnDirtyList(blockPtr, FALSE);
	    }
	}
    }
    if (diskBlock != -1) {
	blockPtr->diskBlock = diskBlock;
	if (blockPtr->blockSize != blockSize) {
	    blockPtr->blockSize = blockSize;
	}
    } else if (blockPtr->blockSize == -1 && blockSize > 0) {
	/*
	 * Patch up the block size so our internal fragmentation
	 * calculation is correct.  The size of a read-only block
	 * is not used for anything else.
	 */
	blockPtr->blockSize = blockSize;
    }

    blockPtr->refCount--;
    if (blockPtr->refCount == 0) {
	/*
	 * Wake up anybody waiting for the block to become unlocked.
	 */
	Sync_Broadcast(&blockPtr->ioDone);
	VmMach_UnlockCachePage(blockPtr->blockAddr);
	if (!(blockPtr->flags & 
		(FSCACHE_BLOCK_DIRTY | FSCACHE_BLOCK_BEING_WRITTEN))) {
	    numAvailBlocks++;
	    if (! List_IsEmpty(fscacheFullWaitList)) {
		Fsutil_WaitListNotify(fscacheFullWaitList);
	    }
	    Sync_Broadcast(&cleanBlockCondition);
	}
	if (blockPtr->flags & FSCACHE_BLOCK_CLEANER_WAITING) {
	    /*
	     * Second parameter is for ASPLOS measurements and can be
	     * removed after all that's over.  Mary 2/14/92
	     */
	    StartBackendWriteback(blockPtr->cacheInfoPtr->backendPtr, FALSE);
	    blockPtr->flags &= ~FSCACHE_BLOCK_CLEANER_WAITING;
	}
	if (flags & FSCACHE_BLOCK_UNNEEDED) {
	    /*
	     * This block is unneeded so move it to the front of the LRU list
	     * and set its time referenced to zero so that it will be taken
	     * at the next convenience.
	     */
	    if (blockPtr->flags & FSCACHE_BLOCK_DIRTY) {
		blockPtr->flags |= FSCACHE_MOVE_TO_FRONT;
	    } else {
		List_Move(&blockPtr->useLinks, LIST_ATFRONT(lruList));
	    }
	    fs_Stats.blockCache.blocksPitched++;
	    blockPtr->timeReferenced = 0;
	} else {
	    /*
	     * Move it to the end of the lru list, mark it as being referenced. 
	     */
	    blockPtr->timeReferenced = Fsutil_TimeInSeconds();
	    blockPtr->flags &= ~FSCACHE_MOVE_TO_FRONT;
	    List_Move( &blockPtr->useLinks, LIST_ATREAR(lruList));
	}
    }

    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_BlockTrunc --
 *
 * 	Truncate the given cache block.  Used to set the blockSize in the
 *	cache block to reflect the actual amount of data in the block after
 *	a truncate.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	blockSize in block is changed.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY void
Fscache_BlockTrunc(cacheInfoPtr, blockNum, newBlockSize)
    Fscache_FileInfo *cacheInfoPtr;	/* Cache state of file. */
    int		blockNum;		/* Block to truncate. */
    int		newBlockSize;		/* New block size. */
{
    register Hash_Entry	     *hashEntryPtr;
    register Fscache_Block    *blockPtr;
    BlockHashKey	     blockHashKey;

    LOCK_MONITOR;

    SET_BLOCK_HASH_KEY(blockHashKey, cacheInfoPtr, 0);

    hashEntryPtr = GetUnlockedBlock(&blockHashKey, blockNum);
    if (hashEntryPtr != (Hash_Entry *) NIL) {
	blockPtr = (Fscache_Block *) Hash_GetValue(hashEntryPtr);

	if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
	    panic( "CacheBlockTrunc, hashing error\n");
	} else {
	    blockPtr->blockSize = newBlockSize;
	}
    }

    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
 *	Functions to perform some action on a file.  This includes write-back
 *	and invalidation.
 *
 * ----------------------------------------------------------------------------
 */

/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_FileInvalidate --
 *
 * 	This function removes from the cache all blocks for the file 
 *	identified by *filePtr in the range firstBlock to lastBlock.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All blocks in the cache for the file are removed.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fscache_FileInvalidate(cacheInfoPtr, firstBlock, lastBlock)
    Fscache_FileInfo *cacheInfoPtr;	/* Cache state of file to invalidate. */
    int		firstBlock;	/* First block to invalidate. Starts at zero. */
    int		lastBlock;	/* Last block to invalidate.  FSCACHE_LAST_BLOCK
				 * can be used if the caller doesn't know
				 * the exact last block of the file. */
{
    LOCK_MONITOR;

    if (lastBlock == FSCACHE_LAST_BLOCK) {
	if (cacheInfoPtr->attr.lastByte > 0) {
	    lastBlock = cacheInfoPtr->attr.lastByte / FS_BLOCK_SIZE;
	} else {
	    lastBlock = 0;
	}
    }
    CacheFileInvalidate(cacheInfoPtr, firstBlock, lastBlock);

    UNLOCK_MONITOR;
}



/*
 * ----------------------------------------------------------------------------
 *
 * CacheFileInvalidate --
 *
 * 	This function removes from the cache all blocks for the given file 
 *	identified in the range firstBlock to lastBlock.  If any blocks are 
 *	being written to disk, it will block until they have finished being
 *	written.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All blocks in the cache for the file are removed.
 *
 * ----------------------------------------------------------------------------
 */
INTERNAL static void
CacheFileInvalidate(cacheInfoPtr, firstBlock, lastBlock)
    Fscache_FileInfo	*cacheInfoPtr;	/* File to invalidate. */
    int			firstBlock;	/* First block to invalidate. */
    int			lastBlock;	/* Last block to invalidate. */
{
    register Hash_Entry	     *hashEntryPtr;
    register Fscache_Block    *blockPtr;
    BlockHashKey	     blockHashKey;
    int			     i;


    if (cacheInfoPtr->blocksInCache > 0) {
	SET_BLOCK_HASH_KEY(blockHashKey, cacheInfoPtr, 0);

	for (i = firstBlock; i <= lastBlock; i++) {
	    hashEntryPtr = GetUnlockedBlock(&blockHashKey, i);
	    if (hashEntryPtr == (Hash_Entry *) NIL) {
		continue;
	    }
	    blockPtr = (Fscache_Block *) Hash_GetValue(hashEntryPtr);
	    if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
		panic( "CacheFileInvalidate, hashing error\n");
		continue;
	    }

	    /*
	     * Remove it from the hash table.
	     */
	    cacheInfoPtr->blocksInCache--;
	    List_Remove(&blockPtr->fileLinks);
	    Hash_Delete(blockHashTable, hashEntryPtr);

	    /*
	     * Invalidate the block, including removing it from dirty list
	     * if necessary.
	     */
	    if (blockPtr->flags & FSCACHE_BLOCK_DIRTY) {
		cacheInfoPtr->numDirtyBlocks--;
		DeleteBlockFromDirtyList(blockPtr);
		numAvailBlocks++;
	    }
	    List_Remove(&blockPtr->useLinks);
	    PutOnFreeList(blockPtr);
	}
    }
    if (cacheInfoPtr->blocksInCache == 0) {
	cacheInfoPtr->flags &=
			~(FSCACHE_SERVER_DOWN | FSCACHE_NO_DISK_SPACE |
			  FSCACHE_DOMAIN_DOWN | FSCACHE_GENERIC_ERROR);
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 * DeleteBlockFromDirtyList --
 *
 * 	Delete the given block from the dirty list.  This is done when
 *	the file is being deleted.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If this is the last dirty block of a file then the file is
 *	removed from the file dirty list.  Also, if someone was waiting
 *	on the block the global writeBackComplete is notified.
 *
 * ----------------------------------------------------------------------------
 */
INTERNAL static void
DeleteBlockFromDirtyList(blockPtr)
    register	Fscache_Block	*blockPtr;
{
    register	Fscache_FileInfo	*cacheInfoPtr;

    cacheInfoPtr = blockPtr->cacheInfoPtr;
    List_Remove(&blockPtr->dirtyLinks);
    if ((cacheInfoPtr->flags & FSCACHE_FILE_ON_DIRTY_LIST) &&
        (cacheInfoPtr->numDirtyBlocks == 0) &&
	!(cacheInfoPtr->flags & FSCACHE_FILE_DESC_DIRTY)) {
	/*
	 * No more dirty blocks for this file.  Remove the file from the dirty
	 * list and wakeup anyone waiting for the file's list to become
	 * empty.
	 */
	List_Remove((List_Links *)cacheInfoPtr);
	cacheInfoPtr->flags &= ~(FSCACHE_FILE_ON_DIRTY_LIST|FSCACHE_FILE_FSYNC|FSCACHE_FILE_BEING_CLEANED);
	Sync_Broadcast(&cacheInfoPtr->noDirtyBlocks);
    }

}

/*
 *----------------------------------------------------------------------
 *
 * StartFileSync --
 *
 *	Start the process of syncing from the cache to the backend.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Backend may be started. File may be moved up the dirty list.
 *
 *----------------------------------------------------------------------
 */
static void
StartFileSync(cacheInfoPtr)
    Fscache_FileInfo	*cacheInfoPtr;
{
    register List_Links	*linkPtr;
    List_Links	*dirtyList, *place;

    dirtyList = &cacheInfoPtr->backendPtr->dirtyListHdr;

    /*
     * If the file has not already been synced, move the file up the
     * dirty list to the front or right behide the last synced file.
     */
    if (!(cacheInfoPtr->flags & FSCACHE_FILE_FSYNC)) {
	/*
	 * Move down the list until we reach the file or the first non
	 * synced file. 
	 */
	place = (List_Links *) cacheInfoPtr;
	LIST_FORALL(dirtyList, linkPtr) {
	    if ((linkPtr == (List_Links *) cacheInfoPtr) ||
		!(((Fscache_FileInfo *) linkPtr)->flags & FSCACHE_FILE_FSYNC)) {
		place = linkPtr;
		break;
	    }
	}
	cacheInfoPtr->flags |= FSCACHE_FILE_FSYNC;
	if (place != (List_Links *) cacheInfoPtr) {
	    List_Move((List_Links *)cacheInfoPtr, LIST_BEFORE(place));
	}
    }
    /*
     * The second parameter here is just for ASPLOS measurements and can
     * be removed after the ASPLOS conference (or after the paper is
     * rejected?).
     *
     * Mary 2/14/92
     */
    StartBackendWriteback(cacheInfoPtr->backendPtr, TRUE);
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_FileWriteBack --
 *
 * 	This function forces all blocks for the file identified by 
 *	*hdrPtr in the range firstBlock to lastBlock to disk (or 
 *	the server).
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All dirty blocks in the cache for the file are written out.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY ReturnStatus
Fscache_FileWriteBack(cacheInfoPtr, firstBlock, lastBlock, flags,
	blocksSkippedPtr)
    register Fscache_FileInfo *cacheInfoPtr;	/* State to force out. */
    int		firstBlock;	/* First block to write back. */
    int		lastBlock;	/* Last block to write back. */
    int		flags;		/* FSCACHE_FILE_WB_WAIT | FSCACHE_WRITE_BACK_INDIRECT |
				 * FSCACHE_WRITE_BACK_AND_INVALIDATE. 
				 * FSCACHE_WB_MIGRATION. */
    int		*blocksSkippedPtr; /* The number of blocks skipped
				      because they were locked. */
{
    register Hash_Entry	     *hashEntryPtr;
    register Fscache_Block    *blockPtr;
    BlockHashKey	     blockHashKey;
    int			     i;
    ReturnStatus	     status;
    Boolean		     fsyncFile;
    enum  {ENTIRE_FILE, SINGLE_BLOCK, MULTI_BLOCK_RANGE} rangeType;

    LOCK_MONITOR;

    *blocksSkippedPtr = 0;

    fsyncFile = FALSE;
    /* 
     * First classify the type of writeback being requests as either involving
     * a single file block, the entire file, or a multiple-block range.
     */
    if ((firstBlock == lastBlock) && (firstBlock >= 0)) {
	rangeType = SINGLE_BLOCK;
    } else if ((firstBlock == 0) && 
	        ((lastBlock == FSCACHE_LAST_BLOCK) || 
	        (lastBlock == cacheInfoPtr->attr.lastByte / FS_BLOCK_SIZE))) {
	rangeType = ENTIRE_FILE;
    } else {
	rangeType = MULTI_BLOCK_RANGE;
    }

    /*
     * Clear out the host down and no disk space flags so we can retry
     * for this file.
     */
    cacheInfoPtr->flags &= 
		    ~(FSCACHE_SERVER_DOWN | FSCACHE_NO_DISK_SPACE | 
		      FSCACHE_DOMAIN_DOWN | FSCACHE_GENERIC_ERROR);

    if ((cacheInfoPtr->blocksInCache == 0) ||
	(flags & FSCACHE_WRITE_BACK_DESC_ONLY)) {
	/*
	 * If file is on dirty list and has no blocks then it 
	 * descriptor is dirty.  Force the descriptor out 
	 * waiting if the user specified to.
	 */
	if ((cacheInfoPtr->flags & FSCACHE_FILE_ON_DIRTY_LIST) &&
	    (flags & FSCACHE_WRITE_BACK_DESC_ONLY)) {
	    StartFileSync(cacheInfoPtr);
	    if (flags & FSCACHE_FILE_WB_WAIT) {
		while (cacheInfoPtr->flags & FSCACHE_FILE_ON_DIRTY_LIST) {
			(void) Sync_Wait(&cacheInfoPtr->noDirtyBlocks, FALSE);
		}
	    }
	}
	UNLOCK_MONITOR;
	return(SUCCESS);
    }

    SET_BLOCK_HASH_KEY(blockHashKey, cacheInfoPtr, 0);

    if (lastBlock == FSCACHE_LAST_BLOCK) {
	if (cacheInfoPtr->attr.lastByte > 0) {
	    lastBlock = cacheInfoPtr->attr.lastByte / FS_BLOCK_SIZE;
	} else {
	    lastBlock = 0;
	}
    }
    blockPtr = (Fscache_Block *) NIL;
    for (i = firstBlock; i <= lastBlock; i++) {
	/*
	 * See if block is in the hash table.
	 */

	blockHashKey.blockNumber = i;
again:
	hashEntryPtr = Hash_LookOnly(blockHashTable, (Address) &blockHashKey);
	if (hashEntryPtr == (Hash_Entry *) NIL) {
	    continue;
	}

	blockPtr = (Fscache_Block *) Hash_GetValue(hashEntryPtr);

	if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
	    panic( "Fscache_FileWriteBack, hashing error\n");
	    UNLOCK_MONITOR;
	    return(FAILURE);
	}

	if (flags & (FSCACHE_WRITE_BACK_AND_INVALIDATE | FSCACHE_FILE_WB_WAIT)) {
	    /*
	     * Wait for the block to become unlocked.  If have to wait then
	     * must start over because the block could have been freed while
	     * we were sleeping.
	     */
	    if (blockPtr->refCount > 0) {
		(void) Sync_Wait(&blockPtr->ioDone, FALSE);
		if (sys_ShuttingDown) {
		    UNLOCK_MONITOR;
		    return(SUCCESS);
		}
		goto again;
	    }
	} else if (blockPtr->refCount > 0) {
	    /* 
	     * If the block is locked and we are not invalidating it, 
	     * skip the block because it might be being modified.
	     */
	    (*blocksSkippedPtr)++;
	    continue;
	}

	if (blockPtr->flags & (FSCACHE_BLOCK_DIRTY|FSCACHE_BLOCK_BEING_WRITTEN)) {
	    fsyncFile = TRUE;
	}
	if (flags & FSCACHE_WRITE_BACK_AND_INVALIDATE) {
	    if (blockPtr->flags & 
			(FSCACHE_BLOCK_DIRTY|FSCACHE_BLOCK_BEING_WRITTEN)) {
		/*
		 * Mark the block to be release by the block cleaner. We
		 * delete it from the hash table and remove it from the LRU
		 * list for the block cleaner. 
		 */
		if (!(blockPtr->flags & FSCACHE_BLOCK_DELETED)) { 
		    blockPtr->flags |= FSCACHE_BLOCK_DELETED;
		    Hash_Delete(blockHashTable, hashEntryPtr);
		    List_Remove( &blockPtr->useLinks);
		}
	    } else {
		/*
		 * The block is clean and not being written, We remove it
		 * from cache.
		 */
		cacheInfoPtr->blocksInCache--;
		List_Remove(&blockPtr->fileLinks);
		Hash_Delete(blockHashTable, hashEntryPtr);
		List_Remove(&blockPtr->useLinks);
		PutOnFreeList(blockPtr);
	    }
	} 
    }
    if ((cacheInfoPtr->flags & FSCACHE_FILE_ON_DIRTY_LIST) && fsyncFile) {
	StartFileSync(cacheInfoPtr);
    }

    /*
     * Wait until all blocks are written back.
     */
    if (flags & FSCACHE_FILE_WB_WAIT) {
	 if ((rangeType == SINGLE_BLOCK) && fsyncFile) {
	    while ((blockPtr->flags & 
		(FSCACHE_BLOCK_DIRTY|FSCACHE_BLOCK_BEING_WRITTEN)) && 
		   !(cacheInfoPtr->flags & 
			(FSCACHE_SERVER_DOWN | FSCACHE_NO_DISK_SPACE |
			 FSCACHE_DOMAIN_DOWN | FSCACHE_GENERIC_ERROR)) &&
		   !sys_ShuttingDown) {
		(void) Sync_Wait(&blockPtr->ioDone, FALSE);
	    }
	 } else { 
	    while ((cacheInfoPtr->flags & 
		    (FSCACHE_FILE_ON_DIRTY_LIST|FSCACHE_FILE_BEING_WRITTEN)) && 
		   !(cacheInfoPtr->flags & 
			(FSCACHE_SERVER_DOWN | FSCACHE_NO_DISK_SPACE |
			 FSCACHE_DOMAIN_DOWN | FSCACHE_GENERIC_ERROR)) &&
		   !sys_ShuttingDown) {
		(void) Sync_Wait(&cacheInfoPtr->noDirtyBlocks, FALSE);
	    }
	}
    }

    switch (cacheInfoPtr->flags&(FSCACHE_SERVER_DOWN|FSCACHE_NO_DISK_SPACE|
				 FSCACHE_DOMAIN_DOWN|FSCACHE_GENERIC_ERROR)) {
	case FSCACHE_SERVER_DOWN:
	    status = RPC_TIMEOUT;
	    break;
	case FSCACHE_NO_DISK_SPACE:
	    printf("%s couldn't write back <%d,%d> \"%s: %s\n",
		   "Fscache_FileWriteBack",
		   cacheInfoPtr->hdrPtr->fileID.major,
		   cacheInfoPtr->hdrPtr->fileID.major,
		   Fsutil_HandleName(cacheInfoPtr->hdrPtr),
		   "cache entry is marked as no-space"); /* DEBUG */
	    status = FS_NO_DISK_SPACE;
	    break;
	case FSCACHE_DOMAIN_DOWN:
	    status = FS_DOMAIN_UNAVAILABLE;
	    break;
	case FSCACHE_GENERIC_ERROR:
	    status = FS_INVALID_ARG;
	    break;
	default:
	    status = SUCCESS;
	    break;
    }

    UNLOCK_MONITOR;

    return(status);
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_BlocksUnneeded --
 *
 *	This function moves the blocks that span the given range of bytes to
 *	the front of the LRU list and marks them as not referenced.  This
 *	function is called by virtual memory after it has read in an object
 *	file block that it will cache in a sticky segment.  If we are the
 *	file server and are being called for an object file, then don't do 
 *	anything because other clients might need the blocks.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None here, see FscacheBlocksUnneeded.
 *	All blocks that span the given range of bytes are moved to the front of
 *	the LRU list and marked as not-referenced.
 *
 * ----------------------------------------------------------------------------
 *
 */
void
Fscache_BlocksUnneeded(streamPtr, offset, numBytes, objectFile)
    register Fs_Stream	*streamPtr;	/* File for which blocks are unneeded.*/
    int			offset;		/* First byte which is unneeded. */
    int			numBytes;	/* Number of bytes that are unneeded. */
    Boolean		objectFile;	/* TRUE if this is for an object 
					 * file.*/
{
    register Fscache_FileInfo *cacheInfoPtr;

    switch (streamPtr->ioHandlePtr->fileID.type) {
	case FSIO_LCL_FILE_STREAM: {
	    register Fsio_FileIOHandle *localHandlePtr;
	    if (objectFile) {
		/*
		 * Keep the blocks cached for remote clients.
		 */
		return;
	    }
	    localHandlePtr = (Fsio_FileIOHandle *)streamPtr->ioHandlePtr;
	    cacheInfoPtr = &localHandlePtr->cacheInfo;
	    break;
	}
	case FSIO_RMT_FILE_STREAM: {
	    register Fsrmt_FileIOHandle *rmtHandlePtr;
	    rmtHandlePtr = (Fsrmt_FileIOHandle *)streamPtr->ioHandlePtr;
	    cacheInfoPtr = &rmtHandlePtr->cacheInfo;
	    break;
	}
	default:
	    panic( "Fscache_BlocksUnneeded, bad stream type %d\n",
		streamPtr->ioHandlePtr->fileID.type);
	    return;
    }
    FscacheBlocksUnneeded(cacheInfoPtr, offset, numBytes);
}


/*
 * ----------------------------------------------------------------------------
 *
 * FscacheBlocksUnneeded --
 *
 *	This function moves the blocks that span the given range of bytes to
 *	the front of the LRU list and marks them as not referenced.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All blocks that span the given range of bytes are moved to the front of
 *	the LRU list and marked as not-referenced.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
FscacheBlocksUnneeded(cacheInfoPtr, offset, numBytes)
    register Fscache_FileInfo *cacheInfoPtr;	/* Cache state. */
    int			offset;		/* First byte which is unneeded. */
    int			numBytes;	/* Number of bytes that are unneeded. */
{
    register Hash_Entry		*hashEntryPtr;
    register Fscache_Block    	*blockPtr;
    BlockHashKey	     	blockHashKey;
    int			     	i;
    int				firstBlock;
    int				lastBlock;

    LOCK_MONITOR;

    if (cacheInfoPtr->blocksInCache == 0) {
	UNLOCK_MONITOR;
	return;
    }

    firstBlock = offset / FS_BLOCK_SIZE;
    lastBlock = (offset + numBytes - 1) / FS_BLOCK_SIZE;
    SET_BLOCK_HASH_KEY(blockHashKey, cacheInfoPtr, 0);

    for (i = firstBlock; i <= lastBlock; i++) {
	/*
	 * See if block is in the hash table.
	 */
	blockHashKey.blockNumber = i;
	hashEntryPtr = Hash_LookOnly(blockHashTable, (Address) &blockHashKey);
	if (hashEntryPtr == (Hash_Entry *) NIL) {
	    continue;
	}

	blockPtr = (Fscache_Block *) Hash_GetValue(hashEntryPtr);

	if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
	    panic( "CacheBlocksUnneeded, hashing error\n");
	    continue;
	}

	if (blockPtr->refCount > 0) {
	    /*
	     * The block is locked.  This means someone is doing something with
	     * it so we just skip it.
	     */
	    continue;
	}
	if (blockPtr->flags & 
			(FSCACHE_BLOCK_DIRTY|FSCACHE_BLOCK_BEING_WRITTEN)) {
	    /*
	     * Block is being cleaned.  Set the flag so that it will be 
	     * moved to the front after it has been cleaned.
	     */
	    blockPtr->flags |= FSCACHE_MOVE_TO_FRONT;
	} else {
	    /*
	     * Move the block to the front of the LRU list.
	     */
	    List_Move(&blockPtr->useLinks, LIST_ATFRONT(lruList));
	}
	fs_Stats.blockCache.blocksPitched++;
	/*
	 * Set time referenced to zero so this block will be taken as soon
	 * as needed.
	 */
	blockPtr->timeReferenced = 0;
    }

    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
 *	Functions to perform an action on the entire cache. 
 *
 * ----------------------------------------------------------------------------
 */

/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_WriteBack --
 *
 *	Force all dirty blocks in the cache that were dirtied before
 *	writeBackTime to disk (or the server).  
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All dirty blocks in the cache are written out.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fscache_WriteBack(writeBackTime, blocksSkippedPtr, writeBackAll)
    unsigned int writeBackTime;	   /* Write back all blocks that were 
				      dirtied before this time. */
    int		*blocksSkippedPtr; /* The number of blocks skipped
				      because they were locked. */
    Boolean	writeBackAll;	   /* Write back all files. */
{
    LOCK_MONITOR;
    CacheWriteBack(writeBackTime, blocksSkippedPtr, writeBackAll);

    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_Empty --
 *
 *	Write back and invalidate all unlocked blocks from the cache.
 *
 * Results:
 *	The number of locked blocks is returned in the argument.
 *
 * Side effects:
 *	All unlocked blocks are written back, if necessary, and invalidated.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fscache_Empty(numLockedBlocksPtr)
    int *numLockedBlocksPtr;
{
    int 			blocksSkipped;
    register	Fscache_Block	*blockPtr;
    register	List_Links	*nextPtr, *listPtr;

    LOCK_MONITOR;

    *numLockedBlocksPtr = 0;
    CacheWriteBack(-1, &blocksSkipped, TRUE);
    listPtr = lruList;
    nextPtr = List_First(listPtr);
    while (!List_IsAtEnd(listPtr, nextPtr)) {
	blockPtr = USE_LINKS_TO_BLOCK(nextPtr);
	nextPtr = List_Next(nextPtr);
	if (blockPtr->refCount > 0 || 
	    (blockPtr->flags & 
		(FSCACHE_BLOCK_DIRTY|FSCACHE_BLOCK_BEING_WRITTEN))) {
	    /* 
	     * Skip locked or dirty blocks.
	     */
	    (*numLockedBlocksPtr)++;
	} else {
	    List_Remove(&blockPtr->useLinks);
	    DeleteBlock(blockPtr);
	    PutOnFreeList(blockPtr);
	}
    }
    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
 * CacheWriteBack --
 *
 *	Force all dirty blocks in the cache that were dirtied before
 *	writeBackTime to disk (or the server).  If writeBackTime equals 
 *	-1 then all blocks are written back.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All dirty blocks in the cache are written out.
 *
 * ----------------------------------------------------------------------------
 *
 */
static INTERNAL void
CacheWriteBack(writeBackTime, blocksSkippedPtr, writeTmpFiles)
    unsigned int writeBackTime;	   /* Write back all blocks that were 
				      dirtied before this time. */
    int		*blocksSkippedPtr; /* The number of blocks skipped
				      because they were locked. */
    Boolean	writeTmpFiles;	   /* TRUE => write-back tmp files even though
				    *         they are marked as not being
				    *         written back. */
{
    register Fscache_FileInfo	*cacheInfoPtr;
    int				currentTime;
    Fscache_Backend		*backendPtr;

    currentTime = Fsutil_TimeInSeconds();

    *blocksSkippedPtr = 0;
    /*
     * Look thru all the cache backend`s dirty list for files to 
     * writeback.
     */
    filewriteBackTime = writeBackTime;
    LIST_FORALL(backendList, (List_Links *) backendPtr) {
	LIST_FORALL(&backendPtr->dirtyListHdr, (List_Links *) cacheInfoPtr) { 
	    /*
	     * Check to see if we should start a block cleaner for this
	     * backend.
	     */
	    if (cacheInfoPtr->flags & (FSCACHE_SERVER_DOWN|FSCACHE_FILE_GONE)) {
		/*
		 * Don't bother to write-back files for which the server is
		 * down.  These will be written back during recovery.
		 */
		continue;
	    }
	    if (cacheInfoPtr->flags &
		    (FSCACHE_NO_DISK_SPACE | FSCACHE_DOMAIN_DOWN |
		     FSCACHE_GENERIC_ERROR)) {
		/*
		 * Retry for these types of errors.
		 */
		if (cacheInfoPtr->lastTimeTried < currentTime) {
		    cacheInfoPtr->flags &=
			~(FSCACHE_NO_DISK_SPACE | FSCACHE_DOMAIN_DOWN |
				  FSCACHE_GENERIC_ERROR);
		    StartBackendWriteback(cacheInfoPtr->backendPtr, FALSE);
		    break;
		} else {
		    continue;
		}
	    }
	    if ((numAvailBlocks < minNumAvailBlocks + FSCACHE_MIN_BLOCKS) ||
		(cacheInfoPtr->oldestDirtyBlockTime < writeBackTime) ||
		(cacheInfoPtr->flags & FSCACHE_FILE_FSYNC)) {
		StartBackendWriteback(cacheInfoPtr->backendPtr, FALSE);
		break;
	    }
	}
    }
    /*
     * Wait for all block cleaners to go idea before returning.
     */
    while ((numBackendsActive > 0) && !sys_ShuttingDown) {
	(void) Sync_Wait(&writeBackComplete, FALSE);
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 *	Functions to create, destroy and allocate cache blocks.  These 
 *	functions are used to provide the variable sized cache and the LRU
 *	algorithm for managing cache blocks.
 *
 * ----------------------------------------------------------------------------
 */

/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_SetMinSize --
 *
 * 	Set the minimum size of the block cache.  This will entail mapping
 *	enough blocks so that the number of physical pages in use is greater
 *	than or equal to the minimum number.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	More blocks get memory put behind them.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY void
Fscache_SetMinSize(minBlocks)
    int	minBlocks;	/* The minimum number of blocks in the cache. */
{
    LOCK_MONITOR;



    if (minBlocks > fs_Stats.blockCache.maxNumBlocks) {
	minBlocks = fs_Stats.blockCache.maxNumBlocks;
	printf( "Fscache_SetMinSize: Only raising min cache size to %d blocks\n", 
				minBlocks);
    }
    fs_Stats.blockCache.minCacheBlocks = minBlocks;
    if (fs_Stats.blockCache.minCacheBlocks <= 
				    fs_Stats.blockCache.numCacheBlocks) {
	UNLOCK_MONITOR;
	return;
    }

    /*
     * Give enough blocks memory so that the minimum cache size requirement
     * is met.
     */
    while (fs_Stats.blockCache.numCacheBlocks < 
					fs_Stats.blockCache.minCacheBlocks) {
	if (!CreateBlock(FALSE, (Fscache_Block **) NIL)) {
	    printf("Fscache_SetMinSize: lowered min cache size to %d blocks\n",
		       fs_Stats.blockCache.numCacheBlocks);
	    fs_Stats.blockCache.minCacheBlocks = 
				    fs_Stats.blockCache.numCacheBlocks;
	}
    }

    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_SetMaxSize --
 *
 * 	Set the maximum size of the block cache.  This entails freeing
 *	enough main memory pages so that the number of cache pages is
 *	less than the maximum allowed.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Cache blocks have memory removed from behind them and are moved to
 *	the unmapped list. 
 *
 * ----------------------------------------------------------------------------
 */
ENTRY void
Fscache_SetMaxSize(maxBlocks)
    int	maxBlocks;	/* The minimum number of pages in the cache. */
{
    Boolean			giveUp;
    int				pageNum;

    LOCK_MONITOR;

    if (maxBlocks > fs_Stats.blockCache.maxNumBlocks) {
	maxBlocks = fs_Stats.blockCache.maxNumBlocks;
	printf("Fscache_SetMaxSize: Only raising max cache size to %d blocks\n",
		maxBlocks);
    }

    fs_Stats.blockCache.maxCacheBlocks = maxBlocks;
    if (fs_Stats.blockCache.maxCacheBlocks >= 
				    fs_Stats.blockCache.numCacheBlocks) {
	UNLOCK_MONITOR;
	return;
    }
    
    /*
     * Free enough pages to get down to maximum size.
     */
    giveUp = FALSE;
    while (fs_Stats.blockCache.numCacheBlocks > 
				fs_Stats.blockCache.maxCacheBlocks && !giveUp) {
	giveUp = !DestroyBlock(FALSE, &pageNum);
    }


    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_GetPageFromFS --
 *
 * 	Compare LRU time of the caller to time of block in LRU list and
 *	if caller has newer pages unmap a block and return a page.
 *
 * Results:
 *	Physical page number if unmap a block.
 *
 * Side effects:
 *	Blocks may be unmapped.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY void
Fscache_GetPageFromFS(timeLastAccessed, pageNumPtr)
    time_t	timeLastAccessed;
    int		*pageNumPtr;
{
    register	Fscache_Block	*blockPtr;

    LOCK_MONITOR;

    fs_Stats.blockCache.vmRequests++;
    *pageNumPtr = -1;
    if (fs_Stats.blockCache.numCacheBlocks > 
		fs_Stats.blockCache.minCacheBlocks && !List_IsEmpty(lruList)) {
	fs_Stats.blockCache.triedToGiveToVM++;
	blockPtr = (Fscache_Block *) USE_LINKS_TO_BLOCK(List_First(lruList));
	if (blockPtr->timeReferenced < timeLastAccessed) {
	    fs_Stats.blockCache.vmGotPage++;
	    (void) DestroyBlock(TRUE, pageNumPtr);
	}
    }

    UNLOCK_MONITOR;
}

/*
 * ----------------------------------------------------------------------------
 *
 * CreateBlock --
 *
 * 	Add a new block to the list of free blocks.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Block removed from the unmapped list and put onto the free list.
 *
 * ----------------------------------------------------------------------------
 */
INTERNAL static Boolean
CreateBlock(retBlock, blockPtrPtr)
    Boolean		retBlock;	/* TRUE => return a pointer to one of 
					 * the newly created blocks in 
					 * *blockPtrPtr. */
    Fscache_Block	**blockPtrPtr;	/* Where to return pointer to block.
					 * NIL if caller isn't interested. */
{
    register	Fscache_Block	*blockPtr;
    int				newCachePages;

    if (List_IsEmpty(unmappedList)) {
	printf( "CreateBlock: No unmapped blocks\n");
	return(FALSE);
    }
    blockPtr = USE_LINKS_TO_BLOCK(List_First(unmappedList));
    /*
     * Put memory behind the first available unmapped cache block.
     */
    newCachePages = Vm_MapBlock(blockPtr->blockAddr);
    if (newCachePages == 0) {
	return(FALSE);
    }
    numAvailBlocks += newCachePages * blocksPerPage;
    fs_Stats.blockCache.numCacheBlocks += newCachePages * blocksPerPage;
    /*
     * If we are told to return a block then take it off of the list of
     * unmapped blocks and let the caller put it onto the appropriate list.
     * Otherwise put it onto the free list.
     */
    if (retBlock) {
	List_Remove(&blockPtr->useLinks);
	*blockPtrPtr = blockPtr;
    } else {
	fs_Stats.blockCache.numFreeBlocks++;
	blockPtr->flags = FSCACHE_BLOCK_FREE;
	List_Move(&blockPtr->useLinks, LIST_ATREAR(totFreeList));
    }
    if (PAGE_IS_8K) {
	/*
	 * Put the other block in the page onto the appropriate free list.
	 */
	blockPtr = GET_OTHER_BLOCK(blockPtr);
	blockPtr->flags = FSCACHE_BLOCK_FREE;
	fs_Stats.blockCache.numFreeBlocks++;
	if (retBlock) {
	    List_Move(&blockPtr->useLinks, LIST_ATREAR(partFreeList));
	} else {
	    List_Move(&blockPtr->useLinks, LIST_ATREAR(totFreeList));
	}
    }
    if (! List_IsEmpty(fscacheFullWaitList)) {
	Fsutil_WaitListNotify(fscacheFullWaitList);
    }
    Sync_Broadcast(&cleanBlockCondition);

    return(TRUE);
}


/*
 * ----------------------------------------------------------------------------
 *
 * DestroyBlock --
 *
 * 	Destroy one physical page worth of blocks.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Cache blocks have memory removed from behind them and are moved to
 *	the unmapped list. 
 *
 * ----------------------------------------------------------------------------
 */
INTERNAL static Boolean
DestroyBlock(retOnePage, pageNumPtr)
    Boolean	retOnePage;
    int		*pageNumPtr;
{
    register	Fscache_Block	*blockPtr;
    register	Fscache_Block	*otherBlockPtr;
    int		pages;

    if ((numAvailBlocks-blocksPerPage <  minNumAvailBlocks) ||
        (fs_Stats.blockCache.numCacheBlocks - FSCACHE_MIN_BLOCKS - 
			blocksPerPage < minNumAvailBlocks) ) {
	return FALSE;
    }
    /*
     * First try the list of totally free pages.
     */
    if (!List_IsEmpty(totFreeList)) {
	blockPtr = USE_LINKS_TO_BLOCK(List_First(totFreeList));
	pages = Vm_UnmapBlock(blockPtr->blockAddr, retOnePage,
				  (unsigned int *)pageNumPtr);
	fs_Stats.blockCache.numCacheBlocks -= pages * blocksPerPage;
	blockPtr->flags = FSCACHE_NOT_MAPPED;
	List_Move(&blockPtr->useLinks, LIST_ATREAR(unmappedList));
	fs_Stats.blockCache.numFreeBlocks--;
	if (PAGE_IS_8K) {
	    /*
	     * Unmap the other block.  The block address can point to either
	     * of the two blocks.
	     */
	    blockPtr = GET_OTHER_BLOCK(blockPtr);
	    blockPtr->flags = FSCACHE_NOT_MAPPED;
	    List_Move(&blockPtr->useLinks, LIST_ATREAR(unmappedList));
	    fs_Stats.blockCache.numFreeBlocks--;
	}
	numAvailBlocks -= pages * blocksPerPage;
	if (numAvailBlocks < 0) {
	    panic("DestroyBlock numAvailBlocks < 0.\n");
	}
	return(TRUE);
    }

    /*
     * Now take blocks from the LRU list until we get one that we can use.
     */
    while (TRUE) {
	blockPtr = FetchBlock(FALSE, FALSE);
	if (blockPtr == (Fscache_Block *) NIL) {
	    /*
	     * There are no clean blocks left so give up.
	     */
	    return(FALSE);
	}
	if (PAGE_IS_8K) {
	    /*
	     * We have to deal with the other block.  If it is in use, then
	     * we can't take this page.  Otherwise delete the block from
	     * the cache and put it onto the unmapped list.
	     */
	    otherBlockPtr = GET_OTHER_BLOCK(blockPtr);
	    if (otherBlockPtr->refCount > 0 ||
		(otherBlockPtr->flags & 
		     (FSCACHE_BLOCK_DIRTY|FSCACHE_BLOCK_BEING_WRITTEN))) {
		PutOnFreeList(blockPtr);
		continue;
	    }
	    /*
	     * The other block is cached but not in use.  Delete it.
	     */
	    if (!(otherBlockPtr->flags & FSCACHE_BLOCK_FREE)) {
		DeleteBlock(otherBlockPtr);
	    }
	    otherBlockPtr->flags = FSCACHE_NOT_MAPPED;
	    List_Move(&otherBlockPtr->useLinks, LIST_ATREAR(unmappedList));
	}
	blockPtr->flags = FSCACHE_NOT_MAPPED;
	List_Insert(&blockPtr->useLinks, LIST_ATREAR(unmappedList));
	pages = Vm_UnmapBlock(blockPtr->blockAddr, 
				retOnePage, (unsigned int *)pageNumPtr);
	fs_Stats.blockCache.numCacheBlocks -= pages * blocksPerPage;
	numAvailBlocks -= pages * blocksPerPage;
	if (numAvailBlocks < 0) {
	    panic("DestroyBlock numAvailBlocks < 0.\n");
	}
	return(TRUE);
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 * FetchBlock --
 *
 *	Return a pointer to the oldest available block on the lru list.
 *	If had to sleep because all of memory is dirty then return NIL.
 *	In this cause our caller has to retry various free lists.
 *
 * Results:
 *	Pointer to oldest available block, NIL if had to wait.  
 *
 * Side effects:
 *	Block deleted.
 *
 * ----------------------------------------------------------------------------
 */
static INTERNAL Fscache_Block *
FetchBlock(canWait, cantBlock)
    Boolean	canWait;	/* TRUE implies can sleep if all of memory is 
				 * dirty. */
    Boolean	cantBlock;	/* TRUE if we can't block. */
{
    register	Fscache_Block	*blockPtr;
    register	List_Links	*listPtr;

    if (List_IsEmpty(lruList)) {
	printf("FetchBlock: LRU list is empty\n");
	return((Fscache_Block *) NIL);
    }

    if ((numAvailBlocks > minNumAvailBlocks) || cantBlock)  {
	/*
	 * Scan list for unlocked, clean block.
	 */
	LIST_FORALL(lruList, listPtr) {
	    blockPtr = USE_LINKS_TO_BLOCK(listPtr);
	    if (blockPtr->refCount > 0) {
		/*
		 * Block is locked.
		 */
	    } else if (blockPtr->flags & 
			    (FSCACHE_BLOCK_DIRTY|FSCACHE_BLOCK_BEING_WRITTEN)) {
		/*
		 * Block is dirty or being cleaned.  Mark it so that it will be
		 * freed after it has been cleaned.
		 */
		blockPtr->flags |= FSCACHE_MOVE_TO_FRONT;
		if (!(blockPtr->cacheInfoPtr->flags & 
					FSCACHE_FILE_BEING_WRITTEN)) {
		    StartFileSync(blockPtr->cacheInfoPtr);
		}
	    } else if (blockPtr->flags & FSCACHE_BLOCK_DELETED) {
		printf( "FetchBlock: deleted block %d of file %d in LRU list\n",
		    blockPtr->blockNum, blockPtr->fileNum);
	    } else  {
		/*
		 * This block is clean and unlocked.  Delete it from the
		 * hash table and use it.
		 */
		fs_Stats.blockCache.lru++;
		List_Remove(&blockPtr->useLinks);
		DeleteBlock(blockPtr);
		return(blockPtr);
	    }
	}
    } else if (numAvailBlocks <= minNumAvailBlocks) {
	 Fscache_Backend	*backendPtr;
         LIST_FORALL(backendList, (List_Links *) backendPtr) {
	    if (!List_IsEmpty(&backendPtr->dirtyListHdr)) { 
		StartBackendWriteback(backendPtr, FALSE);
	    }
         }
  }
    /*
     * We have looked at every block but we couldn't use any.
     * If possible wait until the block cleaner cleans a block for us.
     */
    if (canWait && !cantBlock) {
	(void) Sync_Wait(&cleanBlockCondition, FALSE);
    }
    return((Fscache_Block *) NIL);
}


/*
 *----------------------------------------------------------------------
 *
 * StartBackendWriteback --
 *
 *	Start a backend writeback process for the specified backend.
 *	This routine keeps track the number of backend writebacks 
 *	active.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *
 *----------------------------------------------------------------------
 */

static void
StartBackendWriteback(backendPtr, fileFsynced)
    Fscache_Backend *backendPtr;
    Boolean	fileFsynced;
		    /*
		     * Second parameter is for ASPLOS measurements and can be
		     * removed after all that's over.  Mary 2/14/92
		     */
{
    Boolean	started;

    /*
     * Second parameter is for ASPLOS measurements and can be
     * removed after all that's over.  Mary 2/14/92
     */
    started = backendPtr->ioProcs.startWriteBack(backendPtr, fileFsynced);
    if (started) {
	numBackendsActive++;
    }
    return;
}


/*
 * ----------------------------------------------------------------------------
 *
 *  Fscache_GetDirtyBlock --
 *
 *     	Take the blocks off of a file's dirty list and return a pointer
 *	to it.  The synchronization between closing a file and writing
 *	back its blocks is done here.  If there are no more dirty blocks
 *	and the file is being closed we poke the closing process.  If
 *	there are still dirty blocks and someone is closing the file
 *	we put the file back onto the file dirty list and don't return a block.
 *
 * Results:
 *	The block returned. NIL if no blocks are ready.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY Fscache_Block *
Fscache_GetDirtyBlock(cacheInfoPtr, blockMatchProc, clientData,
			lastDirtyBlockPtr)
    Fscache_FileInfo	*cacheInfoPtr;
    Boolean		(*blockMatchProc)();
    ClientData		clientData;
    int			*lastDirtyBlockPtr;
{
    register	List_Links	*dirtyPtr;
    register	Fscache_Block	*blockPtr;

    LOCK_MONITOR;

    *lastDirtyBlockPtr = 0;

    if (cacheInfoPtr->flags & FSCACHE_CLOSE_IN_PROGRESS) {
	/*
	 * We can't do any write-backs until the file is closed.
	 * Return zero blocks in hope that the backend will return
	 * the file to the cache.
	 */
	UNLOCK_MONITOR;
	return (Fscache_Block *) NIL;
    }
    if (cacheInfoPtr->flags & (FSCACHE_SERVER_DOWN | FSCACHE_NO_DISK_SPACE | 
			      FSCACHE_GENERIC_ERROR|FSCACHE_FILE_GONE)) {
	UNLOCK_MONITOR;
	return (Fscache_Block *) NIL;
    }

    LIST_FORALL(&cacheInfoPtr->dirtyList, dirtyPtr) {
	blockPtr = DIRTY_LINKS_TO_BLOCK(dirtyPtr);
	if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
	    UNLOCK_MONITOR;
	    panic( "GetDirtyBlock, bad block\n");
	    LOCK_MONITOR;
	    continue;
	}
	if (blockPtr->refCount > 0) {
	    /*
	     * Being actively used.  Wait until it is not in use anymore in
	     * case the user is writing it for example.
	     */
	    blockPtr->flags |= FSCACHE_BLOCK_CLEANER_WAITING;
	    continue;
	}
	if (!blockMatchProc(blockPtr, clientData)) {
		continue;
	}
	/*
	 * Mark the block as being written out and clear the dirty flag in case
	 * someone modifies it while we are writing it out.
	 */
	List_Remove(dirtyPtr);
	blockPtr->flags &= ~(FSCACHE_BLOCK_DIRTY|FSCACHE_BLOCK_BEING_CLEANED);
	blockPtr->flags |= FSCACHE_BLOCK_BEING_WRITTEN;
	blockPtr->refCount++;
	if (blockPtr->refCount == 1) { 
	    VmMach_LockCachePage(blockPtr->blockAddr);
	}
	/*
	 * Gather statistics.
	 */
	fs_Stats.blockCache.blocksWrittenThru++;
	switch (blockPtr->flags &
		(FSCACHE_DATA_BLOCK | FSCACHE_IND_BLOCK |
		 FSCACHE_DESC_BLOCK | FSCACHE_DIR_BLOCK)) {
	    case FSCACHE_DATA_BLOCK:
		fs_Stats.blockCache.dataBlocksWrittenThru++;
		break;
	    case FSCACHE_IND_BLOCK:
		fs_Stats.blockCache.indBlocksWrittenThru++;
		break;
	    case FSCACHE_DESC_BLOCK:
		fs_Stats.blockCache.descBlocksWrittenThru++;
		break;
	    case FSCACHE_DIR_BLOCK:
		fs_Stats.blockCache.dirBlocksWrittenThru++;
		break;
	    default:
		printf( "Fscache_GetDirtyBlock: Unknown block type 0x%x\n",
		    blockPtr->flags &
		(FSCACHE_DATA_BLOCK | FSCACHE_IND_BLOCK |
		 FSCACHE_DESC_BLOCK | FSCACHE_DIR_BLOCK));
	}
	if (blockPtr->blockSize < 0) {
	    panic( "Fscache_GetDirtyBlock: uninitialized block size\n");
	}
	*lastDirtyBlockPtr = List_IsEmpty(&cacheInfoPtr->dirtyList);
	UNLOCK_MONITOR;
	return blockPtr;
    }
    *lastDirtyBlockPtr = List_IsEmpty(&cacheInfoPtr->dirtyList);
    UNLOCK_MONITOR;
    return (Fscache_Block *) NIL;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_ReturnDirtyBlock --
 *
 *     	This routine will process the newly cleaned blocks.
 *
 * Results:
 *     	None.
 *
 * Side effects:
 *	The block may be moved on the allocate list and also possibly freed.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY void
Fscache_ReturnDirtyBlock(blockPtr, status)
    register  Fscache_Block	*blockPtr; /*  blocks to  return. */
    ReturnStatus		status;
{
    register	Fscache_FileInfo	*cacheInfoPtr;

    LOCK_MONITOR;

    cacheInfoPtr = blockPtr->cacheInfoPtr;

    blockPtr->flags &= ~FSCACHE_BLOCK_BEING_WRITTEN;
    blockPtr->refCount--;
    if (blockPtr->refCount == 0) {
	VmMach_UnlockCachePage(blockPtr->blockAddr);
    }
    Sync_Broadcast(&blockPtr->ioDone);
    if (status == GEN_EINTR) {
	blockPtr->flags |= FSCACHE_BLOCK_DIRTY;
    } else if (status != SUCCESS) {
	/*
	 * This block could not be written out.
	 */
	Boolean		printErrorMsg;

	printErrorMsg = FALSE;
	switch (status) {
	    case RPC_TIMEOUT:
	    case FS_STALE_HANDLE:
	    case RPC_SERVICE_DISABLED:	
		if (!(cacheInfoPtr->flags & FSCACHE_SERVER_DOWN)) {
		    printErrorMsg = TRUE;
		    cacheInfoPtr->flags |= FSCACHE_SERVER_DOWN;
		}
		/*
		 * Mark the handle as needing recovery.  Then invoke a
		 * background process to attempt the recovery now.
		 */
		(void) Fsutil_WantRecovery(cacheInfoPtr->hdrPtr);
		if (status == FS_STALE_HANDLE) {
		    Proc_CallFunc(Fsutil_AttemptRecovery,
			      (ClientData)cacheInfoPtr->hdrPtr, 0);
		}
		break;
	    case FS_NO_DISK_SPACE:
		if (!(cacheInfoPtr->flags & FSCACHE_NO_DISK_SPACE)) {
		    printErrorMsg = TRUE;
		    cacheInfoPtr->flags |= FSCACHE_NO_DISK_SPACE;
		}
		break;
	    case FS_DOMAIN_UNAVAILABLE:
		if (!(cacheInfoPtr->flags & FSCACHE_DOMAIN_DOWN)) {
		    printErrorMsg = TRUE;
		    cacheInfoPtr->flags |= FSCACHE_DOMAIN_DOWN;
		}
		break;
	    case DEV_RETRY_ERROR:
	    case DEV_HARD_ERROR:
		/*
		 * Schedule a background process to allocate new space for
		 * this block.  Inc the ref count so the block won't go away
		 * and won't be written again, and mark it as being written so
		 * noone will attempt to change where the block is on disk.
		 */
		blockPtr->refCount++;
		if (blockPtr->refCount == 1) { 
		    VmMach_LockCachePage(blockPtr->blockAddr);
		}
		blockPtr->flags |= FSCACHE_BLOCK_BEING_WRITTEN;
		Proc_CallFunc(
		    cacheInfoPtr->backendPtr->ioProcs.reallocBlock, 
				    (ClientData)blockPtr, 0);
		printErrorMsg = TRUE;
		printf("File blk %d phys blk %d: ",
			    blockPtr->blockNum, blockPtr->diskBlock);
		cacheInfoPtr->flags |= FSCACHE_GENERIC_ERROR;
		break;
	    default: 
		printErrorMsg = TRUE;
		cacheInfoPtr->flags |= FSCACHE_GENERIC_ERROR;
		break;
	}
	if (printErrorMsg) {
	    Fsutil_FileError(cacheInfoPtr->hdrPtr, 
		    "Write-back failed", status);
	}
	cacheInfoPtr->lastTimeTried = Fsutil_TimeInSeconds();
	PutBlockOnDirtyList(blockPtr, TRUE);
	UNLOCK_MONITOR;
	return;
    }
    /*
     * Successfully wrote the block.
     */
    cacheInfoPtr->flags &= 
			~(FSCACHE_SERVER_DOWN | FSCACHE_NO_DISK_SPACE | 
			  FSCACHE_GENERIC_ERROR);
    if (blockPtr->flags & FSCACHE_BLOCK_DIRTY) { 
	PutBlockOnDirtyList(blockPtr, TRUE);
    } else { 
	if (blockPtr->refCount == 0) {
	    numAvailBlocks++; 
	}
	/* 
	 * Now see if we are supposed to take any special action with this
	 * block once we are done.
	 */
	if (blockPtr->flags & FSCACHE_BLOCK_DELETED) {
	    cacheInfoPtr->blocksInCache--;
	    List_Remove(&blockPtr->fileLinks);
	    PutOnFreeList(blockPtr);
	} else if (blockPtr->flags & FSCACHE_MOVE_TO_FRONT) {
	    List_Move(&blockPtr->useLinks, LIST_ATFRONT(lruList));
	    blockPtr->flags &= ~FSCACHE_MOVE_TO_FRONT;
	}

	cacheInfoPtr->numDirtyBlocks--;
	/*
	 * Wakeup the block allocator which may be waiting for us to clean
	 * a block
	 */
	if (! List_IsEmpty(fscacheFullWaitList)) {
	    Fsutil_WaitListNotify(fscacheFullWaitList);
	}
	Sync_Broadcast(&cleanBlockCondition);
    }
    UNLOCK_MONITOR;
}

/*
 * ----------------------------------------------------------------------------
 *
 *  Fscache_GetDirtyFile --
 *
 *     	Take a dirty file off of the dirty file list for the
 *	specified backend. Return a pointer to the cache state for 
 *	the file return. This routine is used by the backend to
 *	walk through the dirty list.
 *
 * Results:
 *	A pointer to the cache state for the first file on the dirty list.
 *	If there are no files then a NIL pointer is returned.  
 *
 * Side effects:
 *      An element is removed from the dirty file list.  The fact that
 *	the dirty list links are at the beginning of the cacheInfo struct
 *	is well known and relied on to map from the dirty list to cacheInfoPtr.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY Fscache_FileInfo *
Fscache_GetDirtyFile(backendPtr, fsyncOnly, fileMatchProc, clientData)
    Fscache_Backend	*backendPtr;	/* Cache backend to take dirty files
					 * from. */
    Boolean		fsyncOnly;	/* TRUE if we should return only 
					 * fsynced files. */
    Boolean		(*fileMatchProc)();	/* File match procedure. */
    ClientData		clientData;	/* ClientData for match procedure. */
{
    register Fscache_FileInfo *cacheInfoPtr;

    LOCK_MONITOR;

    /*
     * If the dirty list is empty return NIL.
     */
    if (List_IsEmpty(&backendPtr->dirtyListHdr)) {
	UNLOCK_MONITOR;
	return (Fscache_FileInfo *) NIL;
    }

    /*
     * Otherwise, search the the dirtyList picking off the file to return.
     */
    LIST_FORALL(&(backendPtr->dirtyListHdr), (List_Links *)cacheInfoPtr) {
	 if (cacheInfoPtr->flags & 
			(FSCACHE_CLOSE_IN_PROGRESS|FSCACHE_SERVER_DOWN)) {
	    /*
	     * Close in progress on the file the block lives in so we aren't
	     * allowed to write any more blocks.
	     */
	    continue;
	} else if (cacheInfoPtr->flags & FSCACHE_FILE_GONE) {
	    /*
	     * The file is being deleted.
	     */
	    printf("FscacheGetDirtyFile skipping deleted file <%d,%d> \"%s\"\n",
		cacheInfoPtr->hdrPtr->fileID.major,
		cacheInfoPtr->hdrPtr->fileID.minor,
		Fsutil_HandleName(cacheInfoPtr->hdrPtr));
	    continue;
	} else if (cacheInfoPtr->flags & 
		       (FSCACHE_NO_DISK_SPACE | FSCACHE_DOMAIN_DOWN |
		        FSCACHE_GENERIC_ERROR)) {
	    if (Fsutil_TimeInSeconds() - cacheInfoPtr->lastTimeTried <
			FSUTIL_WRITE_RETRY_INTERVAL) {
		continue;
	    }
	    cacheInfoPtr->flags &= 
			    ~(FSCACHE_NO_DISK_SPACE | FSCACHE_DOMAIN_DOWN |
			      FSCACHE_GENERIC_ERROR);
	} 

	if (!fileMatchProc(cacheInfoPtr, clientData)) {
		continue;
	}
	if ((numAvailBlocks > minNumAvailBlocks) && fsyncOnly && 
		!( (cacheInfoPtr->flags & FSCACHE_FILE_FSYNC) ||
		    (cacheInfoPtr->oldestDirtyBlockTime < filewriteBackTime))) {
	    break;
	}
	/*
	 * Check to make sure that if dirty blocks exist then at least one 
	 * of the blocks is available to write.
	 */
	if (!List_IsEmpty(&cacheInfoPtr->dirtyList)) { 
	    register	List_Links	*dirtyPtr;
	    register	Fscache_Block	*blockPtr;
	    Boolean	found = FALSE;
	    LIST_FORALL(&cacheInfoPtr->dirtyList, dirtyPtr) {
		blockPtr = DIRTY_LINKS_TO_BLOCK(dirtyPtr);
		if (blockPtr->refCount == 0) {
		    found = TRUE;
		    break;
		}
	    }
	    if (!found) {
		continue;
	    }
        }

	cacheInfoPtr->flags |= FSCACHE_FILE_BEING_WRITTEN;
	cacheInfoPtr->flags &= ~FSCACHE_FILE_ON_DIRTY_LIST;
	List_Remove((List_Links *)cacheInfoPtr);
	UNLOCK_MONITOR;
	return cacheInfoPtr;
    }
    UNLOCK_MONITOR;
    return (Fscache_FileInfo *) NIL;
}

/*
 * ----------------------------------------------------------------------------
 *
 *  Fscache_ReturnDirtyFile --
 *
 *     	Return a file checked-out using get dirty file. 
 *
 * Results:
 * Side effects:
 *
 * ----------------------------------------------------------------------------
 */
ENTRY void
Fscache_ReturnDirtyFile(cacheInfoPtr, onFront)
    Fscache_FileInfo	*cacheInfoPtr;	/* File to return. */
    Boolean 		onFront;	/* Put it on the front the of list. */
{

    LOCK_MONITOR;

    /*
     * Move the from file being written state (and list) to the
     * dirty list or no list at all.
     */
    cacheInfoPtr->flags &= ~FSCACHE_FILE_BEING_WRITTEN;
    if (cacheInfoPtr->numDirtyBlocks == 0) { 
	Sync_Broadcast(&cacheInfoPtr->noDirtyBlocks);
	if (!(cacheInfoPtr->flags & FSCACHE_FILE_DESC_DIRTY)) {
	    cacheInfoPtr->flags &= ~(FSCACHE_FILE_FSYNC |
	                             FSCACHE_FILE_BEING_CLEANED);
	}
    }

    if (((cacheInfoPtr->numDirtyBlocks > 0) || 
         (cacheInfoPtr->flags & FSCACHE_FILE_DESC_DIRTY)) &&
	 !(cacheInfoPtr->flags & FSCACHE_FILE_GONE)) {
	PutFileOnDirtyList(cacheInfoPtr, 
			    cacheInfoPtr->oldestDirtyBlockTime);
    }
    if (cacheInfoPtr->flags & FSCACHE_CLOSE_IN_PROGRESS) {
	/*
	 * Wake up anyone waiting for us to finish so that they can 
	 * close their file. 
	 */
	Sync_Broadcast(&closeCondition);
    }

    UNLOCK_MONITOR;
    return;
}

/*
 *----------------------------------------------------------------------
 *
 * FscacheBackendIdle --
 *
 *	Inform the cache that a backend write-back has finished..
 *
 * Results:
 *	None.
 *
 * Side effects:
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
void
FscacheBackendIdle(backendPtr)
    Fscache_Backend *backendPtr;
{
    LOCK_MONITOR;
    numBackendsActive--;
    if (numBackendsActive == 0) {
	Sync_Broadcast(&writeBackComplete);
    }
    UNLOCK_MONITOR;
    return;
}



/*
 * ----------------------------------------------------------------------------
 *
 * FscacheFinishRealloc --
 *
 *	After reallocating new space for a block, finish things up.
 *
 * Results:
 *     	None.
 *
 * Side effects:
 *     	None.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY void
FscacheFinishRealloc(blockPtr, diskBlock)
    Fscache_Block	*blockPtr;
    int			diskBlock;
{
    LOCK_MONITOR;

    blockPtr->refCount--;
    if (blockPtr->refCount == 0) { 
	VmMach_UnlockCachePage(blockPtr->blockAddr);
    }
    blockPtr->flags &= ~FSCACHE_BLOCK_BEING_WRITTEN;
    Sync_Broadcast(&blockPtr->ioDone);
    if (diskBlock != -1) {
	blockPtr->diskBlock = diskBlock;
	blockPtr->cacheInfoPtr->flags &= 
			    ~(FSCACHE_NO_DISK_SPACE | FSCACHE_DOMAIN_DOWN |
			      FSCACHE_GENERIC_ERROR);
	PutFileOnDirtyList(blockPtr->cacheInfoPtr, 
			blockPtr->cacheInfoPtr->oldestDirtyBlockTime);
	StartBackendWriteback(blockPtr->cacheInfoPtr->backendPtr, FALSE);
    }

    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_PreventWriteBacks --
 *
 *	Mark this file as a close in progress.  This routine will not
 *	return until all dirty block cleaners are done writing out blocks
 *	for this file.  This is called before doing a close on a file
 *	and is needed to synchronize write-backs and closes so the
 *	file server knows when it has all the dirty blocks of a file.
 *
 * Results:
 *	The number of dirty blocks in the cache for this file.
 *	-1 is returned if the file is not cacheable.
 *
 * Side effects:
 *	FSCACHE_CLOSE_IN_PROGRESS flags set in the cacheInfo for this file.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY int
Fscache_PreventWriteBacks(cacheInfoPtr)
    Fscache_FileInfo *cacheInfoPtr;
{
    int	numDirtyBlocks;

    LOCK_MONITOR;

    cacheInfoPtr->flags |= FSCACHE_CLOSE_IN_PROGRESS;
    while (cacheInfoPtr->flags & FSCACHE_FILE_BEING_WRITTEN) {
	(void)Sync_Wait(&closeCondition, FALSE);
    }
    if (cacheInfoPtr->flags & FSCACHE_FILE_NOT_CACHEABLE) {
	numDirtyBlocks = -1;
    } else {
	numDirtyBlocks = cacheInfoPtr->numDirtyBlocks;
    }

    UNLOCK_MONITOR;

    return(numDirtyBlocks);
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_AllowWriteBacks --
 *
 *	The close that was in progress on this file is now done.  We
 *	can continue to write back blocks now.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	FSCACHE_CLOSE_IN_PROGRESS flag cleared from the handle for this file.
 *	Also if the block cleaner is waiting for us then wake it up.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fscache_AllowWriteBacks(cacheInfoPtr)
    register	Fscache_FileInfo *cacheInfoPtr;
{
    LOCK_MONITOR;

    cacheInfoPtr->flags &= ~FSCACHE_CLOSE_IN_PROGRESS;
    if ((cacheInfoPtr->numDirtyBlocks > 0) || 
        (cacheInfoPtr->flags & FSCACHE_FILE_DESC_DIRTY)) { 
	PutFileOnDirtyList(cacheInfoPtr, cacheInfoPtr->oldestDirtyBlockTime);
	if (cacheInfoPtr->flags & FSCACHE_FILE_FSYNC) {
	    StartBackendWriteback(cacheInfoPtr->backendPtr, FALSE);
	}
    }

    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_PutFileOnDirtyList --
 *
 *	Put the specified file on the dirty list.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *
 * ----------------------------------------------------------------------------
 *
 */
ReturnStatus
Fscache_PutFileOnDirtyList(cacheInfoPtr, flags)
    register	Fscache_FileInfo *cacheInfoPtr;
    int		flags;
{
    LOCK_MONITOR;
    cacheInfoPtr->flags |= flags;

    PutFileOnDirtyList(cacheInfoPtr, (time_t)Fsutil_TimeInSeconds());

    UNLOCK_MONITOR;
    return (SUCCESS);
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_RemoveFileFromDirtyList --
 *
 *	Remove the specified file on the dirty list.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *
 * ----------------------------------------------------------------------------
 *
 */
ReturnStatus
Fscache_RemoveFileFromDirtyList(cacheInfoPtr)
    register	Fscache_FileInfo *cacheInfoPtr;
{
    int			blocksInCache;

    LOCK_MONITOR;
    while (cacheInfoPtr->flags & FSCACHE_FILE_BEING_WRITTEN) {
	Sync_Wait(&cacheInfoPtr->noDirtyBlocks, FALSE);
    }
    if (cacheInfoPtr->flags & FSCACHE_FILE_ON_DIRTY_LIST) {
	cacheInfoPtr->flags &= ~(FSCACHE_FILE_ON_DIRTY_LIST|FSCACHE_FILE_FSYNC|
			FSCACHE_FILE_BEING_CLEANED);
	List_Remove((List_Links *)cacheInfoPtr);
    }
    blocksInCache = cacheInfoPtr->blocksInCache;
    UNLOCK_MONITOR;

    if (blocksInCache != 0) {
	panic("Fscache_RemoveFileFromDirtyList blocks in cache\n");
    }
    return SUCCESS;
}



/*
 * ----------------------------------------------------------------------------
 *
 *	Miscellaneous functions.
 *
 * ----------------------------------------------------------------------------
 */

/*
 * ----------------------------------------------------------------------------
 *
 * FscacheAllBlocksInCache --
 *
 * 	Return true if all of this files blocks are in the cache.  This
 *	is used to optimize out read ahead.
 *
 * Results:
 *	TRUE if all blocks for the file are in the cache.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY Boolean
FscacheAllBlocksInCache(cacheInfoPtr)
    register	Fscache_FileInfo *cacheInfoPtr;
{
    Boolean	result;
    int		numBlocks;

    LOCK_MONITOR;

    fs_Stats.blockCache.allInCacheCalls++;
    if (cacheInfoPtr->attr.lastByte == -1) {
	result = TRUE;
    } else {
	if (cacheInfoPtr->attr.firstByte == -1) {
	    cacheInfoPtr->attr.firstByte = 0;
	}
	numBlocks = (cacheInfoPtr->attr.lastByte/FS_BLOCK_SIZE) -
		    (cacheInfoPtr->attr.firstByte/FS_BLOCK_SIZE) + 1;
	result = (numBlocks == cacheInfoPtr->blocksInCache);
	if (result) {
	    fs_Stats.blockCache.allInCacheTrue++;
	}
    }

    UNLOCK_MONITOR;

    return(result);
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_ReserveBlocks --
 *
 *   Insure that at least the specified number of cache blocks will be 
 *   available to Fetch_Block() calls the the FSCACHE_CANT_BLOCK flag.
 *
 * Results:
 *	The number of blocks made available.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
/* ARGSUSED */
ENTRY int
Fscache_ReserveBlocks(backendPtr, numResBlocks, numNonResBlocks)
    Fscache_Backend	*backendPtr; /* unused */
    int			numResBlocks;
    int			numNonResBlocks;
{
    int	numBlocks = numResBlocks + numNonResBlocks;

    LOCK_MONITOR;
    if (numBlocks > fs_Stats.blockCache.maxNumBlocks) {
	numBlocks = fs_Stats.blockCache.maxNumBlocks - minNumAvailBlocks;
    }

    while (fs_Stats.blockCache.numCacheBlocks < minNumAvailBlocks + numBlocks) { 
	if (!CreateBlock(FALSE, (Fscache_Block **) NIL)) {
		break;
	} 
    }
    if (minNumAvailBlocks + numResBlocks > 
		fs_Stats.blockCache.numCacheBlocks - numNonResBlocks) {
	numResBlocks = fs_Stats.blockCache.numCacheBlocks - numNonResBlocks -
			minNumAvailBlocks;
	if (numResBlocks< 0) {
	    numResBlocks = 0;
	}
    }
    minNumAvailBlocks += numResBlocks;
    while (minNumAvailBlocks > numAvailBlocks) {
	(void) Sync_Wait(&cleanBlockCondition, FALSE);
    }
    UNLOCK_MONITOR;
    return numResBlocks;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_ReleaseReserveBlocks
 *
 *   Release blocks that were Reserved.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
/* ARGSUSED */
void
Fscache_ReleaseReserveBlocks(backendPtr, numBlocks)
    Fscache_Backend	*backendPtr; /* unused */
    int			numBlocks;
{
    LOCK_MONITOR;

    minNumAvailBlocks  -= numBlocks;
    Sync_Broadcast(&cleanBlockCondition);

    UNLOCK_MONITOR;
    return;
}


/*
 * ----------------------------------------------------------------------------
 *
 * FscacheBlockOkToScavenge --
 *
 *	Decide if it is safe to scavenge the file handle.  This is
 *	called from Fscache_OkToScavenge which
 *	has already grabbed the per-file cache lock.
 *
 * Results:
 *	TRUE if there are no blocks (clean or dirty) in the cache for this file.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY int
FscacheBlockOkToScavenge(cacheInfoPtr)
    register Fscache_FileInfo	*cacheInfoPtr;	/* Cache state to check. */
{
    register int numBlocks;
    register int numBlocksCheck = 0;
    register Boolean ok;
    register Fscache_Block *blockPtr;
    List_Links		*linkPtr;

    LOCK_MONITOR;
    numBlocks = cacheInfoPtr->blocksInCache;
    LIST_FORALL(&cacheInfoPtr->blockList, (List_Links *)linkPtr) {
	blockPtr = FILE_LINKS_TO_BLOCK(linkPtr);
	if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
	    UNLOCK_MONITOR;
	    panic( "FsCacheFileBlocks, bad block\n");
	    return(FALSE);
	}
	numBlocksCheck++;
    }
    LIST_FORALL(&cacheInfoPtr->indList, (List_Links *)linkPtr) {
	numBlocksCheck++;
    }
    if (numBlocksCheck != numBlocks) {
	UNLOCK_MONITOR;
	panic( "FsCacheFileBlocks, wrong block count\n");
	return(FALSE);
    }
    ok = (numBlocks == 0) &&
	((cacheInfoPtr->flags & 
		(FSCACHE_FILE_ON_DIRTY_LIST|FSCACHE_FILE_BEING_WRITTEN)) == 0);
    UNLOCK_MONITOR;
    return(ok);
}

/*
 * ----------------------------------------------------------------------------
 *
 * FscacheBlockOkToScavengeExceptDirty --
 *
 *	Decide if it is safe not to reopen the file handle.  This is
 *	called from Fscache_OkToScavengeExceptDirty which
 *	has already grabbed the per-file cache lock.
 *
 * Results:
 *	TRUE if there are no dirty blocks (dirty) in the cache for this file.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY int
FscacheBlockOkToScavengeExceptDirty(cacheInfoPtr)
    register Fscache_FileInfo	*cacheInfoPtr;	/* Cache state to check. */
{
    register int numBlocks;
    register int numBlocksCheck = 0;
    register Boolean ok;
    register Fscache_Block *blockPtr;
    List_Links		*linkPtr;

    LOCK_MONITOR;
    numBlocks = cacheInfoPtr->blocksInCache;
    LIST_FORALL(&cacheInfoPtr->blockList, (List_Links *)linkPtr) {
	blockPtr = FILE_LINKS_TO_BLOCK(linkPtr);
	if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
	    UNLOCK_MONITOR;
	    panic( "FsCacheFileBlocks, bad block\n");
	    return(FALSE);
	}
	numBlocksCheck++;
    }
    LIST_FORALL(&cacheInfoPtr->indList, (List_Links *)linkPtr) {
	numBlocksCheck++;
    }
    if (numBlocksCheck != numBlocks) {
	UNLOCK_MONITOR;
	panic( "FsCacheFileBlocks, wrong block count\n");
	return(FALSE);
    }
    /*
     * If there are only clean blocks in the file and we're not supposed
     * to reopen such files, invalidate the clean blocks.
     */
    if (recov_IgnoreCleanFiles && !(cacheInfoPtr->flags &
	    (FSCACHE_FILE_ON_DIRTY_LIST | FSCACHE_FILE_BEING_WRITTEN))) {
	Fscache_FileInvalidate(cacheInfoPtr, 0, FSCACHE_LAST_BLOCK);
	numBlocks = cacheInfoPtr->blocksInCache;
    }
    /*
     * If there are only clean blocks in the cache and we're supposed to
     * skip reopening them (but not invalidate them) pretend they have
     * zero blocks.
     */
    if (recov_SkipCleanFiles && !(cacheInfoPtr->flags &
	    (FSCACHE_FILE_ON_DIRTY_LIST | FSCACHE_FILE_BEING_WRITTEN))) {
	numBlocks = 0;
    }

    ok = (numBlocks == 0) &&
	((cacheInfoPtr->flags & 
		(FSCACHE_FILE_ON_DIRTY_LIST|FSCACHE_FILE_BEING_WRITTEN)) == 0);
    UNLOCK_MONITOR;
    return(ok);
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_FileInfoSyncLockCleanup --
 *
 * 	Clean up Sync_Lock tracing for the cache lock.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Set up the fields of the Fscache_FileInfo struct.
 *
 * ----------------------------------------------------------------------------
 */
/*ARGSUSED*/
void
Fscache_FileInfoSyncLockCleanup(cacheInfoPtr)
    Fscache_FileInfo *cacheInfoPtr;
{
    Sync_LockClear(&cacheInfoPtr->lock);
}


/*
 * ----------------------------------------------------------------------------
 * 
 *	List Functions
 *
 * Functions to put objects onto the free and dirty lists.
 *
 * ----------------------------------------------------------------------------
 */

/*
 * ----------------------------------------------------------------------------
 *
 * PutOnFreeList --
 *
 * 	Put the given block onto one of the two free lists.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Block either added to the partially free list or the totally free list.
 *	The list of processes waiting on the full cache is notified if
 *	is non-empty.
 *
 * ----------------------------------------------------------------------------
 */
INTERNAL static void
PutOnFreeList(blockPtr)
    register	Fscache_Block	*blockPtr;
{
    register	Fscache_Block	*otherBlockPtr;

    blockPtr->flags = FSCACHE_BLOCK_FREE;
    fs_Stats.blockCache.numFreeBlocks++;
    if (PAGE_IS_8K) {
	/*
	 * If all blocks in the page are free then put this block onto the
	 * totally free list.  Otherwise it goes onto the partially free list.
	 */
	otherBlockPtr = GET_OTHER_BLOCK(blockPtr);
	if (otherBlockPtr->flags & FSCACHE_BLOCK_FREE) {
	    List_Insert(&blockPtr->useLinks, LIST_ATFRONT(totFreeList));
	    List_Move(&otherBlockPtr->useLinks, LIST_ATFRONT(totFreeList));
	} else {
	    List_Insert(&blockPtr->useLinks, LIST_ATFRONT(partFreeList));
	}
    } else {
	List_Insert(&blockPtr->useLinks, LIST_ATFRONT(totFreeList));
    }
    if (! List_IsEmpty(fscacheFullWaitList)) {
	Fsutil_WaitListNotify(fscacheFullWaitList);
    }
    Sync_Broadcast(&cleanBlockCondition);
}	


/*
 * ----------------------------------------------------------------------------
 *
 * PutFileOnDirtyList --
 *
 * 	Put the given file onto it's backend's dirty list.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	File's backend's dirty list is modified.
 *
 * ----------------------------------------------------------------------------
 */
INTERNAL static void
PutFileOnDirtyList(cacheInfoPtr, oldestDirtyBlockTime)
    register Fscache_FileInfo	*cacheInfoPtr;	/* Cache info for a file */
    time_t	oldestDirtyBlockTime;
{
    register List_Links	*linkPtr;
    List_Links	*dirtyList, *place;

    dirtyList = &cacheInfoPtr->backendPtr->dirtyListHdr;
    if (!(cacheInfoPtr->flags & 
	(FSCACHE_FILE_ON_DIRTY_LIST|FSCACHE_FILE_BEING_WRITTEN))) {
        List_Insert((List_Links *)cacheInfoPtr, LIST_ATREAR(dirtyList));
	if (cacheInfoPtr->flags & FSCACHE_FILE_FSYNC) {
	    /*
	     * Move down the list until we reach the file or the first non
	     * synced file. 
	     */
	    place = (List_Links *) cacheInfoPtr;
	    LIST_FORALL(dirtyList, linkPtr) {
		if ((linkPtr == (List_Links *) cacheInfoPtr) ||
		    !(((Fscache_FileInfo *) linkPtr)->flags & 
					FSCACHE_FILE_FSYNC)) {
		    place = linkPtr;
		    break;
		}
	    }
	    if (place != (List_Links *) cacheInfoPtr) {
		List_Move((List_Links *)cacheInfoPtr, LIST_BEFORE(place));
	    }
	}
	cacheInfoPtr->oldestDirtyBlockTime = oldestDirtyBlockTime;
	cacheInfoPtr->flags |= FSCACHE_FILE_ON_DIRTY_LIST;
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 * PutBlockOnDirtyList --
 *
 * 	Put the given block onto the dirty list for the file, and make
 *	sure that the file is on the list of dirty files.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The block goes onto the dirty list of the file.
 *
 * ----------------------------------------------------------------------------
 */
INTERNAL static void
PutBlockOnDirtyList(blockPtr, onFront)
    register	Fscache_Block	*blockPtr;	/* Block to put on list. */
    Boolean	onFront;			/* Put block on front not
						 * rear of list. */
{
    register Fscache_FileInfo *cacheInfoPtr = blockPtr->cacheInfoPtr;

    blockPtr->flags |= FSCACHE_BLOCK_DIRTY;
    List_Insert(&blockPtr->dirtyLinks, 
		onFront ? LIST_ATFRONT(&cacheInfoPtr->dirtyList) :
			  LIST_ATREAR(&cacheInfoPtr->dirtyList));

    PutFileOnDirtyList(cacheInfoPtr, blockPtr->timeDirtied);
}




/*
 * ----------------------------------------------------------------------------
 *
 * GetUnlockedBlock --
 *
 *	Retrieve a block from the hash table.  This routine will not return
 *	until the block is unlocked and is not being written.
 *
 * Results:
 *	Pointer to hash table entry for the block.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */

INTERNAL static Hash_Entry *
GetUnlockedBlock(blockHashKeyPtr, blockNum)
    register	BlockHashKey	*blockHashKeyPtr;
    int				blockNum;
{
    register	Fscache_Block	*blockPtr;
    register	Hash_Entry	*hashEntryPtr;

    /*
     * See if block is in the hash table.
     */
    blockHashKeyPtr->blockNumber = blockNum;
again:
    hashEntryPtr = Hash_LookOnly(blockHashTable, (Address)blockHashKeyPtr);
    if (hashEntryPtr == (Hash_Entry *) NIL) {
	return((Hash_Entry *) NIL);
    }

    blockPtr = (Fscache_Block *) Hash_GetValue(hashEntryPtr);
    /*
     * Wait until the block is unlocked.  Once wake up start over because
     * the block could have been freed while we were asleep.
     */
    if (blockPtr->refCount > 0 || 
	(blockPtr->flags & FSCACHE_BLOCK_BEING_WRITTEN)) {
	(void) Sync_Wait(&blockPtr->ioDone, FALSE);
	if (sys_ShuttingDown) {
	    return((Hash_Entry *) NIL);
	}
	goto again;
    }
    return(hashEntryPtr);
}


/*
 * ----------------------------------------------------------------------------
 *
 * DeleteBlock --
 *
 *	Remove the block from the hash table.
 *
 * Results:
 *	None.	
 *
 * Side effects:
 *	Decrement count of blocks in cache for file and block deleted from
 *	hash table.
 *
 * ----------------------------------------------------------------------------
 *
 */
static Fscache_Block *deletedBlockPtr;

INTERNAL static void
DeleteBlock(blockPtr)
    register	Fscache_Block	*blockPtr;
{
    BlockHashKey	blockHashKey;
    register Hash_Entry	*hashEntryPtr;

    SET_BLOCK_HASH_KEY(blockHashKey, blockPtr->cacheInfoPtr,
				     blockPtr->blockNum);
    hashEntryPtr = Hash_LookOnly(blockHashTable, (Address) &blockHashKey);
    if (hashEntryPtr == (Hash_Entry *) NIL) {
	UNLOCK_MONITOR;
	deletedBlockPtr = blockPtr;
	panic("DeleteBlock: Block in LRU list is not in the hash table.\n");
	LOCK_MONITOR;
	return;
    }
    Hash_Delete(blockHashTable, hashEntryPtr);
    blockPtr->cacheInfoPtr->blocksInCache--;
    List_Remove(&blockPtr->fileLinks);
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_DumpStats --
 *
 *	Print out the cache statistics.
 *
 * Results:
 *     	None.
 *
 * Side effects:
 *     	None.
 *
 * ----------------------------------------------------------------------------
 */
/*ARGSUSED*/ 
void
Fscache_DumpStats(dummy)
    ClientData dummy;		/* unused; see dump.c:eventTable */
{
    register Fs_BlockCacheStats *block;

    block = &fs_Stats.blockCache;

    printf("\n");
    printf("READ  %d dirty hits %d clean hits %d zero fill %d\n",
		block->readAccesses,
		block->readHitsOnDirtyBlock,
		block->readHitsOnCleanBlock,
		block->readZeroFills);
    printf("WRITE %d p-hits %d p-misses %d thru %d zero %d/%d app %d over %d\n",
		block->writeAccesses,
		block->partialWriteHits,
		block->partialWriteMisses,
		block->blocksWrittenThru,
		block->writeZeroFills1, block->writeZeroFills2,
		block->appendWrites,
		block->overWrites);
    if (block->fragAccesses != 0) {
	printf("FRAG upgrades %d hits %d zero fills\n",
		    block->fragAccesses,
		    block->fragHits,
		    block->fragZeroFills);
    }
    if (block->fileDescReads != 0) {
	printf("FILE DESC reads %d hits %d writes %d hits %d\n", 
		    block->fileDescReads, block->fileDescReadHits,
		    block->fileDescWrites, block->fileDescWriteHits);
    }
    if (block->indBlockAccesses != 0) {
	printf("INDIRECT BLOCKS Accesses %d hits %d\n", 
		    block->indBlockAccesses, block->indBlockHits);
    }
    printf("VM asked %d, we tried %d, gave up %d\n",
		block->vmRequests, block->triedToGiveToVM, block->vmGotPage);
    printf("BLOCK free %d new %d lru %d part free %d\n",
		block->totFree, block->unmapped,
		block->lru, block->partFree);
    printf("SIZES Blocks min %d num %d max %d, Blocks max %d free %d pitched %d\n",
		block->minCacheBlocks, block->numCacheBlocks,
		block->maxCacheBlocks, block->maxNumBlocks,
		block->numFreeBlocks, block->blocksPitched);

    printf("OBJECTS stream %d (clt %d) file %d dir %d rmtFile %d pipe %d\n",
	    fs_Stats.object.streams, fs_Stats.object.streamClients,
	    fs_Stats.object.files, fs_Stats.object.directory,
	    fs_Stats.object.rmtFiles, fs_Stats.object.pipes);
    printf("OBJECTS dev %d pdevControl %d pdev %d remote %d Total %d\n",
	    fs_Stats.object.devices, fs_Stats.object.controls,
	    fs_Stats.object.pseudoStreams, fs_Stats.object.remote,
	    fs_Stats.object.streams + fs_Stats.object.files +
	    fs_Stats.object.rmtFiles + fs_Stats.object.pipes +
	    fs_Stats.object.devices + fs_Stats.object.controls +
	    fs_Stats.object.directory +
	    2 * fs_Stats.object.pseudoStreams + fs_Stats.object.remote);
    printf("HANDLES max %d exist %d. In %d scans replaced %d of %d (dirs %d)\n",
	    fs_Stats.handle.maxNumber, fs_Stats.handle.exists,
	    fs_Stats.handle.lruScans, fs_Stats.handle.lruHits,
	    fs_Stats.handle.lruChecks, fs_Stats.object.dirFlushed);
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_CheckFragmentation --
 *
 *	Scan through the cache determining the number of bytes wasted
 *	compared to a fully variable cache and a cache with 1024 byte blocks.
 *
 * Results:
 *	The number of blocks in the cache, number of bytes wasted.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fscache_CheckFragmentation(numBlocksPtr, totalBytesWastedPtr, fragBytesWastedPtr)
    int	*numBlocksPtr;		/* Return number of blocks in the cache. */
    int	*totalBytesWastedPtr;	/* Return the total number of bytes wasted in
				 * the cache. */
    int	*fragBytesWastedPtr;	/* Return the number of bytes wasted when cache
				 * is caches 1024 byte fragments. */
{
    register Fscache_Block 	*blockPtr;
    register List_Links	  	*listPtr, *lPtr;
    register int		numBlocks = 0;
    register int		totalBytesWasted = 0;
    register int		fragBytesWasted = 0;
    register int		bytesInBlock;
    int				numFrags;

    LOCK_MONITOR;

    listPtr = lruList;
    LIST_FORALL(listPtr, lPtr) {
	blockPtr = USE_LINKS_TO_BLOCK(lPtr);
	if ((blockPtr->refCount > 0) || (blockPtr->blockSize < 0)) {
	    /* 
	     * Skip locked blocks because they might be in the process of
	     * being modified.
	     */
	    continue;
	}
	numBlocks++;
	bytesInBlock = blockPtr->blockSize;
	if (bytesInBlock < FS_BLOCK_SIZE) {
	    totalBytesWasted += FS_BLOCK_SIZE - bytesInBlock;
	    if (blockPtr->blockNum < FSDM_NUM_DIRECT_BLOCKS) {
		numFrags = (bytesInBlock - 1) / FS_FRAGMENT_SIZE + 1; 
		fragBytesWasted += FS_BLOCK_SIZE - numFrags * FS_FRAGMENT_SIZE;
	    }
	}
    }

    *numBlocksPtr = numBlocks;
    *totalBytesWastedPtr = totalBytesWasted;
    *fragBytesWastedPtr = fragBytesWasted;

    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_CountBlocks --
 *
 *	Count the number of clean and dirty blocks under the specified 
 *	domain.
 *
 * Results:
 *	
 *
 * Side effects:
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fscache_CountBlocks(serverID, majorNumber, numBlocksPtr, numDirtyBlocksPtr)
    int		serverID; /* ServerID of file. */
    int		majorNumber;  /* Major number of domain */
    int		*numBlocksPtr; /* OUT: Number of blocks in the cache. */
    int		*numDirtyBlocksPtr;  /* OUT: Number of dirty blocks in cache.*/

{
    register	Fscache_Block	*blockPtr;
    register	List_Links	*listPtr;

    LOCK_MONITOR;

    *numBlocksPtr = *numDirtyBlocksPtr = 0;
    LIST_FORALL(lruList, listPtr) {
	blockPtr = USE_LINKS_TO_BLOCK(listPtr);
	if ((blockPtr->cacheInfoPtr->hdrPtr->fileID.major != majorNumber) ||
	    (blockPtr->cacheInfoPtr->hdrPtr->fileID.serverID != serverID)) {
	    continue;
	}
	(*numBlocksPtr)++;
	if (blockPtr->flags & 
			(FSCACHE_BLOCK_DIRTY|FSCACHE_BLOCK_BEING_WRITTEN)) {
	    (*numDirtyBlocksPtr)++;
	} 
    }

    UNLOCK_MONITOR;
}


/*
 *----------------------------------------------------------------------
 *
 * Fscache_ZeroStats --
 *
 *	Zero out the FS cache counters, leaving the state variables alone.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ENTRY void
Fscache_ZeroStats()
{
    unsigned int minCacheBlocks; /* state variables to preserve */
    unsigned int maxCacheBlocks;
    unsigned int maxNumBlocks;
    unsigned int numCacheBlocks;
    unsigned int numFreeBlocks;

    LOCK_MONITOR;
    minCacheBlocks = fs_Stats.blockCache.minCacheBlocks;
    maxCacheBlocks = fs_Stats.blockCache.maxCacheBlocks;
    maxNumBlocks = fs_Stats.blockCache.maxNumBlocks;
    numCacheBlocks = fs_Stats.blockCache.numCacheBlocks;
    numFreeBlocks = fs_Stats.blockCache.numFreeBlocks;

    bzero(&fs_Stats.blockCache, sizeof(fs_Stats.blockCache));

    fs_Stats.blockCache.minCacheBlocks = minCacheBlocks;
    fs_Stats.blockCache.maxCacheBlocks = maxCacheBlocks;
    fs_Stats.blockCache.maxNumBlocks = maxNumBlocks;
    fs_Stats.blockCache.numCacheBlocks = numCacheBlocks;
    fs_Stats.blockCache.numFreeBlocks = numFreeBlocks;

    UNLOCK_MONITOR;
}
@


9.28
log
@Lint.  Add Fscache_ZeroStats.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fscache/fscacheBlocks.c,v 9.27 92/05/07 17:01:19 kupfer Exp $ SPRITE (Berkeley)";
d36 1
d3051 72
@


9.27
log
@Add debug printfs to track down bogus "disk full" messages.  Lint.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fscache/fscacheBlocks.c,v 9.26 92/03/06 11:54:09 mgbaker Exp $ SPRITE (Berkeley)";
d2821 1
a2821 1
    PutFileOnDirtyList(cacheInfoPtr, Fsutil_TimeInSeconds());
d2938 1
a2938 1
int
d3510 43
@


9.26
log
@Added temporary measurements for ASPLOS paper.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fscache/fscacheBlocks.c,v 9.25 91/09/10 18:24:53 rab Exp $ SPRITE (Berkeley)";
d1402 6
d2937 1
d2940 1
a2940 1
    Fscache_Backend	*backendPtr;
d2988 1
d2991 1
a2991 1
    Fscache_Backend	*backendPtr;
@


9.25
log
@Fixed lint errors and removed tracing.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fscacheBlocks.c,v 9.24 91/08/16 10:58:21 jhh Exp Locker: rab $ SPRITE (Berkeley)";
d227 5
a231 1
static void StartBackendWriteback _ARGS_((Fscache_Backend *backendPtr));
d900 5
a904 1
	    StartBackendWriteback(blockPtr->cacheInfoPtr->backendPtr);
d1189 8
a1196 1
    StartBackendWriteback(cacheInfoPtr->backendPtr);
d1726 1
a1726 1
		    StartBackendWriteback(cacheInfoPtr->backendPtr);
d1735 1
a1735 1
		StartBackendWriteback(cacheInfoPtr->backendPtr);
d2158 1
a2158 1
		StartBackendWriteback(backendPtr);
d2191 1
a2191 1
StartBackendWriteback(backendPtr)
d2193 5
d2201 5
a2205 1
    started = backendPtr->ioProcs.startWriteBack(backendPtr);
d2703 1
a2703 1
	StartBackendWriteback(blockPtr->cacheInfoPtr->backendPtr);
d2784 1
a2784 1
	    StartBackendWriteback(cacheInfoPtr->backendPtr);
@


9.24
log
@error message in Fscache_GetDirtyBlock was too terse
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fscacheBlocks.c,v 9.23 91/06/27 12:34:40 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
a29 1
#include	<fsutilTrace.h>
a225 4
#ifdef SOSP91
static Fscache_Block *FetchBlock _ARGS_((Boolean canWait, Boolean cantBlock,
			unsigned int flags));
#else
a226 1
#endif /* SOSP91 */
a676 4
#ifdef SOSP91
		    blockPtr = FetchBlock(!dontBlock, cantBlock,
			    FSCACHE_BLOCK_LRU);
#else
a677 1
#endif /* SOSP91 */
a689 4
#ifdef SOSP91
			    blockPtr = FetchBlock(!dontBlock, cantBlock,
				    FSCACHE_BLOCK_LRU);
#else
a690 1
#endif /* SOSP91 */
a699 4
#ifdef SOSP91
			blockPtr = FetchBlock(!dontBlock, cantBlock,
				FSCACHE_BLOCK_LRU);
#else
a700 1
#endif /* SOSP91 */
a1643 4
#ifdef SOSP91
    /* XXX Darn - I'll miss blocks quicked out of the cache due to sync. */
#endif SOSP91

a2029 10
#ifdef SOSP91
	unsigned int	flags;

	if (retOnePage) {
	    flags = FSCACHE_BLOCK_VM;
	} else {
	    flags = FSCACHE_BLOCK_SHRINK;
	}
	blockPtr = FetchBlock(FALSE, FALSE, flags);
#else
a2030 1
#endif /* SOSP91 */
a2041 5
#ifdef SOSP91
	     * If we end up not using the block 'cause the other's in
	     * use, this block still counts as being LRU'd since we end up
	     * putting it on the free list and then continuing.
#endif SOSP91
a2054 4
#ifdef SOSP91
		/* Count this block as whatever the other one was. */
		Fscache_AddCleanStats(flags, otherBlockPtr);
#endif SOSP91
a2089 8
#ifdef SOSP91
static INTERNAL Fscache_Block *
FetchBlock(canWait, cantBlock, flags)
    Boolean	canWait;	/* TRUE implies can sleep if all of memory is 
				 * dirty. */
    Boolean	cantBlock;	/* TRUE if we can't block. */
    unsigned	int	flags;
#else
a2094 1
#endif /* SOSP91 */
a2122 9
#ifdef SOSP91
		    if (flags & FSCACHE_BLOCK_VM) {
			blockPtr->cacheInfoPtr->flags |= FSCACHE_VM;
		    } else if (flags & FSCACHE_BLOCK_SHRINK) {
			blockPtr->cacheInfoPtr->flags |= FSCACHE_SHRINK;
		    } else {
			blockPtr->cacheInfoPtr->flags |= FSCACHE_LRU;
		    }
#endif SOSP91
a2132 3
#ifdef SOSP91
		Fscache_AddCleanStats(flags, blockPtr);
#endif SOSP91
a2142 7
#ifdef SOSP91
	    /*
	     * XXX Darn - I can't put FSCACHE_SPACE flag into the various
	     * file's cacheInfo structs here, but I'd like to.  This means
	     * that "unknown" may imply "space" in the results.
	     */
#endif SOSP91
a2554 8
#ifdef SOSP91
	if (fsyncOnly) {
	    cacheInfoPtr->flags |= FSCACHE_TIME;
	}
	if (numAvailBlocks <= minNumAvailBlocks) {
	    cacheInfoPtr->flags |= FSCACHE_SPACE;
	}
#endif SOSP91
d3301 1
a3477 136
#ifdef SOSP91

Fscache_ExtraStats	fscache_ExtraStats;


/*
 *----------------------------------------------------------------------
 *
 * Fscache_AddBlockToStats --
 *
 *	Count another block as being written out from the cache.
 *	Record the reason why from its flags.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Stats updated.
 *
 *----------------------------------------------------------------------
 */
void
Fscache_AddBlockToStats(cacheInfoPtr, blockPtr)
    Fscache_FileInfo	*cacheInfoPtr;
    Fscache_Block	*blockPtr;
{
    int		now;
    time_t	dirtyLifeTime;

    now = Fsutil_TimeInSeconds();
    dirtyLifeTime = now - blockPtr->timeDirtied;

    if ((cacheInfoPtr->flags & FSCACHE_REASON_FLAGS) == 0) {
	fscache_ExtraStats.unknown++;
	fscache_ExtraStats.unDLife += dirtyLifeTime;
	return;
    }
    if (cacheInfoPtr->flags & FSCACHE_CONSIST_WB) {
	fscache_ExtraStats.consistWB++;
	fscache_ExtraStats.cwbDLife += dirtyLifeTime;
    } else if (cacheInfoPtr->flags & FSCACHE_CONSIST_WBINV) {
	fscache_ExtraStats.consistWBInv++;
	fscache_ExtraStats.cwbiDLife += dirtyLifeTime;
    } else if (cacheInfoPtr->flags & FSCACHE_SYNC) {
	fscache_ExtraStats.sync++;
	fscache_ExtraStats.syncDLife += dirtyLifeTime;
    } else if (cacheInfoPtr->flags & FSCACHE_VM) {
	fscache_ExtraStats.vm++;
	fscache_ExtraStats.vmDLife += dirtyLifeTime;
    } else if (cacheInfoPtr->flags & FSCACHE_SHRINK) {
	fscache_ExtraStats.shrink++;
	fscache_ExtraStats.shrinkDLife += dirtyLifeTime;
    } else if (cacheInfoPtr->flags & FSCACHE_REOPEN) {
	fscache_ExtraStats.reopen++;
	fscache_ExtraStats.reDLife += dirtyLifeTime;
    } else if (cacheInfoPtr->flags & FSCACHE_DETACH) {
	fscache_ExtraStats.detach++;
	fscache_ExtraStats.detDLife += dirtyLifeTime;
    } else if (cacheInfoPtr->flags & FSCACHE_TIME) {
	fscache_ExtraStats.time++;
	fscache_ExtraStats.timeDLife += dirtyLifeTime;
    } else if (cacheInfoPtr->flags & FSCACHE_SPACE) {
	fscache_ExtraStats.space++;
	fscache_ExtraStats.spaceDLife += dirtyLifeTime;
    } else if (cacheInfoPtr->flags & FSCACHE_DESC) {
	fscache_ExtraStats.desc++;
	fscache_ExtraStats.descDLife += dirtyLifeTime;
    } else if (cacheInfoPtr->flags & FSCACHE_LRU) {
	fscache_ExtraStats.lru++;
	fscache_ExtraStats.lruDLife += dirtyLifeTime;
    }
    return;

}



/*
 *----------------------------------------------------------------------
 *
 * Fscache_AddCleanStats --
 *
 *	Add extra sosp stats about clean blocks pulled from the lru list.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Stats updated.
 *
 *----------------------------------------------------------------------
 */
void
Fscache_AddCleanStats(flags, blockPtr)
    unsigned int	flags;
    Fscache_Block	*blockPtr;
{
    time_t	now;
    time_t	lifeTime = 0;
    Boolean	unrefed = FALSE;

    now = Fsutil_TimeInSeconds();
    if (blockPtr->timeReferenced <= 0) {
	unrefed = TRUE;
    } else {
	lifeTime = now - blockPtr->timeReferenced;
    }
    if (lifeTime < 0) {
	unrefed = TRUE;
    }

    if (flags & FSCACHE_BLOCK_VM) {
	if (unrefed) {
	    fscache_ExtraStats.unRcleanVm++;
	} else {
	    fscache_ExtraStats.cleanVm++;
	    fscache_ExtraStats.cVmLife += lifeTime;
	}
    } else if (flags & FSCACHE_BLOCK_SHRINK) {
	if (unrefed) {
	    fscache_ExtraStats.unRcleanShrink++;
	} else {
	    fscache_ExtraStats.cleanShrink++;
	    fscache_ExtraStats.cShrinkLife += lifeTime;
	}
    } else {
	if (unrefed) {
	    fscache_ExtraStats.unRcleanLru++;
	} else {
	    fscache_ExtraStats.cleanLru++;
	    fscache_ExtraStats.cLruLife += lifeTime;
	}
    }
    return;
}
#endif SOSP91
@


9.23
log
@Patch code we unmounts of LFS work.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fscacheBlocks.c,v 9.22 91/03/09 17:35:28 kupfer Exp $ SPRITE (Berkeley)";
d2362 4
a2365 1
		printf( "Ofs_CleanBlocks: Unknown block type\n");
@


9.23.1.1
log
@Initial branch for Sprite server.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fscache/fscacheBlocks.c,v 9.23 91/06/27 12:34:40 mendel Exp $ SPRITE (Berkeley)";
@


9.22
log
@Times are signed.  Use "time_t" instead of "int" in a few places.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fscacheBlocks.c,v 9.21 91/01/26 15:32:43 mgbaker Exp Locker: kupfer $ SPRITE (Berkeley)";
d492 11
d517 1
d2894 2
a2895 1
    int blocksInCache;
a2905 1

@


9.21
log
@Sosp stuff.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fscacheBlocks.c,v 9.20 90/12/07 10:12:12 mendel Exp Locker: mgbaker $ SPRITE (Berkeley)";
d236 1
a236 1
			int oldestDirtyBlockTime));
d573 1
a573 1
    int				refTime;
d809 1
a809 1
    unsigned int timeDirtied;	/* Time in seconds that the block was 
d1884 2
a1885 2
    int	timeLastAccessed;
    int	*pageNumPtr;
d3190 1
a3190 1
    int		oldestDirtyBlockTime;
d3252 1
a3252 1
    PutFileOnDirtyList(cacheInfoPtr, (int)(blockPtr->timeDirtied));
d3570 1
a3570 1
    int		dirtyLifeTime;
d3640 2
a3641 2
    int		now;
    int		lifeTime = 0;
@


9.20
log
@Patched problem with files hanging on dirty list no dirty blocks.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fscacheBlocks.c,v 9.19 90/10/19 15:42:12 mendel Exp $ SPRITE (Berkeley)";
d227 4
d232 1
d671 4
d676 1
d689 4
d694 1
d704 4
d709 1
a928 38
	/*
	 * Force the block out if in write-thru or asap mode.
	 */
	if (((blockPtr->flags & 
		(FSCACHE_BLOCK_DIRTY | FSCACHE_BLOCK_BEING_WRITTEN)) &&
	    ((fsutil_WriteThrough || fsutil_WriteBackASAP) &&
	     !(flags & FSCACHE_DONT_WRITE_THRU)) &&
	    (!fsutil_DelayTmpFiles ||
	     Fsdm_FindFileType(blockPtr->cacheInfoPtr) != FSUTIL_FILE_TYPE_TMP))
		|| (flags & FSCACHE_WRITE_TO_DISK)) {
	    /*
	     * Set the write-thru flag for the block so that the block will
	     * keep getting written until it is clean.  This is in case
	     * a block is modified while it is being written to disk.
	     */
	    blockPtr->flags |= FSCACHE_WRITE_THRU_BLOCK;
	    if (fsutil_WriteBackASAP) {
		/*
		 * Force full blocks through.
		 */
		if (blockPtr->blockSize == FS_BLOCK_SIZE ||
		    !(blockPtr->flags & FSCACHE_DATA_BLOCK)) {
		    StartFileSync(blockPtr->cacheInfoPtr);
		}
	    } else {
		/* 
		 * Force the block out and then wait for it.
		 */
		StartFileSync(blockPtr->cacheInfoPtr);
		do {
		    (void) Sync_Wait(&blockPtr->ioDone, FALSE);
		    if (sys_ShuttingDown) {
			break;
		    }
		} while (blockPtr->flags & 
			    (FSCACHE_BLOCK_DIRTY | FSCACHE_BLOCK_BEING_WRITTEN));
	    }
	}
d1653 3
a1713 4
	    if (fsutil_DelayTmpFiles && !writeTmpFiles &&
		Fsdm_FindFileType(cacheInfoPtr) == FSUTIL_FILE_TYPE_TMP) {
		continue;
	    }
d2043 10
d2054 1
d2066 5
d2084 4
d2123 1
d2125 7
d2136 1
d2165 9
d2184 3
d2197 7
a2507 1
#define	WRITE_RETRY_INTERVAL	30
d2575 1
a2575 1
			WRITE_RETRY_INTERVAL) {
d2613 8
d3543 136
@


9.19
log
@Check to make sure that if dirty blocks exist before returning a file
to be written back. 
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fscacheBlocks.c,v 9.18 90/10/10 16:37:17 kupfer Exp $ SPRITE (Berkeley)";
a2609 1
    register Fscache_FileInfo  *nextCacheInfoPtr;
d2618 1
a2618 6

    if ((cacheInfoPtr->numDirtyBlocks == 0) &&
	!(cacheInfoPtr->flags & FSCACHE_FILE_DESC_DIRTY)) {

	cacheInfoPtr->flags &= ~(FSCACHE_FILE_FSYNC |
				    FSCACHE_FILE_BEING_CLEANED);
d2620 5
d2626 3
a2628 1
    } else {
a2638 1
    cacheInfoPtr = nextCacheInfoPtr;
@


9.18
log
@Fscache_DumpStats should take a ClientData.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fscacheBlocks.c,v 9.17 90/10/08 16:19:43 mendel Exp Locker: kupfer $ SPRITE (Berkeley)";
d2563 19
@


9.17
log
@Major changes:
Changed file names to start with "fscache".
Added new cache backend interface. 
Added function prototypes and new include format.
Removed old traceing code.
Added locking/unlocking of cache blocks.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs.mendel/RCS/fsBlockCache.c,v 1.1 90/01/16 17:10:18 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d3313 2
a3314 1
Fscache_DumpStats()
@


9.16
log
@Removed static declarations from Sync_Conditions for debugging.
@
text
@d2 1
a2 1
 * fsBlockCache.c --
d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fsBlockCache.c,v 9.15 90/05/18 12:10:00 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d21 16
a36 15
#include	"sprite.h"
#include	"fs.h"
#include	"fsutil.h"
#include	"fscache.h"
#include	"fsBlockCache.h"
#include	"fsStat.h"
#include	"fsNameOps.h"
#include	"fsdm.h"
#include	"fsio.h"
#include	"fsutilTrace.h"
#include	"hash.h"
#include	"vm.h"
#include	"proc.h"
#include	"sys.h"
#include	"rpc.h"
d38 1
d64 3
a66 4
 *     4) Waiting for blocks from the whole cache to be written back.  This
 *	  is done just like (3) except that a global count of the number
 *	  of blocks being written back is kept and the FSCACHE_WRITE_BACK_WAIT
 *	  flag is set in the block instead.
a95 44
 * Special trace for indirect block bug
 */
#undef FSUTIL_TRACE_BLOCK
#define FSUTIL_TRACE_BLOCK(event, blockPtr) \
    if (((blockPtr)->flags & FSCACHE_IND_BLOCK) && \
	(event != BLOCK_FETCH_HIT)) { \
	Fsutil_TraceBlockRec blockRec;					\
	blockRec.fileID = (blockPtr)->cacheInfoPtr->hdrPtr->fileID;	\
	blockRec.blockNum = (blockPtr)->blockNum;			\
	blockRec.flags	= (blockPtr)->flags;				\
	Trace_Insert(fsutil_TraceHdrPtr, event, (ClientData)&blockRec);\
    }

/*
 * FETCH_INIT	Block newly initialized by Fscache_FetchBlock
 * FETCH_HIT	Block found by Fscache_FetchBlock or GetUnlockedBlock
 * DELETE	Block being removed, usually from FetchBlock
 * FETCH_WAIT	Fscache_FetchBlock had to wait for the block
 * INVALIDATE	CacheFileInvalidate removed the block
 * WRITE_INVALIDATE CacheFileWriteBack removed the block
 * WRITE	Block cleaner wrote the block
 * ITER_WAIT	GetUnlockedBlock had to wait for the block
 * ITER_WAIT_HIT	GetUnlockedBlock got the block after waiting for it.
 * DIRTY	Block becomming dirty for the first time
 * DELETE_UNLOCK	UnlockBlock discarding the block via CacheFileInvalidate
 * DELETE_TO_FRONT	UnlockBlock moving block to front of LRU list
 * DELETE_TO_REAR	UnlockBlock moving block to rear of LRU list
 */
#define BLOCK_FETCH_INIT	1
#define BLOCK_FETCH_HIT		2
#define BLOCK_DELETE		3
#define BLOCK_FETCH_WAIT	4
#define BLOCK_INVALIDATE	5
#define BLOCK_WRITE_INVALIDATE	6
#define BLOCK_WRITE		7
#define BLOCK_ITER_WAIT		8
#define BLOCK_ITER_WAIT_HIT	9
#define BLOCK_DIRTY		10
#define BLOCK_DELETE_UNLOCK	11
#define BLOCK_TO_FRONT		12
#define BLOCK_TO_REAR		13
#define BLOCK_TO_DIRTY_LIST	14

/*
d115 8
a122 1

d147 3
a149 1
 * Pointer to list of files that have dirty blocks being written to disk.
d151 2
a152 2
static	List_Links	dirtyListHdr;
static	List_Links	*dirtyList = &dirtyListHdr;
a188 3
static	int	numWriteBackBlocks = 0;	/* The number of blocks that are being 
					 * forced back to disk by 
					 * Fscache_WriteBack. */
d191 4
a194 3
static	int	numBlockCleaners;	/* Number of block cleaner processes
					 * currently in action. */
int	fscache_MaxBlockCleaners = FSCACHE_MAX_CLEANER_PROCS;
d210 1
a210 1
 * Debugging stuff.
a211 13
#ifndef CLEAN
/*
 * This macro has to be called with a double set of parenthesis.
 * This lets you pass a variable number of arguments through to printf:
 *	DEBUG_PRINT( ("foo %d\n", 17) );
 */
#define DEBUG_PRINT( format ) \
    if (cacheDebug) {\
	printf format ; \
    }
#else
#define	DEBUG_PRINT(format)
#endif not CLEAN
d213 1
a213 2
static	Boolean	traceDirtyBlocks = FALSE;
static	Boolean	cacheDebug = FALSE;
d218 19
a236 61
static void		PutOnFreeList();
static void		PutFileOnDirtyList();
static void		PutBlockOnDirtyList();
static Boolean		CreateBlock();
static Boolean		DestroyBlock();
static Fscache_Block	*FetchBlock();
static void		CacheWriteBack();
static void		StartBlockCleaner();
static void		ProcessCleanBlock();
static void		CacheFileInvalidate();
static void		GetDirtyFile();
static void		GetDirtyBlock();
static void		GetDirtyBlockInt();
static void		ReallocBlock();
static void		FinishRealloc();
static Hash_Entry	*GetUnlockedBlock();
static void		DeleteBlock();


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_InfoInit --
 *
 * 	Initialize the cache information for a file.  Called when setting
 *	up a handle for a file that uses the block cache.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Set up the fields of the Fscache_FileInfo struct.
 *
 * ----------------------------------------------------------------------------
 */
void
Fscache_InfoInit(cacheInfoPtr, hdrPtr, version, cacheable, attrPtr, ioProcsPtr)
    register Fscache_FileInfo *cacheInfoPtr;	/* Information to initialize. */
    Fs_HandleHeader	     *hdrPtr;		/* Back pointer to handle */
    int			     version;		/* Used to check consistency */
    Boolean		     cacheable;		/* TRUE if server says we can
						 * cache */
    Fscache_Attributes	     *attrPtr;		/* File attributes */
    Fscache_IOProcs	     *ioProcsPtr;	/* IO routines. */
{
    List_InitElement(&cacheInfoPtr->links);
    List_Init(&cacheInfoPtr->dirtyList);
    List_Init(&cacheInfoPtr->blockList);
    List_Init(&cacheInfoPtr->indList);
    cacheInfoPtr->flags = (cacheable ? 0 : FSCACHE_FILE_NOT_CACHEABLE);
    cacheInfoPtr->version = version;
    cacheInfoPtr->hdrPtr = hdrPtr;
    cacheInfoPtr->blocksWritten = 0;
    cacheInfoPtr->noDirtyBlocks.waiting = 0;
    cacheInfoPtr->blocksInCache = 0;
    cacheInfoPtr->numDirtyBlocks = 0;
    cacheInfoPtr->lastTimeTried = 0;
    cacheInfoPtr->attr = *attrPtr;
    cacheInfoPtr->ioProcsPtr = ioProcsPtr;
    Sync_LockInitDynamic(&cacheInfoPtr->lock, "Fs:perFileCacheLock");
}
a237 22

/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_InfoSyncLockCleanup --
 *
 * 	Clean up Sync_Lock tracing for the cache lock.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Set up the fields of the Fscache_FileInfo struct.
 *
 * ----------------------------------------------------------------------------
 */
void
Fscache_InfoSyncLockCleanup(cacheInfoPtr)
    Fscache_FileInfo *cacheInfoPtr;
{
    Sync_LockClear(&cacheInfoPtr->lock);
}
a238 1

d267 9
d300 1
a300 1
    List_Init(dirtyList);
d304 2
a305 1
    for (i = 0,blockAddr = blockCacheStart,blockPtr = (Fscache_Block *)listStart;
d311 1
a311 1
	List_Insert((List_Links *) blockPtr, LIST_ATREAR(unmappedList));
d313 10
a322 1

d331 1
a331 1
	    printf("Fscache_Init: Couldn't create block\n");
d336 1
a345 2
 * 
 *	List Functions
d347 1
a347 1
 * Functions to put objects onto the free and dirty lists.
d349 2
a350 12
 * ----------------------------------------------------------------------------
 */

/*
 * ----------------------------------------------------------------------------
 *
 * PutOnFreeList --
 *
 * 	Put the given block onto one of the two free lists.
 *
 * Results:
 *	None.
a351 46
 * Side effects:
 *	Block either added to the partially free list or the totally free list.
 *	The list of processes waiting on the full cache is notified if
 *	is non-empty.
 *
 * ----------------------------------------------------------------------------
 */
INTERNAL static void
PutOnFreeList(blockPtr)
    register	Fscache_Block	*blockPtr;
{
    register	Fscache_Block	*otherBlockPtr;

    blockPtr->flags = FSCACHE_BLOCK_FREE;
    fs_Stats.blockCache.numFreeBlocks++;
    if (PAGE_IS_8K) {
	/*
	 * If all blocks in the page are free then put this block onto the
	 * totally free list.  Otherwise it goes onto the partially free list.
	 */
	otherBlockPtr = GET_OTHER_BLOCK(blockPtr);
	if (otherBlockPtr->flags & FSCACHE_BLOCK_FREE) {
	    List_Insert((List_Links *) blockPtr, LIST_ATFRONT(totFreeList));
	    List_Move((List_Links *) otherBlockPtr, LIST_ATFRONT(totFreeList));
	} else {
	    List_Insert((List_Links *) blockPtr, LIST_ATFRONT(partFreeList));
	}
    } else {
	List_Insert((List_Links *) blockPtr, LIST_ATFRONT(totFreeList));
    }
    if (! List_IsEmpty(fscacheFullWaitList)) {
	Fsutil_WaitListNotify(fscacheFullWaitList);
    }
}	


/*
 * ----------------------------------------------------------------------------
 *
 * PutFileOnDirtyList --
 *
 * 	Put the given file onto the global dirty list.  This is suppressed
 *	if the file is being deleted.  In this case a concurrent delete
 *	and write-back can end up with a deleted file back on the
 *	dirty list if we are not careful.
 *
d356 3
a358 2
 *	None.
 *
d361 11
a371 3
INTERNAL static void
PutFileOnDirtyList(cacheInfoPtr)
    register	Fscache_FileInfo	*cacheInfoPtr;	/* Cache info for a file */
d373 16
a388 12
    if ((cacheInfoPtr->flags & FSCACHE_FILE_GONE) ||
        (cacheInfoPtr->flags & FSCACHE_FILE_BEING_WRITTEN)) {
	/*
	 * Don't put a file on the dirty list if it has been deleted or
	 * it's already being written.
	 */
	return;
    }
    if (!(cacheInfoPtr->flags & FSCACHE_FILE_ON_DIRTY_LIST)) {
	List_Insert((List_Links *)cacheInfoPtr, LIST_ATREAR(dirtyList));
	cacheInfoPtr->flags |= FSCACHE_FILE_ON_DIRTY_LIST;
    }
a389 1

d394 1
a394 1
 * PutBlockOnDirtyList --
d396 1
a396 2
 * 	Put the given block onto the dirty list for the file, and make
 *	sure that the file is on the list of dirty files.
d402 1
a402 2
 *	The block goes onto the dirty list of the file and the
 *	block cleaner is kicked.
d406 4
a409 8
INTERNAL static void
PutBlockOnDirtyList(blockPtr, shutdown)
    register	Fscache_Block	*blockPtr;	/* Block to put on list. */
    Boolean			shutdown;	/* TRUE => are shutting
						   down the system so the
						   calling process is going
						   to synchronously sync
						   the cache. */
d411 2
a412 1
    register Fscache_FileInfo *cacheInfoPtr = blockPtr->cacheInfoPtr;
a413 8
    blockPtr->flags |= FSCACHE_BLOCK_ON_DIRTY_LIST;
    List_Insert(&blockPtr->dirtyLinks, 
		LIST_ATREAR(&cacheInfoPtr->dirtyList));
    PutFileOnDirtyList(cacheInfoPtr);
    if (!shutdown) {
	StartBlockCleaner(cacheInfoPtr);
    }
}
d417 1
a417 11
 * ----------------------------------------------------------------------------
 *
 *	Functions to create, destroy and allocate cache blocks.  These 
 *	functions are used to provide the variable sized cache and the LRU
 *	algorithm for managing cache blocks.
 *
 * ----------------------------------------------------------------------------
 */

/*
 * ----------------------------------------------------------------------------
d419 1
a419 1
 * CreateBlock --
d421 2
a422 1
 * 	Add a new block to the list of free blocks.
d424 2
a425 2
 * Results:
 *	None.
d428 1
a428 1
 *	Block removed from the unmapped list and put onto the free list.
d430 1
a430 1
 * ----------------------------------------------------------------------------
a431 10
INTERNAL static Boolean
CreateBlock(retBlock, blockPtrPtr)
    Boolean		retBlock;	/* TRUE => return a pointer to one of 
					 * the newly created blocks in 
					 * *blockPtrPtr. */
    Fscache_Block	**blockPtrPtr;	/* Where to return pointer to block.
					 * NIL if caller isn't interested. */
{
    register	Fscache_Block	*blockPtr;
    int				newCachePages;
d433 22
a454 44
    if (List_IsEmpty(unmappedList)) {
	printf( "CreateBlock: No unmapped blocks\n");
	return(FALSE);
    }
    blockPtr = (Fscache_Block *) List_First(unmappedList);
    /*
     * Put memory behind the first available unmapped cache block.
     */
    newCachePages = Vm_MapBlock(blockPtr->blockAddr);
    if (newCachePages == 0) {
	return(FALSE);
    }
    fs_Stats.blockCache.numCacheBlocks += newCachePages * blocksPerPage;
    /*
     * If we are told to return a block then take it off of the list of
     * unmapped blocks and let the caller put it onto the appropriate list.
     * Otherwise put it onto the free list.
     */
    if (retBlock) {
	List_Remove((List_Links *) blockPtr);
	*blockPtrPtr = blockPtr;
    } else {
	fs_Stats.blockCache.numFreeBlocks++;
	blockPtr->flags = FSCACHE_BLOCK_FREE;
	List_Move((List_Links *) blockPtr, LIST_ATREAR(totFreeList));
    }
    if (PAGE_IS_8K) {
	/*
	 * Put the other block in the page onto the appropriate free list.
	 */
	blockPtr = GET_OTHER_BLOCK(blockPtr);
	blockPtr->flags = FSCACHE_BLOCK_FREE;
	fs_Stats.blockCache.numFreeBlocks++;
	if (retBlock) {
	    List_Move((List_Links *) blockPtr, LIST_ATREAR(partFreeList));
	} else {
	    List_Move((List_Links *) blockPtr, LIST_ATREAR(totFreeList));
	}
    }
    if (! List_IsEmpty(fscacheFullWaitList)) {
	Fsutil_WaitListNotify(fscacheFullWaitList);
    }

    return(TRUE);
a455 1

d458 1
a458 1
 * ----------------------------------------------------------------------------
d460 1
a460 1
 * DestroyBlock --
d462 2
a463 1
 * 	Destroy one physical page worth of blocks.
d465 1
a465 2
 * Results:
 *	None.
d468 2
a469 2
 *	Cache blocks have memory removed from behind them and are moved to
 *	the unmapped list. 
d471 1
a471 1
 * ----------------------------------------------------------------------------
a472 7
INTERNAL static Boolean
DestroyBlock(retOnePage, pageNumPtr)
    Boolean	retOnePage;
    int		*pageNumPtr;
{
    register	Fscache_Block	*blockPtr;
    register	Fscache_Block	*otherBlockPtr;
d474 3
a476 93
    /*
     * First try the list of totally free pages.
     */
    if (!List_IsEmpty(totFreeList)) {
	DEBUG_PRINT( ("DestroyBlock: Using tot free block to lower size\n") );
	blockPtr = (Fscache_Block *) List_First(totFreeList);
	fs_Stats.blockCache.numCacheBlocks -= 
		    Vm_UnmapBlock(blockPtr->blockAddr, retOnePage,
				  (unsigned int *)pageNumPtr) * blocksPerPage;
	blockPtr->flags = FSCACHE_NOT_MAPPED;
	List_Move((List_Links *) blockPtr, LIST_ATREAR(unmappedList));
	fs_Stats.blockCache.numFreeBlocks--;
	if (PAGE_IS_8K) {
	    /*
	     * Unmap the other block.  The block address can point to either
	     * of the two blocks.
	     */
	    blockPtr = GET_OTHER_BLOCK(blockPtr);
	    blockPtr->flags = FSCACHE_NOT_MAPPED;
	    List_Move((List_Links *) blockPtr, LIST_ATREAR(unmappedList));
	    fs_Stats.blockCache.numFreeBlocks--;
	}
	return(TRUE);
    }

    /*
     * Now take blocks from the LRU list until we get one that we can use.
     */
    while (TRUE) {
	blockPtr = FetchBlock(FALSE);
	if (blockPtr == (Fscache_Block *) NIL) {
	    /*
	     * There are no clean blocks left so give up.
	     */
	    DEBUG_PRINT( ("DestroyBlock: No clean blocks left (1)\n") );
	    return(FALSE);
	}
	if (PAGE_IS_8K) {
	    /*
	     * We have to deal with the other block.  If it is in use, then
	     * we can't take this page.  Otherwise delete the block from
	     * the cache and put it onto the unmapped list.
	     */
	    otherBlockPtr = GET_OTHER_BLOCK(blockPtr);
	    if (otherBlockPtr->refCount > 0 ||
		(otherBlockPtr->flags & FSCACHE_BLOCK_ON_DIRTY_LIST) ||
		(otherBlockPtr->flags & FSCACHE_BLOCK_DIRTY)) {
		DEBUG_PRINT( ("DestroyBlock: Other block in use.\n") );
		PutOnFreeList(blockPtr);
		continue;
	    }
	    /*
	     * The other block is cached but not in use.  Delete it.
	     */
	    if (!(otherBlockPtr->flags & FSCACHE_BLOCK_FREE)) {
		DeleteBlock(otherBlockPtr);
	    }
	    otherBlockPtr->flags = FSCACHE_NOT_MAPPED;
	    List_Move((List_Links *) otherBlockPtr, LIST_ATREAR(unmappedList));
	}
	DEBUG_PRINT( ("DestroyBlock: Using in-use block to lower size\n") );
	blockPtr->flags = FSCACHE_NOT_MAPPED;
	List_Insert((List_Links *) blockPtr, LIST_ATREAR(unmappedList));
	fs_Stats.blockCache.numCacheBlocks -= 
		    Vm_UnmapBlock(blockPtr->blockAddr, 
				retOnePage, (unsigned int *)pageNumPtr)
		    * blocksPerPage;
	return(TRUE);
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 * FetchBlock --
 *
 *	Return a pointer to the oldest available block on the lru list.
 *	If had to sleep because all of memory is dirty then return NIL.
 *	In this cause our caller has to retry various free lists.
 *
 * Results:
 *	Pointer to oldest available block, NIL if had to wait.  
 *
 * Side effects:
 *	Block deleted.
 *
 * ----------------------------------------------------------------------------
 */
static INTERNAL Fscache_Block *
FetchBlock(canWait)
    Boolean	canWait;	/* TRUE implies can sleep if all of memory is 
				 * dirty. */
a477 46
    register	Fscache_Block	*blockPtr;

    if (List_IsEmpty(lruList)) {
	printf("FetchBlock: LRU list is empty\n");
	return((Fscache_Block *) NIL);
    }

    /* 
     * Scan list for unlocked, clean block.
     */
    LIST_FORALL(lruList, (List_Links *) blockPtr) {
	if (blockPtr->refCount > 0) {
	    /*
	     * Block is locked.
	     */
	} else if (blockPtr->flags & FSCACHE_BLOCK_ON_DIRTY_LIST) {
	    /*
	     * Block is being cleaned.  Mark it so that it will be freed
	     * after it has been cleaned.
	     */
	    blockPtr->flags |= FSCACHE_MOVE_TO_FRONT;
	} else if (blockPtr->flags & FSCACHE_BLOCK_DIRTY) {
	    /*
	     * Put a pointer to the block in the dirty list.  
	     * After it is cleaned it will be freed.
	     */
	    FSUTIL_TRACE_BLOCK(BLOCK_TO_DIRTY_LIST, blockPtr);
	    PutBlockOnDirtyList(blockPtr, FALSE);
	    blockPtr->flags |= FSCACHE_MOVE_TO_FRONT;
	} else if (blockPtr->flags & FSCACHE_BLOCK_DELETED) {
	    printf( "FetchBlock: deleted block %d of file %d in LRU list\n",
		blockPtr->blockNum, blockPtr->fileNum);
	} else if (blockPtr->flags & FSCACHE_BLOCK_BEING_WRITTEN) {
	    printf( "FetchBlock: block %d of file %d caught being written\n",
		blockPtr->blockNum, blockPtr->fileNum);
	} else {
	    /*
	     * This block is clean and unlocked.  Delete it from the
	     * hash table and use it.
	     */
	    fs_Stats.blockCache.lru++;
	    List_Remove((List_Links *) blockPtr);
	    DeleteBlock(blockPtr);
	    return(blockPtr);
	}
    }
a478 34
    /*
     * We have looked at every block but we couldn't use any.
     * If possible wait until the block cleaner cleans a block for us.
     */
    DEBUG_PRINT( ("All blocks dirty\n") );
    if (canWait) {
	DEBUG_PRINT( ("Waiting for clean block\n") );
	(void) Sync_Wait(&cleanBlockCondition, FALSE);
    }
    return((Fscache_Block *) NIL);
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_SetMinSize --
 *
 * 	Set the minimum size of the block cache.  This will entail mapping
 *	enough blocks so that the number of physical pages in use is greater
 *	than or equal to the minimum number.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	More blocks get memory put behind them.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY void
Fscache_SetMinSize(minBlocks)
    int	minBlocks;	/* The minimum number of blocks in the cache. */
{
d481 1
a481 12

    DEBUG_PRINT( ("Setting minimum size to %d with current size of %d\n",
		       minBlocks, fs_Stats.blockCache.minCacheBlocks) );

    if (minBlocks > fs_Stats.blockCache.maxNumBlocks) {
	minBlocks = fs_Stats.blockCache.maxNumBlocks;
	printf( "Fscache_SetMinSize: Only raising min cache size to %d blocks\n", 
				minBlocks);
    }
    fs_Stats.blockCache.minCacheBlocks = minBlocks;
    if (fs_Stats.blockCache.minCacheBlocks <= 
				    fs_Stats.blockCache.numCacheBlocks) {
d483 1
d486 2
a487 1

d489 2
a490 2
     * Give enough blocks memory so that the minimum cache size requirement
     * is met.
d492 7
a498 46
    while (fs_Stats.blockCache.numCacheBlocks < 
					fs_Stats.blockCache.minCacheBlocks) {
	if (!CreateBlock(FALSE, (Fscache_Block **) NIL)) {
	    printf("Fscache_SetMinSize: lowered min cache size to %d blocks\n",
		       fs_Stats.blockCache.numCacheBlocks);
	    fs_Stats.blockCache.minCacheBlocks = 
				    fs_Stats.blockCache.numCacheBlocks;
	}
    }

    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_SetMaxSize --
 *
 * 	Set the maximum size of the block cache.  This entails freeing
 *	enough main memory pages so that the number of cache pages is
 *	less than the maximum allowed.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Cache blocks have memory removed from behind them and are moved to
 *	the unmapped list. 
 *
 * ----------------------------------------------------------------------------
 */
ENTRY void
Fscache_SetMaxSize(maxBlocks)
    int	maxBlocks;	/* The minimum number of pages in the cache. */
{
    Boolean			giveUp;
    int				pageNum;

    LOCK_MONITOR;

    if (maxBlocks > fs_Stats.blockCache.maxNumBlocks) {
	maxBlocks = fs_Stats.blockCache.maxNumBlocks;
	printf("Fscache_SetMaxSize: Only raising max cache size to %d blocks\n",
		maxBlocks);
    }
d500 1
a500 15
    fs_Stats.blockCache.maxCacheBlocks = maxBlocks;
    if (fs_Stats.blockCache.maxCacheBlocks >= 
				    fs_Stats.blockCache.numCacheBlocks) {
	UNLOCK_MONITOR;
	return;
    }
    
    /*
     * Free enough pages to get down to maximum size.
     */
    giveUp = FALSE;
    while (fs_Stats.blockCache.numCacheBlocks > 
				fs_Stats.blockCache.maxCacheBlocks && !giveUp) {
	giveUp = !DestroyBlock(FALSE, &pageNum);
    }
a501 7
#ifndef CLEAN
    if (cacheDebug && giveUp) {
	printf("Fscache_SetMaxSize: Could only lower cache to %d\n", 
					fs_Stats.blockCache.numCacheBlocks);
    }
#endif not CLEAN
    
d503 1
a505 40

/*
 * ----------------------------------------------------------------------------
 *
 * Fscache_GetPageFromFS --
 *
 * 	Compare LRU time of the caller to time of block in LRU list and
 *	if caller has newer pages unmap a block and return a page.
 *
 * Results:
 *	Physical page number if unmap a block.
 *
 * Side effects:
 *	Blocks may be unmapped.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY void
Fscache_GetPageFromFS(timeLastAccessed, pageNumPtr)
    int	timeLastAccessed;
    int	*pageNumPtr;
{
    register	Fscache_Block	*blockPtr;

    LOCK_MONITOR;

    fs_Stats.blockCache.vmRequests++;
    *pageNumPtr = -1;
    if (fs_Stats.blockCache.numCacheBlocks > 
		fs_Stats.blockCache.minCacheBlocks && !List_IsEmpty(lruList)) {
	fs_Stats.blockCache.triedToGiveToVM++;
	blockPtr = (Fscache_Block *) List_First(lruList);
	if (blockPtr->timeReferenced < timeLastAccessed) {
	    fs_Stats.blockCache.vmGotPage++;
	    (void) DestroyBlock(TRUE, pageNumPtr);
	}
    }

    UNLOCK_MONITOR;
}
d552 1
d569 2
a570 1
    register Boolean		dontBlock = (flags & FSCACHE_DONT_BLOCK);
d586 1
d588 12
a599 4
	    if (((flags & FSCACHE_IO_IN_PROGRESS) && 
		 blockPtr->refCount > 0) ||
		(blockPtr->flags & FSCACHE_IO_IN_PROGRESS)) {
		if (! dontBlock) {
a603 1
		    FSUTIL_TRACE_BLOCK(BLOCK_FETCH_WAIT, blockPtr);
d609 9
a620 1
		FSUTIL_TRACE_BLOCK(BLOCK_FETCH_HIT, blockPtr);
d628 1
a628 1
	    if (!List_IsEmpty(partFreeList)) {
d630 1
a630 1
		 * Use partially free blocks first.
d632 22
a653 17
		fs_Stats.blockCache.numFreeBlocks--;
		fs_Stats.blockCache.partFree++;
		blockPtr = (Fscache_Block *) List_First(partFreeList);
		List_Remove((List_Links *) blockPtr);
	    } else if (!List_IsEmpty(totFreeList)) {
		/*
		 * Can't find a partially free block so use a totally free
		 * block.
		 */
		fs_Stats.blockCache.numFreeBlocks--;
		fs_Stats.blockCache.totFree++;
		blockPtr = (Fscache_Block *) List_First(totFreeList);
		List_Remove((List_Links *) blockPtr);
		if (PAGE_IS_8K) {
		    otherBlockPtr = GET_OTHER_BLOCK(blockPtr);
		    List_Move((List_Links *) otherBlockPtr,
				  LIST_ATREAR(partFreeList));
d655 2
a656 1
	    } else {
d662 1
a662 1
					    fs_Stats.blockCache.maxCacheBlocks) {
d666 4
a669 1
		    blockPtr = FetchBlock(!dontBlock);
d675 1
a675 3
		    blockPtr = (Fscache_Block *) List_First(lruList);
		    DEBUG_PRINT( ("FsCacheBlockFetch: fs=%d vm=%d\n", 
				       blockPtr->timeReferenced, refTime) );
d677 1
a677 1
			DEBUG_PRINT( ("FsCacheBlockFetch:Creating new block\n" ));
d679 1
a679 2
			    DEBUG_PRINT( ("FsCacheBlockFetch: Couldn't create block\n" ));
			    blockPtr = FetchBlock(!dontBlock);
d689 1
a689 2
			DEBUG_PRINT( ("FsCacheBlockFetch: Recycling block\n") );
			blockPtr = FetchBlock(!dontBlock);
d696 1
a696 6
	     * ploys to get a free block. There used to be a bug
	     * where the first hash didn't find the block, FetchBlock
	     * waited for room in the cache, and the block reappeared
	     * in the cache but FetchBlock was called to get a new block
	     * anyway - the hash was not redone so a block could have
	     * been put into the hash table twice.
d705 1
d714 1
a714 1
	blockPtr->timeReferenced = fsutil_TimeInSeconds;
a715 1
	FSUTIL_TRACE_BLOCK(BLOCK_FETCH_INIT, blockPtr);
d723 1
a723 1
	List_Insert((List_Links *) blockPtr, LIST_ATREAR(lruList));
d730 4
a771 48
 * Fscache_MoveBlock --
 *
 *	Change the disk location of a block.  This has to synchronize
 *	with delayed writes.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The diskBlock field of the cache block is modified.  The block is
 *	not marked dirty, however.  That will be done by UnlockBlock.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fscache_MoveBlock(blockPtr, diskBlock, blockSize)
    Fscache_Block *blockPtr;	/* Pointer to block information for block.*/
    int diskBlock;		/* New location for the block */
    int blockSize;		/* New size for the block */
{
    LOCK_MONITOR;

    if (diskBlock != -1) {
	if (blockPtr->diskBlock != diskBlock ||
	    blockPtr->blockSize != blockSize) {
	    while (blockPtr->flags & FSCACHE_BLOCK_BEING_WRITTEN) {
		(void)Sync_Wait(&blockPtr->ioDone, FALSE);
	    }
	    blockPtr->diskBlock = diskBlock;
	    blockPtr->blockSize = blockSize;
	}
    } else if (blockPtr->blockSize == -1 && blockSize > 0) {
	/*
	 * Patch up the block size so our internal fragmentation
	 * calculation is correct.  The size of a read-only block
	 * is not used for anything else.
	 */
	blockPtr->blockSize = blockSize;
    }

    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
d797 1
a797 1
				 * FSCACHE_WRITE_TO_DISK */
d816 11
a826 1
	FSUTIL_TRACE_BLOCK(BLOCK_DELETE_UNLOCK, blockPtr);
a835 1

d837 4
a846 6
	    blockPtr->cacheInfoPtr->numDirtyBlocks++;
	    if (traceDirtyBlocks) {
		printf("UNL FD=%d Num=%d\n",
			   blockPtr->cacheInfoPtr->hdrPtr->fileID.minor,
			   blockPtr->cacheInfoPtr->numDirtyBlocks);
	    }
d849 4
a852 1
	    FSUTIL_TRACE_BLOCK(BLOCK_DIRTY, blockPtr);
a854 1

d856 2
a857 25
	if (blockPtr->diskBlock != diskBlock ||
	    blockPtr->blockSize != blockSize) {
	    /*
	     * The caller is changing where this block lives on disk.  If
	     * so we have to wait until the block has finished being written
	     * before we can allow this to happen.
	     */
	    while (blockPtr->flags & FSCACHE_BLOCK_BEING_WRITTEN) {
		(void)Sync_Wait(&blockPtr->ioDone, FALSE);
		if (timeDirtied != 0 &&
		    (blockPtr->flags & FSCACHE_BLOCK_BEING_WRITTEN) == 0) {
		    /*
		     * I assert that the cache block is no longer marked
		     * dirty and may never be written out to its proper
		     * location.
		     */
		    if ((blockPtr->flags & FSCACHE_BLOCK_DIRTY) == 0) {
			printf("Fscache_UnlockBlock: file <%d,%d> block %d disk block %d => %d no longer dirty\n",
			    blockPtr->cacheInfoPtr->hdrPtr->fileID.major,
			    blockPtr->cacheInfoPtr->hdrPtr->fileID.minor,
			   blockPtr->blockNum, blockPtr->diskBlock, diskBlock);
		    }
		}
	    }
	    blockPtr->diskBlock = diskBlock;
d875 9
d885 1
a885 1
	    StartBlockCleaner(blockPtr->cacheInfoPtr);
d894 1
a894 1
	    if (blockPtr->flags & FSCACHE_BLOCK_ON_DIRTY_LIST) {
d897 1
a897 2
		FSUTIL_TRACE_BLOCK(BLOCK_TO_FRONT, blockPtr);
		List_Move((List_Links *) blockPtr, LIST_ATFRONT(lruList));
d905 1
a905 1
	    blockPtr->timeReferenced = fsutil_TimeInSeconds;
d907 1
a907 1
	    List_Move((List_Links *) blockPtr, LIST_ATREAR(lruList));
d912 2
a913 1
	if (((blockPtr->flags & (FSCACHE_BLOCK_DIRTY | FSCACHE_BLOCK_BEING_WRITTEN)) &&
d918 1
a918 1
		 || (flags & FSCACHE_WRITE_TO_DISK)) {
d931 1
a931 3
		    if (!(blockPtr->flags & FSCACHE_BLOCK_ON_DIRTY_LIST)) {
			PutBlockOnDirtyList(blockPtr, FALSE);
		    }
d937 1
a937 3
		if (!(blockPtr->flags & FSCACHE_BLOCK_ON_DIRTY_LIST)) {
		    PutBlockOnDirtyList(blockPtr, FALSE);
		}
d944 1
a944 1
			(FSCACHE_BLOCK_DIRTY | FSCACHE_BLOCK_BEING_WRITTEN));
d948 1
d987 6
a992 1
	blockPtr->blockSize = newBlockSize;
a1046 1
static void	DeleteBlockFromDirtyList();
a1077 1
    FSUTIL_TRACE_IO(FSUTIL_TRACE_SRV_WRITE_1, cacheInfoPtr->hdrPtr->fileID, firstBlock, lastBlock);
d1088 4
d1099 1
a1099 2
	    FSUTIL_TRACE_BLOCK(BLOCK_INVALIDATE, blockPtr);
    
a1103 3
	    if (blockPtr->flags & FSCACHE_BLOCK_ON_DIRTY_LIST) {
		DeleteBlockFromDirtyList(blockPtr);
	    }
d1106 2
a1107 5
		if (traceDirtyBlocks) {
		    printf("Inv FD=%d Num=%d\n", 
			    cacheInfoPtr->hdrPtr->fileID.minor,
			    cacheInfoPtr->numDirtyBlocks);
		}
d1109 1
a1109 1
	    List_Remove((List_Links *) blockPtr);
a1112 1

d1148 2
a1149 1
        List_IsEmpty(&cacheInfoPtr->dirtyList)) {
d1156 1
a1156 1
	cacheInfoPtr->flags &= ~FSCACHE_FILE_ON_DIRTY_LIST;
a1159 7
    if (blockPtr->flags & FSCACHE_WRITE_BACK_WAIT) {
	numWriteBackBlocks--;
	blockPtr->flags &= ~FSCACHE_WRITE_BACK_WAIT;
	if (numWriteBackBlocks == 0) {
	    Sync_Broadcast(&writeBackComplete);
	}
    }
d1163 50
d1237 1
a1237 1
				 * FSCACHE_WRITE_BACK_AND_INVALIDATE |
d1247 2
d1254 15
d1277 16
a1292 1
    if (cacheInfoPtr->blocksInCache == 0) {
d1306 1
d1321 6
a1340 8
	    if (flags & FSCACHE_WRITE_BACK_AND_INVALIDATE) {
		cacheInfoPtr->blocksInCache--;
		List_Remove(&blockPtr->fileLinks);
		Hash_Delete(blockHashTable, hashEntryPtr);
		List_Remove((List_Links *) blockPtr);
		blockPtr->flags |= FSCACHE_BLOCK_DELETED;
		FSUTIL_TRACE_BLOCK(BLOCK_WRITE_INVALIDATE, blockPtr);
	    }
d1350 17
a1366 11
	/*
	 * Write back the block.  If the block is already being waited on then
	 * don't have to do anything special.
	 */
	if (blockPtr->flags & FSCACHE_BLOCK_ON_DIRTY_LIST) {
	    /*
	     * Blocks already on the dirty list, no need to do anything.
	     */
	} else if (blockPtr->flags & FSCACHE_BLOCK_DIRTY) {
	    PutBlockOnDirtyList(blockPtr, FALSE);
	    if (flags & FSCACHE_FILE_WB_WAIT) {
d1368 2
a1369 1
		 * Synchronous invalidation... record statistics.
d1371 7
a1377 12
		fs_Stats.blockCache.blocksFlushed++;
		if (flags & FSCACHE_WB_MIGRATION) {
		    fs_Stats.blockCache.migBlocksFlushed++;
		}
	    }
	} else if (flags & FSCACHE_WRITE_BACK_AND_INVALIDATE) {
	    /*
	     * This block is clean.  We need to free it if it is to be
	     * invalidated.
	     */
	    PutOnFreeList(blockPtr);
	}
d1379 2
a1380 20

    /*
     * If required write-back indirect blocks as well.
     */
    if (flags & FSCACHE_WRITE_BACK_INDIRECT) {
	register List_Links	*linkPtr;
	LIST_FORALL(&cacheInfoPtr->indList, linkPtr) {
	    blockPtr = FILE_LINKS_TO_BLOCK(linkPtr);
	    if (blockPtr->flags & FSCACHE_BLOCK_ON_DIRTY_LIST) {
		/*
		 * Blocks already on the dirty list, no need to do anything.
		 */
	    } else if (blockPtr->flags & FSCACHE_BLOCK_DIRTY) {
		PutBlockOnDirtyList(blockPtr, TRUE);
	    }
	}
    }

    if (!List_IsEmpty(&cacheInfoPtr->dirtyList)) {
	StartBlockCleaner(cacheInfoPtr);
d1387 18
a1404 6
	while (!List_IsEmpty(&cacheInfoPtr->dirtyList) && 
	       !(cacheInfoPtr->flags & 
		    (FSCACHE_SERVER_DOWN | FSCACHE_NO_DISK_SPACE |
		     FSCACHE_DOMAIN_DOWN | FSCACHE_GENERIC_ERROR)) &&
	       !sys_ShuttingDown) {
	    (void) Sync_Wait(&cacheInfoPtr->noDirtyBlocks, FALSE);
d1548 5
d1560 2
a1561 1
	if (blockPtr->flags & FSCACHE_BLOCK_ON_DIRTY_LIST) {
d1571 1
a1571 1
	    List_Move((List_Links *) blockPtr, LIST_ATFRONT(lruList));
d1599 1
a1599 2
 *	writeBackTime to disk (or the server).  If writeBackTime equals 
 *	-1 then all blocks are written back.
d1611 1
a1611 1
Fscache_WriteBack(writeBackTime, blocksSkippedPtr, shutdown)
d1616 1
a1616 1
    Boolean	shutdown;	   /* TRUE if the system is being shut down. */
d1619 1
a1619 2

    CacheWriteBack(writeBackTime, blocksSkippedPtr, shutdown, shutdown);
d1652 1
a1652 1
    CacheWriteBack(-1, &blocksSkipped, FALSE, TRUE);
d1656 1
a1656 1
	blockPtr = (Fscache_Block *)nextPtr;
d1659 2
a1660 1
	    (blockPtr->flags & (FSCACHE_BLOCK_DIRTY | FSCACHE_BLOCK_ON_DIRTY_LIST))) {
d1666 1
a1666 1
	    List_Remove((List_Links *) blockPtr);
d1695 1
a1695 1
CacheWriteBack(writeBackTime, blocksSkippedPtr, shutdown, writeTmpFiles)
a1699 1
    Boolean	shutdown;	   /* TRUE if the system is being shut down. */
a1704 2
    register Fscache_Block 	*blockPtr;
    register List_Links	  	*listPtr;
d1706 1
d1708 1
a1708 1
    currentTime = fsutil_TimeInSeconds;
d1711 20
a1730 27

    listPtr = lruList;
    LIST_FORALL(listPtr, (List_Links *) blockPtr) {
	cacheInfoPtr = blockPtr->cacheInfoPtr;
	if (fsutil_DelayTmpFiles && !writeTmpFiles &&
	    Fsdm_FindFileType(cacheInfoPtr) == FSUTIL_FILE_TYPE_TMP) {
	    continue;
	}
	if (cacheInfoPtr->flags & FSCACHE_SERVER_DOWN) {
	    /*
	     * Don't bother to write-back files for which the server is
	     * down.  These will be written back during recovery.
	     */
	    continue;
	}
	if (cacheInfoPtr->flags &
		(FSCACHE_NO_DISK_SPACE | FSCACHE_DOMAIN_DOWN |
		 FSCACHE_GENERIC_ERROR)) {
	    /*
	     * Retry for these types of errors.
	     */
	    if (cacheInfoPtr->lastTimeTried < currentTime) {
		cacheInfoPtr->flags &=
			    ~(FSCACHE_NO_DISK_SPACE | FSCACHE_DOMAIN_DOWN |
			      FSCACHE_GENERIC_ERROR);
		StartBlockCleaner(cacheInfoPtr);
	    } else {
d1733 22
d1756 55
a1810 25
	if (blockPtr->refCount > 0) {
	    /* 
	     * Skip locked blocks because they might be in the process of
	     * being modified.
	     */
	    (*blocksSkippedPtr)++;
	    continue;
	}
	if (blockPtr->flags & FSCACHE_WRITE_BACK_WAIT) {
	    /*
	     * Someone is already waiting on this block.  This means that
	     * numWriteBackBlocks has been incremented once already for this
	     * block so no need to increment it again.
	     */
	    continue;
	}
	if (blockPtr->flags & FSCACHE_BLOCK_ON_DIRTY_LIST) {
	    blockPtr->flags |= FSCACHE_WRITE_BACK_WAIT;
	    numWriteBackBlocks++;
	} else if ((blockPtr->flags & FSCACHE_BLOCK_DIRTY) &&
		   (blockPtr->timeDirtied < writeBackTime || shutdown)) {
	    PutBlockOnDirtyList(blockPtr, shutdown);
	    blockPtr->flags |= FSCACHE_WRITE_BACK_WAIT;
	    numWriteBackBlocks++;
	}
d1812 12
a1823 3
    if (!shutdown && numWriteBackBlocks > 0) {
	while (numWriteBackBlocks > 0 && !sys_ShuttingDown) {
	    (void) Sync_Wait(&writeBackComplete, FALSE);
d1826 2
d1834 12
a1845 1
 *	Functions to clean dirty blocks.
d1849 31
d1881 2
a1882 1
#define WRITE_RETRY_INTERVAL	30
d1884 1
d1888 1
a1888 1
 * Fscache_CleanBlocks
d1890 2
a1891 2
 *	Write all blocks on the dirty list to disk.  Called either from
 *	a block cleaner process or synchronously during system shutdown.
d1894 1
a1894 1
 *     	None.
d1897 1
a1897 1
 *     	The dirty list is emptied.
d1901 4
a1904 8
/*ARGSUSED*/
void
Fscache_CleanBlocks(data, callInfoPtr)
    ClientData		data;		/* Background flag.  If TRUE it means
					 * we are called from a block cleaner
					 * process.  Otherwise we being called
					 * synchrounously during a shutdown */
    Proc_CallInfo	*callInfoPtr;	/* Not Used. */
a1905 1
    Boolean			backGround;
d1907 17
a1923 42
    Fscache_Block		*tBlockPtr;
    ReturnStatus		status;
    int				lastDirtyBlock;
    Fscache_FileInfo		*cacheInfoPtr;
    Boolean			useSameBlock;
    int				numDirtyFiles = 0;
    int				numDirtyBlocks = 0;

    backGround = (Boolean) data;
    GetDirtyFile(backGround, &cacheInfoPtr, &tBlockPtr, &lastDirtyBlock);
    blockPtr = tBlockPtr;
    while (cacheInfoPtr != (Fscache_FileInfo *)NIL) {
	numDirtyFiles++;
	while (blockPtr != (Fscache_Block *)NIL) {
	    if (blockPtr->blockSize < 0) {
		panic( "Fscache_CleanBlocks, uninitialized block size\n");
		status = FAILURE;
		break;
	    }
	    /*
	     * Gather statistics.
	     */
	    numDirtyBlocks++;
	    fs_Stats.blockCache.blocksWrittenThru++;
	    switch (blockPtr->flags &
		    (FSCACHE_DATA_BLOCK | FSCACHE_IND_BLOCK |
		     FSCACHE_DESC_BLOCK | FSCACHE_DIR_BLOCK)) {
		case FSCACHE_DATA_BLOCK:
		    fs_Stats.blockCache.dataBlocksWrittenThru++;
		    break;
		case FSCACHE_IND_BLOCK:
		    fs_Stats.blockCache.indBlocksWrittenThru++;
		    break;
		case FSCACHE_DESC_BLOCK:
		    fs_Stats.blockCache.descBlocksWrittenThru++;
		    break;
		case FSCACHE_DIR_BLOCK:
		    fs_Stats.blockCache.dirBlocksWrittenThru++;
		    break;
		default:
		    printf( "Fscache_CleanBlocks: Unknown block type\n");
	    }
d1925 10
a1934 44
	    /*
	     * Write the block.
	     */
	    FSUTIL_TRACE_BLOCK(BLOCK_WRITE, blockPtr);
	    status = (cacheInfoPtr->ioProcsPtr->blockWrite)
		    (cacheInfoPtr->hdrPtr, blockPtr, lastDirtyBlock);
#ifdef lint
	    status = Fsio_FileBlockWrite(cacheInfoPtr->hdrPtr,
			blockPtr, lastDirtyBlock);
	    status = FsrmtFileBlockWrite(cacheInfoPtr->hdrPtr,
			blockPtr, lastDirtyBlock);
#endif /* lint */
	    ProcessCleanBlock(cacheInfoPtr, blockPtr, status,
			      &useSameBlock, &lastDirtyBlock);
	    if (status != SUCCESS) {
		break;
	    }
	    if (!useSameBlock) {
		GetDirtyBlock(cacheInfoPtr, &tBlockPtr, &lastDirtyBlock);
		blockPtr = tBlockPtr;
	    }
	}
	GetDirtyFile(backGround, &cacheInfoPtr, &tBlockPtr, &lastDirtyBlock);
	blockPtr = tBlockPtr;
    }
    fs_Stats.writeBack.passes++;
    fs_Stats.writeBack.files += numDirtyFiles;
    fs_Stats.writeBack.blocks += numDirtyBlocks;
    if (numDirtyBlocks > fs_Stats.writeBack.maxBlocks) {
	fs_Stats.writeBack.maxBlocks = numDirtyBlocks;
    }
}

/*
 * ----------------------------------------------------------------------------
 *
 * StartBlockCleaner --
 *
 * 	Start a block cleaner process to write out a newly added page to
 *	the given file's dirty list.
 *
 * Results:
 *	None.
 *
d1936 1
a1936 1
 *	Number of block cleaner processes may be incremented.
d1940 7
a1946 3
static INTERNAL void
StartBlockCleaner(cacheInfoPtr)
    Fscache_FileInfo *cacheInfoPtr;	/* Cache info for the file. */
d1948 58
a2005 16
    if (!(cacheInfoPtr->flags & FSCACHE_FILE_BEING_WRITTEN) &&
	numBlockCleaners < fscache_MaxBlockCleaners) {
	Proc_CallFunc(Fscache_CleanBlocks, (ClientData) TRUE, 0);
	numBlockCleaners++;
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 *  GetDirtyFile --
 *
 *     	Take the first dirty file off of the dirty file list and
 *	return a pointer to the cache state for that file.  This
 *	is used by the block cleaner to walk through the dirty list.
d2008 1
a2008 3
 *	A pointer to the cache state for the first file on the dirty list.
 *	If there are no files then a NIL pointer is returned.  Also a
 *	pointer to the first block on the dirty list for the file is returned.
d2011 2
a2012 3
 *      An element is removed from the dirty file list.  The fact that
 *	the dirty list links are at the beginning of the cacheInfo struct
 *	is well known and relied on to map from the dirty list to cacheInfoPtr.
d2016 4
a2019 6
ENTRY static void
GetDirtyFile(backGround, cacheInfoPtrPtr, blockPtrPtr, lastDirtyBlockPtr)
    Boolean		backGround;
    Fscache_FileInfo	**cacheInfoPtrPtr;
    Fscache_Block	**blockPtrPtr;
    int			*lastDirtyBlockPtr;
d2021 3
a2023 1
    register Fscache_FileInfo *cacheInfoPtr;
d2025 32
a2056 1
    LOCK_MONITOR;
d2058 8
a2065 14
    *cacheInfoPtrPtr = (Fscache_FileInfo *)NIL;

    if (List_IsEmpty(dirtyList)) {
	if (backGround) {
	    numBlockCleaners--;
	}
	UNLOCK_MONITOR;
	return;
    }

    LIST_FORALL(dirtyList, (List_Links *)cacheInfoPtr) {
	if (cacheInfoPtr->flags & FSCACHE_SERVER_DOWN) {
	    /*
	     * The host is down for this file.
d2067 3
a2069 2
	    continue;
	} else if (cacheInfoPtr->flags & FSCACHE_CLOSE_IN_PROGRESS) {
d2071 3
a2073 2
	     * Close in progress on the file the block lives in so we aren't
	     * allowed to write any more blocks.
d2075 7
a2081 2
	    continue;
	} else if (cacheInfoPtr->flags & FSCACHE_FILE_GONE) {
d2083 1
a2083 1
	     * The file is being deleted.
d2085 2
a2086 11
	    printf("FsGetDirtyFile skipping deleted file <%d,%d> \"%s\"\n",
		cacheInfoPtr->hdrPtr->fileID.major,
		cacheInfoPtr->hdrPtr->fileID.minor,
		Fsutil_HandleName(cacheInfoPtr->hdrPtr));
	    continue;
	} else if (cacheInfoPtr->flags & 
		       (FSCACHE_NO_DISK_SPACE | FSCACHE_DOMAIN_DOWN |
		        FSCACHE_GENERIC_ERROR)) {
	    if (fsutil_TimeInSeconds - cacheInfoPtr->lastTimeTried <
			WRITE_RETRY_INTERVAL) {
		continue;
d2088 2
a2089 3
	    cacheInfoPtr->flags &= 
			    ~(FSCACHE_NO_DISK_SPACE | FSCACHE_DOMAIN_DOWN |
			      FSCACHE_GENERIC_ERROR);
d2091 8
a2098 9
	List_Remove((List_Links *)cacheInfoPtr);
	cacheInfoPtr->flags |= FSCACHE_FILE_BEING_WRITTEN;
	cacheInfoPtr->flags &= ~FSCACHE_FILE_ON_DIRTY_LIST;
	GetDirtyBlockInt(cacheInfoPtr, blockPtrPtr, lastDirtyBlockPtr);
	if (*blockPtrPtr != (Fscache_Block *)NIL) {
	    *cacheInfoPtrPtr = cacheInfoPtr;
	
	    UNLOCK_MONITOR;
	    return;
d2100 1
a2100 5
    }

    FSCACHE_DEBUG_PRINT("GetDirtyFile: All files unusable\n");
    if (backGround) {
	numBlockCleaners--;
a2101 1
    UNLOCK_MONITOR;
d2108 1
a2108 1
 *  GetDirtyBlock --
d2110 3
a2112 2
 *     	Take the first block off of the dirty list for a file and
 *	return a pointer to it.  This calls GetDirtyBlockInt to do the work.
d2115 1
a2115 2
 *	A pointer to the first block on the file's dirty list,
 *	or NIL if list is empty.
d2118 1
a2118 1
 *	None.
d2122 5
a2126 5
ENTRY static void
GetDirtyBlock(cacheInfoPtr, blockPtrPtr, lastDirtyBlockPtr)
    Fscache_FileInfo	*cacheInfoPtr;
    Fscache_Block	**blockPtrPtr;
    int			*lastDirtyBlockPtr;
d2128 78
a2205 1
    LOCK_MONITOR;
d2207 5
a2211 1
    GetDirtyBlockInt(cacheInfoPtr, blockPtrPtr, lastDirtyBlockPtr);
d2213 5
a2217 1
    UNLOCK_MONITOR;
d2224 1
a2224 1
 *  GetDirtyBlockInt --
d2226 1
a2226 1
 *     	Take the first page off of a file's dirty list and return a pointer
d2234 1
a2234 1
 *     A pointer to the first block on the dirty list (NIL if list is empty).
d2237 1
a2237 3
 *     The block's state is changed from ``dirty'' to ``being written''.
 *	If the block's file is being closed this puts the file
 *	back onto the file dirty list and doens't return a block.
d2241 7
a2247 5
INTERNAL static void
GetDirtyBlockInt(cacheInfoPtr, blockPtrPtr, lastDirtyBlockPtr)
    register	Fscache_FileInfo	*cacheInfoPtr;
    Fscache_Block		**blockPtrPtr;
    int				*lastDirtyBlockPtr;
d2252 3
a2254 1
    *blockPtrPtr = (Fscache_Block *) NIL;
d2256 1
a2256 12
    if (List_IsEmpty(&cacheInfoPtr->dirtyList)) {
	cacheInfoPtr->flags &= ~FSCACHE_FILE_BEING_WRITTEN;
	if (cacheInfoPtr->flags & FSCACHE_CLOSE_IN_PROGRESS) {
	    /*
	     * Wake up anyone waiting for us to finish so that they can close
	     * their file.
	     */
	    Sync_Broadcast(&closeCondition);
	}
	Sync_Broadcast(&cacheInfoPtr->noDirtyBlocks);
	return;
    } else if (cacheInfoPtr->flags & FSCACHE_CLOSE_IN_PROGRESS) {
d2259 2
a2260 2
	 * We put the file back onto the file dirty list so the
	 * block cleaner will find it again.
d2262 8
a2269 5
	cacheInfoPtr->flags &= ~FSCACHE_FILE_BEING_WRITTEN;
	Sync_Broadcast(&closeCondition);
	PutFileOnDirtyList(cacheInfoPtr);
	return;
    } 
d2273 6
d2287 3
a2289 1
	List_Remove(dirtyPtr);
d2294 2
a2295 1
	blockPtr->flags &= ~FSCACHE_BLOCK_DIRTY;
d2297 3
a2299 9
	*blockPtrPtr = blockPtr;
	if (cacheInfoPtr->numDirtyBlocks == 1) {
	    *lastDirtyBlockPtr = FS_LAST_DIRTY_BLOCK;
	    if (cacheInfoPtr->flags & FSCACHE_WB_ON_LDB) {
		*lastDirtyBlockPtr |= FS_WB_ON_LDB;
		cacheInfoPtr->flags &= ~FSCACHE_WB_ON_LDB;
	    }
	} else {
	    *lastDirtyBlockPtr = 0;
d2302 40
a2341 14
	 * Increment the reference count to make the block unavailable to 
	 * others.
	 */
	blockPtr->refCount++;
	return;
    }

    FSCACHE_DEBUG_PRINT("GetDirtyBlockInt: All blocks unusable\n");
    cacheInfoPtr->flags &= ~FSCACHE_FILE_BEING_WRITTEN;
    PutFileOnDirtyList(cacheInfoPtr);
}

/*
 * ----------------------------------------------------------------------------
a2342 4
 * ProcessCleanBlock --
 *
 *     	This routine will process the newly cleaned block.
 *
d2351 3
a2353 5
static ENTRY void
ProcessCleanBlock(cacheInfoPtr, blockPtr, status, useSameBlockPtr,
		  lastDirtyBlockPtr) 
    register	Fscache_FileInfo	*cacheInfoPtr;
    register	Fscache_Block	*blockPtr;
a2354 2
    Boolean			*useSameBlockPtr;
    int				*lastDirtyBlockPtr;
d2356 2
d2360 6
a2365 22
    if (status == SUCCESS && 
        (blockPtr->flags & FSCACHE_WRITE_THRU_BLOCK) &&
        (blockPtr->flags & FSCACHE_BLOCK_DIRTY)) {
	/*
	 * We have to keep writing this block until its gets clean, so
	 * rewrite the same block.   (Hmmm.  Does this mean that a
	 * continually modified block will prevent the rest of the file
	 * from being written out?)
	 */
	blockPtr->flags &= ~FSCACHE_BLOCK_DIRTY;
	if (cacheInfoPtr->numDirtyBlocks == 1) {
	    *lastDirtyBlockPtr = FS_LAST_DIRTY_BLOCK;
	    if (cacheInfoPtr->flags & FSCACHE_WB_ON_LDB) {
		*lastDirtyBlockPtr |= FS_WB_ON_LDB;
		cacheInfoPtr->flags &= ~FSCACHE_WB_ON_LDB;
	    }
	} else {
	    *lastDirtyBlockPtr = 0;
	}
	*useSameBlockPtr = TRUE;
	UNLOCK_MONITOR;
	return;
a2366 1
    *useSameBlockPtr = FALSE;
d2368 3
a2370 21

    blockPtr->flags &= ~(FSCACHE_BLOCK_BEING_WRITTEN | FSCACHE_BLOCK_ON_DIRTY_LIST);
    /*
     * Decrement the reference count to make the block available to others.
     */
    blockPtr->refCount--;
    /*
     * Determine if someone is waiting for the block to be written back.  If
     * so and all of the blocks that are being waited for have been written
     * back (or we at least tried but had a timeout or no disk space)
     * wake them up.
     */
    if (blockPtr->flags & FSCACHE_WRITE_BACK_WAIT) {
	numWriteBackBlocks--;
	blockPtr->flags &= ~FSCACHE_WRITE_BACK_WAIT;
	if (numWriteBackBlocks == 0) {
	    Sync_Broadcast(&writeBackComplete);
	}
    }

    if (status != SUCCESS) {
d2372 1
a2372 1
	 * This file could not be written out.
a2373 2
	register	List_Links	*dirtyPtr;
	register	Fscache_Block	*newBlockPtr;
a2374 15
	/*
	 * Go down the list of blocks for the file and wake up anyone waiting 
	 * for the blocks to be written out because we aren't going be writing
	 * them anytime soon.
	 */
	LIST_FORALL(&cacheInfoPtr->dirtyList, dirtyPtr) {
	    newBlockPtr = DIRTY_LINKS_TO_BLOCK(dirtyPtr);
	    if (newBlockPtr->flags & FSCACHE_WRITE_BACK_WAIT) {
		numWriteBackBlocks--;
		newBlockPtr->flags &= ~FSCACHE_WRITE_BACK_WAIT;
		if (numWriteBackBlocks == 0) {
		    Sync_Broadcast(&writeBackComplete);
		}
	    }
	}
d2393 1
a2393 1
	        }
d2416 3
d2420 3
a2422 1
		Proc_CallFunc(ReallocBlock, (ClientData)blockPtr, 0);
d2434 2
a2435 1
	    Fsutil_FileError(cacheInfoPtr->hdrPtr, "Write-back failed", status);
d2437 1
a2437 2
	cacheInfoPtr->lastTimeTried = fsutil_TimeInSeconds;
	cacheInfoPtr->flags &= ~FSCACHE_FILE_BEING_WRITTEN;
a2438 12
	if (cacheInfoPtr->flags & FSCACHE_CLOSE_IN_PROGRESS) {
	    /*
	     * Wake up anyone waiting for us to finish so that they can close
	     * their file.
	     */
	    Sync_Broadcast(&closeCondition);
	}
	/*
	 * Wakeup up anyone waiting for this file to be written out.
	 */
	Sync_Broadcast(&cacheInfoPtr->noDirtyBlocks);

d2448 121
a2568 2
    if (! List_IsEmpty(fscacheFullWaitList)) {
	Fsutil_WaitListNotify(fscacheFullWaitList);
d2570 24
a2593 10
    /* 
     * Now see if we are supposed to take any special action with this
     * block once we are done.
     */
    if (blockPtr->flags & FSCACHE_BLOCK_DELETED) {
	PutOnFreeList(blockPtr);
    } else if (blockPtr->flags & FSCACHE_MOVE_TO_FRONT) {
	List_Move((List_Links *) blockPtr, LIST_ATFRONT(lruList));
	blockPtr->flags &= ~FSCACHE_MOVE_TO_FRONT;
    }
a2594 1
    cacheInfoPtr->numDirtyBlocks--;
d2596 2
a2597 1
     * Wakeup the block allocator which may be waiting for us to clean a block
d2599 21
a2619 2
    Sync_Broadcast(&cleanBlockCondition);
    blockPtr->flags &= ~FSCACHE_WRITE_THRU_BLOCK;
d2622 1
a2623 1

d2628 1
a2628 1
 * ReallocBlock --
d2630 1
a2630 2
 *	Allocate new space for the given cache block.  Called asynchronously
 *	when a write to disk failed because of a disk error.
a2635 1
 *	None.
d2640 3
a2642 4
static void
ReallocBlock(data, callInfoPtr)
    ClientData		data;			/* Block to move */
    Proc_CallInfo	*callInfoPtr;		/* Not used. */
d2644 9
a2652 2
    Fscache_Block	*blockPtr;
    int			newDiskBlock;
d2654 1
a2654 7
    blockPtr = (Fscache_Block *)data;
    newDiskBlock = FsdmBlockRealloc(blockPtr->cacheInfoPtr->hdrPtr,
				  blockPtr->blockNum, blockPtr->diskBlock);
    FinishRealloc(blockPtr, newDiskBlock);
}


d2658 1
a2658 1
 * FinishRealloc --
d2670 2
a2671 2
ENTRY static void
FinishRealloc(blockPtr, diskBlock)
d2678 3
d2688 3
a2690 2
	PutFileOnDirtyList(blockPtr->cacheInfoPtr);
	StartBlockCleaner(blockPtr->cacheInfoPtr);
d2767 64
a2830 2
    if (!List_IsEmpty(&cacheInfoPtr->dirtyList)) {
	StartBlockCleaner(cacheInfoPtr);
d2832 6
d2840 5
d2847 1
d2901 80
a2991 4
 *	Note:  this has some extra code to check against various bugs.
 *	ideally it should only have to check against blocks in the
 *	cache and being on the dirty list.
 *
d3014 1
a3014 6
	/*
	 * Verify that the block is attached to the right file.  Note that
	 * if the file has been invalidated its minor field is negated.
	 */
	if ((blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) &&
	    (blockPtr->fileNum != - cacheInfoPtr->hdrPtr->fileID.minor)) {
a3028 3
    if (numBlocks == 0 && (cacheInfoPtr->flags & FSCACHE_FILE_ON_DIRTY_LIST)) {
	printf("FscacheBlockOkToScavenge dirty file with no regular blocks\n");
    }
d3030 66
a3095 8
	((cacheInfoPtr->flags & FSCACHE_FILE_ON_DIRTY_LIST) == 0);
    if (ok) {
	if (cacheInfoPtr->flags & FSCACHE_FILE_BEING_WRITTEN) {
	    UNLOCK_MONITOR;
	    panic("Fscache_OkToScavenge: FSCACHE_FILE_BEING_WRITTEN (continuable)\n");
	    LOCK_MONITOR;
	    ok = FALSE;
	}
d3097 2
a3098 1
	 * Verify that this really isn't on the dirty list.
d3100 57
a3156 7
	linkPtr = dirtyList->nextPtr;
	while (linkPtr != (List_Links *)NIL && linkPtr != dirtyList) {
	    if (linkPtr == (List_Links *)cacheInfoPtr) {
		UNLOCK_MONITOR;
		panic("Fscache_OkToScavenge: file on dirty list (continuable)\n");
		LOCK_MONITOR;
		ok = FALSE;
d3158 2
a3159 6
	    linkPtr = linkPtr->nextPtr;
	    if (linkPtr == (List_Links *)NIL) {
		UNLOCK_MONITOR;
		panic("Fscache_OkToScavenge: NIL on dirty list (continuable)\n");
		LOCK_MONITOR;
		ok = FALSE;
d3162 2
d3165 33
a3197 2
    UNLOCK_MONITOR;
    return(ok);
d3199 3
d3219 1
a3226 1
    int event;
a3231 1
    event = BLOCK_FETCH_HIT;
a3234 1
	FSUTIL_TRACE(FSUTIL_TRACE_NO_BLOCK);
a3244 1
	FSUTIL_TRACE_BLOCK(BLOCK_ITER_WAIT, blockPtr);
a3248 1
	event = BLOCK_ITER_WAIT_HIT;
a3250 1
    FSUTIL_TRACE_BLOCK(event, blockPtr);
a3290 1
    FSUTIL_TRACE_BLOCK(BLOCK_DELETE, blockPtr);
d3403 1
a3403 1
    register List_Links	  	*listPtr;
d3413 2
a3414 1
    LIST_FORALL(listPtr, (List_Links *) blockPtr) {
d3439 48
@


9.15
log
@Added code to force blocks to disk.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache.ken/RCS/fsBlockCache.c,v 1.2 90/05/15 14:37:06 shirriff Exp $ SPRITE (Berkeley)";
d147 1
a147 1
static	Sync_Condition	cleanBlockCondition;	/* Condition that block 
d150 1
a150 1
static	Sync_Condition	writeBackComplete; 	/* Condition to wait on when 
d154 1
a154 1
static	Sync_Condition	closeCondition;		/* Condition to wait on when
@


9.14
log
@removed ifdef around stats for block flushing now that fsStat.h is updated.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fsBlockCache.c,v 9.13 90/05/03 19:23:20 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d1303 2
a1304 1
				 * FSCACHE_BLOCK_UNNEEDED | FSCACHE_DONT_WRITE_THRU */
d1425 1
a1425 1
	if ((blockPtr->flags & (FSCACHE_BLOCK_DIRTY | FSCACHE_BLOCK_BEING_WRITTEN)) &&
d1429 2
a1430 1
	     Fsdm_FindFileType(blockPtr->cacheInfoPtr) != FSUTIL_FILE_TYPE_TMP)) {
d1460 1
a1460 1
			    (FSCACHE_BLOCK_DIRTY | FSCACHE_BLOCK_BEING_WRITTEN));
@


9.13
log
@added code for recording statistics, but it's ifdef'ed out pending change
to fsStat.h.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fsBlockCache.c,v 9.12 90/05/03 19:18:39 mendel Exp Locker: douglis $ SPRITE (Berkeley)";
a1799 1
#ifdef wait_for_fsStat
a1806 1
#endif
@


9.12
log
@1) Fixed problem with file being put on dirty list while being written.
2) Fixed sync between block write-back and block invalidate by making
   the block cleaner increament the refCount.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fsBlockCache.c,v 9.11 90/03/26 09:49:31 brent Exp $ SPRITE (Berkeley)";
d1707 2
a1708 1
				 * FSCACHE_WRITE_BACK_AND_INVALIDATE. */
d1799 11
@


9.11
log
@Fixed PutFileOnDirtyList so it won't do it if the file is deleted.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fsBlockCache.c,v 9.10 90/03/13 16:32:43 brent Exp $ SPRITE (Berkeley)";
d517 6
a522 1
    if (cacheInfoPtr->flags & FSCACHE_FILE_GONE) {
d2525 1
a2525 1
    }
d2554 5
a2558 1

d2620 4
a2623 1

d2717 1
a2718 1
	cacheInfoPtr->flags &= ~FSCACHE_FILE_BEING_WRITTEN;
@


9.10
log
@Added code to Fscache_OkToScavenge that looks for
inconsistencies with respect to the dirty list,
FSCACHE_FILE_BEING_WRITTEN and FSCACHE_FILE_ON_DIRTY_LIST.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fsBlockCache.c,v 9.9 90/02/15 09:26:56 brent Exp Locker: brent $ SPRITE (Berkeley)";
d500 4
a503 1
 * 	Put the given file onto the global dirty list.
d517 3
a2706 1
	PutFileOnDirtyList(cacheInfoPtr);
@


9.9
log
@Added use of FSCACHE_MAX_CLEANER_PROCS
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fsBlockCache.c,v 9.8 90/02/14 08:49:02 brent Exp Locker: brent $ SPRITE (Berkeley)";
a1054 6
	    if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
		UNLOCK_MONITOR;
		panic("Fscache_FetchBlock hashing error\n");
		*foundPtr = FALSE;
		return;
	    }
d1489 1
a1489 6

	if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
	    panic( "CacheBlockTrunc, hashing error\n");
	} else {
	    blockPtr->blockSize = newBlockSize;
	}
a1586 4
	    if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
		panic( "CacheFileInvalidate, hashing error\n");
		continue;
	    }
a1745 6
	if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
	    panic( "Fscache_FileWriteBack, hashing error\n");
	    UNLOCK_MONITOR;
	    return(FAILURE);
	}

a1969 5
	if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
	    panic( "CacheBlocksUnneeded, hashing error\n");
	    continue;
	}

a2133 5
	if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
	    printf("CacheWriteBack, skipping bad block on LRU list, file %d not %d\n",
		blockPtr->fileNum, cacheInfoPtr->hdrPtr->fileID.minor);
	    continue;
	}
a2244 4
	    if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
		panic( "Fscache_CleanBlocks, bad block\n");
		continue;
	    }
a2517 6
	if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
	    UNLOCK_MONITOR;
	    panic( "GetDirtyBlock, bad block\n");
	    LOCK_MONITOR;
	    continue;
	}
d2959 4
d2985 6
a2990 1
	if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
d3010 27
@


9.8
log
@Added Fscache_MoveBlock
Added mousetrap for the UpgradeFragment/Fscache_UnlockBlock problem.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fsBlockCache.c,v 9.6 89/12/14 13:09:25 brent Exp Locker: brent $ SPRITE (Berkeley)";
d226 2
d230 1
a230 4
int		fscache_MaxBlockCleaners = 3;	/* The maximum number of block cleaners
					 * that there can be. */
static	int	blocksPerPage;		/* Number of blocks in a page. */

@


9.7
log
@Took out warning about double insertion being avoided.
@
text
@d1223 44
d1268 3
d1358 14
d2626 1
a2626 1
	 * continually modified block will prevent the whole file
@


9.6
log
@Fixed Fscache_FetchBlock so it can't insert a block into
the hash table twice.  The wait inside FetchBlock was
opening a window in which another process could insert the
cache block.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fsBlockCache.c,v 9.5 89/12/11 17:36:06 brent Exp Locker: brent $ SPRITE (Berkeley)";
a1039 1
    Boolean			doubleInsert = FALSE;
a1061 6
	    if (doubleInsert && blockNum != -2) {
		printf("Fscache_FetchBlock: double insert avoided file <%d,%d> block %d\n",
		    blockPtr->cacheInfoPtr->hdrPtr->fileID.major,
		    blockPtr->cacheInfoPtr->hdrPtr->fileID.minor,
		    blockPtr->blockNum);
	    }
d1150 2
a1151 3
	     * ploys to get a free block.
	     * We set the doubleInsert flag here to catch the old bug
	     * case where the first hash didn't find the block, FetchBlock
a1156 1
	    doubleInsert = TRUE;
a1190 1

a1396 1

@


9.5
log
@Fixed up interface to block I/O routines.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fsBlockCache.c,v 9.4 89/11/07 10:40:19 shirriff Exp Locker: brent $ SPRITE (Berkeley)";
d95 44
d787 1
d801 1
d1015 2
d1040 1
d1044 1
a1044 3
    /*
     * See if the block is in the cache.
     */
d1047 11
a1057 18
again:

    hashEntryPtr = Hash_Find(blockHashTable, (Address) &blockHashKey);
    blockPtr = (Fscache_Block *) Hash_GetValue(hashEntryPtr);
    if (blockPtr != (Fscache_Block *) NIL) {
	if (blockPtr->fileNum != cacheInfoPtr->hdrPtr->fileID.minor) {
	    UNLOCK_MONITOR;
	    panic("Fscache_FetchBlock hashing error\n");
	    *foundPtr = FALSE;
	    *blockPtrPtr = (Fscache_Block *) NIL;
	    return;
	}
	if (((flags & FSCACHE_IO_IN_PROGRESS) && 
	     blockPtr->refCount > 0) ||
	    (blockPtr->flags & FSCACHE_IO_IN_PROGRESS)) {
	    if (dontBlock) {
		*foundPtr = TRUE;
		*blockPtrPtr = (Fscache_Block *) NIL;
d1059 2
d1063 26
d1090 2
a1091 2
	     * Wait until becomes unlocked.  Start over when wakeup 
	     * because the block could go away while we are waiting.
d1093 10
a1102 50
	    FSUTIL_TRACE_BLOCK(FSUTIL_TRACE_BLOCK_WAIT, blockPtr);
	    (void)Sync_Wait(&blockPtr->ioDone, FALSE);
	    goto again;
	}
	blockPtr->refCount++;
	if (flags & FSCACHE_IO_IN_PROGRESS) {
	    blockPtr->flags |= FSCACHE_IO_IN_PROGRESS;
	}
	FSUTIL_TRACE_BLOCK(FSUTIL_TRACE_BLOCK_HIT, blockPtr);
	*foundPtr = TRUE;
	*blockPtrPtr = blockPtr;
	UNLOCK_MONITOR;
	return;
    }
    *foundPtr = FALSE;
	
    /*
     * Have to allocate a block.  If there is a free block use it.  Otherwise
     * either take a block off of the lru list or make a new one.
     */
    while (blockPtr == (Fscache_Block *) NIL) {
	if (!List_IsEmpty(partFreeList)) {
	    /*
	     * Use partially free blocks first.
	     */
	    fs_Stats.blockCache.numFreeBlocks--;
	    fs_Stats.blockCache.partFree++;
	    blockPtr = (Fscache_Block *) List_First(partFreeList);
	    List_Remove((List_Links *) blockPtr);
	} else if (!List_IsEmpty(totFreeList)) {
	    /*
	     * Can't find a partially free block so use a totally free
	     * block.
	     */
	    fs_Stats.blockCache.numFreeBlocks--;
	    fs_Stats.blockCache.totFree++;
	    blockPtr = (Fscache_Block *) List_First(totFreeList);
	    List_Remove((List_Links *) blockPtr);
	    if (PAGE_IS_8K) {
		otherBlockPtr = GET_OTHER_BLOCK(blockPtr);
		List_Move((List_Links *) otherBlockPtr,
			      LIST_ATREAR(partFreeList));
	    }
	} else {
	    /*
	     * Can't find any free blocks so have to use one of our blocks
	     * or create new ones.
	     */
	    if (fs_Stats.blockCache.numCacheBlocks >= 
					fs_Stats.blockCache.maxCacheBlocks) {
d1104 2
a1105 1
		 * We can't have anymore blocks so reuse one of our own.
d1107 9
a1115 2
		blockPtr = FetchBlock(!dontBlock);
		fs_Stats.blockCache.lru++;
d1118 2
a1119 1
		 * See if VM has an older page than we have.
d1121 2
a1122 5
		refTime = Vm_GetRefTime();
		blockPtr = (Fscache_Block *) List_First(lruList);
		DEBUG_PRINT( ("FsCacheBlockFetch: fs=%d vm=%d\n", 
				   blockPtr->timeReferenced, refTime) );
		if (blockPtr->timeReferenced > refTime) {
d1124 1
a1124 2
		     * VM has an older page than us so we get to make a new
		     * block.
d1126 1
a1126 9
		    DEBUG_PRINT( ("FsCacheBlockFetch:Creating new block\n" ));
		    if (!CreateBlock(TRUE, &newBlockPtr)) {
			DEBUG_PRINT( ("FsCacheBlockFetch: Couldn't create block\n" ));
			blockPtr = FetchBlock(!dontBlock);
			fs_Stats.blockCache.lru++;
		    } else {
			fs_Stats.blockCache.unmapped++;
			blockPtr = newBlockPtr;
		    }
d1129 1
a1129 2
		     * We have an older block than VM's oldest page so reuse
		     * the block.
d1131 21
a1151 3
		    DEBUG_PRINT( ("FsCacheBlockFetch: Recycling block\n") );
		    fs_Stats.blockCache.lru++;
		    blockPtr = FetchBlock(!dontBlock);
a1153 2
	}
	if ((blockPtr == (Fscache_Block *)NIL) && dontBlock) {
d1155 31
a1185 6
	     * FetchBlock couldn't make room in the cache.  Our caller
	     * should try to treat this like a blocking operation.
	     */
	    fs_Stats.blockCache.lru--;
	    *foundPtr = FALSE;
	    *blockPtrPtr = (Fscache_Block *) NIL;
d1187 10
a1196 1
	    return;
a1197 4
	/*
	 * If blockPtr is NIL we waited inside FetchBlock and now
	 * we'll try all the various ploys to get a free block again.
	 */
a1198 13
    
    cacheInfoPtr->blocksInCache++;
    blockPtr->cacheInfoPtr = cacheInfoPtr;
    blockPtr->refCount = 1;
    blockPtr->flags = flags & (FSCACHE_DATA_BLOCK | FSCACHE_IND_BLOCK |
			       FSCACHE_DESC_BLOCK | FSCACHE_DIR_BLOCK |
			       FSCACHE_READ_AHEAD_BLOCK);
    blockPtr->flags |= FSCACHE_IO_IN_PROGRESS;
    blockPtr->fileNum = cacheInfoPtr->hdrPtr->fileID.minor;
    blockPtr->blockNum = blockNum;
    blockPtr->blockSize = -1;
    blockPtr->timeDirtied = 0;
    blockPtr->timeReferenced = fsutil_TimeInSeconds;
a1199 9
    FSUTIL_TRACE_BLOCK(FSUTIL_TRACE_NO_BLOCK, blockPtr);
    Hash_SetValue(hashEntryPtr, blockPtr);
    List_Insert((List_Links *) blockPtr, LIST_ATREAR(lruList));
    List_InitElement(&blockPtr->fileLinks);
    if (flags & FSCACHE_IND_BLOCK) {
	List_Insert(&blockPtr->fileLinks, LIST_ATREAR(&cacheInfoPtr->indList));
    } else {
	List_Insert(&blockPtr->fileLinks,LIST_ATREAR(&cacheInfoPtr->blockList));
    }
d1281 1
d1307 1
d1353 1
d1560 1
a1560 1
	    FSUTIL_TRACE_BLOCK(FSUTIL_TRACE_DEL_BLOCK, blockPtr);
d1738 1
a1738 1
		FSUTIL_TRACE_BLOCK(FSUTIL_TRACE_DEL_BLOCK, blockPtr);
d2263 1
a2263 1
	    FSUTIL_TRACE_BLOCK(FSUTIL_TRACE_BLOCK_WRITE, blockPtr);
d3020 1
d3026 1
d3041 1
a3041 1
	FSUTIL_TRACE_BLOCK(FSUTIL_TRACE_BLOCK_WAIT, blockPtr);
d3046 1
d3049 1
a3049 1
    FSUTIL_TRACE_BLOCK(FSUTIL_TRACE_BLOCK_HIT, blockPtr);
d3071 2
d3085 1
d3090 1
a3090 1
    FSUTIL_TRACE_BLOCK(FSUTIL_TRACE_DEL_BLOCK, blockPtr);
@


9.4
log
@Added remoteI/O stats.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fsBlockCache.c,v 9.3 89/10/26 13:54:12 brent Exp $ SPRITE (Berkeley)";
d2214 1
a2214 2
		    (cacheInfoPtr->hdrPtr, blockPtr->diskBlock,
		     blockPtr->blockSize, blockPtr->blockAddr, lastDirtyBlock);
d2217 1
a2217 2
			blockPtr->diskBlock, blockPtr->blockSize,
			blockPtr->blockAddr, lastDirtyBlock);
d2219 1
a2219 2
			blockPtr->diskBlock, blockPtr->blockSize,
			blockPtr->blockAddr, lastDirtyBlock);
a2226 6
		if (cacheInfoPtr->hdrPtr->fileID.type == FSIO_RMT_FILE_STREAM) {
		    /*
		     * Excuse the special case check.
		     */
		    fs_Stats.rmtIO.bytesWrittenFromCache += blockPtr->blockSize;
		}
d2524 3
a2526 1
	 * rewrite the same block.
d3028 1
d3030 2
@


9.3
log
@1. removed lint regarding unsigned comparisions > 0
2. Added block cleaner statistics
3. Fixed 'timeDirtied' bug where if a block was continuously
   written it would never become 30 seconds old!
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fsBlockCache.c,v 9.2 89/10/08 15:52:32 mendel Exp $ SPRITE (Berkeley)";
d2230 6
d2675 1
a2675 1
     * Now see if we are supposed to take any spaecial action with this
@


9.2
log
@Fixed bug in Fscache_WriteBackFile in which Writing Back a file with only
indirect blocks in the cache causes an infinite loop. 
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fsBlockCache.c,v 9.1 89/09/18 13:51:59 brent Exp Locker: mendel $ SPRITE (Berkeley)";
d1257 1
a1258 1
	blockPtr->timeDirtied = timeDirtied;
d2167 2
d2174 1
d2180 5
d2188 1
a2211 5
	    if (blockPtr->blockSize < 0) {
		panic( "Fscache_CleanBlocks, uninitialized block size\n");
		status = FAILURE;
		break;
	    }
d2237 6
d3074 1
a3074 1
    if (block->fragAccesses > 0) {
d3080 1
a3080 1
    if (block->fileDescReads > 0) {
d3085 1
a3085 1
    if (block->indBlockAccesses > 0) {
@


9.1
log
@Updated comments
Added fscacheFullWaitList notifications
Added call to Fsutil_AttemptRecovery on stale handle err.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fsBlockCache.c,v 8.17 89/08/21 15:23:38 mendel Exp $ SPRITE (Berkeley)";
d1722 1
a1722 1
	LIST_FORALL(&blockPtr->cacheInfoPtr->indList, linkPtr) {
@


9.0
log
@Changing version numbers.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fscache/RCS/fsBlockCache.c,v 8.17 89/08/21 15:23:38 mendel Exp Locker: douglis $ SPRITE (Berkeley)";
d50 2
a51 2
 *	  function Fscache_IODone is called.  While this flag is set in the block
 *	  all future fetches will block until the flag is cleared.
d64 2
a65 2
 *	  of blocks being written back is kept and the FSCACHE_WRITE_BACK_WAIT flag
 *	  is set in the block instead.
d75 17
a91 16
 *	  Fscache_PreventWriteBacks is called.  This function will not return until
 *	  there are no block cleaners active on the file.  When it returns it 
 *	  sets the FSCACHE_CLOSE_IN_PROGRESS flag in the cacheInfo struct in the file *	  handle and it returns the number of dirty blocks.  All subsequent
 *	  block writes are blocked until the function Fscache_AllowWriteBacks is
 *	  called.  Thus the number of dirty blocks in the cache for the
 *	  file is accurate on close because no dirty blocks can be written
 *	  out while the file is being closed.  Likewise when a block cleaner
 *	  writes out the last dirty block for a file and it tells the server
 *	  on the write that its the last dirty block the server knows that
 *	  it can believe the block cleaner if the file is closed.  This
 *	  is because if its closed then it must have been closed when the
 *	  block cleaner did the write (all closes are prohibited during the
 *	  write) and thus there is no way that more dirty blocks can be
 *	  put into the cache.  If its open then the server ignores what the
 *	  block cleaner says because it will get told again when the file is
 *	  closed.
d145 7
d365 1
d418 2
d446 4
a449 1
}
d591 3
d702 1
d705 1
a705 1
 *	Pointer to oldest available block, NIL if had to wait.
d749 1
a749 1
	    printf( "FetchBlock: block %d of file %d caught being written out\n",
d955 2
a956 2
 *	isn't found or the FSCACHE_IO_IN_PROGRESS flag is given then the block is
 * 	marked as IO in progress and must be either unlocked by 
d975 2
a976 1
				 * FSCACHE_READ_AHEAD_BLOCK | FSCACHE_IO_IN_PROGRESS
d991 1
d1007 1
a1007 1
	    panic( "CacheFetchBlock hashing error\n");
d1015 1
a1015 1
	    if (flags & FSCACHE_DONT_BLOCK) {
a1044 1
    blockPtr = (Fscache_Block *) NIL;
d1078 1
a1078 1
		blockPtr = FetchBlock(TRUE);
d1096 1
a1097 1
			blockPtr = FetchBlock(TRUE);
d1109 1
a1109 1
		    blockPtr = FetchBlock(TRUE);
d1113 15
d1129 1
a1129 1

d1219 1
a1219 1
	panic( "Checking free block\n");
d2212 8
d2585 2
a2586 2
		 * Note, this used to be a non-blocking call to
		 * wait for the I/O server.
d2589 4
d2649 3
a2651 1

d2655 3
a2657 1

@


8.17
log
@Break up fs into many modules.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 8.16 89/08/10 15:47:54 mendel Exp $ SPRITE (Berkeley)";
@


8.16
log
@Fixed FsCacheUnlockBlock to set the size of a read-only block.
Previously it was left as -1, which confused the calculation
of internal fragmentation.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 8.15 89/06/15 09:05:59 brent Exp $ SPRITE (Berkeley)";
d23 2
a24 1
#include	"fsInt.h"
a25 1
#include	"fsDebug.h"
d27 4
a30 4
#include	"fsOpTable.h"
#include	"fsDisk.h"
#include	"fsFile.h"
#include	"fsTrace.h"
d43 2
a44 2
 *	  good data in it.  The FS_IO_IN_PROGRESS flag is used for this.
 *	  If this flag is set in the call to FsCacheFetchBlock then the fetch
d47 4
a50 4
 *        Whenever FsCacheFetchBlock returns a block it sets the 
 *	  FS_IO_IN_PROGRESS flag in the block.  This flag will be cleared
 *	  whenever the block is released with FsCacheUnlockBlock or the
 *	  function FsCacheIODone is called.  While this flag is set in the block
d54 1
a54 1
 *	  block cleaner is writing out a block and FsCacheUnlockBlock is
d56 1
a56 1
 *	  block cleaner finishes.  The flag FS_BLOCK_BEING_WRITTEN in the
d64 1
a64 1
 *	  of blocks being written back is kept and the FS_WRITE_BACK_WAIT flag
d75 1
a75 1
 *	  FsPreventWriteBacks is called.  This function will not return until
d77 2
a78 2
 *	  sets the FS_CLOSE_IN_PROGRESS flag in the cacheInfo struct in the file *	  handle and it returns the number of dirty blocks.  All subsequent
 *	  block writes are blocked until the function FsAllowWriteBacks is
d156 1
a156 1
    FsCacheFileInfo *cacheInfoPtr;
d173 1
a173 1
					 * Fs_CacheWriteBack. */
d176 1
a176 1
int		fsMaxBlockCleaners = 3;	/* The maximum number of block cleaners
d222 1
a222 1
static FsCacheBlock	*FetchBlock();
d239 1
a239 1
 * FsCacheInfoInit --
d248 1
a248 1
 *	Set up the fields of the FsCacheFileInfo struct.
d253 3
a255 3
FsCacheInfoInit(cacheInfoPtr, hdrPtr, version, cacheable, attrPtr)
    register FsCacheFileInfo *cacheInfoPtr;	/* Information to initialize. */
    FsHandleHeader	     *hdrPtr;		/* Back pointer to handle */
d259 2
a260 1
    FsCachedAttributes	     *attrPtr;		/* File attributes */
d266 1
a266 1
    cacheInfoPtr->flags = (cacheable ? 0 : FS_FILE_NOT_CACHEABLE);
d275 1
d283 1
a283 1
 * FsCacheInfoSyncLockCleanup --
d291 1
a291 1
 *	Set up the fields of the FsCacheFileInfo struct.
d296 2
a297 2
FsCacheInfoSyncLockCleanup(cacheInfoPtr)
    FsCacheFileInfo *cacheInfoPtr;
d306 1
a306 1
 * FsBlockCacheInit --
d319 1
a319 1
FsBlockCacheInit(blockHashSize)
d325 1
a325 1
    register	FsCacheBlock	*blockPtr;
d331 1
a331 1
    fsStats.blockCache.maxNumBlocks = 
d334 2
a335 2
    fsStats.blockCache.minCacheBlocks = FS_MIN_CACHE_BLOCKS;
    fsStats.blockCache.maxCacheBlocks = fsStats.blockCache.maxNumBlocks;
d340 3
a342 3
    listStart = Vm_RawAlloc((int)fsStats.blockCache.maxNumBlocks *
			    sizeof(FsCacheBlock));
    blockPtr = (FsCacheBlock *) listStart;
d358 2
a359 2
    for (i = 0,blockAddr = blockCacheStart,blockPtr = (FsCacheBlock *)listStart;
	 i < fsStats.blockCache.maxNumBlocks; 
d361 1
a361 1
	blockPtr->flags = FS_NOT_MAPPED;
d371 7
a377 7
    fsStats.blockCache.numCacheBlocks = 0;
    while (fsStats.blockCache.numCacheBlocks < 
					fsStats.blockCache.minCacheBlocks) {
	if (!CreateBlock(FALSE, (FsCacheBlock **) NIL)) {
	    printf("FsBlockCacheInit: Couldn't create block\n");
	    fsStats.blockCache.minCacheBlocks = 
					fsStats.blockCache.numCacheBlocks;
d381 2
a382 2
	    fsStats.blockCache.minCacheBlocks, FS_BLOCK_SIZE / 1024,
	    fsStats.blockCache.maxNumBlocks);
d414 1
a414 1
    register	FsCacheBlock	*blockPtr;
d416 1
a416 1
    register	FsCacheBlock	*otherBlockPtr;
d418 2
a419 2
    blockPtr->flags = FS_BLOCK_FREE;
    fsStats.blockCache.numFreeBlocks++;
d426 1
a426 1
	if (otherBlockPtr->flags & FS_BLOCK_FREE) {
d455 1
a455 1
    register	FsCacheFileInfo	*cacheInfoPtr;	/* Cache info for a file */
d457 1
a457 1
    if (!(cacheInfoPtr->flags & FS_FILE_ON_DIRTY_LIST)) {
d459 1
a459 1
	cacheInfoPtr->flags |= FS_FILE_ON_DIRTY_LIST;
d483 1
a483 1
    register	FsCacheBlock	*blockPtr;	/* Block to put on list. */
d490 1
a490 1
    register FsCacheFileInfo *cacheInfoPtr = blockPtr->cacheInfoPtr;
d492 1
a492 1
    blockPtr->flags |= FS_BLOCK_ON_DIRTY_LIST;
d532 1
a532 1
    FsCacheBlock	**blockPtrPtr;	/* Where to return pointer to block.
d535 1
a535 1
    register	FsCacheBlock	*blockPtr;
d542 1
a542 1
    blockPtr = (FsCacheBlock *) List_First(unmappedList);
d550 1
a550 1
    fsStats.blockCache.numCacheBlocks += newCachePages * blocksPerPage;
d560 2
a561 2
	fsStats.blockCache.numFreeBlocks++;
	blockPtr->flags = FS_BLOCK_FREE;
d569 2
a570 2
	blockPtr->flags = FS_BLOCK_FREE;
	fsStats.blockCache.numFreeBlocks++;
d603 2
a604 2
    register	FsCacheBlock	*blockPtr;
    register	FsCacheBlock	*otherBlockPtr;
d611 2
a612 2
	blockPtr = (FsCacheBlock *) List_First(totFreeList);
	fsStats.blockCache.numCacheBlocks -= 
d615 1
a615 1
	blockPtr->flags = FS_NOT_MAPPED;
d617 1
a617 1
	fsStats.blockCache.numFreeBlocks--;
d624 1
a624 1
	    blockPtr->flags = FS_NOT_MAPPED;
d626 1
a626 1
	    fsStats.blockCache.numFreeBlocks--;
d636 1
a636 1
	if (blockPtr == (FsCacheBlock *) NIL) {
d651 2
a652 2
		(otherBlockPtr->flags & FS_BLOCK_ON_DIRTY_LIST) ||
		(otherBlockPtr->flags & FS_BLOCK_DIRTY)) {
d660 1
a660 1
	    if (!(otherBlockPtr->flags & FS_BLOCK_FREE)) {
d663 1
a663 1
	    otherBlockPtr->flags = FS_NOT_MAPPED;
d667 1
a667 1
	blockPtr->flags = FS_NOT_MAPPED;
d669 1
a669 1
	fsStats.blockCache.numCacheBlocks -= 
d694 1
a694 1
static INTERNAL FsCacheBlock *
d699 1
a699 1
    register	FsCacheBlock	*blockPtr;
d703 1
a703 1
	return((FsCacheBlock *) NIL);
d714 1
a714 1
	} else if (blockPtr->flags & FS_BLOCK_ON_DIRTY_LIST) {
d719 2
a720 2
	    blockPtr->flags |= FS_MOVE_TO_FRONT;
	} else if (blockPtr->flags & FS_BLOCK_DIRTY) {
d726 2
a727 2
	    blockPtr->flags |= FS_MOVE_TO_FRONT;
	} else if (blockPtr->flags & FS_BLOCK_DELETED) {
d730 1
a730 1
	} else if (blockPtr->flags & FS_BLOCK_BEING_WRITTEN) {
d753 1
a753 1
    return((FsCacheBlock *) NIL);
d760 1
a760 1
 * FsSetMinSize --
d775 1
a775 1
FsSetMinSize(minBlocks)
d782 1
a782 1
		       minBlocks, fsStats.blockCache.minCacheBlocks) );
d784 3
a786 3
    if (minBlocks > fsStats.blockCache.maxNumBlocks) {
	minBlocks = fsStats.blockCache.maxNumBlocks;
	printf( "FsSetMinSize: Only raising min cache size to %d blocks\n", 
d789 3
a791 3
    fsStats.blockCache.minCacheBlocks = minBlocks;
    if (fsStats.blockCache.minCacheBlocks <= 
				    fsStats.blockCache.numCacheBlocks) {
d800 7
a806 7
    while (fsStats.blockCache.numCacheBlocks < 
					fsStats.blockCache.minCacheBlocks) {
	if (!CreateBlock(FALSE, (FsCacheBlock **) NIL)) {
	    printf("FsSetMinSize: lowered min cache size to %d blocks\n",
		       fsStats.blockCache.numCacheBlocks);
	    fsStats.blockCache.minCacheBlocks = 
				    fsStats.blockCache.numCacheBlocks;
d817 1
a817 1
 * FsSetMaxSize --
d833 1
a833 1
FsSetMaxSize(maxBlocks)
d841 3
a843 3
    if (maxBlocks > fsStats.blockCache.maxNumBlocks) {
	maxBlocks = fsStats.blockCache.maxNumBlocks;
	printf("FsSetMaxSize: Only raising max cache size to %d blocks\n",
d847 3
a849 3
    fsStats.blockCache.maxCacheBlocks = maxBlocks;
    if (fsStats.blockCache.maxCacheBlocks >= 
				    fsStats.blockCache.numCacheBlocks) {
d858 2
a859 2
    while (fsStats.blockCache.numCacheBlocks > 
				fsStats.blockCache.maxCacheBlocks && !giveUp) {
d865 2
a866 2
	printf("FsSetMaxSize: Could only lower cache to %d\n", 
					fsStats.blockCache.numCacheBlocks);
d877 1
a877 1
 * Fs_GetPageFromFS --
d891 1
a891 1
Fs_GetPageFromFS(timeLastAccessed, pageNumPtr)
d895 1
a895 1
    register	FsCacheBlock	*blockPtr;
d899 1
a899 1
    fsStats.blockCache.vmRequests++;
d901 4
a904 4
    if (fsStats.blockCache.numCacheBlocks > 
		fsStats.blockCache.minCacheBlocks && !List_IsEmpty(lruList)) {
	fsStats.blockCache.triedToGiveToVM++;
	blockPtr = (FsCacheBlock *) List_First(lruList);
d906 1
a906 1
	    fsStats.blockCache.vmGotPage++;
d927 1
a927 1
 * FsCacheFetchBlock --
d936 2
a937 2
 *	be replaced) until it is unlocked by FsCacheUnlockBlock.  If the block
 *	isn't found or the FS_IO_IN_PROGRESS flag is given then the block is
d939 1
a939 1
 *	FsCacheUnlockBlock or marked as IO done by FsCacheIODone.
d952 2
a953 2
FsCacheFetchBlock(cacheInfoPtr, blockNum, flags, blockPtrPtr, foundPtr)
    register FsCacheFileInfo *cacheInfoPtr; /* Pointer to the cache state 
d956 2
a957 2
    int		 flags;		/* FS_CACHE_DONT_BLOCK |
				 * FS_READ_AHEAD_BLOCK | FS_IO_IN_PROGRESS
d959 1
a959 1
    FsCacheBlock **blockPtrPtr; /* Where pointer to cache block information
d968 3
a970 3
    register	FsCacheBlock	*blockPtr;
    FsCacheBlock		*otherBlockPtr;
    FsCacheBlock		*newBlockPtr;
d983 2
a984 2
    blockPtr = (FsCacheBlock *) Hash_GetValue(hashEntryPtr);
    if (blockPtr != (FsCacheBlock *) NIL) {
d989 1
a989 1
	    *blockPtrPtr = (FsCacheBlock *) NIL;
d992 1
a992 1
	if (((flags & FS_IO_IN_PROGRESS) && 
d994 2
a995 2
	    (blockPtr->flags & FS_IO_IN_PROGRESS)) {
	    if (flags & FS_CACHE_DONT_BLOCK) {
d997 1
a997 1
		*blockPtrPtr = (FsCacheBlock *) NIL;
d1005 1
a1005 1
	    FS_TRACE_BLOCK(FS_TRACE_BLOCK_WAIT, blockPtr);
d1010 2
a1011 2
	if (flags & FS_IO_IN_PROGRESS) {
	    blockPtr->flags |= FS_IO_IN_PROGRESS;
d1013 1
a1013 1
	FS_TRACE_BLOCK(FS_TRACE_BLOCK_HIT, blockPtr);
d1025 2
a1026 2
    blockPtr = (FsCacheBlock *) NIL;
    while (blockPtr == (FsCacheBlock *) NIL) {
d1031 3
a1033 3
	    fsStats.blockCache.numFreeBlocks--;
	    fsStats.blockCache.partFree++;
	    blockPtr = (FsCacheBlock *) List_First(partFreeList);
d1040 3
a1042 3
	    fsStats.blockCache.numFreeBlocks--;
	    fsStats.blockCache.totFree++;
	    blockPtr = (FsCacheBlock *) List_First(totFreeList);
d1054 2
a1055 2
	    if (fsStats.blockCache.numCacheBlocks >= 
					fsStats.blockCache.maxCacheBlocks) {
d1060 1
a1060 1
		fsStats.blockCache.lru++;
d1066 1
a1066 1
		blockPtr = (FsCacheBlock *) List_First(lruList);
d1077 1
a1077 1
			fsStats.blockCache.lru++;
d1080 1
a1080 1
			fsStats.blockCache.unmapped++;
d1089 1
a1089 1
		    fsStats.blockCache.lru++;
d1099 4
a1102 4
    blockPtr->flags = flags & (FS_DATA_CACHE_BLOCK | FS_IND_CACHE_BLOCK |
			       FS_DESC_CACHE_BLOCK | FS_DIR_CACHE_BLOCK |
			       FS_READ_AHEAD_BLOCK);
    blockPtr->flags |= FS_IO_IN_PROGRESS;
d1107 1
a1107 1
    blockPtr->timeReferenced = fsTimeInSeconds;
d1109 1
a1109 1
    FS_TRACE_BLOCK(FS_TRACE_NO_BLOCK, blockPtr);
d1113 1
a1113 1
    if (flags & FS_IND_CACHE_BLOCK) {
d1127 1
a1127 1
 * FsCacheIODone --
d1141 2
a1142 2
FsCacheIODone(blockPtr)
    FsCacheBlock *blockPtr;	/* Pointer to block information for block.*/
d1147 1
a1147 1
    blockPtr->flags &= ~FS_IO_IN_PROGRESS;
d1156 1
a1156 1
 * FsCacheUnlockBlock --
d1170 2
a1171 2
FsCacheUnlockBlock(blockPtr, timeDirtied, diskBlock, blockSize, flags)
    FsCacheBlock *blockPtr;	/* Pointer to block information for block
d1179 2
a1180 2
    int		 flags;		/* FS_DELETE_BLOCK | FS_CLEAR_READ_AHEAD |
				 * FS_BLOCK_UNNEEDED | FS_DONT_WRITE_THRU */
d1184 1
a1184 1
    if (blockPtr->flags & FS_BLOCK_FREE) {
d1188 1
a1188 1
    if (blockPtr->flags & FS_IO_IN_PROGRESS) {
d1190 1
a1190 1
	blockPtr->flags &= ~FS_IO_IN_PROGRESS;
d1193 1
a1193 1
    if (flags & FS_DELETE_BLOCK) {
d1205 2
a1206 2
    if (flags & FS_CLEAR_READ_AHEAD) {
	blockPtr->flags &= ~FS_READ_AHEAD_BLOCK;
d1210 1
a1210 1
	if (!(blockPtr->flags & FS_BLOCK_DIRTY)) {
d1222 1
a1222 1
	    blockPtr->flags |= FS_BLOCK_DIRTY;
d1235 1
a1235 1
	    while (blockPtr->flags & FS_BLOCK_BEING_WRITTEN) {
d1256 1
a1256 1
	if (blockPtr->flags & FS_BLOCK_CLEANER_WAITING) {
d1258 1
a1258 1
	    blockPtr->flags &= ~FS_BLOCK_CLEANER_WAITING;
d1260 1
a1260 1
	if (flags & FS_BLOCK_UNNEEDED) {
d1266 2
a1267 2
	    if (blockPtr->flags & FS_BLOCK_ON_DIRTY_LIST) {
		blockPtr->flags |= FS_MOVE_TO_FRONT;
d1271 1
a1271 1
	    fsStats.blockCache.blocksPitched++;
d1277 2
a1278 2
	    blockPtr->timeReferenced = fsTimeInSeconds;
	    blockPtr->flags &= ~FS_MOVE_TO_FRONT;
d1284 5
a1288 5
	if ((blockPtr->flags & (FS_BLOCK_DIRTY | FS_BLOCK_BEING_WRITTEN)) &&
	    ((fsWriteThrough || fsWriteBackASAP) &&
	     !(flags & FS_DONT_WRITE_THRU)) &&
	    (!fsDelayTmpFiles ||
	     FsFindFileType(blockPtr->cacheInfoPtr) != FS_FILE_TYPE_TMP)) {
d1294 2
a1295 2
	    blockPtr->flags |= FS_WRITE_THRU_BLOCK;
	    if (fsWriteBackASAP) {
d1300 2
a1301 2
		    !(blockPtr->flags & FS_DATA_CACHE_BLOCK)) {
		    if (!(blockPtr->flags & FS_BLOCK_ON_DIRTY_LIST)) {
d1309 1
a1309 1
		if (!(blockPtr->flags & FS_BLOCK_ON_DIRTY_LIST)) {
d1318 1
a1318 1
			    (FS_BLOCK_DIRTY | FS_BLOCK_BEING_WRITTEN));
d1330 1
a1330 1
 * FsCacheBlockTrunc --
d1345 2
a1346 2
FsCacheBlockTrunc(cacheInfoPtr, blockNum, newBlockSize)
    FsCacheFileInfo *cacheInfoPtr;	/* Cache state of file. */
d1351 1
a1351 1
    register FsCacheBlock    *blockPtr;
d1360 1
a1360 1
	blockPtr = (FsCacheBlock *) Hash_GetValue(hashEntryPtr);
d1385 1
a1385 1
 * FsCacheFileInvalidate --
d1400 2
a1401 2
FsCacheFileInvalidate(cacheInfoPtr, firstBlock, lastBlock)
    FsCacheFileInfo *cacheInfoPtr;	/* Cache state of file to invalidate. */
d1403 1
a1403 1
    int		lastBlock;	/* Last block to invalidate.  FS_LAST_BLOCK
d1409 1
a1409 1
    if (lastBlock == FS_LAST_BLOCK) {
d1444 1
a1444 1
    FsCacheFileInfo	*cacheInfoPtr;	/* File to invalidate. */
d1449 1
a1449 1
    register FsCacheBlock    *blockPtr;
d1453 1
a1453 1
    FS_TRACE_IO(FS_TRACE_SRV_WRITE_1, cacheInfoPtr->hdrPtr->fileID, firstBlock, lastBlock);
d1463 1
a1463 1
	    blockPtr = (FsCacheBlock *) Hash_GetValue(hashEntryPtr);
d1475 1
a1475 1
	    FS_TRACE_BLOCK(FS_TRACE_DEL_BLOCK, blockPtr);
d1481 1
a1481 1
	    if (blockPtr->flags & FS_BLOCK_ON_DIRTY_LIST) {
d1484 1
a1484 1
	    if (blockPtr->flags & FS_BLOCK_DIRTY) {
d1499 2
a1500 2
			~(FS_CACHE_SERVER_DOWN | FS_CACHE_NO_DISK_SPACE |
			  FS_CACHE_DOMAIN_DOWN | FS_CACHE_GENERIC_ERROR);
d1525 1
a1525 1
    register	FsCacheBlock	*blockPtr;
d1527 1
a1527 1
    register	FsCacheFileInfo	*cacheInfoPtr;
d1531 1
a1531 1
    if ((cacheInfoPtr->flags & FS_FILE_ON_DIRTY_LIST) &&
d1539 1
a1539 1
	cacheInfoPtr->flags &= ~FS_FILE_ON_DIRTY_LIST;
d1543 1
a1543 1
    if (blockPtr->flags & FS_WRITE_BACK_WAIT) {
d1545 1
a1545 1
	blockPtr->flags &= ~FS_WRITE_BACK_WAIT;
a1552 76
 *----------------------------------------------------------------------
 *
 * Fs_FileWriteBackStub --
 *
 *      This is the stub for the Fs_WriteBackID system call.
 *	The byte arguments are rounded to blocks, and the range of
 *	blocks that covers the byte range is written back out of the cache.
 *
 * Results:
 *	A return status or SUCCESS if successful.
 *
 * Side effects:
 *	Write out the range of blocks in the cache.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
Fs_FileWriteBackStub(streamID, firstByte, lastByte, shouldBlock)
    int		streamID;	/* Stream ID of file to write back. */
    int		firstByte;	/* First byte to write back. */
    int		lastByte;	/* Last byte to write back. */
    Boolean	shouldBlock;	/* TRUE if should wait for the blocks to go
				 * to disk. */
{
    ReturnStatus	status;
    Fs_Stream		*streamPtr;
    FsCacheFileInfo	*cacheInfoPtr;
    register int	firstBlock;
    register int	lastBlock;
    register int	flags;
    int			blocksSkipped;

    status = FsGetStreamPtr(Proc_GetEffectiveProc(), 
			    streamID, &streamPtr);
    if (status != SUCCESS) {
	return(status);
    }
    switch(streamPtr->ioHandlePtr->fileID.type) {
	case FS_LCL_FILE_STREAM: {
	    register FsLocalFileIOHandle *localHandlePtr;
	    localHandlePtr = (FsLocalFileIOHandle *)streamPtr->ioHandlePtr;
	    cacheInfoPtr = &localHandlePtr->cacheInfo;
	    break;
	}
	case FS_RMT_FILE_STREAM: {
	    register FsRmtFileIOHandle *rmtHandlePtr;
	    rmtHandlePtr = (FsRmtFileIOHandle *)streamPtr->ioHandlePtr;
	    cacheInfoPtr = &rmtHandlePtr->cacheInfo;
	    break;
	}
	default:
	    return(FS_WRONG_TYPE);
    }
    flags = 0;
    if (shouldBlock) {
	flags |= FS_FILE_WB_WAIT;
    }
    if (firstByte > 0) {
	firstBlock = firstByte / FS_BLOCK_SIZE;
    } else {
	firstBlock = 0;
    }
    if (lastByte > 0) {
	lastBlock = lastByte / FS_BLOCK_SIZE;
    } else {
	lastBlock = FS_LAST_BLOCK;
    }
    cacheInfoPtr->flags |= FS_CACHE_WB_ON_LDB;
    status = FsCacheFileWriteBack(cacheInfoPtr, firstBlock, lastBlock,
		    flags, &blocksSkipped);

    return(status);
}


/*
d1555 1
a1555 1
 * FsCacheFileWriteBack --
d1571 1
a1571 1
FsCacheFileWriteBack(cacheInfoPtr, firstBlock, lastBlock, flags,
d1573 1
a1573 1
    register FsCacheFileInfo *cacheInfoPtr;	/* State to force out. */
d1576 2
a1577 2
    int		flags;		/* FS_FILE_WB_WAIT | FS_FILE_WB_INDIRECT |
				 * FS_FILE_WB_INVALIDATE. */
d1582 1
a1582 1
    register FsCacheBlock    *blockPtr;
d1596 2
a1597 2
		    ~(FS_CACHE_SERVER_DOWN | FS_CACHE_NO_DISK_SPACE | 
		      FS_CACHE_DOMAIN_DOWN | FS_CACHE_GENERIC_ERROR);
d1606 1
a1606 1
    if (lastBlock == FS_LAST_BLOCK) {
d1625 1
a1625 1
	blockPtr = (FsCacheBlock *) Hash_GetValue(hashEntryPtr);
d1628 1
a1628 1
	    panic( "FsCacheFileWriteBack, hashing error\n");
d1633 1
a1633 1
	if (flags & (FS_FILE_WB_INVALIDATE | FS_FILE_WB_WAIT)) {
d1647 1
a1647 1
	    if (flags & FS_FILE_WB_INVALIDATE) {
d1652 2
a1653 2
		blockPtr->flags |= FS_BLOCK_DELETED;
		FS_TRACE_BLOCK(FS_TRACE_DEL_BLOCK, blockPtr);
d1668 1
a1668 1
	if (blockPtr->flags & FS_BLOCK_ON_DIRTY_LIST) {
d1672 1
a1672 1
	} else if (blockPtr->flags & FS_BLOCK_DIRTY) {
d1674 1
a1674 1
	} else if (flags & FS_FILE_WB_INVALIDATE) {
d1686 1
a1686 1
    if (flags & FS_FILE_WB_INDIRECT) {
d1690 1
a1690 1
	    if (blockPtr->flags & FS_BLOCK_ON_DIRTY_LIST) {
d1694 1
a1694 1
	    } else if (blockPtr->flags & FS_BLOCK_DIRTY) {
d1707 1
a1707 1
    if (flags & FS_FILE_WB_WAIT) {
d1710 2
a1711 2
		    (FS_CACHE_SERVER_DOWN | FS_CACHE_NO_DISK_SPACE |
		     FS_CACHE_DOMAIN_DOWN | FS_CACHE_GENERIC_ERROR)) &&
d1717 3
a1719 3
    switch (cacheInfoPtr->flags&(FS_CACHE_SERVER_DOWN|FS_CACHE_NO_DISK_SPACE|
				 FS_CACHE_DOMAIN_DOWN|FS_CACHE_GENERIC_ERROR)) {
	case FS_CACHE_SERVER_DOWN:
d1722 1
a1722 1
	case FS_CACHE_NO_DISK_SPACE:
d1725 1
a1725 1
	case FS_CACHE_DOMAIN_DOWN:
d1728 1
a1728 1
	case FS_CACHE_GENERIC_ERROR:
d1745 1
a1745 1
 * Fs_CacheBlocksUnneeded --
d1758 1
a1758 1
 *	None here, see FsCacheBlocksUnneeded.
d1766 1
a1766 1
Fs_CacheBlocksUnneeded(streamPtr, offset, numBytes, objectFile)
d1773 1
a1773 1
    register FsCacheFileInfo *cacheInfoPtr;
d1776 2
a1777 2
	case FS_LCL_FILE_STREAM: {
	    register FsLocalFileIOHandle *localHandlePtr;
d1784 1
a1784 1
	    localHandlePtr = (FsLocalFileIOHandle *)streamPtr->ioHandlePtr;
d1788 3
a1790 3
	case FS_RMT_FILE_STREAM: {
	    register FsRmtFileIOHandle *rmtHandlePtr;
	    rmtHandlePtr = (FsRmtFileIOHandle *)streamPtr->ioHandlePtr;
d1795 1
a1795 1
	    panic( "Fs_CacheBlocksUnneeded, bad stream type %d\n",
d1799 1
a1799 1
    FsCacheBlocksUnneeded(cacheInfoPtr, offset, numBytes);
d1806 1
a1806 1
 * FsCacheBlocksUnneeded --
d1822 2
a1823 2
FsCacheBlocksUnneeded(cacheInfoPtr, offset, numBytes)
    register FsCacheFileInfo *cacheInfoPtr;	/* Cache state. */
d1828 1
a1828 1
    register FsCacheBlock    	*blockPtr;
d1855 1
a1855 1
	blockPtr = (FsCacheBlock *) Hash_GetValue(hashEntryPtr);
d1869 1
a1869 1
	if (blockPtr->flags & FS_BLOCK_ON_DIRTY_LIST) {
d1874 1
a1874 1
	    blockPtr->flags |= FS_MOVE_TO_FRONT;
d1881 1
a1881 1
	fsStats.blockCache.blocksPitched++;
d1904 1
a1904 1
 * Fs_CacheWriteBack --
d1920 1
a1920 1
Fs_CacheWriteBack(writeBackTime, blocksSkippedPtr, shutdown)
d1938 1
a1938 1
 * Fs_CacheEmpty --
d1952 1
a1952 1
Fs_CacheEmpty(numLockedBlocksPtr)
d1956 1
a1956 1
    register	FsCacheBlock	*blockPtr;
d1966 1
a1966 1
	blockPtr = (FsCacheBlock *)nextPtr;
d1969 1
a1969 1
	    (blockPtr->flags & (FS_BLOCK_DIRTY | FS_BLOCK_ON_DIRTY_LIST))) {
d2014 2
a2015 2
    register FsCacheFileInfo	*cacheInfoPtr;
    register FsCacheBlock 	*blockPtr;
d2019 1
a2019 1
    currentTime = fsTimeInSeconds;
d2031 2
a2032 2
	if (fsDelayTmpFiles && !writeTmpFiles &&
	    FsFindFileType(cacheInfoPtr) == FS_FILE_TYPE_TMP) {
d2035 1
a2035 1
	if (cacheInfoPtr->flags & FS_CACHE_SERVER_DOWN) {
d2043 2
a2044 2
		(FS_CACHE_NO_DISK_SPACE | FS_CACHE_DOMAIN_DOWN |
		 FS_CACHE_GENERIC_ERROR)) {
d2050 2
a2051 2
			    ~(FS_CACHE_NO_DISK_SPACE | FS_CACHE_DOMAIN_DOWN |
			      FS_CACHE_GENERIC_ERROR);
d2065 1
a2065 1
	if (blockPtr->flags & FS_WRITE_BACK_WAIT) {
d2073 2
a2074 2
	if (blockPtr->flags & FS_BLOCK_ON_DIRTY_LIST) {
	    blockPtr->flags |= FS_WRITE_BACK_WAIT;
d2076 1
a2076 1
	} else if ((blockPtr->flags & FS_BLOCK_DIRTY) &&
d2079 1
a2079 1
	    blockPtr->flags |= FS_WRITE_BACK_WAIT;
d2104 1
a2104 1
 * FsCleanBlocks
d2119 1
a2119 1
FsCleanBlocks(data, callInfoPtr)
d2127 2
a2128 2
    register	FsCacheBlock	*blockPtr;
    FsCacheBlock		*tBlockPtr;
d2131 1
a2131 1
    FsCacheFileInfo		*cacheInfoPtr;
d2137 2
a2138 2
    while (cacheInfoPtr != (FsCacheFileInfo *)NIL) {
	while (blockPtr != (FsCacheBlock *)NIL) {
d2140 1
a2140 1
		panic( "FsCleanBlocks, bad block\n");
d2146 1
a2146 1
	    fsStats.blockCache.blocksWrittenThru++;
d2148 4
a2151 4
		    (FS_DATA_CACHE_BLOCK | FS_IND_CACHE_BLOCK |
		     FS_DESC_CACHE_BLOCK | FS_DIR_CACHE_BLOCK)) {
		case FS_DATA_CACHE_BLOCK:
		    fsStats.blockCache.dataBlocksWrittenThru++;
d2153 2
a2154 2
		case FS_IND_CACHE_BLOCK:
		    fsStats.blockCache.indBlocksWrittenThru++;
d2156 2
a2157 2
		case FS_DESC_CACHE_BLOCK:
		    fsStats.blockCache.descBlocksWrittenThru++;
d2159 2
a2160 2
		case FS_DIR_CACHE_BLOCK:
		    fsStats.blockCache.dirBlocksWrittenThru++;
d2163 1
a2163 1
		    printf( "FsCleanBlocks: Unknown block type\n");
d2170 1
a2170 1
		panic( "FsCleanBlocks, uninitialized block size\n");
d2174 2
a2175 2
	    FS_TRACE_BLOCK(FS_TRACE_BLOCK_WRITE, blockPtr);
	    status = (*fsStreamOpTable[cacheInfoPtr->hdrPtr->fileID.type].blockWrite)
d2211 1
a2211 1
    FsCacheFileInfo *cacheInfoPtr;	/* Cache info for the file. */
d2213 3
a2215 3
    if (!(cacheInfoPtr->flags & FS_FILE_BEING_WRITTEN) &&
	numBlockCleaners < fsMaxBlockCleaners) {
	Proc_CallFunc(FsCleanBlocks, (ClientData) TRUE, 0);
d2245 2
a2246 2
    FsCacheFileInfo	**cacheInfoPtrPtr;
    FsCacheBlock	**blockPtrPtr;
d2249 1
a2249 1
    register FsCacheFileInfo *cacheInfoPtr;
d2253 1
a2253 1
    *cacheInfoPtrPtr = (FsCacheFileInfo *)NIL;
d2264 1
a2264 1
	if (cacheInfoPtr->flags & FS_CACHE_SERVER_DOWN) {
d2269 1
a2269 1
	} else if (cacheInfoPtr->flags & FS_CLOSE_IN_PROGRESS) {
d2275 1
a2275 1
	} else if (cacheInfoPtr->flags & FS_FILE_GONE) {
d2282 1
a2282 1
		FsHandleName(cacheInfoPtr->hdrPtr));
d2285 3
a2287 3
		       (FS_CACHE_NO_DISK_SPACE | FS_CACHE_DOMAIN_DOWN |
		        FS_CACHE_GENERIC_ERROR)) {
	    if (fsTimeInSeconds - cacheInfoPtr->lastTimeTried <
d2292 2
a2293 2
			    ~(FS_CACHE_NO_DISK_SPACE | FS_CACHE_DOMAIN_DOWN |
			      FS_CACHE_GENERIC_ERROR);
d2296 2
a2297 2
	cacheInfoPtr->flags |= FS_FILE_BEING_WRITTEN;
	cacheInfoPtr->flags &= ~FS_FILE_ON_DIRTY_LIST;
d2299 1
a2299 1
	if (*blockPtrPtr != (FsCacheBlock *)NIL) {
d2307 1
a2307 1
    FS_CACHE_DEBUG_PRINT("GetDirtyFile: All files unusable\n");
d2334 2
a2335 2
    FsCacheFileInfo	*cacheInfoPtr;
    FsCacheBlock	**blockPtrPtr;
d2370 2
a2371 2
    register	FsCacheFileInfo	*cacheInfoPtr;
    FsCacheBlock		**blockPtrPtr;
d2375 1
a2375 1
    register	FsCacheBlock	*blockPtr;
d2377 1
a2377 1
    *blockPtrPtr = (FsCacheBlock *) NIL;
d2380 2
a2381 2
	cacheInfoPtr->flags &= ~FS_FILE_BEING_WRITTEN;
	if (cacheInfoPtr->flags & FS_CLOSE_IN_PROGRESS) {
d2390 1
a2390 1
    } else if (cacheInfoPtr->flags & FS_CLOSE_IN_PROGRESS) {
d2396 1
a2396 1
	cacheInfoPtr->flags &= ~FS_FILE_BEING_WRITTEN;
d2415 1
a2415 1
	    blockPtr->flags |= FS_BLOCK_CLEANER_WAITING;
d2423 2
a2424 2
	blockPtr->flags &= ~FS_BLOCK_DIRTY;
	blockPtr->flags |= FS_BLOCK_BEING_WRITTEN;
d2428 1
a2428 1
	    if (cacheInfoPtr->flags & FS_CACHE_WB_ON_LDB) {
d2430 1
a2430 1
		cacheInfoPtr->flags &= ~FS_CACHE_WB_ON_LDB;
d2439 2
a2440 2
    FS_CACHE_DEBUG_PRINT("GetDirtyBlockInt: All blocks unusable\n");
    cacheInfoPtr->flags &= ~FS_FILE_BEING_WRITTEN;
d2462 2
a2463 2
    register	FsCacheFileInfo	*cacheInfoPtr;
    register	FsCacheBlock	*blockPtr;
d2471 2
a2472 2
        (blockPtr->flags & FS_WRITE_THRU_BLOCK) &&
        (blockPtr->flags & FS_BLOCK_DIRTY)) {
d2477 1
a2477 1
	blockPtr->flags &= ~FS_BLOCK_DIRTY;
d2480 1
a2480 1
	    if (cacheInfoPtr->flags & FS_CACHE_WB_ON_LDB) {
d2482 1
a2482 1
		cacheInfoPtr->flags &= ~FS_CACHE_WB_ON_LDB;
d2494 1
a2494 1
    blockPtr->flags &= ~(FS_BLOCK_BEING_WRITTEN | FS_BLOCK_ON_DIRTY_LIST);
d2502 1
a2502 1
    if (blockPtr->flags & FS_WRITE_BACK_WAIT) {
d2504 1
a2504 1
	blockPtr->flags &= ~FS_WRITE_BACK_WAIT;
d2515 1
a2515 1
	register	FsCacheBlock	*newBlockPtr;
d2524 1
a2524 1
	    if (newBlockPtr->flags & FS_WRITE_BACK_WAIT) {
d2526 1
a2526 1
		newBlockPtr->flags &= ~FS_WRITE_BACK_WAIT;
d2538 1
a2538 1
		if (!(cacheInfoPtr->flags & FS_CACHE_SERVER_DOWN)) {
d2540 1
a2540 1
		    cacheInfoPtr->flags |= FS_CACHE_SERVER_DOWN;
d2546 1
a2546 1
		(void) FsWantRecovery(cacheInfoPtr->hdrPtr);
d2549 1
a2549 1
		if (!(cacheInfoPtr->flags & FS_CACHE_NO_DISK_SPACE)) {
d2551 1
a2551 1
		    cacheInfoPtr->flags |= FS_CACHE_NO_DISK_SPACE;
d2555 1
a2555 1
		if (!(cacheInfoPtr->flags & FS_CACHE_DOMAIN_DOWN)) {
d2557 1
a2557 1
		    cacheInfoPtr->flags |= FS_CACHE_DOMAIN_DOWN;
d2569 1
a2569 1
		blockPtr->flags |= FS_BLOCK_BEING_WRITTEN;
d2574 1
a2574 1
		cacheInfoPtr->flags |= FS_CACHE_GENERIC_ERROR;
d2578 1
a2578 1
		cacheInfoPtr->flags |= FS_CACHE_GENERIC_ERROR;
d2582 1
a2582 1
	    FsFileError(cacheInfoPtr->hdrPtr, "Write-back failed", status);
d2584 1
a2584 1
	cacheInfoPtr->lastTimeTried = fsTimeInSeconds;
d2586 1
a2586 1
	cacheInfoPtr->flags &= ~FS_FILE_BEING_WRITTEN;
d2588 1
a2588 1
	if (cacheInfoPtr->flags & FS_CLOSE_IN_PROGRESS) {
d2605 2
a2606 2
			~(FS_CACHE_SERVER_DOWN | FS_CACHE_NO_DISK_SPACE | 
			  FS_CACHE_GENERIC_ERROR);
d2612 1
a2612 1
    if (blockPtr->flags & FS_BLOCK_DELETED) {
d2614 1
a2614 1
    } else if (blockPtr->flags & FS_MOVE_TO_FRONT) {
d2616 1
a2616 1
	blockPtr->flags &= ~FS_MOVE_TO_FRONT;
d2624 1
a2624 1
    blockPtr->flags &= ~FS_WRITE_THRU_BLOCK;
d2652 1
a2652 1
    FsCacheBlock	*blockPtr;
d2655 2
a2656 2
    blockPtr = (FsCacheBlock *)data;
    newDiskBlock = FsBlockRealloc(blockPtr->cacheInfoPtr->hdrPtr,
d2679 1
a2679 1
    FsCacheBlock	*blockPtr;
d2685 1
a2685 1
    blockPtr->flags &= ~FS_BLOCK_BEING_WRITTEN;
d2690 2
a2691 2
			    ~(FS_CACHE_NO_DISK_SPACE | FS_CACHE_DOMAIN_DOWN |
			      FS_CACHE_GENERIC_ERROR);
d2703 1
a2703 1
 * FsPreventWriteBacks --
d2716 1
a2716 1
 *	FS_CLOSE_IN_PROGRESS flags set in the cacheInfo for this file.
d2722 2
a2723 2
FsPreventWriteBacks(cacheInfoPtr)
    FsCacheFileInfo *cacheInfoPtr;
d2729 2
a2730 2
    cacheInfoPtr->flags |= FS_CLOSE_IN_PROGRESS;
    while (cacheInfoPtr->flags & FS_FILE_BEING_WRITTEN) {
d2733 1
a2733 1
    if (cacheInfoPtr->flags & FS_FILE_NOT_CACHEABLE) {
d2748 1
a2748 1
 * FsAllowWriteBacks --
d2757 1
a2757 1
 *	FS_CLOSE_IN_PROGRESS flag cleared from the handle for this file.
d2764 2
a2765 2
FsAllowWriteBacks(cacheInfoPtr)
    register	FsCacheFileInfo *cacheInfoPtr;
d2769 1
a2769 1
    cacheInfoPtr->flags &= ~FS_CLOSE_IN_PROGRESS;
d2789 1
a2789 1
 * FsAllInCache --
d2803 2
a2804 2
FsAllInCache(cacheInfoPtr)
    register	FsCacheFileInfo *cacheInfoPtr;
d2811 1
a2811 1
    fsStats.blockCache.allInCacheCalls++;
d2822 1
a2822 1
	    fsStats.blockCache.allInCacheTrue++;
d2835 1
a2835 1
 * FsBlockCacheOkToScavenge --
d2838 1
a2838 1
 *	called from FsCacheOkToScavenge which
d2850 2
a2851 2
FsBlockCacheOkToScavenge(cacheInfoPtr)
    register FsCacheFileInfo	*cacheInfoPtr;	/* Cache state to check. */
d2856 1
a2856 1
    register FsCacheBlock *blockPtr;
d2878 2
a2879 2
    if (numBlocks == 0 && (cacheInfoPtr->flags & FS_FILE_ON_DIRTY_LIST)) {
	printf("FsBlockCacheOkToScavenge dirty file with no regular blocks\n");
d2882 1
a2882 1
	((cacheInfoPtr->flags & FS_FILE_ON_DIRTY_LIST) == 0);
d2908 1
a2908 1
    register	FsCacheBlock	*blockPtr;
d2918 1
a2918 1
	FS_TRACE(FS_TRACE_NO_BLOCK);
d2922 1
a2922 1
    blockPtr = (FsCacheBlock *) Hash_GetValue(hashEntryPtr);
d2928 2
a2929 2
	(blockPtr->flags & FS_BLOCK_BEING_WRITTEN)) {
	FS_TRACE_BLOCK(FS_TRACE_BLOCK_WAIT, blockPtr);
d2936 1
a2936 1
    FS_TRACE_BLOCK(FS_TRACE_BLOCK_HIT, blockPtr);
d2960 1
a2960 1
    register	FsCacheBlock	*blockPtr;
d2971 1
a2971 1
    FS_TRACE_BLOCK(FS_TRACE_DEL_BLOCK, blockPtr);
d2981 1
a2981 1
 * Fs_DumpCacheStats --
d2994 1
a2994 1
Fs_DumpCacheStats()
d2996 1
a2996 1
    register FsBlockCacheStats *block;
d2998 1
a2998 1
    block = &fsStats.blockCache;
d3040 3
a3042 3
	    fsStats.object.streams, fsStats.object.streamClients,
	    fsStats.object.files, fsStats.object.directory,
	    fsStats.object.rmtFiles, fsStats.object.pipes);
d3044 7
a3050 7
	    fsStats.object.devices, fsStats.object.controls,
	    fsStats.object.pseudoStreams, fsStats.object.remote,
	    fsStats.object.streams + fsStats.object.files +
	    fsStats.object.rmtFiles + fsStats.object.pipes +
	    fsStats.object.devices + fsStats.object.controls +
	    fsStats.object.directory +
	    2 * fsStats.object.pseudoStreams + fsStats.object.remote);
d3052 3
a3054 3
	    fsStats.handle.maxNumber, fsStats.handle.exists,
	    fsStats.handle.lruScans, fsStats.handle.lruHits,
	    fsStats.handle.lruChecks, fsStats.object.dirFlushed);
d3061 1
a3061 1
 * Fs_CheckFragmentation --
d3076 1
a3076 1
Fs_CheckFragmentation(numBlocksPtr, totalBytesWastedPtr, fragBytesWastedPtr)
d3083 1
a3083 1
    register FsCacheBlock 	*blockPtr;
d3106 1
a3106 1
	    if (blockPtr->blockNum < FS_NUM_DIRECT_BLOCKS) {
@


8.15
log
@Updated L1-C output to match new Fs_Stats structure
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 8.13 89/05/30 16:10:28 jhh Exp Locker: brent $ SPRITE (Berkeley)";
d1239 7
d3127 2
a3128 2
	    fsStats.handle.lruScans, fsStats.handle.lruChecks,
	    fsStats.handle.lruHits, fsStats.object.dirFlushed);
d3169 1
a3169 1
	if (blockPtr->refCount > 0) {
@


8.14
log
@Removed lint.
Change calculation of min & max cache size so the minimum is
a reasonably small value, and the max is the total possible
maximum.  These should do for all machines and not need to
be adjusted.
@
text
@d3081 17
a3097 12
    printf("FRAG upgrades %d hits %d zero fills\n",
		block->fragAccesses,
		block->fragHits,
		block->fragZeroFills);
    printf("FILE DESC reads %d hits %d writes %d hits %d\n", 
		block->fileDescReads, block->fileDescReadHits,
		block->fileDescWrites, block->fileDescWriteHits);
    printf("INDIRECT BLOCKS Accesses %d hits %d\n", 
		block->indBlockAccesses, block->indBlockHits);
    printf("VM requests %d/%d/%d, gave up %d\n",
		block->vmRequests, block->triedToGiveToVM, block->vmGotPage,
		block->gavePageToVM);
d3118 1
a3118 1
    printf("HANDLES max %d exist %d scans %d scavenged %d (dirs %d)\n",
d3120 2
a3121 2
	    fsStats.object.lruScans, fsStats.object.scavenges,
	    fsStats.object.dirFlushed);
@


8.13
log
@Removed call to Sync_LockRegister
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 8.12 89/03/18 13:30:42 mgbaker Exp Locker: jhh $ SPRITE (Berkeley)";
a221 1
#ifndef sun4
a225 9
#else
/*
 * The sun4 compiler doesn't seem to allow this sort of redeclaration.
 */
extern FsCacheBlock	*FetchBlock();
extern void		CacheWriteBack();
extern void		StartBlockCleaner();
extern void		ProcessCleanBlock();
#endif sun4
d295 1
a295 1
    register FsCacheFileInfo *cacheInfoPtr;
a325 3
    fsStats.blockCache.minCacheBlocks = 64;
    fsStats.blockCache.maxCacheBlocks = 64;

d332 3
d692 1
a692 1
INTERNAL FsCacheBlock *
d2070 1
a2070 1
INTERNAL void
d2276 1
a2276 1
INTERNAL void
d2526 1
a2526 1
ENTRY void
@


8.12
log
@The sun4 compiler doesn't seem to allow routines to be declared
static and then redeclared as not.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 8.11 89/03/03 08:12:24 brent Exp Locker: mgbaker $ SPRITE (Berkeley)";
a787 1
    Sync_LockRegister(LOCKPTR);
a1152 2

    Sync_LockRegister(&cacheLock);
@


8.11
log
@Fixed static procedure declarations
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 8.10 89/02/19 22:03:00 jhh Exp Locker: brent $ SPRITE (Berkeley)";
d222 1
a223 1
static void		CacheFileInvalidate();
d226 11
a239 1
static void		ProcessCleanBlock();
@


8.10
log
@Changes due to lock registration
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 8.9 89/02/09 08:37:09 brent Exp Locker: jhh $ SPRITE (Berkeley)";
d217 17
a233 17
void		PutOnFreeList();
void		PutFileOnDirtyList();
void		PutBlockOnDirtyList();
Boolean		CreateBlock();
Boolean		DestroyBlock();
FsCacheBlock	*FetchBlock();
void		CacheFileInvalidate();
void		CacheWriteBack();
void		StartBlockCleaner();
void		GetDirtyFile();
void		GetDirtyBlock();
void		GetDirtyBlockInt();
void		ProcessCleanBlock();
void		ReallocBlock();
void		FinishRealloc();
Hash_Entry	*GetUnlockedBlock();
void		DeleteBlock();
d1415 1
a1415 1
void	DeleteBlockFromDirtyList();
@


8.9
log
@Added Sync_LockClear calls, and fixed Sync_Lock initialization
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 8.8 89/02/04 12:23:04 brent Exp $ SPRITE (Berkeley)";
d777 2
@


8.8
log
@Tweaked L1-C output
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 8.7 89/01/30 17:37:58 brent Exp $ SPRITE (Berkeley)";
d96 1
a96 1
static Sync_Lock	cacheLock = SYNC_LOCK_INIT_STATIC();
d274 1
a274 1
    SYNC_LOCK_INIT_DYNAMIC(&cacheInfoPtr->lock);
d281 23
d1143 2
d3102 1
a3102 1
    printf("OBJECTS stream %d (clt %d) file %d rmtFile %d pipe %d\n",
d3104 2
a3105 2
	    fsStats.object.files, fsStats.object.rmtFiles,
	    fsStats.object.pipes);
d3112 1
@


8.7
log
@Fiddled with L1-C output some more
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 8.6 89/01/30 14:01:31 brent Exp $ SPRITE (Berkeley)";
d1376 6
a1381 3
    if ((lastBlock == FS_LAST_BLOCK) &&
	(cacheInfoPtr->attr.lastByte > 0)) {
	lastBlock = cacheInfoPtr->attr.lastByte / FS_BLOCK_SIZE;
d1649 6
a1654 3
    if ((lastBlock == FS_LAST_BLOCK) &&
	(cacheInfoPtr->attr.lastByte > 0)) {
	lastBlock = cacheInfoPtr->attr.lastByte / FS_BLOCK_SIZE;
d3077 7
a3083 12
    printf("OBJECTS stream %d stmClient %d file %d rmtFile %d\n",
	    fsStats.object.streams,
	    fsStats.object.streamClients, fsStats.object.files,
	    fsStats.object.rmtFiles);
    printf("OBJECTS   pipe %d dev %d control %d pdev %d remote %d\n",
	    fsStats.object.pipes, fsStats.object.devices,
	    fsStats.object.controls, fsStats.object.pseudoStreams,
	    fsStats.object.remote);
    printf("HANDLES limit %d exist %d created %d lruScans %d scavenged %d objects %d\n",
	    fsStats.handle.maxNumber, fsStats.handle.exists,
	    fsStats.handle.created,
	    fsStats.object.lruScans, fsStats.object.scavenges,
d3088 4
@


8.6
log
@Added object information to L1-C dump
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 8.5 89/01/06 11:18:20 jhh Exp $ SPRITE (Berkeley)";
d3071 2
a3072 2
    printf("OBJECTS lruScan %d stream %d stmClient %d file %d rmtFile %d\n",
	    fsStats.object.lruScans, fsStats.object.streams,
d3075 1
a3075 1
    printf("OBJECTS    pipe %d dev %d control %d pdev %d remote %d\n",
d3079 4
a3082 2
    printf("HANDLES exist %d objects %d\n",
	    fsStats.handle.exists,
@


8.5
log
@new Sync_Lock definition
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 8.4 89/01/04 08:49:57 brent Exp Locker: jhh $ SPRITE (Berkeley)";
d3070 15
@


8.4
log
@Put check in FetchBlock() against block in the FS_BLOCK_BEING_WRITTEN state.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 8.3 88/12/07 11:36:02 brent Exp $ SPRITE (Berkeley)";
d96 1
a96 1
static Sync_Lock	cacheLock = {0, 0};
d274 1
@


8.3
log
@Added mousetrap against corrupted LRU list
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 8.2 88/11/30 15:10:49 brent Exp Locker: brent $ SPRITE (Berkeley)";
d631 3
d702 5
a706 1
	    printf( "FetchBlock: deleted block in LRU list\n");
d1074 1
a1074 1
    			       FS_READ_AHEAD_BLOCK);
@


8.2
log
@Updated the OkToScavenge routine to check for dirty
files and to look at indirect blocks.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 8.1 88/11/26 11:34:47 brent Exp $ SPRITE (Berkeley)";
d1657 1
a1657 1
	    panic( "CacheWriteBack, hashing error\n");
d2055 5
@


8.1
log
@Moved handling of FS_LAST_BLOCK constant from CacheFileInvalidate
to FsCacheFileInvalidate.  The former may be called with indirect
block numbers which match FS_LAST_BLOCK.
Changed the block cleaner to skip deleted files that are dirty.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 7.0 88/11/11 15:29:10 brent Exp $ SPRITE (Berkeley)";
d2859 1
a2859 1
 * FsCacheFileBlocks --
d2861 2
a2862 2
 *	Return the number of blocks in the cache for the file.  This is
 *	called from FsCacheNumBlocks (sigh, sorry for the names) which
d2866 1
a2866 1
 *	The number of blocks in the cache for the file.
d2874 1
a2874 1
FsCacheFileBlocks(cacheInfoPtr)
d2879 1
d2890 1
a2890 1
	    return(numBlocks);
d2894 3
d2900 1
a2900 1
	return(numBlocks);
d2902 5
d2908 1
a2908 1
    return(numBlocks);
@


8.0
log
@Changing version numbers.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 7.0 88/11/11 15:29:10 brent Exp Locker: douglis $ SPRITE (Berkeley)";
d1361 4
a1364 2
    int		firstBlock;	/* First block to invalidate. */
    int		lastBlock;	/* Last block to invalidate. */
d1368 4
a1412 4
	if ((lastBlock == FS_LAST_BLOCK) &&
	    (cacheInfoPtr->attr.lastByte > 0)) {
	    lastBlock = cacheInfoPtr->attr.lastByte / FS_BLOCK_SIZE;
	}
d2298 9
@


7.0
log
@New version for conversion to new C library
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsBlockCache.c,v 6.6 88/09/14 12:35:36 nelson Exp Locker: brent $ SPRITE (Berkeley)";
@


6.6
log
@Changed it to no longer force write through on blocks when upgrade
fragments.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: fsBlockCache.c,v 6.5 88/09/08 19:09:39 brent Exp $ SPRITE (Berkeley)";
d200 1
a200 1
 * This lets you pass a variable number of arguments through to Sys_Printf:
d205 1
a205 1
	Sys_Printf format ; \
d349 1
a349 1
	    Sys_Printf("FsBlockCacheInit: Couldn't create block\n");
d354 1
a354 1
    Sys_Printf("FS Cache has %d %d-Kbyte blocks (%d max)\n",
d513 1
a513 1
	Sys_Panic(SYS_WARNING, "CreateBlock: No unmapped blocks\n");
d673 1
a673 1
	Sys_Panic(SYS_WARNING, "FetchBlock: LRU list empty\n");
d699 1
a699 1
	    Sys_Panic(SYS_WARNING, "FetchBlock: deleted block in LRU list\n");
d752 1
a752 1
	Sys_Printf( "FsSetMinSize: Only raising min cache size to %d blocks\n", 
d769 1
a769 1
	    Sys_Printf("FsSetMinSize: lowered min cache size to %d blocks\n",
d809 1
a809 1
	Sys_Printf("FsSetMaxSize: Only raising max cache size to %d blocks\n",
d831 1
a831 1
	Sys_Printf("FsSetMaxSize: Could only lower cache to %d\n", 
d953 1
a953 1
	    Sys_Panic(SYS_FATAL, "CacheFetchBlock hashing error\n");
d1151 1
a1151 1
	Sys_Panic(SYS_FATAL, "Checking free block\n");
d1184 1
a1184 1
		Sys_Printf("UNL FD=%d Num=%d\n",
d1322 1
a1322 1
	    Sys_Panic(SYS_FATAL, "CacheBlockTrunc, hashing error\n");
d1419 1
a1419 1
		Sys_Panic(SYS_FATAL, "CacheFileInvalidate, hashing error\n");
d1441 1
a1441 1
		    Sys_Printf("Inv FD=%d Num=%d\n", 
d1655 1
a1655 1
	    Sys_Panic(SYS_FATAL, "CacheWriteBack, hashing error\n");
d1822 1
a1822 1
	    Sys_Panic(SYS_FATAL, "Fs_CacheBlocksUnneeded, bad stream type %d\n",
d1885 1
a1885 1
	    Sys_Panic(SYS_FATAL, "CacheBlocksUnneeded, hashing error\n");
d2162 1
a2162 1
		Sys_Panic(SYS_FATAL, "FsCleanBlocks, bad block\n");
d2185 1
a2185 1
		    Sys_Panic(SYS_WARNING, "FsCleanBlocks: Unknown block type\n");
d2192 1
a2192 1
		Sys_Panic(SYS_FATAL, "FsCleanBlocks, uninitialized block size\n");
d2419 1
a2419 1
	    Sys_Panic(SYS_FATAL, "GetDirtyBlock, bad block\n");
d2585 1
a2585 1
		Sys_Printf("File blk %d phys blk %d: ",
d2877 1
a2877 1
	    Sys_Panic(SYS_FATAL, "FsCacheFileBlocks, bad block\n");
d2884 1
a2884 1
	Sys_Panic(SYS_FATAL, "FsCacheFileBlocks, wrong block count\n");
d2973 1
a2973 2
	Sys_Panic(SYS_FATAL,
	    "DeleteBlock: Block in LRU list is not in the hash table.\n");
d3004 2
a3005 2
    Sys_Printf("\n");
    Sys_Printf("READ  %d dirty hits %d clean hits %d zero fill %d\n",
d3010 1
a3010 1
    Sys_Printf("WRITE %d p-hits %d p-misses %d thru %d zero %d/%d app %d over %d\n",
d3018 1
a3018 1
    Sys_Printf("FRAG upgrades %d hits %d zero fills\n",
d3022 1
a3022 1
    Sys_Printf("FILE DESC reads %d hits %d writes %d hits %d\n", 
d3025 1
a3025 1
    Sys_Printf("INDIRECT BLOCKS Accesses %d hits %d\n", 
d3027 1
a3027 1
    Sys_Printf("VM requests %d/%d/%d, gave up %d\n",
d3030 1
a3030 1
    Sys_Printf("BLOCK free %d new %d lru %d part free %d\n",
d3033 1
a3033 1
    Sys_Printf("SIZES Blocks min %d num %d max %d, Blocks max %d free %d pitched %d\n",
@


6.5
log
@Added consistency check called during scavenge time.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: fsBlockCache.c,v 6.4 88/09/08 17:56:44 brent Exp $ SPRITE (Berkeley)";
d1146 1
a1146 1
				 * FS_BLOCK_UNNEEDED */
d1244 2
a1245 1
	    (fsWriteThrough || fsWriteBackASAP) &&
@


6.4
log
@Added synchronized routine to check the number of blocks in the cache.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: fsBlockCache.c,v 6.3 88/09/07 21:18:26 nelson Exp $ SPRITE (Berkeley)";
d2866 4
d2872 14
@


6.3
log
@Put alternative writing policies into the file system.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: fsBlockCache.c,v 6.2 88/08/31 12:03:53 brent Exp $ SPRITE (Berkeley)";
d2843 28
@


6.2
log
@Removed lint.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: fsBlockCache.c,v 6.1 88/08/18 17:58:12 brent Exp $ SPRITE (Berkeley)";
d239 41
a358 23

/*
 * ----------------------------------------------------------------------------
 *
 * FsSetMinSize --
 *
 * 	Set the minimum size of the block cache.  This will entail mapping
 *	enough blocks so that the number of physical pages in use is greater
 *	than or equal to the minimum number.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	More blocks get memory put behind them.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY void
FsSetMinSize(minBlocks)
    int	minBlocks;	/* The minimum number of blocks in the cache. */
{
    LOCK_MONITOR;
a359 32
    DEBUG_PRINT( ("Setting minimum size to %d with current size of %d\n",
		       minBlocks, fsStats.blockCache.minCacheBlocks) );

    if (minBlocks > fsStats.blockCache.maxNumBlocks) {
	minBlocks = fsStats.blockCache.maxNumBlocks;
	Sys_Printf( "FsSetMinSize: Only raising min cache size to %d blocks\n", 
				minBlocks);
    }
    fsStats.blockCache.minCacheBlocks = minBlocks;
    if (fsStats.blockCache.minCacheBlocks <= 
				    fsStats.blockCache.numCacheBlocks) {
	UNLOCK_MONITOR;
	return;
    }
    
    /*
     * Give enough blocks memory so that the minimum cache size requirement
     * is met.
     */
    while (fsStats.blockCache.numCacheBlocks < 
					fsStats.blockCache.minCacheBlocks) {
	if (!CreateBlock(FALSE, (FsCacheBlock **) NIL)) {
	    Sys_Printf("FsSetMinSize: lowered min cache size to %d blocks\n",
		       fsStats.blockCache.numCacheBlocks);
	    fsStats.blockCache.minCacheBlocks = 
				    fsStats.blockCache.numCacheBlocks;
	}
    }

    UNLOCK_MONITOR;
}

a362 101
 *
 * FsSetMaxSize --
 *
 * 	Set the maximum size of the block cache.  This entails freeing
 *	enough main memory pages so that the number of cache pages is
 *	less than the maximum allowed.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Cache blocks have memory removed from behind them and are moved to
 *	the unmapped list. 
 *
 * ----------------------------------------------------------------------------
 */
ENTRY void
FsSetMaxSize(maxBlocks)
    int	maxBlocks;	/* The minimum number of pages in the cache. */
{
    Boolean			giveUp;
    int				pageNum;

    LOCK_MONITOR;

    if (maxBlocks > fsStats.blockCache.maxNumBlocks) {
	maxBlocks = fsStats.blockCache.maxNumBlocks;
	Sys_Printf("FsSetMaxSize: Only raising max cache size to %d blocks\n",
		maxBlocks);
    }

    fsStats.blockCache.maxCacheBlocks = maxBlocks;
    if (fsStats.blockCache.maxCacheBlocks >= 
				    fsStats.blockCache.numCacheBlocks) {
	UNLOCK_MONITOR;
	return;
    }
    
    /*
     * Free enough pages to get down to maximum size.
     */
    giveUp = FALSE;
    while (fsStats.blockCache.numCacheBlocks > 
				fsStats.blockCache.maxCacheBlocks && !giveUp) {
	giveUp = !DestroyBlock(FALSE, &pageNum);
    }

#ifndef CLEAN
    if (cacheDebug && giveUp) {
	Sys_Printf("FsSetMaxSize: Could only lower cache to %d\n", 
					fsStats.blockCache.numCacheBlocks);
    }
#endif not CLEAN
    
    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
 * FsCacheInfoInit --
 *
 * 	Initialize the cache information for a file.  Called when setting
 *	up a handle for a file that uses the block cache.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Set up the fields of the FsCacheFileInfo struct.
 *
 * ----------------------------------------------------------------------------
 */
void
FsCacheInfoInit(cacheInfoPtr, hdrPtr, version, cacheable, attrPtr)
    register FsCacheFileInfo *cacheInfoPtr;	/* Information to initialize. */
    FsHandleHeader	     *hdrPtr;		/* Back pointer to handle */
    int			     version;		/* Used to check consistency */
    Boolean		     cacheable;		/* TRUE if server says we can
						 * cache */
    FsCachedAttributes	     *attrPtr;		/* File attributes */
{
    List_InitElement(&cacheInfoPtr->links);
    List_Init(&cacheInfoPtr->dirtyList);
    List_Init(&cacheInfoPtr->blockList);
    List_Init(&cacheInfoPtr->indList);
    cacheInfoPtr->flags = (cacheable ? 0 : FS_FILE_NOT_CACHEABLE);
    cacheInfoPtr->version = version;
    cacheInfoPtr->hdrPtr = hdrPtr;
    cacheInfoPtr->blocksWritten = 0;
    cacheInfoPtr->noDirtyBlocks.waiting = 0;
    cacheInfoPtr->blocksInCache = 0;
    cacheInfoPtr->numDirtyBlocks = 0;
    cacheInfoPtr->lastTimeTried = 0;
    cacheInfoPtr->attr = *attrPtr;
}


/*
 * ----------------------------------------------------------------------------
d554 1
d559 93
a722 1

d727 1
a727 1
 * DestroyBlock --
d729 3
a731 1
 * 	Destroy one physical page worth of blocks.
d737 1
a737 2
 *	Cache blocks have memory removed from behind them and are moved to
 *	the unmapped list. 
d741 3
a743 4
INTERNAL static Boolean
DestroyBlock(retOnePage, pageNumPtr)
    Boolean	retOnePage;
    int		*pageNumPtr;
d745 1
a745 2
    register	FsCacheBlock	*blockPtr;
    register	FsCacheBlock	*otherBlockPtr;
d747 15
d763 2
a764 1
     * First try the list of totally free pages.
d766 7
a772 19
    if (!List_IsEmpty(totFreeList)) {
	DEBUG_PRINT( ("DestroyBlock: Using tot free block to lower size\n") );
	blockPtr = (FsCacheBlock *) List_First(totFreeList);
	fsStats.blockCache.numCacheBlocks -= 
		    Vm_UnmapBlock(blockPtr->blockAddr, retOnePage,
				  (unsigned int *)pageNumPtr)
		    * blocksPerPage;
	blockPtr->flags = FS_NOT_MAPPED;
	List_Move((List_Links *) blockPtr, LIST_ATREAR(unmappedList));
	fsStats.blockCache.numFreeBlocks--;
	if (PAGE_IS_8K) {
	    /*
	     * Unmap the other block.  The block address can point to either
	     * of the two blocks.
	     */
	    blockPtr = GET_OTHER_BLOCK(blockPtr);
	    blockPtr->flags = FS_NOT_MAPPED;
	    List_Move((List_Links *) blockPtr, LIST_ATREAR(unmappedList));
	    fsStats.blockCache.numFreeBlocks--;
a773 1
	return(TRUE);
d776 44
d821 1
a821 1
     * Now take blocks from the LRU list until we get one that we can use.
d823 4
a826 37
    while (TRUE) {
	blockPtr = FetchBlock(FALSE);
	if (blockPtr == (FsCacheBlock *) NIL) {
	    /*
	     * There are no clean blocks left so give up.
	     */
	    DEBUG_PRINT( ("DestroyBlock: No clean blocks left (1)\n") );
	    return(FALSE);
	}
	if (PAGE_IS_8K) {
	    /*
	     * We have to deal with the other block.  If it is in use, then
	     * we can't take this page.  Otherwise delete the block from
	     * the cache and put it onto the unmapped list.
	     */
	    otherBlockPtr = GET_OTHER_BLOCK(blockPtr);
	    if (otherBlockPtr->refCount > 0 ||
		(otherBlockPtr->flags & FS_BLOCK_ON_DIRTY_LIST) ||
		(otherBlockPtr->flags & FS_BLOCK_DIRTY)) {
		DEBUG_PRINT( ("DestroyBlock: Other block in use.\n") );
		PutOnFreeList(blockPtr);
		continue;
	    }
	    if (!(otherBlockPtr->flags & FS_BLOCK_FREE)) {
		DeleteBlock(otherBlockPtr);
	    }
	    otherBlockPtr->flags = FS_NOT_MAPPED;
	    List_Move((List_Links *) otherBlockPtr, LIST_ATREAR(unmappedList));
	}
	DEBUG_PRINT( ("DestroyBlock: Using in-use block to lower size\n") );
	blockPtr->flags = FS_NOT_MAPPED;
	List_Insert((List_Links *) blockPtr, LIST_ATREAR(unmappedList));
	fsStats.blockCache.numCacheBlocks -= 
		    Vm_UnmapBlock(blockPtr->blockAddr, 
				retOnePage, (unsigned int *)pageNumPtr)
		    * blocksPerPage;
	return(TRUE);
d828 9
d1064 1
a1064 1
    blockPtr->refCount++;
d1073 1
d1145 2
a1146 1
    int		 flags;		/* FS_DELETE_BLOCK | FS_CLEAR_READ_AHEAD */
a1208 16
    /*
     * If the file is write thru then force the block out.
     */
    if ((blockPtr->cacheInfoPtr->flags & FS_FILE_IS_WRITE_THRU) && 
	(blockPtr->flags & (FS_BLOCK_DIRTY | FS_BLOCK_BEING_WRITTEN))) {
	if (!(blockPtr->flags & FS_BLOCK_ON_DIRTY_LIST)) {
	    PutBlockOnDirtyList(blockPtr, FALSE);
	}
	do {
	    (void) Sync_Wait(&blockPtr->ioDone, FALSE);
	    if (sys_ShuttingDown) {
		break;
	    }
	} while (blockPtr->flags & (FS_BLOCK_DIRTY | FS_BLOCK_BEING_WRITTEN));
    }

a1209 1

d1212 1
a1212 3
	 * The block is no longer locked.  Move it to the end of the lru list,
	 * mark it as being referenced, and wake up anybody waiting for the
	 * block to become unlocked.
a1213 3
	blockPtr->timeReferenced = fsTimeInSeconds;
	blockPtr->flags &= ~FS_MOVE_TO_FRONT;
	List_Move((List_Links *) blockPtr, LIST_ATREAR(lruList));
d1219 60
d1573 1
d1709 17
d1955 1
a1955 1
    CacheWriteBack(writeBackTime, blocksSkippedPtr, shutdown);
d1988 1
a1988 1
    CacheWriteBack(-1, &blocksSkipped, FALSE);
d2030 1
a2030 1
CacheWriteBack(writeBackTime, blocksSkippedPtr, shutdown)
d2036 3
d2052 4
d2151 1
a2151 1
    Boolean			lastDirtyBlock;
d2153 1
d2199 2
a2200 1
	    ProcessCleanBlock(cacheInfoPtr, blockPtr, status);
d2204 4
a2207 2
	    GetDirtyBlock(cacheInfoPtr, &tBlockPtr, &lastDirtyBlock);
	    blockPtr = tBlockPtr;
d2268 1
a2268 1
    Boolean		*lastDirtyBlockPtr;
d2348 1
a2348 1
    Boolean		*lastDirtyBlockPtr;
d2384 1
a2384 1
    Boolean			*lastDirtyBlockPtr;
d2438 9
a2446 1
	*lastDirtyBlockPtr = (cacheInfoPtr->numDirtyBlocks == 1);
d2472 2
a2473 1
ProcessCleanBlock(cacheInfoPtr, blockPtr, status) 
d2477 2
d2482 22
d2636 1
@


6.1
log
@Fixed a comment
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: fsBlockCache.c,v 6.0 88/08/11 12:14:27 brent Stable $ SPRITE (Berkeley)";
d273 2
a274 2
    listStart = 
	Vm_RawAlloc(fsStats.blockCache.maxNumBlocks * sizeof(FsCacheBlock));
d777 3
a779 2
		    Vm_UnmapBlock(blockPtr->blockAddr, 
				    retOnePage, pageNumPtr) * blocksPerPage;
d833 2
a834 1
				retOnePage, pageNumPtr) * blocksPerPage;
@


6.0
log
@Changing version numbers.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: fsBlockCache.c,v 1.7 88/06/16 10:21:43 brent Exp $ SPRITE (Berkeley)";
d1468 1
a1468 1
 *      This is the stub for the FsCacheFileWriteBack system call.
@


1.7
log
@Fixed Fs_CacheFileWriteBackStub so it handles a lastByte of -1.
This bug lead to some recently checked in files only having
their first block safely written back to the server...
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: fsBlockCache.c,v 1.6 88/06/15 17:20:06 brent Exp $ SPRITE (Berkeley)";
@


1.6
log
@1. Added tracing
2. Fixed FsPreventWriteBacks to return -1 if not caching so
   we don't return FS_LAST_DIRTY_BLOCK to the server.  That makes
   the server try to delete the last writer which isn't right.
3. Patched FetchBlock to check against finding a deleted block in LRU list.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: fsBlockCache.c,v 1.5 88/06/06 09:33:37 brent Exp $ SPRITE (Berkeley)";
d1491 3
a1494 1
    int			flags;
d1521 12
a1532 2
    status = FsCacheFileWriteBack(cacheInfoPtr, firstByte / FS_BLOCK_SIZE,
		    lastByte / FS_BLOCK_SIZE, flags, &blocksSkipped);
@


1.5
log
@Added the per-file list of blocks and indirect blocks
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: fsBlockCache.c,v 1.4 88/06/04 12:08:38 brent Exp $ SPRITE (Berkeley)";
d719 2
d969 1
d977 1
d1072 1
d1386 1
d1624 1
d2115 1
d2608 1
d2628 5
a2632 1
    numDirtyBlocks = cacheInfoPtr->numDirtyBlocks;
d2812 1
@


1.4
log
@Put in mousetrap against un-initilized blockSize in cache.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: fsBlockCache.c,v 1.3 88/06/01 16:57:37 brent Exp $ SPRITE (Berkeley)";
d462 2
d1070 6
d1379 1
d1614 1
d2801 1
@


1.3
log
@Added tracing to facilitate debugging
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: fsBlockCache.c,v 1.2 88/05/05 17:32:25 brent Exp $ SPRITE (Berkeley)";
d1063 1
d2093 5
@


1.2
log
@Nuked Sys_GetProcessorNumber
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: fsBlockCache.c,v 1.1 88/04/04 10:29:06 brent Exp $ SPRITE (Berkeley)";
d30 1
d322 116
a666 1

a670 92
 * DestroyBlock --
 *
 * 	Destroy one physical page worth of blocks.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Cache blocks have memory removed from behind them and are moved to
 *	the unmapped list. 
 *
 * ----------------------------------------------------------------------------
 */
INTERNAL static Boolean
DestroyBlock(retOnePage, pageNumPtr)
    Boolean	retOnePage;
    int		*pageNumPtr;
{
    register	FsCacheBlock	*blockPtr;
    register	FsCacheBlock	*otherBlockPtr;

    /*
     * First try the list of totally free pages.
     */
    if (!List_IsEmpty(totFreeList)) {
	DEBUG_PRINT( ("DestroyBlock: Using tot free block to lower size\n") );
	blockPtr = (FsCacheBlock *) List_First(totFreeList);
	fsStats.blockCache.numCacheBlocks -= 
		    Vm_UnmapBlock(blockPtr->blockAddr, 
				    retOnePage, pageNumPtr) * blocksPerPage;
	blockPtr->flags = FS_NOT_MAPPED;
	List_Move((List_Links *) blockPtr, LIST_ATREAR(unmappedList));
	fsStats.blockCache.numFreeBlocks--;
	if (PAGE_IS_8K) {
	    /*
	     * Unmap the other block.  The block address can point to either
	     * of the two blocks.
	     */
	    blockPtr = GET_OTHER_BLOCK(blockPtr);
	    blockPtr->flags = FS_NOT_MAPPED;
	    List_Move((List_Links *) blockPtr, LIST_ATREAR(unmappedList));
	    fsStats.blockCache.numFreeBlocks--;
	}
	return(TRUE);
    }

    /*
     * Now take blocks from the LRU list until we get one that we can use.
     */
    while (TRUE) {
	blockPtr = FetchBlock(FALSE);
	if (blockPtr == (FsCacheBlock *) NIL) {
	    /*
	     * There are no clean blocks left so give up.
	     */
	    DEBUG_PRINT( ("DestroyBlock: No clean blocks left (1)\n") );
	    return(FALSE);
	}
	if (PAGE_IS_8K) {
	    /*
	     * We have to deal with the other block.  If it is in use, then
	     * we can't take this page.  Otherwise delete the block from
	     * the cache and put it onto the unmapped list.
	     */
	    otherBlockPtr = GET_OTHER_BLOCK(blockPtr);
	    if (otherBlockPtr->refCount > 0 ||
		(otherBlockPtr->flags & FS_BLOCK_ON_DIRTY_LIST) ||
		(otherBlockPtr->flags & FS_BLOCK_DIRTY)) {
		DEBUG_PRINT( ("DestoryBlock: Other block in use.\n") );
		PutOnFreeList(blockPtr);
		continue;
	    }
	    if (!(otherBlockPtr->flags & FS_BLOCK_FREE)) {
		DeleteBlock(otherBlockPtr);
	    }
	    otherBlockPtr->flags = FS_NOT_MAPPED;
	    List_Move((List_Links *) otherBlockPtr, LIST_ATREAR(unmappedList));
	}
	DEBUG_PRINT( ("DestroyBlock: Using in-use block to lower size\n") );
	blockPtr->flags = FS_NOT_MAPPED;
	List_Insert((List_Links *) blockPtr, LIST_ATREAR(unmappedList));
	fsStats.blockCache.numCacheBlocks -= 
		    Vm_UnmapBlock(blockPtr->blockAddr, 
				retOnePage, pageNumPtr) * blocksPerPage;
	return(TRUE);
    }
}


/*
 * ----------------------------------------------------------------------------
 *
d740 1
d745 1
a745 1
 * FsSetMinSize --
d747 1
a747 3
 * 	Set the minimum size of the block cache.  This will entail mapping
 *	enough blocks so that the number of physical pages in use is greater
 *	than or equal to the minimum number.
d753 2
a754 1
 *	More blocks get memory put behind them.
d758 4
a761 3
ENTRY void
FsSetMinSize(minBlocks)
    int	minBlocks;	/* The minimum number of blocks in the cache. */
d763 2
a764 1
    LOCK_MONITOR;
a765 15
    DEBUG_PRINT( ("Setting minimum size to %d with current size of %d\n",
		       minBlocks, fsStats.blockCache.minCacheBlocks) );

    if (minBlocks > fsStats.blockCache.maxNumBlocks) {
	minBlocks = fsStats.blockCache.maxNumBlocks;
	Sys_Printf( "FsSetMinSize: Only raising min cache size to %d blocks\n", 
				minBlocks);
    }
    fsStats.blockCache.minCacheBlocks = minBlocks;
    if (fsStats.blockCache.minCacheBlocks <= 
				    fsStats.blockCache.numCacheBlocks) {
	UNLOCK_MONITOR;
	return;
    }
    
d767 1
a767 2
     * Give enough blocks memory so that the minimum cache size requirement
     * is met.
d769 18
a786 7
    while (fsStats.blockCache.numCacheBlocks < 
					fsStats.blockCache.minCacheBlocks) {
	if (!CreateBlock(FALSE, (FsCacheBlock **) NIL)) {
	    Sys_Printf("FsSetMinSize: lowered min cache size to %d blocks\n",
		       fsStats.blockCache.numCacheBlocks);
	    fsStats.blockCache.minCacheBlocks = 
				    fsStats.blockCache.numCacheBlocks;
d788 1
a790 44
    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
 * FsSetMaxSize --
 *
 * 	Set the maximum size of the block cache.  This entails freeing
 *	enough main memory pages so that the number of cache pages is
 *	less than the maximum allowed.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Cache blocks have memory removed from behind them and are moved to
 *	the unmapped list. 
 *
 * ----------------------------------------------------------------------------
 */
ENTRY void
FsSetMaxSize(maxBlocks)
    int	maxBlocks;	/* The minimum number of pages in the cache. */
{
    Boolean			giveUp;
    int				pageNum;

    LOCK_MONITOR;

    if (maxBlocks > fsStats.blockCache.maxNumBlocks) {
	maxBlocks = fsStats.blockCache.maxNumBlocks;
	Sys_Printf("FsSetMaxSize: Only raising max cache size to %d blocks\n",
		maxBlocks);
    }

    fsStats.blockCache.maxCacheBlocks = maxBlocks;
    if (fsStats.blockCache.maxCacheBlocks >= 
				    fsStats.blockCache.numCacheBlocks) {
	UNLOCK_MONITOR;
	return;
    }
    
d792 1
a792 1
     * Free enough pages to get down to maximum size.
d794 36
a829 4
    giveUp = FALSE;
    while (fsStats.blockCache.numCacheBlocks > 
				fsStats.blockCache.maxCacheBlocks && !giveUp) {
	giveUp = !DestroyBlock(FALSE, &pageNum);
a830 9

#ifndef CLEAN
    if (cacheDebug && giveUp) {
	Sys_Printf("FsSetMaxSize: Could only lower cache to %d\n", 
					fsStats.blockCache.numCacheBlocks);
    }
#endif not CLEAN
    
    UNLOCK_MONITOR;
d945 7
d1061 1
d1263 6
a1268 1
	blockPtr->blockSize = newBlockSize;
d1346 2
d1361 5
a1365 1
    
d1582 6
d1793 5
d2062 4
d2309 6
d2729 1
d2740 1
d2747 1
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: fsBlockCache.c,v 6.0 87/12/03 11:03:55 brent Exp $ SPRITE (Berkeley)";
d1458 1
a1458 1
    status = FsGetStreamPtr(Proc_GetEffectiveProc(Sys_GetProcessorNumber()), 
@
