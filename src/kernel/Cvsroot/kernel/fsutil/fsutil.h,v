head     9.19;
branch   ;
access   ;
symbols  ds3100:9.18 sun3:9.18 sun4nw:9.15 symm:9.15 spur:9.15 sprited:9.14.1 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.19
date     92.12.13.18.18.35;  author mgbaker;  state Exp;
branches ;
next     9.18;

9.18
date     92.10.28.18.11.11;  author mgbaker;  state Exp;
branches ;
next     9.17;

9.17
date     92.10.26.14.33.57;  author mgbaker;  state Exp;
branches ;
next     9.16;

9.16
date     92.06.01.15.34.01;  author kupfer;  state Exp;
branches ;
next     9.15;

9.15
date     91.09.10.18.24.26;  author rab;  state Exp;
branches ;
next     9.14;

9.14
date     91.05.30.15.02.46;  author kupfer;  state Exp;
branches 9.14.1.1;
next     9.13;

9.13
date     91.01.26.15.35.52;  author mgbaker;  state Exp;
branches ;
next     9.12;

9.12
date     90.12.06.21.55.26;  author jhh;  state Exp;
branches ;
next     9.11;

9.11
date     90.10.10.16.47.49;  author kupfer;  state Exp;
branches ;
next     9.10;

9.10
date     90.10.10.11.14.58;  author mendel;  state Exp;
branches ;
next     9.9;

9.9
date     90.10.08.13.15.34;  author mendel;  state Exp;
branches ;
next     9.8;

9.8
date     90.08.29.17.41.07;  author mgbaker;  state Exp;
branches ;
next     9.7;

9.7
date     89.12.12.18.05.13;  author mgbaker;  state Exp;
branches ;
next     9.6;

9.6
date     89.11.27.14.29.09;  author mgbaker;  state Exp;
branches ;
next     9.5;

9.5
date     89.11.07.10.41.12;  author mgbaker;  state Exp;
branches ;
next     9.4;

9.4
date     89.10.30.20.34.56;  author mgbaker;  state Exp;
branches ;
next     9.3;

9.3
date     89.10.23.09.23.52;  author brent;  state Exp;
branches ;
next     9.2;

9.2
date     89.10.12.14.18.26;  author brent;  state Exp;
branches ;
next     9.1;

9.1
date     89.09.15.15.25.44;  author brent;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.11.49;  author douglis;  state Stable;
branches ;
next     8.13;

8.13
date     89.08.28.10.56.27;  author brent;  state Exp;
branches ;
next     8.12;

8.12
date     89.08.21.15.30.30;  author mendel;  state Exp;
branches ;
next     8.11;

8.11
date     89.08.15.18.42.44;  author rab;  state Exp;
branches ;
next     8.10;

8.10
date     89.06.14.22.38.16;  author brent;  state Exp;
branches ;
next     8.9;

8.9
date     89.05.14.13.59.20;  author brent;  state Exp;
branches ;
next     8.8;

8.8
date     89.03.22.13.28.14;  author brent;  state Exp;
branches ;
next     8.7;

8.7
date     89.02.28.14.51.24;  author brent;  state Exp;
branches ;
next     8.6;

8.6
date     89.02.14.10.54.54;  author jhh;  state Exp;
branches ;
next     8.5;

8.5
date     89.02.04.14.09.30;  author brent;  state Exp;
branches ;
next     8.4;

8.4
date     89.01.31.09.44.48;  author brent;  state Exp;
branches ;
next     8.3;

8.3
date     89.01.30.09.21.36;  author brent;  state Exp;
branches ;
next     8.2;

8.2
date     89.01.24.17.05.51;  author brent;  state Exp;
branches ;
next     8.1;

8.1
date     88.12.04.14.50.27;  author ouster;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.16.32;  author douglis;  state Stable;
branches ;
next     7.0;

7.0
date     88.11.07.14.47.25;  author brent;  state Exp;
branches ;
next     6.15;

6.15
date     88.10.22.15.13.20;  author brent;  state Exp;
branches ;
next     6.14;

6.14
date     88.10.14.12.09.53;  author brent;  state Exp;
branches ;
next     6.13;

6.13
date     88.10.14.10.25.52;  author brent;  state Exp;
branches ;
next     6.12;

6.12
date     88.10.13.09.27.42;  author brent;  state Exp;
branches ;
next     6.11;

6.11
date     88.10.04.09.12.06;  author brent;  state Exp;
branches ;
next     6.10;

6.10
date     88.09.30.11.06.19;  author brent;  state Exp;
branches ;
next     6.9;

6.9
date     88.09.23.09.30.08;  author brent;  state Exp;
branches ;
next     6.8;

6.8
date     88.09.23.09.02.41;  author brent;  state Exp;
branches ;
next     6.7;

6.7
date     88.09.15.17.53.45;  author brent;  state Exp;
branches ;
next     6.6;

6.6
date     88.09.07.21.18.12;  author nelson;  state Exp;
branches ;
next     6.5;

6.5
date     88.09.07.16.00.17;  author brent;  state Exp;
branches ;
next     6.4;

6.4
date     88.09.07.14.48.39;  author brent;  state Exp;
branches ;
next     6.3;

6.3
date     88.09.07.12.59.54;  author brent;  state Exp;
branches ;
next     6.2;

6.2
date     88.09.01.17.12.18;  author brent;  state Exp;
branches ;
next     6.1;

6.1
date     88.08.30.11.57.59;  author brent;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.13.38;  author brent;  state Stable;
branches ;
next     1.9;

1.9
date     88.08.05.14.12.34;  author douglis;  state Exp;
branches ;
next     1.8;

1.8
date     88.08.05.13.44.23;  author mlgray;  state Exp;
branches ;
next     1.7;

1.7
date     88.08.03.17.20.38;  author mlgray;  state Exp;
branches ;
next     1.6;

1.6
date     88.06.26.11.37.46;  author ouster;  state Exp;
branches ;
next     1.5;

1.5
date     88.06.14.16.15.50;  author brent;  state Exp;
branches ;
next     1.4;

1.4
date     88.06.10.08.30.18;  author brent;  state Exp;
branches ;
next     1.3;

1.3
date     88.06.04.13.13.21;  author brent;  state Exp;
branches ;
next     1.2;

1.2
date     88.04.12.17.03.21;  author brent;  state Exp;
branches ;
next     1.1;

1.1
date     88.04.11.10.17.59;  author brent;  state Exp;
branches ;
next     ;

9.14.1.1
date     91.10.28.14.31.53;  author kupfer;  state Exp;
branches ;
next     ;


desc
@Main internal definitions file for fs.
@


9.19
log
@Code to handle server-driven recovery.
@
text
@/*
 * fsutil.h --
 *
 *	Declarations of utility routines used by all the file system modules.
 *	This file defines handle types and some sub-structures
 *	that are embedded in various types of handles.  A
 *	"handle" is a data structure that corresponds one-for-one
 *	with a file system object, i.e. a particular file, a device,
 *	a pipe, or a pseudo-device.  A handle is not always one-for-one
 *	with a file system name.  Devices can have more than one name,
 *	and pseudo-devices have many handles associated with one name.
 *	Each handle is identfied by a unique Fs_FileID, and has a standard
 *	header for manipulation by generic routines.
 *
 * Copyright 1989 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 *
 * $Header: /sprite/src/kernel/Cvsroot/kernel/fsutil/fsutil.h,v 9.18 92/10/28 18:11:11 mgbaker Exp $ SPRITE (Berkeley)
 */

#ifndef _FSUTIL
#define _FSUTIL

#include <stdlib.h>

#ifdef KERNEL
#include <fs.h>
#include <fsconsist.h>
#include <hash.h>
#include <proc.h>
#include <vm.h>
#include <rpc.h>
#include <timer.h>
#else
#include <kernel/fs.h>
#include <kernel/fsconsist.h>
#include <kernel/hash.h>
#include <kernel/proc.h>
#include <kernel/vm.h>
#include <kernel/rpc.h>
#include <kernel/timer.h>
#endif
/* constants */
/*
 * Define the types of files that we care about in the kernel, for such
 * things as statistics gathering, write-through policy, etc.  There is not
 * necessarily a one-to-one mapping between these and the types defined
 * in user/fs.h as FS_USER_TYPE_*; for example, FS_USER_TYPE_BINARY and
 * FS_USER_TYPE_OBJECT were mapped into FSUTIL_FILE_TYPE_DERIVED before they
 * were separated into two categories.  It would be possible to flag other
 * derived files (text formatting output, for example) to be in the DERIVED
 * category as well.  
 */
#define FSUTIL_FILE_TYPE_TMP 0
#define FSUTIL_FILE_TYPE_SWAP 1
#define FSUTIL_FILE_TYPE_DERIVED 2
#define FSUTIL_FILE_TYPE_BINARY 3
#define FSUTIL_FILE_TYPE_OTHER 4

/*
 * How often to try rewriting a file.
 */
#define	FSUTIL_WRITE_RETRY_INTERVAL	30

/* data structures */

/*
 * Files or devices with remote I/O servers need to keep some recovery
 * state to handle recovery after their server reboots.
 */

typedef struct Fsutil_RecoveryInfo {
    Sync_Lock		lock;		/* This struct is monitored */
    Sync_Condition	reopenComplete;	/* Notified when the handle has been
					 * re-opened at the I/O server */
    int			flags;		/* defined in fsRecovery.c */
    ReturnStatus	status;		/* Recovery status */
    Fsio_UseCounts		use;		/* Client's copy of use state */
} Fsutil_RecoveryInfo;

/*
 * Statistics for testing recovery.
 */
typedef	struct	Fsutil_FsRecovNamedStats {
    Fs_FileID		fileID;			/* Unique id for object. */
    Boolean		streamHandle;		/* Is this a stream handle? */
    int			mode;			/* Mode of stream. */
    int			refCount;		/* Ref count on IO handle. */
    int			streamRefCount;		/* Ref count on stream. */
    int			numBlocks;		/* Number of blocks in cache. */
    int			numDirtyBlocks;		/* Number dirty cache blocks. */
    char		name[50];		/* Name of object. */
} Fsutil_FsRecovNamedStats;


/*
 * For bulk reopen rpc's -- reopening more than one handle at a time
 * per rpc -- this is the information sent to the server per handle.
 *
 * The reopenParams field is rather bogusly set to a size larger than
 * Fsio_FileReopenParams,
 * just because that's the reopenParam that requires the most space.  The
 * field is really a generic reopenParams for all the stream types.  Yeah,
 * this isn't safe, but mentioning the type names here gives a circular
 * loop in the header files.
 */
typedef struct Fsutil_BulkHandle {
    int				type;		/* Type of handle. */
    int				serverID;	/* For checking on other end. */
    Fs_HandleHeader		*hdrPtr;	/* Ptr to hdr for handle. */
						/* Valid only on client. */
    char			reopenParams[14 * 4];
						/* Reopen info for server. */
} Fsutil_BulkHandle;

/*
 * For bulk reopen rpc's, this is the information returned to the client
 * from the server for each handle.
 *
 * Here too the state field is rather bogusly set to a size larger than that
 * for Fsio_FileState, since the other handle types don't need as much space.
 */
typedef struct Fsutil_BulkReturn {
    ReturnStatus	status;		/* Handle reopen status from server. */
    char		state[18 * 4];	/* Info returned from server. */
} Fsutil_BulkReturn;

/*
 * Operations per stream type to be called for setting up and finishing
 * off handles to be reopened.
 */
typedef struct Fsutil_BulkReopenOps {
    ReturnStatus	(*setup) _ARGS_((Fs_HandleHeader *hdrPtr,
						    Address paramsPtr));
    void		(*finish) _ARGS_((Fs_HandleHeader *hdrPtr,
						    Address statePtr,
						    ReturnStatus status));
} Fsutil_BulkReopenOps;


extern Boolean fsconsist_Debug;
/*
 * Whether or not to flush the cache at regular intervals.
 */

extern Boolean fsutil_ShouldSyncDisks;

extern	int	fsutil_NumRecovering;

/* procedures */
/*
 * Fsutil_StringNCopy
 *
 *	Copy the null terminated string in srcStr to destStr and return the
 *	actual length copied in *strLengthPtr.  At most numBytes will be
 *	copied if the string is not null-terminated.
 */

#define	Fsutil_StringNCopy(numBytes, srcStr, destStr, strLengthPtr) \
    Proc_StringNCopy(numBytes, srcStr, destStr, strLengthPtr)

/*
 * Macros to handle type casting when dealing with handles.
 */
#define Fsutil_HandleFetchType(type, fileIDPtr) \
    (type *)Fsutil_HandleFetch(fileIDPtr)

#define Fsutil_HandleDupType(type, handlePtr) \
    (type *)Fsutil_HandleDup((Fs_HandleHeader *)handlePtr)

#define Fsutil_HandleLock(handlePtr) \
    Fsutil_HandleLockHdr((Fs_HandleHeader *)handlePtr)

#define Fsutil_HandleUnlock(handlePtr) \
    (void)Fsutil_HandleUnlockHdr((Fs_HandleHeader *)handlePtr)

#define Fsutil_HandleRelease(handlePtr, locked) \
    Fsutil_HandleReleaseHdr((Fs_HandleHeader *)handlePtr, locked)

#define Fsutil_HandleRemove(handlePtr) \
    Fsutil_HandleRemoveHdr((Fs_HandleHeader *)handlePtr)

#define Fsutil_HandleName(handlePtr) \
    ((((Fs_HandleHeader *)handlePtr) == (Fs_HandleHeader *)NIL) ? \
	    "(no handle)": \
      ((((Fs_HandleHeader *)handlePtr)->name == (char *)NIL) ? "(no name)" : \
	((Fs_HandleHeader *)handlePtr)->name) )

#define	Fsutil_TimeInSeconds()	(Timer_GetUniversalTimeInSeconds())

#define mnew(type)	(type *)malloc(sizeof(type))

extern void Fsutil_RecoveryInit _ARGS_((Fsutil_RecoveryInfo *recovPtr));
extern void Fsutil_RecoverySyncLockCleanup _ARGS_((
		Fsutil_RecoveryInfo *recovPtr));
extern void Fsutil_WantRecovery _ARGS_((Fs_HandleHeader *hdrPtr));
extern void Fsutil_AttemptRecovery _ARGS_((ClientData data, 
		Proc_CallInfo *callInfoPtr));
extern ReturnStatus Fsutil_WaitForRecovery _ARGS_((Fs_HandleHeader *hdrPtr, 
		ReturnStatus rpcStatus));
extern Boolean Fsutil_RecoveryNeeded _ARGS_((Fsutil_RecoveryInfo *recovPtr));
extern void Fsutil_Reopen _ARGS_((int serverID, ClientData clientData));
extern Boolean Fsutil_RemoteHandleScavenge _ARGS_((Fs_HandleHeader *hdrPtr));
extern void Fsutil_ClientCrashed _ARGS_((int spriteID, ClientData clientData));
extern void Fsutil_ClientCrashed _ARGS_((int spriteID, ClientData clientData));
extern void Fsutil_RemoveClient _ARGS_((int clientID));


/*
 * Wait list routines.  Waiting lists for various conditions are kept
 * hanging of I/O handles.
 */
extern void Fsutil_WaitListInsert _ARGS_((List_Links *list, 
		Sync_RemoteWaiter *waitPtr));
extern void Fsutil_WaitListNotify _ARGS_((List_Links *list));
extern void Fsutil_FastWaitListInsert _ARGS_((List_Links *list, 
		Sync_RemoteWaiter *waitPtr));
extern void Fsutil_FastWaitListNotify _ARGS_((List_Links *list));
extern void Fsutil_WaitListDelete _ARGS_((List_Links *list));
extern void Fsutil_WaitListRemove _ARGS_((List_Links *list, 
		Sync_RemoteWaiter *waitPtr));

/*
 * File handle routines.
 */
extern void Fsutil_HandleInit _ARGS_((int fileHashSize));
extern Boolean Fsutil_HandleInstall _ARGS_((Fs_FileID *fileIDPtr, 
	int size, char *name, Boolean cantBlock, Fs_HandleHeader **hdrPtrPtr));
extern Fs_HandleHeader *Fsutil_HandleFetch _ARGS_((Fs_FileID *fileIDPtr));
extern Fs_HandleHeader *Fsutil_HandleFetchNoWait _ARGS_((Fs_FileID *fileIDPtr,
						Boolean *wouldWaitPtr));
extern Fs_HandleHeader *Fsutil_HandleDup _ARGS_((Fs_HandleHeader *hdrPtr));
extern Fs_HandleHeader *Fsutil_GetNextHandle _ARGS_((Hash_Search *hashSearchPtr));
extern void Fsutil_HandleLockHdr _ARGS_((Fs_HandleHeader *hdrPtr));
extern void Fsutil_HandleIncRefCount _ARGS_((Fs_HandleHeader *hdrPtr,
		int amount));
extern void Fsutil_HandleDecRefCount _ARGS_((Fs_HandleHeader *hdrPtr));
extern void Fsutil_HandleInvalidate _ARGS_((Fs_HandleHeader *hdrPtr));
extern Boolean Fsutil_HandleValid _ARGS_((Fs_HandleHeader *hdrPtr));
extern Boolean Fsutil_HandleUnlockHdr _ARGS_((Fs_HandleHeader *hdrPtr));
extern void Fsutil_HandleReleaseHdr _ARGS_(( Fs_HandleHeader *hdrPtr, 
		Boolean locked));
extern void Fsutil_HandleRemoveHdr _ARGS_((Fs_HandleHeader *hdrPtr));
extern Boolean Fsutil_HandleAttemptRemove _ARGS_((Fs_HandleHeader *hdrPtr));
extern void Fsutil_HandleRemoveInt _ARGS_((Fs_HandleHeader *hdrPtr));
/*
 * Miscellaneous.
 */
extern void Fsutil_FileError _ARGS_((Fs_HandleHeader *hdrPtr, char *string, 
		int status));
extern void Fsutil_PrintStatus _ARGS_((int status));
extern char *Fsutil_FileTypeToString _ARGS_((int type));

extern ReturnStatus Fsutil_DomainInfo _ARGS_((Fs_FileID *fileIDPtr, 
		Fs_DomainInfo *domainInfoPtr));

extern int Fsutil_HandleDescWriteBack _ARGS_((Boolean shutdown, int domain));
extern void Fsutil_SyncProc _ARGS_((ClientData data, 
		Proc_CallInfo *callInfoPtr));
extern void Fsutil_Sync _ARGS_((unsigned int writeBackTime, Boolean shutdown));
extern void Fsutil_SyncStub _ARGS_((ClientData data));
extern ReturnStatus Fsutil_WaitForHost _ARGS_((Fs_Stream *streamPtr, int flags,
		ReturnStatus rpcStatus));

extern ReturnStatus Fsutil_RpcRecovery _ARGS_((ClientData srvToken, 
		int clientID, int command, Rpc_Storage *storagePtr));

extern void Fsutil_HandleScavengeStub _ARGS_((ClientData data));
extern void Fsutil_HandleScavenge _ARGS_((ClientData data, 
		Proc_CallInfo *callInfoPtr));

extern char *Fsutil_GetFileName _ARGS_((Fs_Stream *streamPtr));

extern ReturnStatus Fsutil_FsRecovInfo _ARGS_((int length, 
		Fsutil_FsRecovNamedStats *resultPtr, int *lengthNeededPtr));

extern int Fsutil_TestForHandles _ARGS_((int serverID));

extern void Fsutil_ZeroHandleStats _ARGS_((void));
extern void Fsutil_InitBulkReopenOps _ARGS_((int type,
	Fsutil_BulkReopenOps *reopenOpsPtr));
	
extern ReturnStatus Fsutil_DoServerRecovery _ARGS_((int clientID));
extern void Fsutil_InitBulkReopenTables _ARGS_((void));

#endif /* _FSUTIL */
@


9.18
log
@Fixed an error about a function return type, and got rid of an extremely
noisy message.
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/Cvsroot/kernel/fsutil/fsutil.h,v 9.17 92/10/26 14:33:57 mgbaker Exp $ SPRITE (Berkeley)
d288 3
@


9.17
log
@Support for bulk reopen rpcs.
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/Cvsroot/kernel/fsutil/fsutil.h,v 9.16 92/06/01 15:34:01 kupfer Exp $ SPRITE (Berkeley)
d139 5
a143 4
	    /* Takes hdrPtr and reopenParamsPtr */
    ReturnStatus	(*setup)(/* Fs_HandleHeader *, Address */);
	    /* Takes hdrPtr, fileStatePtr, and status. */	
    ReturnStatus	(*finish)(/* Fs_HandleHeader *, Address, ReturnStatus */);
@


9.16
log
@Add Fsutil_ZeroHandleStats.
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/Cvsroot/kernel/fsutil/fsutil.h,v 9.15 91/09/10 18:24:26 rab Exp $ SPRITE (Berkeley)
d101 44
d285 2
@


9.15
log
@Fixed lint errors and removed tracing.
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 9.14 91/05/30 15:02:46 kupfer Exp Locker: rab $ SPRITE (Berkeley)
d239 3
@


9.14
log
@Change Proc_StringNCopy so that it checks Proc_IsMigratedProcess and
calls Vm_StringNCopy if necessary.
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 9.13 91/01/26 15:35:52 mgbaker Exp Locker: kupfer $ SPRITE (Berkeley)
a153 13
#ifdef SOSP91
/*
 * We are borrowing a couple of bits from the handle to record the read/write
 * status of the stream.  Each stream has a handle so we can get away with
 * this.
 */

#define FSUTIL_RW_FLAGS 	0x300
#define FSUTIL_RW_READ		0x100
#define FSUTIL_RW_WRITE		0x200

#endif

d225 1
a225 4
extern int Fsutil_TraceInit _ARGS_((void));
extern int Fsutil_PrintTraceRecord _ARGS_((ClientData clientData, int event,
		Boolean printHeaderFlag));
extern void Fsutil_PrintTrace _ARGS_((ClientData clientData));
a227 1

@


9.14.1.1
log
@Initial branch for Sprite server.
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 9.14 91/05/30 15:02:46 kupfer Exp $ SPRITE (Berkeley)
@


9.13
log
@Sosp stuff
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 9.12 90/12/06 21:55:26 jhh Exp Locker: mgbaker $ SPRITE (Berkeley)
d121 1
a121 3
    (Proc_IsMigratedProcess() ? \
	    Proc_StringNCopy(numBytes, srcStr, destStr, strLengthPtr) : \
	    Vm_StringNCopy(numBytes, srcStr, destStr, strLengthPtr))
@


9.12
log
@borrowed some bits from the handle for rw flags
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 9.11 90/10/10 16:47:49 kupfer Exp Locker: jhh $ SPRITE (Berkeley)
d65 5
@


9.11
log
@Fsutil_PrintTrace should take a ClientData
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 9.10 90/10/10 11:14:58 mendel Exp Locker: kupfer $ SPRITE (Berkeley)
d150 13
@


9.10
log
@Fixed include files to work with user programs.
Added externs needed by recov module.
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 9.9 90/10/08 13:15:34 mendel Exp Locker: mendel $ SPRITE (Berkeley)
d225 1
a225 1
extern void Fsutil_PrintTrace _ARGS_((int numRecs));
@


9.9
log
@ 
Changed fsutil_TimeInSeconds to be a macro.
Changed include to use <> rather than "" and added function prototypes.
Fixed lint.
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fs.mendel/RCS/fsutil.h,v 1.1 90/01/16 17:12:14 mendel Exp Locker: mendel $ SPRITE (Berkeley)
d32 1
d40 9
a48 1

d104 1
d239 1
a239 1

@


9.8
log
@Added an extern declaration.
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 9.7 89/12/12 18:05:13 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)
d30 1
a30 1
#include "stdlib.h"
d32 7
a38 2
#include "fs.h"
#include "fsio.h"
d70 1
a70 1
    Fsutil_UseCounts		use;		/* Client's copy of use state */
a87 9
/*
 * The current time in seconds and the element used to schedule the update to
 * it.
 */

extern	int			fsutil_TimeInSeconds;
extern	Timer_QueueElement	fsutil_TimeOfDayElement;
extern	int			fsutil_NumRecovering;

d137 2
d141 14
a154 10
extern void		Fsutil_RecoveryInit();
extern void		Fsutil_RecoverySyncLockCleanup();
extern void		Fsutil_WantRecovery();
extern void		Fsutil_AttemptRecovery();
extern ReturnStatus	Fsutil_WaitForRecovery();
extern void		Fsutil_Reopen();
extern Boolean		Fsutil_RecoveryNeeded();
extern Boolean		Fsutil_RemoteHandleScavenge();
extern void		Fsutil_ClientCrashed();
extern void		Fsutil_RemoveClient();
d161 9
a169 6
extern	void		Fsutil_WaitListInsert();
extern	void		Fsutil_WaitListNotify();
extern	void		Fsutil_FastWaitListInsert();
extern	void		Fsutil_FastWaitListNotify();
extern	void		Fsutil_WaitListDelete();
extern	void		Fsutil_WaitListRemove();
d174 20
a193 15
extern	void 	 	Fsutil_HandleInit();
extern	Boolean     	Fsutil_HandleInstall();
extern	Fs_HandleHeader 	*Fsutil_HandleFetch();
extern	Fs_HandleHeader	*Fsutil_HandleDup();
extern  Fs_HandleHeader	*Fsutil_GetNextHandle();
extern	void 	 	Fsutil_HandleLockHdr();
extern	void	 	Fsutil_HandleInvalidate();
extern	Boolean		Fsutil_HandleValid();
extern	void		Fsutil_HandleIncRefCount();
extern	void		Fsutil_HandleDecRefCount();
extern	Boolean	 	Fsutil_HandleUnlockHdr();
extern	void 	 	Fsutil_HandleReleaseHdr();
extern	void 	 	Fsutil_HandleRemoveHdr();
extern	Boolean	 	Fsutil_HandleAttemptRemove();
extern	void 	 	Fsutil_HandleRemoveInt();
d197 28
a224 22
extern	void		Fsutil_FileError();
extern	void		Fsutil_PrintStatus();
extern	void		Fsutil_UpdateTimeOfDay();
extern	void		Fs_ClearStreamID();
extern  int	 	Fsdm_FindFileType();
extern	char *		Fsutil_FileTypeToString();

extern ReturnStatus	Fsutil_DomainInfo();

extern ReturnStatus Fsutil_HandleDescWriteBack();
extern	void	Fsutil_SyncProc();
extern	void	Fsutil_Sync();
extern void Fsutil_SyncStub();
extern ReturnStatus Fsutil_WaitForHost();
extern int Fsutil_TraceInit();
extern ReturnStatus Fsutil_RpcRecovery();
extern int Fsutil_PrintTraceRecord();
extern void Fsutil_PrintTrace();


extern	void		Fsutil_HandleScavengeStub();
extern	void		Fsutil_HandleScavenge();
d226 2
a227 1
extern  char		*Fsutil_GetFileName();
a228 1
extern	ReturnStatus	Fsutil_FsRecovInfo();
@


9.7
log
@Added more stuff for my recovinfo program.
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 9.6 89/11/27 14:29:09 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)
d90 1
@


9.6
log
@Adding new stats syscall command.
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 9.5 89/11/07 10:41:12 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)
d72 8
a79 7
    Fs_FileID		fileID;
    int			mode;
    int			refCount;
    int			streamRefCount;
    int			numBlocks;
    int			numDirtyBlocks;
    char		name[50];
@


9.5
log
@Added Fsutil_FsRecovStats
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 9.4 89/10/30 20:34:56 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)
d71 9
a79 17
typedef	struct	FsutilTypeStats {
    int		num;
    int		refCount;
} FsutilTypeStats;

typedef	struct	Fsutil_FsRecovStats {
    int			recovWanted;
    int			existingHandles;
    int			numHandles;
    int			numHandleRefCounts;
    int			numRead;
    int			numWrite;
    int			numExecute;
    int			numAppend;
    FsutilTypeStats	typeInfo[FSIO_NUM_STREAM_TYPES];
} Fsutil_FsRecovStats;

@


9.4
log
@Adding new stat routine.
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 9.3 89/10/23 09:23:52 brent Exp Locker: mgbaker $ SPRITE (Berkeley)
d67 20
@


9.3
log
@Added #include stdlib.h
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 9.2 89/10/12 14:18:26 brent Exp Locker: brent $ SPRITE (Berkeley)
d197 2
@


9.2
log
@Added extern
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 9.1 89/09/15 15:25:44 brent Exp Locker: brent $ SPRITE (Berkeley)
d30 1
@


9.1
log
@Added extern
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 9.0 89/09/12 15:11:49 douglis Stable Locker: brent $ SPRITE (Berkeley)
d173 1
@


9.0
log
@Changing version numbers.
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 8.13 89/08/28 10:56:27 brent Exp Locker: douglis $ SPRITE (Berkeley)
d131 1
@


8.13
log
@Fixed Fsutil_HandleName so it protects itself against a NIL pointer.
@
text
@d24 1
a24 1
 * $Header: /sprite/src/kernel/fsutil/RCS/fsutil.h,v 8.12 89/08/21 15:30:30 mendel Exp $ SPRITE (Berkeley)
@


8.12
log
@


Break up fs into many modules.    
@
text
@d24 1
a24 1
 * $Header: /sprite/lib/forms/RCS/proto.h,v 1.2 89/01/07 04:12:44 rab Exp $ SPRITE (Berkeley)
d121 4
a124 2
    ((((Fs_HandleHeader *)handlePtr)->name == (char *)NIL) ? "(no name)" : \
	((Fs_HandleHeader *)handlePtr)->name)
@


8.11
log
@Commented #endif labels.
@
text
@d2 1
a2 1
 * fsInt.h --
d4 1
a4 1
 *      Internal types and definitions for the fs module.
a13 2
 *	Note: FsHandleHeader is defined in fs.h because it is
 *	embedded in the Fs_Stream type which is exported.
d15 1
a15 2
 * Copyright 1987 Regents of the University of California
 * All rights reserved.
d24 1
a24 1
 * $Header: /sprite/src/kernel/fs/RCS/fsInt.h,v 8.10 89/06/14 22:38:16 brent Exp Locker: rab $ SPRITE (Berkeley)
d27 8
a34 97
#ifndef _FSINT
#define _FSINT

#include "status.h"
#include "list.h"
#include "timer.h"
#include "stdlib.h"
#include "string.h"

/*
 * Stream Types:
 *	FS_STREAM		Top level type for stream with offset.  Streams
 *				have an ID and are in the handle table to
 *				support migration and shared stream offsets.
 * The remaining types are for I/O handles
 *	FS_LCL_FILE_STREAM	For a regular disk file stored locally.
 *	FS_RMT_FILE_STREAM	For a remote Sprite file.
 *	FS_LCL_DEVICE_STREAM	For a device on this host.
 *	FS_RMT_DEVICE_STREAM	For a remote device.
 *	FS_LCL_PIPE_STREAM	For an anonymous pipe buffered on this host.
 *	FS_RMT_PIPE_STREAM	For an anonymous pipe bufferd on a remote host.
 *				This type arises from process migration.
 *	FS_CONTROL_STREAM	This is the stream used by the server for
 *				a pseudo device to listen for new clients.
 *	FS_SERVER_STREAM	The main state for a pdev request-response
 *				connection.  Refereneced by the server's stream.
 *	FS_LCL_PSEUDO_STREAM	A client's handle on a request-response
 *				connection to a local pdev server.
 *	FS_RMT_PSEUDO_STREAM	As above, but when the pdev server is remote.
 *	FS_PFS_CONTROL_STREAM	Control stream for pseudo-filesystems.
 *	FS_PFS_NAMING_STREAM	The request-response stream used for naming
 *				operations in a pseudo-filesystem.  This
 *				I/O handle is hung off the prefix table.
 *	FS_LCL_PFS_STREAM	A clients' handle on a request-response
 *				connection to a local pfs server.
 *	FS_RMT_PFS_STREAM	As above, but when the pfs server is remote.
 *	FS_RMT_CONTROL_STREAM	Needed only during get/set I/O attributes of
 *				a pseudo-device whose server is remote.
 *	FS_PASSING_STREAM	Used to pass streams from a pseudo-device
 *				server to its client in response to an open.
 *		Internet Protocols
 *	FS_RAW_IP_STREAM	Raw Internet Protocol stream.
 *	FS_UDP_STREAM		UDP protocol stream.
 *	FS_TCP_STREAM		TCP protocol stream.
 *
 * The following streams are not implemented
 *	FS_RMT_NFS_STREAM	NFS access implemented in kernel.
 *	FS_RMT_UNIX_STREAM	For files on the old hybrid unix/sprite server.
 *	FS_LCL_NAMED_PIPE_STREAM Stream to a named pipe whose backing file
 *				is on the local host.
 *	FS_RMT_NAMED_PIPE_STREAM Stream to a named pipe whose backing file
 *				is remote.
 */
#define FS_STREAM			0
#define FS_LCL_FILE_STREAM		1
#define FS_RMT_FILE_STREAM		2
#define FS_LCL_DEVICE_STREAM		3
#define FS_RMT_DEVICE_STREAM		4
#define FS_LCL_PIPE_STREAM		5
#define FS_RMT_PIPE_STREAM		6
#define FS_CONTROL_STREAM		7
#define FS_SERVER_STREAM		8
#define FS_LCL_PSEUDO_STREAM		9
#define FS_RMT_PSEUDO_STREAM		10
#define FS_PFS_CONTROL_STREAM		11
#define FS_PFS_NAMING_STREAM		12
#define FS_LCL_PFS_STREAM		13
#define FS_RMT_PFS_STREAM		14
#define FS_RMT_CONTROL_STREAM		15
#define FS_PASSING_STREAM		16
#define FS_RAW_IP_STREAM		17
#define FS_UDP_STREAM			18
#define FS_TCP_STREAM			19

#define FS_NUM_STREAM_TYPES		20

/*
 * Two arrays are used to map between local and remote types.  This has
 * to happen when shipping Fs_FileIDs between clients and servers.
 */
extern int fsLclToRmtType[];
extern int fsRmtToLclType[];
/*
 * FsMapLclToRmtType(type) - Maps from a local to a remote stream type.
 *	This returns -1 if the input type is out-of-range.
 */
#define FsMapLclToRmtType(localType) \
    ( ((localType) < 0 || (localType) >= FS_NUM_STREAM_TYPES) ? -1 : \
	fsLclToRmtType[localType] )
/*
 * FsMapRmtToLclType(type) - Maps from a remote to a local stream type.
 *	This returns -1 if the input type is out-of-range.
 */
#define FsMapRmtToLclType(remoteType) \
    ( ((remoteType) < 0 || (remoteType) >= FS_NUM_STREAM_TYPES) ? -1 : \
	fsRmtToLclType[remoteType] )

d36 8
a43 2
 * The following structures are subfields of the various I/O handles.
 * First we define a use count structure to handle common book keeping needs.
d45 5
d51 1
a51 26
typedef struct FsUseCounts {
    int		ref;		/* The number of referneces to handle */
    int		write;		/* The number of writers on handle */
    int		exec;		/* The number of executors of handle */
} FsUseCounts;

/*
 * There is a system call to lock a file.  The lock state is kept in
 * the I/O handle on the I/O server so that the lock has network-wide effect.
 */

typedef struct FsLockState {
    int		flags;		/* Bits defined below */
    List_Links	waitList;	/* List of processes to wakeup when the
				 * file gets unlocked */
    int		numShared;	/* Number of shared lock holders */
    List_Links	ownerList;	/* List of processes responsible for locks */
} FsLockState;

/*
 * (The following lock bits are defined in user/fs.h)
 * IOC_LOCK_EXCLUSIVE - only one process may hold an exclusive lock.
 * IOC_LOCK_SHARED    - many processes may hold shared locks as long as
 *	there are no exclusive locks held.  Exclusive locks have to
 *	wait until all shared locks go away.
 */
d58 1
a58 1
typedef struct FsRecoveryInfo {
d64 2
a65 103
    FsUseCounts		use;		/* Client's copy of use state */
} FsRecoveryInfo;


/*
 * Cache information for each file.
 */

typedef struct FsCachedAttributes {
    int		firstByte;	/* Cached version of desc. firstByte */
    int		lastByte;	/* Cached version of desc. lastByte */
    int		accessTime;	/* Cached version of access time */
    int		modifyTime;	/* Cached version of modify time */
    int		createTime;	/* Create time (won't change, but passed
				 * to clients for use in
				 * statistics-gathering) */
    int		userType;	/* user advisory file type, defined in
				 * user/fs.h */
    /*
     * The following fields are needed by Proc_Exec.
     */
    int		permissions;	/* File permissions */
    int		uid;		/* User ID of owner */
    int		gid;		/* Group Owner ID */
} FsCachedAttributes;

typedef struct FsCacheFileInfo {
    List_Links	   links;	   /* Links for the list of dirty files.
				      THIS MUST BE FIRST in the struct */
    List_Links	   dirtyList;	   /* List of dirty blocks for this file.
				    * THIS MUST BE SECOND, see the macro
				    * in fsBlockCache.c that depends on it. */
    List_Links	   blockList;      /* List of blocks for the file */
    List_Links	   indList;	   /* List of indirect blocks for the file */
    Sync_Lock	   lock;	   /* This is used to serialize cache access */
    int		   flags;	   /* Flags to indicate the state of the
				      file, defined in fsBlockCache.h */
    int		   version;	   /* Used to verify validity of cached data */
    struct FsHandleHeader *hdrPtr; /* Back pointer to I/O handle */
    int		   blocksInCache;  /* The number of blocks that this file has
				      in the cache. */
    int		   blocksWritten;  /* The number of blocks that have been
				    * written in a row without requiring a
				    * sync of the servers cache. */
    int		   numDirtyBlocks; /* The number of dirty blocks in the cache.*/
    Sync_Condition noDirtyBlocks;  /* Notified when all write backs done. */
    int		   lastTimeTried;  /* Time that last tried to see if disk was
				    * available for this block. */
    FsCachedAttributes attr;	   /* Local version of descriptor attributes. */
} FsCacheFileInfo;


/*
 * The client use state needed to allow remote client access and to
 * enforce network cache consistency.  A list of state for each client
 * using the file is kept, including the name server itself.  This
 * is used to determine what cache consistency actions to take.
 * There is synchronization over this list between subsequent open
 * operations and the cache consistency actions themselves.
 */

typedef struct FsConsistInfo {
    Sync_Lock	lock;		/* Monitor lock used to synchronize access
				 * to cache consistency routines and the
				 * consistency list. */
    int		flags;		/* Flags defined in fsCacheConsist.c */
    int		lastWriter;	/* Client id of last client to have it open
				   for write caching. */
    int		openTimeStamp;	/* Generated on the server when the file is
				 * opened.  Checked on clients to catch races
				 * between open replies and consistency
				 * messages */
    FsHandleHeader *hdrPtr;	/* Back pointer to handle header needed to
				 * identify the file. */
    List_Links	clientList;	/* List of clients of this file.  Scanned
				 * to determine cachability conflicts */
    List_Links	msgList;	/* List of outstanding cache
				 * consistency messages. */
    Sync_Condition consistDone;	/* Opens block on this condition
				 * until ongoing cache consistency
				 * actions have completed */
    Sync_Condition repliesIn;	/* This condition is notified after
				 * all the clients told to take
				 * consistency actions have replied. */
} FsConsistInfo;

/*
 * The I/O descriptor for remote streams.  This is all that is needed for
 *	remote devices, remote pipes, and named pipes that are not cached
 *	on the local machine.  This structure is also embedded into the
 *	I/O descriptor for remote files.  These stream types share some
 *	common remote procedure stubs, and this structure provides
 *	a common interface.
 *	FS_RMT_DEVICE_STREAM, FS_RMT_PIPE_STREAM, FS_RMT_NAMED_PIPE_STREAM,
 *	FS_RMT_PSEUDO_STREAM, FS_RMT_PFS_STREAM
 */

typedef struct FsRemoteIOHandle {
    FsHandleHeader	hdr;		/* Standard handle header.  The server
					 * ID field in the hdr is used to
					 * forward the I/O operation. */
    FsRecoveryInfo	recovery;	/* For I/O server recovery */
} FsRemoteIOHandle;
a66 1
extern void FsRemoteIOHandleInit();
d74 2
a75 8
extern	int			fsTimeInSeconds;
extern	Timer_QueueElement	fsTimeOfDayElement;

/*
 * These record the maximum transfer size supported by the RPC system.
 */
extern int fsMaxRpcDataSize;
extern int fsMaxRpcParamSize;
d77 1
d82 1
a82 12
extern Boolean fsShouldSyncDisks;

/*
 * TRUE once the file system has been initialized, so we
 * know we can sync the disks safely.
 */
extern  Boolean fsInitialized;

/*
 * The directory that temporary files will live in.
 */
extern	int	fsTmpDirNum;
a83 20
/*
 * Define the types of files that we care about in the kernel, for such
 * things as statistics gathering, write-through policy, etc.  There is not
 * necessarily a one-to-one mapping between these and the types defined
 * in user/fs.h as FS_USER_TYPE_*; for example, FS_USER_TYPE_BINARY and
 * FS_USER_TYPE_OBJECT were mapped into FS_FILE_TYPE_DERIVED before they
 * were separated into two categories.  It would be possible to flag other
 * derived files (text formatting output, for example) to be in the DERIVED
 * category as well.
 */
#define FS_FILE_TYPE_TMP 0
#define FS_FILE_TYPE_SWAP 1
#define FS_FILE_TYPE_DERIVED 2
#define FS_FILE_TYPE_BINARY 3
#define FS_FILE_TYPE_OTHER 4

/*
 * Whether or not to keep information about file I/O by user file type.
 */
extern Boolean fsKeepTypeInfo;
d85 1
d87 1
a87 1
 * Fs_StringNCopy
d94 1
a94 1
#define	Fs_StringNCopy(numBytes, srcStr, destStr, strLengthPtr) \
d100 1
a100 1
 * Writing policies.
d102 17
a118 5
extern	Boolean	fsDelayTmpFiles;
extern	Boolean	fsWriteThrough;
extern	Boolean	fsWriteBackASAP;
extern	Boolean	fsWriteBackOnClose;
extern	Boolean	fsWBOnLastDirtyBlock;
d120 15
d141 6
a146 18
extern	void		FsWaitListInsert();
extern	void		FsWaitListNotify();
extern	void		FsFastWaitListInsert();
extern	void		FsFastWaitListNotify();
extern	void		FsWaitListDelete();
extern	void		FsWaitListRemove();

/*
 * Name lookup routines that handle iteration over the prefix table.
 */
extern	ReturnStatus	FsLookupOperation();
extern	ReturnStatus	FsTwoNameOperation();

/*
 * Cache size control.
 */
extern	void		FsSetMinSize();
extern	void		FsSetMaxSize();
d151 15
a165 47
extern	void 	 	FsHandleInit();
extern	Boolean     	FsHandleInstall();
extern	FsHandleHeader 	*FsHandleFetch();
extern	FsHandleHeader	*FsHandleDup();
extern  FsHandleHeader	*FsGetNextHandle();
extern	void 	 	FsHandleLockHdr();
extern	void	 	FsHandleInvalidate();
extern	Boolean		FsHandleValid();
extern	void		FsHandleIncRefCount();
extern	void		FsHandleDecRefCount();
extern	Boolean	 	FsHandleUnlockHdr();
extern	void 	 	FsHandleReleaseHdr();
extern	void 	 	FsHandleRemoveHdr();
extern	Boolean	 	FsHandleAttemptRemove();
extern	void 	 	FsHandleRemoveInt();

/*
 * Macros to handle type casting when dealing with handles.
 */
#define FsHandleFetchType(type, fileIDPtr) \
    (type *)FsHandleFetch(fileIDPtr)

#define FsHandleDupType(type, handlePtr) \
    (type *)FsHandleDup((FsHandleHeader *)handlePtr)

#define FsHandleLock(handlePtr) \
    FsHandleLockHdr((FsHandleHeader *)handlePtr)

#define FsHandleUnlock(handlePtr) \
    (void)FsHandleUnlockHdr((FsHandleHeader *)handlePtr)

#define FsHandleRelease(handlePtr, locked) \
    FsHandleReleaseHdr((FsHandleHeader *)handlePtr, locked)

#define FsHandleRemove(handlePtr) \
    FsHandleRemoveHdr((FsHandleHeader *)handlePtr)

#define FsHandleName(handlePtr) \
    ((((FsHandleHeader *)handlePtr)->name == (char *)NIL) ? "(no name)" : \
	((FsHandleHeader *)handlePtr)->name)
/*
 * Routines for use by the name component hash table.  They increment the
 * low-level reference count on a handle when it is in the cache.
 */
extern	void	 	FsHandleIncRefCount();
extern	void	 	FsHandleDecRefCount();

d169 21
a189 7
extern	void		FsFileError();
extern	void		FsUpdateTimeOfDay();
extern	void		FsClearStreamID();
extern	void		FsAssignAttrs();
extern  int	 	FsFindFileType();
extern	char *		FsFileTypeToString();
extern  void	 	FsRecordDeletionStats();
d191 1
a191 1
#define mnew(type)	(type *)malloc(sizeof(type))
d193 1
a193 1
#endif /* _FSINT */
@


8.10
log
@Added  FsMapLclToRmtType and FsMapRmtToLclType macros
@
text
@d27 1
a27 1
 * $Header: /sprite/src/kernel/fs/RCS/fsInt.h,v 8.9 89/05/14 13:59:20 brent Exp Locker: brent $ SPRITE (Berkeley)
d81 1
a81 1
 *				is remote. 
d212 1
a212 1
				    * written in a row without requiring a 
d256 1
a256 1
/* 
d301 1
a301 1
extern  Boolean fsInitialized;		
d316 1
a316 1
 * category as well.  
d439 1
a439 1
#endif _FSINT
@


8.9
log
@Updated some comments
@
text
@d27 1
a27 1
 * $Header: /sprite/src/kernel/fs/RCS/fsInt.h,v 8.8 89/03/22 13:28:14 brent Exp $ SPRITE (Berkeley)
d112 14
d365 1
a365 1
 * Name lookup routines.
@


8.8
log
@Added FS_PASSING_STREAM used when passing streams from the
server back to the client.
@
text
@d27 1
a27 1
 * $Header: /sprite/src/kernel/fs/RCS/fsInt.h,v 8.7 89/02/28 14:51:24 brent Exp Locker: brent $ SPRITE (Berkeley)
d122 1
a122 1
} FsUseCounts;			/* 12 BYTES */
d135 1
a135 1
} FsLockState;			/* 24 BYTES */
d157 1
a157 1
} FsRecoveryInfo;			/* 32 BYTES (48 with traced locks) */
d180 1
a180 1
} FsCachedAttributes;		/* 36 BYTES */
d205 1
a205 1
} FsCacheFileInfo;		   /* 108 BYTES  (124 with traced locks)*/
d240 1
a240 1
} FsConsistInfo;		/* 48 BYTES (64 with traced locks) */
d258 1
a258 1
} FsRemoteIOHandle;			/* 72 BYTES (88 with traced locks) */
@


8.7
log
@Added Internet Protocols as stream types.
@
text
@d27 1
a27 1
 * $Header: /sprite/src/kernel/fs/RCS/fsInt.h,v 8.6 89/02/14 10:54:54 jhh Exp Locker: brent $ SPRITE (Berkeley)
d68 2
d99 4
a102 3
#define FS_RAW_IP_STREAM		16
#define FS_UDP_STREAM			17
#define FS_TCP_STREAM			18
d104 1
a104 1
#define FS_NUM_STREAM_TYPES		19
@


8.6
log
@Nuked use of mem.h
@
text
@d27 1
a27 1
 * $Header: /sprite/src/kernel/fs/RCS/fsInt.h,v 8.5 89/02/04 14:09:30 brent Exp $ SPRITE (Berkeley)
d68 4
d97 3
d101 1
a101 6
#define FS_RMT_NFS_STREAM		16
#define FS_LCL_NAMED_PIPE_STREAM	17
#define FS_RMT_NAMED_PIPE_STREAM	18
#define FS_RMT_UNIX_STREAM		19

#define FS_NUM_STREAM_TYPES		20
@


8.5
log
@Updated comments, including sizes of structures
@
text
@d27 1
a27 1
 * $Header: /sprite/src/kernel/fs/RCS/fsInt.h,v 8.4 89/01/31 09:44:48 brent Exp Locker: brent $ SPRITE (Berkeley)
d36 1
a36 1
#include "mem.h"
@


8.4
log
@Changed type of FsHandleRemoveInt
@
text
@d14 1
a14 1
 *	Note: FsHandleHeader is defined here because it is
d27 1
a27 1
 * $Header: /sprite/src/kernel/fs/RCS/fsInt.h,v 8.3 89/01/30 09:21:36 brent Exp Locker: brent $ SPRITE (Berkeley)
d51 1
a51 2
 *	FS_LCL_NAMED_PIPE_STREAM	For a named pipe cached on this host.
 *	FS_RMT_NAMED_PIPE_STREAM	For a named pipe cached elsewhere.
d53 6
a58 7
 *		a pseudo device to listen for new client arrivals and the
 *		departure of old clients.
 *	FS_SERVER_STREAM	This is the stream used by the server for
 *		the request/reponse channel to a particular client.
 *	FS_LCL_PSEUDO_STREAM	This is the client's end of the stream
 *		between it and the server process for the pseudo device.
 *	FS_RMT_PSEUDO_STREAM	As above, but when the server is remote.
d61 5
a65 4
 *				operations in a pseudo-filesystem.
 *	FS_LCL_PFS_STREAM	A pseudo-stream to a pseudo-filesystem.  This
 *		differs only in what happens at open time.  I/O is the same.
 *	FS_RMT_PFS_STREAM	As above, but when the server is remote.
d70 2
a71 2
 *	FS_REMOTE_NFS_STREAM	NFS access implemented in kernel.
 *	FS_REMOTE_UNIX_STREAM	For files on the old hybrid unix/sprite server.
d152 1
a152 1
} FsRecoveryInfo;			/* 32 BYTES */
d200 1
a200 1
} FsCacheFileInfo;		   /* 108 BYTES */
d235 1
a235 2
    List_Links migList;		/* List header for clients migrating the file */
} FsConsistInfo;		/* 56 BYTES */
d244 2
a245 1
 *	FS_RMT_DEVICE_STREAM, FS_RMT_PIPE_STREAM, FS_RMT_NAMED_PIPE_STREAM.
d253 1
a253 1
} FsRemoteIOHandle;			/* 64 BYTES */
@


8.3
log
@Changed scavenge routine to a Boolean
@
text
@d27 1
a27 1
 * $Header: /sprite/src/kernel/fs/RCS/fsInt.h,v 8.2 89/01/24 17:05:51 brent Exp $ SPRITE (Berkeley)
d374 1
a374 1
extern	void 	 	FsHandleAttemptRemove();
@


8.2
log
@Added FS_RMT_CONTROL_STREAM type needed for get/set I/O attrs
of pseudo-devices
@
text
@d27 1
a27 1
 * $Header: /sprite/src/kernel/fs/RCS/fsInt.h,v 8.1 88/12/04 14:50:27 ouster Exp $ SPRITE (Berkeley)
d371 1
a371 1
extern	void 	 	FsHandleUnlockHdr();
d390 1
a390 1
    FsHandleUnlockHdr((FsHandleHeader *)handlePtr)
@


8.1
log
@Don't include byte.h anymore:  not needed.
@
text
@d27 1
a27 1
 * $Header: /sprite/src/kernel/fs/RCS/fsInt.h,v 8.0 88/11/11 18:16:32 douglis Stable Locker: ouster $ SPRITE (Berkeley)
d67 2
d93 1
d95 4
a98 4
#define FS_RMT_NFS_STREAM		15
#define FS_LCL_NAMED_PIPE_STREAM	16
#define FS_RMT_NAMED_PIPE_STREAM	17
#define FS_RMT_UNIX_STREAM		18
d100 1
a100 1
#define FS_NUM_STREAM_TYPES		19
@


8.0
log
@Changing version numbers.
@
text
@d27 1
a27 1
 * $Header: /sprite/src/kernel/fs/RCS/fsInt.h,v 7.0 88/11/07 14:47:25 brent Exp Locker: douglis $ SPRITE (Berkeley)
a36 1
#include "byte.h"
@


7.0
log
@New version for conversion to new C library
@
text
@d27 1
a27 1
 * $Header: /sprite/src/kernel/fs/RCS/fsInt.h,v 6.15 88/10/22 15:13:20 brent Exp Locker: brent $ SPRITE (Berkeley)
@


6.15
log
@Added extern
@
text
@d27 1
a27 1
 * $Header: /sprite/src/kernel/fs/RCS/fsInt.h,v 6.14 88/10/14 12:09:53 brent Exp Locker: brent $ SPRITE (Berkeley)
d416 2
@


6.14
log
@Tidied up comments
@
text
@d27 1
a27 1
 * $Header: fsInt.h,v 6.13 88/10/14 10:25:52 brent Exp $ SPRITE (Berkeley)
d253 2
@


6.13
log
@moved FsUserIDs to user-visible Fs_UserIDs
@
text
@d12 1
a12 1
 *	Each handle is identfied by a unique FsFileID, and has a standard
d14 1
a14 2
 *	Note: some obviously internal things like FsFileID and
 *	FsHandleHeader are defined in fs.h because they are
d27 1
a27 1
 * $Header: fsInt.h,v 6.12 88/10/13 09:27:42 brent Exp $ SPRITE (Berkeley)
d102 1
a102 1
 * to happen when shipping FsFileIDs between clients and servers.
@


6.12
log
@Added stream types for pseudo-streams to pseudo-filesystems.  These
differ in the CltOpen routine (only) from pseudo-streams to pseudo-devices.
Added maps from local type to remote, and vice versa.
@
text
@d28 1
a28 1
 * $Header: fsInt.h,v 6.11 88/10/04 09:12:06 brent Exp $ SPRITE (Berkeley)
a319 12

/*
 *	The FS_NUM_GROUPS constant limits the number of group IDs that
 *	are used even though the proc table supports a variable number.
 */
#define FS_NUM_GROUPS	8

typedef struct FsUserIDs {
    int user;			/* Indicates effective user ID */
    int numGroupIDs;		/* Number of valid entries in groupIDs */
    int group[FS_NUM_GROUPS];	/* The set of groups the user is in */
} FsUserIDs;			/* 40 BYTES */
@


6.11
log
@Added FS_PFS_NAMING_STREAM
@
text
@d28 1
a28 1
 * $Header: fsInt.h,v 6.10 88/09/30 11:06:19 brent Exp $ SPRITE (Berkeley)
d66 4
d91 2
d94 4
a97 4
#define FS_RMT_NFS_STREAM		13
#define FS_LCL_NAMED_PIPE_STREAM	14
#define FS_RMT_NAMED_PIPE_STREAM	15
#define FS_RMT_UNIX_STREAM		16
d99 8
@


6.10
log
@Added FS_PFS_CONTROL_STREAM
@
text
@d28 1
a28 1
 * $Header: fsInt.h,v 6.9 88/09/23 09:30:08 brent Exp $ SPRITE (Berkeley)
d64 2
d86 1
d88 4
a91 4
#define FS_RMT_NFS_STREAM		12
#define FS_LCL_NAMED_PIPE_STREAM	13
#define FS_RMT_NAMED_PIPE_STREAM	14
#define FS_RMT_UNIX_STREAM		15
d269 1
a269 1
 * The directory that temporary file will live in.
@


6.9
log
@Moved recovery flags out to fsRecovery.c
@
text
@d28 1
a28 1
 * $Header: fsInt.h,v 6.8 88/09/23 09:02:41 brent Exp $ SPRITE (Berkeley)
d62 4
a65 1
 *	FS_RMT_PSUEDO_STREAM	As above, but when the server is remote.
d67 4
a70 1
 *	FS_REMOTE_NFS_STREAM	(unimplemented) For NFS access.
d83 6
a88 4
#define FS_LCL_NAMED_PIPE_STREAM	11
#define FS_RMT_NAMED_PIPE_STREAM	12
#define FS_RMT_UNIX_STREAM		13
#define FS_RMT_NFS_STREAM		14
@


6.8
log
@Added a status to recovery state, and updated comments
@
text
@d28 1
a28 1
 * $Header: fsInt.h,v 6.7 88/09/15 17:53:45 brent Exp $ SPRITE (Berkeley)
d124 1
a124 1
    int			flags;		/* WANT_RECOVERY, RECOVERY_FAILED. */
a127 8

/*
 * Values for the recovery info flags field.
 *	FS_WANT_RECOVERY	The handle needs to be re-opened at the server.
 *	FS_RECOVERY_FAILED	The last re-open attempt failed.
 */
#define FS_WANT_RECOVERY	0x1
#define FS_RECOVERY_FAILED	0x2
@


6.7
log
@Added ownership list to FsLockState for crash recovery
@
text
@d4 13
a16 1
 *      Filesystem wide internal types and definitions for the fs module.
d28 1
a28 1
 * $Header: fsInt.h,v 6.6 88/09/07 21:18:12 nelson Exp $ SPRITE (Berkeley)
d125 1
d127 1
a127 1
} FsRecoveryInfo;			/* 28 BYTES */
d184 1
d236 1
a236 1
} FsRemoteIOHandle;			/* 60 BYTES */
@


6.6
log
@Put alternative writing policies into the file system.
@
text
@d16 1
a16 1
 * $Header: fsInt.h,v 6.5 88/09/07 16:00:17 brent Exp $ SPRITE (Berkeley)
d92 2
a93 1
} FsLockState;			/* 16 BYTES */
@


6.5
log
@Fixed FsHandleName macro
@
text
@d16 1
a16 1
 * $Header: fsInt.h,v 6.4 88/09/07 14:48:39 brent Exp $ SPRITE (Berkeley)
d300 9
@


6.4
log
@Added FsHandleName macro
@
text
@d16 1
a16 1
 * $Header: fsInt.h,v 6.3 88/09/07 12:59:54 brent Exp $ SPRITE (Berkeley)
d367 2
a368 2
    ((((FsHandleHeader *)(handlePtr))->name == (char *)NIL) ? "(no name)" :
	((FsHandleHeader *)(handlePtr)->name))
@


6.3
log
@Moved name information from stream to handle for better error messages.
@
text
@d16 1
a16 1
 * $Header: fsInt.h,v 6.2 88/09/01 17:12:18 brent Exp $ SPRITE (Berkeley)
d366 3
@


6.2
log
@Added extern
@
text
@d16 1
a16 1
 * $Header: fsInt.h,v 6.1 88/08/30 11:57:59 brent Exp $ SPRITE (Berkeley)
d169 1
a169 1
} FsCacheFileInfo;		   /* 84 BYTES */
d204 1
a204 1
} FsConsistInfo;		/* 48 BYTES */
d221 1
a221 1
} FsRemoteIOHandle;			/* 56 BYTES */
d299 1
a299 1
} FsUserIDs;
@


6.1
log
@Added extern
@
text
@d16 1
a16 1
 * $Header: fsInt.h,v 6.0 88/08/11 12:13:38 brent Stable $ SPRITE (Berkeley)
d381 1
@


6.0
log
@Changing version numbers.
@
text
@d16 1
a16 1
 * $Header: fsInt.h,v 1.9 88/08/05 14:12:34 douglis Exp $ SPRITE (Berkeley)
d27 1
@


1.9
log
@Changes to support keeping track of file deletions, certain FS system
calls, and large fsStat counters, ported from the old filesystem.
This ci message is generic.
@
text
@d16 1
a16 1
 * $Header: fsInt.h,v 1.7 88/08/03 17:20:38 mlgray Exp $ SPRITE (Berkeley)
@


1.8
log
@Added Fred's changes.
@
text
@d249 4
@


1.7
log
@works on Spur.
@
text
@d16 1
a16 1
 * $Header: fsInt.h,v 1.6 88/06/26 11:37:46 ouster Exp $ SPRITE (Berkeley)
d132 5
d143 1
a143 1
} FsCachedAttributes;		/* 28 BYTES */
d224 1
a224 1
 * The current time in seconds and the element used to schedule the update to 
d249 1
d251 21
d375 2
@


1.6
log
@Don't pass arg to Proc_IsMigratedProcess.
@
text
@d16 1
a16 1
 * $Header: fsInt.h,v 1.5 88/06/14 16:15:50 brent Exp $ SPRITE (Berkeley)
d268 1
@


1.5
log
@Added fsInitialized
@
text
@d16 1
a16 1
 * $Header: fsInt.h,v 1.4 88/06/10 08:30:18 brent Exp $ SPRITE (Berkeley)
d253 1
a253 1
    (Proc_IsMigratedProcess(Sys_GetProcessorNumber()) ? \
@


1.4
log
@Cleaned up old function declarations and removed the
FsHandleAttemptRemove define.
@
text
@d16 1
a16 1
 * $Header: fsInt.h,v 1.3 88/06/04 13:13:21 brent Exp $ SPRITE (Berkeley)
d237 6
@


1.3
log
@Added block list and indirect block list to cache info.
@
text
@d16 1
a16 1
 * $Header: fsInt.h,v 1.2 88/04/12 17:03:21 brent Exp $ SPRITE (Berkeley)
d265 2
a266 1
 * Remote waiting.
a267 1
extern	void		FsWaitListRemove();
d272 2
a273 6
extern	void		FsRemoteWaitInit();
extern	void		FsClientRemoteWakeup();
extern	ReturnStatus	FsClientRemoteWait();
extern	void		FsServerSchedRemoteWait();
extern	void		FsServerRemoteWakeup();
extern	void		FsWakeupListRemove();
d303 1
a303 1
extern	void 	 	FsHandleAttemptRemoveHdr();
a326 3
#define FsHandleAttemptRemove(handlePtr) \
    FsHandleAttemptRemoveHdr((FsHandleHeader *)handlePtr)

d328 2
a329 1
 * Crappy handle routines...
a330 1
extern	ReturnStatus 	FsHandleSameOpen();
d332 1
a332 2
extern	void	 	FsHandleServerReopen();

@


1.2
log
@Changed stream type definitions to re-order things.
@
text
@d16 1
a16 1
 * $Header: fsInt.h,v 1.1 88/04/11 10:17:59 brent Exp $ SPRITE (Berkeley)
d146 2
@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
 * $Header: fsInt.h,v 1.1 88/04/04 10:26:54 brent Exp $ SPRITE (Berkeley)
d60 6
a65 6
#define FS_LCL_NAMED_PIPE_STREAM	7
#define FS_RMT_NAMED_PIPE_STREAM	8
#define FS_CONTROL_STREAM		9
#define FS_SERVER_STREAM		10
#define FS_LCL_PSEUDO_STREAM		11
#define FS_RMT_PSEUDO_STREAM		12
@
