head     9.21;
branch   ;
access   ;
symbols  ds3100:9.20 sun3:9.20 sprited:9.16.1 sun4nw:9.16 symm:9.16 spur:9.16 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.21
date     92.10.28.18.31.39;  author mgbaker;  state Exp;
branches ;
next     9.20;

9.20
date     92.10.28.18.09.24;  author mgbaker;  state Exp;
branches ;
next     9.19;

9.19
date     92.10.26.14.02.08;  author mgbaker;  state Exp;
branches ;
next     9.18;

9.18
date     92.08.10.17.26.59;  author mgbaker;  state Exp;
branches ;
next     9.17;

9.17
date     91.11.05.13.19.19;  author mgbaker;  state Exp;
branches ;
next     9.16;

9.16
date     91.05.06.14.29.27;  author kupfer;  state Exp;
branches 9.16.1.1;
next     9.15;

9.15
date     91.04.08.12.43.40;  author mgbaker;  state Exp;
branches ;
next     9.14;

9.14
date     91.03.30.17.08.51;  author mgbaker;  state Exp;
branches ;
next     9.13;

9.13
date     91.01.07.19.33.38;  author mgbaker;  state Exp;
branches ;
next     9.12;

9.12
date     90.12.10.23.50.09;  author jhh;  state Exp;
branches ;
next     9.11;

9.11
date     90.11.30.16.05.18;  author mgbaker;  state Exp;
branches ;
next     9.10;

9.10
date     90.11.30.15.47.06;  author jhh;  state Exp;
branches ;
next     9.9;

9.9
date     90.10.10.11.08.31;  author mendel;  state Exp;
branches ;
next     9.8;

9.8
date     90.10.08.15.56.08;  author mendel;  state Exp;
branches ;
next     9.7;

9.7
date     90.05.03.19.03.30;  author douglis;  state Exp;
branches ;
next     9.6;

9.6
date     90.02.01.16.16.13;  author brent;  state Exp;
branches ;
next     9.5;

9.5
date     89.11.09.09.10.56;  author brent;  state Exp;
branches ;
next     9.4;

9.4
date     89.11.08.10.19.12;  author brent;  state Exp;
branches ;
next     9.3;

9.3
date     89.10.26.18.43.36;  author brent;  state Exp;
branches ;
next     9.2;

9.2
date     89.10.23.14.09.25;  author brent;  state Exp;
branches ;
next     9.1;

9.1
date     89.10.12.11.56.20;  author brent;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.06.03;  author douglis;  state Stable;
branches ;
next     8.15;

8.15
date     89.08.21.15.26.08;  author mendel;  state Exp;
branches ;
next     8.14;

8.14
date     89.07.01.17.37.14;  author brent;  state Exp;
branches ;
next     8.13;

8.13
date     89.06.15.09.35.01;  author brent;  state Exp;
branches ;
next     8.12;

8.12
date     89.05.30.16.12.03;  author jhh;  state Exp;
branches ;
next     8.11;

8.11
date     89.05.18.16.05.25;  author brent;  state Exp;
branches ;
next     8.10;

8.10
date     89.05.14.15.23.11;  author brent;  state Exp;
branches ;
next     8.9;

8.9
date     89.04.06.17.42.28;  author mgbaker;  state Exp;
branches ;
next     8.8;

8.8
date     89.03.28.09.33.41;  author mgbaker;  state Exp;
branches ;
next     8.7;

8.7
date     89.02.14.10.56.33;  author jhh;  state Exp;
branches ;
next     8.6;

8.6
date     89.02.07.14.22.49;  author brent;  state Exp;
branches ;
next     8.5;

8.5
date     89.01.30.14.03.42;  author brent;  state Exp;
branches ;
next     8.4;

8.4
date     89.01.30.09.23.55;  author brent;  state Exp;
branches ;
next     8.3;

8.3
date     89.01.06.11.20.05;  author jhh;  state Exp;
branches ;
next     8.2;

8.2
date     88.12.21.10.17.39;  author brent;  state Exp;
branches ;
next     8.1;

8.1
date     88.11.17.09.57.12;  author brent;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.22.34;  author douglis;  state Stable;
branches ;
next     7.0;

7.0
date     88.11.11.15.33.14;  author brent;  state Exp;
branches ;
next     6.11;

6.11
date     88.11.04.08.25.51;  author brent;  state Exp;
branches ;
next     6.10;

6.10
date     88.10.22.15.15.28;  author brent;  state Exp;
branches ;
next     6.9;

6.9
date     88.10.20.15.44.23;  author brent;  state Exp;
branches ;
next     6.8;

6.8
date     88.10.14.17.17.38;  author mlgray;  state Exp;
branches ;
next     6.7;

6.7
date     88.10.14.12.17.17;  author brent;  state Exp;
branches ;
next     6.6;

6.6
date     88.10.14.10.40.36;  author douglis;  state Exp;
branches ;
next     6.5;

6.5
date     88.10.13.10.11.11;  author douglis;  state Exp;
branches ;
next     6.4;

6.4
date     88.10.11.15.46.53;  author brent;  state Exp;
branches ;
next     6.3;

6.3
date     88.10.05.12.06.36;  author brent;  state Exp;
branches ;
next     6.2;

6.2
date     88.09.07.16.54.13;  author brent;  state Exp;
branches ;
next     6.1;

6.1
date     88.08.31.12.06.42;  author brent;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.17.45;  author brent;  state Stable;
branches ;
next     1.11;

1.11
date     88.08.04.15.05.59;  author mlgray;  state Exp;
branches ;
next     1.10;

1.10
date     88.08.04.14.56.42;  author brent;  state Exp;
branches ;
next     1.9;

1.9
date     88.06.15.17.14.57;  author brent;  state Exp;
branches ;
next     1.8;

1.8
date     88.06.08.15.01.50;  author brent;  state Exp;
branches ;
next     1.7;

1.7
date     88.06.06.09.39.24;  author brent;  state Exp;
branches ;
next     1.6;

1.6
date     88.06.02.11.36.32;  author brent;  state Exp;
branches ;
next     1.5;

1.5
date     88.05.10.11.22.43;  author brent;  state Exp;
branches ;
next     1.4;

1.4
date     88.05.06.12.39.37;  author brent;  state Exp;
branches ;
next     1.3;

1.3
date     88.05.05.17.35.14;  author brent;  state Exp;
branches ;
next     1.2;

1.2
date     88.04.11.17.41.47;  author brent;  state Exp;
branches ;
next     1.1;

1.1
date     88.04.04.10.42.52;  author brent;  state Exp;
branches ;
next     ;

9.16.1.1
date     91.11.15.16.04.46;  author kupfer;  state Exp;
branches ;
next     ;


desc
@

Stream creation/handling module
@


9.21
log
@Got rid of unused functions are variables.
@
text
@/* 
 * fsioStream.c --
 *
 *	There are two sets of procedures here.  The first manage the stream
 *	as it relates to the handle table; streams are installed in this
 *	table so that handle synchronization primitives can be used, and
 *	so that streams can be found after migration.  The golden rule is
 *	that the stream's refCount reflects local use, and its client list
 *	is used to reflect remote use of a stream.  Thus I/O server's
 *	don't keep references, only client list entries, unless there is
 *	a local user.
 *
 *	The second set of procedures handle the mapping from streams to
 *	user-level stream IDs,	which are indexes into a per-process array
 *	of stream pointers.
 *
 * Copyright (C) 1987 Regents of the University of California
 * All rights reserved.
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fsio/fsioStream.c,v 9.20 92/10/28 18:09:24 mgbaker Exp $ SPRITE (Berkeley)";
#endif not lint


#include <sprite.h>
#include <fs.h>
#include <fsutil.h>
#include <fsio.h>
#include <fsNameOps.h>
#include <fsconsist.h>
#include <fsStat.h>
#include <fsrmt.h>
#include <proc.h>
#include <procMigrate.h>
#include <sync.h>
#include <rpc.h>
#include <fsioRpc.h>
#include <stdio.h>
#include <fsrecov.h>
#include <recov.h>
#include <fsioStreamInt.h>

/*
 * Monitor to synchronize access to the streamCount variable.
 */
static	Sync_Lock	streamLock = Sync_LockInitStatic("Fs:streamLock");
#define LOCKPTR (&streamLock)

static int	streamCount;	/* Used to generate fileIDs for streams*/

/*
 * Forward declarations. 
 */
static ReturnStatus StreamMigCallback _ARGS_((Fsio_MigInfo *migInfoPtr, 
			Boolean *sharedPtr, int *offsetPtr));


/*
 *----------------------------------------------------------------------
 *
 * Fsio_StreamCreate --
 *
 *	Create a new stream for a client.  This chooses a unique minor number
 *	for the	fileID of the stream, installs it in the handle table,
 *	and initializes the client list to contain the client.  This is
 *	used on the file server to remember clients of regular files, and
 *	when creating pipe streams which need client info for migration.
 *
 * Results:
 *	A pointer to a locked stream with 1 reference and one client entry.
 *
 * Side effects:
 *	Install the new stream into the handle table and increment the global
 *	streamCount used to generate IDs.  The stream is returned locked and
 *	with one reference.  Our caller should release this reference if
 *	this is just a shadow stream.
 *
 *----------------------------------------------------------------------
 */
ENTRY Fs_Stream *
Fsio_StreamCreate(serverID, clientID, ioHandlePtr, useFlags, name)
    int			serverID;	/* I/O server for stream */
    int			clientID;	/* Client of the stream */
    Fs_HandleHeader	*ioHandlePtr;	/* I/O handle to attach to stream */
    int			useFlags;	/* Usage flags from Fs_Open call */
    char		*name;		/* Name for error messages */
{
    register Boolean found;
    register Fs_Stream *streamPtr;
    Fs_Stream *newStreamPtr;
    Fs_FileID fileID;

    LOCK_MONITOR;

    /*
     * The streamID is uniquified by using our own host ID for the major
     * field (for network uniqueness), and then choosing minor
     * numbers until we don't have a local conflict.
     */
    fileID.type = FSIO_STREAM;
    fileID.serverID = serverID;
    fileID.major = rpc_SpriteID;

    do {
	fileID.minor = ++streamCount;
	found = Fsutil_HandleInstall(&fileID, sizeof(Fs_Stream), name,
				FALSE, (Fs_HandleHeader **)&newStreamPtr);
	if (found) {
	    /*
	     * Don't want to conflict with existing streams.
	     */
	    Fsutil_HandleRelease(newStreamPtr, TRUE);
	}
    } while (found);

    streamPtr = newStreamPtr;
    streamPtr->offset = 0;
    streamPtr->flags = useFlags;
    streamPtr->ioHandlePtr = ioHandlePtr;
    streamPtr->nameInfoPtr = (Fs_NameInfo *)NIL;
    List_Init(&streamPtr->clientList);
    fs_Stats.object.streams++;

    (void)Fsio_StreamClientOpen(&streamPtr->clientList, clientID, useFlags,
	    (Boolean *)NIL);

    UNLOCK_MONITOR;
    return(streamPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * Fsio_StreamAddClient --
 *
 *	Find a stream and add another client to its client list.
 *
 * Results:
 *	A pointer to a locked stream with 1 reference and one or more 
 *	client entries.  Our call should release this reference if 
 *	this is just a shadow stream.
 *
 * Side effects:
 *	Install the stream into the handle table if it's not there 
 *	already.
 *
 *----------------------------------------------------------------------
 */
Fs_Stream *
Fsio_StreamAddClient(streamIDPtr, clientID, ioHandlePtr, useFlags, name,
	    foundClientPtr, foundStreamPtr)
    Fs_FileID		*streamIDPtr;	/* File ID for stream */
    int			clientID;	/* Client of the stream */
    Fs_HandleHeader	*ioHandlePtr;	/* I/O handle to attach to stream */
    int			useFlags;	/* Usage flags from Fs_Open call */
    char		*name;		/* Name for error messages */
    /*
     * These two boolean pointers may be NIL if their info is not needed.
     */
    Boolean		*foundClientPtr;/* True if Client already existed */
    Boolean		*foundStreamPtr;/* True if stream already existed */
{
    register Boolean found;
    register Fs_Stream *streamPtr;
    Fs_Stream *newStreamPtr;

    found = Fsutil_HandleInstall(streamIDPtr, sizeof(Fs_Stream), name,
			    FALSE, (Fs_HandleHeader **)&newStreamPtr);
    streamPtr = newStreamPtr;
    if (!found) {
	streamPtr->offset = 0;
	streamPtr->flags = useFlags;
	streamPtr->ioHandlePtr = ioHandlePtr;
	streamPtr->nameInfoPtr = (Fs_NameInfo *)NIL;
	List_Init(&streamPtr->clientList);
	fs_Stats.object.streams++;
    } else if (streamPtr->ioHandlePtr == (Fs_HandleHeader *)NIL) {
	streamPtr->ioHandlePtr = ioHandlePtr;
    }
    (void)Fsio_StreamClientOpen(&streamPtr->clientList, clientID, useFlags,
	    foundClientPtr);
    if (foundStreamPtr != (Boolean *)NIL) {
	*foundStreamPtr = found;
    }

    return(streamPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * Fsio_StreamMigClient --
 *
 *	This is called on the I/O server for to move client streams refs.
 *	This makes a callback to the source client to release the reference
 *	to the stream which has (now) moved away.
 *	Note:  this operation locks the stream in order to serialize
 *	with a close comming in from a remote client who has dup'ed the
 *	stream, migrated one reference, and closed the other reference.
 *	Also, on the client the callback and the regular close will both
 *	try to lock the stream in order to release a reference.  Deadlock
 *	cannot occur because if the close happens first there will be two
 *	references at the client.  The close at the client will release
 *	one reference and not try to contact us.  If the callback occurs
 *	first then the close will come through to us, but it will have
 *	to wait until we are done with this migration.
 *
 * Results:
 *	TRUE if the stream is shared across the network after migration.
 *
 * Side effects:
 *	Shifts the client list entry from one host to another.  This does
 *	not add/subtract any references to the stream here on this host.
 *	However, the call-back releases a reference at the source client.
 *
 *----------------------------------------------------------------------
 */
ENTRY void
Fsio_StreamMigClient(migInfoPtr, dstClientID, ioHandlePtr, closeSrcClientPtr)
    Fsio_MigInfo		*migInfoPtr;	/* Encapsulated stream */
    int			dstClientID;	/* New client of the stream */
    Fs_HandleHeader	*ioHandlePtr;	/* I/O handle to attach to stream */
    Boolean		*closeSrcClientPtr;	/* Return - TRUE if the src
					 * client stopped using stream */
{
    register Boolean found;
    register Fs_Stream *streamPtr;
    Fs_Stream *newStreamPtr;
    int newClientStream = migInfoPtr->flags & FS_NEW_STREAM;
    ReturnStatus status;
    Boolean shared;
    int offset;

    /*
     * Get the stream and synchronize with closes from the client.
     * The I/O handle has to be unlocked while the stream is locked
     * in order to prevent deadlock with un-related open/close activity.
     */
    Fsutil_HandleUnlock(ioHandlePtr);
    found = Fsutil_HandleInstall(&migInfoPtr->streamID, sizeof(Fs_Stream),
			 (char *)NIL, FALSE, (Fs_HandleHeader **)&newStreamPtr);
    streamPtr = newStreamPtr;
    if (!found) {
	streamPtr->offset = migInfoPtr->offset;
	streamPtr->flags = migInfoPtr->flags & ~FS_NEW_STREAM;
	streamPtr->ioHandlePtr = ioHandlePtr;
	streamPtr->nameInfoPtr = (Fs_NameInfo *)NIL;
	List_Init(&streamPtr->clientList);
	fs_Stats.object.streams++;
    } else if (streamPtr->ioHandlePtr == (Fs_HandleHeader *)NIL) {
	streamPtr->ioHandlePtr = ioHandlePtr;
    }
    if (migInfoPtr->srcClientID != rpc_SpriteID) {
	/*
	 * Call back to the client to tell it to release its reference
	 * on the stream.  We can't hold the I/O handle locked because
	 * an unrelated close from the source client might have the
	 * I/O handle locked over there.  By unlocking this I/O handle
	 * we allow unrelated closes to complete, while the stream
	 * lock prevents closes of other references to this stream
	 * from coming in and changing the state.
	 */
	status = StreamMigCallback(migInfoPtr, &shared, &offset);
	if ((streamPtr->flags & FS_RMT_SHARED) == 0) {
	    /*
	     * We don't think the stream is being shared so we
	     * grab the offset from the client.
	     */
	    streamPtr->offset = offset;
	    /* XXX Record new offset? */
	}
    } else {
	/*
	 * The stream has been migrated away from us, the I/O server.
	 * Decrement the stream ref count.  The I/O handle references
	 * are left alone here on the I/O server.
	 */
	Fsutil_HandleDecRefCount((Fs_HandleHeader *)streamPtr);
	/* XXX Ignore this since we don't include our own streams in box? */
	shared = (streamPtr->hdr.refCount > 1);
	status = SUCCESS;
    }

    if (status != SUCCESS || !shared) {
	/*
	 * The client doesn't perceive sharing of the stream so
	 * it must be its last reference so we indicate an I/O close is needed.
	 */
	*closeSrcClientPtr = TRUE;
	(void)Fsio_StreamClientClose(&streamPtr->clientList,
				  migInfoPtr->srcClientID);
	/* Remove from recov box if the ioHandle is of right type too. */
	if (recov_Transparent && migInfoPtr->srcClientID != rpc_SpriteID &&
		Fsrecov_ThisType((Fs_HandleHeader *) ioHandlePtr,
		migInfoPtr->srcClientID) &&
		Fsrecov_DeleteHandle((Fs_HandleHeader *) streamPtr,
		migInfoPtr->srcClientID, streamPtr->flags) != SUCCESS) {
	    /* We'll have to do better than this! */
	    panic(
		"Fsio_StreamMigClient: couldn't remove handle from recov box.");
	}
    } else {
	*closeSrcClientPtr = FALSE;
    }
    /*
     * Mark (unmark) the stream if it is being shared.  This is checked
     * in the read and write RPC stubs in order to know what offset to use,
     * the one here in the shadow stream, or the one from the client.
     */
    if (Fsio_StreamClientOpen(&streamPtr->clientList, dstClientID,
			    migInfoPtr->flags, (Boolean *)NIL)) {
	streamPtr->flags |= FS_RMT_SHARED;
    } else {
	streamPtr->flags &= ~FS_RMT_SHARED;
    }
    /* Add handle to recov box if it's of right type. */
    if (recov_Transparent && ioHandlePtr != (Fs_HandleHeader *) NIL &&
	    dstClientID != rpc_SpriteID
	    && Fsrecov_ThisType((Fs_HandleHeader *) ioHandlePtr, dstClientID)) {
	status = Fsrecov_AddHandle((Fs_HandleHeader *) streamPtr,
		&(ioHandlePtr->fileID), dstClientID, streamPtr->flags,
		streamPtr->offset, TRUE);
    } else if (ioHandlePtr == (Fs_HandleHeader *) NIL) {
	panic("Fsio_StreamMigClient: ioHandlePtr was NIL");
    }
    /* We'll have to do better than this! */
    if (recov_Transparent && status != SUCCESS) {
	panic("Fsio_StreamMigClient: couldn't add handle to recov box.");
    }
    migInfoPtr->flags = streamPtr->flags | newClientStream;
    migInfoPtr->offset = streamPtr->offset;
    Fsutil_HandleRelease(streamPtr, TRUE);
    Fsutil_HandleLock(ioHandlePtr);
}

/*
 * Parameters and results for RPC_FS_RELEASE that is called
 * to release a reference to a stream on the source of a migration.
 */
typedef struct {
    Fs_FileID streamID;		/* Stream from which to release a reference */
} FsStreamReleaseParam;

typedef struct {
    Boolean	inUse;		/* TRUE if stream still in use after release */
    int		offset;		/* Offset of stream on source of migration. */
} FsStreamReleaseReplyNew;

/*
 *----------------------------------------------------------------------
 *
 * StreamMigCallback --
 *
 *	Call back to the source client of a migration and tell it to
 *	release its stream.  This invokes Fsio_StreamMigrate on the
 *	remote client
 *
 * Results:
 *	A return status.
 *
 * Side effects:
 *      None.
 *	
 *----------------------------------------------------------------------
 */
static ReturnStatus
StreamMigCallback(migInfoPtr, sharedPtr, offsetPtr)
    Fsio_MigInfo	*migInfoPtr;	/* Encapsulated information */
    Boolean	*sharedPtr;	/* TRUE if stream still used on client */
    int 	*offsetPtr;	/* Offset of stream on client */
{
    register ReturnStatus	status;
    Rpc_Storage 		storage;
    FsStreamReleaseParam	param;
    FsStreamReleaseReplyNew	replyNew;

    param.streamID = migInfoPtr->streamID;
    storage.requestParamPtr = (Address) &param;
    storage.requestParamSize = sizeof(param);
    storage.requestDataPtr = (Address)NIL;
    storage.requestDataSize = 0;

    replyNew.inUse = FALSE;
    storage.replyParamPtr = (Address)&replyNew;
    storage.replyParamSize = sizeof(replyNew);
    storage.replyDataPtr = (Address) NIL;
    storage.replyDataSize = 0;

    status = Rpc_Call(migInfoPtr->srcClientID, RPC_FS_RELEASE_NEW, &storage);
    *sharedPtr = replyNew.inUse;
    *offsetPtr = replyNew.offset;
#ifdef NOTDEF
    if (status != SUCCESS && fsio_MigDebug) {
	printf("StreamMigCallback: status %x from RPC.\n", status);
    }
#endif
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * Fsio_RpcStreamMigCloseNew --
 *
 *	The service stub for FsStreamMigCallback.
 *	This invokes the StreamMigrate routine that releases a reference
 *	to a stream on this host.  Our reply message indicates if
 *	the stream is still in use on this host, and what its offset is.
 *
 * Results:
 *	FS_STALE_HANDLE if handle that if client that is migrating the file
 *	doesn't have the file opened on this machine.  Otherwise return
 *	SUCCESS.  
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Fsio_RpcStreamMigCloseNew(srvToken, clientID, command, storagePtr)
    ClientData srvToken;	/* Handle on server process passed to
				 * Rpc_Reply */
    int clientID;		/* Sprite ID of client host */
    int command;		/* Command identifier */
    Rpc_Storage *storagePtr;    /* The request fields refer to the request
				 * buffers and also indicate the exact amount
				 * of data in the request buffers.  The reply
				 * fields are initialized to NIL for the
				 * pointers and 0 for the lengths.  This can
				 * be passed to Rpc_Reply */
{
    register FsStreamReleaseParam	*paramPtr;
    register Fs_Stream			*streamPtr;
    register ReturnStatus		status;
    register FsStreamReleaseReplyNew	*replyPtr;
    register Rpc_ReplyMem		*replyMemPtr;

    paramPtr = (FsStreamReleaseParam *) storagePtr->requestParamPtr;

    streamPtr = Fsio_StreamClientVerify(&paramPtr->streamID,
				(Fs_HandleHeader *)NIL, rpc_SpriteID);
    if (streamPtr == (Fs_Stream *) NIL) {
	printf("Fsio_RpcStreamMigCloseNew, unknown stream <%d>, client %d\n",
	    paramPtr->streamID.minor, clientID);
	return( (paramPtr->streamID.minor < 0) ? GEN_INVALID_ARG
					       : FS_STALE_HANDLE);
    }
    replyPtr = mnew(FsStreamReleaseReplyNew);
    storagePtr->replyParamPtr = (Address)replyPtr;
    storagePtr->replyParamSize = sizeof(FsStreamReleaseReplyNew);
    storagePtr->replyDataPtr = (Address)NIL;
    storagePtr->replyDataSize = 0;

    status = Fsio_StreamMigCloseNew(streamPtr, &replyPtr->inUse,
				    &replyPtr->offset);

    replyMemPtr = (Rpc_ReplyMem *) malloc(sizeof(Rpc_ReplyMem));
    replyMemPtr->paramPtr = storagePtr->replyParamPtr;
    replyMemPtr->dataPtr = (Address) NIL;
    Rpc_Reply(srvToken, status, storagePtr, Rpc_FreeMem,
		(ClientData)replyMemPtr);
    return(SUCCESS);
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fsio_StreamMigCloseNew --
 *
 *	This is called to release a reference to a stream at the source
 *	of a migration.  We are told to release the reference by the
 *	I/O server during its Fsio_StreamMigClient call.  The timing of our
 *	call ensures that a simultaneous Fs_Close on the stream will be
 *	properly synchronized - the I/O server has to know how many
 *	stream references we, the source of a migration, really have.  It also
 *	keeps the offset consistent in the face of operations after
 *	encapsulation.
 *
 * Results:
 *	SUCCESS unless the stream isn't even found.  This sets *inUsePtr
 *	if the stream is still in use here, otherwise it clears this flag.
 *	This also sets *offsetPtr to the current offset of the stream.
 *
 * Side effects:
 *	This releases one reference to the stream.  If it is the last
 *	reference then this propogates the close down to the I/O handle
 *	by calling the stream-specific release procedure.
 *
 * ----------------------------------------------------------------------------
 *
 */
/*ARGSUSED*/
ReturnStatus
Fsio_StreamMigCloseNew(streamPtr, inUsePtr, offsetPtr)
    Fs_Stream *streamPtr;	/* Stream to release, should be locked */
    Boolean *inUsePtr;		/* TRUE if still in use after release */
    int *offsetPtr;		/* Current stream offset */
{
    /*
     * Set the offset we are passing back to the I/O server.
     */
    *offsetPtr = streamPtr->offset;
    /*
     * Release the reference that has now migrated away.
     */
    Fsutil_HandleDecRefCount((Fs_HandleHeader *)streamPtr);
    /*
     * If this is the last reference then call down to the I/O handle
     * so it can decrement use counts that come from the stream.
     * (Remember there is still one reference from Fsio_RpcStreamMigCloseNew)
     */
    if (streamPtr->hdr.refCount <= 1) {
	(*fsio_StreamOpTable[streamPtr->ioHandlePtr->fileID.type].release)
		(streamPtr->ioHandlePtr, streamPtr->flags);
	/* XXX This is on client here, what should I do about recov box? */
	if (Fsio_StreamClientClose(&streamPtr->clientList, rpc_SpriteID)) {
	    /*
	     * No references, no other clients, nuke it.
	     */
	    *inUsePtr = FALSE;
	    Fsio_StreamDestroy(streamPtr);
	    return(SUCCESS);
	}
    }
    *inUsePtr = TRUE;
    streamPtr->flags |= FS_RMT_SHARED;
    Fsutil_HandleRelease(streamPtr, TRUE);
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * Fsio_StreamCreateID --
 *
 *	Generate a new streamID for a client.  This chooses a unique minor
 *	number for the	fileID of the stream and returns the fileID.  This
 *	is used on the file server to generate IDs for remote device streams.
 *	This ID will be used to create matching streams on the device I/O server
 *	and on the client's machine.
 *
 * Results:
 *	A unique fileID for a stream to the given I/O server.
 *
 * Side effects:
 *	Increment the global streamCount used to generate IDs.
 *
 *----------------------------------------------------------------------
 */
ENTRY void
Fsio_StreamCreateID(serverID, streamIDPtr)
    int			serverID;	/* I/O server for stream */
    Fs_FileID		*streamIDPtr;	/* Return - FileID for the stream */
{
    register Boolean found;
    Fs_Stream *newStreamPtr;
    Fs_FileID fileID;

    LOCK_MONITOR;

    /*
     * The streamID is uniquified by using our own host ID for the major
     * field (for network uniqueness), and then choosing minor
     * numbers until we don't have a local conflict.
     */
    fileID.type = FSIO_STREAM;
    fileID.serverID = serverID;
    fileID.major = rpc_SpriteID;

    do {
	fileID.minor = ++streamCount;
	found = Fsutil_HandleInstall(&fileID, sizeof(Fs_Stream), (char *)NIL,
				FALSE, (Fs_HandleHeader **)&newStreamPtr);
	if (found) {
	    /*
	     * Don't want to conflict with existing streams.
	     */
	    Fsutil_HandleRelease(newStreamPtr, TRUE);
	}
    } while (found);
    *streamIDPtr = newStreamPtr->hdr.fileID;
    Fsutil_HandleRelease(newStreamPtr, TRUE);
    Fsutil_HandleRemove(newStreamPtr);
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * Fsio_StreamCopy --
 *
 *	Duplicate a stream.  This ups the reference count on the stream
 *	so that it won't go away until its last user closes it.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The reference count on the stream is incremented.
 *
 *----------------------------------------------------------------------
 */
ENTRY void
Fsio_StreamCopy(oldStreamPtr, newStreamPtrPtr)
    Fs_Stream *oldStreamPtr;
    Fs_Stream **newStreamPtrPtr;
{
    *newStreamPtrPtr = Fsutil_HandleDupType(Fs_Stream, oldStreamPtr);
    Fsutil_HandleUnlock(oldStreamPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * Fsio_StreamClientVerify --
 *
 *	Verify that the remote client is known for the stream, and return
 *	a locked pointer to the stream's handle.
 *
 * Results:
 *	A pointer to the handle for the stream, or NIL if
 *	the client is bad.
 *
 * Side effects:
 *	The handle is returned locked and with its refCount incremented.
 *	It should be released with Fsutil_HandleRelease(..., TRUE)
 *
 *----------------------------------------------------------------------
 */

Fs_Stream *
Fsio_StreamClientVerify(streamIDPtr, ioHandlePtr, clientID)
    Fs_FileID	*streamIDPtr;		/* Client's stream ID */
    Fs_HandleHeader *ioHandlePtr;	/* I/O handle the client thinks
					 * is attached to the stream */
    int		clientID;		/* Host ID of the client */
{
    register FsioStreamClient *clientPtr;
    register Fs_Stream *streamPtr;
    Boolean found = FALSE;

    streamPtr = Fsutil_HandleFetchType(Fs_Stream, streamIDPtr);
    if (streamPtr != (Fs_Stream *)NIL) {
	LIST_FORALL(&streamPtr->clientList, (List_Links *) clientPtr) {
	    if (clientPtr->clientID == clientID) {
		found = TRUE;
		break;
	    }
	}
	if (!found) {
	    printf("Fsio_StreamClientVerify: no client %d for stream <%d> \"%s\"\n",
		clientID, streamPtr->hdr.fileID.minor,
		Fsutil_HandleName((Fs_HandleHeader *)streamPtr));
	    Fsutil_HandleRelease(streamPtr, TRUE);
	    streamPtr = (Fs_Stream *)NIL;

	} else if (ioHandlePtr != (Fs_HandleHeader *)NIL &&
		   streamPtr->ioHandlePtr != ioHandlePtr) {
	    /*
	     * The client's stream doesn't reference the same handle as we do.
	     * Note that ioHandlePtr is NIL when we are called from
	     * Fsio_RpcStreamMigCloseNew, so we can't make this check in that case.
	     */
	    printf("Fsio_StreamClientVerify ioHandle mismatch client ID %d:\n",
			clientID);
	    if (streamPtr->ioHandlePtr == (Fs_HandleHeader *)NIL) {
		printf("\tStream <%d> \"%s\" my I/O handle NIL\n",
		    Fsutil_HandleName(streamPtr), streamIDPtr->minor);
	    } else {
		printf("\tStream <%d> my handle %s \"%s\" <%d,%d>\n",
		    streamIDPtr->minor,
		    Fsutil_FileTypeToString(streamPtr->ioHandlePtr->fileID.type),
		    Fsutil_HandleName(streamPtr->ioHandlePtr),
		    streamPtr->ioHandlePtr->fileID.major,
		    streamPtr->ioHandlePtr->fileID.minor);
	    }
	    printf("\tClient %d handle %s \"%s\" <%d,%d>\n",
		    clientID, Fsutil_HandleName(ioHandlePtr),
		    Fsutil_FileTypeToString(ioHandlePtr->fileID.type),
		    ioHandlePtr->fileID.major, ioHandlePtr->fileID.minor);
	   Fsutil_HandleRelease(streamPtr, TRUE);
	   streamPtr = (Fs_Stream *)NIL;
	}
    } else {
	printf("No stream <%d> for client %d\n", streamIDPtr->minor, clientID);
    }
    return(streamPtr);
}


/*
 *----------------------------------------------------------------------
 *
 * Fsio_StreamClientKill --
 *
 *	Called when a client is assumed down.  This cleans up the
 *	client list for the stream or removes the stream.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Removes the client list entry for the client.
 *	It removes or unlocks the handle.
 *
 *----------------------------------------------------------------------
 */
void
Fsio_StreamClientKill(hdrPtr, clientID)
    Fs_HandleHeader	*hdrPtr;	/* Stream to clean up */
    int			clientID;	/* Host assumed down */
{
    Fs_Stream		*streamPtr = (Fs_Stream *) hdrPtr;

    if (!Fsio_StreamClientClose(&streamPtr->clientList, clientID)) {
	/*
	 * There were other clients.
	 */
	Fsutil_HandleUnlock(streamPtr);
    } else {
	Fsutil_HandleRemove(streamPtr);
    }
}


/*
 *----------------------------------------------------------------------
 *
 * Fsio_StreamDestroy --
 *
 *	Discard a stream.  This call removes the stream from the handle
 *	table and frees associated storage.  The I/O handle pointer part
 *	should have already been cleaned up by its handler.
 *
 *	If the stream still has associated clients, release the reference
 *	to the stream but don't get rid of the stream, since it is a shadow
 *	stream.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Remove the stream handle from the handle table.
 *
 *----------------------------------------------------------------------
 */

Boolean fsio_StreamDisposeDebug = TRUE;

ENTRY void
Fsio_StreamDestroy(streamPtr)
    register Fs_Stream *streamPtr;
{
    Boolean noClients = TRUE;
    
    if (!List_IsEmpty(&streamPtr->clientList)) {
	noClients = FALSE;
	if (fsio_StreamDisposeDebug) {
	    register FsioStreamClient *clientPtr;

	    LIST_FORALL(&streamPtr->clientList, (List_Links *) clientPtr) {

		printf("Fsio_StreamDestroy, client %d still in list for stream <%d,%d>, refCount %d\n",
			  clientPtr->clientID, streamPtr->hdr.fileID.major,
			  streamPtr->hdr.fileID.minor, streamPtr->hdr.refCount);
		if (streamPtr->ioHandlePtr != (Fs_HandleHeader *)NIL) {
		    printf("\tI/O handle: %s <%d,%d>, refCount %d\n",
			       Fsutil_FileTypeToString(streamPtr->ioHandlePtr->fileID.type),
			       streamPtr->ioHandlePtr->fileID.major,
			       streamPtr->ioHandlePtr->fileID.minor,
			       streamPtr->ioHandlePtr->refCount);
		}
	    }
	}
    } 

    Fsutil_HandleRelease(streamPtr, TRUE);
    if (noClients) {
	if (streamPtr->nameInfoPtr != (Fs_NameInfo *)NIL) {
	    free((Address)streamPtr->nameInfoPtr);
	}
	Fsutil_HandleRemove(streamPtr);
	fs_Stats.object.streams--;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Fsio_StreamScavenge --
 *
 *	Scavenge a stream.  Servers may have no references to a stream handle,
 *	but still have some things on its client list.  Clients have
 *	references, but no client list.  A stream with neither references
 *	or a client list is scavengable.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Removes the stream handle if it has no references and no clients.
 *
 *----------------------------------------------------------------------
 */
#ifdef notdef
Boolean
Fsio_StreamScavenge(hdrPtr)
    Fs_HandleHeader *hdrPtr;
{
    register Fs_Stream *streamPtr = (Fs_Stream *)hdrPtr;

    if (streamPtr->hdr.refCount == 0 &&
	List_IsEmpty(&streamPtr->clientList)) {
	printf( "Fsio_StreamScavenge, removing stream <%d,%d>\n",
		streamPtr->hdr.fileID.serverID,
		streamPtr->hdr.fileID.minor);
	Fsutil_HandleRemove((Fs_HandleHeader *)streamPtr);
	fs_Stats.object.streams--;
	return(TRUE);
    } else {
	Fsutil_HandleUnlock((Fs_HandleHeader *)streamPtr);
	return(FALSE);
    }
}
#endif notdef


typedef struct StreamReopenParams {
    Fs_FileID	streamID;
    Fs_FileID	ioFileID;
    int		useFlags;
    int		offset;
} StreamReopenParams;

/*
 *----------------------------------------------------------------------
 *
 * Fsio_StreamReopen --
 *
 *	This is called initially on the client side from FsHandleReopen.
 *	That instance then does an RPC to the server, which again invokes
 *	this routine.  On the client side we don't do much except pass
 *	over the streamID and the ioHandle fileID so the server can
 *	re-create state.  On the server we have to re-setup the stream,
 *	which is sort of a pain because it must reference the correct
 *	I/O handle.
 *
 * Results:
 *	SUCCESS if the stream was reopened.
 *
 * Side effects:
 *	On the client, do an RPC to the server.
 *	On the server, re-create the stream.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ENTRY ReturnStatus
Fsio_StreamReopen(hdrPtr, clientID, inData, outSizePtr, outDataPtr)
    Fs_HandleHeader	*hdrPtr;	/* Stream's handle header */
    int			clientID;
    ClientData		inData;		/* Non-NIL on the server */
    int			*outSizePtr;	/* Unused. */
    ClientData		*outDataPtr;	/* Unused. */
{
    register Fs_Stream	*streamPtr = (Fs_Stream *)hdrPtr;
    ReturnStatus status;

    if (inData == (ClientData)NIL) {
	/*
	 * Called on the client side.  We contact the server to invoke
	 * this procedure there with some input parameters.
	 */
	StreamReopenParams reopenParams;
	int outSize = 0;

	reopenParams.streamID = hdrPtr->fileID;
	reopenParams.ioFileID = streamPtr->ioHandlePtr->fileID;
	reopenParams.useFlags = streamPtr->flags;
	reopenParams.offset   = streamPtr->offset;
	/*
	 * This is a mousetrap to catch the "poison packets" reported in
	 * log message 30402.  It can be removed once that bug is fixed.
	 * JHH 12/10/90
	 */
	if (reopenParams.ioFileID.type == -1) {
	    panic("About to reopen stream with ioFileID.type set to -1\n");
	}
	status = FsrmtReopen(hdrPtr, sizeof(reopenParams),
		    (Address)&reopenParams, &outSize, (Address)NIL);
    /*
     * This here is the server side fix for the "poison packet" bug.
     * Ignore the request if the type is -1.  Remove this when
     * the bug is fixed.
     * JHH 12/10/90
     */
    } else if (((StreamReopenParams *) inData)->ioFileID.type < 0 ||
	    ((StreamReopenParams *) inData)->ioFileID.type >=
	    FSIO_NUM_STREAM_TYPES) {
	printf("Fsio_StreamReopen: fileID type = 0x%x from client %d\n",
		((StreamReopenParams *) inData)->ioFileID.type, clientID);
	status = FAILURE;
    } else {
	/*
	 * Called on the server side.  We need to first make sure there
	 * is a corresponding I/O handle for the stream, and then we
	 * can set up the stream.
	 */
	StreamReopenParams	*reopenParamsPtr;
	register Fs_FileID	*fileIDPtr;
	Fs_HandleHeader		*ioHandlePtr;
	/* 
	 * Note about shared stream recovery.  We loose the offset of
	 * a shared stream during a crash.  We just print a message and
	 * try to go forward.  Often the shared stream is for a process's
	 * current working directory, so the offset doesn't matter.
	 */
	Boolean			patchOffset = FALSE;

	reopenParamsPtr = (StreamReopenParams *)inData;
	fileIDPtr = &reopenParamsPtr->ioFileID;

	/* If this is a fast restart, we can look at recov box contents. */
	if (recov_Transparent && fsrecov_AlreadyInit) {
	    Fs_FileID       	streamID;
	    Fsrecov_HandleState	recovInfo;

	    streamID = reopenParamsPtr->streamID;
	    printf("Reopen, looking for stream %d.%d.%d.%d\n", streamID.type,
		    streamID.serverID, streamID.major, streamID.minor);
	    /* Get info from recov box. */
	    status = Fsrecov_GetHandle(streamID, clientID, &recovInfo, TRUE);
	    if (status != SUCCESS) {
		panic("Fsio_StreamReopen: couldn't get recov info for handle.");
	    }
	    /* Test it for sameness. */
	    if ((recovInfo.fileID.major != streamID.major) ||
		    (recovInfo.fileID.minor != streamID.minor)) {
		panic("Fsio_StreamReopen: major or minor numbers disagree.");
	    }
	    if ((recovInfo.otherID.major != fileIDPtr->major) ||
		    (recovInfo.otherID.minor != fileIDPtr->minor)) {
		panic(
		"Fsio_StreamReopen: ioHandle major or minor numbers disagree.");
	    }
	    if (((unsigned int) recovInfo.info & FS_RMT_SHARED) !=
		    (reopenParamsPtr->useFlags & FS_RMT_SHARED)) {
		panic("Fsio_StreamReopen: flags disagree.");
	    }
	    /*
	     * Offsets don't seem to matter on pdev control streams.
	     * I assume they only matter if the stream is shared, but
	     * how do I detect that here? XXX
	     */
	    if (recovInfo.otherID.type != FSIO_CONTROL_STREAM &&
		    recovInfo.clientData != reopenParamsPtr->offset) {
		panic("Fsio_StreamReopen: offsets disagree.");
	    }
	    if (fsrecov_FromBox) {
		/* Just use stream info that was recovered from recov box. */
		return SUCCESS;
	    }
	}

	ioHandlePtr = (*fsio_StreamOpTable[fileIDPtr->type].clientVerify)
			(fileIDPtr, clientID, (int *)NIL);
	if (ioHandlePtr != (Fs_HandleHeader *)NIL) {
	    status = SUCCESS;
	    streamPtr = Fsutil_HandleFetchType(Fs_Stream,
			&reopenParamsPtr->streamID);
	    if (streamPtr != (Fs_Stream *)NIL) {
		/*
		 * Verify that we have the stream hooked to the same
		 * I/O handle as the client.  It is possible that we
		 * have reused the client's stream ID with a different
		 * I/O handle, in which case the client loses this stream.
		 */
		if (streamPtr->ioHandlePtr != ioHandlePtr) {
		    printf("Fsio_StreamReopen, I/O handle mismatch, client %d its I/O <%d,%d> my I/O <%d,%d>\n",
			clientID,
			ioHandlePtr->fileID.major,
			ioHandlePtr->fileID.minor,
			streamPtr->ioHandlePtr->fileID.major,
			streamPtr->ioHandlePtr->fileID.minor);
		    status = FAILURE;
		} else if ((reopenParamsPtr->useFlags & FS_RMT_SHARED) &&
			   (streamPtr->flags & FS_RMT_SHARED) == 0) {
		    /*
		     * The client thinks the stream is shared by processes
		     * on a different client, but we lost the shadow stream.
		     * (If we do think the stream is shared things are ok.)
		     */
		    printf("Fsio_StreamReopen, not a shadow stream, client %d stream <%d> client I/O <%d,%d>\n",
			    clientID, streamPtr->hdr.fileID.minor,
			    ioHandlePtr->fileID.major,
			    ioHandlePtr->fileID.minor);
		    status = FAILURE;
		}
		Fsutil_HandleRelease(streamPtr, TRUE);
	    } else if (reopenParamsPtr->useFlags & FS_RMT_SHARED) {
		/*
		 * The client thinks the stream is shared by processes
		 * on a different client, but we don't have a shadow stream.
		 */
		printf("Fsio_StreamReopen, lost shared stream offset? using offset (%d), client %d, I/O <%d,%d> \"%s\"\n",
			reopenParamsPtr->offset, clientID,
			ioHandlePtr->fileID.major,
			ioHandlePtr->fileID.minor,
			Fsutil_HandleName(ioHandlePtr));
		patchOffset = TRUE;
	    }
	    if (status == SUCCESS) {
		streamPtr = Fsio_StreamAddClient(&reopenParamsPtr->streamID,
		    clientID, ioHandlePtr, reopenParamsPtr->useFlags,
		    ioHandlePtr->name, (Boolean *)NIL, (Boolean *)NIL);
		/*
		 * There isn't proper recovery of the offset if the stream
		 * was shared when we crashed, but here we fake it.
		 */
		if (patchOffset) {
		    streamPtr->offset = reopenParamsPtr->offset;
		}
		if (recov_Transparent && status == SUCCESS &&
			!fsrecov_AlreadyInit) {
		    status = Fsrecov_AddHandle((Fs_HandleHeader *) streamPtr,
			    (Fs_FileID *) &(ioHandlePtr->fileID), clientID,
			    streamPtr->flags, streamPtr->offset, TRUE);
		    if (status != SUCCESS) {
			/* We'll have to do better than this! */
			panic("Fsio_StreamReopen: couldn't add stream to box.");
		    }
		}
		Fsutil_HandleRelease(streamPtr, TRUE);
	    }
	    Fsutil_HandleRelease(ioHandlePtr, TRUE);
	} else {
	    printf("Fsio_StreamReopen, %s I/O handle <%d,%d> not found\n",
		Fsutil_FileTypeToString(fileIDPtr->type),
		fileIDPtr->major, fileIDPtr->minor);
	    status = FAILURE;
	}
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FsioSetupStreamReopen --
 *
 *	This is called on the client side from FsHandleReopen.
 *
 * Results:
 *	SUCCESS if the stream is setup to be reopened.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
FsioSetupStreamReopen(hdrPtr, paramsPtr)
    Fs_HandleHeader	*hdrPtr;	/* Stream's handle header */
    Address		paramsPtr;
{
    register Fs_Stream	*streamPtr = (Fs_Stream *)hdrPtr;
    StreamReopenParams	*reopenParamsPtr = (StreamReopenParams *)paramsPtr;

    /*
     * Called on the client side.  We contact the server to invoke
     * this procedure there with some input parameters.
     */

    reopenParamsPtr->streamID = hdrPtr->fileID;
    reopenParamsPtr->ioFileID = streamPtr->ioHandlePtr->fileID;
    reopenParamsPtr->useFlags = streamPtr->flags;
    reopenParamsPtr->offset   = streamPtr->offset;
    /*
     * This is a mousetrap to catch the "poison packets" reported in
     * log message 30402.  It can be removed once that bug is fixed.
     * JHH 12/10/90
     */
    if (reopenParamsPtr->ioFileID.type == -1) {
	panic("About to reopen stream with ioFileID.type set to -1\n");
    }

    return SUCCESS;
}


/*
 *----------------------------------------------------------------------
 *
 * FsioFinishStreamReopen --
 *
 *	This is called on the client side after the bulk reopen.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
void
FsioFinishStreamReopen(hdrPtr, statePtr, status)
    Fs_HandleHeader	*hdrPtr;
    Address		statePtr;
    ReturnStatus	status;
{
    /* Nothing to do for streams. */
    return;
}
@


9.20
log
@Fixed error in return type of function.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fsio/fsioStream.c,v 9.19 92/10/26 14:02:08 mgbaker Exp $ SPRITE (Berkeley)";
a1078 1
    ReturnStatus status;
d1117 1
a1126 29


/*
 * There are stubs for old routines.  When we are sure this has run on clients
 * and the file server for a while, then we can remove these stubs and
 * their corresponding declarations in the .h files.  -- 11/5/91 Mary
 */
ReturnStatus
Fsio_StreamMigClose(streamPtr, inUsePtr)
    Fs_Stream   *streamPtr;
    Boolean     *inUsePtr;
{
    panic("Fsio_StreamMigClose is old and shouldn't be called.");

    return FAILURE;
}

ReturnStatus
Fsio_RpcStreamMigClose(srvToken, clientID, command, storagePtr)
    ClientData  srvToken;
    int         clientID;
    int         command;
    Rpc_Storage *storagePtr;
{
    panic("Fsio_RpcStreamMigClose is old and shouldn't be called.");

    return FAILURE;
}

@


9.19
log
@Support for bulk reopen rpcs.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fsio/fsioStream.c,v 9.18 92/08/10 17:26:59 mgbaker Exp $ SPRITE (Berkeley)";
d49 1
@


9.18
log
@Transparent server recovery now available.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fsio/fsioStream.c,v 9.17 91/11/05 13:19:19 mgbaker Exp $ SPRITE (Berkeley)";
d1055 72
@


9.17
log
@Got rid of unnecessary old routines - Fsio_RpcStreamMigClose and
Fsio_StreamMigClose.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fsio/fsioStream.c,v 9.16 91/05/06 14:29:27 kupfer Exp $ SPRITE (Berkeley)";
d47 2
d277 1
d286 1
d299 10
d323 14
d525 1
d873 2
a874 2
    int			*outSizePtr;	/* Non-NIL on the server */
    ClientData		*outDataPtr;	/* Non-NIL on the server */
d932 43
d1032 10
@


9.16
log
@Remove bogus UNLOCK_MONITOR from Fsio_StreamAddClient, fix header
comments.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsioStream.c,v 9.15 91/04/08 12:43:40 mgbaker Exp Locker: kupfer $ SPRITE (Berkeley)";
d274 1
a274 8
	    if (offset == -1) {
		/*
		 * Temporary case for clients who can't return it.
		 */
		streamPtr->offset = migInfoPtr->offset;
	    } else {
		streamPtr->offset = offset;
	    }
a324 4
} FsStreamReleaseReply;

typedef struct {
    Boolean	inUse;		/* TRUE if stream still in use after release */
a353 1
    FsStreamReleaseReply	reply;
d369 2
a370 21

    if (status == RPC_INVALID_RPC) {

	if (proc_MigDebugLevel > 2) {
	    printf("StreamMigCallback: client %d doesn't support new RPC.\n",
		   migInfoPtr->srcClientID);
	}
	reply.inUse = FALSE;
	storage.replyParamPtr = (Address)&reply;
	storage.replyParamSize = sizeof(reply);
	storage.replyDataPtr = (Address) NIL;
	storage.replyDataSize = 0;

	status = Rpc_Call(migInfoPtr->srcClientID, RPC_FS_RELEASE, &storage);

	*sharedPtr = reply.inUse;
	*offsetPtr = -1;
    } else {
	*sharedPtr = replyNew.inUse;
	*offsetPtr = replyNew.offset;
    }
a377 66

/*
 *----------------------------------------------------------------------
 *
 * Fsio_RpcStreamMigClose --
 *
 *	The service stub for FsStreamMigCallback.
 *	This invokes the StreamMigrate routine that releases a reference
 *	to a stream on this host.  Our reply message indicates if
 *	the stream is still in use on this host.
 *
 * Results:
 *	FS_STALE_HANDLE if handle that if client that is migrating the file
 *	doesn't have the file opened on this machine.  Otherwise return
 *	SUCCESS.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Fsio_RpcStreamMigClose(srvToken, clientID, command, storagePtr)
    ClientData srvToken;	/* Handle on server process passed to
				 * Rpc_Reply */
    int clientID;		/* Sprite ID of client host */
    int command;		/* Command identifier */
    Rpc_Storage *storagePtr;    /* The request fields refer to the request
				 * buffers and also indicate the exact amount
				 * of data in the request buffers.  The reply
				 * fields are initialized to NIL for the
				 * pointers and 0 for the lengths.  This can
				 * be passed to Rpc_Reply */
{
    register FsStreamReleaseParam	*paramPtr;
    register Fs_Stream			*streamPtr;
    register ReturnStatus		status;
    register FsStreamReleaseReply	*replyPtr;
    register Rpc_ReplyMem		*replyMemPtr;

    paramPtr = (FsStreamReleaseParam *) storagePtr->requestParamPtr;

    streamPtr = Fsio_StreamClientVerify(&paramPtr->streamID,
				(Fs_HandleHeader *)NIL, rpc_SpriteID);
    if (streamPtr == (Fs_Stream *) NIL) {
	printf("Fsio_RpcStreamMigClose, unknown stream <%d>, client %d\n",
	    paramPtr->streamID.minor, clientID);
	return( (paramPtr->streamID.minor < 0) ? GEN_INVALID_ARG
					       : FS_STALE_HANDLE);
    }
    replyPtr = mnew(FsStreamReleaseReply);
    storagePtr->replyParamPtr = (Address)replyPtr;
    storagePtr->replyParamSize = sizeof(FsStreamReleaseReply);
    storagePtr->replyDataPtr = (Address)NIL;
    storagePtr->replyDataSize = 0;

    status = Fsio_StreamMigClose(streamPtr, &replyPtr->inUse);

    replyMemPtr = (Rpc_ReplyMem *) malloc(sizeof(Rpc_ReplyMem));
    replyMemPtr->paramPtr = storagePtr->replyParamPtr;
    replyMemPtr->dataPtr = (Address) NIL;
    Rpc_Reply(srvToken, status, storagePtr, Rpc_FreeMem,
		(ClientData)replyMemPtr);
    return(SUCCESS);
}
d425 1
a425 1
	printf("Fsio_RpcStreamMigClose, unknown stream <%d>, client %d\n",
a449 58
 * Fsio_StreamMigClose --
 *
 *	This is called to release a reference to a stream at the source
 *	of a migration.  We are told to release the reference by the
 *	I/O server during its Fsio_StreamMigClient call.  The timing of our
 *	call ensures that a simultaneous Fs_Close on the stream will be
 *	properly synchronized - the I/O server has to know how many
 *	stream references we, the source of a migration, really have.
 *
 * Results:
 *	SUCCESS unless the stream isn't even found.  This sets the FS_RMT_SHARED
 *	flag in the *flagsPtr field if the stream is still in use here,
 *	otherwise it clears this flag.
 *
 * Side effects:
 *	This releases one reference to the stream.  If it is the last
 *	reference then this propogates the close down to the I/O handle
 *	by calling the stream-specific release procedure.
 *
 * ----------------------------------------------------------------------------
 *
 */
/*ARGSUSED*/
ReturnStatus
Fsio_StreamMigClose(streamPtr, inUsePtr)
    Fs_Stream *streamPtr;	/* Stream to release, should be locked */
    Boolean *inUsePtr;		/* TRUE if still in use after release */
{
    /*
     * Release the reference that has now migrated away.
     */
    Fsutil_HandleDecRefCount((Fs_HandleHeader *)streamPtr);
    /*
     * If this is the last reference then call down to the I/O handle
     * so it can decrement use counts that come from the stream.
     * (Remember there is still one reference from Fsio_RpcStreamMigClose)
     */
    if (streamPtr->hdr.refCount <= 1) {
	(*fsio_StreamOpTable[streamPtr->ioHandlePtr->fileID.type].release)
		(streamPtr->ioHandlePtr, streamPtr->flags);
	if (Fsio_StreamClientClose(&streamPtr->clientList, rpc_SpriteID)) {
	    /*
	     * No references, no other clients, nuke it.
	     */
	    *inUsePtr = FALSE;
	    Fsio_StreamDestroy(streamPtr);
	    return(SUCCESS);
	}
    }
    *inUsePtr = TRUE;
    streamPtr->flags |= FS_RMT_SHARED;
    Fsutil_HandleRelease(streamPtr, TRUE);
    return(SUCCESS);
}

/*
 * ----------------------------------------------------------------------------
 *
d492 1
a492 1
     * (Remember there is still one reference from Fsio_RpcStreamMigClose)
d643 1
a643 1
	     * Fsio_RpcStreamMigClose, so we can't make this check in that case.
d973 28
@


9.16.1.1
log
@Initial branch for Sprite server.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fsio/fsioStream.c,v 9.16 91/05/06 14:29:27 kupfer Exp $ SPRITE (Berkeley)";
@


9.15
log
@Fixed negative reference count bug for killing off client streams.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsioStream.c,v 9.14 91/03/30 17:08:51 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d144 3
a146 2
 *	A pointer to a locked stream with 1 reference and one client entry.
 *	Our call should release this reference if this is just a shadow stream.
d149 2
a150 2
 *	Install the new stream into the handle table and increment the global
 *	streamCount used to generate IDs.
d154 1
a154 1
ENTRY Fs_Stream *
d190 1
a190 1
    UNLOCK_MONITOR;
@


9.14
log
@New Fsio_StreamClientKill routine to clean up streams the same way
ioHandles are cleaned up.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsioStream.c,v 9.13 91/01/07 19:33:38 mgbaker Exp $ SPRITE (Berkeley)";
a855 1
	Fsutil_HandleRelease(streamPtr, TRUE);
@


9.13
log
@Attempt to fix zero-length parameters poison reopen packet bug from
server's side.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsioStream.c,v 9.12 90/12/10 23:50:09 jhh Exp Locker: mgbaker $ SPRITE (Berkeley)";
d824 37
@


9.12
log
@poison packet bug fix
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsioStream.c,v 9.11 90/11/30 16:05:18 mgbaker Exp $ SPRITE (Berkeley)";
d996 3
a998 1
    } else if (((StreamReopenParams *) inData)->ioFileID.type < 0) {
@


9.11
log
@Patch to prevent reopen dispatching on fileID types of -1.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsioStream.c,v 9.10 90/11/30 15:47:06 jhh Exp Locker: mgbaker $ SPRITE (Berkeley)";
d980 8
d990 6
@


9.10
log
@marks streams as FS_RMT_SHARED during the Release callback.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsioStream.c,v 9.9 90/10/10 11:08:31 mendel Exp $ SPRITE (Berkeley)";
d982 4
@


9.9
log
@Added include file for RPC stubs.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsioStream.c,v 9.8 90/10/08 15:56:08 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d596 1
d661 1
@


9.8
log
@Changed name to fsioStream.c.
Fixed include files to use <> rather than "".
 function prototyping.  
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs.mendel/RCS/fsStream.c,v 1.1 90/01/16 17:11:45 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d45 1
a45 1

@


9.7
log
@get the stream offset at the time client releases stream.
@
text
@d2 1
a2 1
 * fsStream.c --
d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsStream.c,v 9.6 90/02/01 16:16:13 brent Exp Locker: douglis $ SPRITE (Berkeley)";
d33 12
a44 11
#include "sprite.h"
#include "fs.h"
#include "fsutil.h"
#include "fsio.h"
#include "fsNameOps.h"
#include "fsconsist.h"
#include "fsStat.h"
#include "proc.h"
#include "procMigrate.h"
#include "sync.h"
#include "rpc.h"
d46 2
d59 2
a60 2
static ReturnStatus StreamMigCallback();
static ReturnStatus GrowStreamList();
d112 1
a112 1
				(Fs_HandleHeader **)&newStreamPtr);
d172 1
a172 1
			    (Fs_HandleHeader **)&newStreamPtr);
d224 1
a224 1
    FsMigInfo		*migInfoPtr;	/* Encapsulated stream */
d245 1
a245 1
			    (char *)NIL, (Fs_HandleHeader **)&newStreamPtr);
d357 1
a357 1
    FsMigInfo	*migInfoPtr;	/* Encapsulated information */
d706 1
a706 1
				(Fs_HandleHeader **)&newStreamPtr);
@


9.6
log
@Fixed Fsio_StreamReopen so it detects stream->handle mismatches.
Also put checks in to patch up the shared stream offset,
although this is a patch and the best solution requires
true recovery of the offset with the help of the clients.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsStream.c,v 9.5 89/11/09 09:10:56 brent Exp $ SPRITE (Berkeley)";
d41 1
d200 1
a200 1
 *	stream, migrated one refernece, and closed the other reference.
d233 1
a253 7
    if ((streamPtr->flags & FS_RMT_SHARED) == 0) {
	/*
	 * We don't think the stream is being shared so we
	 * grab the offset from the client.
	 */
	streamPtr->offset = migInfoPtr->offset;
    }
d262 1
a262 1
	 * from comming in and changing the state.
d264 15
a278 1
	status = StreamMigCallback(migInfoPtr, &shared);
d330 5
d353 1
a353 1
StreamMigCallback(migInfoPtr, sharedPtr)
d356 1
d362 1
d370 3
a372 3
    reply.inUse = FALSE;
    storage.replyParamPtr = (Address)&reply;
    storage.replyParamSize = sizeof(reply);
d376 15
a390 1
    status = Rpc_Call(migInfoPtr->srcClientID, RPC_FS_RELEASE, &storage);
d392 6
a397 1
    *sharedPtr = reply.inUse;
d474 67
d572 65
a636 1
     * Release the refernece that has now migrated away.
d640 1
a640 1
     * If this is the last refernece then call down to the I/O handle
@


9.5
log
@Corrected error checking in Fsio_StreamClientVerify so
that it works with Fsio_RpcMigStream.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsStream.c,v 9.4 89/11/08 10:19:12 brent Exp $ SPRITE (Berkeley)";
d820 7
d833 57
a889 8
	    streamPtr = Fsio_StreamAddClient(&reopenParamsPtr->streamID, clientID,
		    ioHandlePtr, reopenParamsPtr->useFlags, ioHandlePtr->name,
		    (Boolean *)NIL, (Boolean *)NIL);
	    /*
	     * BRENT Have to worry about the shared offset here.
	     */
	    streamPtr->offset = reopenParamsPtr->offset;

a890 2
	    Fsutil_HandleRelease(streamPtr, TRUE);
	    status = SUCCESS;
d892 1
a892 2
	    printf(
		"Fsio_StreamReopen, %s I/O handle <%d,%d> not found\n",
@


9.4
log
@Fixed error checking in Fsio_StreamClientVerify
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsStream.c,v 9.3 89/10/26 18:43:36 brent Exp $ SPRITE (Berkeley)";
d417 1
a417 1
	    paramPtr->streamID.major, clientID);
a605 3
    if (ioHandlePtr == (Fs_HandleHeader *)NIL) {
	return((Fs_Stream *)NIL);
    }
d621 7
a627 1
	} else if (streamPtr->ioHandlePtr != ioHandlePtr) {
@


9.3
log
@Fixed broken error check.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsStream.c,v 9.2 89/10/23 14:09:25 brent Exp $ SPRITE (Berkeley)";
d606 3
d618 1
a618 1
	    printf("Fsio_StreamClientVerify, unknown client %d for stream <%d> \"%s\"\n",
d623 2
a624 2
	} else if (ioHandlePtr != (Fs_HandleHeader *)NIL &&
		    streamPtr->ioHandlePtr != ioHandlePtr) {
d627 5
a631 1
	    printf("\tStream <%d> my handle %s \"%s\" <%d,%d>\n",
d637 1
@


9.2
log
@Changed typedef to FsioStreamClient
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsStream.c,v 9.1 89/10/12 11:56:20 brent Exp $ SPRITE (Berkeley)";
d620 2
a621 3
	}
	if (ioHandlePtr != (Fs_HandleHeader *)NIL &&
	    streamPtr->ioHandlePtr != ioHandlePtr) {
@


9.1
log
@Fixed Fsio_StreamClientVerify to verify the I/O handle too
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsStream.c,v 8.15 89/08/21 15:26:08 mendel Exp $ SPRITE (Berkeley)";
d602 1
a602 1
    register FsStreamClientInfo *clientPtr;
d677 1
a677 1
	    register FsStreamClientInfo *clientPtr;
@


9.0
log
@Changing version numbers.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsStream.c,v 8.15 89/08/21 15:26:08 mendel Exp Locker: douglis $ SPRITE (Berkeley)";
d413 2
a414 1
    streamPtr = Fsio_StreamClientVerify(&paramPtr->streamID, rpc_SpriteID);
d418 2
a419 1
	return(FS_STALE_HANDLE);
d596 5
a600 3
Fsio_StreamClientVerify(streamIDPtr, clientID)
    Fs_FileID	*streamIDPtr;	/* Client's stream ID */
    int		clientID;	/* Host ID of the client */
d615 3
a617 3
	    register Fs_HandleHeader *tHdrPtr = streamPtr->ioHandlePtr;
	    printf("Fsio_StreamClientVerify, unknown client %d for stream <%d>\n",
		clientID, tHdrPtr->fileID.minor);
d620 17
@


8.15
log
@Break up fs into many modules.    
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 8.14 89/07/01 17:37:14 brent Exp $ SPRITE (Berkeley)";
@


8.14
log
@Fixed two migration bugs:
1) Wasn't releasing the reference to the stream at the source client.
2) Was polluting the streamPtr->flags with FS_NEW_STREAM.
(Handling of the streamPtr->offset and streamPtr->flags is still ugly!)
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 8.13 89/06/15 09:35:01 brent Exp $ SPRITE (Berkeley)";
d35 4
a38 5
#include "fsInt.h"
#include "fsStream.h"
#include "fsOpTable.h"
#include "fsClient.h"
#include "fsMigrate.h"
d62 1
a62 1
 * FsStreamNewClient --
d82 1
a82 1
FsStreamNewClient(serverID, clientID, ioHandlePtr, useFlags, name)
d85 1
a85 1
    FsHandleHeader	*ioHandlePtr;	/* I/O handle to attach to stream */
d101 1
a101 1
    fileID.type = FS_STREAM;
d107 2
a108 2
	found = FsHandleInstall(&fileID, sizeof(Fs_Stream), name,
				(FsHandleHeader **)&newStreamPtr);
d113 1
a113 1
	    FsHandleRelease(newStreamPtr, TRUE);
d121 1
a121 1
    streamPtr->nameInfoPtr = (FsNameInfo *)NIL;
d123 1
a123 1
    fsStats.object.streams++;
d125 1
a125 1
    (void)FsStreamClientOpen(&streamPtr->clientList, clientID, useFlags,
d135 1
a135 1
 * FsStreamAddClient --
d150 1
a150 1
FsStreamAddClient(streamIDPtr, clientID, ioHandlePtr, useFlags, name,
d154 1
a154 1
    FsHandleHeader	*ioHandlePtr;	/* I/O handle to attach to stream */
d167 2
a168 2
    found = FsHandleInstall(streamIDPtr, sizeof(Fs_Stream), name,
			    (FsHandleHeader **)&newStreamPtr);
d174 1
a174 1
	streamPtr->nameInfoPtr = (FsNameInfo *)NIL;
d176 2
a177 2
	fsStats.object.streams++;
    } else if (streamPtr->ioHandlePtr == (FsHandleHeader *)NIL) {
d180 1
a180 1
    (void)FsStreamClientOpen(&streamPtr->clientList, clientID, useFlags,
d192 1
a192 1
 * FsStreamMigClient --
d219 1
a219 1
FsStreamMigClient(migInfoPtr, dstClientID, ioHandlePtr, closeSrcClientPtr)
d222 1
a222 1
    FsHandleHeader	*ioHandlePtr;	/* I/O handle to attach to stream */
d238 3
a240 3
    FsHandleUnlock(ioHandlePtr);
    found = FsHandleInstall(&migInfoPtr->streamID, sizeof(Fs_Stream),
			    (char *)NIL, (FsHandleHeader **)&newStreamPtr);
d246 1
a246 1
	streamPtr->nameInfoPtr = (FsNameInfo *)NIL;
d248 2
a249 2
	fsStats.object.streams++;
    } else if (streamPtr->ioHandlePtr == (FsHandleHeader *)NIL) {
d276 1
a276 1
	FsHandleDecRefCount((FsHandleHeader *)streamPtr);
d287 1
a287 1
	(void)FsStreamClientClose(&streamPtr->clientList,
d297 1
a297 1
    if (FsStreamClientOpen(&streamPtr->clientList, dstClientID,
d305 2
a306 2
    FsHandleRelease(streamPtr, TRUE);
    FsHandleLock(ioHandlePtr);
d327 1
a327 1
 *	release its stream.  This invokes FsStreamMigrate on the
d363 2
a364 1
    if (status != SUCCESS && fsMigDebug) {
d367 1
d374 1
a374 1
 * Fs_RpcReleaseStream --
d393 1
a393 1
Fs_RpcReleaseStream(srvToken, clientID, command, storagePtr)
d413 1
a413 1
    streamPtr = FsStreamClientVerify(&paramPtr->streamID, rpc_SpriteID);
d415 1
a415 1
	printf("Fs_RpcReleaseStream, unknown stream <%d>, client %d\n",
d425 1
a425 1
    status = FsStreamRelease(streamPtr, &replyPtr->inUse);
d439 1
a439 1
 * FsStreamRelease --
d443 1
a443 1
 *	I/O server during its FsStreamMigClient call.  The timing of our
d463 1
a463 1
FsStreamRelease(streamPtr, inUsePtr)
d470 1
a470 1
    FsHandleDecRefCount((FsHandleHeader *)streamPtr);
d474 1
a474 1
     * (Remember there is still one reference from Fs_RpcReleaseStream)
d477 1
a477 1
	(*fsStreamOpTable[streamPtr->ioHandlePtr->fileID.type].release)
d479 1
a479 1
	if (FsStreamClientClose(&streamPtr->clientList, rpc_SpriteID)) {
d484 1
a484 1
	    FsStreamDispose(streamPtr);
d489 1
a489 1
    FsHandleRelease(streamPtr, TRUE);
d496 1
a496 1
 * FsStreamNewID --
d513 1
a513 1
FsStreamNewID(serverID, streamIDPtr)
d528 1
a528 1
    fileID.type = FS_STREAM;
d534 2
a535 2
	found = FsHandleInstall(&fileID, sizeof(Fs_Stream), (char *)NIL,
				(FsHandleHeader **)&newStreamPtr);
d540 1
a540 1
	    FsHandleRelease(newStreamPtr, TRUE);
d544 2
a545 2
    FsHandleRelease(newStreamPtr, TRUE);
    FsHandleRemove(newStreamPtr);
d552 1
a552 1
 * Fs_StreamCopy --
d566 1
a566 1
Fs_StreamCopy(oldStreamPtr, newStreamPtrPtr)
d570 2
a571 2
    *newStreamPtrPtr = FsHandleDupType(Fs_Stream, oldStreamPtr);
    FsHandleUnlock(oldStreamPtr);
d577 1
a577 1
 * FsStreamClientVerify --
d588 1
a588 1
 *	It should be released with FsHandleRelease(..., TRUE)
d594 1
a594 1
FsStreamClientVerify(streamIDPtr, clientID)
d602 1
a602 1
    streamPtr = FsHandleFetchType(Fs_Stream, streamIDPtr);
d611 2
a612 2
	    register FsHandleHeader *tHdrPtr = streamPtr->ioHandlePtr;
	    printf("FsStreamClientVerify, unknown client %d for stream <%d>\n",
d614 1
a614 1
	    FsHandleRelease(streamPtr, TRUE);
d626 1
a626 1
 * FsStreamDispose --
d645 1
a645 1
Boolean fsStreamDisposeDebug = TRUE;
d648 1
a648 1
FsStreamDispose(streamPtr)
d655 1
a655 1
	if (fsStreamDisposeDebug) {
d660 1
a660 1
		printf("FsStreamDispose, client %d still in list for stream <%d,%d>, refCount %d\n",
d663 1
a663 1
		if (streamPtr->ioHandlePtr != (FsHandleHeader *)NIL) {
d665 1
a665 1
			       FsFileTypeToString(streamPtr->ioHandlePtr->fileID.type),
d674 1
a674 1
    FsHandleRelease(streamPtr, TRUE);
d676 1
a676 1
	if (streamPtr->nameInfoPtr != (FsNameInfo *)NIL) {
d679 2
a680 2
	FsHandleRemove(streamPtr);
	fsStats.object.streams--;
d687 1
a687 1
 * FsStreamScavenge --
d704 2
a705 2
FsStreamScavenge(hdrPtr)
    FsHandleHeader *hdrPtr;
d711 1
a711 1
	printf( "FsStreamScavenge, removing stream <%d,%d>\n",
d714 2
a715 2
	FsHandleRemove((FsHandleHeader *)streamPtr);
	fsStats.object.streams--;
d718 1
a718 1
	FsHandleUnlock((FsHandleHeader *)streamPtr);
d735 1
a735 1
 * FsStreamReopen --
d756 2
a757 2
FsStreamReopen(hdrPtr, clientID, inData, outSizePtr, outDataPtr)
    FsHandleHeader	*hdrPtr;	/* Stream's handle header */
d778 1
a778 1
	status = FsSpriteReopen(hdrPtr, sizeof(reopenParams),
d788 1
a788 1
	FsHandleHeader		*ioHandlePtr;
d792 1
a792 1
	ioHandlePtr = (*fsStreamOpTable[fileIDPtr->type].clientVerify)
d794 2
a795 2
	if (ioHandlePtr != (FsHandleHeader *)NIL) {
	    streamPtr = FsStreamAddClient(&reopenParamsPtr->streamID, clientID,
d803 2
a804 2
	    FsHandleRelease(ioHandlePtr, TRUE);
	    FsHandleRelease(streamPtr, TRUE);
d808 2
a809 2
		"FsStreamReopen, %s I/O handle <%d,%d> not found\n",
		FsFileTypeToString(fileIDPtr->type),
a814 329
}

/*
 *----------------------------------------------------------------------
 *
 * FsGetStreamID --
 *
 *	Save the stream pointer in the process's list of stream pointers
 *	and return its index in that list.  The index is used as
 *	a handle for the stream.  E.g. the user supplies the index
 *	in read and write calls and the kernel gets the file pointer
 *	from the list.
 *
 * Results:
 *	SUCCESS		- the operation was successful.
 *	others		- value returned by GrowStreamList.
 *
 * Side effects:
 *	It adds the input streamPtr to the end of the process's list,
 *	if the list is too short (or empty) it is expanded (or created).
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
FsGetStreamID(streamPtr, streamIDPtr)
    Fs_Stream	*streamPtr;	/* A reference to an open file */
    int		*streamIDPtr;	/* Return value, the index of the file pointer
				 * in the process's list of open files */
{
    register Fs_ProcessState	*fsPtr;		/* From process's proc table 
						 * entry */
    register Fs_Stream		**streamPtrPtr;	/* Process's list of open 
						 * streams. */
    register int		index;		/* Index into list of open 
						 * streams */
    ReturnStatus		status;		/* Error from growing file 
						 * list. */

    fsPtr = (Proc_GetEffectiveProc())->fsPtr;

    if (streamPtr == (Fs_Stream *)0) {
	panic( "Zero valued streamPtr");
    }
    if (fsPtr->streamList == (Fs_Stream **)NIL) {
	/*
	 * Allocate the initial array of file pointers.
	 */
	(void)GrowStreamList(fsPtr, 8);
    }

    /*
     * Take the first free streamID, or add a new one to the end.
     */
    for (index = 0, streamPtrPtr = fsPtr->streamList; 
	 index < fsPtr->numStreams; 
	 index++, streamPtrPtr++) {
	if (*streamPtrPtr == (Fs_Stream *)NIL) {
	    *streamPtrPtr = streamPtr;
	    *streamIDPtr = index;
	    fsPtr->streamFlags[index] = 0;
	    return(SUCCESS);
	}
    }
    /*
     * Ran out of room in the original array, allocate a larger
     * array, copy the contents of the original into the beginning,
     * then pick the first empty slot.
     */
    index = fsPtr->numStreams;
    status = GrowStreamList(fsPtr, fsPtr->numStreams * 2);
    if (status == SUCCESS) {
	*streamIDPtr = index;
	fsPtr->streamList[index] = streamPtr;
	fsPtr->streamFlags[index] = 0;
    }
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * FsClearStreamID --
 *
 *	This invalidates a stream ID.  This is called in conjuction
 *	with Fs_Close to close a stream.  The open stream is identified
 *	by the stream ID which this routine invalidates.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The stream pointer entry in the open stream list is cleared.
 *
 *----------------------------------------------------------------------
 */
void
FsClearStreamID(streamID, procPtr)
    int streamID;		/* Stream ID to invalidate */
    Proc_ControlBlock *procPtr;	/* (Optional) process pointer */
{
    if (procPtr == (Proc_ControlBlock *)NIL) {
	procPtr = Proc_GetEffectiveProc();
    }
    procPtr->fsPtr->streamList[streamID] = (Fs_Stream *)NIL;
}


/*
 *----------------------------------------------------------------------
 *
 * GrowStreamList --
 *
 *	Grow a stream ID list.  This routine
 *	allocates another array of file pointers and copies the
 *	values from the original array into the new one.  It also
 *	initializes the new array elements to NIL.  The original
 *	array of pointers is free'd and the pointer to the
 *	array is reset to point to the new array.
 *
 * Results:
 *	SUCCESS		- the operation was successful.
 *	(One could limit the number of streams here, but we don't.)
 *
 * Side effects:
 *	Grows the stream list and the associated array of flag bytes.
 *	The number of streams in the file system state is updated.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
GrowStreamList(fsPtr, newLength)
    Fs_ProcessState *fsPtr;	/* The file system state */
    int newLength;		/* The length of the new array */
{
    register int index;
    register Fs_Stream **streamList;
    register char *streamFlags;

    streamList = (Fs_Stream **)malloc(newLength * sizeof(Fs_Stream *));
    streamFlags = (char *)malloc(newLength * sizeof(char));

    if (fsPtr->numStreams > 0) {
	bcopy((Address)fsPtr->streamList, (Address)streamList, sizeof(Fs_Stream *) * fsPtr->numStreams);
	bcopy((Address)fsPtr->streamFlags, (Address)streamFlags, sizeof(char) * fsPtr->numStreams);

	free((Address)fsPtr->streamList);
	free((Address)fsPtr->streamFlags);
    
	for (index=0 ; index < fsPtr->numStreams ; index++) {
	    if ((int)streamList[index] != NIL &&
		(unsigned int)streamList[index] < 1024) {
		panic( "GrowStreamList copied bad streamPtr, %x\n",
				       streamList[index]);
	    }
	}
    }

    fsPtr->streamList = streamList;
    fsPtr->streamFlags =  streamFlags;

    for (index=fsPtr->numStreams ; index < newLength ; index++) {
	fsPtr->streamList[index] = (Fs_Stream *)NIL;
	fsPtr->streamFlags[index] = 0;
    }
    fsPtr->numStreams = newLength;
    return(SUCCESS);
}


/*
 *----------------------------------------------------------------------
 *
 * FsGetStreamPtr --
 *
 *	This converts a users stream id into a pointer to the
 *	stream structure for the open stream.  The stream id is
 *	an index into a per-process open stream list.  This does
 *	bounds checking the open stream list and returns the
 *	indexed stream pointer.
 *
 * Results:
 *	SUCCESS		- the operation was successful.
 *	FS_INVALID_ARG	- the stream ID was out of range or the streamPtr
 *			  for streamID was NIL.
 *
 * Side effects:
 *	*streamPtrPtr is set to reference the stream structure indexed
 *	by the streamID.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
FsGetStreamPtr(procPtr, streamID, streamPtrPtr)
    Proc_ControlBlock	*procPtr;	/* The owner of an open file list */
    int			streamID;	/* A possible index into the list */
    Fs_Stream		**streamPtrPtr;	/* The pointer from the list*/
{
    if (streamID < 0 || streamID >= procPtr->fsPtr->numStreams) {
	return(FS_INVALID_ARG);
    } else {
	register Fs_Stream *streamPtr;

	streamPtr = procPtr->fsPtr->streamList[streamID];
	if (streamPtr == (Fs_Stream *)NIL) {
	    return(FS_INVALID_ARG);
	} else if ((unsigned int)streamPtr < 1024) {
	    /*
	     * There was a time when control stream pointers were not
	     * being passed right, or being passed a second time after
	     * already being converted to a streamID, which resulted in
	     * small integers being kept in the stream list instead of
	     * valid stream pointers.  Not sure if that still happens.
	     */
	    panic( "Stream Ptr # %d was an int %d!\n",
				streamID, streamPtr);
	    return(FS_INVALID_ARG);
	} else {
	    *streamPtrPtr = streamPtr;
	    return(SUCCESS);
	}
    }
}


/*
 *----------------------------------------------------------------------
 *
 * Fs_GetNewID --
 *
 *	This gets a new stream ID that refers to the same open file
 *	as the first argument.  After the call the new stream ID will
 *	be equivalent to the old one - system calls that take a stream
 *	ID could be passed either stream ID.  There are two uses of this
 *	routine.  If it doesn't matter what the new stream ID is then
 *	the second argument should point to FS_ANYID.  If the new stream
 *	ID should have a value then the second argument should point
 *	to that value.  If that value was a valid stream ID then the
 *	stream is first closed.
 *
 * Results:
 *	SUCCESS		- the operation was successful.
 *	FS_INVALID_ARG	- newStreamIDPtr was bad or had a bad value.
 *	other		- value returned by FsGrowList.
 *
 * Side effects:
 *	The second argument gets instantiated to a new stream ID.
 *	If the second argument refered to a valid stream ID on entry
 *	(as opposed to pointing to FS_ANYID) then that stream is first closed.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
Fs_GetNewID(streamID, newStreamIDPtr)
    int streamID;
    int *newStreamIDPtr;
{
    register ReturnStatus 	status;
    Fs_Stream 			*streamPtr;
    Proc_ControlBlock		*procPtr;
    register Fs_ProcessState	*fsPtr;

    if (newStreamIDPtr == (int *)NIL) {
	return(FS_INVALID_ARG);
    }
    procPtr = Proc_GetEffectiveProc();
    status = FsGetStreamPtr(procPtr, streamID, &streamPtr);
    if (status != SUCCESS) {
	return(status);
    }
    fsPtr = procPtr->fsPtr;
    if (*newStreamIDPtr == FS_ANYID) {
	Fs_Stream		*newStreamPtr;

	Fs_StreamCopy(streamPtr, &newStreamPtr);
	status = FsGetStreamID(newStreamPtr, newStreamIDPtr);
	if (status != SUCCESS) {
	    (void)Fs_Close(newStreamPtr);
	}
	return(status);
    } else {
	if (*newStreamIDPtr == streamID) {
	    /*
	     * Probably a user error.  We just return without fiddling
	     * with reference counts.
	     */
	    return(SUCCESS);
	} else {
	    /*
	     * Trying to get a specific stream ID.
	     */
	    register int newStreamID;

	    newStreamID = *newStreamIDPtr;
	    if (newStreamID < 0) {
		return(FS_INVALID_ARG);
	    }
	    if (newStreamID >= fsPtr->numStreams) {
		register int maxID;
		/*
		 * Need to grow the file list to accomodate this stream ID.
		 * We do a sanity check on the value of stream ID so
		 * we don't nuke ourselves with a huge array.
		 */
		maxID = 2 * fsPtr->numStreams;
		maxID = (maxID<128 ? 128 : maxID);
		if (newStreamID > maxID) {
		    return(FS_NEW_ID_TOO_BIG);
		}
		status = GrowStreamList(fsPtr, newStreamID + 1 );
		if (status != SUCCESS) {
		    return(status);
		}
	    } else {
		/*
		 * Check to see if *newStreamIDPtr is a valid (Fs_Stream *)
		 * and close it if it is.
		 */
		register Fs_Stream *oldFilePtr;

		oldFilePtr = fsPtr->streamList[newStreamID];
		if (oldFilePtr != (Fs_Stream *)NIL) {
		    (void)Fs_Close(oldFilePtr);
		}
	    }
	    Fs_StreamCopy(streamPtr, &fsPtr->streamList[newStreamID]);
	    return(SUCCESS);
	}
    }
@


8.13
log
@Added a new RPC RPC_FS_STREAM_RELEASE so we don't have to
overload RPC_FS_MIGRATE with the function of releasing
a reference to a stream at the source client.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 8.12 89/05/30 16:12:03 jhh Exp $ SPRITE (Berkeley)";
d245 1
a245 1
	streamPtr->flags = migInfoPtr->flags;
d467 4
d473 1
a473 3
     * (The funky check against 2 is because there have been two fetches
     * of the stream.  One by Fs_RpcReleaseStream, plus there is the
     * original ref from the stream that has migrated.  Thus 2 is the minimum.)
d475 1
a475 1
    if (streamPtr->hdr.refCount <= 2) {
@


8.12
log
@Removed call to Sync_LockRegister
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 8.11 89/05/18 16:05:25 brent Exp Locker: jhh $ SPRITE (Berkeley)";
d311 12
d345 3
a347 3
    Rpc_Storage 	storage;
    FsMigInfo		migInfo;
    FsMigParam		migParam;
d349 3
a351 8
    /*
     * We want to call FsStreamMigrate, so we change the ioFileID to
     * the streamID before passing it.
     */
    migInfo = *migInfoPtr;
    migInfo.ioFileID = migInfoPtr->streamID;
    storage.requestParamPtr = (Address) &migInfo;
    storage.requestParamSize = sizeof(FsMigInfo);
d355 3
a357 2
    storage.replyParamPtr = (Address)&migParam;
    storage.replyParamSize = sizeof(FsMigParam);
d361 1
a361 4
    status = Rpc_Call(migInfoPtr->srcClientID, RPC_FS_MIGRATE, &storage);

    if (status == SUCCESS) {
	FsMigrateReply	*migReplyPtr;
d363 3
a365 6
	migReplyPtr = &(migParam.migReply);
	*sharedPtr = migReplyPtr->flags & FS_RMT_SHARED;
    } else if (fsMigDebug) {
	printf(
	  "StreamMigCallback: status %x from remote migrate routine.\n",
		  status);
d371 65
d438 1
a438 1
 * FsStreamMigrate --
a446 4
 *	FIXME: this uses FS_RPC_MIGRATE instead of a new RPC.  This requires
 *	a patch in the RPC stub for FS_RPC_MIGRATE, and a patch here because
 *	there are more references to the stream that originally thought.
 *
d454 2
a455 1
 *	reference then this propogates the close down to the I/O handle.
d462 3
a464 7
FsStreamMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr, sizePtr, dataPtr)
    FsMigInfo	*migInfoPtr;	/* Migration state */
    int		dstClientID;	/* ID of target client */
    int		*flagsPtr;	/* In/Out Stream usage flags */
    int		*offsetPtr;	/* Return - new stream offset (not needed) */
    int		*sizePtr;	/* Return - 0 */
    Address	*dataPtr;	/* Return - NIL */
a465 21
    register Fs_Stream *streamPtr;

    *sizePtr = 0;
    *dataPtr = (Address)NIL;
    /*
     * Fetch the stream but don't increment the refernece count while
     * keeping it locked.
     */
    streamPtr = FsHandleFetchType(Fs_Stream, &migInfoPtr->streamID);
    if (streamPtr == (Fs_Stream *)NIL) {
	printf(
		"FsStreamMigrate, no stream <%d> for %s handle <%d,%d>\n",
		migInfoPtr->streamID.minor,
		FsFileTypeToString(migInfoPtr->ioFileID.type),
		migInfoPtr->ioFileID.major, migInfoPtr->ioFileID.minor);
	return(FS_FILE_NOT_FOUND);
    }
    FsHandleDecRefCount((FsHandleHeader *)streamPtr);

    *flagsPtr = streamPtr->flags;
    *offsetPtr = streamPtr->offset;
d470 2
a471 4
     * of the stream.  One by Fs_RpcStartMigration, and one by use.  We
     * decrement our reference above, but there is still an extra from
     * Fs_RpcStartMigration.  Plus there is the original ref from the
     * stream that has migrated.  Thus 2 is the minimum.)
d480 1
a480 1
	    *flagsPtr &= ~FS_RMT_SHARED;
d485 1
a485 1
    *flagsPtr |= FS_RMT_SHARED;
@


8.11
log
@Correctly fixed the deadlock problem in migration.
The stream and the I/O handle cannot be locked at the same time
during the migration book-keeping done on the I/O server.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 8.10 89/05/14 15:23:11 brent Exp Locker: brent $ SPRITE (Berkeley)";
a95 1
    Sync_LockRegister(&streamLock);
@


8.10
log
@Fixed StreamMigrateCallback to unlock the I/O handle
so that migrations and unrelated closes do not deadlock.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 8.9 89/04/06 17:42:28 mgbaker Exp $ SPRITE (Berkeley)";
d237 2
d240 1
a270 1
	FsHandleUnlock(ioHandlePtr);
a271 1
	FsHandleLock(ioHandlePtr);
d308 1
@


8.9
log
@Changed panic to a printf in the StreamClientVerify procedure.
Also fixed a typecast.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 8.8 89/03/28 09:33:41 mgbaker Exp $ SPRITE (Berkeley)";
d261 6
a266 1
	 * on the stream.
d268 1
d270 1
d285 1
a285 1
	 * it must be its last reference so we do an I/O close.
@


8.8
log
@Fixed a comparison between an address and a low integer so that the address
will be treated as unsigned.  The test was failing on the sun4, since
addresses are high enough to be negative signed integers.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 8.7 89/02/14 10:56:33 jhh Exp Locker: mgbaker $ SPRITE (Berkeley)";
d564 1
a564 1
	    panic("FsStreamClientVerify, client %d not known for stream <%d>\n",
d918 1
a918 1
		(int)streamList[index] < 1024) {
@


8.7
log
@Update Sync_Lock initialization and registration
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 8.6 89/02/07 14:22:49 brent Exp Locker: jhh $ SPRITE (Berkeley)";
d973 1
a973 1
	} else if ((int)streamPtr < 1024) {
@


8.6
log
@Removed Lint
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 8.5 89/01/30 14:03:42 brent Exp $ SPRITE (Berkeley)";
d48 1
a48 1
static	Sync_Lock	streamLock = SYNC_LOCK_INIT_STATIC();
d96 1
d654 1
d674 1
@


8.5
log
@Added object stats
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 8.4 89/01/30 09:23:55 brent Exp Locker: brent $ SPRITE (Berkeley)";
a93 1
    FsStreamClientInfo *clientPtr;
a166 1
    Boolean foundClient;
d611 1
a611 2
		printf( 
			  "FsStreamDispose, client %d still in list for stream <%d,%d>, refCount %d\n",
@


8.4
log
@Changed scavenge routine to a Boolean
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 8.3 89/01/06 11:20:05 jhh Exp $ SPRITE (Berkeley)";
d40 1
d125 1
d127 2
a128 5
    clientPtr = mnew(FsStreamClientInfo);
    clientPtr->clientID = clientID;
    clientPtr->useFlags = useFlags;
    List_InitElement((List_Links *)clientPtr);
    List_Insert((List_Links *) clientPtr, LIST_ATFRONT(&streamPtr->clientList));
d168 1
d179 1
d248 1
d634 1
d668 1
@


8.3
log
@new Sync_Lock definition
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 8.2 88/12/21 10:17:39 brent Exp Locker: jhh $ SPRITE (Berkeley)";
d653 1
a653 1
ENTRY void
d665 1
d668 1
@


8.2
log
@Double migration bug fix
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 8.1 88/11/17 09:57:12 brent Exp $ SPRITE (Berkeley)";
d47 1
a47 1
static	Sync_Lock	streamLock = {0, 0};
@


8.1
log
@Downgraded a panic in FsStreamClientVerify to a warning.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 7.0 88/11/11 15:33:14 brent Exp $ SPRITE (Berkeley)";
d221 1
a221 1
FsStreamMigClient(migInfoPtr, dstClientID, ioHandlePtr)
d225 2
d279 1
d282 2
d364 6
a369 7
 *	This is called from the stub for RPC_FS_MIGRATE on a host that
 *	is the source of a migration.  At this point this host can
 *	release its reference on a stream that migrated.  We are told
 *	by the I/O server during the I/O migrate call in order
 *	to properly synchronize with closes to the stream.  For example,
 *	a stream often gets duped, then one refernce migrates and the olther
 *	reference gets closed.
d371 3
a373 3
 *	Note.  This is wedged into the mold of an I/O handle migrate routine
 *	because the RPC system is in flux and it isn't convenient to add
 *	a new RPC.
d381 2
a382 1
 *	Does an RPC to the source client and logs a message if that fails.
d421 5
d427 1
a427 1
    if (streamPtr->hdr.refCount <= 1) {
@


8.0
log
@Changing version numbers.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 7.0 88/11/11 15:33:14 brent Exp Locker: douglis $ SPRITE (Berkeley)";
d559 1
a559 1
	panic("No stream <%d> for client %d\n", streamIDPtr->minor, clientID);
@


7.0
log
@New version for conversion to new C library
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 6.11 88/11/04 08:25:51 brent Exp Locker: brent $ SPRITE (Berkeley)";
@


6.11
log
@Fixed use of FS_RMT_SHARED bit so it gets cleared on the server
when sharing stops.  This is required to make MigrateUseCounts
do the right thing.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 6.10 88/10/22 15:15:28 brent Exp $ SPRITE (Berkeley)";
a40 2
#include "mem.h"
#include "byte.h"
d125 1
a125 1
    clientPtr = Mem_New(FsStreamClientInfo);
d347 1
a347 1
	Sys_Panic(SYS_WARNING,
d402 1
a402 1
	Sys_Panic(SYS_WARNING,
d553 1
a553 2
	    Sys_Panic((fsMigDebug > 0) ? SYS_FATAL : SYS_WARNING,
		"FsStreamClientVerify, client %d not known for stream <%d>\n",
d559 1
a559 3
	Sys_Panic((fsMigDebug > 0) ? SYS_FATAL : SYS_WARNING,
		  "No stream <%d> for client %d\n",
		  streamIDPtr->minor, clientID);
d601 1
a601 1
		Sys_Panic(SYS_WARNING, 
d606 1
a606 1
		    Sys_Printf("\tI/O handle: %s <%d,%d>, refCount %d\n",
d619 1
a619 1
	    Mem_Free((Address)streamPtr->nameInfoPtr);
d651 1
a651 1
	Sys_Panic(SYS_WARNING, "FsStreamScavenge, removing stream <%d,%d>\n",
d743 1
a743 1
	    Sys_Panic(SYS_WARNING,
d792 1
a792 1
	Sys_Panic(SYS_FATAL, "Zero valued streamPtr");
d890 2
a891 2
    streamList = (Fs_Stream **)Mem_Alloc(newLength * sizeof(Fs_Stream *));
    streamFlags = (char *)Mem_Alloc(newLength * sizeof(char));
d894 2
a895 4
	Byte_Copy(sizeof(Fs_Stream *) * fsPtr->numStreams,
		  (Address)fsPtr->streamList, (Address)streamList);
	Byte_Copy(sizeof(char) * fsPtr->numStreams,
		  (Address)fsPtr->streamFlags, (Address)streamFlags);
d897 2
a898 2
	Mem_Free((Address)fsPtr->streamList);
	Mem_Free((Address)fsPtr->streamFlags);
d903 1
a903 1
		Sys_Panic(SYS_FATAL, "GrowStreamList copied bad streamPtr, %x\n",
d965 1
a965 1
	    Sys_Panic(SYS_FATAL, "Stream Ptr # %d was an int %d!\n",
@


6.10
log
@Minor tweaking
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 6.9 88/10/20 15:44:23 brent Exp $ SPRITE (Berkeley)";
d282 5
a288 3
	/*
	 * We detected network sharing so we mark the stream.
	 */
d290 2
d361 4
a364 3
 *	This is used to tell the source of a migration that it is ok to
 *	release its reference on the stream that migrated.  This has to
 *	done from the I/O server during the I/O migrate call in order
@


6.9
log
@Changed FsStreamMigClient so it does a callback to the source client
to tell it to release a refernece to a stream which has migrated
away.  This is because Fs_EncapStream is now completely side-effect
free so migrations and closes of duplicated streams don't race.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsStream.c,v 6.8 88/10/14 17:17:38 mlgray Exp $ SPRITE (Berkeley)";
d590 1
a590 1
    Fs_Stream *streamPtr;
d597 1
a597 2
	    FsStreamClientInfo *clientPtr;
	    char *FsFileTypeToString();
@


6.8
log
@Patched FsStreamMigClient so it preserves the FS_NEW_STREAM bit.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsStream.c,v 6.7 88/10/14 12:17:17 brent Exp $ SPRITE (Berkeley)";
d57 1
d155 2
a156 1
FsStreamAddClient(streamIDPtr, clientID, ioHandlePtr, useFlags, name, foundPtr)
d162 5
a166 1
    Boolean		*foundPtr;	/* True if client already existed */
a183 1

d185 4
a188 2
	    foundPtr);

d196 1
a196 1
 * FsStreamAddClient --
d198 13
a210 4
 *	Find a stream and move a client from one host to another.  The
 *	FS_RMT_SHARED stream flag is used to detect if the stream is
 *	being shared by more than one client.  This may be already set by
 *	the source client, or we may set it if we detect sharing here.
d217 2
a218 1
 *	not add/subtract any references to the stream itself.
d223 2
a224 4
FsStreamMigClient(streamIDPtr, srcClientID, dstClientID, ioHandlePtr,
	    offsetPtr, flagsPtr)
    Fs_FileID		*streamIDPtr;	/* File ID for stream */
    int			srcClientID;	/* Original client of the stream */
a226 2
    int			*offsetPtr;	/* Offset from migration info */
    int			*flagsPtr;	/* Stream use flags */
d231 3
a233 1
    int newClientStream = *flagsPtr & FS_NEW_STREAM;
d235 5
a239 2
    found = FsHandleInstall(streamIDPtr, sizeof(Fs_Stream), (char *)NIL,
			    (FsHandleHeader **)&newStreamPtr);
d242 2
a243 2
	streamPtr->offset = *offsetPtr;
	streamPtr->flags = *flagsPtr;
d255 1
a255 1
	streamPtr->offset = *offsetPtr;
d257 1
a257 1
    if ((*flagsPtr & FS_RMT_SHARED) == 0) {
d259 17
d279 2
a280 1
	(void)FsStreamClientClose(&streamPtr->clientList, srcClientID);
d282 2
a283 2
    if (FsStreamClientOpen(&streamPtr->clientList, dstClientID, *flagsPtr,
			    (Boolean *)NIL)) {
d289 120
a408 1
    *flagsPtr = streamPtr->flags | newClientStream;
d410 17
d428 1
a486 1
#ifdef notdef
a489 47
 * FsStreamFind --
 *
 *	Find a stream given its fileID.  If it isn't found then a local
 *	instance is installed.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Install the new stream into the handle table.
 *
 *----------------------------------------------------------------------
 */
Fs_Stream *
FsStreamFind(streamIDPtr, ioHandlePtr, useFlags, name, foundPtr)
    Fs_FileID *streamIDPtr;
    FsHandleHeader *ioHandlePtr;
    int useFlags;
    char *name;
    Boolean *foundPtr;
{
    register Boolean found;
    register Fs_Stream *streamPtr;
    Fs_Stream *newStreamPtr;

    found = FsHandleInstall(streamIDPtr, sizeof(Fs_Stream), name,
			    (FsHandleHeader **)&newStreamPtr);
    streamPtr = newStreamPtr;
    if (!found) {
	streamPtr->offset = 0;
	streamPtr->flags = useFlags;
	streamPtr->ioHandlePtr = ioHandlePtr;
	streamPtr->nameInfoPtr = (FsNameInfo *)NIL;
	List_Init(&streamPtr->clientList);
    } else if (streamPtr->ioHandlePtr == (FsHandleHeader *)NIL) {
	streamPtr->ioHandlePtr = ioHandlePtr;
    }
    if (foundPtr != (Boolean *)NIL) {
	*foundPtr = found;
    }
    return(streamPtr);
}
#endif notdef

/*
 *----------------------------------------------------------------------
 *
d734 1
a734 1
		    (Boolean *)NIL);
@


6.7
log
@FsFileID FsUserID change
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsStream.c,v 6.6 88/10/14 10:40:36 douglis Exp $ SPRITE (Berkeley)";
d218 1
d253 1
a253 1
    *flagsPtr = streamPtr->flags;
@


6.6
log
@Added debugging hook
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsStream.c,v 6.5 88/10/13 10:11:11 douglis Exp $ SPRITE (Berkeley)";
d93 1
a93 1
    FsFileID fileID;
d155 1
a155 1
    FsFileID		*streamIDPtr;	/* File ID for stream */
d208 1
a208 1
    FsFileID		*streamIDPtr;	/* File ID for stream */
d279 1
a279 1
    FsFileID		*streamIDPtr;	/* Return - FileID for the stream */
d283 1
a283 1
    FsFileID fileID;
d332 1
a332 1
    FsFileID *streamIDPtr;
d407 1
a407 1
    FsFileID	*streamIDPtr;	/* Client's stream ID */
d537 2
a538 2
    FsFileID	streamID;
    FsFileID	ioFileID;
d598 1
a598 1
	register FsFileID	*fileIDPtr;
@


6.5
log
@just fixed typo in FsStreamClientVerify error msg.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsStream.c,v 6.4 88/10/11 15:46:53 brent Exp $ SPRITE (Berkeley)";
d39 1
d424 1
a424 1
	    Sys_Panic(SYS_WARNING,
d431 3
a433 2
	Sys_Panic(SYS_WARNING, "No stream <%d> for client %d\n",
	    streamIDPtr->minor, clientID);
@


6.4
log
@Changed the stream creation primatives to match their higher-level
use better.  Also added new function to manipulate client lists
in response to a migration.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsStream.c,v 6.3 88/10/05 12:06:36 brent Exp $ SPRITE (Berkeley)";
d424 1
a424 1
		"FsClientVerify, client %d not known for stream <%d>\n",
@


6.3
log
@Added domainTypePtr parameter to the clientVerify routine
@
text
@d7 5
a11 3
 *	so that streams can be found after migration.  The second set of
 *	procedures handle the mapping from streams to user-level stream IDs,
 *	which are indexes into a per-process array of stream pointers.
d13 4
d29 1
a29 1
static char rcsid[] = "$Header: fsStream.c,v 6.2 88/09/07 16:54:13 brent Exp $ SPRITE (Berkeley)";
d54 1
a54 1
 * Forward routines. 
d62 1
a62 1
 * FsStreamNew --
d64 5
a68 3
 *	Create a new stream.  This chooses a unique minor number for the
 *	fileID of the stream, installs it in the handle table,
 *	and initializes fields.
d71 1
a71 1
 *	None.
d75 3
a77 1
 *	streamCount used to generate IDs.
d82 1
a82 1
FsStreamNew(serverID, ioHandlePtr, useFlags, name)
d84 1
d93 1
d125 6
d138 178
d358 1
d604 3
a606 4
	    Boolean found;

	    streamPtr = FsStreamFind(&reopenParamsPtr->streamID, ioHandlePtr,
		     reopenParamsPtr->useFlags, ioHandlePtr->name, &found);
d612 1
a612 12
	    (void)FsStreamClientOpen(&streamPtr->clientList, clientID,
			reopenParamsPtr->useFlags);

	    if (!found) {
		/*
		 * If the stream wasn't found it means we have to leave
		 * a refernece on the I/O handle for it.
		 */
		FsHandleUnlock(ioHandlePtr);
	    } else {
		FsHandleRelease(ioHandlePtr, TRUE);
	    }
@


6.2
log
@Moved name from stream to I/O handle.
@
text
@d23 1
a23 1
static char rcsid[] = "$Header: fsStream.c,v 6.1 88/08/31 12:06:42 brent Exp $ SPRITE (Berkeley)";
d405 1
a405 1
			(fileIDPtr, clientID);
@


6.1
log
@Removed lint.
@
text
@d23 1
a23 1
static char rcsid[] = "$Header: fsStream.c,v 6.0 88/08/11 12:17:45 brent Stable $ SPRITE (Berkeley)";
d72 1
a72 1
FsStreamNew(serverID, ioHandlePtr, useFlags)
d74 3
a76 2
    FsHandleHeader	*ioHandlePtr;
    int			useFlags;
d96 1
a96 1
	found = FsHandleInstall(&fileID, sizeof(Fs_Stream),
d134 1
a134 1
FsStreamFind(streamIDPtr, ioHandlePtr, useFlags, foundPtr)
d138 1
d145 1
a145 1
    found = FsHandleInstall(streamIDPtr, sizeof(Fs_Stream),
a294 3
	    if (streamPtr->nameInfoPtr->name != (char *)NIL) {
		Mem_Free((Address)streamPtr->nameInfoPtr->name);
	    }
d410 1
a410 1
				     reopenParamsPtr->useFlags, &found);
d431 4
a434 1
	    Sys_Panic(SYS_WARNING, "FsStreamReopen, I/O handle not found\n");
@


6.0
log
@Changing version numbers.
@
text
@d23 1
a23 1
static char rcsid[] = "$Header: fsStream.c,v 1.11 88/08/04 15:05:59 mlgray Exp $ SPRITE (Berkeley)";
d177 1
a177 1
ENTRY ReturnStatus
a183 1
    return(SUCCESS);
d417 1
a417 1
	    FsStreamClientOpen(&streamPtr->clientList, clientID,
d713 4
a716 6
	status = Fs_StreamCopy(streamPtr, &newStreamPtr);
	if (status == SUCCESS) {
	    status = FsGetStreamID(newStreamPtr, newStreamIDPtr);
	    if (status != SUCCESS) {
		Fs_Close(newStreamPtr);
	    }
d764 2
a765 3
	    status =
		Fs_StreamCopy(streamPtr, &fsPtr->streamList[newStreamID]);
	    return(status);
@


1.11
log
@merging changes from fs into fs.new
@
text
@d23 1
a23 1
static char rcsid[] = "$Header: fsStream.c,v 1.12 88/07/22 12:46:44 douglis Exp $ SPRITE (Berkeley)";
@


1.10
log
@Mary checking in for Brent.
@
text
@d23 1
a23 1
static char rcsid[] = "$Header: fsStream.c,v 1.9 88/06/15 17:14:57 brent Exp $ SPRITE (Berkeley)";
d47 4
d58 3
a60 2
 *	Create a new stream.  This chooses a fileID for the stream (because
 *	the stream gets put into the handle table) and initializes fields.
d73 3
a75 3
    int serverID;
    FsHandleHeader *ioHandlePtr;
    int useFlags;
d84 5
a90 5
    /*
     * The streamID is made unique by using our hostID for the major
     * number (we are the chooser), and installing under a new minor
     * number until we don't hit an existing stream.
     */
d92 1
d98 3
a141 1
    FsFileID;
d247 4
d259 3
d266 7
a272 3
    while (!List_IsEmpty(&streamPtr->clientList)) {
	FsStreamClientInfo *clientPtr;
	char *FsFileTypeToString();
d274 14
a287 10
	clientPtr = (FsStreamClientInfo *)List_First(&streamPtr->clientList);
	Sys_Panic(SYS_WARNING, 
	    "FsStreamDispose, client %d still in list for stream <%d,%d>\n",
	    clientPtr->clientID, streamPtr->hdr.fileID.major,
	    streamPtr->hdr.fileID.minor);
	if (streamPtr->ioHandlePtr != (FsHandleHeader *)NIL) {
	    Sys_Printf("\tI/O handle: %s <%d,%d>\n",
		FsFileTypeToString(streamPtr->ioHandlePtr->fileID.type),
		streamPtr->ioHandlePtr->fileID.major,
		streamPtr->ioHandlePtr->fileID.minor);
d289 1
a289 3
	List_Remove((List_Links *)clientPtr);
	Mem_Free((Address)clientPtr);
    }
d292 6
a297 3
    if (streamPtr->nameInfoPtr != (FsNameInfo *)NIL) {
	if (streamPtr->nameInfoPtr->name != (char *)NIL) {
	    Mem_Free((Address)streamPtr->nameInfoPtr->name);
d299 1
a299 1
	Mem_Free((Address)streamPtr->nameInfoPtr);
a300 1
    FsHandleRemove(streamPtr);
@


1.9
log
@Took out extraneous monitor lock
@
text
@d23 1
a23 1
static char rcsid[] = "$Header: fsStream.c,v 1.8 88/06/08 15:01:50 brent Exp $ SPRITE (Berkeley)";
d37 1
d81 6
a86 2
    fileID.major = 0;

a91 3
	    /*
	     * Don't want to conflict with existing streams.
	     */
d251 17
a267 2
    if (!List_IsEmpty(&streamPtr->clientList)) {
	Sys_Panic(SYS_FATAL, "FsStreamDispose, client list not empty\n");
d269 1
@


1.8
log
@Plugged core leak
@
text
@d23 1
a23 1
static char rcsid[] = "$Header: fsStream.c,v 1.7 88/06/06 09:39:24 brent Exp $ SPRITE (Berkeley)";
a337 1
    LOCK_MONITOR;
a395 1
    UNLOCK_MONITOR;
@


1.7
log
@Fixed stream handle locking protocol
@
text
@d23 1
a23 1
static char rcsid[] = "$Header: fsStream.c,v 1.6 88/06/02 11:36:32 brent Exp $ SPRITE (Berkeley)";
d249 3
d254 3
@


1.6
log
@Removed ifdef'ed out code that is old and ugly
@
text
@d23 1
a23 1
static char rcsid[] = "$Header: fsStream.c,v 1.5 88/05/10 11:22:43 brent Exp $ SPRITE (Berkeley)";
d190 2
a191 2
 *	The handle is returned unlocked but with its refCount incremented.
 *	It should be released with FsHandleRelease(..., FALSE)
d219 1
a219 2
	} else {
	    FsHandleUnlock(streamPtr);
@


1.5
log
@Fixed close-on-exec
@
text
@d23 1
a23 1
static char rcsid[] = "$Header: fsStream.c,v 1.4 88/05/06 12:39:37 brent Exp $ SPRITE (Berkeley)";
a360 18
#ifdef notdef
	switch (fileIDPtr->type) {
	    case FS_RMT_FILE_STREAM:
		fileIDPtr->type = FS_LCL_FILE_STREAM;
		status = FsLocalFileHandleInit(fileIDPtr,
			    (FsLocalFileIOHandle **)ioHandlePtr);
		break;
	    case FS_RMT_DEVICE_STREAM:
		fileIDPtr->type = FS_LCL_DEVICE_STREAM;
		(void)FsDeviceHandleInit(fileIDPtr,
			    (FsLocalFileIOHandle **)ioHandlePtr);
		status = SUCCESS;
		break;
	    default:
		Sys_Panic(SYS_FATAL, "Unsupported type in FsStreamReopen\n");
		return(FAILURE);
	}
#endif
@


1.4
log
@Changed proc table -> file system interface
@
text
@d23 1
a23 1
static char rcsid[] = "$Header: fsStream.c,v 1.3 88/05/05 17:35:14 brent Exp $ SPRITE (Berkeley)";
d554 5
a558 4
    Byte_Copy(sizeof(Fs_Stream *) * fsPtr->numStreams,
	      (Address)fsPtr->streamList, (Address)streamList);
    Byte_Copy(sizeof(char) * fsPtr->numStreams,
	      (Address)fsPtr->streamFlags, (Address)streamFlags);
d560 11
a570 2
    Mem_Free((Address)fsPtr->streamList);
    Mem_Free((Address)fsPtr->streamFlags);
a574 6
    for (index=0 ; index < fsPtr->numStreams ; index++) {
	if ((int)streamList[index] < 1024) {
	    Sys_Panic(SYS_FATAL, "GrowStreamList copied bad streamPtr, %x\n",
				   streamList[index]);
	}
    }
@


1.3
log
@Nuked Sys_GetProcessorNumber
@
text
@d23 1
a23 1
static char rcsid[] = "$Header: fsStream.c,v 1.2 88/04/11 17:41:47 brent Exp $ SPRITE (Berkeley)";
d441 1
a441 1
    register Proc_ControlBlock	*procPtr;	/* This process's proc table 
d450 1
a450 1
    procPtr = Proc_GetEffectiveProc();
d455 1
a455 1
    if (procPtr->streamList == (Fs_Stream **)NIL) {
d459 1
a459 9
#define LENGTH	8
	streamPtrPtr = 
		(Fs_Stream **)Mem_Alloc(LENGTH * sizeof(Fs_Stream *));
	procPtr->streamList = streamPtrPtr;
	procPtr->numStreams = LENGTH;
	for (index = 0; index < LENGTH; index++, streamPtrPtr++) {
	    *streamPtrPtr = (Fs_Stream *)NIL;
	}
#undef LENGTH
d465 2
a466 2
    for (index = 0, streamPtrPtr = procPtr->streamList; 
	 index < procPtr->numStreams; 
d471 1
d480 2
a481 2
    status = GrowStreamList(&procPtr->streamList, procPtr->numStreams,
			procPtr->numStreams * 2);
d483 3
a485 3
	*streamIDPtr = procPtr->numStreams;
	procPtr->streamList[*streamIDPtr] = streamPtr;
	procPtr->numStreams *= 2;
d516 1
a516 1
    procPtr->streamList[streamID] = (Fs_Stream *)NIL;
d525 1
a525 2
 *	Grow a stream ID list.  The caller passes in a pointer
 *	to an array of file pointers => ***Fs_Stream.  This routine
d537 2
a538 3
 *	The original array refered to by *streamListPtr is free'd.
 *	A new array of (Fs_Stream *) is allocated and *streamListPtr
 *	is reset to point to it.
d543 2
a544 3
GrowStreamList(streamListPtr, oldLength, newLength)
    Fs_Stream ***streamListPtr;	/* Pointer to an array of (Fs_Stream *) */
    int oldLength;		/* The length of the orignal array */
d548 2
a549 1
    Fs_Stream **streamList;
a550 3
    if (newLength <= oldLength) {
	Sys_Panic(SYS_FATAL, "GrowStreamList, stupid call\n");
    }
d552 1
d554 4
a557 2
    Byte_Copy(sizeof(Fs_Stream *) * oldLength,
	      (Address)*streamListPtr, (Address)streamList);
d559 2
a560 1
    Mem_Free((Address)*streamListPtr);
d562 7
a568 4
    for (index=0 ; index<oldLength ; index++) {
	if (streamList[index] == (Fs_Stream *)0) {
	    Sys_Panic(SYS_FATAL, "FsGrowList copied zero streamPtr, #%d\n",
				   index);
d571 3
a573 2
    for (index=oldLength ; index<newLength ; index++) {
	streamList[index] = (Fs_Stream *)NIL;
d575 1
a575 1
    *streamListPtr = streamList;
d608 1
a608 1
    if (streamID < 0 || streamID >= procPtr->numStreams) {
d613 1
a613 1
	streamPtr = procPtr->streamList[streamID];
d616 10
a625 2
	} else if (streamPtr == (Fs_Stream *)0) {
	    Sys_Panic(SYS_WARNING, "Stream Ptr # %d was zero\n", streamID);
d667 4
a670 3
    ReturnStatus 	status;
    Fs_Stream 		*streamPtr;
    Proc_ControlBlock	*procPtr;
d680 1
d709 1
a709 1
	    if (newStreamID >= procPtr->numStreams) {
d716 1
a716 1
		maxID = 2 * procPtr->numStreams;
d721 1
a721 3
		status = GrowStreamList(&procPtr->streamList,
				   procPtr->numStreams,
				   newStreamID + 1 );
a723 2
		} else {
		    procPtr->numStreams = newStreamID + 1;
d732 1
a732 1
		oldFilePtr = procPtr->streamList[newStreamID];
d738 1
a738 1
		Fs_StreamCopy(streamPtr, &procPtr->streamList[newStreamID]);
@


1.2
log
@Nuked old procedure
@
text
@d23 1
a23 1
static char rcsid[] = "$Header: fsStream.c,v 1.1 88/04/04 10:42:52 brent Exp $ SPRITE (Berkeley)";
d450 1
a450 1
    procPtr = Proc_GetEffectiveProc(Sys_GetProcessorNumber());
d521 1
a521 1
	procPtr = Proc_GetEffectiveProc(Sys_GetProcessorNumber());
d670 1
a670 1
    procPtr = Proc_GetEffectiveProc(Sys_GetProcessorNumber());
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
static char rcsid[] = "$Header: fsStream.c,v 5.2 87/09/24 13:15:15 brent Exp $ SPRITE (Berkeley)";
a291 32

#ifdef notdef
/*
 *----------------------------------------------------------------------
 *
 * FsStreamCloseCheck --
 *
 *	Return TRUE if an actual close should be performed on the stream
 *	because this is the last reference to a particular open.
 *	MUST BE CALLED WITH stream handle LOCKED so it is safe to
 *	look at the reference count of the handle.
 *
 * Results:
 *	TRUE if an actual close should be performed on this stream.
 *
 * Side effects:
 *	Reference count of the stream is decremented.
 *
 *----------------------------------------------------------------------
 */
ENTRY Boolean
FsStreamCloseCheck(streamPtr)
    Fs_Stream	*streamPtr;
{
    register Boolean	shouldClose;
    LOCK_MONITOR;
    streamPtr->refCount--;
    shouldClose = (streamPtr->refCount == 0);
    UNLOCK_MONITOR;
    return(shouldClose);
}
#endif notdef
@
