head     9.12;
branch   ;
access   ;
symbols  ds3100:9.12 sun3:9.12 sprited:9.10.1 sun4nw:9.11 symm:9.11 spur:9.11 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.12
date     92.08.10.17.26.55;  author mgbaker;  state Exp;
branches ;
next     9.11;

9.11
date     91.09.10.18.38.02;  author rab;  state Exp;
branches ;
next     9.10;

9.10
date     91.03.30.17.10.09;  author mgbaker;  state Exp;
branches 9.10.1.1;
next     9.9;

9.9
date     90.12.06.21.56.46;  author jhh;  state Exp;
branches ;
next     9.8;

9.8
date     90.10.08.15.55.34;  author mendel;  state Exp;
branches ;
next     9.7;

9.7
date     90.08.29.17.04.46;  author douglis;  state Exp;
branches ;
next     9.6;

9.6
date     90.08.07.10.51.56;  author douglis;  state Exp;
branches ;
next     9.5;

9.5
date     90.07.15.13.36.32;  author shirriff;  state Exp;
branches ;
next     9.4;

9.4
date     90.06.27.11.16.50;  author douglis;  state Exp;
branches ;
next     9.3;

9.3
date     90.05.23.14.13.50;  author jhh;  state Exp;
branches ;
next     9.2;

9.2
date     89.11.27.14.26.58;  author mgbaker;  state Exp;
branches ;
next     9.1;

9.1
date     89.10.23.14.09.12;  author brent;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.05.55;  author douglis;  state Stable;
branches ;
next     8.19;

8.19
date     89.08.21.15.26.02;  author mendel;  state Exp;
branches ;
next     8.18;

8.18
date     89.08.17.17.21.16;  author jhh;  state Exp;
branches ;
next     8.17;

8.17
date     89.07.18.13.08.15;  author jhh;  state Exp;
branches ;
next     8.16;

8.16
date     89.07.01.17.36.36;  author brent;  state Exp;
branches ;
next     8.15;

8.15
date     89.06.22.16.30.36;  author brent;  state Exp;
branches ;
next     8.14;

8.14
date     89.06.21.12.30.40;  author brent;  state Exp;
branches ;
next     8.13;

8.13
date     89.06.16.12.06.54;  author brent;  state Exp;
branches ;
next     8.12;

8.12
date     89.06.15.09.24.30;  author brent;  state Exp;
branches ;
next     8.11;

8.11
date     89.05.30.16.10.50;  author jhh;  state Exp;
branches ;
next     8.10;

8.10
date     89.05.09.13.10.39;  author brent;  state Exp;
branches ;
next     8.9;

8.9
date     89.02.28.08.48.19;  author brent;  state Exp;
branches ;
next     8.8;

8.8
date     89.02.14.10.56.15;  author jhh;  state Exp;
branches ;
next     8.7;

8.7
date     89.02.06.17.38.32;  author brent;  state Exp;
branches ;
next     8.6;

8.6
date     89.02.01.16.40.28;  author brent;  state Exp;
branches ;
next     8.5;

8.5
date     89.02.01.16.35.58;  author brent;  state Exp;
branches ;
next     8.4;

8.4
date     89.01.30.14.04.20;  author brent;  state Exp;
branches ;
next     8.3;

8.3
date     89.01.30.09.22.18;  author brent;  state Exp;
branches ;
next     8.2;

8.2
date     89.01.06.11.19.23;  author jhh;  state Exp;
branches ;
next     8.1;

8.1
date     88.12.21.10.17.30;  author brent;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.19.22;  author douglis;  state Stable;
branches ;
next     7.0;

7.0
date     88.11.11.15.31.07;  author brent;  state Exp;
branches ;
next     6.17;

6.17
date     88.10.20.15.48.20;  author brent;  state Exp;
branches ;
next     6.16;

6.16
date     88.10.16.11.11.36;  author brent;  state Exp;
branches ;
next     6.15;

6.15
date     88.10.14.12.15.17;  author brent;  state Exp;
branches ;
next     6.14;

6.14
date     88.10.11.15.59.15;  author brent;  state Exp;
branches ;
next     6.13;

6.13
date     88.10.10.11.25.49;  author douglis;  state Exp;
branches ;
next     6.12;

6.12
date     88.10.05.12.10.48;  author brent;  state Exp;
branches ;
next     6.11;

6.11
date     88.09.28.13.32.14;  author brent;  state Exp;
branches ;
next     6.10;

6.10
date     88.09.28.08.38.01;  author brent;  state Exp;
branches ;
next     6.9;

6.9
date     88.09.23.13.39.05;  author brent;  state Exp;
branches ;
next     6.8;

6.8
date     88.09.22.09.04.10;  author brent;  state Exp;
branches ;
next     6.7;

6.7
date     88.09.16.16.51.24;  author brent;  state Exp;
branches ;
next     6.6;

6.6
date     88.09.13.11.27.26;  author brent;  state Exp;
branches ;
next     6.5;

6.5
date     88.09.08.17.30.30;  author brent;  state Exp;
branches ;
next     6.4;

6.4
date     88.09.07.16.52.42;  author brent;  state Exp;
branches ;
next     6.3;

6.3
date     88.08.31.12.05.18;  author brent;  state Exp;
branches ;
next     6.2;

6.2
date     88.08.26.11.10.34;  author brent;  state Exp;
branches ;
next     6.1;

6.1
date     88.08.12.12.31.00;  author brent;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.15.43;  author brent;  state Stable;
branches ;
next     1.6;

1.6
date     88.08.05.13.57.59;  author brent;  state Exp;
branches ;
next     1.5;

1.5
date     88.08.04.15.05.05;  author mlgray;  state Exp;
branches ;
next     1.4;

1.4
date     88.06.08.14.59.25;  author brent;  state Exp;
branches ;
next     1.3;

1.3
date     88.06.06.09.36.48;  author brent;  state Exp;
branches ;
next     1.2;

1.2
date     88.04.19.10.34.28;  author brent;  state Exp;
branches ;
next     1.1;

1.1
date     88.04.11.10.09.00;  author brent;  state Exp;
branches ;
next     ;

9.10.1.1
date     91.11.15.16.00.21;  author kupfer;  state Exp;
branches ;
next     ;


desc
@Unnamed pipe procedures.
@


9.12
log
@Transparent server recovery now available.
@
text
@/*
 * fsPipe.c --
 *
 *	Routines for unnamed pipes.  An unnamed pipe has a fixed length
 *	resident buffer, a reading stream, and a writing stream.
 *	Process migration can result in remotely accessed pipes.
 *
 * Copyright (C) 1985 Regents of the University of California
 * All rights reserved.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fsio/fsioPipe.c,v 9.11 91/09/10 18:38:02 rab Exp $ SPRITE (Berkeley)";
#endif not lint


#include <sprite.h>

#include <fs.h>
#include <fsutil.h>
#include <fsio.h>
#include <fsNameOps.h>
#include <fsconsist.h>
#include <fsStat.h>
#include <fsrmt.h>
#include <vm.h>
#include <proc.h>
#include <rpc.h>
#include <fsioPipe.h>

#include <stdio.h>
#include <recov.h>

/*
 * Monitor to synchronize access to the openInstance in GetFileID.
 */
static	Sync_Lock	pipeLock = Sync_LockInitStatic("Fs:pipeLock");
#define	LOCKPTR	&pipeLock

/*
 * Forward references.
 */
static void GetFileID _ARGS_((Fs_FileID *fileIDPtr));
extern Fsio_PipeIOHandle *Fsio_PipeHandleInit _ARGS_((Fs_FileID *fileIDPtr, 
		Boolean findIt));
static ReturnStatus PipeCloseInt _ARGS_((Fsio_PipeIOHandle *handlePtr, 
		int ref, int write, Boolean release));

/*
 * Migration debugging.
 */
#ifdef MIG_DEBUG

#define PIPE_CREATED(inStreamPtr, outStreamPtr) \
    { \
	printf("Create Pipe: Srvr %d Read <%d> Write <%d> I/O %d <%d,%d>\n", \
		(inStreamPtr)->hdr.fileID.serverID, \
		(inStreamPtr)->hdr.fileID.minor, \
		(outStreamPtr)->hdr.fileID.minor, \
		(inStreamPtr)->ioHandlePtr->fileID.serverID, \
		(inStreamPtr)->ioHandlePtr->fileID.major, \
		(inStreamPtr)->ioHandlePtr->fileID.minor); \
    }

#define PIPE_CLOSE(streamPtr, handlePtr) \
	printf("Pipe Close: Stream %s <%d> I/O <%d,%d> ref %d write %d flags %x\n", \
		((streamPtr)->flags & FS_READ) ? "Read" : "Write", \
		(streamPtr)->hdr.fileID.minor, \
		(handlePtr)->hdr.fileID.major, (handlePtr)->hdr.fileID.minor, \
		(handlePtr)->use.ref, (handlePtr)->use.write, \
		(handlePtr)->flags)

#define PIPE_MIG_1(migInfoPtr, dstClientID) \
	printf("Pipe Migrate: %d => %d Stream %d <%d> I/O <%d,%d> migFlags %x ", \
	    (migInfoPtr)->srcClientID, dstClientID, \
	    (migInfoPtr)->streamID.serverID, (migInfoPtr)->streamID.minor, \
	    (migInfoPtr)->ioFileID.major, (migInfoPtr)->ioFileID.minor, \
	    (migInfoPtr)->flags);

#define PIPE_MIG_2(migInfoPtr, closeSrcClient, handlePtr) \
	printf("=> %x\n    closeSrc %d (ref %d write %d", (migInfoPtr)->flags, \
		closeSrcClient, (handlePtr)->use.ref, (handlePtr)->use.write);

#define PIPE_MIG_3(handlePtr) \
	printf(" | ref %d write %d)\n", \
		(handlePtr)->use.ref, (handlePtr)->use.write);

#define PIPE_MIG_END(handlePtr) \
	printf("PipeMigEnd: I/O <%d,%d> ref %d write %d\n", \
	    (handlePtr)->hdr.fileID.major, (handlePtr)->hdr.fileID.minor, \
	    (handlePtr)->use.ref, (handlePtr)->use.write)
#else

#define PIPE_CREATED(inStreamPtr, outStreamPtr)
#define PIPE_CLOSE(streamPtr, handlePtr)
#define PIPE_MIG_1(migInfoPtr, dstClientID)
#define PIPE_MIG_2(migInfoPtr, closeSrcClient, handlePtr)
#define PIPE_MIG_3(handlePtr)
#define PIPE_MIG_END(handlePtr)

#endif /* MIG_DEBUG */

/*
 *----------------------------------------------------------------------
 *
 * Fsio_CreatePipe --
 *
 *      Create an unnamed pipe.  Pointers to streams for both ends of the pipe
 *	are returned in *inStreamPtrPtr and *outStreamPtrPtr.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Fsio_CreatePipe(inStreamPtrPtr, outStreamPtrPtr)
    Fs_Stream **inStreamPtrPtr;		/* Return - in (reading) stream */
    Fs_Stream **outStreamPtrPtr;	/* Return - out (writing) stream */
{
    Fs_FileID		fileID;
    register Fsio_PipeIOHandle	*handlePtr;
    register Fs_Stream		*streamPtr;

    /*
     * Set up the I/O handle for the pipe.  The installation puts
     * one reference on the I/O handle.
     */

    GetFileID(&fileID);
    handlePtr = Fsio_PipeHandleInit(&fileID, FALSE);
    (void)Fsconsist_IOClientOpen(&handlePtr->clientList, rpc_SpriteID, FS_READ, FALSE);
    (void)Fsconsist_IOClientOpen(&handlePtr->clientList, rpc_SpriteID, FS_WRITE, FALSE);

    /*
     * Allocate and initialize the read, or "in", end of the stream.
     */
    streamPtr = Fsio_StreamCreate(rpc_SpriteID, rpc_SpriteID,
			    (Fs_HandleHeader *)handlePtr,
			    FS_READ | FS_USER, "read-pipe");
    Fsutil_HandleUnlock(streamPtr);
    *inStreamPtrPtr = streamPtr;

    /*
     * Set up the writing end.  Note that we get a second reference to
     * the I/O handle by duping it.
     */
    Fsutil_HandleUnlock(handlePtr);
    (void)Fsutil_HandleDup((Fs_HandleHeader *)handlePtr);
    streamPtr = Fsio_StreamCreate(rpc_SpriteID, rpc_SpriteID,
			(Fs_HandleHeader *)handlePtr,
			FS_WRITE | FS_APPEND | FS_USER, "write-pipe");
    Fsutil_HandleUnlock(handlePtr);
    Fsutil_HandleUnlock(streamPtr);
    *outStreamPtrPtr = streamPtr;

    PIPE_CREATED(*inStreamPtrPtr, *outStreamPtrPtr);

    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * GetFileID --
 *
 *      Get a unique file ID for the pipe.  This is a monitor to synchronize
 *	access to the openInstance variable that gives us unique file
 *	ids for unnamed pipes.
 *
 * Results:
 *	Unique file ID.
 *
 * Side effects:
 *	Open instance incremented.
 *
 *----------------------------------------------------------------------
 */

static ENTRY void
GetFileID(fileIDPtr)
    Fs_FileID	*fileIDPtr;
{
    static int openInstance = 0;

    LOCK_MONITOR;

    fileIDPtr->type = FSIO_LCL_PIPE_STREAM;
    fileIDPtr->serverID = rpc_SpriteID;
    fileIDPtr->major = 0;
    fileIDPtr->minor = openInstance;
    openInstance++;

    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * Fsio_PipeHandleInit --
 *
 *	Initialize a handle for a pipe.
 *
 * Results:
 *	A pointer to the pipe handle.
 *
 * Side effects:
 *	Create and install a handle for the file.  It is returned locked
 *	and with its reference count incremented if SUCCESS is returned.
 *
 *----------------------------------------------------------------------
 */
Fsio_PipeIOHandle *
Fsio_PipeHandleInit(fileIDPtr, findIt)
    Fs_FileID	*fileIDPtr;	/* Pipe file ID */
    Boolean	findIt;		/* TRUE if we expect to find its handle */
{
    Fs_HandleHeader *hdrPtr;
    register Fsio_PipeIOHandle *handlePtr;
    register Boolean found;

    found = Fsutil_HandleInstall(fileIDPtr, sizeof(Fsio_PipeIOHandle), "pipe",
		FALSE, &hdrPtr);
    handlePtr = (Fsio_PipeIOHandle *)hdrPtr;
    if (!found) {
	if (findIt) {
	    panic( "Fsio_PipeHandleInit, didn't find handle\n");
	}
	/*
	 * When a pipe is created, it has one read and one write
	 * reference on the handle.
	 */
	handlePtr->use.ref = 2;
	handlePtr->use.write = 1;
	handlePtr->use.exec = 0;
	List_Init(&handlePtr->clientList);
	handlePtr->flags = 0;
	handlePtr->firstByte = handlePtr->lastByte = -1;
	handlePtr->buffer = (Address)malloc(FS_BLOCK_SIZE);
	handlePtr->bufSize = FS_BLOCK_SIZE;
	List_Init(&handlePtr->readWaitList);
	List_Init(&handlePtr->writeWaitList);
	fs_Stats.object.pipes++;
    }
    return(handlePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * Fsio_PipeClose --
 *
 *      Close a local pipe.  Other processes waiting on the pipe are
 *	unblocked and the pipe's buffer is freed when the last
 *	user goes away.
 *
 * Results:
 *      SUCCESS.
 *
 * Side effects:
 *      Unblock local waiting reader (or writer) waiting on the pipe.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Fsio_PipeClose(streamPtr, clientID, procID, flags, dataSize, closeData)
    Fs_Stream		*streamPtr;	/* Stream to a pipe */
    int			clientID;	/* Host ID of closing process */
    Proc_PID		procID;		/* Process closing */
    int			flags;		/* Flags from the stream being closed */
    int			dataSize;	/* Should be 0 */
    ClientData		closeData;	/* Should be NIL */
{
    register Fsio_PipeIOHandle *handlePtr = 
	    (Fsio_PipeIOHandle *)streamPtr->ioHandlePtr;
    Boolean cache = FALSE;
    ReturnStatus status;

    if (!Fsconsist_IOClientClose(&handlePtr->clientList, clientID, flags, &cache)) {
	printf( "Fsio_PipeClose, unknown client %d\n", clientID);
	Fsutil_HandleUnlock(handlePtr);
    } else {
	PIPE_CLOSE(streamPtr, handlePtr);
	status = PipeCloseInt(handlePtr, 1, (flags & FS_WRITE) != 0, TRUE);
	if (status != FS_FILE_REMOVED) {
	    Fsutil_HandleRelease(handlePtr, TRUE);
	}
    }
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * PipeCloseInt --
 *
 *      Do the real work of closing a pipe, given a variable number
 *	of references. 
 *
 * Results:
 *      SUCCESS or FS_FILE_REMOVED, which indicates that the pipe has been
 * 	freed up.
 *
 * Side effects:
 *      Unblock local waiting reader (or writer) waiting on the pipe.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
static ReturnStatus
PipeCloseInt(handlePtr, ref, write, release)
    Fsio_PipeIOHandle *handlePtr;	/* Pipe to clean up */
    int ref;				/* Number of uses to remove */
    int write;				/* Number of writers to remove */
    Boolean release;			/* Whether to release handle to
					   remove it. */
{
    /*
     * Update the global/summary use counts for the file.
     */
    handlePtr->use.ref -= ref;
    handlePtr->use.write -= write;
    if (handlePtr->use.ref < 0 || handlePtr->use.write < 0) {
	panic("PipeCloseInt <%d,%d> use %d, write %d\n",
	      handlePtr->hdr.fileID.major, handlePtr->hdr.fileID.minor,
	      handlePtr->use.ref, handlePtr->use.write);
    }
    if (write && handlePtr->use.write == 0) {
	/*
	 * Notify reader that the writer has closed.
	 */
	handlePtr->flags |= FSIO_PIPE_WRITER_GONE;
	Fsutil_FastWaitListNotify(&handlePtr->readWaitList);
    } else if (ref && handlePtr->use.ref == handlePtr->use.write) {
	/*
	 * Update state and notify any blocked writers.  Their write
	 * will fail with no remaining readers.
	 */
	handlePtr->flags |= FSIO_PIPE_READER_GONE;
	Fsutil_FastWaitListNotify(&handlePtr->writeWaitList);
    }
    if (handlePtr->flags == (FSIO_PIPE_WRITER_GONE|FSIO_PIPE_READER_GONE)) {
	free(handlePtr->buffer);
	Fsutil_WaitListDelete(&handlePtr->readWaitList);
	Fsutil_WaitListDelete(&handlePtr->writeWaitList);
	if (release) {
	    Fsutil_HandleRelease(handlePtr, FALSE);
	}
	Fsutil_HandleRemove(handlePtr);
	fs_Stats.object.pipes--;
	return (FS_FILE_REMOVED);
    }
    /*
     * Handle will be released or unlocked by caller as appropriate.
     */
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * Fsio_PipeRead --
 *
 *      Read on a pipe.  Data is copied out of the pipe to satisfy the
 *	read.  If the pipe is empty this routine returns FS_WOULD_BLOCK.
 *	If the pipe writer is gone this returns SUCCESS and 0 bytes
 *	to simulate EOF.
 *
 * Results:
 *      SUCCESS unless there was an address error or I/O error.
 *
 * Side effects:
 *      Fill in the buffer.  Notifies the pipe's writeWaitList after
 *	removing data from the pipe.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Fsio_PipeRead(streamPtr, readPtr, waitPtr, replyPtr)
    Fs_Stream           *streamPtr;     /* Stream to read from */
    Fs_IOParam		*readPtr;	/* Read parameter block. */
    Sync_RemoteWaiter	*waitPtr;	/* Process info for remote waiting */
    Fs_IOReply		*replyPtr;	/* Signal to return, if any,
					 * plus the amount read. */
{
    ReturnStatus 	status = SUCCESS;
    register Fsio_PipeIOHandle *handlePtr =
	    (Fsio_PipeIOHandle *)streamPtr->ioHandlePtr;
    int 		toRead;
    int 		startOffset;
    int			startByte;
    int			endByte;

    Fsutil_HandleLock(handlePtr);

    if (handlePtr->firstByte == -1) {
	/*
	 * No data in the pipe.  If there is no writer left then
	 * return SUCCESS so the user process thinks of it as end of file,
	 * otherwise block waiting for input.
	 */
	replyPtr->length = 0;
	if (handlePtr->flags & FSIO_PIPE_WRITER_GONE) {
	    status = SUCCESS;
	    goto exit;
	} else {
	    status = FS_WOULD_BLOCK;
	    goto exit;
	}
    }
    /*
     * Compute the number of bytes that we can read from the pipe.  
     */
    toRead = handlePtr->lastByte - handlePtr->firstByte + 1;
    if (toRead > readPtr->length) {
	toRead = readPtr->length;
    }

    /*
     * Compute offsets into the pipe buffer.  The offsets float out past
     * the size of the buffer, but we use masks to take of the top bits.
     * We can also compare these top bits to determine if the valid range
     * of the buffer wraps around the end of the pipe.
     */
    startByte = handlePtr->firstByte;
    startOffset = startByte & FS_BLOCK_OFFSET_MASK;
    endByte = handlePtr->firstByte + toRead - 1;

    if ((startByte & ~FS_BLOCK_OFFSET_MASK) ==
	(endByte & ~FS_BLOCK_OFFSET_MASK)) {
	/*
	 * Can do a straight copy, no wrap around necessary.
	 */
	if (readPtr->flags & FS_USER) {
	    if (Vm_CopyOut(toRead, handlePtr->buffer + startOffset, readPtr->buffer)
			  != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    }
	} else {
	    bcopy(handlePtr->buffer + startOffset, readPtr->buffer, toRead);
	}
    } else {
	int	numBytes;
	/*
	 * Have to wrap around in the block so do it in two copies.
	 */
	numBytes = FS_BLOCK_SIZE - startOffset;
	if (readPtr->flags & FS_USER) {
	    if (Vm_CopyOut(numBytes, handlePtr->buffer + startOffset, readPtr->buffer)
			  != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    } else if (Vm_CopyOut(toRead - numBytes, handlePtr->buffer,
				readPtr->buffer + numBytes) != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    }
	} else {
	    bcopy(handlePtr->buffer + startOffset, readPtr->buffer, numBytes);
	    bcopy(handlePtr->buffer, readPtr->buffer + numBytes, toRead - numBytes);
	}
    }

    /*
     * We just made space in the pipe so wake up blocked writers.
     */
    Fsutil_FastWaitListNotify(&handlePtr->writeWaitList);

    /*
     * Update the first byte and the parameters.
     */
    handlePtr->firstByte += toRead;
    if (handlePtr->firstByte > handlePtr->lastByte) {
	handlePtr->firstByte = -1;
	handlePtr->lastByte = -1;
    }
    replyPtr->length = toRead;
exit:
    if (status == FS_WOULD_BLOCK) {
	Fsutil_FastWaitListInsert(&handlePtr->readWaitList, waitPtr);
    }
    Fsutil_HandleUnlock(handlePtr);
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * Fsio_PipeWrite --
 *
 *      Write on a pipe.  This will put as much data as possible into the
 *	pipe buffer, and then block the process (return would-block) if
 *	there is any left over data.  *lenPtr is updated to reflect how
 *	much data was written to the pipe.
 *
 * Results:
 *      SUCCESS unless there was an address error or I/O error.
 *
 * Side effects:
 *      Fill the pipe from the buffer.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
Fsio_PipeWrite(streamPtr, writePtr, waitPtr, replyPtr)
    Fs_Stream           *streamPtr;     /* Stream to write to */
    Fs_IOParam		*writePtr;	/* Read parameter block */
    Sync_RemoteWaiter	*waitPtr;	/* Process info for remote waiting */
    Fs_IOReply		*replyPtr;	/* Signal to return, if any */
{
    register ReturnStatus 	status = SUCCESS;
    register Fsio_PipeIOHandle	*handlePtr =
	    (Fsio_PipeIOHandle *)streamPtr->ioHandlePtr;
    int 			startOffset;
    register int 		toWrite;
    int				startByte;
    int				endByte;

    Fsutil_HandleLock(handlePtr);

    if (handlePtr->flags & FSIO_PIPE_READER_GONE) {
	replyPtr->length = 0;
	replyPtr->signal = SIG_PIPE;
	status = FS_BROKEN_PIPE;
	goto exit;
    }

    /*
     * Compute the number of bytes that will fit in the pipe.  Remember
     * that the pipe can only hold one block of data.
     */
    if (handlePtr->firstByte == -1) {
	toWrite = FS_BLOCK_SIZE;
    } else {
	toWrite = FS_BLOCK_SIZE - 
		    (handlePtr->lastByte - handlePtr->firstByte + 1);
    }
    if (toWrite == 0) {
	/*
	 * No room in the pipe.
	 */
	replyPtr->length = 0;
	status = FS_WOULD_BLOCK;
	goto exit;
    } else if (toWrite > writePtr->length) {
	toWrite = writePtr->length;
    } else if (writePtr->length > toWrite) {
	/*
	 * If there is more data to write we must block after writing the
	 * data that we can.  
	 */
	status = FS_WOULD_BLOCK;
    }
    /*
     * Determine where to start and stop writing.  Note that the firstByte
     * and lastByte offsets float out beyond the size of the pipe but
     * we use masks to clear off the extra high order bits.
     */
    startByte = handlePtr->lastByte + 1;
    startOffset = startByte & FS_BLOCK_OFFSET_MASK;
    endByte = handlePtr->lastByte + toWrite;

    if ((startByte & ~FS_BLOCK_OFFSET_MASK) ==
	(endByte & ~FS_BLOCK_OFFSET_MASK)) {
	/*
	 * Can do a straight copy, no wrap around necessary.
	 */
	if (writePtr->flags & FS_USER) {
	    if (Vm_CopyIn(toWrite, writePtr->buffer, handlePtr->buffer + startOffset)
			  != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    }
	} else {
	    bcopy(writePtr->buffer, handlePtr->buffer + startOffset, toWrite);
	}
    } else {
	int	numBytes;
	/*
	 * Have to wrap around in the block so do it in two copies.
	 */
	numBytes = FS_BLOCK_SIZE - startOffset;
	if (writePtr->flags & FS_USER) {
	    if (Vm_CopyIn(numBytes, writePtr->buffer, handlePtr->buffer + startOffset)
			  != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    } else if (Vm_CopyIn(toWrite - numBytes, writePtr->buffer + numBytes, 
			    handlePtr->buffer) != SUCCESS) {
		status = SYS_ARG_NOACCESS;
	    }
	} else {
	    bcopy(writePtr->buffer, handlePtr->buffer + startOffset, numBytes);
	    bcopy(writePtr->buffer + numBytes, handlePtr->buffer, toWrite - numBytes);
	}
    }

    /*
     * We just wrote to the pipe so wake up blocked readers.
     */
    Fsutil_FastWaitListNotify(&handlePtr->readWaitList);

    /*
     * Update first byte, last byte and the parameters.
     */
    if (handlePtr->firstByte == -1) {
	handlePtr->firstByte = 0;
    }
    handlePtr->lastByte = endByte;
    replyPtr->length = toWrite;
exit:
    if (status == FS_WOULD_BLOCK) {
	Fsutil_FastWaitListInsert(&handlePtr->writeWaitList, waitPtr);
    }
    Fsutil_HandleUnlock(handlePtr);
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * Fsio_PipeIOControl --
 *
 *	Check the IOC_CLEAR_FLAG control, and allow the IOC_SET_FLAG control.
 *
 * Results:
 *      SUCCESS unless they try to clear the FS_APPEND flag.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Fsio_PipeIOControl(streamPtr, ioctlPtr, replyPtr)
    Fs_Stream *streamPtr;
    Fs_IOCParam *ioctlPtr;		/* I/O Control parameter block */
    Fs_IOReply *replyPtr;		/* Return length and signal */
{
    register Fsio_PipeIOHandle *handlePtr =
	    (Fsio_PipeIOHandle *)streamPtr->ioHandlePtr;
    register int command = ioctlPtr->command;
    ReturnStatus status = SUCCESS;

    switch(command) {
	case IOC_REPOSITION:
	    return(FS_BAD_SEEK);
	case IOC_GET_FLAGS:
	case IOC_SET_BITS:
	    return(SUCCESS);
	case IOC_CLEAR_BITS:
	case IOC_SET_FLAGS: {
	    /*
	     * Guard against turning off append mode in pipes.
	     */
	    int flags;
	    int size;
	    int inSize;

	    if (ioctlPtr->inBufSize != sizeof(int)) {
		status = GEN_INVALID_ARG;
	    } else if (ioctlPtr->format != mach_Format) {
		int fmtStatus;
		size = sizeof(int);
		inSize = ioctlPtr->inBufSize;
		fmtStatus = Fmt_Convert("w", ioctlPtr->format, &inSize,
				ioctlPtr->inBuffer, mach_Format, &size,
				(Address) &flags);
		if (fmtStatus != 0) {
		    printf("Format of ioctl failed <0x%x>\n", fmtStatus);
		    status = GEN_INVALID_ARG;
		}
		if (size != sizeof(int)) {
		    status = GEN_INVALID_ARG;
		}
	    } else {
		flags = *(int *)ioctlPtr->inBuffer;
	    }
	    if (status != SUCCESS) {
		return(status);
	    }
	    if ((command == IOC_SET_FLAGS && (flags & IOC_APPEND) == 0) ||
		(command == IOC_CLEAR_BITS && (flags & IOC_APPEND))) {
		return(GEN_INVALID_ARG);
	    }
	    return(SUCCESS);
	}
	case IOC_TRUNCATE:
	case IOC_LOCK:
	case IOC_UNLOCK:
	    return(GEN_NOT_IMPLEMENTED);
	case IOC_NUM_READABLE: {
	    int bytesAvailable = handlePtr->lastByte - handlePtr->firstByte;

	    if (ioctlPtr->outBufSize != sizeof(int)) {
		status = GEN_INVALID_ARG;
	    } else if (ioctlPtr->format != mach_Format) {
		int size = sizeof(int);
		int inSize = sizeof(int);
		int fmtStatus;
		fmtStatus = Fmt_Convert("w", mach_Format, &inSize,
				(Address) &bytesAvailable, ioctlPtr->format, 
				&size, (Address) ioctlPtr->outBuffer);
		if (fmtStatus != 0) {
		    printf("Format of ioctl failed <0x%x>\n", fmtStatus);
		    status = GEN_INVALID_ARG;
		}
		if (size != sizeof(int)) {
		    status = GEN_INVALID_ARG;
		}
	    } else {
		*(int *)ioctlPtr->outBuffer = bytesAvailable;
	    }
	    return(status);
	}
	case IOC_GET_OWNER:
	case IOC_SET_OWNER:
	case IOC_MAP:
	case IOC_PREFIX:
	    return(GEN_NOT_IMPLEMENTED);
	default:
	    return(GEN_INVALID_ARG);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Fsio_PipeSelect --
 *
 *	Select on a pipe.
 *
 * Results:
 *      SUCCESS unless there was an address error or I/O error.
 *
 * Side effects:
 *      Fill the pipe from the buffer.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
Fsio_PipeSelect(hdrPtr, waitPtr, readPtr, writePtr, exceptPtr)
    Fs_HandleHeader *hdrPtr;	/* The handle of the file */
    Sync_RemoteWaiter *waitPtr;	/* Process info for waiting */
    int		*readPtr;	/* Read bit */
    int		*writePtr;	/* Write bit */
    int		*exceptPtr;	/* Exception bit */
{
    register Fsio_PipeIOHandle *handlePtr = (Fsio_PipeIOHandle *)hdrPtr;

    Fsutil_HandleLock(hdrPtr);
    *exceptPtr = 0;
    if (*writePtr) {
	/*
	 * Turn off writability if the pipe is full and there
	 * are still readers.  If there are no readers we allow
	 * writing but the next write will fail.
	 */
	if ((((handlePtr->firstByte + 1) % FS_BLOCK_SIZE) ==
	     handlePtr->lastByte) && 
	     ((handlePtr->flags & FSIO_PIPE_READER_GONE) == 0)) {
	    if (waitPtr != (Sync_RemoteWaiter *)NIL) {
		Fsutil_FastWaitListInsert(&handlePtr->writeWaitList, waitPtr);
	    }
	    *writePtr = 0;
	}
    }
    if (*readPtr) {
	/*
	 * If there's data to be read then set the READABLE bit.
	 * If all the writers have died, then this process will never be 
	 * woken up again so lie and say the pipe is readble. The process
	 * discover there's no writer when it tries to read the pipe.
	 */
	if ((handlePtr->firstByte == -1) &&
	    ((handlePtr->flags & FSIO_PIPE_WRITER_GONE) == 0)) {
	    *readPtr = 0;
	    if (waitPtr != (Sync_RemoteWaiter *)NIL) {
		Fsutil_FastWaitListInsert(&handlePtr->readWaitList, waitPtr);
	    }
        }
    }
    Fsutil_HandleUnlock(hdrPtr);
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * Fsio_PipeGetIOAttr --
 *
 *	Get the most up-to-date I/O attributes for a pipe.
 *
 * Results:
 *	SUCCESS
 *
 * Side effects:
 *      Updates the first and last byte indexes of the handle.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Fsio_PipeGetIOAttr(fileIDPtr, clientID, attrPtr)
    Fs_FileID			*fileIDPtr;	/* FileID of pipe */
    int 			clientID;	/* IGNORED */
    register Fs_Attributes	*attrPtr;	/* Attributes to update */
{
    Fsio_PipeIOHandle *handlePtr;

    handlePtr = Fsutil_HandleFetchType(Fsio_PipeIOHandle, fileIDPtr);
    if (handlePtr != (Fsio_PipeIOHandle *)NIL) {
	attrPtr->serverID	= fileIDPtr->serverID;
	attrPtr->domain		= fileIDPtr->major;
	attrPtr->fileNumber	= fileIDPtr->minor;
	attrPtr->type		= FS_LOCAL_PIPE;
	attrPtr->size		= handlePtr->lastByte - handlePtr->firstByte +1;
	attrPtr->devServerID	= fileIDPtr->serverID;
	Fsutil_HandleRelease(handlePtr, TRUE);
    }
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * Fsio_PipeSetIOAttr --
 *
 *	Set the I/O attributes for a pipe.  This doesn't do anything.
 *
 * Results:
 *	SUCCESS
 *
 * Side effects:
 *      Updates the first and last byte indexes of the handle.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Fsio_PipeSetIOAttr(fileIDPtr, attrPtr, flags)
    Fs_FileID		*fileIDPtr;	/* FileID of pipe */
    Fs_Attributes	*attrPtr;	/* Attributes to update */
    int			flags;		/* What attrs to set */
{
    return(SUCCESS);
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fsio_PipeMigClose --
 *
 *	Release a reference on a Pipe I/O handle.
 *	
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Release the I/O handle.
 *
 * ----------------------------------------------------------------------------
 *
 */
/*ARGSUSED*/
ReturnStatus
Fsio_PipeMigClose(hdrPtr, flags)
    Fs_HandleHeader *hdrPtr;	/* File being released */
    int flags;			/* Use flags from the stream */
{
    panic("Fsio_PipeMigClose called\n");
    Fsutil_HandleRelease(hdrPtr, FALSE);
    return(SUCCESS);
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fsio_PipeMigrate --
 *
 *	This takes care of transfering references from one client to the other.
 *	A useful side-effect of this routine is	to properly set the type in
 *	the ioFileID, either FSIO_LCL_PIPE_STREAM or FSIO_RMT_PIPE_STREAM.
 *	In the latter case FsrmtPipeMigrate is called to do all the work.
 *
 * Results:
 *	An error status if the I/O handle can't be set-up.
 *	Otherwise SUCCESS is returned, *flagsPtr may have the FS_RMT_SHARED
 *	bit set, and *sizePtr and *dataPtr are set to reference Fsio_DeviceState.
 *
 * Side effects:
 *	Sets the correct stream type on the ioFileID.
 *	Shifts client references from the srcClient to the destClient.
 *
 * ----------------------------------------------------------------------------
 *
 */
/*ARGSUSED*/
ReturnStatus
Fsio_PipeMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr, sizePtr, dataPtr)
    Fsio_MigInfo	*migInfoPtr;	/* Migration state */
    int		dstClientID;	/* ID of target client */
    int		*flagsPtr;	/* In/Out Stream usage flags */
    int		*offsetPtr;	/* Return - new stream offset (not needed) */
    int		*sizePtr;	/* Return - sizeof(Fsio_DeviceState) */
    Address	*dataPtr;	/* Return - pointer to Fsio_DeviceState */
{
    Fsio_PipeIOHandle			*handlePtr;
    Boolean				closeSrcClient;

    if (migInfoPtr->ioFileID.serverID != rpc_SpriteID) {
	/*
	 * The pipe was local, which is usually true, but is now remote.
	 */
	migInfoPtr->ioFileID.type = FSIO_RMT_PIPE_STREAM;
	return(FsrmtPipeMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr,
		sizePtr, dataPtr));
    }
    migInfoPtr->ioFileID.type = FSIO_LCL_PIPE_STREAM;
    handlePtr = Fsio_PipeHandleInit(&migInfoPtr->ioFileID, TRUE);

    PIPE_MIG_1(migInfoPtr, dstClientID);
    /*
     * At the stream level, add the new client to the set of clients
     * for the stream, and check for any cross-network stream sharing.
     */
    Fsio_StreamMigClient(migInfoPtr, dstClientID, (Fs_HandleHeader *)handlePtr,
		    &closeSrcClient);
/* XXX The above is a reference to the remote guy we've got a handle for,
 * since we're the server and have the ioHandle with the buffer.  I guess this
 * means that closeSrcClient must be false?  Or maybe both things happen and
 * this is used for unmigrating too?
 */
    PIPE_MIG_2(migInfoPtr, closeSrcClient, handlePtr);

    /*
     * Adjust use counts on the I/O handle to reflect any new sharing.
     */
    Fsio_MigrateUseCounts(migInfoPtr->flags, closeSrcClient, &handlePtr->use);
    PIPE_MIG_3(handlePtr);

    /*
     * Move the client at the I/O handle level.
     */
/* XXX Do I need to do something here? */
    Fsio_MigrateClient(&handlePtr->clientList, migInfoPtr->srcClientID,
			dstClientID, migInfoPtr->flags, closeSrcClient);

/* XXX So now put newish handle in recov table? */
    *sizePtr = 0;
    *dataPtr = (Address)NIL;
    *flagsPtr = migInfoPtr->flags;
    *offsetPtr = migInfoPtr->offset;
    /*
     * We don't need this reference on the I/O handle; there is no change.
     */
    Fsutil_HandleRelease(handlePtr, TRUE);
    return(SUCCESS);
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fsio_PipeMigOpen --
 *
 *	Complete setup of a FSIO_LCL_PIPE_STREAM after migration (back) to the
 *	pipe I/O server.  Fsio_PipeMigrate has done the work of shifting use
 *	counts at the stream and I/O handle level.  This routine has to
 *	increment the low level reference count on the pipe I/O handle
 *	to reflect the existence of a new stream to the I/O handle.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 *
 */
/*ARGSUSED*/
ReturnStatus
Fsio_PipeMigOpen(migInfoPtr, size, data, hdrPtrPtr)
    Fsio_MigInfo	*migInfoPtr;	/* Migration state */
    int		size;		/* Zero */
    ClientData	data;		/* NIL */
    Fs_HandleHeader **hdrPtrPtr;	/* Return - handle for the file */
{
    register Fsio_PipeIOHandle *handlePtr;

    handlePtr = Fsutil_HandleFetchType(Fsio_PipeIOHandle, &migInfoPtr->ioFileID);
    if (handlePtr == (Fsio_PipeIOHandle *)NIL) {
	panic( "Fsio_PipeMigOpen, no handle\n");
	return(FAILURE);
    } else {
	PIPE_MIG_END(handlePtr);
	Fsutil_HandleUnlock(handlePtr);
	*hdrPtrPtr = (Fs_HandleHeader *)handlePtr;
	return(SUCCESS);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Fsio_PipeReopen --
 *
 *	Reopen a pipe for a client.  This executed on a server and will
 *	only work if it was a network partition that made us forget
 *	about the client.  If we've already removed the pipe handle
 *	then the clien't won't be able to recover.
 *
 * Results:
 *	A  non-SUCCESS return code if the re-open failed.
 *
 * Side effects:
 *	Adds the client to the set of client's for the pipe.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Fsio_PipeReopen(hdrPtr, clientID, inData, outSizePtr, outDataPtr)
    Fs_HandleHeader	*hdrPtr;		/* NIL */
    int			clientID;		/* Host ID of client */
    ClientData		inData;			/* sizeof Fsio_PipeReopenParams */
    int			*outSizePtr;		/* Returns 0 */
    ClientData		*outDataPtr;		/* Returns NIL */
{
    register Fsio_PipeIOHandle	*handlePtr;
    ReturnStatus		status;
    Fsio_PipeReopenParams		*reopenParamsPtr;

    reopenParamsPtr = (Fsio_PipeReopenParams *)inData;
    *outSizePtr = 0;
    *outDataPtr = (ClientData)NIL;

    /*
     * Old clients may still do reopens of pipes with no references (at least,
     * they do this with devices with no references), so protect ourselves
     * here on the server.  But since we don't recover pipes except after
     * network partitions, this may not be necessary.
     */
    if (reopenParamsPtr->use.ref == 0) {
	return SUCCESS;
    }

    handlePtr = Fsutil_HandleFetchType(Fsio_PipeIOHandle, &reopenParamsPtr->fileID);
    if (handlePtr == (Fsio_PipeIOHandle *)NIL) {
	status = FAILURE;
    } else {
	Fsconsist_IOClientStatus(&handlePtr->clientList, clientID,
				 &reopenParamsPtr->use);
	(void)Fsconsist_IOClientReopen(&handlePtr->clientList, clientID,
				 &reopenParamsPtr->use);
	handlePtr->use.ref += reopenParamsPtr->use.ref;
	handlePtr->use.write += reopenParamsPtr->use.write;
	Fsutil_HandleRelease(handlePtr, TRUE);
	status = SUCCESS;
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * Fsio_PipeClientKill --
 *
 *	Clean up after a crashed client.  Note, this doesn't handle the
 *	obscure case of one end of a pipe being duplicated and then
 *	one of the sharers migrating to a host which crashes.  In this
 *	funny case we'll wrongly think that all users of one end of
 *	the pipe have crashed.
 *
 * Results:
 *      SUCCESS.
 *
 * Side effects:
 *      Removes the client (if applicable) from the pipe's set of clients.
 *	This will cause a FS_BROKEN_PIPE error unless the pipe is re-opened,
 *	which might happen in a network partition.  This unlocks the handle.
 *
 *----------------------------------------------------------------------
 */
void
Fsio_PipeClientKill(hdrPtr, clientID)
    Fs_HandleHeader *hdrPtr;     /* Handle to clean up */
    int clientID;		/* Host assumed down */
{
    register Fsio_PipeIOHandle *handlePtr = (Fsio_PipeIOHandle *)hdrPtr;
    int refs, writes, execs;
    register ReturnStatus status;

    Fsconsist_IOClientKill(&handlePtr->clientList, clientID, &refs, &writes, &execs);
    status = PipeCloseInt(handlePtr, refs, writes, FALSE);
    if (status != FS_FILE_REMOVED) {
	Fsutil_HandleUnlock(handlePtr);
    }
}


/*
 *----------------------------------------------------------------------
 *
 * Fsio_PipeScavenge --
 *
 *	Scavenge a pipe.  The handle might be usless if all its
 *	client's have crashed.
 *
 * Results:
 *      TRUE if the handle was removed.
 *
 * Side effects:
 *      Unlocks the pipe's handle.
 *
 *----------------------------------------------------------------------
 */
Boolean
Fsio_PipeScavenge(hdrPtr)
    Fs_HandleHeader *hdrPtr;     /* Handle about to be deleted */
{
#ifdef notdef
    register Fsio_PipeIOHandle *handlePtr = (Fsio_PipeIOHandle *)hdrPtr;
    if (List_IsEmpty(&handlePtr->clientList) &&
	(handlePtr->flags == (FSIO_PIPE_WRITER_GONE|FSIO_PIPE_READER_GONE))) {
	/*
	 * Never scavenge pipe handles.  Regular recovery cleanup
	 * should invoke the pipe close routines and do proper cleanup.
	 */
	free(handlePtr->buffer);
	Fsutil_WaitListDelete(&handlePtr->readWaitList);
	Fsutil_WaitListDelete(&handlePtr->writeWaitList);
	Fsutil_HandleRemove(hdrPtr);
	fs_Stats.object.pipes--;
	return(TRUE);
    }
#endif notdef
    Fsutil_HandleUnlock(hdrPtr);
    return(FALSE);
}


/*
 *----------------------------------------------------------------------
 *
 * Fsio_PipeRecovTestUseCount --
 *
 *	For recovery testing, return the use count on the io handle.
 *
 * Results:
 *      The use count.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
int
Fsio_PipeRecovTestUseCount(handlePtr)
    Fsio_PipeIOHandle *handlePtr;
{
    return handlePtr->use.ref;
}


/*
 *----------------------------------------------------------------------
 *
 * Fsio_PipeSetupHandle --
 *
 *	Given a pipe recovery object, setup the necessary handle state for it.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A handle is created in put in the handle table.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
Fsio_PipeSetupHandle(recovInfoPtr)
    Fsrecov_HandleState	*recovInfoPtr;
{
    Fs_FileID		fileID;
    int			clientID;
    Fsio_PipeIOHandle	*handlePtr;

    if (!recov_Transparent) {
	panic("Fsio_PipeSetupHandle: shouldn't have been called.");
    }
    fileID = recovInfoPtr->fileID;
    clientID = fileID.serverID;
    fileID.serverID = rpc_SpriteID;

    handlePtr = Fsutil_HandleFetchType(Fsio_PipeIOHandle, &fileID);
    if (handlePtr == (Fsio_PipeIOHandle *) NIL) {
	return FAILURE;
    }
    (void)Fsconsist_IOClientReopen(&handlePtr->clientList, clientID,
	    &recovInfoPtr->use);
    handlePtr->use.ref += recovInfoPtr->use.ref;
    handlePtr->use.write += recovInfoPtr->use.write;
    Fsutil_HandleRelease(handlePtr, TRUE);

    return SUCCESS;
}
@


9.11
log
@Fixed lint errors and removed tracing.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsioPipe.c,v 9.10 91/03/30 17:10:09 mgbaker Exp Locker: rab $ SPRITE (Berkeley)";
d32 1
d934 5
d950 1
d954 1
d1040 13
a1065 2
    *outSizePtr = 0;
    *outDataPtr = (ClientData)NIL;
d1168 44
@


9.10
log
@Got rid of FS_CONSUME flag.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsioPipe.c,v 9.9 90/12/06 21:56:46 jhh Exp Locker: mgbaker $ SPRITE (Berkeley)";
a268 1
#ifndef SOSP91
a270 5
#else
ReturnStatus
Fsio_PipeClose(streamPtr, clientID, procID, flags, dataSize, closeData,
    offsetPtr, rwFlagsPtr)
#endif
a276 5
#ifdef SOSP91
    int			*offsetPtr;	/* Not used. */
    int			*rwFlagsPtr;	/* Not used. */
#endif

@


9.10.1.1
log
@Initial branch for Sprite server.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fsio/fsioPipe.c,v 9.10 91/03/30 17:10:09 mgbaker Exp $ SPRITE (Berkeley)";
@


9.9
log
@Added sosp tracing code
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsioPipe.c,v 9.8 90/10/08 15:55:34 mendel Exp Locker: jhh $ SPRITE (Berkeley)";
d143 1
a143 1
			    FS_READ | FS_CONSUME | FS_USER, "read-pipe");
@


9.8
log
@Changed name to fsioPipe.c
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs.mendel/RCS/fsPipe.c,v 1.1 90/01/16 17:11:18 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d269 1
d272 5
d283 5
@


9.7
log
@fixed bug with not releasing reference on the handle after getting attrs.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsPipe.c,v 9.6 90/08/07 10:51:56 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d17 1
a17 1
#include "sprite.h"
d19 11
a29 11
#include "fs.h"
#include "fsutil.h"
#include "fsio.h"
#include "fsNameOps.h"
#include "fsconsist.h"
#include "fsStat.h"
#include "fsrmt.h"
#include "vm.h"
#include "proc.h"
#include "rpc.h"
#include "fsioPipe.h"
d31 2
d42 5
a46 3
static void GetFileID();
Fsio_PipeIOHandle *Fsio_PipeHandleInit();
static ReturnStatus PipeCloseInt();
d225 2
a226 1
    found = Fsutil_HandleInstall(fileIDPtr, sizeof(Fsio_PipeIOHandle), "pipe", &hdrPtr);
d905 1
a905 1
    FsMigInfo	*migInfoPtr;	/* Migration state */
d981 1
a981 1
    FsMigInfo	*migInfoPtr;	/* Migration state */
@


9.6
log
@fixed stupid, stupid bug that passed wrong number of arguments to PipeCloseInt,
causing it never to release handles for pipes before attempting to remove them.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsPipe.c,v 9.5 90/07/15 13:36:32 shirriff Exp Locker: douglis $ SPRITE (Berkeley)";
d818 1
a818 1
	Fsutil_HandleUnlock(handlePtr);
@


9.5
log
@Fixed locking.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsPipe.c,v 9.4 90/06/27 11:16:50 douglis Exp $ SPRITE (Berkeley)";
d283 1
a283 2
	status = PipeCloseInt(handlePtr, 1, (flags & FS_WRITE) != 0,
			      (flags & FS_EXECUTE) != 0, TRUE);
@


9.4
log
@fixed bug that caused crash if migrated pipe was closed due to a crash
callback. instead, handle the reference counts like multiple closes,
just like in fsFile.c
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsPipe.c,v 9.3 90/05/23 14:13:50 jhh Exp Locker: douglis $ SPRITE (Berkeley)";
d347 1
a347 1
	    Fsutil_HandleRelease(handlePtr, TRUE);
@


9.3
log
@Does not return SUCCESS and expect a retry.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio.jhh/RCS/fsPipe.c,v 9.2 89/11/27 14:26:58 mgbaker Exp Locker: jhh $ SPRITE (Berkeley)";
d40 1
a40 1
void GetFileID();
d42 1
d179 1
a179 1
ENTRY void
d276 1
d282 5
a286 11
	/*
	 * Update the global/summary use counts for the file.
	 */
	handlePtr->use.ref--;
	if (flags & FS_WRITE) {
	    handlePtr->use.write--;
	}
	if (handlePtr->use.ref < 0 || handlePtr->use.write < 0) {
	    panic("Fsio_PipeClose <%d,%d> use %d, write %d\n",
		      handlePtr->hdr.fileID.major, handlePtr->hdr.fileID.minor,
		      handlePtr->use.ref, handlePtr->use.write);
d288 69
a356 26
	if ((flags & FS_WRITE) && handlePtr->use.write == 0) {
	    /*
	     * Notify reader that the writer has closed.
	     */
	    handlePtr->flags |= FSIO_PIPE_WRITER_GONE;
	    Fsutil_FastWaitListNotify(&handlePtr->readWaitList);
	} else if ((flags & FS_READ) &&
		    handlePtr->use.ref == handlePtr->use.write) {
	    /*
	     * Update state and notify any blocked writers.  Their write
	     * will fail with no remaining readers.
	     */
	    handlePtr->flags |= FSIO_PIPE_READER_GONE;
	    Fsutil_FastWaitListNotify(&handlePtr->writeWaitList);
	}
	PIPE_CLOSE(streamPtr, handlePtr);
	Fsutil_HandleRelease(handlePtr, TRUE);
	if (handlePtr->flags == (FSIO_PIPE_WRITER_GONE|FSIO_PIPE_READER_GONE)) {
	    free(handlePtr->buffer);
	    Fsutil_WaitListDelete(&handlePtr->readWaitList);
	    Fsutil_WaitListDelete(&handlePtr->writeWaitList);
	    Fsutil_HandleRemove(handlePtr);
	    fs_Stats.object.pipes--;
	}
    }
    return(SUCCESS);
d1074 1
d1077 3
a1079 6
    if (refs > 0) {
	if (writes) {
	    handlePtr->flags |= FSIO_PIPE_WRITER_GONE;
	} else {
	    handlePtr->flags |= FSIO_PIPE_READER_GONE;
	}
a1080 1
    Fsutil_HandleUnlock(handlePtr);
@


9.2
log
@Adding new stats syscall command.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsPipe.c,v 9.1 89/10/23 14:09:12 brent Exp Locker: mgbaker $ SPRITE (Berkeley)";
d508 1
a508 3
#ifdef notdef
    } else if ((writePtr->length > toWrite) &&
	       ((flags & FS_NON_BLOCKING) == 0)) {
d511 1
a511 7
	 * data that we can.  If the stream is non-blocking, however, we
	 * return a successful error code after writing what we can.
	 *
	 * Fs_Write takes care of returning the correct code.  We should
	 * be able to return SUCCESS if we return some data, and
	 * FS_WOULD_BLOCK if we return no data.  Fs_Write looks at the
	 * stream flags for us and "does the right thing" with partial writes.
a513 1
#endif
@


9.1
log
@Changed typedef to FsioStreamClient
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsPipe.c,v 8.19 89/08/21 15:26:02 mendel Exp $ SPRITE (Berkeley)";
d1097 22
@


9.0
log
@Changing version numbers.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsio/RCS/fsPipe.c,v 8.19 89/08/21 15:26:02 mendel Exp Locker: douglis $ SPRITE (Berkeley)";
d910 1
a910 1
    Fsio_IOClientMigrate(&handlePtr->clientList, migInfoPtr->srcClientID,
@


8.19
log
@Break up fs into many modules.    
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.17 89/07/18 13:08:15 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
@


8.18
log
@Changed to use Fmt_Convert
@
text
@d18 1
d20 4
a23 7
#include "fsInt.h"
#include "fsPipe.h"
#include "fsOpTable.h"
#include "fsStream.h"
#include "fsMigrate.h"
#include "fsRecovery.h"
#include "fsClient.h"
d25 1
a25 1

d29 1
d41 1
a41 1
FsPipeIOHandle *FsPipeHandleInit();
d100 1
a100 1
 * Fs_CreatePipe --
d115 1
a115 1
Fs_CreatePipe(inStreamPtrPtr, outStreamPtrPtr)
d120 1
a120 1
    register FsPipeIOHandle	*handlePtr;
d129 3
a131 3
    handlePtr = FsPipeHandleInit(&fileID, FALSE);
    (void)FsIOClientOpen(&handlePtr->clientList, rpc_SpriteID, FS_READ, FALSE);
    (void)FsIOClientOpen(&handlePtr->clientList, rpc_SpriteID, FS_WRITE, FALSE);
d136 2
a137 2
    streamPtr = FsStreamNewClient(rpc_SpriteID, rpc_SpriteID,
			    (FsHandleHeader *)handlePtr,
d139 1
a139 1
    FsHandleUnlock(streamPtr);
d146 4
a149 4
    FsHandleUnlock(handlePtr);
    (void)FsHandleDup((FsHandleHeader *)handlePtr);
    streamPtr = FsStreamNewClient(rpc_SpriteID, rpc_SpriteID,
			(FsHandleHeader *)handlePtr,
d151 2
a152 2
    FsHandleUnlock(handlePtr);
    FsHandleUnlock(streamPtr);
d186 1
a186 1
    fileIDPtr->type = FS_LCL_PIPE_STREAM;
d198 1
a198 1
 * FsPipeHandleInit --
d211 2
a212 2
FsPipeIOHandle *
FsPipeHandleInit(fileIDPtr, findIt)
d216 2
a217 2
    FsHandleHeader *hdrPtr;
    register FsPipeIOHandle *handlePtr;
d220 2
a221 2
    found = FsHandleInstall(fileIDPtr, sizeof(FsPipeIOHandle), "pipe", &hdrPtr);
    handlePtr = (FsPipeIOHandle *)hdrPtr;
d224 1
a224 1
	    panic( "FsPipeHandleInit, didn't find handle\n");
d240 1
a240 1
	fsStats.object.pipes++;
d248 1
a248 1
 * FsPipeClose --
d264 1
a264 1
FsPipeClose(streamPtr, clientID, procID, flags, dataSize, closeData)
d272 2
a273 2
    register FsPipeIOHandle *handlePtr = 
	    (FsPipeIOHandle *)streamPtr->ioHandlePtr;
d276 3
a278 3
    if (!FsIOClientClose(&handlePtr->clientList, clientID, flags, &cache)) {
	printf( "FsPipeClose, unknown client %d\n", clientID);
	FsHandleUnlock(handlePtr);
d288 1
a288 1
	    panic("FsPipeClose <%d,%d> use %d, write %d\n",
d296 2
a297 2
	    handlePtr->flags |= PIPE_WRITER_GONE;
	    FsFastWaitListNotify(&handlePtr->readWaitList);
d304 2
a305 2
	    handlePtr->flags |= PIPE_READER_GONE;
	    FsFastWaitListNotify(&handlePtr->writeWaitList);
d308 2
a309 2
	FsHandleRelease(handlePtr, TRUE);
	if (handlePtr->flags == (PIPE_WRITER_GONE|PIPE_READER_GONE)) {
d311 4
a314 4
	    FsWaitListDelete(&handlePtr->readWaitList);
	    FsWaitListDelete(&handlePtr->writeWaitList);
	    FsHandleRemove(handlePtr);
	    fsStats.object.pipes--;
d323 1
a323 1
 * FsPipeRead --
d341 1
a341 1
FsPipeRead(streamPtr, readPtr, waitPtr, replyPtr)
d349 2
a350 2
    register FsPipeIOHandle *handlePtr =
	    (FsPipeIOHandle *)streamPtr->ioHandlePtr;
d356 1
a356 1
    FsHandleLock(handlePtr);
d365 1
a365 1
	if (handlePtr->flags & PIPE_WRITER_GONE) {
d427 1
a427 1
    FsFastWaitListNotify(&handlePtr->writeWaitList);
d440 1
a440 1
	FsFastWaitListInsert(&handlePtr->readWaitList, waitPtr);
d442 1
a442 1
    FsHandleUnlock(handlePtr);
d450 1
a450 1
 * FsPipeWrite --
d466 1
a466 1
FsPipeWrite(streamPtr, writePtr, waitPtr, replyPtr)
d473 2
a474 2
    register FsPipeIOHandle	*handlePtr =
	    (FsPipeIOHandle *)streamPtr->ioHandlePtr;
d480 1
a480 1
    FsHandleLock(handlePtr);
d482 1
a482 1
    if (handlePtr->flags & PIPE_READER_GONE) {
d569 1
a569 1
    FsFastWaitListNotify(&handlePtr->readWaitList);
d581 1
a581 1
	FsFastWaitListInsert(&handlePtr->writeWaitList, waitPtr);
d583 1
a583 1
    FsHandleUnlock(handlePtr);
d591 1
a591 1
 * FsPipeIOControl --
d605 1
a605 1
FsPipeIOControl(streamPtr, ioctlPtr, replyPtr)
d610 2
a611 2
    register FsPipeIOHandle *handlePtr =
	    (FsPipeIOHandle *)streamPtr->ioHandlePtr;
d699 1
a699 1
 * FsPipeSelect --
d712 2
a713 2
FsPipeSelect(hdrPtr, waitPtr, readPtr, writePtr, exceptPtr)
    FsHandleHeader *hdrPtr;	/* The handle of the file */
d719 1
a719 1
    register FsPipeIOHandle *handlePtr = (FsPipeIOHandle *)hdrPtr;
d721 1
a721 1
    FsHandleLock(hdrPtr);
d731 1
a731 1
	     ((handlePtr->flags & PIPE_READER_GONE) == 0)) {
d733 1
a733 1
		FsFastWaitListInsert(&handlePtr->writeWaitList, waitPtr);
d746 1
a746 1
	    ((handlePtr->flags & PIPE_WRITER_GONE) == 0)) {
d749 1
a749 1
		FsFastWaitListInsert(&handlePtr->readWaitList, waitPtr);
d753 1
a753 1
    FsHandleUnlock(hdrPtr);
d760 1
a760 1
 * FsPipeGetIOAttr --
d774 1
a774 1
FsPipeGetIOAttr(fileIDPtr, clientID, attrPtr)
d779 1
a779 1
    FsPipeIOHandle *handlePtr;
d781 2
a782 2
    handlePtr = FsHandleFetchType(FsPipeIOHandle, fileIDPtr);
    if (handlePtr != (FsPipeIOHandle *)NIL) {
d789 1
a789 1
	FsHandleUnlock(handlePtr);
d797 1
a797 1
 * FsPipeSetIOAttr --
d811 1
a811 1
FsPipeSetIOAttr(fileIDPtr, attrPtr, flags)
d822 1
a822 1
 * FsPipeRelease --
d837 2
a838 2
FsPipeRelease(hdrPtr, flags)
    FsHandleHeader *hdrPtr;	/* File being released */
d841 2
a842 2
    panic("FsPipeRelease called\n");
    FsHandleRelease(hdrPtr, FALSE);
d849 1
a849 1
 * FsPipeMigrate --
d853 2
a854 2
 *	the ioFileID, either FS_LCL_PIPE_STREAM or FS_RMT_PIPE_STREAM.
 *	In the latter case FsRmtPipeMigrate is called to do all the work.
d859 1
a859 1
 *	bit set, and *sizePtr and *dataPtr are set to reference FsDeviceState.
d870 1
a870 1
FsPipeMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr, sizePtr, dataPtr)
d875 2
a876 2
    int		*sizePtr;	/* Return - sizeof(FsDeviceState) */
    Address	*dataPtr;	/* Return - pointer to FsDeviceState */
d878 1
a878 1
    FsPipeIOHandle			*handlePtr;
d885 2
a886 2
	migInfoPtr->ioFileID.type = FS_RMT_PIPE_STREAM;
	return(FsRmtPipeMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr,
d889 2
a890 2
    migInfoPtr->ioFileID.type = FS_LCL_PIPE_STREAM;
    handlePtr = FsPipeHandleInit(&migInfoPtr->ioFileID, TRUE);
d897 1
a897 1
    FsStreamMigClient(migInfoPtr, dstClientID, (FsHandleHeader *)handlePtr,
d904 1
a904 1
    FsMigrateUseCounts(migInfoPtr->flags, closeSrcClient, &handlePtr->use);
d910 1
a910 1
    FsIOClientMigrate(&handlePtr->clientList, migInfoPtr->srcClientID,
d920 1
a920 1
    FsHandleRelease(handlePtr, TRUE);
d927 1
a927 58
 * FsRmtPipeMigrate --
 *
 *	This takes care of transfering references from one client to the other.
 *	A useful side-effect of this routine is	to properly set the type in
 *	the ioFileID, either FS_LCL_PIPE_STREAM or FS_RMT_PIPE_STREAM,
 *	so that the subsequent call to FsRemoteIOMigEnd will set up
 *	the right I/O handle.
 *
 * Results:
 *	An error status if the I/O handle can't be set-up.
 *	Otherwise SUCCESS is returned, *flagsPtr may have the FS_RMT_SHARED
 *	bit set, and *sizePtr and *dataPtr are set to reference FsDeviceState.
 *
 * Side effects:
 *	Sets the correct stream type on the ioFileID.
 *	Shifts client references from the srcClient to the destClient.
 *	Set up and return FsDeviceState for use by the MigEnd routine.
 *
 * ----------------------------------------------------------------------------
 *
 */
/*ARGSUSED*/
ReturnStatus
FsRmtPipeMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr, sizePtr, dataPtr)
    FsMigInfo	*migInfoPtr;	/* Migration state */
    int		dstClientID;	/* ID of target client */
    int		*flagsPtr;	/* In/Out Stream usage flags */
    int		*offsetPtr;	/* Return - new stream offset (not needed) */
    int		*sizePtr;	/* Return - sizeof(FsDeviceState) */
    Address	*dataPtr;	/* Return - pointer to FsDeviceState */
{
    register ReturnStatus		status;

    if (migInfoPtr->ioFileID.serverID == rpc_SpriteID) {
	/*
	 * The pipe was remote, which is why we were called, but is now local.
	 */
	migInfoPtr->ioFileID.type = FS_LCL_PIPE_STREAM;
	return(FsPipeMigrate(migInfoPtr, dstClientID, flagsPtr, offsetPtr,
		sizePtr, dataPtr));
    }
    migInfoPtr->ioFileID.type = FS_RMT_PIPE_STREAM;
    status = FsNotifyOfMigration(migInfoPtr, flagsPtr, offsetPtr,
				 0, (Address)NIL);
    if (status != SUCCESS) {
	printf( "FsRmtPipeMigrate, server error <%x>\n",
	    status);
    } else {
	*dataPtr = (Address)NIL;
	*sizePtr = 0;
    }
    return(status);
}

/*
 * ----------------------------------------------------------------------------
 *
 * FsPipeMigEnd --
d929 2
a930 2
 *	Complete setup of a FS_LCL_PIPE_STREAM after migration (back) to the
 *	pipe I/O server.  FsPipeMigrate has done the work of shifting use
d946 1
a946 1
FsPipeMigEnd(migInfoPtr, size, data, hdrPtrPtr)
d950 1
a950 1
    FsHandleHeader **hdrPtrPtr;	/* Return - handle for the file */
d952 1
a952 1
    register FsPipeIOHandle *handlePtr;
d954 3
a956 3
    handlePtr = FsHandleFetchType(FsPipeIOHandle, &migInfoPtr->ioFileID);
    if (handlePtr == (FsPipeIOHandle *)NIL) {
	panic( "FsPipeMigEnd, no handle\n");
d960 2
a961 2
	FsHandleUnlock(handlePtr);
	*hdrPtrPtr = (FsHandleHeader *)handlePtr;
d969 1
a969 99
 * FsRmtPipeVerify --
 *
 *	Verify that the remote client is known for the pipe, and return
 *	a locked pointer to the pipe's I/O handle.
 *
 * Results:
 *	A pointer to the I/O handle for the pipe, or NIL if
 *	the client is bad.
 *
 * Side effects:
 *	The handle is returned locked and with its refCount incremented.
 *	It should be released with FsHandleRelease.
 *
 *----------------------------------------------------------------------
 */

FsHandleHeader *
FsRmtPipeVerify(fileIDPtr, clientID, domainTypePtr)
    Fs_FileID	*fileIDPtr;	/* Client's I/O file ID */
    int		clientID;	/* Host ID of the client */
    int		*domainTypePtr;	/* Return - FS_LOCAL_DOMAIN */
{
    register FsPipeIOHandle	*handlePtr;
    register FsClientInfo	*clientPtr;
    Boolean			found = FALSE;

    fileIDPtr->type = FS_LCL_PIPE_STREAM;
    handlePtr = FsHandleFetchType(FsPipeIOHandle, fileIDPtr);
    if (handlePtr != (FsPipeIOHandle *)NIL) {
	LIST_FORALL(&handlePtr->clientList, (List_Links *) clientPtr) {
	    if (clientPtr->clientID == clientID) {
		found = TRUE;
		break;
	    }
	}
	if (!found) {
	    FsHandleRelease(handlePtr, TRUE);
	    handlePtr = (FsPipeIOHandle *)NIL;
	}
    }
    if (!found) {
	printf(
	    "FsRmtPipeVerify, client %d not known for pipe <%d,%d>\n",
	    clientID, fileIDPtr->major, fileIDPtr->minor);
    }
    if (domainTypePtr != (int *)NIL) {
	*domainTypePtr = FS_LOCAL_DOMAIN;
    }
    return((FsHandleHeader *)handlePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * FsRmtPipeReopen --
 *
 *	Reopen a remote pipe.  This sets up and conducts an 
 *	RPC_FS_REOPEN remote procedure call to re-open the remote pipe.
 *
 * Results:
 *	A  non-SUCCESS return code if the re-open failed.
 *
 * Side effects:
 *	If the reopen works we'll have a valid I/O handle.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
FsRmtPipeReopen(hdrPtr, clientID, inData, outSizePtr, outDataPtr)
    FsHandleHeader	*hdrPtr;
    int			clientID;		/* Should be rpc_SpriteID */
    ClientData		inData;			/* IGNORED */
    int			*outSizePtr;		/* IGNORED */
    ClientData		*outDataPtr;		/* IGNORED */
{
    register FsRemoteIOHandle	*rmtHandlePtr;
    ReturnStatus		status;
    FsPipeReopenParams		reopenParams;
    int				outSize;

    rmtHandlePtr = (FsRemoteIOHandle *)hdrPtr;
    reopenParams.fileID = hdrPtr->fileID;
    reopenParams.fileID.type = FS_LCL_PIPE_STREAM;
    reopenParams.use = rmtHandlePtr->recovery.use;

    /*
     * Contact the server to do the reopen, and then notify waiters.
     */
    outSize = 0;
    status = FsSpriteReopen(hdrPtr, sizeof(FsPipeReopenParams),
		(Address)&reopenParams, &outSize, (Address)NIL);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * FsPipeReopen --
d986 2
a987 2
FsPipeReopen(hdrPtr, clientID, inData, outSizePtr, outDataPtr)
    FsHandleHeader	*hdrPtr;		/* NIL */
d989 1
a989 1
    ClientData		inData;			/* sizeof FsPipeReopenParams */
d993 1
a993 1
    register FsPipeIOHandle	*handlePtr;
d995 1
a995 1
    FsPipeReopenParams		*reopenParamsPtr;
d997 3
a999 3
    reopenParamsPtr = (FsPipeReopenParams *)inData;
    handlePtr = FsHandleFetchType(FsPipeIOHandle, &reopenParamsPtr->fileID);
    if (handlePtr == (FsPipeIOHandle *)NIL) {
d1002 1
a1002 1
	FsIOClientStatus(&handlePtr->clientList, clientID,
d1004 1
a1004 1
	(void)FsIOClientReopen(&handlePtr->clientList, clientID,
d1008 1
a1008 1
	FsHandleRelease(handlePtr, TRUE);
d1019 1
a1019 1
 * FsPipeClientKill --
d1038 2
a1039 2
FsPipeClientKill(hdrPtr, clientID)
    FsHandleHeader *hdrPtr;     /* Handle to clean up */
d1042 1
a1042 1
    register FsPipeIOHandle *handlePtr = (FsPipeIOHandle *)hdrPtr;
d1045 1
a1045 1
    FsIOClientKill(&handlePtr->clientList, clientID, &refs, &writes, &execs);
d1048 1
a1048 1
	    handlePtr->flags |= PIPE_WRITER_GONE;
d1050 1
a1050 1
	    handlePtr->flags |= PIPE_READER_GONE;
d1053 1
a1053 1
    FsHandleUnlock(handlePtr);
d1060 1
a1060 1
 * FsPipeScavenge --
d1074 2
a1075 2
FsPipeScavenge(hdrPtr)
    FsHandleHeader *hdrPtr;     /* Handle about to be deleted */
d1078 1
a1078 1
    register FsPipeIOHandle *handlePtr = (FsPipeIOHandle *)hdrPtr;
d1080 1
a1080 1
	(handlePtr->flags == (PIPE_WRITER_GONE|PIPE_READER_GONE))) {
d1086 4
a1089 4
	FsWaitListDelete(&handlePtr->readWaitList);
	FsWaitListDelete(&handlePtr->writeWaitList);
	FsHandleRemove(hdrPtr);
	fsStats.object.pipes--;
d1093 1
a1093 1
    FsHandleUnlock(hdrPtr);
@


8.17
log
@Added IOC_PREFIX ioctl
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.16 89/07/01 17:36:36 brent Exp $ SPRITE (Berkeley)";
a17 1

a30 1
#include "swapBuffer.h"
d629 1
d633 2
a634 1
	    } else if (ioctlPtr->byteOrder != mach_ByteOrder) {
d636 8
a643 3
		Swap_Buffer(ioctlPtr->inBuffer, ioctlPtr->inBufSize,
			    ioctlPtr->byteOrder,
			    mach_ByteOrder, "w", (Address)&flags, &size);
d668 1
a668 1
	    } else if (ioctlPtr->byteOrder != mach_ByteOrder) {
d670 9
a678 3
		Swap_Buffer((Address)&bytesAvailable, sizeof(int),
		    mach_ByteOrder, ioctlPtr->byteOrder, "w",
		    ioctlPtr->outBuffer, &size);
@


8.16
log
@Added pipe migration debugging that is enabled with -DMIG_DEBUG
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.15 89/06/22 16:30:36 brent Exp Locker: brent $ SPRITE (Berkeley)";
d679 1
@


8.15
log
@Updated reopen procedure to use FsIOClientStatus along
with FsIOClientReopen
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.14 89/06/21 12:30:40 brent Exp Locker: brent $ SPRITE (Berkeley)";
d46 53
d158 2
d291 1
a291 2
	    panic(
		      "FsPipeClose <%d,%d> use %d, write %d\n",
d310 1
d830 1
a830 1
    panic( "FsPipeRelease called\n");
d881 1
d888 2
d894 1
d1005 1
@


8.14
log
@Fixed Reopen procedure.  It must remember to
unlock its handle.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.13 89/06/16 12:06:54 brent Exp $ SPRITE (Berkeley)";
d1086 2
d1090 2
@


8.13
log
@Updated I/O Control interface
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.12 89/06/15 09:24:30 brent Exp $ SPRITE (Berkeley)";
d1088 1
@


8.12
log
@Updated read/write to use Fs_IOParam and Fs_IOReply
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.11 89/05/30 16:10:50 jhh Exp $ SPRITE (Berkeley)";
d553 1
a553 1
FsPipeIOControl(streamPtr, command, byteOrder, inBufPtr, outBufPtr)
d555 2
a556 4
    int command;
    int byteOrder;
    Fs_Buffer *inBufPtr;
    Fs_Buffer *outBufPtr;
d560 1
d576 4
a579 1
	    if (inBufPtr->size >= sizeof(int) && byteOrder != mach_ByteOrder) {
d581 2
a582 1
		Swap_Buffer(inBufPtr->addr, inBufPtr->size, byteOrder,
a586 2
	    } else if (inBufPtr->size != sizeof(int)) {
		status = GEN_INVALID_ARG;
d588 1
a588 1
		flags = *(int *)inBufPtr->addr;
d604 5
a608 3
	    int bytesAvailable;
	    bytesAvailable = handlePtr->lastByte - handlePtr->firstByte;
	    if (outBufPtr->size >= sizeof(int) && byteOrder != mach_ByteOrder) {
d611 2
a612 1
		    mach_ByteOrder, byteOrder, "w", outBufPtr->addr, &size);
a615 2
	    } else if (outBufPtr->size != sizeof(int)) {
		status = GEN_INVALID_ARG;
d617 1
a617 1
		*(int *)outBufPtr->addr = bytesAvailable;
@


8.11
log
@Removed call to Sync_LockRegister
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.10 89/05/09 13:10:39 brent Exp Locker: jhh $ SPRITE (Berkeley)";
d289 1
a289 1
FsPipeRead(streamPtr, flags, buffer, offsetPtr, lenPtr, waitPtr)
d291 4
a294 5
    int			flags;		/* FS_USER | FS_CONSUME */
    register Address    buffer;         /* Buffer to fill with file data */
    int                 *offsetPtr;     /* In/Out byte offset */
    int                 *lenPtr;        /* In/Out byte count */
    Sync_RemoteWaiter   *waitPtr;	 /* Process wait info */
d312 1
a312 1
	*lenPtr = 0;
d325 2
a326 2
    if (toRead > *lenPtr) {
	toRead = *lenPtr;
d344 2
a345 2
	if (flags & FS_USER) {
	    if (Vm_CopyOut(toRead, handlePtr->buffer + startOffset, buffer)
d350 1
a350 1
	    bcopy(handlePtr->buffer + startOffset, buffer, toRead);
d358 2
a359 2
	if (flags & FS_USER) {
	    if (Vm_CopyOut(numBytes, handlePtr->buffer + startOffset, buffer)
d363 1
a363 1
				buffer + numBytes) != SUCCESS) {
d367 2
a368 2
	    bcopy(handlePtr->buffer + startOffset, buffer, numBytes);
	    bcopy(handlePtr->buffer, buffer + numBytes, toRead - numBytes);
d385 1
a385 2
    *lenPtr = toRead;
    *offsetPtr += toRead;
d414 1
a414 1
FsPipeWrite(streamPtr, flags, buffer, offsetPtr, lenPtr, waitPtr)
d416 3
a418 7
    int			flags;		/* FS_NON_BLOCKING checked so the
					 * correct error code is returned, plus
					 * FS_USER for copying data. */
    register Address    buffer;         /* Buffer to add to the pipe */
    int                 *offsetPtr;     /* In/Out byte offset */
    int                 *lenPtr;        /* In/Out byte count */
    Sync_RemoteWaiter   *waitPtr;	 /* Process waiting info */
d431 2
a432 1
	*lenPtr = 0;
d451 1
a451 1
	*lenPtr = 0;
d454 5
a458 3
    } else if (toWrite > *lenPtr) {
	toWrite = *lenPtr;
    } else if ((*lenPtr > toWrite) && ((flags & FS_NON_BLOCKING) == 0)) {
d463 5
d470 1
d486 2
a487 2
	if (flags & FS_USER) {
	    if (Vm_CopyIn(toWrite, buffer, handlePtr->buffer + startOffset)
d492 1
a492 1
	    bcopy(buffer, handlePtr->buffer + startOffset, toWrite);
d500 2
a501 2
	if (flags & FS_USER) {
	    if (Vm_CopyIn(numBytes, buffer, handlePtr->buffer + startOffset)
d504 1
a504 1
	    } else if (Vm_CopyIn(toWrite - numBytes, buffer + numBytes, 
d509 2
a510 2
	    bcopy(buffer, handlePtr->buffer + startOffset, numBytes);
	    bcopy(buffer + numBytes, handlePtr->buffer, toWrite - numBytes);
d526 1
a526 2
    *lenPtr = toWrite;
    *offsetPtr += toWrite;
a1077 2
    register FsClientInfo	*clientPtr;
    Boolean			found;
d1084 2
a1085 17
	/*
	 * Loop through the client list to see if we know about the client.
	 */
	found = FALSE;
	LIST_FORALL(&handlePtr->clientList, (List_Links *)clientPtr) {
	    if (clientPtr->clientID == clientID) {
		found = TRUE;
		break;
	    }
	}
	if (!found) {
	    clientPtr = mnew(FsClientInfo);
	    clientPtr->clientID = clientID;
	    List_Insert((List_Links *) clientPtr,
		    LIST_ATFRONT(&handlePtr->clientList));
	}
	clientPtr->use = reopenParamsPtr->use;
d1154 1
a1155 1
#ifdef notdef
@


8.10
log
@Nuked the FsPipeScavenge routine because there is
no good reason that pipe handles should have to
be cleaned up this way.  Furthermore, this is a suspect
in a crash caused by a duplicate remove of a pipe handle.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.9 89/02/28 08:48:19 brent Exp $ SPRITE (Berkeley)";
a132 2

    Sync_LockRegister(&pipeLock);
@


8.9
log
@Changed object-specific select routines to handle NIL waitPtr information
so they can avoid setting up wait lists.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.8 89/02/14 10:56:15 jhh Exp Locker: brent $ SPRITE (Berkeley)";
d1172 1
d1175 5
a1184 3
    } else {
	FsHandleUnlock(hdrPtr);
	return(FALSE);
d1186 3
@


8.8
log
@Update Sync_Lock initialization and registration
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.7 89/02/06 17:38:32 brent Exp Locker: jhh $ SPRITE (Berkeley)";
d664 3
a666 1
	    FsFastWaitListInsert(&handlePtr->writeWaitList, waitPtr);
d679 4
a682 2
	   *readPtr = 0;
	    FsFastWaitListInsert(&handlePtr->readWaitList, waitPtr);
@


8.7
log
@Tidied up handle initialization
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.6 89/02/01 16:40:28 brent Exp $ SPRITE (Berkeley)";
d37 1
a37 1
static	Sync_Lock	pipeLock = SYNC_LOCK_INIT_STATIC();
d133 2
@


8.6
log
@fixed a typo
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.5 89/02/01 16:35:58 brent Exp $ SPRITE (Berkeley)";
d180 1
@


8.5
log
@Fixed the pipe scavenge routine
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.4 89/01/30 14:04:20 brent Exp $ SPRITE (Berkeley)";
d1170 1
a1170 1
	fsStats.object.pipes--
@


8.4
log
@Added object stats
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.3 89/01/30 09:22:18 brent Exp Locker: brent $ SPRITE (Berkeley)";
d1170 2
d1174 1
@


8.3
log
@Changed scavenge routine to a Boolean
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.2 89/01/06 11:19:23 jhh Exp $ SPRITE (Berkeley)";
d27 1
d187 1
d261 1
@


8.2
log
@new Sync_Lock definition
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 8.1 88/12/21 10:17:30 brent Exp Locker: jhh $ SPRITE (Berkeley)";
d1150 1
a1150 1
 *      SUCCESS.
d1157 1
a1157 1
void
@


8.1
log
@Double migration bug fix
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 7.0 88/11/11 15:31:07 brent Exp $ SPRITE (Berkeley)";
d36 1
a36 1
static	Sync_Lock	pipeLock = {0, 0};
@


8.0
log
@Changing version numbers.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 7.0 88/11/11 15:31:07 brent Exp Locker: douglis $ SPRITE (Berkeley)";
d801 1
d818 2
a819 1
    FsStreamMigClient(migInfoPtr, dstClientID, (FsHandleHeader *)handlePtr);
d823 1
a823 1
    FsMigrateUseCounts(migInfoPtr->flags, &handlePtr->use);
d829 1
a829 1
			dstClientID, migInfoPtr->flags);
@


7.0
log
@New version for conversion to new C library
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 6.17 88/10/20 15:48:20 brent Exp Locker: brent $ SPRITE (Berkeley)";
@


6.17
log
@Changed from MigStart to Release procedure to handle new structuring
of migration.  A callback is now made by the I/O server to the source
of migration when it is ok to release references on a stream, and perhaps
the underlying I/O handle.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 6.16 88/10/16 11:11:36 brent Exp $ SPRITE (Berkeley)";
d171 1
a171 1
	    Sys_Panic(SYS_FATAL, "FsPipeHandleInit, didn't find handle\n");
d182 1
a182 1
	handlePtr->buffer = Mem_Alloc(FS_BLOCK_SIZE);
d222 1
a222 1
	Sys_Panic(SYS_WARNING, "FsPipeClose, unknown client %d\n", clientID);
d233 1
a233 1
	    Sys_Panic(SYS_FATAL,
d255 1
a255 1
	    Mem_Free(handlePtr->buffer);
d347 1
a347 1
	    Byte_Copy(toRead, handlePtr->buffer + startOffset, buffer);
d364 2
a365 2
	    Byte_Copy(numBytes, handlePtr->buffer + startOffset, buffer);
	    Byte_Copy(toRead - numBytes, handlePtr->buffer, buffer + numBytes);
d485 1
a485 1
	    Byte_Copy(toWrite, buffer, handlePtr->buffer + startOffset);
d502 2
a503 2
	    Byte_Copy(numBytes, buffer, handlePtr->buffer + startOffset);
	    Byte_Copy(toWrite - numBytes, buffer + numBytes, handlePtr->buffer);
d763 1
a763 1
    Sys_Panic(SYS_FATAL, "FsPipeRelease called\n");
d888 1
a888 1
	Sys_Panic(SYS_WARNING, "FsRmtPipeMigrate, server error <%x>\n",
d929 1
a929 1
	Sys_Panic(SYS_FATAL, "FsPipeMigEnd, no handle\n");
d982 1
a982 1
	Sys_Panic(SYS_WARNING,
d1085 1
a1085 1
	    clientPtr = Mem_New(FsClientInfo);
@


6.16
log
@Removed RecoveryComplete call that is now made by top-level recovery routine
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsPipe.c,v 6.15 88/10/14 12:15:17 brent Exp Locker: brent $ SPRITE (Berkeley)";
d744 1
a744 1
 * FsDeviceMigStart --
d746 1
a746 3
 *	Begin migration of a FS_LCL_PIPE_STREAM.  There is no extra
 *	state that needs saving, but we do release a reference to the I/O
 *	handle.
d759 2
a760 2
FsPipeMigStart(hdrPtr, flags, clientID, migFlagsPtr)
    FsHandleHeader *hdrPtr;	/* File being encapsulated */
a761 2
    int clientID;		/* Host doing the encapsulation */
    int *migFlagsPtr;		/* Migration flags we may modify */
d763 2
a764 19
    register FsPipeIOHandle *handlePtr = (FsPipeIOHandle *)hdrPtr;
    int writes;
    
    if ((flags & FS_RMT_SHARED) == 0) {
	if (flags & FS_WRITE) {
	    /*
	     * Figure out if this client is migrating away the last writer.
	     */
	    FsHandleLock(handlePtr);
	    FsIOClientStatus(&handlePtr->clientList, clientID,
			     (int *) NIL, &writes, (int *) NIL);
	    if (writes == 1) {
		*migFlagsPtr |= FS_LAST_WRITER;
	    }
	    FsHandleRelease(hdrPtr, TRUE);
	} else {
	    FsHandleRelease(hdrPtr, FALSE);
	}
    }
d817 1
a817 3
    FsStreamMigClient(&migInfoPtr->streamID, migInfoPtr->srcClientID,
		    dstClientID, (FsHandleHeader *)handlePtr,
		    &migInfoPtr->offset, &migInfoPtr->flags);
d902 5
a906 3
 *	Complete setup of a FS_LCL_PIPE_STREAM after migration.
 *	The migrate routine has done most all the work.
 *	We just grab a reference on the I/O handle for the stream.
@


6.15
log
@FsFileID FsUserID change
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.14 88/10/11 15:59:15 brent Exp $ SPRITE (Berkeley)";
a1053 1
    FsRecoveryComplete(&rmtHandlePtr->recovery, status);
@


6.14
log
@Cleaned up migration code
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.13 88/10/10 11:25:49 douglis Exp $ SPRITE (Berkeley)";
d68 1
a68 1
    FsFileID		fileID;
d127 1
a127 1
    FsFileID	*fileIDPtr;
d160 1
a160 1
    FsFileID	*fileIDPtr;	/* Pipe file ID */
d697 1
a697 1
    FsFileID			*fileIDPtr;	/* FileID of pipe */
d734 1
a734 1
    FsFileID		*fileIDPtr;	/* FileID of pipe */
d980 1
a980 1
    FsFileID	*fileIDPtr;	/* Client's I/O file ID */
@


6.13
log
@Fixed bug with looking at streamPtr->flags instead of flags param.
Keep around reference counts for shadow streams.  Got rid of 
clientdata argument to *MigStart routines, and pass in migFlagsPtr
instead so LAST_WRITER can be set.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.12 88/10/05 12:10:48 brent Exp $ SPRITE (Berkeley)";
d85 2
a86 1
    streamPtr = FsStreamNew(rpc_SpriteID, (FsHandleHeader *)handlePtr,
a87 1
    (void)FsStreamClientOpen(&streamPtr->clientList, rpc_SpriteID, FS_READ);
d97 2
a98 1
    streamPtr = FsStreamNew(rpc_SpriteID, (FsHandleHeader *)handlePtr,
a99 1
    (void)FsStreamClientOpen(&streamPtr->clientList, rpc_SpriteID, FS_WRITE);
a821 4
    register Fs_Stream			*streamPtr;
    Boolean				found;
    Boolean				cache = FALSE;
    Boolean				keepReference = FALSE;
d833 1
d838 3
a840 24
    streamPtr = FsStreamFind(&migInfoPtr->streamID,
	(FsHandleHeader *)handlePtr, migInfoPtr->flags, (char *)NIL, &found);
    if ((streamPtr->flags & FS_RMT_SHARED) == 0) {
	streamPtr->offset = migInfoPtr->offset;
    }
    if ((migInfoPtr->flags & FS_RMT_SHARED) == 0) {
	(void)FsStreamClientClose(&streamPtr->clientList,
				migInfoPtr->srcClientID);
    } else if (migInfoPtr->flags & FS_NEW_STREAM) {
	keepReference = TRUE;
    }
    if (FsStreamClientOpen(&streamPtr->clientList, dstClientID,
	    migInfoPtr->flags)) {
	streamPtr->flags |= FS_RMT_SHARED;
#ifdef notdef
	migInfoPtr->flags |= FS_RMT_SHARED;
#endif
    }
    if (keepReference) {
	FsHandleUnlock(streamPtr);
    } else {
	FsHandleRelease(streamPtr, TRUE);
    }

d844 2
a845 30
     if ((migInfoPtr->flags & FS_NEW_STREAM) &&
	 (migInfoPtr->flags & FS_RMT_SHARED)) {
	/*
	 * The stream is becoming shared across the network so
	 * we need to increment the use counts on the I/O handle
	 * to reflect the additional client stream.
	 */
	handlePtr->use.ref++;
	if ((migInfoPtr->flags & FS_WRITE) &&
	    !(migInfoPtr->flags & FS_LAST_WRITER)) {
	    handlePtr->use.write++;
	}
    } else if ((migInfoPtr->flags & (FS_NEW_STREAM|FS_RMT_SHARED)) == 0) {
	/*
	 * The stream is no longer shared, and it is not new on the
	 * target client, so we have to decrement the use counts
	 * to reflect the fact that the original client's stream is not
	 * referencing the I/O handle.
	 */
	handlePtr->use.ref--;
	if (migInfoPtr->flags & FS_WRITE) {
	    handlePtr->use.write--;
	}
    } else if (migInfoPtr->flags & FS_LAST_WRITER) {
	/*
	 * The stream is still open for reading but no longer for writing
	 * on the source client.
	 */
	handlePtr->use.write--;
    }
d847 1
a847 4
     * Move the client at the I/O handle level.  We are careful to only
     * close the srcClient if its migration state indicates it isn't
     * shared.  We are careful to only open the dstClient if it getting
     * the stream for the first time.
d849 2
a850 21
    if ((migInfoPtr->flags & FS_RMT_SHARED) == 0) {
	found = FsIOClientClose(&handlePtr->clientList,
		    migInfoPtr->srcClientID, migInfoPtr->flags, &cache);
	if (!found) {
	    Sys_Panic(SYS_WARNING,
		"FsPipeMigrate, IO Client %d not found\n",
		migInfoPtr->srcClientID);
	}
    } else if (migInfoPtr->flags & FS_LAST_WRITER) {
	found = FsIOClientRemoveWriter(&handlePtr->clientList,
		    migInfoPtr->srcClientID);
	if (!found) {
	    Sys_Panic(SYS_WARNING,
		"FsPipeMigrate, IO Client %d not found\n",
		migInfoPtr->srcClientID);
	}
    }
    if (migInfoPtr->flags & FS_NEW_STREAM) {
	(void)FsIOClientOpen(&handlePtr->clientList, dstClientID,
		migInfoPtr->flags, FALSE);
    }
d854 2
a855 2
    *flagsPtr = streamPtr->flags;
    *offsetPtr = streamPtr->offset;
@


6.12
log
@Added domainTypePtr parameter to the clientVerify routine
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.11 88/09/28 13:32:14 brent Exp $ SPRITE (Berkeley)";
d22 1
d287 1
a287 1
    int			flags;		/* IGNORED */
d341 1
a341 1
	if (streamPtr->flags & FS_USER) {
d355 1
a355 1
	if (streamPtr->flags & FS_USER) {
d415 2
a416 1
					 * correct error code is returned. */
d479 1
a479 1
	if (streamPtr->flags & FS_USER) {
d493 1
a493 1
	if (streamPtr->flags & FS_USER) {
d761 1
a761 1
FsPipeMigStart(hdrPtr, flags, clientID, data)
d765 1
a765 1
    ClientData data;		/* Buffer we fill in */
d767 3
d771 14
a784 1
	FsHandleRelease(hdrPtr, FALSE);
d825 1
d849 2
d855 1
d857 1
d859 5
a863 1
    FsHandleRelease(streamPtr, TRUE);
d876 2
a877 1
	if (migInfoPtr->flags & FS_WRITE) {
d891 6
d907 8
@


6.11
log
@Added include for extern definitions
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.10 88/09/28 08:38:01 brent Exp $ SPRITE (Berkeley)";
d1011 1
a1011 1
FsRmtPipeVerify(fileIDPtr, clientID)
d1014 1
d1038 3
@


6.10
log
@Changed IOControl interface to take Fs_Buffer's instead of
separate size/address parameters.  Need to pass user space
flag along to get pseudo-devices right after migration!
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.9 88/09/23 13:39:05 brent Exp $ SPRITE (Berkeley)";
d30 1
@


6.9
log
@Update interface to recovery routines.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.8 88/09/22 09:04:10 brent Exp $ SPRITE (Berkeley)";
d544 1
a544 2
FsPipeIOControl(streamPtr, command, byteOrder, inBufSize, inBuffer, outBufSize,
	outBuffer)
d548 2
a549 4
    int inBufSize;
    Address inBuffer;
    int outBufSize;
    Address outBuffer;
d568 1
a568 1
	    if (byteOrder != mach_ByteOrder) {
d570 2
a571 2
		Swap_Buffer(inBuffer, inBufSize, byteOrder, mach_ByteOrder, "w",
			    (Address)&flags, &size);
d575 1
a575 1
	    } else if (inBufSize != sizeof(int)) {
d578 1
a578 1
		flags = *(int *)inBuffer;
d596 1
a596 1
	    if (byteOrder != mach_ByteOrder) {
d599 1
a599 1
		    mach_ByteOrder, byteOrder, "w", outBuffer, &size);
d603 1
a603 1
	    } else if (outBufSize != sizeof(int)) {
d606 1
a606 1
		*(int *)outBuffer = bytesAvailable;
@


6.8
log
@y
y
Changed I/O Control interface to take streamPtr instead of ioHandlePtr
so we can implement lock crash recovery based on stream ownership of locks.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.7 88/09/16 16:51:24 brent Exp $ SPRITE (Berkeley)";
d1084 1
a1084 1
    FsRecoveryWakeup(&rmtHandlePtr->recovery, status);
@


6.7
log
@Added procID to close procedure to support lock cleanup
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.6 88/09/13 11:27:26 brent Exp $ SPRITE (Berkeley)";
d544 1
a544 1
FsPipeIOControl(hdrPtr, command, byteOrder, inBufSize, inBuffer, outBufSize,
d546 1
a546 1
    FsHandleHeader *hdrPtr;
d554 2
a555 1
    register FsPipeIOHandle *handlePtr = (FsPipeIOHandle *)hdrPtr;
@


6.6
log
@Added byte swapping code to IOControls
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.5 88/09/08 17:30:30 brent Exp $ SPRITE (Berkeley)";
d207 1
a207 1
FsPipeClose(streamPtr, clientID, flags, dataSize, closeData)
d209 2
a210 1
    int			clientID;	/* Client closing */
@


6.5
log
@Fixed recovery wakeup call so that it is done after errors.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.4 88/09/07 16:52:42 brent Exp $ SPRITE (Berkeley)";
d543 1
a543 1
FsPipeIOControl(hdrPtr, command, inBufSize, inBuffer, outBufSize,
d547 1
d554 1
d562 1
d567 19
a585 2
	    register int *flagsPtr = (int *)inBuffer;
	    if ((*flagsPtr & IOC_APPEND) == 0) {
a589 8
	case IOC_CLEAR_BITS: {
	    register int *flagsPtr = (int *)inBuffer;
	    if (*flagsPtr & IOC_APPEND) {
		return(GEN_INVALID_ARG);
	    } else {
		return(SUCCESS);
	    }
	}
d595 1
a595 1
	    register int bytesAvailable;
d597 13
a609 2
	    *(int *)outBuffer = bytesAvailable;
	    return(SUCCESS);
@


6.4
log
@Moved name from stream to I/O handle.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.3 88/08/31 12:05:18 brent Exp $ SPRITE (Berkeley)";
d1054 1
a1054 1
     * Contact the server to do the reopen.
d1059 1
a1059 7

    if (status == SUCCESS) {
	/*
	 * Notify waiters that recovery is complete.
	 */
	FsRecoveryWakeup(&rmtHandlePtr->recovery);
    }
@


6.3
log
@Removed lint.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.2 88/08/26 11:10:34 brent Exp $ SPRITE (Berkeley)";
d84 1
a84 1
			    FS_READ | FS_CONSUME | FS_USER);
d96 1
a96 1
			FS_WRITE | FS_APPEND | FS_USER);
d165 1
a165 1
    found = FsHandleInstall(fileIDPtr, sizeof(FsPipeIOHandle), &hdrPtr);
d800 1
a800 1
		(FsHandleHeader *)handlePtr, migInfoPtr->flags, &found);
@


6.2
log
@Fixed close routine to correctly determine when reader left.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.1 88/08/12 12:31:00 brent Exp $ SPRITE (Berkeley)";
d77 2
a78 2
    FsIOClientOpen(&handlePtr->clientList, rpc_SpriteID, FS_READ, FALSE);
    FsIOClientOpen(&handlePtr->clientList, rpc_SpriteID, FS_WRITE, FALSE);
d85 1
a85 1
    FsStreamClientOpen(&streamPtr->clientList, rpc_SpriteID, FS_READ);
d97 1
a97 1
    FsStreamClientOpen(&streamPtr->clientList, rpc_SpriteID, FS_WRITE);
@


6.1
log
@Added flags argument to setIOAttr routine that specifies
what attributes to update.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 6.0 88/08/11 12:15:43 brent Stable $ SPRITE (Berkeley)";
d235 1
a235 1
	if (flags & FS_WRITE && handlePtr->use.write == 0) {
d241 2
a242 1
	} else if (handlePtr->use.ref == 0) {
@


6.0
log
@Changing version numbers.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 1.6 88/08/05 13:57:59 brent Exp $ SPRITE (Berkeley)";
d707 1
a707 1
FsPipeSetIOAttr(fileIDPtr, attrPtr)
d710 1
@


1.6
log
@removed lint.
Fixed non-blocking writes to pipes so they return SUCCESS if
they were able to get any bytes written.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 1.5 88/08/04 15:05:05 mlgray Exp $ SPRITE (Berkeley)";
@


1.5
log
@merging changes from fs into fs.new
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 1.5 88/07/22 12:42:30 douglis Exp $ SPRITE (Berkeley)";
d279 1
d410 2
a411 1
    int			flags;		/* IGNORED */
d417 2
a418 2
    ReturnStatus 	status = SUCCESS;
    register FsPipeIOHandle *handlePtr =
d420 4
a423 4
    int 		startOffset;
    int 		toWrite;
    int			startByte;
    int			endByte;
d452 1
a452 1
    } else if (*lenPtr > toWrite) {
d455 2
a456 1
	 * data that we can.
d708 2
a709 2
    FsFileID			*fileIDPtr;	/* FileID of pipe */
    register Fs_Attributes	*attrPtr;	/* Attributes to update */
@


1.4
log
@Plugged core leak
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 1.3 88/06/06 09:36:48 brent Exp $ SPRITE (Berkeley)";
d171 6
d222 4
d227 9
d241 1
a241 1
	} else {
d810 26
@


1.3
log
@Changed close interface to pass back the streamID so the server's
shadow streams can be closed too.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 1.2 88/04/19 10:34:28 brent Exp $ SPRITE (Berkeley)";
d233 2
d1145 2
@


1.2
log
@Changed interface to FsIOClient{Open,Close} to include cached property.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 1.1 88/04/11 10:09:00 brent Exp $ SPRITE (Berkeley)";
d201 2
a202 2
FsPipeClose(hdrPtr, clientID, flags, dataSize, closeData)
    FsHandleHeader	*hdrPtr;	/* Handle to close */
d208 2
a209 1
    register FsPipeIOHandle *handlePtr = (FsPipeIOHandle *)hdrPtr;
@


1.1
log
@Initial revision
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: fsPipe.c,v 1.1 88/04/04 10:38:14 brent Exp $ SPRITE (Berkeley)";
d77 2
a78 2
    (void)FsIOClientOpen(&handlePtr->clientList, rpc_SpriteID, FS_READ);
    (void)FsIOClientOpen(&handlePtr->clientList, rpc_SpriteID, FS_WRITE);
d209 1
a209 1
    Boolean notUsed;
d211 1
a211 1
    if (!FsIOClientClose(&handlePtr->clientList, clientID, flags, &notUsed)) {
d756 1
a756 1
    Boolean				wasCached;	/* IGNORED */
d796 1
a796 1
		    migInfoPtr->srcClientID, migInfoPtr->flags, &wasCached);
d805 1
a805 1
		migInfoPtr->flags);
@
