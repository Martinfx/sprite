head     9.6;
branch   ;
access   ;
symbols  ds3100:9.6 sun3:9.6 sprited:9.4.1 sun4nw:9.5 symm:9.5 spur:9.5 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.6
date     92.08.10.17.26.53;  author mgbaker;  state Exp;
branches ;
next     9.5;

9.5
date     91.09.10.18.38.13;  author rab;  state Exp;
branches ;
next     9.4;

9.4
date     90.12.06.21.56.54;  author jhh;  state Exp;
branches 9.4.1.1;
next     9.3;

9.3
date     90.10.10.11.07.41;  author mendel;  state Exp;
branches ;
next     9.2;

9.2
date     90.10.08.15.53.24;  author mendel;  state Exp;
branches ;
next     9.1;

9.1
date     89.10.09.14.41.34;  author brent;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.06.17;  author douglis;  state Stable;
branches ;
next     8.6;

8.6
date     89.08.21.15.26.21;  author mendel;  state Exp;
branches ;
next     8.5;

8.5
date     89.08.15.18.42.41;  author rab;  state Exp;
branches ;
next     8.4;

8.4
date     89.02.09.09.09.13;  author brent;  state Exp;
branches ;
next     8.3;

8.3
date     89.02.06.17.56.05;  author brent;  state Exp;
branches ;
next     8.2;

8.2
date     89.02.04.14.11.52;  author brent;  state Exp;
branches ;
next     8.1;

8.1
date     89.01.30.09.22.33;  author brent;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.19.31;  author douglis;  state Stable;
branches ;
next     7.0;

7.0
date     88.11.07.14.47.23;  author brent;  state Exp;
branches ;
next     6.6;

6.6
date     88.10.19.13.12.34;  author brent;  state Exp;
branches ;
next     6.5;

6.5
date     88.10.14.12.15.28;  author brent;  state Exp;
branches ;
next     6.4;

6.4
date     88.09.23.13.00.47;  author brent;  state Exp;
branches ;
next     6.3;

6.3
date     88.09.23.09.04.21;  author brent;  state Exp;
branches ;
next     6.2;

6.2
date     88.09.15.17.54.02;  author brent;  state Exp;
branches ;
next     6.1;

6.1
date     88.08.24.14.54.52;  author brent;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.15.49;  author brent;  state Stable;
branches ;
next     1.2;

1.2
date     88.06.01.16.52.29;  author brent;  state Exp;
branches ;
next     1.1;

1.1
date     88.04.04.10.32.18;  author brent;  state Exp;
branches ;
next     ;

9.4.1.1
date     91.11.15.15.57.19;  author kupfer;  state Exp;
branches ;
next     ;


desc
@Definitions for the local and remote file procedures
@


9.6
log
@Transparent server recovery now available.
@
text
@/*
 * fsioFile.h --
 *
 *	Declarations for regular file access, local and remote.
 *
 * Copyright 1987 Regents of the University of California
 * All rights reserved.
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 *
 * $Header: /sprite/src/kernel/Cvsroot/kernel/fsio/fsioFile.h,v 9.5 91/09/10 18:38:13 rab Exp $ SPRITE (Berkeley)
 */

#ifndef _FSFILE
#define _FSFILE

#ifdef KERNEL
#include <fsio.h>
#include <fsutil.h>
#include <fsconsist.h>
#include <fscache.h>
#include <fsioLock.h>
#include <fsNameOps.h>
#else
#include <kernel/fsio.h>
#include <kernel/fsutil.h>
#include <kernel/fsconsist.h>
#include <kernel/fscache.h>
#include <kernel/fsioLock.h>
#include <kernel/fsNameOps.h>
#endif
/*
 * When a regular file is opened state is packaged up on the server
 * and used on the client to set up the I/O handle for the file.
 * This is the 'streamData' generated by Fsio_FileNameOpen and passed to
 * Fsio_FileIoOpen
 */
typedef struct Fsio_FileState {
    Boolean	cacheable;	/* TRUE if the client can cache data blocks */
    int		version;	/* Version number for data block cache */
    int		openTimeStamp;	/* Time stamp used to catch races between
				 * open replies and cache consistency msgs */
    Fscache_Attributes attr;	/* A copy of some file attributes */
    int		newUseFlags;	/* The server may modify the stream use flags.
				 * In particular, the execute bit is stripped
				 * off when directories are opened. */
} Fsio_FileState;

/*
 * When a client re-opens a file it sends the following state to the server.
 */
typedef struct Fsio_FileReopenParams {
    Fs_FileID	fileID;		/* File ID of file to reopen. MUST BE FIRST */
    Fs_FileID	prefixFileID;	/* File ID for the prefix of this file. */
    Fsio_UseCounts	use;		/* Reference counts */
    Boolean	flags;		/* FSIO_HAVE_BLOCKS | FS_SWAP */
    int		version;	/* Expected version number for the file. */
} Fsio_FileReopenParams;

/*
 * File reopen flags
 *	FSIO_HAVE_BLOCKS	Set when the client has dirty blocks in its cache.
 *		This implies that it ought to be able to continue caching.
 *		A race exists in that another client could open for writing
 *		first, and thus invalidate the first client's data, or another
 *		client could open for reading and possibly see stale data.
 *	FS_SWAP	This stream flag is passed along so the server doesn't
 *		erroneously grant cacheability to swap files.
 *			
 */
#define FSIO_HAVE_BLOCKS		0x1
/*resrv FS_SWAP			0x4000 */

/*
 * The I/O descriptor for a local file.  Used with FSIO_LCL_FILE_STREAM.
 */

typedef struct Fsio_FileIOHandle {
    Fs_HandleHeader	hdr;		/* Standard handle header.  The
					 * 'major' field of the fileID
					 * is the domain number.  The
					 * 'minor' field is the file num. */
    Fsio_UseCounts		use;	/* Open, writer, and exec counts.
					 * Used for consistency checks. This
					 * is a summary of all uses of a file */
    int			flags;		/* FSIO_FILE_NAME_DELETED and
					 * FSIO_FILE_DESC_DELETED */
    struct Fsdm_FileDescriptor *descPtr;/* Reference to disk info, this
					 * has attritutes, plus disk map. */
    Fscache_FileInfo	cacheInfo;	/* Used to access block cache. */
    Fsconsist_Info	consist;	/* Client use info needed to enforce
					 * network cache consistency */
    Fsio_LockState		lock;		/* User level locking state. */
    Fscache_ReadAheadInfo	readAhead;/* Read ahead info used to synchronize
					 * with other I/O and closes/deletes. */
    struct Vm_Segment	*segPtr;	/* Reference to code segment needed
					 * to flush VM cache. */
} Fsio_FileIOHandle;			/* 268 BYTES (316 with traced locks) */

/*
 * Flags for local I/O handles.
 *	FSIO_FILE_NAME_DELETED		Set when all names of a file have been
 *				removed.  This marks the handle for removal.
 *	FSIO_FILE_DESC_DELETED		Set when the disk descriptor is in
 *				the process of being removed.  This guards
 *				against a close/remove race where two parties
 *				try to do the disk deletion phase.
 */
#define FSIO_FILE_NAME_DELETED		0x1
#define FSIO_FILE_DESC_DELETED		0x2


/*
 * OPEN SWITCH
 * The nameOpen procedure is used on the file server when opening streams or
 * setting up an I/O fileID for a file or device.  It is keyed on
 * disk file descriptor types( i.e. FS_FILE, FS_DIRECTORY, FS_DEVICE,
 * FS_PSEUDO_DEVICE).  The nameOpen procedure returns an ioFileID
 * used for I/O on the file, plus other data needed for the client's
 * stream.  The streamIDPtr is NIL during set/get attributes, which
 * indicates that the extra stream information isn't needed.
 */

typedef struct Fsio_OpenOps {
    int		type;			/* One of the file descriptor types */
    /*
     * The calling sequence for the nameOpen routine is:
     *	FooNameOpen(handlePtr, openArgsPtr, openResultsPtr);
     */
    ReturnStatus (*nameOpen) _ARGS_((Fsio_FileIOHandle *handlePtr, 
				     Fs_OpenArgs *openArgsPtr,
				     Fs_OpenResults *openResultsPtr));
} Fsio_OpenOps;

extern Fsio_OpenOps fsio_OpenOpTable[];

/*
 * Open operations.
 */
extern ReturnStatus Fsio_FileNameOpen _ARGS_((Fsio_FileIOHandle *handlePtr, 
			Fs_OpenArgs *openArgsPtr, 
			Fs_OpenResults *openResultsPtr));

/*
 * Stream operations.
 */
extern ReturnStatus Fsio_FileIoOpen _ARGS_((Fs_FileID *ioFileIDPtr,
		int *flagsPtr, int clientID, ClientData streamData, char *name,
		Fs_HandleHeader **ioHandlePtrPtr));
extern ReturnStatus Fsio_FileRead _ARGS_((Fs_Stream *streamPtr,
		Fs_IOParam *readPtr, Sync_RemoteWaiter *remoteWaitPtr, 
		Fs_IOReply *replyPtr));
extern ReturnStatus Fsio_FileWrite _ARGS_((Fs_Stream *streamPtr, 
		Fs_IOParam *writePtr, Sync_RemoteWaiter *remoteWaitPtr, 
		Fs_IOReply *replyPtr));
extern ReturnStatus Fsio_FileIOControl _ARGS_((Fs_Stream *streamPtr, 
		Fs_IOCParam *ioctlPtr, Fs_IOReply *replyPtr));
extern ReturnStatus Fsio_FileSelect _ARGS_((Fs_HandleHeader *hdrPtr, 
		Sync_RemoteWaiter *waitPtr, int *readPtr, int *writePtr, 
		int *exceptPtr));
extern ReturnStatus Fsio_FileMigClose _ARGS_((Fs_HandleHeader *hdrPtr, 
		int flags));
extern ReturnStatus Fsio_FileMigOpen _ARGS_((Fsio_MigInfo *migInfoPtr, int size,
		ClientData data, Fs_HandleHeader **hdrPtrPtr));
extern ReturnStatus Fsio_FileMigrate _ARGS_((Fsio_MigInfo *migInfoPtr, 
		int dstClientID, int *flagsPtr, int *offsetPtr, int *sizePtr, 
		Address *dataPtr));
extern ReturnStatus Fsio_FileReopen _ARGS_((Fs_HandleHeader *hdrPtr, 
		int clientID, ClientData inData, int *outSizePtr, 
		ClientData *outDataPtr));
extern ReturnStatus Fsio_FileBlockCopy _ARGS_((Fs_HandleHeader *srcHdrPtr, 
		Fs_HandleHeader *dstHdrPtr, int blockNum));
extern Boolean Fsio_FileScavenge _ARGS_((Fs_HandleHeader *hdrPtr));
extern ReturnStatus Fsio_FileClose _ARGS_((Fs_Stream *streamPtr, int clientID,
		Proc_PID procID, int flags, int dataSize,
		ClientData closeData));
extern ReturnStatus Fsio_FileCloseInt _ARGS_((Fsio_FileIOHandle *handlePtr,
		int ref, int write, int exec, int clientID, Boolean callback));
extern void Fsio_FileClientKill _ARGS_((Fs_HandleHeader *hdrPtr, int clientID));

extern void Fsio_FileSyncLockCleanup _ARGS_((Fsio_FileIOHandle *handlePtr));

extern void Fsio_InstallSrvOpenOp _ARGS_((int fileType, 
			Fsio_OpenOps *openOpsPtr));
extern ReturnStatus Fsio_LocalFileHandleInit _ARGS_((Fs_FileID *fileIDPtr,
		char *name, struct Fsdm_FileDescriptor *descPtr,
		Boolean cantBlock, Fsio_FileIOHandle **newHandlePtrPtr));

extern ReturnStatus Fsio_DeviceNameOpen _ARGS_((Fsio_FileIOHandle *handlePtr, 
				Fs_OpenArgs *openArgsPtr, 
				Fs_OpenResults *openResultsPtr));
/*
 * ftrunc() support
 */
extern ReturnStatus Fsio_FileTrunc _ARGS_((Fsio_FileIOHandle *handlePtr, 
			int size, int flags));

/*
 * Recovery testing operations.
 */
extern int Fsio_FileRecovTestUseCount _ARGS_((Fsio_FileIOHandle *handlePtr));
extern int Fsio_FileRecovTestNumCacheBlocks _ARGS_((Fsio_FileIOHandle *handlePtr));
extern int Fsio_FileRecovTestNumDirtyCacheBlocks _ARGS_((Fsio_FileIOHandle *handlePtr));

/*
 * Fast recov stuff.
 */
#include <fsrecovTypes.h>
extern ReturnStatus Fsio_FileSetupHandle _ARGS_((Fsrecov_HandleState *recovInfoPtr));

#endif /* _FSFILE */
@


9.5
log
@Fixed lint errors and removed tracing.
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fsio/RCS/fsioFile.h,v 9.4 90/12/06 21:56:54 jhh Exp Locker: rab $ SPRITE (Berkeley)
d202 13
@


9.4
log
@Added sosp tracing code
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fsio/RCS/fsioFile.h,v 9.3 90/10/10 11:07:41 mendel Exp $ SPRITE (Berkeley)
a178 6

#ifdef SOSP91
extern ReturnStatus Fsio_FileClose _ARGS_((Fs_Stream *streamPtr, int clientID,
		Proc_PID procID, int flags, int dataSize,
		ClientData closeData, int *offsetPtr, int *rwFlagsPtr));
#else
a181 1
#endif
d203 1
a203 1
#endif _FSFILE
@


9.4.1.1
log
@Initial branch for Sprite server.
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/Cvsroot/kernel/fsio/fsioFile.h,v 9.4 90/12/06 21:56:54 jhh Exp $ SPRITE (Berkeley)
@


9.3
log
@Fixed include file to work with user programs.
Added Fsio_DeviceNameOpen prototyped remove from fsioDevice.h
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fsio/RCS/fsioFile.h,v 9.2 90/10/08 15:53:24 mendel Exp Locker: mendel $ SPRITE (Berkeley)
d179 6
d188 1
@


9.2
log
@Fixed include files to use <> rather than "".
Added function prototyping.  
Added ftrunc() support.
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fs.mendel/RCS/fsioFile.h,v 1.1 90/01/16 17:12:06 mendel Exp Locker: mendel $ SPRITE (Berkeley)
d22 1
d29 8
a36 1

d194 3
@


9.1
log
@Changed FSIO_FILE_DELETED to
FSIO_FILE_NAME_DELETED and FSIO_FILE_DESC_DELETED
because both phases of delete can happen at
different times, and it is crucial that only
one party attempt the descriptor deletion phase.
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fsio/RCS/fsioFile.h,v 8.6 89/08/21 15:26:21 mendel Exp $ SPRITE (Berkeley)
d22 6
a27 5
#include "fsio.h"
#include "fsutil.h"
#include "fsconsist.h"
#include "fscache.h"
#include "fsioLock.h"
d52 1
a52 1
    Fsutil_UseCounts	use;		/* Reference counts */
d80 1
a80 1
    Fsutil_UseCounts		use;		/* Open, writer, and exec counts.
d85 1
a85 1
    struct Fsdm_FileDescriptor *descPtr;	/* Reference to disk info, this
d91 1
a91 1
    Fscache_ReadAheadInfo	readAhead;	/* Read ahead info used to synchronize
d108 1
d111 24
d137 3
a139 1
extern ReturnStatus	Fsio_FileNameOpen();
d144 47
a190 16
extern ReturnStatus	Fsio_FileIoOpen();
extern ReturnStatus	Fsio_FileRead();
extern ReturnStatus	Fsio_FileWrite();
extern ReturnStatus	Fsio_FileIOControl();
extern ReturnStatus	Fsio_FileSelect();
extern ReturnStatus	Fsio_FileMigClose();
extern ReturnStatus	Fsio_FileMigOpen();
extern ReturnStatus	Fsio_FileMigrate();
extern ReturnStatus	Fsio_FileReopen();
extern ReturnStatus	Fsio_FileBlockRead();
extern ReturnStatus	Fsio_FileBlockWrite();
extern ReturnStatus	Fsio_FileBlockCopy();
extern Boolean		Fsio_FileScavenge();
extern void		Fsio_FileClientKill();
extern ReturnStatus	Fsio_FileClose();
extern ReturnStatus	Fsio_FileCloseInt();
a191 1
extern void		Fsio_FileSyncLockCleanup();
@


9.0
log
@Changing version numbers.
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fsio/RCS/fsioFile.h,v 8.6 89/08/21 15:26:21 mendel Exp Locker: douglis $ SPRITE (Berkeley)
d82 2
a83 1
    int			flags;		/* FSIO_FILE_DELETED */
d98 1
a98 1
 *	FSIO_FILE_DELETED		Set when all names of a file have been
d100 4
d105 2
a106 1
#define FSIO_FILE_DELETED		0x1
@


8.6
log
@Break up fs into many modules.    
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fs/RCS/fsFile.h,v 8.4 89/02/09 09:09:13 brent Exp $ SPRITE (Berkeley)
@


8.5
log
@Commented #endif labels.
@
text
@d2 1
a2 1
 * fsFile.h --
d16 1
a16 1
 * $Header: /sprite/src/kernel/fs/RCS/fsFile.h,v 8.4 89/02/09 09:09:13 brent Exp Locker: rab $ SPRITE (Berkeley)
d22 5
a26 2
#include "fsRecovery.h"
#include "fsReadAhead.h"
d31 2
a32 2
 * This is the 'streamData' generated by FsFileSrvOpen and passed to
 * FsFileCltOpen
d34 1
a34 1
typedef struct FsFileState {
d39 1
a39 1
    FsCachedAttributes attr;	/* A copy of some file attributes */
d43 1
a43 1
} FsFileState;
d48 1
a48 1
typedef struct FsFileReopenParams {
d51 2
a52 2
    FsUseCounts	use;		/* Reference counts */
    Boolean	flags;		/* FS_HAVE_BLOCKS | FS_SWAP */
d54 1
a54 1
} FsFileReopenParams;
d58 1
a58 1
 *	FS_HAVE_BLOCKS	Set when the client has dirty blocks in its cache.
d65 1
a65 1
 *
d67 1
a67 1
#define FS_HAVE_BLOCKS		0x1
d71 1
a71 1
 * The I/O descriptor for a local file.  Used with FS_LCL_FILE_STREAM.
d74 2
a75 2
typedef struct FsLocalFileIOHandle {
    FsHandleHeader	hdr;		/* Standard handle header.  The
d79 1
a79 1
    FsUseCounts		use;		/* Open, writer, and exec counts.
d82 2
a83 2
    int			flags;		/* FS_FILE_DELETED */
    struct FsFileDescriptor *descPtr;	/* Reference to disk info, this
d85 2
a86 2
    FsCacheFileInfo	cacheInfo;	/* Used to access block cache. */
    FsConsistInfo	consist;	/* Client use info needed to enforce
d88 2
a89 2
    FsLockState		lock;		/* User level locking state. */
    FsReadAheadInfo	readAhead;	/* Read ahead info used to synchronize
d93 1
a93 1
} FsLocalFileIOHandle;			/* 268 BYTES (316 with traced locks) */
d97 1
a97 1
 *	FS_FILE_DELETED		Set when all names of a file have been
d100 1
a100 19
#define FS_FILE_DELETED		0x1

/*
 * The I/O descriptor for a remote file.  Used with FS_RMT_FILE_STREAM.
 */

typedef struct FsRmtFileIOHandle {
    FsRemoteIOHandle	rmt;		/* Remote I/O handle used for RPCs. */
    FsCacheFileInfo	cacheInfo;	/* Used to access block cache. */
    FsReadAheadInfo	readAhead;	/* Read ahead info used to synchronize
					 * with other I/O and closes/deletes. */
    int			openTimeStamp;	/* Returned on open from the server
					 * and used to catch races with cache
					 * consistency msgs due to other opens*/
    int			flags;		/* FS_SWAP */
    struct Vm_Segment	*segPtr;	/* Reference to code segment needed
					 * to flush VM cache. */
} FsRmtFileIOHandle;			/* 216 BYTES  (264 with traced locks)*/

d105 1
a105 1
extern ReturnStatus	FsFileSrvOpen();
d110 16
a125 36
extern ReturnStatus	FsFileCltOpen();
extern ReturnStatus	FsFileRead();
extern ReturnStatus	FsFileWrite();
extern ReturnStatus	FsFileIOControl();
extern ReturnStatus	FsFileSelect();
extern ReturnStatus	FsFileRelease();
extern ReturnStatus	FsFileMigEnd();
extern ReturnStatus	FsFileMigrate();
extern ReturnStatus	FsFileReopen();
extern ReturnStatus	FsFileBlockAllocate();
extern ReturnStatus	FsFileBlockRead();
extern ReturnStatus	FsFileBlockWrite();
extern ReturnStatus	FsFileBlockCopy();
extern Boolean		FsFileScavenge();
extern void		FsFileClientKill();
extern ReturnStatus	FsFileClose();
extern ReturnStatus	FsFileCloseInt();

extern ReturnStatus	FsRmtFileCltOpen();
extern FsHandleHeader	*FsRmtFileVerify();
extern ReturnStatus	FsRmtFileRead();
extern ReturnStatus	FsRmtFileWrite();
extern ReturnStatus	FsRmtFileIOControl();
extern ReturnStatus	FsRmtFileSelect();
extern ReturnStatus	FsRmtFileGetIOAttr();
extern ReturnStatus	FsRmtFileSetIOAttr();
extern ReturnStatus	FsRmtFileRelease();
extern ReturnStatus	FsRmtFileMigEnd();
extern ReturnStatus	FsRmtFileMigrate();
extern ReturnStatus	FsRmtFileReopen();
extern ReturnStatus	FsRmtFileAllocate();
extern ReturnStatus	FsRmtFileBlockRead();
extern ReturnStatus	FsRmtFileBlockWrite();
extern ReturnStatus	FsRmtFileBlockCopy();
extern Boolean		FsRmtFileScavenge();
extern ReturnStatus	FsRmtFileClose();
d127 2
a128 2
extern void		FsFileSyncLockCleanup();
#endif /* _FSFILE */
@


8.4
log
@Added FsFileCloseInt and FsFileSyncLockCleanup
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fs/RCS/fsFile.h,v 8.3 89/02/06 17:56:05 brent Exp $ SPRITE (Berkeley)
d62 1
a62 1
 *			
d163 1
a163 1
#endif _FSFILE
@


8.3
log
@Nuked unused prefixFileID from remote file handle
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fs/RCS/fsFile.h,v 8.2 89/02/04 14:11:52 brent Exp $ SPRITE (Berkeley)
d141 1
d162 1
@


8.2
log
@Updated comments, including size of handles
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fs/RCS/fsFile.h,v 8.1 89/01/30 09:22:33 brent Exp $ SPRITE (Berkeley)
a111 3
    Fs_FileID		prefixFileID;	/* Passed to the server so it can
					 * properly trap out lookups that
					 * ascend past the prefix. */
d114 1
a114 1
} FsRmtFileIOHandle;			/* 232 BYTES  (280 with traced locks)*/
@


8.1
log
@Changed scavenge routine to a Boolean
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fs/RCS/fsFile.h,v 8.0 88/11/11 18:19:31 douglis Stable Locker: brent $ SPRITE (Berkeley)
a75 3
    List_Links		streamList;	/* List of streams to the file.  Used
					 * to verify clients, and check cache
					 * consistency and stream sharing */
d90 1
a90 1
} FsLocalFileIOHandle;			/* 240 BYTES */
d117 1
a117 1
} FsRmtFileIOHandle;			/* 196 BYTES */
@


8.0
log
@Changing version numbers.
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fs/RCS/fsFile.h,v 7.0 88/11/07 14:47:23 brent Exp Locker: douglis $ SPRITE (Berkeley)
d144 1
a144 1
extern void		FsFileScavenge();
d164 1
a164 1
extern void		FsRmtFileScavenge();
@


7.0
log
@New version for conversion to new C library
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fs/RCS/fsFile.h,v 6.6 88/10/19 13:12:34 brent Exp Locker: brent $ SPRITE (Berkeley)
@


6.6
log
@Changed MigStart routine to Release
@
text
@d16 1
a16 1
 * $Header: /sprite/src/kernel/fs/RCS/fsFile.h,v 6.5 88/10/14 12:15:28 brent Exp Locker: brent $ SPRITE (Berkeley)
@


6.5
log
@FsFileID FsUserID change
@
text
@d16 1
a16 1
 * $Header: fsFile.h,v 6.4 88/09/23 13:00:47 brent Exp $ SPRITE (Berkeley)
d136 1
a136 1
extern ReturnStatus	FsFileMigStart();
d156 1
a156 1
extern ReturnStatus	FsRmtFileMigStart();
@


6.4
log
@Added a flags field in the remote file handle so we can
remember that its a swap file and do better recovery.  The
server was granting us cache permission before.
@
text
@d16 1
a16 1
 * $Header: fsFile.h,v 6.3 88/09/23 09:04:21 brent Exp $ SPRITE (Berkeley)
d46 2
a47 2
    FsFileID	fileID;		/* File ID of file to reopen. MUST BE FIRST */
    FsFileID	prefixFileID;	/* File ID for the prefix of this file. */
d115 1
a115 1
    FsFileID		prefixFileID;	/* Passed to the server so it can
@


6.3
log
@Updated the size of the remote file handle.
@
text
@d16 1
a16 1
 * $Header: fsFile.h,v 6.2 88/09/15 17:54:02 brent Exp $ SPRITE (Berkeley)
d49 1
a49 4
    Boolean	haveDirtyBlocks;/* TRUE => This open must not suceed unless the
				 * file can be cached.  This flag is set when
				 * dirty blocks remain in the cache for a file.
				 */
d54 14
d114 1
d120 1
a120 1
} FsRmtFileIOHandle;			/* 192 BYTES */
@


6.2
log
@Added ownership list to FsLockState for crash recovery
@
text
@d4 1
a4 1
 *	Declarations for regular file access.
d16 1
a16 1
 * $Header: fsFile.h,v 6.1 88/08/24 14:54:52 brent Exp $ SPRITE (Berkeley)
d108 1
a108 1
} FsRmtFileIOHandle;			/* 188 BYTES */
a109 7

/*
 * Data transferred when a regular file stream migrates.
 */
typedef struct FsFileMigData {
    int foo;
} FsFileMigData;
@


6.1
log
@name change of field, mustBeCacheable => haveDirtyBlocks
@
text
@d16 1
a16 1
 * $Header: fsFile.h,v 6.0 88/08/11 12:15:49 brent Stable $ SPRITE (Berkeley)
d82 1
a82 1
} FsLocalFileIOHandle;			/* 232 BYTES */
@


6.0
log
@Changing version numbers.
@
text
@d16 1
a16 1
 * $Header: fsFile.h,v 1.2 88/06/01 16:52:29 brent Exp $ SPRITE (Berkeley)
d49 1
a49 1
    Boolean	mustBeCacheable;/* TRUE => This open must not suceed unless the
@


1.2
log
@Removed the FS_FILE_GONE flag. Moved it to the block cache struct.
@
text
@d16 1
a16 1
 * $Header: fsFile.h,v 1.1 88/04/04 10:32:18 brent Exp $ SPRITE (Berkeley)
@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
 * $Header: fsFile.h,v 5.7 87/11/02 10:43:56 brent Exp $ SPRITE (Berkeley)
a87 4
 *	FS_FILE_GONE		Set after the file descriptor has been
 *				marked as deleted.  This is used during
 *				deletion to ignore delayed writes while
 *				making call-backs to other clients.
a89 1
#define FS_FILE_GONE		0x2
@
