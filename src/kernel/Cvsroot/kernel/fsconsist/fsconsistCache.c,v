head     9.32;
branch   ;
access   ;
symbols  ds3100:9.32 sun3:9.32 sprited:9.24.1 sun4nw:9.28 symm:9.28 spur:9.28 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.32
date     92.08.10.17.23.58;  author mgbaker;  state Exp;
branches ;
next     9.31;

9.31
date     92.05.07.17.05.08;  author kupfer;  state Exp;
branches ;
next     9.30;

9.30
date     92.04.17.13.53.56;  author jhh;  state Exp;
branches ;
next     9.29;

9.29
date     91.12.12.11.58.15;  author mgbaker;  state Exp;
branches ;
next     9.28;

9.28
date     91.10.08.14.12.14;  author mgbaker;  state Exp;
branches ;
next     9.27;

9.27
date     91.09.10.18.49.39;  author rab;  state Exp;
branches ;
next     9.26;

9.26
date     91.09.06.13.37.29;  author mgbaker;  state Exp;
branches ;
next     9.25;

9.25
date     91.09.05.23.26.02;  author rab;  state Exp;
branches ;
next     9.24;

9.24
date     91.07.26.17.14.33;  author mendel;  state Exp;
branches 9.24.1.1;
next     9.23;

9.23
date     91.01.26.15.36.06;  author mgbaker;  state Exp;
branches ;
next     9.22;

9.22
date     91.01.07.23.30.25;  author mgbaker;  state Exp;
branches ;
next     9.21;

9.21
date     90.12.06.21.57.05;  author jhh;  state Exp;
branches ;
next     9.20;

9.20
date     90.11.25.16.26.02;  author mgbaker;  state Exp;
branches ;
next     9.19;

9.19
date     90.11.25.16.13.35;  author jhh;  state Exp;
branches ;
next     9.18;

9.18
date     90.11.24.18.29.06;  author mgbaker;  state Exp;
branches ;
next     9.17;

9.17
date     90.10.08.12.18.56;  author mendel;  state Exp;
branches ;
next     9.16;

9.16
date     90.08.26.16.18.15;  author douglis;  state Exp;
branches ;
next     9.15;

9.15
date     90.08.26.16.16.36;  author shirriff;  state Exp;
branches ;
next     9.14;

9.14
date     90.07.15.13.34.57;  author shirriff;  state Exp;
branches ;
next     9.13;

9.13
date     90.06.21.16.47.36;  author douglis;  state Exp;
branches ;
next     9.12;

9.12
date     90.06.21.13.57.18;  author shirriff;  state Exp;
branches ;
next     9.11;

9.11
date     90.05.14.13.08.43;  author douglis;  state Exp;
branches ;
next     9.10;

9.10
date     90.02.20.15.03.59;  author brent;  state Exp;
branches ;
next     9.9;

9.9
date     89.11.08.11.28.10;  author shirriff;  state Exp;
branches ;
next     9.8;

9.8
date     89.11.02.16.37.02;  author brent;  state Exp;
branches ;
next     9.7;

9.7
date     89.11.02.16.34.03;  author shirriff;  state Exp;
branches ;
next     9.6;

9.6
date     89.11.02.13.55.14;  author brent;  state Exp;
branches ;
next     9.5;

9.5
date     89.11.01.10.50.58;  author shirriff;  state Exp;
branches ;
next     9.4;

9.4
date     89.10.30.18.06.31;  author shirriff;  state Exp;
branches ;
next     9.3;

9.3
date     89.10.27.08.23.23;  author brent;  state Exp;
branches ;
next     9.2;

9.2
date     89.10.23.09.57.08;  author brent;  state Exp;
branches ;
next     9.1;

9.1
date     89.09.25.16.51.11;  author brent;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.04.28;  author douglis;  state Stable;
branches ;
next     8.14;

8.14
date     89.08.29.15.41.33;  author brent;  state Exp;
branches ;
next     8.13;

8.13
date     89.08.21.15.24.33;  author mendel;  state Exp;
branches ;
next     8.12;

8.12
date     89.08.17.12.12.17;  author brent;  state Exp;
branches ;
next     8.11;

8.11
date     89.08.10.17.11.41;  author brent;  state Exp;
branches ;
next     8.10;

8.10
date     89.05.14.15.23.58;  author brent;  state Exp;
branches ;
next     8.9;

8.9
date     89.02.13.08.31.50;  author brent;  state Exp;
branches ;
next     8.8;

8.8
date     89.02.09.09.22.05;  author brent;  state Exp;
branches ;
next     8.7;

8.7
date     89.02.06.18.29.02;  author brent;  state Exp;
branches ;
next     8.6;

8.6
date     89.02.01.13.56.42;  author brent;  state Exp;
branches ;
next     8.5;

8.5
date     89.01.24.12.27.39;  author brent;  state Exp;
branches ;
next     8.4;

8.4
date     89.01.06.11.20.29;  author jhh;  state Exp;
branches ;
next     8.3;

8.3
date     88.12.21.10.17.57;  author brent;  state Exp;
branches ;
next     8.2;

8.2
date     88.11.28.12.51.58;  author brent;  state Exp;
branches ;
next     8.1;

8.1
date     88.11.26.11.41.25;  author brent;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.24.41;  author douglis;  state Stable;
branches ;
next     7.0;

7.0
date     88.11.11.15.35.16;  author brent;  state Exp;
branches ;
next     6.18;

6.18
date     88.10.14.12.19.09;  author brent;  state Exp;
branches ;
next     6.17;

6.17
date     88.10.10.11.31.04;  author douglis;  state Exp;
branches ;
next     6.16;

6.16
date     88.09.23.13.34.51;  author brent;  state Exp;
branches ;
next     6.15;

6.15
date     88.09.22.14.38.47;  author brent;  state Exp;
branches ;
next     6.14;

6.14
date     88.09.19.15.02.25;  author brent;  state Exp;
branches ;
next     6.13;

6.13
date     88.09.19.11.19.48;  author brent;  state Exp;
branches ;
next     6.12;

6.12
date     88.09.15.16.34.13;  author brent;  state Exp;
branches ;
next     6.11;

6.11
date     88.09.13.23.13.07;  author nelson;  state Exp;
branches ;
next     6.10;

6.10
date     88.09.12.08.32.50;  author brent;  state Exp;
branches ;
next     6.9;

6.9
date     88.09.09.14.56.33;  author brent;  state Exp;
branches ;
next     6.8;

6.8
date     88.09.09.14.44.43;  author brent;  state Exp;
branches ;
next     6.7;

6.7
date     88.09.09.12.47.26;  author brent;  state Exp;
branches ;
next     6.6;

6.6
date     88.09.07.16.54.59;  author brent;  state Exp;
branches ;
next     6.5;

6.5
date     88.08.27.12.40.53;  author brent;  state Exp;
branches ;
next     6.4;

6.4
date     88.08.26.17.30.29;  author brent;  state Exp;
branches ;
next     6.3;

6.3
date     88.08.26.12.06.47;  author brent;  state Exp;
branches ;
next     6.2;

6.2
date     88.08.26.11.15.12;  author brent;  state Exp;
branches ;
next     6.1;

6.1
date     88.08.24.18.13.22;  author brent;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.19.08;  author brent;  state Stable;
branches ;
next     1.8;

1.8
date     88.08.05.13.00.38;  author brent;  state Exp;
branches ;
next     1.7;

1.7
date     88.06.15.17.18.02;  author brent;  state Exp;
branches ;
next     1.6;

1.6
date     88.06.06.09.41.34;  author brent;  state Exp;
branches ;
next     1.5;

1.5
date     88.06.04.12.10.07;  author brent;  state Exp;
branches ;
next     1.4;

1.4
date     88.06.01.17.52.42;  author brent;  state Exp;
branches ;
next     1.3;

1.3
date     88.04.28.09.00.50;  author brent;  state Exp;
branches ;
next     1.2;

1.2
date     88.04.19.10.51.13;  author brent;  state Exp;
branches ;
next     1.1;

1.1
date     88.04.11.10.10.15;  author brent;  state Exp;
branches ;
next     ;

9.24.1.1
date     91.11.15.15.29.14;  author kupfer;  state Exp;
branches ;
next     ;


desc
@Cache consistency routines
@


9.32
log
@Changes for transparent server recovery.

@
text
@/* 
 * fsCacheConsist.c --
 *
 *	Routines used to keep the file system caches consistent.  The
 *	server maintains a list of client machines that have the file
 *	open.  This list indicates how many opens per client, if the file
 *	is being cached, and if the file is open for writing on a client.
 *	The client list is updated when files are opened, closed, and removed.
 *
 *	SYNCHRONIZATION:  There are two classes of procedures here: those
 *	that make call-backs to clients, and those that just examine the
 *	client list.  All access to a client list is synchronized using
 *	a monitor lock embedded in the consist structure.  Furthermore,
 *	consistency actions are serialized by setting a flag during
 *	call-backs (CONSIST_IN_PROGRESS).  There is a possible deadlock
 *	if the monitor lock is held during a call-back because this
 *	prevents a close operation from completing. (At close time the
 *	client list is adjusted but no call-backs are made.  Also, the client
 *	has its handle locked which blocks our call-back.)  Accordingly,
 *	both the handle lock and the monitor lock are released during
 *	a call-back.  The CONSIST_IN_PROGRESS flag is left on to prevent
 *	other consistency actions during the call-back.
 *
 * Copyright 1986 Regents of the University of California.
 * All rights reserved.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fsconsist/fsconsistCache.c,v 9.31 92/05/07 17:05:08 kupfer Exp $ SPRITE (Berkeley)";
#endif

#include	<sprite.h>
#include	<fs.h>
#include	<fsutil.h>
#include	<fsconsist.h>
#include	<fscache.h>
#include	<fsStat.h>
#include	<fslcl.h>
#include	<fsprefix.h>
#include	<hash.h>
#include	<vm.h>
#include	<proc.h>
#include	<sys.h>
#include	<rpc.h>
#include	<recov.h>
#include	<timer.h>
#include	<dbg.h>
#include 	<fsio.h>
#include	<fsrmt.h>
#include	<fsdm.h>

#include <stdio.h>

#include	<fsrecov.h>

#define	LOCKPTR	(&consistPtr->lock)

Boolean	fsconsist_Debug = FALSE;
Boolean	fsconsist_ClientCachingEnabled = TRUE;

/*
 * Flags for the Fsconsist_Info struct that's defined in fsInt.h
 *
 *	FS_CONSIST_IN_PROGRESS	Cache consistency is being performed on this
 *				file.
 *	FS_CONSIST_ERROR	There was an error during the cache 
 *				consistency.
 *	FS_CONSIST_TIMEOUT	There is a timeout setup for the consistency
 *				actions.
 */
#define	FS_CONSIST_IN_PROGRESS	0x1
#define	FS_CONSIST_ERROR	0x2
#define FS_CONSIST_TIMEOUT	0x4

/*
 * Clients have an (arbitrary) number of minutes to complete call-back
 * actions before the server blows them off and lets an open operation
 * complete.  This time has to be enough to let a client with a large
 * main-memory cache writeback a large file.
 */
int fsconsist_TimeoutMinutes = 1;

/*
 * Rpc to send when forcing a client to invalidate or write back a file.
 */

typedef struct ConsistMsg {
    Fs_FileID	fileID;		/* Which file to invalidate. */
    int		flags;		/* One of the flags defined below. */
    int		openTimeStamp;	/* Open that this rpc pertains to. */
    int		version;	/* Version number of the file */
} ConsistMsg;

/*
 * Message sent when the client has completed the work requested by the server.
 * This is actually the request part of the rpc transaction.
 */

typedef struct ConsistReply {
    Fs_FileID 		fileID;
    Fscache_Attributes	cachedAttr;
    ReturnStatus	status;
} ConsistReply;


/*
 * Structure used to keep track of outstanding cache consistency requests.
 */
typedef struct {
    List_Links	links;
    int		clientID;
    int		flags;
} ConsistMsgInfo;

/*
 * Global time stamp.  A time stamp is returned to clients on each open
 * and on cache consistency messages.  This way clients can detect races
 * between open replies and consistency actions.
 */
static	int	openTimeStamp = 0;

/*
 * Forward declarations.
 */
extern void StartConsistency _ARGS_((Fsconsist_Info *consistPtr, 
			int clientID, int useFlags, Boolean *cacheablePtr));
extern void UpdateList _ARGS_((Fsconsist_Info *consistPtr, int clientID, 
		int useFlags, Boolean cacheable, int *openTimeStampPtr));
extern ReturnStatus EndConsistency _ARGS_((Fsconsist_Info *consistPtr));
extern void ConsistTimeoutIntr _ARGS_((Timer_Ticks time, ClientData data));
extern void ConsistTimeout _ARGS_((ClientData data, 
		Proc_CallInfo *callInfoPtr));

extern void ClientCommand _ARGS_((Fsconsist_Info *consistPtr,
		Fsconsist_ClientInfo *clientPtr, int flags));

extern void ProcessConsist _ARGS_((ClientData data,Proc_CallInfo *callInfoPtr));
extern void ProcessConsistReply _ARGS_((Fsconsist_Info *consistPtr, 
		int clientID, ConsistReply *replyPtr));

extern char *ConsistType _ARGS_((int flags));


/*
 * ----------------------------------------------------------------------------
 *
 * Fsconsist_Init --
 *
 *      Initialize the client use information for a file.  This is done
 *	before adding any clients so it just resets all the fields.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Reset the client use state..
 *
 * ----------------------------------------------------------------------------
 *
 */
void
Fsconsist_Init(consistPtr, hdrPtr)
    register Fsconsist_Info *consistPtr;	/* State to initialize */
    Fs_HandleHeader *hdrPtr;			/* Back pointer to handle */
{
    Sync_LockInitDynamic(&consistPtr->lock, "Fs:consistLock");
    consistPtr->flags = 0;
    consistPtr->lastWriter = -1;
    consistPtr->openTimeStamp = 0;
    consistPtr->hdrPtr = hdrPtr;
    List_Init(&consistPtr->clientList);
    List_Init(&consistPtr->msgList);
    consistPtr->consistDone.waiting = 0;
    consistPtr->repliesIn.waiting = 0;
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fsconsist_SyncLockCleanup --
 *
 *      Clean up Sync_Lock tracing for the cache lock.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	As above.
 *
 * ----------------------------------------------------------------------------
 *
 */
/*ARGSUSED*/
void
Fsconsist_SyncLockCleanup(consistPtr)
    Fsconsist_Info *consistPtr;	/* State to initialize */
{
    Sync_LockClear(&consistPtr->lock);
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fsconsist_MappedConsistency --
 *
 *	Take action to ensure that everything is consistent for a
 *	file that is being mapped.
 *
 * Results:
 *	SUCCESS or FS_FILE_BUSY.
 *
 * Side effects:
 *	Issues cache consistency messages.
 *
 * ----------------------------------------------------------------------------
 *
 */
/*ARGSUSED*/
ENTRY ReturnStatus
Fsconsist_MappedConsistency(handlePtr, clientID, isMapped)
    Fsio_FileIOHandle 	*handlePtr;	/* File to check consistency of. */
    int 		clientID;	/* ID of the host doing the map. */
    int			isMapped;	/* 1 if file is being mapped. */
{
#ifdef notdef
    int					cacheable;	/* Dummy. */
    register Fsconsist_ClientInfo	*clientPtr;
    register Fsconsist_Info		*consistPtr = &handlePtr->consist;
    ReturnStatus			status;

    printf("Fsconsist_MappedConsistency: updating consistency (a)\n");
    LOCK_MONITOR;

    printf("Fsconsist_MappedConsistency: updating consistency (b)\n");
    StartConsistency(consistPtr, clientID, (int)(isMapped ? FS_MAP : 0),
	    &cacheable);

    printf("Fsconsist_MappedConsistency: updating consistency (c)\n");
    LIST_FORALL(&consistPtr->clientList, (List_Links *)clientPtr) {
	if (clientPtr->clientID == clientID) {
	    clientPtr->mapped = isMapped ? TRUE : FALSE;
	}
    }

    printf("Fsconsist_MappedConsistency: updating consistency (d)\n");
    status = EndConsistency(consistPtr);
    printf("Fsconsist_MappedConsistency: updating consistency (e)\n");

    UNLOCK_MONITOR;
    return(status);
#endif
    return SUCCESS;
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fsconsist_FileConsistency --
 *
 *	Take action to ensure that the caches are consistent for this
 *	file.  This checks against use conflicts and will return an
 *	non-SUCCESS status if the open should fail.  Otherwise this
 *	makes call-backs to other clients to keep caches consistent.
 *
 * Results:
 *	SUCCESS or FS_FILE_BUSY.  Also, *cacheablePtr set to TRUE if the
 *	file is cacheable on the client.  *openTimeStampPtr is set to the
 *	next open time stamp on the file.  Clients use this timeStamp
 *	to catch races between open replies, which have the next timeStamp,
 *	and consistency messages from other opens happening
 *	at about the same time, which have the current timeStamp.
 *
 * Side effects:
 *	Issues cache consistency messages and adds the client to the
 *	list of clients of the file.
 *	The handle is unlocked before Fsconsist_FileConsistency is called.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY ReturnStatus
Fsconsist_FileConsistency(handlePtr, clientID, useFlags, cacheablePtr,
    openTimeStampPtr)
    Fsio_FileIOHandle *handlePtr;	/* File to check consistency of. */
    int 		clientID;	/* ID of the host doing the open */
    register int 	useFlags;	/* useFlags from the open call */
    Boolean		*cacheablePtr;	/* TRUE if file is cacheable. */
    int			*openTimeStampPtr;/* Timestamp of open.  Used by clients
					 * to catch races between open replies
					 * and cache consistency messages */
{
    register Fsconsist_Info *consistPtr = &handlePtr->consist;
    ReturnStatus status;

    LOCK_MONITOR;

    /*
     * Go through the list of other clients using the file checking
     * for conflicts and issuing cache consistency messages.
     */
    StartConsistency(consistPtr, clientID, useFlags, cacheablePtr);
    /*
     * Add ourselves to the list of clients using the file.
     */
    UpdateList(consistPtr, clientID, useFlags, *cacheablePtr,
		openTimeStampPtr);
    /*
     * Now that we are all set up, and have told all the other clients
     * using the file what they have to do, we wait for them to finish.
     */
    status = EndConsistency(consistPtr);
    UNLOCK_MONITOR;
    return(status);
}

/*
 * ----------------------------------------------------------------------------
 *
 * StartConsistency --
 *
 *      Initiate cache consistency action on a file.  This decides if the
 *	client can cache the file, and then makes call-backs to other
 *	clients so that caches stay consistent.  EndConsistency
 *	should be called later to wait for the client replies.
 *
 * Results:
 *	*cacheablePtr set to TRUE if the file is cacheable.   *fileBusyPtr
 *	is set to FS_FILE_BUSY if the file is either being opened for execution
 *	and it is already open for writing or vice versa.
 *
 * Side effects:
 *	Sets the FS_CONSIST_IN_PROGRESS flag and makes call-backs to
 *	clients.  The flag is cleared if the call-backs can't be made.
 *
 * ----------------------------------------------------------------------------
 *
 */

INTERNAL void
StartConsistency(consistPtr, clientID, useFlags, cacheablePtr)
    Fsconsist_Info	*consistPtr;	/* File's consistency state. */
    int			clientID;	/* ID of host opening the file */
    int			useFlags;	/* Indicates how they are using it */
    Boolean		*cacheablePtr;	/* Return, TRUE if client can cache */
{
    register Fsconsist_ClientInfo *clientPtr;
    register Fsconsist_ClientInfo *nextClientPtr;
    register Fs_ConsistStats *statPtr = &fs_Stats.consist;
    register Fs_MigStats *migStatPtr = &fs_Stats.mig;
    register int openForWriting = useFlags & FS_WRITE;
    register Boolean cacheable;
    Boolean countMigration;	/* Set if we're supposed to increment a
				   counter for the type of consistency
				   performed, and cleared once the increment
				   is done. */
    int clients = 0;
    int notCaching = 0;
    int writebackFlags;

    /*
     * Make sure that noone else is in the middle of performing cache
     * consistency on this file.
     */
    while (consistPtr->flags & FS_CONSIST_IN_PROGRESS) {
	(void) Sync_Wait(&consistPtr->consistDone, FALSE);
    }
    consistPtr->flags = FS_CONSIST_IN_PROGRESS;

    /*
     * Determine cacheability of the file.  Note the system-wide switch
     * to disable client caching.  There are other special cases that
     * are not cached:
     *  1. Swap files are not cached on clients.
     *	2. Non-files, (dirs, links) are not cacheable so we don't have to
     *	   worry about keeping them consistent.  (This could be done.)
     *  3. Files that are being concurrently write-shared are not cached.
     *     This includes one writer and one or more readers on other hosts,
     *	   and writers on multiple hosts.
     */
    cacheable = fsconsist_ClientCachingEnabled;
    if (useFlags & FS_MIGRATING) {
	countMigration = 1;
	writebackFlags = FSCONSIST_MIGRATION;
    } else {
	countMigration = 0;
	writebackFlags = 0;
    }
    if ((useFlags & FS_SWAP) && (clientID != rpc_SpriteID)) {
	cacheable = FALSE;
	statPtr->swap++;
    } else if (((Fsio_FileIOHandle *)consistPtr->hdrPtr)->descPtr->fileType
		    != FS_FILE) {
	cacheable = FALSE;
	statPtr->nonFiles++;
    } else if (useFlags & FS_MAP) {
	cacheable = FALSE;
    }
    if (cacheable) {
	LIST_FORALL(&consistPtr->clientList, (List_Links *)clientPtr) {
	    if (clientPtr->mapped) {
		cacheable = FALSE;
		goto done;
	    }
	    if (clientPtr->clientID != clientID) {
		if ((clientPtr->use.write > 0) ||
		    ((clientPtr->use.ref > 0) && openForWriting)) {
		    cacheable = FALSE;
		    goto done;
		}
	    }
	}
    } else {
	countMigration = FALSE;
    }
done:
    /*
     * Now that we know the cacheable state of the file, check the use
     * by other clients, perhaps sending them cache consistency
     * messages.  For each message we send out (the client replies
     * right-away without actually doing anything yet) ClientCommand
     * adds an entry to the consistInfo's message list.  Note also that
     * the current client list entry can get removed as side effects of
     * a call-back so we can't use a simple LIST_FOR_ALL here.
     *
     * Record statistics for both regular opens and migrations.  Migrations
     * are really a subset of regular opens since only some cases can occur.
     */
    statPtr->files++;
    if (countMigration) {
	migStatPtr->consistActions++;
    }
    nextClientPtr = (Fsconsist_ClientInfo *)List_First(&consistPtr->clientList);
    while (!List_IsAtEnd(&consistPtr->clientList, (List_Links *)nextClientPtr)){
	clientPtr = nextClientPtr;
	clientPtr->locked = FALSE;
	nextClientPtr = (Fsconsist_ClientInfo *)List_Next((List_Links *)clientPtr);
	/*
	 * Hang onto the next client element across calls to ClientCommand,
	 * which releases the consistency lock and may allow client list
	 * deletions due to garbage collection.
	 */
	if (!List_IsAtEnd(&consistPtr->clientList,(List_Links *)nextClientPtr)){
	    nextClientPtr->locked = TRUE;
	}
	if (clientPtr->clientID == clientID) {
	    /*
	     * Don't call back to the client doing the open.  That can
	     * cause deadlock.  Instead, that client takes care of its
	     * own cache via the Fscache_UpdateFile procedure.
	     */
	    if (clientPtr->clientID == consistPtr->lastWriter) {
		statPtr->writeCaching++;
	    } else if (clientPtr->use.ref > 0 && clientPtr->cached) {
		statPtr->readCachingMyself++;
	    }
	    continue;
	}
	clients++;
	if (!clientPtr->cached) {
	    /*
	     * Case 1, the other client isn't caching the file. Do nothing.
	     */
	    notCaching++;
	} else if (cacheable) {
	    if (consistPtr->lastWriter != clientPtr->clientID) {
		/*
		 * Case 2, the other client is caching and it's ok.
		 */
		statPtr->readCachingOther++;
		if (countMigration) {
		    /*
		     * Already caching for reading -- this migration can't
		     * change that.
		     */
		    migStatPtr->readOnlyFiles++;
		    countMigration = 0;
		}
	    } else if (consistPtr->lastWriter == clientID) {
		/*
		 * Case 3, the last writer is now opening for reading.
		 * Its dirty cache is ok.  (This case is trapped out above.)
		 */
		statPtr->writeCaching++;
	    } else {
		int mode;
		/*
		 * Case 4, the last writer needs to give us back the
		 * dirty blocks so the opening client will get good data.
		 * In the case of migration, it is possible for a writable
		 * file to be migrated to another host while still being
		 * cacheable.  In that case the old client doesn't have
		 * any more references to the file and can't use its cached
		 * blocks for it anyway.  Since the version number doesn't
		 * get incremented due to migration we have to invalidate
		 * at migration time.
		 */
		mode = FSCONSIST_WRITE_BACK_BLOCKS | writebackFlags;
		if (openForWriting) {
		    mode |= FSCONSIST_INVALIDATE_BLOCKS;
		}
		ClientCommand(consistPtr, clientPtr, mode);
		statPtr->writeBack++;
		if (countMigration) {
		    migStatPtr->cacheWritableFiles++;
		    countMigration = 0;
		}
	    }
	} else {
	    if ((clientPtr->use.write == 0) && (clientPtr->use.ref > 0)) {
		/*
		 * Case 5, another reader needs to stop caching.
		 */
		ClientCommand(consistPtr, clientPtr,
					FSCONSIST_INVALIDATE_BLOCKS);
		statPtr->readInvalidate++;
	    } else if (clientPtr->use.write > 0) {
		/*
		 * Case 6, the writer needs to stop caching and give
		 * us back its dirty blocks.
		 */
		ClientCommand(consistPtr, clientPtr,
			      FSCONSIST_WRITE_BACK_BLOCKS |
			      FSCONSIST_INVALIDATE_BLOCKS | writebackFlags);
		statPtr->writeInvalidate++;
	    }
	    if (countMigration) {
		migStatPtr->cacheToUncacheFiles++;
		countMigration = 0;
	    }
	}
    }
    if (cacheable) {
	statPtr->cacheable++;
	if (countMigration) {
	    if (notCaching == clients) {
		migStatPtr->uncacheToCacheFiles++;
	    } else {
		migStatPtr->readOnlyFiles++;
	    }
	}
    } else {
	statPtr->uncacheable++;
	if (countMigration) {
	    migStatPtr->uncacheableFiles++;
	}
    }
    statPtr->clients += clients;
    statPtr->notCaching += notCaching;
    *cacheablePtr = cacheable;
}

/*
 * ----------------------------------------------------------------------------
 *
 * UpdateList --
 *
 *	Update the state of the client that is using one of our files.
 *	A timestamp is generated for return to the client so it can
 *	catch races between the open return message and cache consistency
 *	messages associated with this file.
 *
 * Results:
 *	The timestamp.
 *
 * Side effects:
 *	The version number is incremented when open for writing.  The
 *	lastWriter is remembered when opening for writing.  Use counts
 *	are kept to reflect the clients use of the file.  Finally,
 *	client list entries for hosts no longer using or caching the
 *	file are deleted.
 *
 * ----------------------------------------------------------------------------
 */

INTERNAL void
UpdateList(consistPtr, clientID, useFlags, cacheable, openTimeStampPtr)
    register Fsconsist_Info *consistPtr;/* Consistency state for the file. */
    int			clientID;	/* ID of client using the file */
    int			useFlags;	/* FS_READ|FS_WRITE|FS_EXECUTE */
    Boolean		cacheable;	/* TRUE if client is caching the file */
    int			*openTimeStampPtr;/* Generated for the client so it can
					 * catch races between the return from
					 * this open and other cache messages */
{
    register Fsconsist_ClientInfo *clientPtr;	/* State for other clients */

    /*
     * Add the client to the I/O handle client list.
     */
    clientPtr = Fsconsist_IOClientOpen(&consistPtr->clientList, clientID,
		useFlags, cacheable);

    if (cacheable && (useFlags & FS_WRITE)) {
	consistPtr->lastWriter = clientID;
    }
    /*
     * Return a time stamp for the open.  This timestamp is used by clients
     * to catch races between the reply message for an open, and a cache
     * consistency message generated from a different open happening at
     * about the same time.
     */
    if (openTimeStampPtr != (int *)NIL) {
	openTimeStamp++;
	*openTimeStampPtr =
	    consistPtr->openTimeStamp =
		clientPtr->openTimeStamp = openTimeStamp;
    } else {
	consistPtr->openTimeStamp = clientPtr->openTimeStamp = 0;
    }
}


/*
 * ----------------------------------------------------------------------------
 *
 * EndConsistency --
 *	Wait for cache consistency actions to complete.
 *
 * Results:
 *	SUCCESS or FS_NO_DISK_SPACE.  We have to abort an open if a client
 *	cannot write back its cache in response to a consistency message.
 *	This only happens if the disk is full.  If the client is down we
 *	won't wait for it.  If it is not really down we treat it as
 *	down and will abort its attempt to re-open later.
 *
 * Side effects:
 *	Notifies the consistDone condition to allow someone else to
 *	open the file.  Clears the FS_CONSIST_IN_PROGRES flag.
 *
 * ----------------------------------------------------------------------------
 *
 */

INTERNAL ReturnStatus
EndConsistency(consistPtr)
    Fsconsist_Info	*consistPtr;
{
    register ReturnStatus status;
    Timer_QueueElement timeout;

    /*
     * Set up a timeout in case a flakey client can't complete
     * its consistency actions.  We pick an arbitrary "long" interval
     * and just abort after that.  A more complex solution would be
     * to re-iterate what ever high level operation we are doing.
     */
    timeout.routine = ConsistTimeoutIntr;
    timeout.interval = timer_IntOneMinute * fsconsist_TimeoutMinutes;
    timeout.clientData = (ClientData)consistPtr;
    consistPtr->flags |= FS_CONSIST_TIMEOUT;
    Timer_ScheduleRoutine(&timeout, TRUE);

    while (!List_IsEmpty(&consistPtr->msgList)) {
	(void) Sync_Wait(&consistPtr->repliesIn, FALSE);
    }
    if (consistPtr->flags & FS_CONSIST_TIMEOUT) {
	(void)Timer_DescheduleRoutine(&timeout);
	consistPtr->flags &= ~FS_CONSIST_TIMEOUT;
    }
    if (consistPtr->flags & FS_CONSIST_ERROR) {
	/*
	 * The only reason consistency actions fail altogether is when
	 * a client can't do a writeback because there isn't enough
	 * disk space here.  Crashed clients don't matter.
	 */
	printf("EndConsistency: consistency failed for %s: no disk space\n",
	       Fsutil_HandleName(consistPtr->hdrPtr)); /* DEBUG */
	status = FS_NO_DISK_SPACE;
    } else {
	status = SUCCESS;
    }
    consistPtr->flags = 0;
    Sync_Broadcast(&consistPtr->consistDone);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * ConsistTimeoutIntr --
 *
 *	Routine called at timer-interrupt time if a client has not
 *	completed consistency actions.  This turns around and does
 *	a Proc_CallFunc to invoke ConsistTimeout at process level.
 *	ConsistTimeout prints a warning and removes the information
 *	about the now aborted consistency request so that the higher-level
 *	operation can complete.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Triggers a call to ConsistTimeout, which in turn erases the
 *	consistPtr->msgList and notifies the consistPtr->repliesIn condition.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
void
ConsistTimeoutIntr(time, data)
    Timer_Ticks time;	/* The time we timed out at. */
    ClientData data;	/* A pointer to a Fsconsist_Info */
{
    Fsconsist_Info *consistPtr = (Fsconsist_Info *)data;

    consistPtr->flags &= ~FS_CONSIST_TIMEOUT;
    Proc_CallFunc(ConsistTimeout, (ClientData)consistPtr, 0);
}

void
ConsistTimeout(data, callInfoPtr)
    ClientData		data;	/* A pointer to a Fsconsist_Info */
    Proc_CallInfo	*callInfoPtr;
{
    Fsconsist_Info *consistPtr = (Fsconsist_Info *)data;
    ConsistMsgInfo *msgPtr;
    int ref, write, exec;

    LOCK_MONITOR;
    while (!List_IsEmpty(&consistPtr->msgList)) {
	msgPtr = (ConsistMsgInfo *)List_First(&consistPtr->msgList);

	printf("ConsistTimeout (%d minutes) client %d %s file <%d,%d> \"%s\"\n",
		fsconsist_TimeoutMinutes,
		msgPtr->clientID, ConsistType(msgPtr->flags),
		consistPtr->hdrPtr->fileID.major,
		consistPtr->hdrPtr->fileID.minor,
		Fsutil_HandleName(consistPtr->hdrPtr));

	Fsconsist_IOClientKill(&consistPtr->clientList, msgPtr->clientID,
		    &ref, &write, &exec);
	printf("\tClient state killed: %d refs %d write %d exec\n",
		    ref, write, exec);

	if (msgPtr->clientID == consistPtr->lastWriter) {
	    consistPtr->lastWriter = -1;
	}
	List_Remove((List_Links *)msgPtr);
	free((Address)msgPtr);
    }
    Sync_Broadcast(&consistPtr->repliesIn);
    callInfoPtr->interval = 0;	/* No more invocations, please */
    UNLOCK_MONITOR;
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fsconsist_ReopenClient --
 *
 *	Conflict checking has already been done for the re-open, and this
 *	routine updates global use counts and the client list so that
 *	regular opens know the file is being used.  This is called with
 *	the handle locked and it also grabs the consistency monitor lock
 *	to update the client list.
 *	Consistency call-backs are made	later by Fsconsist_ReopenConsistency.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Updates the global use counts of the file, the last writer of
 *	the file, and the client list entry for this client.  Note that
 *	by updating the lastWriter here we may cause a call-back to
 *	the re-opening client during Fsconsist_ReopenConsistency.  This is the
 *	best we can do if another client has slipped in and opened
 *	for reading already.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY void
Fsconsist_ReopenClient(handlePtr, clientID, use, haveDirtyBlocks)
    Fsio_FileIOHandle	*handlePtr;	/* Should be LOCKED. */
    int			clientID;	/* The client who is opening the file.*/
    Fsio_UseCounts		use;		/* Clients usage of the file */
    Boolean 		haveDirtyBlocks;/* TRUE if client expects it to be
					 * cacheable because it has
					 * outstanding dirty blocks. */
{
    register Fsconsist_Info	*consistPtr = &handlePtr->consist;
    register Fsconsist_ClientInfo	*clientPtr;
    Boolean			found;

    LOCK_MONITOR;

    found = FALSE;
    LIST_FORALL(&(consistPtr->clientList), (List_Links *)clientPtr) {
	if (clientPtr->clientID == clientID) {
	    found = TRUE;
	    handlePtr->use.ref   += use.ref   - clientPtr->use.ref;
	    handlePtr->use.write += use.write - clientPtr->use.write;
	    handlePtr->use.exec  += use.exec  - clientPtr->use.exec;
	    clientPtr->use = use;
	    clientPtr->cached = haveDirtyBlocks;
	    if ((handlePtr->use.ref < 0) || (handlePtr->use.write < 0) ||
		    (handlePtr->use.exec < 0)) {
		panic("Fsconsist_ReopenClient: client %d ref %d write %d exec %d\n" ,
			clientID,
			handlePtr->use.ref, handlePtr->use.write,
			handlePtr->use.exec);
	    }
	} else if ((clientPtr->use.ref > 0) && haveDirtyBlocks) {
	    /*
	     * Oops, another client is reading this file but the re-opening
	     * client has dirty blocks for it.  We've already checked the
	     * version number so we know another client isn't writing.
	     * We allow this conflict to happen - the regular cache
	     * consistency routines will tell the reading client to
	     * stop caching, and the writing client will write-back
	     * its blocks as soon as possible.  This leaves a window
	     * for inconsistent reads, but the outstanding dirty blocks
	     * are not lost.
	     */
	    printf("FsReopenHandle: file \"%s\" <%d,%d>: client %d has dirty blocks, but client %d is using\n",
		Fsutil_HandleName(handlePtr),
		handlePtr->hdr.fileID.major, handlePtr->hdr.fileID.minor,
		clientID, clientPtr->clientID);
	}
    }
    if (!found) {
	INSERT_CLIENT(&consistPtr->clientList, clientPtr, clientID);
	clientPtr->use = use;
	clientPtr->cached = haveDirtyBlocks;

	handlePtr->use.ref   += use.ref;
	handlePtr->use.write += use.write;
	handlePtr->use.exec  += use.exec;
    }
    if (haveDirtyBlocks) {
	if (consistPtr->lastWriter != -1 &&
	    consistPtr->lastWriter != clientID) {
	    /*
	     * Version number checking should have prevented this.
	     */
	    printf("FsReopenHandle: file \"%s\" <%d,%d>: Client %d with dirty blocks not last writer %d\n",
		Fsutil_HandleName(handlePtr),
		handlePtr->hdr.fileID.major, handlePtr->hdr.fileID.minor,
		clientID, consistPtr->lastWriter);
	} else {
	    consistPtr->lastWriter = clientID;
	}
    } else if (consistPtr->lastWriter == clientID) {
	consistPtr->lastWriter = -1;
    }
    UNLOCK_MONITOR;
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fsconsist_ReopenConsistency --
 *
 *	Perform cache consistency actions for a file that the client had 
 *	open before we crashed.  This is similar to regular cache consistency,
 *	except that the client list has already been updated by
 *	Fsconsist_ReopenClient.  This can result in a call-back to the
 *	re-opening client asking to write back its version of the file.
 *
 * Results:
 *	TRUE if could provide the cacheability expected, FALSE otherwise.
 *
 * Side effects:
 *	*cacheablePtr is TRUE if the file is to be cached by the client.
 *	*openTimeStampPtr is set for use by clients.  They keep this timestamp
 *	in order to catch races between the return from their open request
 *	(which we are part of) and cache consistency messages resulting from
 *	opens occuring at about the same time.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY ReturnStatus
Fsconsist_ReopenConsistency(handlePtr, clientID, use, swap, cacheablePtr,
	openTimeStampPtr)
    Fsio_FileIOHandle	*handlePtr;	/* Should be UNLOCKED. */
    int			clientID;	/* The client who is opening the file.*/
    Fsio_UseCounts	use;		/* Clients usage of the file */
    int			swap;		/* 0 or FS_SWAP to indicate swap file.*/
    Boolean 		*cacheablePtr;	/* IN: TRUE if client expects it to be
					 * cacheable, i.e. has dirty blocks.
					 * OUT: Cacheability of the file. */
    int			*openTimeStampPtr; /* Place to return a timestamp for 
					 * this open.*/
{
    int				useFlags;
    Boolean			cacheable;
    ReturnStatus		status;
    register Fsconsist_Info	*consistPtr = &handlePtr->consist;
    register Fsconsist_ClientInfo	*clientPtr;

    LOCK_MONITOR;

    useFlags = swap;
    if (use.ref > use.write + use.exec) {
	useFlags |= FS_READ;
    }
    if (use.write > 0 || *cacheablePtr) {
	useFlags |= FS_WRITE;
    }
    if (use.exec > 0) {
	useFlags |= FS_EXECUTE;
    }

    if (useFlags == 0) {
	/*
	 * The client isn't using the file anymore so clean up state.
	 */
	LIST_FORALL(&(consistPtr->clientList), (List_Links *)clientPtr) {
	    if (clientPtr->clientID == clientID) {
		REMOVE_CLIENT(clientPtr);
		break;
	    }
	}
	*openTimeStampPtr = consistPtr->openTimeStamp;
	*cacheablePtr = FALSE;
	status = SUCCESS;
    } else {
	StartConsistency(consistPtr, clientID, useFlags, &cacheable);

	/*
	 * Get a new openTimeStamp so the client can detect races between
	 * the reopen return and consistency messages generated by other
	 * opens happening right now (or real soon).
	 * FIX ME.  The file version number should be used instead.
	 */
	openTimeStamp++;
	*openTimeStampPtr = consistPtr->openTimeStamp = openTimeStamp;
	/*
	 * Mark the client as caching or not.
	 */
	*cacheablePtr = cacheable;
	if ((useFlags & FS_WRITE) && cacheable) {
	    consistPtr->lastWriter = clientID;
	}
	/*
	 * We are careful to search for the client list entry again
	 * because it might go away during concurrent operations.
	 */
	LIST_FORALL(&consistPtr->clientList, (List_Links *)clientPtr) {
	    if (clientPtr->clientID == clientID) {
		clientPtr->openTimeStamp = openTimeStamp;
		clientPtr->cached = cacheable;
		break;
	    }
	}
	/*
	 * Wait for cache consistency call-backs to complete.
	 */
	status = EndConsistency(consistPtr);
    }
    UNLOCK_MONITOR;
    return(status);
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fsconsist_MigrateConsistency --
 *
 *	Shift the references on a file from one client to another.  If
 *	the stream to this handle is not shared across network this
 *	is done by first removing the useCounts due to the srcClient,
 *	and them performing the regular cache consistency algorithm as
 *	if the dstClient is opening the file.  If the stream is shared
 *	things are more complicated.  We must not close the original
 *	client until all stream references to its I/O handle have migrated,
 *	and we must be careful to not add too many references to the
 *	new client.
 *
 * Results:
 *	SUCCESS, unless there is a cache consistency conflict detected.
 *
 * Side effects:
 *	The HANDLE RETURNS UNLOCKED.  Also, full-fledged cache consistency
 *	actions are taken.
 *
 * ----------------------------------------------------------------------------
 */

ENTRY ReturnStatus
Fsconsist_MigrateConsistency(handlePtr, srcClientID, dstClientID, useFlags,
	closeSrc, cacheablePtr, openTimeStampPtr)
    Fsio_FileIOHandle	*handlePtr;	/* Needs to be UNLOCKED  */
    int			srcClientID;	/* ID of client using the file */
    int			dstClientID;	/* ID of client using the file */
    int			useFlags;	/* FS_READ|FS_WRITE|FS_EXECUTE
					 * FS_RMT_SHARED if shared now.
					 * FS_NEW_STREAM if dstClientID is
					 * getting stream for first time.
					 * FS_MIGRATED_FILE is set to tell
					 * the low-level consistency routines
					 * to record statistics. */
    Boolean		closeSrc;	/* TRUE if should close source client.
					 * Set by Fsio_StreamMigClient */
    Boolean		*cacheablePtr;	/* Return - Cachability of file */
    int			*openTimeStampPtr;/* Generated for the client so it can
					 * catch races between the return from
					 * this open and other cache messages */
{
    register Fsconsist_Info *consistPtr = &handlePtr->consist;
    Boolean			cache;
    register	ReturnStatus	status;

    LOCK_MONITOR;

    cache = (srcClientID == consistPtr->lastWriter);

    if (closeSrc) {
	/*
	 * Remove references due to the original client so it doesn't confuse
	 * the regular cache consistency algorithm.  Note that this call
	 * doesn't disturb the last writer state so any dirty blocks on
	 * the old client will get handled properly.
	 */
	if (!Fsconsist_IOClientClose(&consistPtr->clientList, srcClientID,
				     useFlags, &cache)) {
	    printf("Fsconsist_MigrateConsistency, srcClient %d unknown for %s %s <%d,%d>\n",
		srcClientID,
		Fsutil_FileTypeToString(handlePtr->hdr.fileID.type),
		Fsutil_HandleName(handlePtr),
		handlePtr->hdr.fileID.major, handlePtr->hdr.fileID.minor);
	}
    }
    /*
     * The rest of this is like regular cache consistency.
     */

    StartConsistency(consistPtr, dstClientID, (int) (useFlags | FS_MIGRATING),
		     cacheablePtr);
    if (useFlags & FS_NEW_STREAM) {
	/*
	 * The client is getting the stream to this I/O handle for
	 * the first time so we should add it as a client.  We are
	 * careful about this because there is only one reference to
	 * the I/O handle per client per stream. 
	 */
	UpdateList(consistPtr, dstClientID, useFlags, *cacheablePtr,
		    openTimeStampPtr);
    }
    status = EndConsistency(consistPtr);

    UNLOCK_MONITOR;
    return(status);
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fsconsist_GetClientAttrs --
 *
 *	This does call-backs to clients to flush back cached attributes.
 *	Files that are being executed are treated as a special case.  They
 *	are not being written so we, the server, have the right size and
 *	modify time.  Instead of getting access times from clients (there
 *	could be lots and lots) we just return a flag that says the
 *	file is being executed.  Our caller will presumably use the
 *	the current time for the access time in this case.
 *
 * Results:
 *	*isExecedPtr set to TRUE if the file is being executed.
 *
 * Side effects:
 *      RPC's may be done to clients using the file to tell them to write
 *	back their cached attributes.
 *	This unlocks the handle while waiting for clients, but
 *	re-locks it before returning.
 *
 * ----------------------------------------------------------------------------
 */
ENTRY void
Fsconsist_GetClientAttrs(handlePtr, clientID, isExecedPtr)
    register Fsio_FileIOHandle *handlePtr;
    int			clientID;	/* The client who is doing the stat.*/
    Boolean		*isExecedPtr;	/* TRUE if file is being executed.
					 * Our caller will use the current
					 * time for the access time in this
					 * case */
{
    register Boolean		isExeced = FALSE;
    register Fsconsist_Info	*consistPtr = &handlePtr->consist;
    register Fsconsist_ClientInfo	*clientPtr;
    register Fsconsist_ClientInfo	*nextClientPtr;

    /*
     * Unlock the handle so other operations on the file can proceed while
     * we probe around the network for the most up-to-date attributes.
     * Otherwise the following deadlock is possible:
     * Client 1 does a get attributes about the same time client 2 does
     * a close.  Client 2 has its handle locked during the close, but we
     * will be calling back to it to get its attributes.  Our callback can't
     * start until client 2 unlocks its handle, but it can't unlock it's
     * handle until the close finishes.  The close can't finish because
     * it is blocked here on the locked handle.
     */

    Fsutil_HandleUnlock(handlePtr);
    LOCK_MONITOR;

    /*
     * Make sure that noone else is in the middle of performing cache
     * consistency on this handle.  If so wait until they are done.
     */
    while (consistPtr->flags & FS_CONSIST_IN_PROGRESS) {
	(void) Sync_Wait(&consistPtr->consistDone, FALSE);
    }
    consistPtr->flags = FS_CONSIST_IN_PROGRESS;

    /*
     * Go through the set of clients using the file and see if they
     * are caching attributes.
     */
    nextClientPtr = (Fsconsist_ClientInfo *)List_First(&consistPtr->clientList);
    while (!List_IsAtEnd(&consistPtr->clientList, (List_Links *)nextClientPtr)){
	clientPtr = nextClientPtr;
	clientPtr->locked = FALSE;;
	nextClientPtr = (Fsconsist_ClientInfo *)List_Next((List_Links *)clientPtr);
	/*
	 * Hang onto the next client list element across calls to ClientCommand,
	 * which releases the consistency lock and allows list deletions.
	 */
	if (!List_IsAtEnd(&consistPtr->clientList,(List_Links *)nextClientPtr)){
	    nextClientPtr->locked = TRUE;
	}
	if (clientPtr->use.exec > 0) {
	    isExeced = TRUE;
	}
	if ((clientPtr->cached) && (clientPtr->use.ref > 0)) {
	    if ((clientPtr->clientID != clientID) &&
		(clientPtr->use.exec == 0)) {
		/*
		 * Don't call back to our caller because it will check
		 * its own attributes later.  Also, don't send rpcs to
		 * clients executing files.  For these clients we just
		 * set the access time to the current time.  This
		 * is an optimization to not make stating of binaries
		 * abysmally slow.
		 */

		ClientCommand(consistPtr, clientPtr, FSCONSIST_WRITE_BACK_ATTRS);
	    }
	}
    }
    /*
     * Now that we are all set up, and have told all the other clients using
     * the file what they have to do, we wait for them to finish.
     */
    (void)EndConsistency(consistPtr);

    *isExecedPtr = isExeced;
    UNLOCK_MONITOR;
    Fsutil_HandleLock(handlePtr);
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fsconsist_Close --
 *
 *	A thin layer on top of Fsconsist_IOClientClose that also cleans up
 *	the last writer of a file.
 *
 * Results:
 *	TRUE if there was a record that the client was using the file.
 *	This is used to trap out invalid closes.  Also, *wasCachedPtr
 *	is set to TRUE if the file (in particular, its attributes) was
 *	cached on the client.
 *
 * Side effects:
 *	The client list entry is removed.  If the client was
 *	the last writer but has no dirty blocks (as indicated by the flags)
 *	then the last writer field of the consist info is cleared.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY Boolean
Fsconsist_Close(consistPtr, clientID, flags, wasCachedPtr)
    register Fsconsist_Info *consistPtr;	/* Handle of file being closed */
    int			clientID;	/* Host ID of client that had it open */
    register int	flags;		/* Flags from the stream. */
    Boolean		*wasCachedPtr;	/* TRUE upon return if the client was
					 * caching (attributes) of the file. */
{
    LOCK_MONITOR;

    *wasCachedPtr = (consistPtr->lastWriter == clientID);
    if (!Fsconsist_IOClientClose(&consistPtr->clientList, clientID, flags,
			 wasCachedPtr)) {
	UNLOCK_MONITOR;
	return(FALSE);
    }

    if ((consistPtr->lastWriter != -1) && (flags & FS_LAST_DIRTY_BLOCK)) {
        if (clientID != consistPtr->lastWriter) {
            /*
             * Probably a client error with the lastWriter.  We print
             * a warning and then nuke the lastWriter field below.
             */
            printf("%s, \"%s\" <%d,%d>: client %d not last writer %d, %s\n",
                    "Fsconsist_Close",
                    Fsutil_HandleName(consistPtr->hdrPtr),
                    consistPtr->hdrPtr->fileID.major,
                    consistPtr->hdrPtr->fileID.minor,
                    clientID, consistPtr->lastWriter,
                    (*wasCachedPtr) ? "was cached" : "wasn't cached");
        }
        consistPtr->lastWriter = -1;
    }

    UNLOCK_MONITOR;
    return(TRUE);
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fsconsist_NumClients --
 *
 *	Returns the number of clients in the client list for a file.
 *	Called to see if it's ok to scavenge the file handle.
 *
 * Results:
 *	The number of clients in the client list.
 *
 * Side effects:
 *	Unused client list entries are cleaned up.  We only need to remember
 *	clients that are actively using the file or who have dirty blocks
 *	because they are the last writer.
 *
 * ----------------------------------------------------------------------------
 *
 */

ENTRY int
Fsconsist_NumClients(consistPtr)
    register Fsconsist_Info *consistPtr;    /* Handle of file being closed */
{
    register int numClients = 0;
    register Fsconsist_ClientInfo *clientPtr;
    register Fsconsist_ClientInfo *nextClientPtr;

    LOCK_MONITOR;

    if (consistPtr->flags & FS_CONSIST_IN_PROGRESS) {
	/*
	 * Not safe to mess with list during consistency.
	 */
	numClients = 1;
	goto exit;
    }
    nextClientPtr = (Fsconsist_ClientInfo *)List_First(&consistPtr->clientList);
    while (!List_IsAtEnd(&consistPtr->clientList, (List_Links *)nextClientPtr)){
	clientPtr = nextClientPtr;
	nextClientPtr = (Fsconsist_ClientInfo *)List_Next((List_Links *)clientPtr);
	/*
	 * Nuke the client list entry if the client isn't using the file now,
	 * and it isn't a remote client holding dirty blocks,
	 * and this element isn't locked by another process doing consistency.
	 */
	if (clientPtr->use.ref == 0 &&
	    ((clientPtr->clientID == rpc_SpriteID) || 
	     (clientPtr->clientID != consistPtr->lastWriter)) &&
	    !clientPtr->locked) {
	    REMOVE_CLIENT(clientPtr);
	} else {
	    numClients++;
	}
    }
exit:
    UNLOCK_MONITOR;
    return(numClients);
}


/*
 * ----------------------------------------------------------------------------
 *
 * Fsconsist_DeleteLastWriter --
 *
 *	Remove the last writer from the consistency list.  This is called
 *	from the write rpc stub when the last block of a file comes
 *	in from a remote client.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Removes the client list entry for the last writer if the last
 *	writer is no longer using the file.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fsconsist_DeleteLastWriter(consistPtr, clientID)
    Fsconsist_Info *consistPtr;
    int		clientID;
{
    register	Fsconsist_ClientInfo	*clientPtr;

    LOCK_MONITOR;

    if (consistPtr->flags & FS_CONSIST_IN_PROGRESS) {
	/*
	 * Not safe to mess with the list during consistency.  We are called
	 * from Fsrmt_RpcWrite on the client's last block, but we will
	 * delete the last writer in ProcessConsistReply if the write-back
	 * is forced as part of cache consistency.
	 */
	UNLOCK_MONITOR;
	return;
    }
    LIST_FORALL(&consistPtr->clientList, (List_Links *) clientPtr) {
	if (clientPtr->clientID == clientID) {
	    if (clientPtr->use.ref == 0 &&
		consistPtr->lastWriter == clientID) {
		if (!clientPtr->locked) {
		    Fsrecov_HandleState	recovInfo;
		    ReturnStatus	status;

		    REMOVE_CLIENT(clientPtr);
		    /*
		     * If the handle had a 0 ref count but was still in the
		     * recovery box due to having dirty blocks in the client's
		     * cache, we can now get rid of it.
		     */
		    if (recov_Transparent &&
			    Fsrecov_GetHandle(consistPtr->hdrPtr->fileID,
			    clientID, &recovInfo, FALSE) == SUCCESS) {
			if (recovInfo.use.ref <= 0) {
			    status = Fsrecov_DeleteHandle(consistPtr->hdrPtr,
				    clientID, FS_WRITE | FS_LAST_DIRTY_BLOCK);
			    if (status != SUCCESS) {
				/* Should I panic? */
				printf("Fsconsist_ClientRemoveCallback: couldn't ");
				printf("delete handle from recov box.\n");
			    }
			} else {
			    printf("Fsconsist_ClientRemoveCallback: ref count ");
			    panic("on object is too high.");
			}
		    }
		}
		consistPtr->lastWriter = -1;
		break;
	    }
	}
    }
    UNLOCK_MONITOR;
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fsconsist_ClientRemoveCallback --
 *
 *      Called when a file is deleted.  Send an rpc to the client who has
 *      dirty blocks cached telling it to delete them from its cache.
 *	We may have forgotten about clients with clean blocks so we can't
 *	call them back.  Instead we depend on the version number being
 *	incremented to catch old blocks left in caches.  There are two
 *	reasons to tell the last writer - first, it prevents needless
 *	write-backs, which consumes our CPU, and it is nice to the client
 *	because it can make room in its cache by deleting the file.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Any remotely cached dirty data is invalidated.
 *	All the entries in the client list are deleted.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fsconsist_ClientRemoveCallback(consistPtr, clientID)
    Fsconsist_Info *consistPtr;	/* File to check */
    int		clientID;	/* Client who is removing the file.  This
				 * host is not contacted via call-back.
				 * Instead, the current RPC (close) should
				 * return FS_FILE_REMOVED.  Note, a callback
				 * is made during a remove-by-name. */
{
    register	Fsconsist_ClientInfo	*clientPtr;
    int				curClientID;

    Fsutil_HandleUnlock(consistPtr->hdrPtr);

    LOCK_MONITOR;

    while (consistPtr->flags & FS_CONSIST_IN_PROGRESS) {
	(void) Sync_Wait(&consistPtr->consistDone, FALSE);
    }
    consistPtr->flags = FS_CONSIST_IN_PROGRESS;

    /*
     * Loop through the list notifying clients and deleting client elements.
     */
    while (!List_IsEmpty((List_Links *)&consistPtr->clientList)) {
	clientPtr = (Fsconsist_ClientInfo *)
		    List_First((List_Links *) &consistPtr->clientList);
	curClientID = clientPtr->clientID;
	if (clientPtr->use.ref > 0) {
	    printf("Fsconsist_ClientRemoveCallback: Client %d using removed file <%s>\n",
		curClientID, Fsutil_HandleName(consistPtr->hdrPtr));
	} else if (consistPtr->lastWriter != -1) {
	    if (clientPtr->clientID != consistPtr->lastWriter) {
		printf("Fsconsist_ClientRemoveCallback: \"%s\" <%d,%d> client %d not last writer (%d).\n",
			Fsutil_HandleName(consistPtr->hdrPtr),
			consistPtr->hdrPtr->fileID.major,
			consistPtr->hdrPtr->fileID.minor,
			clientPtr->clientID, consistPtr->lastWriter);
	    } else if (clientPtr->clientID != clientID) {
		Fsrecov_HandleState	recovInfo;
		ReturnStatus		status;
		/*
		 * Tell the client caching the file to remove it from its cache.
		 * This should only be the last writer as we are called only
		 * when it is truely time to remove the file.
		 */
		ClientCommand(consistPtr, clientPtr, FSCONSIST_DELETE_FILE);
		(void)EndConsistency(consistPtr);
		/*
		 * If the handle had a 0 ref count but was still in the
		 * recovery box due to having dirty blocks in the client's
		 * cache, we can now get rid of it.
		 */
		if (recov_Transparent &&
			Fsrecov_GetHandle(consistPtr->hdrPtr->fileID,
			clientPtr->clientID, &recovInfo, FALSE) == SUCCESS) {
		    if (recovInfo.use.ref <= 0) {
			status = Fsrecov_DeleteHandle(consistPtr->hdrPtr,
				clientPtr->clientID,
				FS_WRITE | FS_LAST_DIRTY_BLOCK);
			if (status != SUCCESS) {
			    /* Should I panic? */
			    printf("Fsconsist_ClientRemoveCallback: couldn't ");
			    printf("delete handle from recov box.\n");
			}
		    }
		}
	    }
	}
	/*
	 * We have to check carefully that the client element is still
	 * here because it may already be removed by ClientKill.
	 */
	LIST_FORALL((List_Links *)&consistPtr->clientList,
		    (List_Links *)clientPtr) {
	    if (clientPtr->clientID == curClientID) {
		REMOVE_CLIENT(clientPtr);
		break;
	    }
	}
    }
    consistPtr->flags = 0;
    consistPtr->lastWriter = -1;
    UNLOCK_MONITOR;
    Fsutil_HandleLock(consistPtr->hdrPtr);
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fsconsist_Kill --
 *
 *	Find and remove the given client in the list for the handle.  The
 *	number of client references, writers, and executers is returned
 *	so our caller can clean up the reference counts in the handle.
 *
 * Results:
 *	*inUsePtr set to TRUE if the client has the file open, *writingPtr
 *	set to TRUE if the client has the file open for writing, and 
 *	*executingPtr set to TRUE if the client has the file open for
 *	execution.
 *	
 * Side effects:
 *	If this client was the last writer for the file then the last
 *	writer field in the handle is set to -1.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fsconsist_Kill(consistPtr, clientID, refPtr, writePtr, execPtr)
    Fsconsist_Info *consistPtr;	/* Consistency state from which to remove
				 * the client. */
    int		clientID;	/* Client to delete. */
    int		*refPtr;	/* Number of times client has file open. */
    int		*writePtr;	/* Number of times client is writing file. */
    int		*execPtr;	/* Number of times clients is executing file.*/
{
    register ConsistMsgInfo 	*msgPtr;

    LOCK_MONITOR;

    Fsconsist_IOClientKill(&consistPtr->clientList, clientID, refPtr, writePtr,
		    execPtr);

    if (consistPtr->lastWriter == clientID) {
	consistPtr->lastWriter = -1;
    }
    /*
     * Remove the client from the list of clients involved in a cache
     * consistency action so we don't hang on the dead client.
     */
    LIST_FORALL(&(consistPtr->msgList), (List_Links *) msgPtr) {
	if (msgPtr->clientID == clientID) {
	    List_Remove((List_Links *) msgPtr);
	    free((Address) msgPtr);
	    Sync_Broadcast(&consistPtr->repliesIn);
	    break;
	}
    }

    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------------
 *
 * Fsconsist_GetAllDirtyBlocks --
 *
 *	Retrieve dirty blocks from all clients that have files open on the
 *	given domain.  This is called when a disk is being detached.  We
 *	have to get any outstanding data before taking the disk off-line.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------------
 */
void
Fsconsist_GetAllDirtyBlocks(domain, invalidate)
    int		domain;		/* Domain to get dirty blocks for. */
    Boolean	invalidate;	/* Remove file from cache after getting blocks
				 * back. */
{
    Hash_Search				hashSearch;
    register	Fs_HandleHeader		*hdrPtr;

    Hash_StartSearch(&hashSearch);
    for (hdrPtr = Fsutil_GetNextHandle(&hashSearch);
	 hdrPtr != (Fs_HandleHeader *) NIL;
         hdrPtr = Fsutil_GetNextHandle(&hashSearch)) {
	if (hdrPtr->fileID.type == FSIO_LCL_FILE_STREAM &&
	    hdrPtr->fileID.major == domain) {
	    register Fsio_FileIOHandle *handlePtr =
		    (Fsio_FileIOHandle *) hdrPtr;
	    Fsconsist_FetchDirtyBlocks(&handlePtr->consist, invalidate);
	}
	Fsutil_HandleUnlock(hdrPtr);
    }
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fsconsist_FetchDirtyBlocks --
 *
 *      Fetch dirty blocks back from the last writer of the file.
 *	This is called when a domain is being detached (dis-mounted)
 *	and we want all dirty data to be written back first.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If the last writer doesn't have the file actively open, then it is
 *	no longer the last writer and it is deleted from the client list.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fsconsist_FetchDirtyBlocks(consistPtr, invalidate)
    Fsconsist_Info *consistPtr;	/* Consistency state for file. */
    Boolean	invalidate;	/* If TRUE the client is told to invalidate
				 * after writing back the blocks */
{
    register	Fsconsist_ClientInfo	*clientPtr;
    register	Fsconsist_ClientInfo	*nextClientPtr;

    Fsutil_HandleUnlock(consistPtr->hdrPtr);
    LOCK_MONITOR;

    /*
     * Make sure that no one else is in the middle of performing cache
     * consistency on this handle.  If so wait until they are done.
     */
    while (consistPtr->flags & FS_CONSIST_IN_PROGRESS) {
	(void) Sync_Wait(&consistPtr->consistDone, FALSE);
    }
    /*
     * See if there are any dirty blocks to fetch.
     */
    if (consistPtr->lastWriter == -1 ||
	consistPtr->lastWriter == rpc_SpriteID) {
        UNLOCK_MONITOR;
	Fsutil_HandleLock(consistPtr->hdrPtr);
	return;
    }
    consistPtr->flags = FS_CONSIST_IN_PROGRESS;

    /*
     * There is a last writer.  In this case the only thing on the list is
     * the client that is the last writer because we know the domain for
     * the file is in-active.
     */
    nextClientPtr = (Fsconsist_ClientInfo *)List_First(&consistPtr->clientList);
    while (!List_IsAtEnd(&consistPtr->clientList, (List_Links *)nextClientPtr)){
	clientPtr = nextClientPtr;
	clientPtr->locked = FALSE;
	nextClientPtr = (Fsconsist_ClientInfo *)List_Next((List_Links *)clientPtr);
	if (!List_IsAtEnd(&consistPtr->clientList,(List_Links *)nextClientPtr)){
	    nextClientPtr->locked = TRUE;
	}
	if (clientPtr->clientID != consistPtr->lastWriter) {
	    Fsutil_HandleLock(consistPtr->hdrPtr);
	    consistPtr->flags = 0;
	    UNLOCK_MONITOR;
	    panic("Fsconsist_FetchDirtyBlocks: Non last writer in list.\n");
	    return;
	} else if (clientPtr->use.write > 0) {
	    /*
	     * The client has it actively open for writing.  In this case don't
	     * do anything because he can have more dirty blocks anyway.
	     */
	} else {
	    register int flags = FSCONSIST_WRITE_BACK_BLOCKS;
	    if (invalidate) {
		flags |= FSCONSIST_INVALIDATE_BLOCKS;
	    }
	    ClientCommand(consistPtr, clientPtr, flags);
	    (void)EndConsistency(consistPtr);
	}
    }
    consistPtr->flags = 0;
    UNLOCK_MONITOR;
    Fsutil_HandleLock(consistPtr->hdrPtr);
    return;
}

/*
 * The consistency messages are issued in two parts.  In the first phase
 * the server issues all the clients commands, but the clients return
 * an RPC reply immediately and schedule ProcessConsist in the background
 * to actually effect the cache consistency.  The second phase consists
 * of the server waiting around for a return RPC by the client that
 * indicates that it is done.
 */
void	ProcessConsist();
void	ProcessConsistReply();
/*
 * Consist message information.
 */
typedef struct ConsistItem {
    int		serverID;
    ConsistMsg args;
} ConsistItem;

/*
 * ----------------------------------------------------------------------------
 *
 * ClientCommand --
 *
 *	Send an rpc to a client telling him to perform some cache 
 *	consistency operation.  Also put the client onto a list of 
 *	outstanding cache consistency messages.
 *
 * Results:
 *	The status from the RPC.
 *
 * Side effects:
 *	All locks except the consistency-in-progress lock are released
 *	during the call back to the client.  This allows operations like
 *	write-backs and unrelated closes of the file to complete.
 *	However, this means that the state of a file can change considerably
 *	during a call-back.  Of concern to routines in this file is that
 *	client list entries might get deleted, so LIST_FORALL doesn't work.
 *	Callers of ClientCommand have to be coded to reflect this.
 *
 * ----------------------------------------------------------------------------
 *
 */

INTERNAL void
ClientCommand(consistPtr, clientPtr, flags)
    register Fsconsist_Info *consistPtr;	/* Consistency state of file */
    Fsconsist_ClientInfo *clientPtr;	/* State of other client's cache */
    int			flags;		/* Command for the other client */
{
    Rpc_Storage		storage;
    ConsistMsg		consistRpc;
    ReturnStatus	status;
    ConsistMsgInfo	*msgPtr;
    int			numRefusals;

    if (clientPtr->clientID == rpc_SpriteID) {
	/*
	 * Don't issue commands to ourselves (the server) because the commands
	 * issued to the other clients (write-back, invalidate, etc.) will
	 * all result in a consistent server cache anyway.
	 */
	if (flags & FSCONSIST_INVALIDATE_BLOCKS) {
	    /*
	     * If we told ourselves to invalidate the file then mark us
	     * as not caching the file.
	     */
	    clientPtr->cached = FALSE;
	}
	if (flags & FSCONSIST_WRITE_BACK_BLOCKS) {
	    /*
	     * We already have the most recent blocks.
	     */
	    consistPtr->lastWriter = -1;
	}
	if (clientPtr->use.ref == 0 && 
	    consistPtr->lastWriter != clientPtr->clientID) {
	    FSCACHE_DEBUG_PRINT1("ClientCommand: Removing %d ",
					clientPtr->clientID);
	    REMOVE_CLIENT(clientPtr);
	}
	return;
    }
    /*
     * Map to the client's view of the file (i.e. remote).
     */
    consistRpc.fileID = consistPtr->hdrPtr->fileID;
    if (consistRpc.fileID.type != FSIO_LCL_FILE_STREAM) {
	    panic("ClientCommand, bad stream type <%d>\n",
		    consistRpc.fileID.type);
    } else {
	consistRpc.fileID.type = FSIO_RMT_FILE_STREAM;
    }
    /*
     * The openTimeStamp lets the client catch races between this message
     * and the reply to an open it may be making at the same time.
     */
    consistRpc.flags = flags;
    consistRpc.openTimeStamp = clientPtr->openTimeStamp;
    consistRpc.version =
	((Fsio_FileIOHandle *)consistPtr->hdrPtr)->cacheInfo.version;

    storage.requestParamPtr = (Address) &consistRpc;
    storage.requestParamSize = sizeof(ConsistMsg);
    storage.requestDataPtr = (Address) NIL;
    storage.requestDataSize = 0;

    storage.replyParamPtr = (Address) NIL;
    storage.replyParamSize = 0;
    storage.replyDataPtr = (Address) NIL;
    storage.replyDataSize = 0;

    /*
     * Put the client onto the list of outstanding cache consistency
     * messages.
     */

    msgPtr = (ConsistMsgInfo *) malloc(sizeof(ConsistMsgInfo));
    msgPtr->clientID = clientPtr->clientID;
    msgPtr->flags = consistRpc.flags;
    List_Insert((List_Links *) msgPtr, LIST_ATREAR(&consistPtr->msgList));

    /*
     * Have to release this monitor during the call-back so that
     * an unrelated close can complete its call to Fsconsist_Close.
     * Alternatives are to fix the consistency call-back RPC stubs
     * so they don't lock the handle.
     */
    if ((consistPtr->flags & FS_CONSIST_IN_PROGRESS) == 0) {
	panic( "Client CallBack - consist flag not set\n");
    }
    UNLOCK_MONITOR;
    numRefusals = 0;
    while ( TRUE ) {
	/*
	 * Send the rpc to the client.  The client will return FAILURE if the
	 * open that we are talking about hasn't returned to the client yet.
	 */
	status = Rpc_Call(clientPtr->clientID, RPC_FS_CONSIST, &storage);
	if (status != FAILURE) {
	    break;
	} else {
	    numRefusals++;
	    if (numRefusals > 30) {
		printf("Client %d dropped 30 %s requests for \"%s\" <%d,%d>\n",
			    clientPtr->clientID, ConsistType(flags),
			    Fsutil_HandleName(consistPtr->hdrPtr),
			    consistRpc.fileID.major, consistRpc.fileID.minor);
		numRefusals = 0;
	    }
	}
    }
    if (status != SUCCESS) {
	/*
	 * Couldn't post call-back to the client.
	 */
	int ref, write, exec;
	int clientID = clientPtr->clientID;
	printf("ClientCommand, %s msg to client %d file \"%s\" <%d,%d> failed %x\n",
	    ConsistType(flags), clientID, Fsutil_HandleName(consistPtr->hdrPtr),
	    consistRpc.fileID.major, consistRpc.fileID.minor, status);
	if (status == RPC_TIMEOUT || status == FS_STALE_HANDLE) {
	    /*
	     * If its really down, then nuke it from the
	     * list of clients using the file.
	     */
	    Fsconsist_Kill(consistPtr, clientPtr->clientID, &ref, &write, &exec);
	    printf("\tClient state killed: %d refs %d write %d exec\n",
			ref, write, exec);
	} else {
	    /*
	     * Just nuke the message from the list so EndConsistency
	     * terminates.  Sometimes the callback fails because the
	     * host is still booting and hasn't enabled its RPC service yet.
	     */
	    List_Remove((List_Links *)msgPtr);
	    free((Address)msgPtr);
	}
    }
    LOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * Fsconsist_RpcConsist --
 *
 *	Service stub for RPC_FS_CONSIST.  This is executed on a filesystem
 *	client in response to a cache consistency command.  This schedules
 *	a call to ProcessConsist and returns a reply to the server.
 *	If, by remote chance, the message concerns an in-progress open
 *	that hasn't yet completed, we just return an error code to the
 *	server so that it will re-send its request after we know about
 *	the open.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Add work to the queue for the client consistency process.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Fsconsist_RpcConsist(srvToken, clientID, command, storagePtr)
    ClientData srvToken;	/* Handle on server process passed to
				 * Rpc_Reply */
    int clientID;		/* ID of server controlling the file */
    int command;		/* Command identifier */
    Rpc_Storage *storagePtr;	/* The request fields refer to the request
				 * buffers and also indicate the exact amount
				 * of data in the request buffers.  The reply
				 * fields are initialized to NIL for the
				 * pointers and 0 for the lengths.  This can
				 * be passed to Rpc_Reply */
{
    register ConsistMsg		*consistArgPtr;
    register ConsistItem	*consistPtr;
    register Fsrmt_FileIOHandle	*rmtHandlePtr;
    register ReturnStatus	status;

    consistArgPtr = (ConsistMsg *)storagePtr->requestParamPtr;
    if (consistArgPtr->fileID.type != FSIO_RMT_FILE_STREAM) {
	printf("Fsconsist_RpcConsist bad fileID <%d,%d,%d,%d> from client %d\n",
		    consistArgPtr->fileID.type, consistArgPtr->fileID.serverID,
		    consistArgPtr->fileID.major, consistArgPtr->fileID.minor,
		    clientID);
	return(FAILURE);
    }
    /*
     * This fetch locks the handle.  In earlier versions of the kernel
     * this could cause deadlock.  This may still be true.  3/9/88.
     */
    rmtHandlePtr = Fsutil_HandleFetchType(Fsrmt_FileIOHandle,
					  &consistArgPtr->fileID);
    if (rmtHandlePtr == (Fsrmt_FileIOHandle *)NIL) {
	if (Fsprefix_OpenInProgress(&consistArgPtr->fileID) == 0) {
	    status = FS_STALE_HANDLE;
	} else {
	    /*
	     * A consistency message has arrived from an open from which
	     * we haven't received the reply.  Return FAILURE to force
	     * the server to resend and give the open reply a chance
	     * of getting to us.  This is the "open/consistency race".
	     */
	    status = FAILURE;
	}
    } else if (rmtHandlePtr->openTimeStamp != consistArgPtr->openTimeStamp) {
	if ((rmtHandlePtr->cacheInfo.version == consistArgPtr->version) &&
	    ((consistArgPtr->flags & (FSCONSIST_DELETE_FILE|
				     FSCONSIST_WRITE_BACK_BLOCKS)) == 0)) {
	    /*
	     * We have the same version as the server, but there has been
	     * more open traffic than we realize.  If this is any command
	     * except a write-back or delete (like return-attrs), then
	     * we'll do it.
	     */
	    status = SUCCESS;
	} else if (Fsprefix_OpenInProgress(&consistArgPtr->fileID) == 0) {
	    status = FS_STALE_HANDLE;
	    printf("Fsconsist_RpcConsist: <%d,%d> %s msg from %d timestamp %d not %d\n\t version %d and %d, returning stale handle\n",
		    consistArgPtr->fileID.major,
		    consistArgPtr->fileID.minor,
		    ConsistType(consistArgPtr->flags),
		    consistArgPtr->fileID.serverID,
		    consistArgPtr->openTimeStamp, rmtHandlePtr->openTimeStamp,
		    consistArgPtr->version, rmtHandlePtr->cacheInfo.version);
	} else {
	    /*
	     * Timestamp mis-match and an open in progress.
	     * Possible open/consistency race.
	     */
	    status = FAILURE;
	}
    } else {
	status = SUCCESS;
    }

    if (rmtHandlePtr != (Fsrmt_FileIOHandle *)NIL) {
	Fsutil_HandleRelease(rmtHandlePtr, TRUE);
    }
    if (status == SUCCESS) {
	/*
	 * This is a message corresponding to our current notion of the
	 * file.  Pass the message to a consistency handler process.
	 */
	consistPtr = (ConsistItem *) malloc(sizeof(ConsistItem));
	consistPtr->serverID = clientID;
	consistPtr->args = *consistArgPtr;
	Proc_CallFunc(ProcessConsist, (ClientData) consistPtr, 0);
    }
    Rpc_Reply(srvToken, status, storagePtr, (int(*)())NIL, (ClientData)NIL);
    return(SUCCESS);
}


/*
 * ----------------------------------------------------------------------------
 *
 * ProcessConsist --
 *
 *	Process a cache consistency request from the server.  This
 *	is called in the background as the result of a request from
 *	the server.  This routine is a thin wrapper around a routine
 *	in the cache module that does all the work.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	See Fscache_Consist.
 *
 * ----------------------------------------------------------------------------
 *
 */
void
ProcessConsist(data, callInfoPtr)
    ClientData		data;
    Proc_CallInfo	*callInfoPtr;
{
    register Fsrmt_FileIOHandle 	*handlePtr;
    ReturnStatus		status;
    Rpc_Storage			storage;
    ConsistReply		reply;
    register	ConsistItem	*consistPtr;

    consistPtr = (ConsistItem *) data;
    callInfoPtr->interval = 0;

    handlePtr = Fsutil_HandleFetchType(Fsrmt_FileIOHandle,
				       &consistPtr->args.fileID);
    if (handlePtr == (Fsrmt_FileIOHandle *)NIL) {
	printf("ProcessConsist: no handle <%d, %d, %d, %d>\n",
		    consistPtr->args.fileID.type,
		    consistPtr->args.fileID.serverID,
		    consistPtr->args.fileID.major,
		    consistPtr->args.fileID.minor);
	free((char *) consistPtr);
	return;
    }
    Fsutil_HandleUnlock(handlePtr);

    FSCACHE_DEBUG_PRINT2("ProcessConsist: Got %s request for file %d\n", 
	ConsistType(consistPtr->args.flags), handlePtr->rmt.hdr.fileID.minor);

    /*
     * Process the request under the per file cache lock.
     */
    reply.status = Fscache_Consist(&handlePtr->cacheInfo,
			consistPtr->args.flags, &reply.cachedAttr);
    reply.fileID = handlePtr->rmt.hdr.fileID;
    reply.fileID.type = FSIO_LCL_FILE_STREAM;
    Fsutil_HandleRelease(handlePtr, FALSE);
    /*
     * Set up the reply buffer.
     */
    storage.requestParamPtr = (Address)&reply;
    storage.requestParamSize = sizeof(ConsistReply);
    storage.requestDataPtr = (Address)NIL;
    storage.requestDataSize = 0;
    storage.replyParamPtr = (Address)NIL;
    storage.replyParamSize = 0;
    storage.replyDataPtr = (Address)NIL;
    storage.replyDataSize = 0;

    for ( ; ; ) {
	status = Rpc_Call(consistPtr->serverID, RPC_FS_CONSIST_REPLY, &storage);
	if (status != SUCCESS) {
	    printf("Got error (%x) from consist reply on <%d,%d>\n", status,
		reply.fileID.major, reply.fileID.minor);
	}
	if (status != RPC_TIMEOUT) {
	    break;
	}
    }
    free((Address)consistPtr);
}


/*
 *----------------------------------------------------------------------
 *
 * Fsconsist_RpcConsistReply --
 *
 *	Service stub for RPC_FS_CONSIST_REPLY.  This RPC indicates that
 *	the client has completed the consistency actions we previously
 *	asked it to perform.
 *
 * Results:
 *	SUCCESS, unless we don't like the fileID specified by the client.
 *
 * Side effects:
 *	See ProcessConsistReply.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Fsconsist_RpcConsistReply(srvToken, clientID, command, storagePtr)
    ClientData srvToken;	/* Handle on server process passed to
				 * Rpc_Reply */
    int clientID;		/* Sprite ID of client host */
    int command;		/* Command identifier */
    Rpc_Storage *storagePtr;    /* The request fields refer to the request
				 * buffers and also indicate the exact amount
				 * of data in the request buffers.  The reply
				 * fields are initialized to NIL for the
				 * pointers and 0 for the lengths.  This can
				 * be passed to Rpc_Reply */
{
    Fsio_FileIOHandle	*handlePtr;
    ConsistReply	*replyPtr;

    replyPtr = (ConsistReply *) storagePtr->requestParamPtr;
    if (replyPtr->fileID.type != FSIO_LCL_FILE_STREAM) {
	printf("Fsconsist_RpcConsistReply: bad fileID <%d,%d,%d,%d> from client %d\n",
	    replyPtr->fileID.type, replyPtr->fileID.serverID,
	    replyPtr->fileID.major, replyPtr->fileID.minor, clientID);
	    return(GEN_INVALID_ARG);
    }
    handlePtr = Fsutil_HandleFetchType(Fsio_FileIOHandle, &(replyPtr->fileID));
    if (handlePtr == (Fsio_FileIOHandle *) NIL) {
	printf("Fsconsist_RpcConsistReply: no handle <%d,%d> for client %d\n",
	    replyPtr->fileID.major, replyPtr->fileID.minor, clientID);
	return(FS_STALE_HANDLE);
    }
    /*
     * Unlock the handle to prevent deadlock if this RPC
     * arrives as ClientRemoveCallback is attempting to relock
     * the handle on its way out of the per-file consistency monitor.
     * (This can only happen if the server 'kills' the client state and so
     * aborts the cache consistency wait before this arrives.)
     * Ordinarily this RPC arrives as it is waiting with the monitor
     * unlocked.  The handle lock is not needed anyway because once we have
     * successfully fetched the handle it won't go away on us.  Furthermore,
     * ProcessConsistReply can handle it if the client state has been killed.
     */
    Fsutil_HandleUnlock(handlePtr);
    ProcessConsistReply(&handlePtr->consist, clientID, replyPtr);
    Fsutil_HandleRelease(handlePtr, FALSE);
    Rpc_Reply(srvToken, SUCCESS, storagePtr, 
	      (int (*)())NIL, (ClientData)NIL);
    return(SUCCESS);
}


/*
 *----------------------------------------------------------------------
 *
 * ProcessConsistReply --
 *
 *	Process the reply sent by the client for the given handle.
 *	This updates the caching state of the client, and it may
 *	also update the handle attributes based on information returned
 *	from the client.  This is call after the client has completed
 *	the cache consistency actions we previously requested of it.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Element deleted from the list of outstanding client consist 
 *	messages.  Also if the message was for invalidation then the
 *	client list entry is marked as non-cacheable.  IMPORTANT:
 *	client list entry may be REMOVED here which prevents safe
 *	use of LIST_FORALL iteration over the client list by any
 *	routine that calls ClientCommand (which eventually gets us called)
 *
 *----------------------------------------------------------------------
 */
ENTRY void
ProcessConsistReply(consistPtr, clientID, replyPtr)
    Fsconsist_Info		*consistPtr;	/* File to process reply for*/
    int				clientID;	/* Client who sent us the 
						 * reply. */
    register	ConsistReply	*replyPtr;	/* The reply that was sent. */
{
    register	ConsistMsgInfo		*msgPtr;
    register	Fsconsist_ClientInfo 	*clientPtr;
    Boolean				found = FALSE;
    Fsio_FileIOHandle			*handlePtr;

    LOCK_MONITOR;

    /*
     * Find the client in the list of pending messages.  Notify the
     * opening process after all the clients have responded.
     */
    LIST_FORALL(&(consistPtr->msgList), (List_Links *) msgPtr) {
	if (msgPtr->clientID == clientID) {
	    List_Remove((List_Links *) msgPtr);
	    found = TRUE;
	    break;
	}
    }
    if (List_IsEmpty(&(consistPtr->msgList))) {
	Sync_Broadcast(&consistPtr->repliesIn);
    }
    if (!found) {
	/*
	 * We don't know about this cache consistency action by the
	 * client, perhaps because we concluded it was down and
	 * killed our state about it.  It is also possible that it is an
	 * old message from the client, probably queued in the network
	 * interface across a reboot or from a gateway.
	 */
	UNLOCK_MONITOR;
	return;
    }
    if (replyPtr->status != SUCCESS) {
	printf("ProcessConsist: %s request failed <%x> file \"%s\" <%d,%d>\n",
		ConsistType(msgPtr->flags), replyPtr->status,
		Fsutil_HandleName(consistPtr->hdrPtr),
		consistPtr->hdrPtr->fileID.major,
		consistPtr->hdrPtr->fileID.minor);
	consistPtr->flags |= FS_CONSIST_ERROR;
    } else {
	if ((msgPtr->flags & FSCONSIST_WRITE_BACK_BLOCKS) &&
	    (consistPtr->lastWriter == clientID)) {
	    /*
	     * We just got the most recent blocks so we don't care who the
	     * last writer is anymore.
	     */
	    consistPtr->lastWriter = -1;
	}
	/*
	 * Look for client list entry that match the client, and update
	 * its state to reflect the consistency action by the client.
	 * Because we've release the monitor lock during the previous
	 * call-back, an unrelated action may have removed the client
	 * from the list - no big deal.
	 */
	LIST_FORALL(&(consistPtr->clientList), (List_Links *) clientPtr) {
	    if (clientPtr->clientID == clientID) {
		Fsrecov_HandleState	recovInfo;
		ReturnStatus	status;

		handlePtr = (Fsio_FileIOHandle *)consistPtr->hdrPtr;
		if (msgPtr->flags & (FSCONSIST_WRITE_BACK_BLOCKS |
				     FSCONSIST_WRITE_BACK_ATTRS)) {
		    Fscache_UpdateAttrFromClient(clientID,
			    &handlePtr->cacheInfo, &replyPtr->cachedAttr);
		    (void) Fsdm_UpdateDescAttr(handlePtr, 
					&handlePtr->cacheInfo.attr, -1);
		}
		if (clientPtr->use.ref == 0 &&
		    consistPtr->lastWriter != clientID) {

		    /*
		     * If the handle had a 0 ref count but was still in the
		     * recovery box due to having dirty blocks in the client's
		     * cache, we can now get rid of it.  XXX I hope this is
		     * the right place to do it.  Should it be done
		     * above?  Leaving it here could get more clients,
		     * but if they aren't the last writer and they have 0 refs,
		     * they should go away.
		     */
		    if (recov_Transparent &&
			    Fsrecov_GetHandle(consistPtr->hdrPtr->fileID,
			    clientID, &recovInfo, FALSE) == SUCCESS) {
			if (recovInfo.use.ref <= 0) {
			    status = Fsrecov_DeleteHandle(consistPtr->hdrPtr,
				    clientID, FS_WRITE | FS_LAST_DIRTY_BLOCK);
			    if (status != SUCCESS) {
				/* Should I panic? */
				printf("ProcessConsistReply: couldn't ");
				printf("delete handle from recov box.\n");
			    }
			} else {
				printf("ProcessConsistReply: ref count ");
				panic("on object too high.");
			}
		    }
		    REMOVE_CLIENT(clientPtr);
		} else if (msgPtr->flags & FSCONSIST_INVALIDATE_BLOCKS) {
		    clientPtr->cached = FALSE;
		    /* Change cacheability info in recov box. */
		    if (recov_Transparent &&
			    Fsrecov_GetHandle(consistPtr->hdrPtr->fileID,
			    clientID, &recovInfo, FALSE) == SUCCESS) {
			if (recovInfo.clientData != FALSE) {
			    recovInfo.clientData = FALSE;
			    if (Fsrecov_UpdateHandle(consistPtr->hdrPtr->fileID,
				    clientID, &recovInfo) != SUCCESS) {
				printf(" ProcessConsistReply: ");
				printf("Couldn't update recov box.\n");
			    }
			}
		    }
		}
		break;
	    }
	}
    }
    free((Address) msgPtr);

    UNLOCK_MONITOR;
}


/*
 *----------------------------------------------------------------------
 *
 * ConsistType --
 *
 *	Utility routine to map from consistency flags to a printable string.
 *
 * Results:
 *	A pointer to a printable string.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char *
ConsistType(flags)
    int flags;		/* Cache consistency message flags */
{
    register char *result;

    switch (flags) {
    case FSCONSIST_WRITE_BACK_BLOCKS:
	result = "write-back";
	break;
    case FSCONSIST_INVALIDATE_BLOCKS:
	result = "invalidate";
	break;
    case (FSCONSIST_WRITE_BACK_BLOCKS|FSCONSIST_INVALIDATE_BLOCKS):
	result = "write-back & invalidate";
	break;
    case FSCONSIST_DELETE_FILE:
	result = "delete";
	break;
    case FSCONSIST_WRITE_BACK_ATTRS:
	result = "return-attrs";
	break;
    default:
	result = "UNKNOWN";
	break;
    }
    return result;
}

/*
 * ----------------------------------------------------------------------------
 *
 * Fsconsist_UpdateFileConsistencyList --
 *
 *	This updates the data structures to include this file in the
 *	client consistency lists.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Lists updated, lastWriter field set, etc.
 *
 * ----------------------------------------------------------------------------
 *
 */
ENTRY void
Fsconsist_UpdateFileConsistencyList(handlePtr, clientID, useFlags, cacheable)
    Fsio_FileIOHandle *handlePtr;	/* File to check consistency of. */
    int 		clientID;	/* ID of the host doing the open */
    register int 	useFlags;	/* useFlags from the open call */
    Boolean		cacheable;	/* TRUE if file is cacheable. */
{
    register Fsconsist_Info *consistPtr = &handlePtr->consist;
    LOCK_MONITOR;

    /*
     * Add ourselves to the list of clients using the file.
     */
    UpdateList(consistPtr, clientID, useFlags, cacheable, (int *) NIL);
    UNLOCK_MONITOR;
    return;
}
@


9.31
log
@Add debug printfs to track down bogus "disk full" messages.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fsconsist/fsconsistCache.c,v 9.30 92/04/17 13:53:56 jhh Exp $ SPRITE (Berkeley)";
d54 2
d1320 3
d1324 21
d1417 2
d1426 19
d2184 3
d2197 26
d2226 13
d2293 35
@


9.30
log
@Patched a memory leak.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fsconsist/fsconsistCache.c,v 9.29 91/12/12 11:58:15 mgbaker Exp $ SPRITE (Berkeley)";
d664 2
@


9.29
log
@Removing left-over SOSP tracing code.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fsconsist/fsconsistCache.c,v 9.28 91/10/08 14:12:14 mgbaker Exp $ SPRITE (Berkeley)";
d1938 1
@


9.28
log
@Some late sosp tracing.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsconsistCache.c,v 9.27 91/09/10 18:49:39 rab Exp Locker: mgbaker $ SPRITE (Berkeley)";
a1267 78
    UNLOCK_MONITOR;
    return(numClients);
}

/* This routine can be removed after sosp.  -Mary 10/1/91 */

/*
 * ----------------------------------------------------------------------------
 *
 * Fsconsist_MGBNumClients --
 *
 *	Returns the number of clients in the client list for a file.
 *	Called to see if it's ok to scavenge the file handle.
 *
 * Results:
 *	The number of clients in the client list.
 *
 * Side effects:
 *	Unused client list entries are cleaned up.  We only need to remember
 *	clients that are actively using the file or who have dirty blocks
 *	because they are the last writer.
 *
 * ----------------------------------------------------------------------------
 *
 */

ENTRY int
Fsconsist_MGBNumClients(consistPtr, numReadPtr, numWritePtr)
    register Fsconsist_Info *consistPtr;    /* Handle of file being closed */
    int	*numReadPtr;		/* Number of clients reading the file. */
    int	*numWritePtr;		/* Number of clients writing the file. */
{
    register int numClients = 0;
    register Fsconsist_ClientInfo *clientPtr;
    register Fsconsist_ClientInfo *nextClientPtr;
    int		numWrite = 0;
    int		numRead = 0;

    LOCK_MONITOR;

    if (consistPtr->flags & FS_CONSIST_IN_PROGRESS) {
	/*
	 * Not safe to mess with list during consistency.
	 */
	numClients = 1;
	goto exit;
    }
    nextClientPtr = (Fsconsist_ClientInfo *)List_First(&consistPtr->clientList);
    while (!List_IsAtEnd(&consistPtr->clientList, (List_Links *)nextClientPtr)){
	clientPtr = nextClientPtr;
	nextClientPtr = (Fsconsist_ClientInfo *)List_Next((List_Links *)clientPtr);
	/*
	 * Nuke the client list entry if the client isn't using the file now,
	 * and it isn't a remote client holding dirty blocks,
	 * and this element isn't locked by another process doing consistency.
	 */
	if (clientPtr->use.ref == 0 &&
	    ((clientPtr->clientID == rpc_SpriteID) || 
	     (clientPtr->clientID != consistPtr->lastWriter)) &&
	    !clientPtr->locked) {
	    REMOVE_CLIENT(clientPtr);
	} else {
	    numClients++;
	    if (clientPtr->use.write > 0) {
		numWrite++;
	    }
	    if (clientPtr->use.ref - clientPtr->use.write > 0) {
		numRead++;
	    }
	}
    }
exit:
    if (numWritePtr != (int *) NIL) {
	*numWritePtr = numWrite;
    }
    if (numReadPtr != (int *) NIL) {
	*numReadPtr = numRead;
    }
@


9.27
log
@Fixed lint errors and removed tracing.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsconsistCache.c,v 9.26 91/09/06 13:37:29 mgbaker Exp Locker: rab $ SPRITE (Berkeley)";
d1268 78
@


9.26
log
@Added back the FS_LAST_DIRTY_BLOCK code so we'll nuke the lastWriter when
we should.
@
text
@d29 2
a30 2
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsconsistCache.c,v 9.25 91/09/05 23:26:02 rab Exp Locker: mgbaker $ SPRITE (Berkeley)";
#endif not lint
a57 3
#ifdef CONSIST_DEBUG
int	fsTraceConsistMinor = 2249;
#endif /* CONSIST_DEBUG */
a140 1

a413 9
#ifdef CONSIST_DEBUG
    if (fsTraceConsistMinor == consistPtr->hdrPtr->fileID.minor) {
	printf("File <%d,%d> version %d start consist w/ use 0x%x, %s\n",
		consistPtr->hdrPtr->fileID.major,
		consistPtr->hdrPtr->fileID.minor,
		((Fsio_FileIOHandle *)consistPtr->hdrPtr)->cacheInfo.version,
		useFlags, (cacheable ? "cacheable" : "not cacheable"));
    }
#endif /* CONSIST_DEBUG */
a455 8
#ifdef CONSIST_DEBUG
	if (fsTraceConsistMinor == consistPtr->hdrPtr->fileID.minor) {
	    printf("Client %d, %s, use %d write %d\n",
		    clientPtr->clientID,
		    (clientPtr->cached ? "caching" : "not caching"),
		    clientPtr->use.ref, clientPtr->use.write);
	}
#endif /* CONSIST_DEBUG */
a593 7
#ifdef CONSIST_DEBUG
    if (fsTraceConsistMinor == consistPtr->hdrPtr->fileID.minor) {
	printf("UpdateList: client %d %s, last writer %d\n",
	    clientID, (clientPtr->cached ? "caching" : "not caching"),
	    consistPtr->lastWriter);
    }
#endif /* CONSIST_DEBUG */
a816 8
#ifdef CONSIST_DEBUG
    if (fsTraceConsistMinor == handlePtr->hdr.fileID.minor) {
	printf("Fsconsist_ReopenClient %d, use %d write %d, %s, last writer %d\n",
		clientID, use.ref, use.write, (found ? "found" : "not found"),
		consistPtr->lastWriter);
    }
#endif /* notdef */

a1183 6
#ifdef CONSIST_DEBUG
    if (consistPtr->hdrPtr->fileID.minor == fsTraceConsistMinor) {
	printf("ConsistClose: closing client %d, lastwriter %d\n",
		    clientID, consistPtr->lastWriter);
    }
#endif CONSIST_DEBUG
d1196 2
a1197 2
            printf("Fsconsist_Close, \"%s\" <%d,%d>: client %d not last writer %
d, %s\n",
a1203 5
#ifdef CONSIST_DEBUG
        if (consistPtr->hdrPtr->fileID.minor == fsTraceConsistMinor) {
            printf("ConsistClose: erasing %d lastwriter\n", clientID);
        }
#endif CONSIST_DEBUG
a1314 7
#ifdef CONSIST_DEBUG
		if (consistPtr->hdrPtr->fileID.minor == fsTraceConsistMinor) {
		    printf("Fsconsist_DeleteLastWriter <%d,%d> host %d\n",
			consistPtr->hdrPtr->fileID.major,
			consistPtr->hdrPtr->fileID.minor, clientID);
		}
#endif CONSIST_DEBUG
a1747 1
		consistRpc.flags |= FSCONSIST_DEBUG;
a1748 2
	    } else {
		consistRpc.flags &= ~FSCONSIST_DEBUG;
a1838 8
#ifdef CONSIST_DEBUG
	    printf("Fsconsist_RpcConsist: <%d,%d> %s msg from %d dropped: %s\n",
		    consistArgPtr->fileID.major,
		    consistArgPtr->fileID.minor,
		    ConsistType(consistArgPtr->flags),
		    consistArgPtr->fileID.serverID,
		    "no handle");
#endif /* CONSIST_DEBUG */
a1890 7
    } else if (consistArgPtr->flags & FSCONSIST_DEBUG) {
	printf("Fsconsist_RpcConsist: <%d,%d> Lots of %s msgs dropped: %s\n",
		    consistArgPtr->fileID.major,
		    consistArgPtr->fileID.minor,
		    ConsistType(consistArgPtr->flags),
		    (status == FS_STALE_HANDLE) ? "stale handle" :
						  "open in progress");
a1949 16
#ifdef CONSIST_DEBUG
    if (fsTraceConsistMinor == handlePtr->rmt.hdr.fileID.minor) {
	printf(
	"ProcessConsist, %s msg for file \"%s\" <%d,%d> version %d status %x\n",
	    ConsistType(consistPtr->args.flags), 
	    Fsutil_HandleName(handlePtr),
	    handlePtr->rmt.hdr.fileID.major, handlePtr->rmt.hdr.fileID.minor,
	    consistPtr->args.version, reply.status);
    }
#endif /* CONSIST_DEBUG */

    FSCACHE_DEBUG_PRINT2("Returning: mod (%d), acc (%d),",
		       reply.cachedAttr.modifyTime,
		       reply.cachedAttr.accessTime);
    FSCACHE_DEBUG_PRINT2(" first (%d), last (%d)\n",
		       reply.cachedAttr.firstByte, reply.cachedAttr.lastByte);
a2108 11
#ifdef CONSIST_DEBUG
    if (fsTraceConsistMinor == consistPtr->hdrPtr->fileID.minor) {
	printf(
	"ConsistReply, %s msg for file \"%s\" <%d,%d> writer %d status %x\n",
	    ConsistType(msgPtr->flags), 
	    Fsutil_HandleName(consistPtr->hdrPtr),
	    consistPtr->hdrPtr->fileID.major, consistPtr->hdrPtr->fileID.minor,
	    consistPtr->lastWriter,
	    replyPtr->status);
    }
#endif /* CONSIST_DEBUG */
d2156 1
d2179 20
a2198 19
    switch (flags & ~FSCONSIST_DEBUG) {
	case FSCONSIST_WRITE_BACK_BLOCKS:
	    result = "write-back";
	    break;
	case FSCONSIST_INVALIDATE_BLOCKS:
	    result = "invalidate";
	    break;
	case (FSCONSIST_WRITE_BACK_BLOCKS|FSCONSIST_INVALIDATE_BLOCKS):
	    result = "write-back & invalidate";
	    break;
	case FSCONSIST_DELETE_FILE:
	    result = "delete";
	    break;
	case FSCONSIST_WRITE_BACK_ATTRS:
	    result = "return-attrs";
	    break;
	default:
	    result = "UNKNOWN";
	    break;
d2200 1
a2200 1
    return(result);
@


9.25
log
@Mary checking this in for Bob.  He was doing the kernel cleanup changes.
I have an outstanding bug to fix.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsconsistCache.c,v 9.24 91/07/26 17:14:33 mendel Exp Locker: rab $ SPRITE (Berkeley)";
d1230 22
@


9.24
log
@Don't to consist stuff if last writer is local host.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsconsistCache.c,v 9.23 91/01/26 15:36:06 mgbaker Exp Locker: mendel $ SPRITE (Berkeley)";
a50 3
#ifdef SOSP91
#include	<sospRecord.h>
#endif /* SOSP91 */
a520 3
#ifdef SOSP91
		SOSP_ADD_CONSIST_ACTION_TRACE(clientID, clientPtr->clientID, consistPtr->hdrPtr->fileID, mode);
#endif SOSP91
a533 3
#ifdef SOSP91
		SOSP_ADD_CONSIST_ACTION_TRACE(clientID, clientPtr->clientID, consistPtr->hdrPtr->fileID, FSCONSIST_INVALIDATE_BLOCKS);
#endif SOSP91
a542 3
#ifdef SOSP91
		SOSP_ADD_CONSIST_ACTION_TRACE(clientID, clientPtr->clientID, consistPtr->hdrPtr->fileID, FSCONSIST_WRITE_BACK_BLOCKS | FSCONSIST_INVALIDATE_BLOCKS);
#endif SOSP91
a1054 3
#ifdef SOSP91
	SOSP_ADD_CONSIST_CHANGE_TRACE(srcClientID, consistPtr->hdrPtr->fileID, SOSP_CLOSE, cache);
#endif SOSP91
d1060 1
a1060 1
    StartConsistency(consistPtr, dstClientID, useFlags | FS_MIGRATING,
a1061 6
#ifdef SOSP91
    if (*cacheablePtr) {
	SOSP_ADD_CONSIST_CHANGE_TRACE(dstClientID, consistPtr->hdrPtr->fileID,
		SOSP_OPEN, useFlags & FS_WRITE);
    }
#endif /* SOSP91 */
a1171 4
#ifdef SOSP91
		/* what do I do about attribute call-backs? */
		SOSP_ADD_CONSIST_ACTION_TRACE(clientID, clientPtr->clientID, consistPtr->hdrPtr->fileID, FSCONSIST_WRITE_BACK_ATTRS);
#endif SOSP91
a1256 9
#ifdef SOSP91
ENTRY int
Fsconsist_NumClients(consistPtr, numReadPtr, numWritePtr)
    register Fsconsist_Info *consistPtr;   /* Handle of file being closed */
    int	*numReadPtr;		/* Number of clients reading the file. */
    int	*numWritePtr;		/* Number of clients writing the file. */

#else

a1259 3

#endif

a1264 6
#ifdef SOSP91
    int	numWrite = 0;
    int numRead = 0;
#endif


a1289 9
#ifdef SOSP91
	    if (clientPtr->use.write > 0) {
		numWrite++;
	    } 
	    if (clientPtr->use.ref - clientPtr->use.write > 0) {
		numRead++;
	    }
#endif

a1292 8
#ifdef SOSP91
    if (numWritePtr != (int *) NIL) {
	*numWritePtr = numWrite;
    }
    if (numReadPtr != (int *) NIL) {
	*numReadPtr = numRead;
    }
#endif
a1426 3
#ifdef SOSP91
		SOSP_ADD_CONSIST_ACTION_TRACE(clientID, clientPtr->clientID, consistPtr->hdrPtr->fileID, FSCONSIST_DELETE_FILE);
#endif SOSP91
a1623 4
#ifdef SOSP91
	    /*  This is a weird one XXX */
	    SOSP_ADD_CONSIST_ACTION_TRACE(rpc_SpriteID, clientPtr->clientID, consistPtr->hdrPtr->fileID, flags);
#endif SOSP91
@


9.24.1.1
log
@Initial branch for Sprite server.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/fsconsist/fsconsistCache.c,v 9.24 91/07/26 17:14:33 mendel Exp $ SPRITE (Berkeley)";
@


9.23
log
@Sosp stuff.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsconsistCache.c,v 9.22 91/01/07 23:30:25 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d1323 1
a1323 1
	 * and it isn't holding dirty blocks,
d1327 2
a1328 1
	    clientPtr->clientID != consistPtr->lastWriter &&
@


9.22
log
@More sosp tracing stuff.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsconsistCache.c,v 9.21 90/12/06 21:57:05 jhh Exp Locker: mgbaker $ SPRITE (Berkeley)";
a1256 20
    if ((consistPtr->lastWriter != -1) && (flags & FS_LAST_DIRTY_BLOCK)) {
	if (clientID != consistPtr->lastWriter) {
	    /*
	     * Probably a client error with the lastWriter.  We print
	     * a warning and then nuke the lastWriter field below.
	     */
	    printf("Fsconsist_Close, \"%s\" <%d,%d>: client %d not last writer %d, %s\n",
		    Fsutil_HandleName(consistPtr->hdrPtr),
		    consistPtr->hdrPtr->fileID.major,
		    consistPtr->hdrPtr->fileID.minor,
		    clientID, consistPtr->lastWriter,
		    (*wasCachedPtr) ? "was cached" : "wasn't cached");
	}
#ifdef CONSIST_DEBUG
	if (consistPtr->hdrPtr->fileID.minor == fsTraceConsistMinor) {
	    printf("ConsistClose: erasing %d lastwriter\n", clientID);
	}
#endif CONSIST_DEBUG
	consistPtr->lastWriter = -1;
    }
@


9.21
log
@Added sosp tracing code
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsconsistCache.c,v 9.20 90/11/25 16:26:02 mgbaker Exp $ SPRITE (Berkeley)";
a563 4
#ifdef SOSP91
	SOSP_ADD_CONSIST_CHANGE_TRACE(clientID, consistPtr->hdrPtr->fileID, SOSP_OPEN, openForWriting);
#endif /* SOSP91 */

d1068 1
a1068 1
		SOSP_ADD_CONSIST_CHANGE_TRACE(srcClientID, consistPtr->hdrPtr->fileID, SOSP_CLOSE, cache);
d1077 6
a1256 4
#ifdef SOSP91
    SOSP_ADD_CONSIST_CHANGE_TRACE(clientID, consistPtr->hdrPtr->fileID, SOSP_CLOSE, *wasCachedPtr);
#endif SOSP91

d1303 1
@


9.20
log
@sosp updates
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsconsistCache.c,v 9.19 90/11/25 16:13:35 jhh Exp Locker: mgbaker $ SPRITE (Berkeley)";
d1357 1
a1357 1
	    if (clientPtr->use.write - clientPtr->use.ref > 0) {
@


9.19
log
@changes to NumClients for sosp
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsconsistCache.c,v 9.18 90/11/24 18:29:06 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d51 3
d525 1
a525 1
		SOSP_ADD_CONSIST_ACTION_TRACE(clientID, clientPtr->clientID, consistPtr->hdrPtr.fileID, mode);
d541 1
a541 1
		SOSP_ADD_CONSIST_ACTION_TRACE(clientID, clientPtr->clientID, consistPtr->hdrPtr.fileID, FSCONSIST_INVALIDATE_BLOCKS);
d553 1
a553 1
		SOSP_ADD_CONSIST_ACTION_TRACE(clientID, clientPtr->clientID, consistPtr->hdrPtr.fileID, FSCONSIST_WRITE_BACK_BLOCKS | FSCONSIST_INVALIDATE_BLOCKS);
d565 1
a565 1
	SOSP_ADD_CONSIST_CHANGE_TRACE(clientID, consistPtr->hdrPtr.fileID, SOSP_OPEN, openForWriting);
d1072 1
a1072 1
		SOSP_ADD_CONSIST_CHANGE_TRACE(clientID, consistPtr->hdrPtr.fileID, SOSP_CLOSE, cache);
d1193 1
a1193 1
		SOSP_ADD_CONSIST_ACTION_TRACE(clientID, clientPtr->clientID, consistPtr->hdrPtr.fileID, XXX);
d1256 1
a1256 1
    SOSP_ADD_CONSIST_CHANGE_TRACE(clientID, consistPtr->hdrPtr.fileID, SOSP_CLOSE, *wasCachedPtr);
d1508 1
a1508 1
		SOSP_ADD_CONSIST_ACTION_TRACE(clientID, clientPtr->clientID, consistPtr->hdrPtr.fileID, FSCONSIST_DELETE_FILE);
d1709 1
a1709 1
	    SOSP_ADD_CONSIST_ACTION_TRACE(clientID, clientPtr->clientID, consistPtr->hdrPtr.fileID, flags);
@


9.18
log
@Added SOSP traces.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsconsistCache.c,v 9.17 90/10/08 12:18:56 mendel Exp Locker: mgbaker $ SPRITE (Berkeley)";
d1300 9
d1311 4
a1314 1
    register Fsconsist_Info *consistPtr;	/* Handle of file being closed */
d1320 6
d1332 2
a1333 2
	UNLOCK_MONITOR;
	return(1);
d1350 9
d1361 9
@


9.17
log
@Changed name from fsCacheConsist.c to fsconsistCache.c.

Fixed include files to use <> rather than "".
Added function prototypes.
Removed deadcode and lint.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs.mendel/RCS/fsCacheConsist.c,v 1.1 90/01/16 17:10:24 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d521 3
d537 3
d549 3
d561 4
d1068 3
d1187 5
d1252 4
d1468 3
d1668 4
@


9.16
log
@don't print "dropped: no handle" messages unless CONSIST_DEBUG defined.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsCacheConsist.c,v 9.15 90/08/26 16:16:36 shirriff Exp Locker: douglis $ SPRITE (Berkeley)";
d32 19
a50 18
#include	"sprite.h"
#include	"fs.h"
#include	"fsutil.h"
#include	"fsconsist.h"
#include	"fscache.h"
#include	"fsStat.h"
#include	"fslcl.h"
#include	"hash.h"
#include	"vm.h"
#include	"proc.h"
#include	"sys.h"
#include	"rpc.h"
#include	"recov.h"
#include	"timer.h"
#include	"dbg.h"
#include 	"fsio.h"
#include	"fsrmt.h"
#include	"fsdm.h"
d52 2
d126 18
a143 9
void		StartConsistency();
void 		UpdateList();
ReturnStatus	EndConsistency();
void	 	ClientCommand();
void		ProcessConsist();
void		ProcessConsistReply();
void		ConsistTimeoutIntr();
void		ConsistTimeout();
char *		ConsistType();
d195 1
d198 1
a198 1
    register Fsconsist_Info *consistPtr;	/* State to initialize */
a210 4
 *	This routine looks after consistency of a file mapped on multiple
 *	clients.  Since nobody's wanted to do that, I haven't got this
 *	routine implemented yet.  -- Ken Shirriff 8/90
 *
d220 1
d227 27
d683 1
a683 1
	Timer_DescheduleRoutine(&timeout);
d800 1
a800 1
    Fsutil_UseCounts		use;		/* Clients usage of the file */
d909 1
a909 1
    Fsutil_UseCounts	use;		/* Clients usage of the file */
a1116 1

d1128 1
d2232 2
d2286 3
@


9.15
log
@Removed dead code.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsCacheConsist.c,v 9.14 90/07/15 13:34:57 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d1853 1
d1860 1
@


9.14
log
@Changed locking to prevent deadlocks.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsCacheConsist.c,v 9.13 90/06/21 16:47:36 douglis Exp Locker: shirriff $ SPRITE (Berkeley)";
d198 4
d217 1
a217 27
#ifdef 0
    int					cacheable;	/* Dummy. */
    register Fsconsist_ClientInfo	*clientPtr;
    register Fsconsist_Info		*consistPtr = &handlePtr->consist;
    ReturnStatus			status;

    printf("Fsconsist_MappedConsistency: updating consistency (a)\n");
    LOCK_MONITOR;

    printf("Fsconsist_MappedConsistency: updating consistency (b)\n");
    StartConsistency(consistPtr, clientID, (int)(isMapped ? FS_MAP : 0),
	    &cacheable);

    printf("Fsconsist_MappedConsistency: updating consistency (c)\n");
    LIST_FORALL(&consistPtr->clientList, (List_Links *)clientPtr) {
	if (clientPtr->clientID == clientID) {
	    clientPtr->mapped = isMapped ? TRUE : FALSE;
	}
    }

    printf("Fsconsist_MappedConsistency: updating consistency (d)\n");
    status = EndConsistency(consistPtr);
    printf("Fsconsist_MappedConsistency: updating consistency (e)\n");

    UNLOCK_MONITOR;
    return(status);
#endif
@


9.13
log
@removed ifdef that prevented server from passing FSCONSIST_MIGRATION
flag, now that all machines should be running kernels that understand the
flag.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsCacheConsist.c,v 9.12 90/06/21 13:57:18 shirriff Exp Locker: douglis $ SPRITE (Berkeley)";
d805 7
d1395 2
a1398 2
    Fsutil_HandleUnlock(consistPtr->hdrPtr);

d1445 1
a1446 1
    UNLOCK_MONITOR;
d1574 1
a1575 1
    Fsutil_HandleUnlock(consistPtr->hdrPtr);
d1589 1
a1590 1
        UNLOCK_MONITOR;
d1629 1
a1630 1
    UNLOCK_MONITOR;
@


9.12
log
@Changed handle locking to avoid some deadlocks.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsCacheConsist.c,v 9.11 90/05/14 13:08:43 douglis Exp Locker: shirriff $ SPRITE (Berkeley)";
a369 5
#ifdef 0
	/*
	 * We can't give this flag to other machines until they can handle
	 * it.
	 */
a370 3
#else
	writebackFlags = 0;
#endif
@


9.11
log
@changes for migration statistics
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fd.fsconsist/RCS/fsCacheConsist.c,v 9.10 90/02/20 15:03:59 brent Exp Locker: douglis $ SPRITE (Berkeley)";
a1102 1
    LOCK_MONITOR;
d1116 1
a1166 1
    Fsutil_HandleLock(handlePtr);
d1169 1
@


9.10
log
@Added IOClientKill call after a consistency call-back times-out.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsCacheConsist.c,v 9.9 89/11/08 11:28:10 shirriff Exp $ SPRITE (Berkeley)";
d336 1
d339 7
d368 15
d407 2
d428 3
d433 3
d457 1
a457 1
	    } else if (clientPtr->use.ref > 0) {
d470 1
a470 1
	statPtr->clients++;
d475 1
a475 1
	    statPtr->notCaching++;
d482 8
d497 1
d501 7
d509 5
a513 2
		ClientCommand(consistPtr, clientPtr,
					FSCONSIST_WRITE_BACK_BLOCKS);
d515 4
d534 2
a535 1
		    FSCONSIST_WRITE_BACK_BLOCKS | FSCONSIST_INVALIDATE_BLOCKS);
d538 4
d546 7
d555 3
d559 2
d1007 4
a1010 1
					 * getting stream for first time. */
d1025 1
d1029 3
a1031 3
	 * the regular cache consistency algorithm.  Note that this call doesn't
	 * disturb the last writer state so any dirty blocks on the old client
	 * will get handled properly.
d1046 2
a1047 1
    StartConsistency(consistPtr, dstClientID, useFlags, cacheablePtr);
@


9.9
log
@Ifdef'd out Fsconsist_MappedConsistency.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsCacheConsist.c,v 9.8 89/11/02 16:37:02 brent Exp Locker: shirriff $ SPRITE (Berkeley)";
d663 1
d675 5
@


9.8
log
@Fixed previous tweak to ClientCommand so the client is
nuked upon a FS_STALE_HANDLE return.  This forces it
to reopen the file and verify its version number later.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsCacheConsist.c,v 9.6 89/11/02 13:55:14 brent Exp Locker: shirriff $ SPRITE (Berkeley)";
d213 1
d239 1
@


9.7
log
@Made changes to Fsconsist_MappedConsist.
@
text
@d1714 1
a1714 1
	if (status == RPC_TIMEOUT) {
@


9.6
log
@Tweaked ClientCommand so it doesn't nuke the client if
it gets a RPC_SERVICE_DISABLED return code.  This prevents
the server from yanking the world out from under a booting client.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsCacheConsist.c,v 9.5 89/11/01 10:50:58 shirriff Exp $ SPRITE (Berkeley)";
d218 1
d221 3
a223 1
    StartConsistency(consistPtr, clientID, isMapped ? FS_MAP : 0, &cacheable);
d225 1
d232 1
d234 1
d261 1
a261 1
 *	THIS UNLOCKS THE HANDLE.
@


9.5
log
@Added Fs_MappedConsistency.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsCacheConsist.c,v 9.4 89/10/30 18:06:31 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d1701 1
a1701 2
	 * Couldn't post call-back to the client.  Nuke it from the
	 * list of clients using the file.
a1704 1
	Fsconsist_Kill(consistPtr, clientPtr->clientID, &ref, &write, &exec);
d1708 17
a1724 2
	printf("\tClient state killed: %d refs %d write %d exec\n",
		    ref, write, exec);
@


9.4
log
@Added clientPtr->mapped, for later mapped page stuff.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsCacheConsist.c,v 9.3 89/10/27 08:23:23 brent Exp Locker: shirriff $ SPRITE (Berkeley)";
d193 44
d254 1
a254 1
 *	lis of clients of the file.
d359 2
@


9.3
log
@Updated consistency statistics.
Tidied up use of the Client Lists.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsCacheConsist.c,v 9.2 89/10/23 09:57:08 brent Exp Locker: brent $ SPRITE (Berkeley)";
d195 1
a195 1
 *	Take action to ensure that the caches are consistency for this
d318 4
d848 1
a848 1
 *	the stream to this handle is not shared accross network this
d854 1
a854 1
 *	and we must be careful to not add too many refererences to the
d1002 1
a1002 1
	 * which releases the consistency lock and allows list deletetions.
d1443 1
a1443 1
     * Make sure that noone else is in the middle of performing cache
@


9.2
log
@Fixed lots of type alignment due to name changes.
Main fix: eliminated deadlock caused by holding
the handle locked while handling a ConsistencyReply.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsCacheConsist.c,v 9.1 89/09/25 16:51:11 brent Exp $ SPRITE (Berkeley)";
d37 1
a37 1
#include	"fsNameOps.h"
a120 6
 * Cache conistency statistics.
 */

Fsconsist_Stats fsconsist_Stats;

/*
d283 1
a283 1
    register Fsconsist_Stats *statPtr = &fsconsist_Stats;
d310 1
d314 1
d346 1
a346 1
    statPtr->numConsistChecks++;
d366 5
d381 1
a381 1
	statPtr->numClients++;
d392 1
a392 1
		statPtr->readCaching++;
d396 1
a396 1
		 * Its dirty cache is ok.
d427 5
d705 1
a705 2
	clientPtr = mnew(Fsconsist_ClientInfo);
	clientPtr->clientID = clientID;
a707 4
	clientPtr->openTimeStamp = 0;
	List_InitElement((List_Links *) clientPtr);
	List_Insert((List_Links *) clientPtr,
		LIST_ATFRONT(&consistPtr->clientList));
d793 1
a793 2
		List_Remove((List_Links *)clientPtr);
		free((Address)clientPtr);
a802 10
	status = FAILURE;
	LIST_FORALL(&consistPtr->clientList, (List_Links *)clientPtr) {
	    if (clientPtr->clientID == clientID) {
		status = SUCCESS;
		break;
	    }
	}
	if (status != SUCCESS) {
	    panic( "Fsconsist_ReopenConsistency, no client entry\n");
	}
d807 1
a807 1
	 * FIX ME.  The file version number should be used instead, I think.
d810 1
a810 3
	*openTimeStampPtr =
	    consistPtr->openTimeStamp =
		clientPtr->openTimeStamp = openTimeStamp;
d814 1
a814 1
	*cacheablePtr = clientPtr->cached = cacheable;
d819 11
d1142 5
a1146 1

d1148 3
a1150 9
	    clientPtr->clientID != consistPtr->lastWriter) {
	    if (clientPtr->locked) {
		printf("Fsconsist_NumClients hit locked client %d for <%d,%d>\n",
		    clientPtr->clientID, consistPtr->hdrPtr->fileID.major,
		    consistPtr->hdrPtr->fileID.minor);
	    } else {
		List_Remove((List_Links *) clientPtr);
		free((Address) clientPtr);
	    }
d1209 2
a1210 7
		if (clientPtr->locked) {
		    printf("Fsconsist_DeleteLastWriter: locked client %d of <%d,%d>\n",
			clientPtr->clientID, consistPtr->hdrPtr->fileID.major,
			consistPtr->hdrPtr->fileID.minor);
		} else {
		    List_Remove((List_Links  *) clientPtr);
		    free((Address) clientPtr);
d1273 2
a1274 1
	    panic("Fsconsist_ClientRemoveCallback: Client using removed file\n");
d1299 1
a1299 2
		List_Remove((List_Links *) clientPtr);
		free((Address) clientPtr);
d1573 1
a1573 2
	    List_Remove((List_Links *) clientPtr);
	    free((Address) clientPtr);
d2066 1
a2066 2
		    List_Remove((List_Links *) clientPtr);
		    free((Address) clientPtr);
@


9.1
log
@Changed things so a client will honor a consistency request
if the version numbers match and it isn't a write-back.
This takes care of requests for attributes during heavy
traffic, in which the client may not have the right
openTimeStamp for some time.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsCacheConsist.c,v 8.14 89/08/29 15:41:33 brent Exp $ SPRITE (Berkeley)";
d160 1
a160 1
    Fs_HandleHeader *hdrPtr;		/* Back pointer to handle */
d421 1
a421 1
			    FSCONSIST_WRITE_BACK_BLOCKS | FSCONSIST_INVALIDATE_BLOCKS);
d453 2
a454 3
UpdateList(consistPtr, clientID, useFlags, cacheable,
	   openTimeStampPtr)
    register Fsconsist_Info *consistPtr;	/* Consistency state for the file. */
d462 1
a462 1
    register	Fsconsist_ClientInfo	*clientPtr;	/* State for other clients */
d467 2
a468 2
    clientPtr = Fsconsist_IOClientOpen(&consistPtr->clientList, clientID, useFlags,
				cacheable);
d684 1
a684 2
	    printf(
	"FsReopenHandle: file \"%s\" <%d,%d>: client %d has dirty blocks, but client %d is using\n",
d690 1
a690 1
#ifdef notdef
d738 3
a740 3
 *	except that the client list has already been updated by Fsconsist_ReopenClient.
 *	This can result in a call-back to the re-opening client to get
 *	its version of the file.
d755 2
a756 1
Fsconsist_ReopenConsistency(handlePtr, clientID, use, swap, cacheablePtr, openTimeStampPtr)
d759 1
a759 1
    Fsutil_UseCounts		use;		/* Clients usage of the file */
d817 1
d865 2
a866 2
Fsconsist_MigrateConsistency(handlePtr, srcClientID, dstClientID, useFlags, closeSrc,
	cacheablePtr, openTimeStampPtr)
d875 1
a875 1
					 * This is set by Fsio_StreamMigClient */
d895 3
a897 4
	if (!Fsconsist_IOClientClose(&consistPtr->clientList, srcClientID, useFlags,
		&cache)) {
	    printf(
	"Fsconsist_MigrateConsistency, srcClient %d unknown for %s %s <%d,%d>\n",
d1084 1
a1084 2
	    printf(
	    "Fsconsist_Close, \"%s\" <%d,%d>: client %d not last writer %d, %s\n",
d1193 1
a1193 1
	 * Not safe to mess with list during consistency.  We are called
d1233 2
a1234 2
 *      Called when a file is deleted.  Send an rpc to everyone who has
 *      dirty blocks cached telling them to delete them from their cache.
d1237 4
a1240 1
 *	incremented to catch old blocks left in caches.
d1284 1
a1284 2
		printf(
    "Fsconsist_ClientRemoveCallback: \"%s\" <%d,%d> client %d not last writer (%d).\n",
d1301 1
a1301 1
	 * here because it may already be removed.
d1534 7
a1540 1
 *      Client added to list of outstanding cache consistency messages.
d1549 1
a1549 1
    Fsconsist_ClientInfo	*clientPtr;	/* State of other client's cache */
d1591 2
a1592 2
	    panic( "ClientCommand, bad stream type <%d>\n",
		consistRpc.fileID.type);
d1669 2
a1670 1
	printf("\tClient had %d refs %d write %d exec\n", ref, write, exec);
d1685 2
a1686 1
 *	server so that it will re-try.
d1710 1
a1710 1
    register ConsistMsg	*consistArgPtr;
d1717 4
a1720 2
	printf("Fsconsist_RpcConsist, bad stream type <%d>\n",
		    consistArgPtr->fileID.type);
d1727 2
a1728 1
    rmtHandlePtr = Fsutil_HandleFetchType(Fsrmt_FileIOHandle, &consistArgPtr->fileID);
d1808 4
a1811 1
 *	Process a client's cache consistency request.
d1817 1
a1817 1
 *	The cache may be flushed or invalidated.
d1836 2
a1837 1
    handlePtr = Fsutil_HandleFetchType(Fsrmt_FileIOHandle, &consistPtr->args.fileID);
d1839 5
a1843 5
	printf("<%d, %d, %d, %d>:", consistPtr->args.fileID.type,
		     consistPtr->args.fileID.serverID,
		     consistPtr->args.fileID.major,
		     consistPtr->args.fileID.minor);
	printf( "ProcessConsist: lost the handle\n");
d1906 3
a1908 2
 *	Service stub for RPC_FS_CONSIST_REPLY.  This indicates that
 *	the client has handled the consistency command.
d1911 2
a1912 2
 *	SUCCESS.
 *
d1914 1
a1914 1
 *	None.
d1937 4
a1940 2
	panic( "Fsconsist_RpcConsistReply bad stream type <%d>\n",
	    replyPtr->fileID.type);
d1948 12
d1961 1
a1961 1
    Fsutil_HandleRelease(handlePtr, TRUE);
d1974 4
d2000 1
a2000 1
    register	Fsconsist_ClientInfo 		*clientPtr;
d2022 5
a2026 2
	 * Old message from the client, probably queued in the network
	 * interface or from a gateway.
a2027 2
	printf( "ProcessConsistReply: Client %d not found\n",
			clientID);
d2043 1
a2043 2
	printf(
	    "ProcessConsist: %s request failed <%x> file \"%s\" <%d,%d>\n",
a2067 1

d2070 2
a2071 2
		    Fscache_UpdateAttrFromClient(clientID, &handlePtr->cacheInfo,
			&replyPtr->cachedAttr);
a2072 1
		
@


9.0
log
@Changing version numbers.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsCacheConsist.c,v 8.14 89/08/29 15:41:33 brent Exp Locker: douglis $ SPRITE (Berkeley)";
d1737 11
a1747 1
	if (Fsprefix_OpenInProgress(&consistArgPtr->fileID) == 0) {
d1839 2
a1840 2
    reply.status = Fscache_Consist(&handlePtr->cacheInfo, consistPtr->args.flags,
			    &reply.cachedAttr);
@


8.14
log
@Tweaked server timeouts on client callbacks.
Shorted timeout to 1 minute.
Changed clients to retry their CONSIST_REPLY rpc
if they get a timeout trying to reach the server.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fsconsist/RCS/fsCacheConsist.c,v 8.13 89/08/21 15:24:33 mendel Exp Locker: brent $ SPRITE (Berkeley)";
@


8.13
log
@Break up fs into many modules.    
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsCacheConsist.c,v 8.11 89/08/10 17:11:41 brent Exp $ SPRITE (Berkeley)";
d79 1
a79 1
int fsconsist_TimeoutMinutes = 5;
d1296 1
a1296 3
		while (!List_IsEmpty(&consistPtr->msgList)) {
		    (void) Sync_Wait(&consistPtr->repliesIn, FALSE);
		}
d1862 9
a1870 4
    status = Rpc_Call(consistPtr->serverID, RPC_FS_CONSIST_REPLY, &storage);
    if (status != SUCCESS) {
	printf("Got error (%x) from consist reply on <%d,%d>\n", status,
	    reply.fileID.major, reply.fileID.minor);
@


8.12
log
@Updated a warning print state about openTimeStamps
to also report the client and server version numbers.
@
text
@d34 5
a38 8
#include	"fsInt.h"
#include	"fsClient.h"
#include	"fsConsist.h"
#include	"fsBlockCache.h"
#include	"fsCacheOps.h"
#include	"fsOpTable.h"
#include	"fsLocalDomain.h"
#include	"fsDebug.h"
d47 3
d53 2
a54 2
Boolean	fsCacheDebug = FALSE;
Boolean	fsClientCaching = TRUE;
d60 1
a60 1
 * Flags for the FsConsistInfo struct that's defined in fsInt.h
d79 1
a79 1
int fsConsistTimeoutMinutes = 5;
d99 1
a99 1
    FsCachedAttributes	cachedAttr;
d124 1
a124 1
FsCacheConsistStats fsConsistStats;
d143 1
a143 1
 * FsConsistInit --
d158 3
a160 3
FsConsistInit(consistPtr, hdrPtr)
    register FsConsistInfo *consistPtr;	/* State to initialize */
    FsHandleHeader *hdrPtr;		/* Back pointer to handle */
d176 1
a176 1
 * FsConsistSyncLockCleanup --
d190 2
a191 2
FsConsistSyncLockCleanup(consistPtr)
    register FsConsistInfo *consistPtr;	/* State to initialize */
d199 1
a199 1
 * FsFileConsistency --
d223 1
a223 1
FsFileConsistency(handlePtr, clientID, useFlags, cacheablePtr,
d225 1
a225 1
    FsLocalFileIOHandle *handlePtr;	/* File to check consistency of. */
d233 1
a233 1
    register FsConsistInfo *consistPtr = &handlePtr->consist;
d282 1
a282 1
    FsConsistInfo	*consistPtr;	/* File's consistency state. */
d287 3
a289 3
    register FsClientInfo *clientPtr;
    register FsClientInfo *nextClientPtr;
    register FsCacheConsistStats *statPtr = &fsConsistStats;
d313 1
a313 1
    cacheable = fsClientCaching;
d316 1
a316 1
    } else if (((FsLocalFileIOHandle *)consistPtr->hdrPtr)->descPtr->fileType
d337 1
a337 1
		((FsLocalFileIOHandle *)consistPtr->hdrPtr)->cacheInfo.version,
d351 1
a351 1
    nextClientPtr = (FsClientInfo *)List_First(&consistPtr->clientList);
d355 1
a355 1
	nextClientPtr = (FsClientInfo *)List_Next((List_Links *)clientPtr);
d368 1
a368 1
	     * own cache via the FsCacheUpdate procedure.
d404 1
a404 1
					FS_WRITE_BACK_BLOCKS);
d413 1
a413 1
					FS_INVALIDATE_BLOCKS);
d421 1
a421 1
			    FS_WRITE_BACK_BLOCKS | FS_INVALIDATE_BLOCKS);
d455 1
a455 1
    register FsConsistInfo *consistPtr;	/* Consistency state for the file. */
d463 1
a463 1
    register	FsClientInfo	*clientPtr;	/* State for other clients */
d468 1
a468 1
    clientPtr = FsIOClientOpen(&consistPtr->clientList, clientID, useFlags,
d521 1
a521 1
    FsConsistInfo	*consistPtr;
d533 1
a533 1
    timeout.interval = timer_IntOneMinute * fsConsistTimeoutMinutes;
d581 1
a581 1

d585 1
a585 1
    ClientData data;	/* A pointer to a FsConsistInfo */
d587 1
a587 1
    FsConsistInfo *consistPtr = (FsConsistInfo *)data;
d595 1
a595 1
    ClientData		data;	/* A pointer to a FsConsistInfo */
d598 1
a598 1
    FsConsistInfo *consistPtr = (FsConsistInfo *)data;
d606 1
a606 1
		fsConsistTimeoutMinutes,
d610 1
a610 1
		FsHandleName(consistPtr->hdrPtr));
d627 1
a627 1
 * FsReopenClient --
d634 1
a634 1
 *	Consistency call-backs are made	later by FsReopenConsistency.
d643 1
a643 1
 *	the re-opening client during FsReopenConsistency.  This is the
d650 2
a651 2
FsReopenClient(handlePtr, clientID, use, haveDirtyBlocks)
    FsLocalFileIOHandle	*handlePtr;	/* Should be LOCKED. */
d653 1
a653 1
    FsUseCounts		use;		/* Clients usage of the file */
d658 2
a659 2
    register FsConsistInfo	*consistPtr = &handlePtr->consist;
    register FsClientInfo	*clientPtr;
d687 1
a687 1
		FsHandleName(handlePtr),
d694 1
a694 1
	printf("FsReopenClient %d, use %d write %d, %s, last writer %d\n",
d701 1
a701 1
	clientPtr = mnew(FsClientInfo);
d721 1
a721 1
		FsHandleName(handlePtr),
d736 1
a736 1
 * FsReopenConsistency --
d740 1
a740 1
 *	except that the client list has already been updated by FsReopenClient.
d757 2
a758 2
FsReopenConsistency(handlePtr, clientID, use, swap, cacheablePtr, openTimeStampPtr)
    FsLocalFileIOHandle	*handlePtr;	/* Should be UNLOCKED. */
d760 1
a760 1
    FsUseCounts		use;		/* Clients usage of the file */
d771 2
a772 2
    register FsConsistInfo	*consistPtr = &handlePtr->consist;
    register FsClientInfo	*clientPtr;
d812 1
a812 1
	    panic( "FsReopenConsistency, no client entry\n");
d842 1
a842 1
 * FsMigrateConsistency --
d865 1
a865 1
FsMigrateConsistency(handlePtr, srcClientID, dstClientID, useFlags, closeSrc,
d867 1
a867 1
    FsLocalFileIOHandle	*handlePtr;	/* Needs to be UNLOCKED  */
d875 1
a875 1
					 * This is set by FsStreamMigClient */
d881 1
a881 1
    register FsConsistInfo *consistPtr = &handlePtr->consist;
d895 1
a895 1
	if (!FsIOClientClose(&consistPtr->clientList, srcClientID, useFlags,
d898 1
a898 1
	"FsMigrateConsistency, srcClient %d unknown for %s %s <%d,%d>\n",
d900 2
a901 2
		FsFileTypeToString(handlePtr->hdr.fileID.type),
		FsHandleName(handlePtr),
d930 1
a930 1
 * FsGetClientAttrs --
d952 2
a953 2
FsGetClientAttrs(handlePtr, clientID, isExecedPtr)
    register FsLocalFileIOHandle *handlePtr;
d961 3
a963 3
    register FsConsistInfo	*consistPtr = &handlePtr->consist;
    register FsClientInfo	*clientPtr;
    register FsClientInfo	*nextClientPtr;
d978 1
a978 1
    FsHandleUnlock(handlePtr);
d993 1
a993 1
    nextClientPtr = (FsClientInfo *)List_First(&consistPtr->clientList);
d997 1
a997 1
	nextClientPtr = (FsClientInfo *)List_Next((List_Links *)clientPtr);
d1019 1
a1019 1
		ClientCommand(consistPtr, clientPtr, FS_WRITE_BACK_ATTRS);
d1029 1
a1029 1
    FsHandleLock(handlePtr);
d1037 1
a1037 1
 * FsConsistClose --
d1039 1
a1039 1
 *	A thin layer on top of FsIOClientClose that also cleans up
d1057 2
a1058 2
FsConsistClose(consistPtr, clientID, flags, wasCachedPtr)
    register FsConsistInfo *consistPtr;	/* Handle of file being closed */
d1073 1
a1073 1
    if (!FsIOClientClose(&consistPtr->clientList, clientID, flags,
d1086 2
a1087 2
	    "FsConsistClose, \"%s\" <%d,%d>: client %d not last writer %d, %s\n",
		    FsHandleName(consistPtr->hdrPtr),
d1108 1
a1108 1
 * FsConsistClients --
d1125 2
a1126 2
FsConsistClients(consistPtr)
    register FsConsistInfo *consistPtr;	/* Handle of file being closed */
d1129 2
a1130 2
    register FsClientInfo *clientPtr;
    register FsClientInfo *nextClientPtr;
d1141 1
a1141 1
    nextClientPtr = (FsClientInfo *)List_First(&consistPtr->clientList);
d1144 1
a1144 1
	nextClientPtr = (FsClientInfo *)List_Next((List_Links *)clientPtr);
d1149 1
a1149 1
		printf("FsConsistClients hit locked client %d for <%d,%d>\n",
d1168 1
a1168 1
 * FsDeleteLastWriter --
d1185 2
a1186 2
FsDeleteLastWriter(consistPtr, clientID)
    FsConsistInfo *consistPtr;
d1189 1
a1189 1
    register	FsClientInfo	*clientPtr;
d1196 1
a1196 1
	 * from Fs_RpcWrite on the client's last block, but we will
d1209 1
a1209 1
		    printf("FsDeleteLastWriter <%d,%d> host %d\n",
d1215 1
a1215 1
		    printf("FsDeleteLastWriter: locked client %d of <%d,%d>\n",
d1233 1
a1233 1
 * FsClientRemoveCallback --
d1252 2
a1253 2
FsClientRemoveCallback(consistPtr, clientID)
    FsConsistInfo *consistPtr;	/* File to check */
d1260 1
a1260 1
    register	FsClientInfo	*clientPtr;
d1265 1
a1265 1
    FsHandleUnlock(consistPtr->hdrPtr);
d1276 1
a1276 1
	clientPtr = (FsClientInfo *)
d1280 1
a1280 1
	    panic("FsClientRemoveCallback: Client using removed file\n");
d1284 2
a1285 2
    "FsClientRemoveCallback: \"%s\" <%d,%d> client %d not last writer (%d).\n",
			FsHandleName(consistPtr->hdrPtr),
d1295 1
a1295 1
		ClientCommand(consistPtr, clientPtr, FS_DELETE_FILE);
d1316 1
a1316 1
    FsHandleLock(consistPtr->hdrPtr);
d1323 1
a1323 1
 * FsConsistKill --
d1343 2
a1344 2
FsConsistKill(consistPtr, clientID, refPtr, writePtr, execPtr)
    FsConsistInfo *consistPtr;	/* Consistency state from which to remove
d1355 1
a1355 1
    FsIOClientKill(&consistPtr->clientList, clientID, refPtr, writePtr,
d1380 1
a1380 1
 * FsGetAllDirtyBlocks --
d1395 1
a1395 1
FsGetAllDirtyBlocks(domain, invalidate)
d1401 1
a1401 1
    register	FsHandleHeader		*hdrPtr;
d1404 4
a1407 4
    for (hdrPtr = FsGetNextHandle(&hashSearch);
	 hdrPtr != (FsHandleHeader *) NIL;
         hdrPtr = FsGetNextHandle(&hashSearch)) {
	if (hdrPtr->fileID.type == FS_LCL_FILE_STREAM &&
d1409 3
a1411 3
	    register FsLocalFileIOHandle *handlePtr =
		    (FsLocalFileIOHandle *) hdrPtr;
	    FsFetchDirtyBlocks(&handlePtr->consist, invalidate);
d1413 1
a1413 1
	FsHandleUnlock(hdrPtr);
d1420 1
a1420 1
 * FsFetchDirtyBlocks --
d1437 2
a1438 2
FsFetchDirtyBlocks(consistPtr, invalidate)
    FsConsistInfo *consistPtr;	/* Consistency state for file. */
d1442 2
a1443 2
    register	FsClientInfo	*clientPtr;
    register	FsClientInfo	*nextClientPtr;
d1446 1
a1446 1
    FsHandleUnlock(consistPtr->hdrPtr);
d1460 1
a1460 1
	FsHandleLock(consistPtr->hdrPtr);
d1471 1
a1471 1
    nextClientPtr = (FsClientInfo *)List_First(&consistPtr->clientList);
d1475 1
a1475 1
	nextClientPtr = (FsClientInfo *)List_Next((List_Links *)clientPtr);
d1480 1
a1480 1
	    FsHandleLock(consistPtr->hdrPtr);
d1483 1
a1483 1
	    panic("FsFetchDirtyBlocks: Non last writer in list.\n");
d1491 1
a1491 1
	    register int flags = FS_WRITE_BACK_BLOCKS;
d1493 1
a1493 1
		flags |= FS_INVALIDATE_BLOCKS;
d1500 1
a1500 1
    FsHandleLock(consistPtr->hdrPtr);
d1544 2
a1545 2
    register FsConsistInfo *consistPtr;	/* Consistency state of file */
    FsClientInfo	*clientPtr;	/* State of other client's cache */
d1560 1
a1560 1
	if (flags & FS_INVALIDATE_BLOCKS) {
d1567 1
a1567 1
	if (flags & FS_WRITE_BACK_BLOCKS) {
d1575 1
a1575 1
	    FS_CACHE_DEBUG_PRINT1("ClientCommand: Removing %d ",
d1586 1
a1586 1
    if (consistRpc.fileID.type != FS_LCL_FILE_STREAM) {
d1590 1
a1590 1
	consistRpc.fileID.type = FS_RMT_FILE_STREAM;
d1599 1
a1599 1
	((FsLocalFileIOHandle *)consistPtr->hdrPtr)->cacheInfo.version;
d1623 1
a1623 1
     * an unrelated close can complete its call to FsConsistClose.
d1645 1
a1645 1
			    FsHandleName(consistPtr->hdrPtr),
d1647 1
a1647 1
		consistRpc.flags |= FS_DEBUG_CONSIST;
d1650 1
a1650 1
		consistRpc.flags &= ~FS_DEBUG_CONSIST;
d1661 1
a1661 1
	FsConsistKill(consistPtr, clientPtr->clientID, &ref, &write, &exec);
d1663 1
a1663 1
	    ConsistType(flags), clientID, FsHandleName(consistPtr->hdrPtr),
d1673 1
a1673 1
 * Fs_RpcConsist --
d1692 1
a1692 1
Fs_RpcConsist(srvToken, clientID, command, storagePtr)
d1706 1
a1706 1
    register FsRmtFileIOHandle	*rmtHandlePtr;
d1710 2
a1711 2
    if (consistArgPtr->fileID.type != FS_RMT_FILE_STREAM) {
	printf("Fs_RpcConsist, bad stream type <%d>\n",
d1719 3
a1721 3
    rmtHandlePtr = FsHandleFetchType(FsRmtFileIOHandle, &consistArgPtr->fileID);
    if (rmtHandlePtr == (FsRmtFileIOHandle *)NIL) {
	if (FsPrefixOpenInProgress(&consistArgPtr->fileID) == 0) {
d1723 1
a1723 1
	    printf("Fs_RpcConsist: <%d,%d> %s msg from %d dropped: %s\n",
d1739 1
a1739 1
	if (FsPrefixOpenInProgress(&consistArgPtr->fileID) == 0) {
d1741 1
a1741 1
	    printf("Fs_RpcConsist: <%d,%d> %s msg from %d timestamp %d not %d\n\t version %d and %d, returning stale handle\n",
d1759 2
a1760 2
    if (rmtHandlePtr != (FsRmtFileIOHandle *)NIL) {
	FsHandleRelease(rmtHandlePtr, TRUE);
d1771 2
a1772 2
    } else if (consistArgPtr->flags & FS_DEBUG_CONSIST) {
	printf("Fs_RpcConsist: <%d,%d> Lots of %s msgs dropped: %s\n",
d1805 1
a1805 1
    register FsRmtFileIOHandle 	*handlePtr;
d1814 2
a1815 2
    handlePtr = FsHandleFetchType(FsRmtFileIOHandle, &consistPtr->args.fileID);
    if (handlePtr == (FsRmtFileIOHandle *)NIL) {
d1823 1
a1823 1
    FsHandleUnlock(handlePtr);
d1825 1
a1825 1
    FS_CACHE_DEBUG_PRINT2("ProcessConsist: Got %s request for file %d\n", 
d1831 1
a1831 1
    reply.status = FsCacheConsist(&handlePtr->cacheInfo, consistPtr->args.flags,
d1838 1
a1838 1
	    FsHandleName(handlePtr),
d1844 1
a1844 1
    FS_CACHE_DEBUG_PRINT2("Returning: mod (%d), acc (%d),",
d1847 1
a1847 1
    FS_CACHE_DEBUG_PRINT2(" first (%d), last (%d)\n",
d1850 2
a1851 2
    reply.fileID.type = FS_LCL_FILE_STREAM;
    FsHandleRelease(handlePtr, FALSE);
d1876 1
a1876 1
 * Fs_RpcConsistReply --
d1891 1
a1891 1
Fs_RpcConsistReply(srvToken, clientID, command, storagePtr)
d1903 1
a1903 1
    FsLocalFileIOHandle	*handlePtr;
d1907 2
a1908 2
    if (replyPtr->fileID.type != FS_LCL_FILE_STREAM) {
	panic( "Fs_RpcConsistReply bad stream type <%d>\n",
d1911 3
a1913 3
    handlePtr = FsHandleFetchType(FsLocalFileIOHandle, &(replyPtr->fileID));
    if (handlePtr == (FsLocalFileIOHandle *) NIL) {
	printf("Fs_RpcConsistReply: no handle <%d,%d> for client %d\n",
d1918 1
a1918 1
    FsHandleRelease(handlePtr, TRUE);
d1947 1
a1947 1
    FsConsistInfo		*consistPtr;	/* File to process reply for*/
d1953 1
a1953 1
    register	FsClientInfo 		*clientPtr;
d1955 1
a1955 1
    FsLocalFileIOHandle			*handlePtr;
d1988 1
a1988 1
	    FsHandleName(consistPtr->hdrPtr),
d1998 1
a1998 1
		FsHandleName(consistPtr->hdrPtr),
d2003 1
a2003 1
	if ((msgPtr->flags & FS_WRITE_BACK_BLOCKS) &&
d2020 1
a2020 1
		handlePtr = (FsLocalFileIOHandle *)consistPtr->hdrPtr;
d2022 3
a2024 3
		if (msgPtr->flags & (FS_WRITE_BACK_BLOCKS |
				     FS_WRITE_BACK_ATTRS)) {
		    FsUpdateAttrFromClient(clientID, &handlePtr->cacheInfo,
d2032 1
a2032 1
		} else if (msgPtr->flags & FS_INVALIDATE_BLOCKS) {
d2065 2
a2066 2
    switch (flags & ~FS_DEBUG_CONSIST) {
	case FS_WRITE_BACK_BLOCKS:
d2069 1
a2069 1
	case FS_INVALIDATE_BLOCKS:
d2072 1
a2072 1
	case (FS_WRITE_BACK_BLOCKS|FS_INVALIDATE_BLOCKS):
d2075 1
a2075 1
	case FS_DELETE_FILE:
d2078 1
a2078 1
	case FS_WRITE_BACK_ATTRS:
@


8.11
log
@Added a timeout to consistency call-backs so an errent client
cannot hang a particular file indefinintly.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsCacheConsist.c,v 8.10 89/05/14 15:23:58 brent Exp Locker: brent $ SPRITE (Berkeley)";
d1741 1
a1741 1
	    printf("Fs_RpcConsist: <%d,%d> %s msg from %d timestamp %d not %d, %s\n",
d1747 1
a1747 1
		    "stale handle");
@


8.10
log
@Fixed bug in FsConsistKill where the wrong condition
variable was being notified.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsCacheConsist.c,v 8.9 89/02/13 08:31:50 brent Exp $ SPRITE (Berkeley)";
d48 1
d66 2
d71 1
d74 8
d135 2
d524 1
d526 12
d541 4
d561 64
d1081 4
d1092 1
a1092 1
	} else {
d1094 3
a1096 3
	    if (consistPtr->hdrPtr->fileID.minor == fsTraceConsistMinor) {
		printf("ConsistClose: erasing %d lastwriter\n", clientID);
	    }
d1098 1
a1098 2
	    consistPtr->lastWriter = -1;
	}
d1423 2
@


8.9
log
@Changed "Client X with dirty blocks not last writer Y" from a fatal
panic to a better warning message.  This case has occurred after
the server reboots, which may just mean that a write-shared file
is experiencing a open/re-open race.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsCacheConsist.c,v 8.8 89/02/09 09:22:05 brent Exp $ SPRITE (Berkeley)";
d1271 1
a1271 1
	    Sync_Broadcast(&consistPtr->consistDone);
@


8.8
log
@Added FsConsistSyncLockCleanup
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsCacheConsist.c,v 8.7 89/02/06 18:29:02 brent Exp $ SPRITE (Berkeley)";
d591 1
a591 1
	"FsReopenHandle: file \"%s\" <%d,%d>: client %d reading stale data\n",
d594 1
a594 1
		clientPtr->clientID);
d625 4
a628 3
	    panic(
		    "Client %d with dirty blocks not last writer %d\n",
		    clientID, consistPtr->lastWriter);
@


8.7
log
@Took out initialization of obsolete list
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsCacheConsist.c,v 8.6 89/02/01 13:56:42 brent Exp Locker: brent $ SPRITE (Berkeley)";
d148 1
a148 1
    SYNC_LOCK_INIT_DYNAMIC(&consistPtr->lock);
d162 23
d1140 1
a1140 2
 *	incremented (by 1 when opened for writing, by 2 when creating)
 *	to catch old blocks left in caches.
d1181 1
a1181 2
	    panic(
		"FsClientRemoveCallback: Client using removed file\n");
d1542 1
a1542 2
		printf(
		    "Client %d dropped 30 %s requests for \"%s\" <%d,%d>\n",
d1610 1
a1610 1
	panic( "Fs_RpcConsist, bad stream type <%d>\n",
d1612 1
d1622 1
a1622 2
	    printf(
		    "Fs_RpcConsist: <%d,%d> %s msg from %d dropped: %s\n",
a1635 9
#ifdef notdef
	    printf(
		    "Fs_RpcConsist: <%d,%d> %s msg from %d dropped: %s\n",
		    consistArgPtr->fileID.major,
		    consistArgPtr->fileID.minor,
		    ConsistType(consistArgPtr->flags),
		    consistArgPtr->fileID.serverID,
		    "open in progress");
#endif
d1640 1
a1640 2
	    printf(
		"Fs_RpcConsist: <%d,%d> %s msg from %d timestamp %d not %d, %s\n",
d1649 1
a1652 10
#ifdef notdef
	    printf(
		"Fs_RpcConsist: <%d,%d> %s msg from %d timestamp %d not %d, %s\n",
		    consistArgPtr->fileID.major,
		    consistArgPtr->fileID.minor,
		    ConsistType(consistArgPtr->flags),
		    consistArgPtr->fileID.serverID,
		    consistArgPtr->openTimeStamp, rmtHandlePtr->openTimeStamp,
		    "open in progress");
#endif
d1671 1
a1671 2
	printf(
	    "Fs_RpcConsist: <%d,%d> Lots of %s msgs dropped: %s\n",
a1712 5
    if (consistPtr->args.fileID.type != FS_RMT_FILE_STREAM) {
	panic( "ProcessConsist, unexpected file type %d\n",
	    consistPtr->args.fileID.type);
	return;
    }
@


8.6
log
@Removed lint that might cause bogus RPC reply
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsCacheConsist.c,v 8.5 89/01/24 12:27:39 brent Exp $ SPRITE (Berkeley)";
d148 1
d153 2
a154 1
    SYNC_LOCK_INIT_DYNAMIC(&consistPtr->lock);
a156 3
    List_Init(&consistPtr->clientList);
    List_Init(&consistPtr->msgList);
    List_Init(&consistPtr->migList);
@


8.5
log
@Fixed handling of old consistency replies.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsCacheConsist.c,v 8.4 89/01/06 11:20:29 jhh Exp $ SPRITE (Berkeley)";
d1826 1
@


8.4
log
@new Sync_Lock definition
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsCacheConsist.c,v 8.3 88/12/21 10:17:57 brent Exp $ SPRITE (Berkeley)";
d1771 2
a1772 1
	printf( "Got error (%x) from consist reply\n", status);
d1818 3
a1820 1
	panic( "Fs_RpcConsistReply: no handle\n");
@


8.3
log
@Double migration bug fix
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsCacheConsist.c,v 8.2 88/11/28 12:51:58 brent Exp $ SPRITE (Berkeley)";
d152 1
a152 2
    consistPtr->lock.inUse = 0;
    consistPtr->lock.waiting = 0;
@


8.2
log
@Added more protection against munging the client list during
consistency.  Occasionally mint would go infinite because
a list would change out from underneath it.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsCacheConsist.c,v 8.1 88/11/26 11:41:25 brent Exp $ SPRITE (Berkeley)";
d748 1
a748 1
FsMigrateConsistency(handlePtr, srcClientID, dstClientID, useFlags,
d757 2
d771 1
a771 1
    if ((useFlags & FS_RMT_SHARED) == 0) {
a785 9
	}
    } else if (useFlags & FS_LAST_WRITER) {
	Boolean found;
	
	found = FsIOClientRemoveWriter(&consistPtr->clientList, srcClientID);
	if (!found) {
	    printf(
		"FsMigrateConsistency, IO Client %d not found\n",
		srcClientID);
@


8.1
log
@1 - Changed StartConsistency() to not call-back to the opening/reopening/
	migrating client so as to prevent deadlock.
2 - Changed handling of dropped consistency requests.  FsConsistKill()
	is used to wipe the client off the client list if it drops
	a consistency request.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsCacheConsist.c,v 7.0 88/11/11 15:35:16 brent Exp $ SPRITE (Berkeley)";
d312 2
a313 2
     * client list entries can get removed as side effects of call-backs
     * so we can't use a simple LIST_FOR_ALL here.
d319 1
d321 8
d373 1
a373 1
	    if (clientPtr->use.write == 0) {
d380 1
a380 1
	    } else {
d886 1
d888 7
a894 1

d1021 7
d1035 8
a1042 2
	    List_Remove((List_Links *) clientPtr);
	    free((Address) clientPtr);
d1080 10
d1101 8
a1108 2
		List_Remove((List_Links  *) clientPtr);
		free((Address) clientPtr);
d1145 2
a1146 1
				 * return FS_FILE_REMOVED. */
d1361 1
d1363 3
a1365 1

d1370 1
a1370 2
	    panic(
		    "FsFetchDirtyBlocks: Non last writer in list.\n");
@


8.0
log
@Changing version numbers.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsCacheConsist.c,v 7.0 88/11/11 15:35:16 brent Exp Locker: douglis $ SPRITE (Berkeley)";
d320 8
a1493 12
    LOCK_MONITOR;
#ifdef CONSIST_DEBUG
    if (fsTraceConsistMinor == consistPtr->hdrPtr->fileID.minor) {
	printf(
	"ClientCommand, %s msg to client %d file \"%s\" <%d,%d> version %d status %x\n",
	    ConsistType(flags), clientPtr->clientID,
	    FsHandleName(consistPtr->hdrPtr),
	    consistRpc.fileID.major, consistRpc.fileID.minor,
	    consistRpc.version, status);
    }
#endif /* CONSIST_DEBUG */

d1496 2
a1497 4
	 * Couldn't post call-back to the client.  (Carefully) remove
	 * the message from the list of outstanding messages
	 * (because recovery actions by FsConsistKill may have already
	 * done this for us).
d1499 5
a1503 5
	register ConsistMsgInfo *existingMsgPtr;
	printf(
	"ClientCommand, %s msg to client %d file \"%s\" <%d,%d> failed %x\n",
	    ConsistType(flags), clientPtr->clientID,
	    FsHandleName(consistPtr->hdrPtr),
d1505 1
a1505 8

	LIST_FORALL(&(consistPtr->msgList), (List_Links *) existingMsgPtr) {
	    if (existingMsgPtr == msgPtr) {
		List_Remove((List_Links *) msgPtr);
		free((Address) msgPtr);
		break;
	    }
	}
d1507 1
@


7.0
log
@New version for conversion to new C library
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: /sprite/src/kernel/fs/RCS/fsCacheConsist.c,v 6.18 88/10/14 12:19:09 brent Exp Locker: brent $ SPRITE (Berkeley)";
@


6.18
log
@FsFileID FsUserID change
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.17 88/10/10 11:31:04 douglis Exp $ SPRITE (Berkeley)";
d299 1
a299 1
	Sys_Printf("File <%d,%d> version %d start consist w/ use 0x%x, %s\n",
d322 1
a322 1
	    Sys_Printf("Client %d, %s, use %d write %d\n",
d424 1
a424 1
	Sys_Printf("UpdateList: client %d %s, last writer %d\n",
d552 1
a552 1
	    Sys_Panic(SYS_WARNING,
d561 1
a561 1
	Sys_Printf("FsReopenClient %d, use %d write %d, %s, last writer %d\n",
d568 1
a568 1
	clientPtr = Mem_New(FsClientInfo);
d587 1
a587 1
	    Sys_Panic(SYS_FATAL,
d660 1
a660 1
		Mem_Free((Address)clientPtr);
d678 1
a678 1
	    Sys_Panic(SYS_FATAL, "FsReopenConsistency, no client entry\n");
d761 1
a761 1
	    Sys_Panic(SYS_WARNING,
d773 1
a773 1
	    Sys_Panic(SYS_WARNING,
d935 1
a935 1
	Sys_Printf("ConsistClose: closing client %d, lastwriter %d\n",
d947 1
a947 1
	    Sys_Panic(SYS_WARNING,
d957 1
a957 1
		Sys_Printf("ConsistClose: erasing %d lastwriter\n", clientID);
d1005 1
a1005 1
	    Mem_Free((Address) clientPtr);
d1049 1
a1049 1
		    Sys_Printf("FsDeleteLastWriter <%d,%d> host %d\n",
d1055 1
a1055 1
		Mem_Free((Address) clientPtr);
d1114 1
a1114 1
	    Sys_Panic(SYS_FATAL,
d1118 1
a1118 1
		Sys_Panic(SYS_WARNING,
d1144 1
a1144 1
		Mem_Free((Address) clientPtr);
d1203 1
a1203 1
	    Mem_Free((Address) msgPtr);
d1313 1
a1313 1
	    Sys_Panic(SYS_FATAL,
d1409 1
a1409 1
	    Mem_Free((Address) clientPtr);
d1418 1
a1418 1
	    Sys_Panic(SYS_FATAL, "ClientCommand, bad stream type <%d>\n",
d1447 1
a1447 1
    msgPtr = (ConsistMsgInfo *) Mem_Alloc(sizeof(ConsistMsgInfo));
d1459 1
a1459 1
	Sys_Panic(SYS_FATAL, "Client CallBack - consist flag not set\n");
d1474 1
a1474 1
		Sys_Panic(SYS_WARNING,
d1489 1
a1489 1
	Sys_Printf(
d1506 1
a1506 1
	Sys_Panic(SYS_WARNING,
d1515 1
a1515 1
		Mem_Free((Address) msgPtr);
d1563 1
a1563 1
	Sys_Panic(SYS_FATAL, "Fs_RpcConsist, bad stream type <%d>\n",
d1574 1
a1574 1
	    Sys_Panic(SYS_WARNING,
d1590 1
a1590 1
	    Sys_Panic(SYS_WARNING,
d1602 1
a1602 1
	    Sys_Panic(SYS_WARNING,
d1616 1
a1616 1
	    Sys_Panic(SYS_WARNING,
d1638 1
a1638 1
	consistPtr = (ConsistItem *) Mem_Alloc(sizeof(ConsistItem));
d1643 1
a1643 1
	Sys_Panic(SYS_WARNING,
d1687 1
a1687 1
	Sys_Panic(SYS_FATAL, "ProcessConsist, unexpected file type %d\n",
d1693 1
a1693 1
	Sys_Printf("<%d, %d, %d, %d>:", consistPtr->args.fileID.type,
d1697 1
a1697 1
	Sys_Panic(SYS_WARNING, "ProcessConsist: lost the handle\n");
d1712 1
a1712 1
	Sys_Printf(
d1743 1
a1743 1
	Sys_Panic(SYS_WARNING, "Got error (%x) from consist reply\n", status);
d1745 1
a1745 1
    Mem_Free((Address)consistPtr);
d1784 1
a1784 1
	Sys_Panic(SYS_FATAL, "Fs_RpcConsistReply bad stream type <%d>\n",
d1789 1
a1789 1
	Sys_Panic(SYS_FATAL, "Fs_RpcConsistReply: no handle\n");
d1851 1
a1851 1
	Sys_Panic(SYS_WARNING, "ProcessConsistReply: Client %d not found\n",
d1858 1
a1858 1
	Sys_Printf(
d1868 1
a1868 1
	Sys_Panic(SYS_WARNING,
d1904 1
a1904 1
		    Mem_Free((Address) clientPtr);
d1912 1
a1912 1
    Mem_Free((Address) msgPtr);
@


6.17
log
@call FsIOClientRemoveWriter if a migration causes a machine to go from
having a r/w reference to only having a r reference.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.16 88/09/23 13:34:51 brent Exp $ SPRITE (Berkeley)";
d74 1
a74 1
    FsFileID	fileID;		/* Which file to invalidate. */
d86 1
a86 1
    FsFileID 		fileID;
@


6.16
log
@Added swap parameter to FsReopenConsistency so the server doesn't
grant cacheability to clients on swap files.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.15 88/09/22 14:38:47 brent Exp $ SPRITE (Berkeley)";
d767 9
@


6.15
log
@Fixed consistency bug.  StartConsistency issues call-back to lastwriter.
Update list modifies lastWriter (there is a new writer).
ProcessConsist reply would blindly erase the lastwriter.
Thus the heavily shared userLog file wasn't being kept consistent.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.14 88/09/19 15:02:25 brent Exp $ SPRITE (Berkeley)";
d623 1
a623 1
FsReopenConsistency(handlePtr, clientID, use, cacheablePtr, openTimeStampPtr)
d627 1
d634 1
a634 1
    int				useFlags = 0;
d642 1
d1885 1
a1885 11
		if (!clientPtr->cached) {
		    Sys_Panic(SYS_WARNING,
			"ProcessConsistReply: client %d stopped caching\n",
			 clientID);
		    Sys_Printf("\tFile \"%s\" <%d,%d>, lastByte %d (not %d)\n",
			FsHandleName(handlePtr),
			handlePtr->hdr.fileID.major,
			handlePtr->hdr.fileID.minor,
			replyPtr->cachedAttr.lastByte,
			handlePtr->cacheInfo.attr.lastByte);
		}
d1888 1
a1888 1
		    FsUpdateAttrFromClient(&handlePtr->cacheInfo,
@


6.14
log
@Fixed uninitialized pointer bug in FsReopenConsistency
Was breaking re-opens of write-shared files, and who
knows where the pointer assignments went
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.13 88/09/19 11:19:48 brent Exp $ SPRITE (Berkeley)";
d54 3
a56 3
#ifdef REOPEN_DEBUG
int	fsTraceReopenMinor = 4779;
#endif /* REOPEN_DEBUG */
d297 3
a299 3
#ifdef REOPEN_DEBUG
    if (fsTraceReopenMinor == consistPtr->hdrPtr->fileID.minor) {
	Sys_Printf("File <%d,%d> start consist w/ use 0x%x, %s\n",
d301 3
a303 2
		consistPtr->hdrPtr->fileID.minor, useFlags,
		(cacheable ? "cacheable" : "not cacheable"));
d305 1
a305 1
#endif /* REOPEN_DEBUG */
d320 2
a321 2
#ifdef REOPEN_DEBUG
	if (fsTraceReopenMinor == consistPtr->hdrPtr->fileID.minor) {
d327 1
a327 1
#endif /* REOPEN_DEBUG */
d422 2
a423 2
#ifdef REOPEN_DEBUG
    if (fsTraceReopenMinor == consistPtr->hdrPtr->fileID.minor) {
d428 1
a428 1
#endif /* REOPEN_DEBUG */
d559 2
a560 2
#ifdef REOPEN_DEBUG
    if (fsTraceReopenMinor == handlePtr->hdr.fileID.minor) {
d565 1
a565 1
#endif /* REOPEN_DEBUG */
d922 6
d944 5
d1036 7
d1418 2
d1462 3
a1464 3
	    if (consistRpc.flags & FS_DEBUG_CONSIST) {
		Sys_Panic(SYS_FATAL,
		    "Client %d dropped too many %s requests for <%d,%d>\n",
d1466 1
d1468 4
a1471 2
	    } else if (numRefusals > 30) {
		    consistRpc.flags |= FS_DEBUG_CONSIST;
d1476 10
d1632 2
a1633 2
	Sys_Panic(SYS_FATAL,
	    "Fs_RpcConsist: <%d,%d> Too Many %s msgs dropped: %s\n",
d1699 10
d1845 11
d1865 2
a1866 1
	if (msgPtr->flags & FS_WRITE_BACK_BLOCKS) {
@


6.13
log
@Added debug print statements which caught bug in FsIOClientOpen
regarding updating the cached property of a client
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.12 88/09/15 16:34:13 brent Exp $ SPRITE (Berkeley)";
d634 1
a634 1
    ReturnStatus		status = SUCCESS;
d666 11
@


6.12
log
@Fixed cleanup of client lists so only the last writer of a
file is kept in the list after the client is completely closed.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.11 88/09/13 23:13:07 nelson Exp $ SPRITE (Berkeley)";
d54 3
d297 8
a304 1

d319 8
a326 1

d421 7
d558 8
@


6.11
log
@Fixed bug with maintaining last writer informatino.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.10 88/09/12 08:32:50 brent Exp $ SPRITE (Berkeley)";
d700 1
a700 1
    Boolean			cache = TRUE;
d705 1
d877 1
@


6.10
log
@Fixed bug regarding status returned to consistency requests.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.9 88/09/09 14:56:33 brent Exp $ SPRITE (Berkeley)";
d981 1
a985 1
    consistPtr->lastWriter = -1;
@


6.9
log
@Removed lint
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.8 88/09/09 14:44:43 brent Exp $ SPRITE (Berkeley)";
d1618 1
a1618 1
    status = FsCacheConsist(&handlePtr->cacheInfo, consistPtr->args.flags,
@


6.8
log
@Added a routine which is monitored by the per file cache lock
that takes cache consistency actions.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.7 88/09/09 12:47:26 brent Exp $ SPRITE (Berkeley)";
a1587 1
    register FsCacheFileInfo	*cacheInfoPtr;
a1591 3
    int				firstBlock;
    int				lastBlock;
    int				numSkipped;
@


6.7
log
@Updated a comment regarding version numbers
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.6 88/09/07 16:54:59 brent Exp $ SPRITE (Berkeley)";
a87 16
/*
 * Flags to determine what type of operation is required.
 *
 *    	FS_WRITE_BACK_BLOCKS	Write back all dirty blocks.
 *    	FS_INVALIDATE_BLOCKS	Invalidate all block in the cache for this
 *				file.  This means that the file is no longer
 *				cacheable.
 *    	FS_DELETE_FILE		Delete the file from the local cache and
 *				the file handle table.
 *    	FS_CANT_READ_CACHE_PIPE	The named pipe is no longer read cacheable
 *				on the client.  This would happen if two
 *				separate clients tried to read the named pipe
 *				at the same time.
 *	FS_WRITE_BACK_ATTRS	Write back the cached attributes.
 *	FS_DEBUG_CONSIST	Forces machine into debugger
 */
a88 7
#define	FS_WRITE_BACK_BLOCKS		0x01
#define	FS_INVALIDATE_BLOCKS		0x02
#define	FS_DELETE_FILE			0x04
#define	FS_CANT_READ_CACHE_PIPE		0x08
#define	FS_WRITE_BACK_ATTRS		0x10
#define FS_DEBUG_CONSIST		0x100

d1614 1
d1620 1
a1620 1
     * Process the request.
d1622 2
a1623 7
    cacheInfoPtr = &handlePtr->cacheInfo;
    if (cacheInfoPtr->attr.firstByte == -1) {
	firstBlock = 0;
    } else {
	firstBlock = cacheInfoPtr->attr.firstByte / FS_BLOCK_SIZE;
    }
    lastBlock = FS_LAST_BLOCK;
a1624 38
    reply.status = SUCCESS;
    switch (consistPtr->args.flags) {
	case FS_WRITE_BACK_BLOCKS:
	    reply.status = FsCacheFileWriteBack(cacheInfoPtr, firstBlock,
					lastBlock, FS_FILE_WB_WAIT,
					 &numSkipped);
	    break;
	case FS_CANT_READ_CACHE_PIPE:
	case FS_INVALIDATE_BLOCKS:
	    FsCacheFileInvalidate(cacheInfoPtr, firstBlock, lastBlock);
	    cacheInfoPtr->flags |= FS_FILE_NOT_CACHEABLE;
	    break;
	case FS_INVALIDATE_BLOCKS | FS_WRITE_BACK_BLOCKS:
	    reply.status = FsCacheFileWriteBack(cacheInfoPtr, firstBlock,
					lastBlock, 
				FS_FILE_WB_INVALIDATE | FS_FILE_WB_WAIT,
					&numSkipped);
	    cacheInfoPtr->flags |= FS_FILE_NOT_CACHEABLE;
	    break;
	case FS_DELETE_FILE:
	    FsCacheFileInvalidate(cacheInfoPtr, firstBlock, lastBlock);
	    cacheInfoPtr->flags |= FS_FILE_NOT_CACHEABLE;
	    if (handlePtr->rmt.recovery.use.ref > 1) {
		Sys_Panic(SYS_FATAL,
		    "ProcessConsist: Ref count > 1 on deleted file handle\n");
	    }
	    break;
	case FS_WRITE_BACK_ATTRS:
	    break;
	default:
	    Sys_Panic(SYS_WARNING, 
		      "ProcessConsist: Bad consistency action %x\n",
		      consistPtr->args.flags);
    }
    /*
     * The server wants the cached file attributes that we have.
     */
    reply.cachedAttr = cacheInfoPtr->attr;
d1632 1
a1632 1
    FsHandleRelease(handlePtr, TRUE);
@


6.6
log
@Moved name from stream to I/O handle.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.5 88/08/27 12:40:53 brent Exp $ SPRITE (Berkeley)";
d1018 5
a1022 1
 *      this file cached telling them to delete it from their cache.
d1028 1
a1028 1
 *	Any remotely cached data is invalidated.
@


6.5
log
@Fiddled with warning messages regarding cache consistency actions.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.4 88/08/26 17:30:29 brent Exp $ SPRITE (Berkeley)";
d551 2
a552 1
		"FsReopenHandle: file <%d,%d> client %d reading stale data\n",
d738 5
a742 2
		    "FsMigrateConsistency, srcClient %d unknown\n",
		    srcClientID);
d908 2
a909 1
	    "FsConsistClose, <%d,%d> client %d not last writer %d, cached %d\n",
d912 2
a913 1
		    clientID, consistPtr->lastWriter, *wasCachedPtr);
d1063 4
a1066 1
		    "FsClientRemoveCallback: client %d not last writer (%d).\n",
d1397 2
d1436 1
a1436 1
	    "ClientCommand, %s msg to client %d file <%d,%d> failed %x\n",
d1438 1
d1440 1
d1822 6
a1827 2
	Sys_Panic(SYS_WARNING, "ProcessConsist: %s request failed <%x>\n",
		ConsistType(msgPtr->flags), replyPtr->status);
d1851 2
a1852 1
		    Sys_Printf("\tFile <%d,%d>, lastByte %d (not %d)\n",
@


6.4
log
@Added version number to consistency messages
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.3 88/08/26 12:06:47 brent Exp $ SPRITE (Berkeley)";
d1405 5
a1409 6
		Sys_Panic(SYS_FATAL, "Client %d dropped too many requests\n",
			    clientPtr->clientID);
	    } else {
		Sys_Panic(SYS_WARNING, "Client %d dropped consist request %s\n",
		    clientPtr->clientID, ConsistType(flags));
		if (numRefusals > 30) {
a1410 1
		}
d1498 6
d1505 1
d1513 1
d1527 3
d1531 1
d1540 1
a1545 14
#ifdef notdef
    if ((rmtHandlePtr != (FsRmtFileIOHandle *)NIL) &&
	(rmtHandlePtr->openTimeStamp == consistArgPtr->openTimeStamp)) {
	status = SUCCESS;
    } else if (FsPrefixOpenInProgress(&consistArgPtr->fileID) == 0) {
	status = FS_STALE_HANDLE;
    } else {
	/*
	 * This message may in fact pertain to an open that we have
	 * in progress.  In this case return FAILURE and the server will retry.
	 */
	status = FAILURE;
    }
#endif notdef
d1559 2
a1560 5
	Sys_Panic(SYS_FATAL, "Fs_RpcConsist: told to enter debugger\n");
#ifdef notdef
    } else {
	Sys_Panic(SYS_WARNING,
	    "Fs_RpcConsist: <%d,%d> %s msg dropped: %s\n",
d1565 1
a1565 2
						  "open/consist race");
#endif notdef
@


6.3
log
@Removed lint
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.2 88/08/26 11:15:12 brent Exp $ SPRITE (Berkeley)";
d74 1
@


6.2
log
@Added ConsistType for better error messages.
Restructured warnings in Fs_RpcConsist.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.1 88/08/24 18:13:22 brent Exp $ SPRITE (Berkeley)";
a623 1
    Boolean			found;
@


6.1
log
@Overhauled consistency actions to remove possible deadlocks.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 6.0 88/08/11 12:19:08 brent Stable $ SPRITE (Berkeley)";
d142 1
d1349 1
a1349 3
     * Map to the client's view of the file (i.e. remote).  The openTimeStamp
     * lets the client catch races between this message and the reply
     * to an open it may be making at the same time.
d1352 1
a1352 5
    switch (consistPtr->hdrPtr->fileID.type) {
	case FS_LCL_FILE_STREAM:
	    consistRpc.fileID.type = FS_RMT_FILE_STREAM;
	    break;
	default:
d1354 3
a1356 2
		consistPtr->hdrPtr->fileID.type);
	    break;
d1358 4
d1408 3
a1410 3
		Sys_Panic(SYS_WARNING, "Client %d dropped consist request %x\n",
		    clientPtr->clientID, flags);
		if (numRefusals > 8) {
d1426 4
a1429 2
	Sys_Panic(SYS_WARNING, "ClientCommand, msg %x to client %d failed %x\n",
	    flags, clientPtr->clientID, status);
d1489 47
d1548 1
d1563 1
d1566 1
a1566 1
	    "Fs_RpcConsist: <%d,%d> %s, action %x\n",
d1569 1
d1571 2
a1572 2
						  "open/consist race",
		    consistArgPtr->flags);
d1628 2
a1629 2
    FS_CACHE_DEBUG_PRINT2("ProcessConsist: Got request %x for file %d\n", 
		    consistPtr->args.flags, handlePtr->rmt.hdr.fileID.minor);
a1674 1

d1816 2
a1817 2
	Sys_Panic(SYS_WARNING, "ProcessConsist: consistency failed <%x>\n",
				    replyPtr->status);
d1867 41
@


6.0
log
@Changing version numbers.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 1.8 88/08/05 13:00:38 brent Exp $ SPRITE (Berkeley)";
d101 1
d109 1
a218 5
    /*
     * After getting the lock on the client state we unlock the handle
     * so that doesn't interfere with cache consistency actions (like
     * write-backs) by other clients.
     */
a219 1
    FsHandleUnlock(handlePtr);
d247 1
a247 3
 *	clients so that caches stay consistent.  Some conflict checking
 *	is done first and this bails out with a non-SUCCESS return code
 *	if the open should fail altogether.  EndConsistency
d490 99
d592 4
a595 4
 *	open before we crashed.  Add the client to the set of clients using 
 *	the file.  As a side effect messages may be sent to other clients to
 *	maintain the consistency of the various clients' caches.  If we can't
 *	provide the cacheability expected by the caller then return an error.
a596 2
 *	NOTE: This routine must be called with the handle locked.
 *
d599 1
a605 4
 *      The client is added to the client list for the handle.  RPC's may
 *      be done to the other clients using the file to tell them to write
 *      back dirty blocks, or to invalidate their cached blocks.
 *	THIS UNLOCKS THE HANDLE.
d610 2
a611 4
FsReopenConsistency(handlePtr, clientID, use, cacheablePtr,
	useChangePtr, openTimeStampPtr)
    FsLocalFileIOHandle	*handlePtr;	/* Locked upon entry.  This routine
					 * unlocks it before returning. */
d615 1
a615 1
					 * cacheable.
a616 3
    FsUseCounts		*useChangePtr;	/* Actual difference between current */
					/* use for the client and the current
					 * use for the whole file. */
a627 1
    FsHandleUnlock(handlePtr);
d639 1
a639 12
    /*
     * Find the current client.
     */
    found = FALSE;
    LIST_FORALL(&(consistPtr->clientList), (List_Links *)clientPtr) {
	if (clientPtr->clientID == clientID) {
	    found = TRUE;
	    break;
	}
    }

    if (consistPtr->lastWriter == clientID && !*cacheablePtr) {
d641 1
a641 2
	 * Client was the last writer but it no longer has any dirty blocks,
	 * thus it is the last writer no longer.
d643 5
a647 21
	consistPtr->lastWriter = -1;
    }

    if (useFlags != 0) {
	if (!found) {
	    /*
	     * If we don't know about this client yet then perform full
	     * cache consistency on this file.
	     */
	    StartConsistency(consistPtr, clientID, useFlags, &cacheable);
	    if (!cacheable && *cacheablePtr) {
		/*
		 * Can't give the cacheability needed by the client.  This
		 * is because it had dirty blocks but we let someone else
		 * open for reading or writing.
		 */
		Sys_Panic(SYS_WARNING,
		    "FsReopenConsistency: cacheable conflict file <%d,%d>\n",
		    handlePtr->hdr.fileID.major, handlePtr->hdr.fileID.minor);
		status = FS_VERSION_MISMATCH;
		goto exit;
a648 5
	} else {
	    /*
	     * We already know about this client.
	     */
	    cacheable = clientPtr->cached;
d650 3
d654 1
d656 3
a658 1
	 * The client isn't using the file anymore so clean up state.
d660 10
a669 3
	if (found) {
	    List_Remove((List_Links *)clientPtr);
	    Mem_Free((Address)clientPtr);
d671 4
a674 6
	*openTimeStampPtr = consistPtr->openTimeStamp;
	useChangePtr->ref = 0;
	useChangePtr->write = 0;
	useChangePtr->exec = 0;
	UNLOCK_MONITOR;
	return(SUCCESS);
a675 42

    /*
     * At this point the re-open is ok and we have initiated any related
     * cache consistency actions by other clients.  Now we update the
     * client list to reflect what the client's current usage.  We return
     * the change in usage so our caller can update global use counts.
     */
    if (!found) {
	clientPtr = Mem_New(FsClientInfo);
	clientPtr->clientID = clientID;
	List_Insert((List_Links *) clientPtr,
		LIST_ATFRONT(&consistPtr->clientList));
	*useChangePtr = use;
    } else {
	useChangePtr->ref = use.ref - clientPtr->use.ref;
	useChangePtr->write = use.write - clientPtr->use.write;
	useChangePtr->exec = use.exec - clientPtr->use.exec;
    }
    clientPtr->use = use;
    /*
     * Get a new openTimeStamp so the client can detect races between
     * the reopen return and consistency messages generated by other
     * opens happening right now (or real soon).
     */
    openTimeStamp++;
    *openTimeStampPtr =
	consistPtr->openTimeStamp =
	    clientPtr->openTimeStamp = openTimeStamp;
    /*
     * Mark the client as caching or not.
     */
    clientPtr->cached = cacheable;
    if ((useFlags & FS_WRITE) && cacheable) {
	consistPtr->lastWriter = clientID;
    }

    /*
     * Wait for cache consistency call-backs to complete.
     */
exit:
    status = EndConsistency(consistPtr);
    *cacheablePtr = cacheable;
d708 1
a708 1
    FsLocalFileIOHandle	*handlePtr;	/* Returned UNLOCKED */
a724 1
    FsHandleUnlock(handlePtr);
d1317 1
d1393 1
d1403 11
a1413 2
	    Sys_Panic(SYS_WARNING, "Client %d dropping consist request %x\n",
		clientPtr->clientID, flags);
d1420 4
a1423 1
	 * Couldn't post call-back to the client.
d1425 1
d1428 7
a1434 2
	List_Remove((List_Links *)msgPtr);
	Mem_Free((Address)msgPtr);
d1511 2
d1514 4
a1517 1
	Sys_Panic(SYS_WARNING, "Fs_RpcConsist: %s, timeStamp %d, flags %x\n",
a1519 1
		    consistArgPtr->openTimeStamp,
a1782 1
	found = FALSE;
d1785 10
a1794 3
		found = TRUE;
		if (msgPtr->flags & FS_INVALIDATE_BLOCKS) {
		    clientPtr->cached = FALSE;
d1796 6
d1806 2
a1810 13
	}
	if (found) {
	    handlePtr = (FsLocalFileIOHandle *)consistPtr->hdrPtr;
	    if (!clientPtr->cached) {
		Sys_Panic(SYS_WARNING,
		    "ProcessConsistReply: shouldn't accecpt these attrs:\n");
		Sys_Printf("\t\tFile <%d,%d>, client %d, lastByte %d\n",
		    handlePtr->hdr.fileID.major,
		    handlePtr->hdr.fileID.minor,
		    clientID, replyPtr->cachedAttr.lastByte);
	    }
	    FsUpdateAttrFromClient(&handlePtr->cacheInfo,
		&replyPtr->cachedAttr);
@


1.8
log
@Removed lint
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 1.7 88/06/15 17:18:02 brent Exp $ SPRITE (Berkeley)";
@


1.7
log
@Changed ClientCommand and StartConsistency to voids.
Patched FsClientRemoveCallback to be more careful when
deleting client elements - sometimes they are already removed.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 1.6 88/06/06 09:41:34 brent Exp $ SPRITE (Berkeley)";
d1239 1
a1239 2
	    ReturnStatus	status;
	    register int	flags = FS_WRITE_BACK_BLOCKS;
@


1.6
log
@Fixed iterations over the client list because elements get
removed as a side-effect of call-backs.
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 1.5 88/06/04 12:10:07 brent Exp $ SPRITE (Berkeley)";
d134 1
a134 1
ReturnStatus	StartConsistency();
d137 1
a137 1
ReturnStatus 	ClientCommand();
d229 11
a239 13
    status = StartConsistency(consistPtr, clientID, useFlags, cacheablePtr);
    if (status == SUCCESS) {
	/*
	 * Add ourselves to the list of clients using the file.
	 */
	UpdateList(consistPtr, clientID, useFlags, *cacheablePtr,
		    openTimeStampPtr);
	/*
	 * Now that we are all set up, and have told all the other clients
	 * using the file what they have to do, we wait for them to finish.
	 */
	status = EndConsistency(consistPtr);
    }
d269 1
a269 1
INTERNAL ReturnStatus
a279 1
    register ReturnStatus status;
a331 1
    status = SUCCESS;
d360 1
a360 1
		status = ClientCommand(consistPtr, clientPtr,
d369 1
a369 1
		status = ClientCommand(consistPtr, clientPtr,
d377 1
a377 1
		status = ClientCommand(consistPtr, clientPtr,
a381 6
	if (status != SUCCESS) {
	    Sys_Panic(SYS_WARNING,
		"StartConsistency, error 0x%x client %d\n",
		status, clientPtr->clientID);
	    consistPtr->flags = 0;
	}
a383 1
    return(status);
d582 2
a583 3
	    status = StartConsistency(consistPtr, clientID, useFlags,
				    &cacheable);
	    if (status == SUCCESS && (!cacheable && *cacheablePtr)) {
d593 1
a593 1
		(void)EndConsistency(consistPtr);
a594 3
	    if (status != SUCCESS) {
		goto exit;
	    } 
d655 1
a656 1
exit:
d727 10
a736 13
    status = StartConsistency(consistPtr, dstClientID, useFlags, cacheablePtr);
    if (status == SUCCESS) {
	if (useFlags & FS_NEW_STREAM) {
	    /*
	     * The client is getting the stream to this I/O handle for
	     * the first time so we should add it as a client.  We are
	     * careful about this because there is only one reference to
	     * the I/O handle per client per stream. 
	     */
	    UpdateList(consistPtr, dstClientID, useFlags, *cacheablePtr,
			openTimeStampPtr);
	}
	status = EndConsistency(consistPtr);
d738 1
d885 5
a889 2
	    Sys_Panic(SYS_FATAL, "FsConsistClose, bad last writer, %d not %d\n",
		    consistPtr->lastWriter, clientID);
d1015 1
d1032 1
d1038 3
a1040 2
		Sys_Panic(SYS_FATAL,
		    "FsClientRemoveCallback: Non last writer in list.\n");
d1047 1
a1047 1
		(void)ClientCommand(consistPtr, clientPtr, FS_DELETE_FILE);
d1053 12
a1064 2
	List_Remove((List_Links *) clientPtr);
	Mem_Free((Address) clientPtr);
d1244 2
a1245 4
	    status = ClientCommand(consistPtr, clientPtr, flags);
	    if (status == SUCCESS) {
		(void)EndConsistency(consistPtr);
	    }
d1291 1
a1291 1
INTERNAL ReturnStatus
d1328 1
a1328 1
	return(SUCCESS);
d1395 2
a1399 1
    return(status);
d1760 8
@


1.5
log
@Fixed FS_CONSIST_IN_PROGRESS synchronization, see comment in code
@
text
@d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 1.4 88/06/01 17:52:42 brent Exp $ SPRITE (Berkeley)";
d279 1
d330 3
a332 1
     * adds an entry to the consistInfo's message list.
d336 5
a340 1
    LIST_FORALL(&consistPtr->clientList, (List_Links *) clientPtr) {
d798 1
d828 5
a832 1
    LIST_FORALL(&(consistPtr->clientList), (List_Links *) clientPtr) {
d925 3
a927 1
 *	Unused client list entries are cleaned up.
d943 1
a943 1
    while (!List_IsAtEnd(&consistPtr->clientList, (List_Links *)nextClientPtr)) {
d946 3
a948 1
	if (clientPtr->use.ref == 0 && !clientPtr->cached) {
d965 3
a967 1
 *	Remove the last writer from the consistency list.
d970 1
a970 1
 *	TRUE if file open, FALSE if closed.
d973 2
a974 1
 *	None.
d994 1
d1194 1
d1222 5
a1226 1
    LIST_FORALL(&consistPtr->clientList, (List_Links *)clientPtr) {
d1681 4
a1684 1
 *	client list entry is marked as non-cacheable.
@


1.4
log
@Fixed comments
@
text
@d10 14
d29 1
a29 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 1.3 88/04/28 09:00:50 brent Exp $ SPRITE (Berkeley)";
d264 2
a265 1
 *	None.
d383 1
d467 1
a467 1
 *	open the file.
d795 13
a811 1
	FsHandleUnlock((FsHandleHeader *)handlePtr);
a812 1
	FsHandleLock((FsHandleHeader *)handlePtr);
d814 2
d841 1
a841 3
     * the file what they have to do, we wait for them to finish.  The handle
     * has to be unlocked so we can fetch the handle when we process the
     * client's reply.  Set the in progress flag to block any further opens.
a842 2
    FsHandleUnlock(handlePtr);
    consistPtr->flags = FS_CONSIST_IN_PROGRESS;
d844 1
a852 62
 * FsClientGetChanges --
 *
 *	Return the changes in reference counts (of all kinds) due
 *	to a re-open attempt by a client.  This is called to determine
 *	what open or closes to make to make the server's client state
 *	consistent with what the client has.  Assuming the opens
 *	or closes succeed, FsClientOpen should be called to
 *	actually update the client list information.
 *
 *	NOTE: Synchronization must be done by our caller, i.e. by
 *	locking the I/O handle.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *      None.
 *
 * ----------------------------------------------------------------------------
 */
#ifdef notdef
INTERNAL void
FsClientGetChanges(clientList, clientID, refCount, writerCount,
		refChangePtr, writerChangePtr)
    List_Links	*clientList;	/* List of clients for the file/device */
    int		clientID;	/* The client who is opening the file. */
    int		refCount;	/* Number of references to add to this file.*/
    int		writerCount;	/* Number of writers to add to this file. */
    int		*refChangePtr;	/* Number of new references to add to this file.
				 * If < 0 is the number of closes to perform. */
    int		*writerChangePtr; /* Number of new writers to add to this file.
				   * If < 0 is the number of closes to 
				   * perform. */
{
    register FsClientInfo	*clientPtr;
    Boolean			found = FALSE;

    /*
     * Find the current client in the list.
     */
    LIST_FORALL(clientList, (List_Links *)clientPtr) {
	if (clientPtr->clientID == clientID) {
	    found = TRUE;
	    goto done;
	}
    }
done:
    if (found) {
	*refChangePtr = refCount - clientPtr->use.ref;
	*writerChangePtr = writerCount - clientPtr->use.write;
    } else {
	*refChangePtr = refCount;
	*writerChangePtr = writerCount;
    }

    UNLOCK_MONITOR;
}
#endif notdef

/*
 * ----------------------------------------------------------------------------
 *
d1011 8
a1036 2
		 * The handle is momentarily unlocked to allow the consistency
		 * reply to come in.
a1038 1
		FsHandleUnlock(consistPtr->hdrPtr);
a1041 1
		FsHandleLock(consistPtr->hdrPtr);
d1047 1
d1049 1
d1176 1
a1182 1
	FsHandleUnlock(consistPtr->hdrPtr);
a1183 1
	FsHandleLock(consistPtr->hdrPtr);
d1190 1
d1194 1
d1203 2
a1221 2
		FsHandleUnlock(consistPtr->hdrPtr);
		consistPtr->flags = FS_CONSIST_IN_PROGRESS;
a1222 1
		FsHandleLock(consistPtr->hdrPtr);
d1226 2
a1227 1

d1276 1
a1276 1
    ConsistMsg	consistRpc;
d1278 1
d1336 18
d1363 2
a1364 2
	    Sys_Panic(SYS_WARNING, "Client %d dropping consist request\n",
		clientPtr->clientID);
d1367 1
d1369 1
a1369 1
    if (status == SUCCESS) {
d1371 1
a1371 2
	 * Put the client onto the list of outstanding cache consistency
	 * messages.
d1373 2
a1374 6
	ConsistMsgInfo	*msgPtr;

	msgPtr = (ConsistMsgInfo *) Mem_Alloc(sizeof(ConsistMsgInfo));
	msgPtr->clientID = clientPtr->clientID;
	msgPtr->flags = consistRpc.flags;
	List_Insert((List_Links *) msgPtr, LIST_ATREAR(&consistPtr->msgList));
d1453 1
a1453 1
	Sys_Panic(SYS_WARNING, "Fs_RpcConsist: %s, timeStamp %d\n",
d1456 2
a1457 1
		    consistArgPtr->openTimeStamp);
d1685 3
d1693 2
a1694 1
	Sys_Panic(SYS_WARNING, "ProcessConsistReply: Client not in rpc list\n");
a1697 3
    if (List_IsEmpty(&(consistPtr->msgList))) {
	Sync_Broadcast(&consistPtr->repliesIn);
    }
d1713 3
@


1.3
log
@Made all non-regular-files un-cachable.  I.e. directories, symbolic links.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 1.2 88/04/19 10:51:13 brent Exp $ SPRITE (Berkeley)";
d1039 4
a1042 1
    int		clientID;	/* Client who is removing the file. */
d1066 1
a1066 3
		 * reply to come in.  It probably doesn't matter if it gets
		 * re-locked as the handle is bound for removal, but it leaves
		 * things as they were upon entry into this procedure.
@


1.2
log
@Added routine to return number of clients, used during scavenging.
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 1.1 88/04/11 10:10:15 brent Exp $ SPRITE (Berkeley)";
d283 1
a283 1
     *	2. Directories are not cacheable so we don't have to
d293 1
a293 1
		    == FS_DIRECTORY) {
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char rcsid[] = "$Header: fsCacheConsist.c,v 1.1 88/04/04 10:29:36 brent Exp $ SPRITE (Berkeley)";
d413 3
a415 5
    clientPtr = FsIOClientOpen(&consistPtr->clientList, clientID, useFlags);
    /*
     * Update client state that only pertains to keeping files consistent.
     */
    clientPtr->cached = cacheable;
d695 1
a695 1
    Boolean			wasCached;	/* IGNORED */
d709 1
a709 1
		&wasCached)) {
d934 43
@
