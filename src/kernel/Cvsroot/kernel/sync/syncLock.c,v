head     9.13;
branch   ;
access   ;
symbols  ds3100:9.13 sun3:9.13 sun4nw:9.12 symm:9.12 spur:9.12 sprited:9.10.1 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.13
date     92.01.06.15.19.49;  author kupfer;  state Exp;
branches ;
next     9.12;

9.12
date     91.09.24.17.37.02;  author rab;  state Exp;
branches ;
next     9.11;

9.11
date     91.09.10.18.43.31;  author rab;  state Exp;
branches ;
next     9.10;

9.10
date     91.08.15.19.58.11;  author kupfer;  state Exp;
branches 9.10.1.1;
next     9.9;

9.9
date     91.05.06.14.49.44;  author kupfer;  state Exp;
branches ;
next     9.8;

9.8
date     91.04.19.21.56.22;  author kupfer;  state Exp;
branches ;
next     9.7;

9.7
date     91.03.20.11.31.03;  author kupfer;  state Exp;
branches ;
next     9.6;

9.6
date     90.10.05.17.50.28;  author mendel;  state Exp;
branches ;
next     9.5;

9.5
date     90.10.05.17.35.31;  author shirriff;  state Exp;
branches ;
next     9.4;

9.4
date     90.09.11.12.17.25;  author jhh;  state Exp;
branches ;
next     9.3;

9.3
date     90.04.03.14.39.57;  author mgbaker;  state Exp;
branches ;
next     9.2;

9.2
date     89.10.23.11.14.08;  author jhh;  state Exp;
branches ;
next     9.1;

9.1
date     89.10.21.17.26.51;  author jhh;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.19.57;  author douglis;  state Stable;
branches ;
next     8.12;

8.12
date     89.08.29.15.11.05;  author jhh;  state Exp;
branches ;
next     8.11;

8.11
date     89.08.17.17.31.52;  author jhh;  state Exp;
branches ;
next     8.10;

8.10
date     89.08.01.20.43.56;  author jhh;  state Exp;
branches ;
next     8.9;

8.9
date     89.07.23.16.59.00;  author jhh;  state Exp;
branches ;
next     8.8;

8.8
date     89.06.25.20.05.08;  author jhh;  state Exp;
branches ;
next     8.7;

8.7
date     89.04.06.12.11.06;  author jhh;  state Exp;
branches ;
next     8.6;

8.6
date     89.02.28.12.27.08;  author jhh;  state Exp;
branches ;
next     8.5;

8.5
date     89.02.19.22.15.18;  author jhh;  state Exp;
branches ;
next     8.4;

8.4
date     89.01.06.11.29.07;  author jhh;  state Exp;
branches ;
next     8.3;

8.3
date     89.01.05.15.47.07;  author mendel;  state Exp;
branches ;
next     8.2;

8.2
date     88.12.04.15.34.23;  author ouster;  state Exp;
branches ;
next     8.1;

8.1
date     88.11.22.19.36.32;  author jhh;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.37.57;  author douglis;  state Stable;
branches ;
next     6.4;

6.4
date     88.10.30.21.14.22;  author jhh;  state Exp;
branches ;
next     6.3;

6.3
date     88.10.24.09.18.55;  author douglis;  state Exp;
branches ;
next     6.2;

6.2
date     88.08.25.22.39.56;  author douglis;  state Exp;
branches ;
next     6.1;

6.1
date     88.08.24.14.48.43;  author douglis;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.27.04;  author brent;  state Stable;
branches ;
next     5.8;

5.8
date     88.06.27.14.20.59;  author ouster;  state Exp;
branches ;
next     5.7;

5.7
date     88.05.05.18.00.22;  author nelson;  state Exp;
branches ;
next     5.6;

5.6
date     88.03.22.09.15.47;  author brent;  state Exp;
branches ;
next     5.5;

5.5
date     88.03.09.11.13.37;  author douglis;  state Exp;
branches ;
next     5.4;

5.4
date     88.03.08.16.16.08;  author nelson;  state Exp;
branches ;
next     5.3;

5.3
date     87.12.16.13.03.51;  author nelson;  state Exp;
branches ;
next     5.2;

5.2
date     87.12.15.16.50.12;  author nelson;  state Exp;
branches ;
next     5.1;

5.1
date     87.12.12.16.41.13;  author nelson;  state Exp;
branches ;
next     5.0;

5.0
date     87.08.11.10.50.59;  author sprite;  state Exp;
branches ;
next     ;

9.10.1.1
date     91.08.15.20.08.09;  author kupfer;  state Exp;
branches ;
next     ;


desc
@@


9.13
log
@Fix header comments for Sync_UnlockAndSwitch.
@
text
@/* 
 * syncLock.c --
 *
 *	These are internal locking routines of the Synchronization module.
 *	These routines are slower but safer versions of the routines (found
 *	in sync.h) to get and release monitor locks, and to wait on
 *	and notify condition variables.
 *
 *	A process is blocked by making it wait on an event.  An event is
 *	just an uninterpreted integer that gets 'signaled' by the routine
 *	Sync_SlowBroadcast.
 *
 * Copyright 1985 Regents of the University of California
 * All rights reserved.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/sync/syncLock.c,v 9.12 91/09/24 17:37:02 rab Exp $ SPRITE (Berkeley)";
#endif /* not lint */

#include <sync.h>
#include <sprite.h>
#include <mach.h>
#include <list.h>
#include <syncInt.h>
#include <sched.h>
#include <proc.h>
#include <timer.h>
#include <rpc.h>
#include <bstring.h>

/*
 * A counter to record the number of busy wait loops executed
 * while trying to P a semaphore.  This is incremented inside the
 * loop of MASTER_LOCK.
 */
int sync_BusyWaits = 0;

/*
 * A counter to record the number of events that had clashes on the hash.
 */

int	sync_Collisions = 0;

/*
 * The event hash chain.  Process control blocks are placed in a hash
 * chain keyed on the event that the process is waiting on.
 */

#define PROC_HASHBUCKETS	63
static List_Links eventChainHeaders[PROC_HASHBUCKETS];

/*
 * Instrumentation to record the number of calls to the wakeup routine
 * and to record how many processes were woken up.
 */

Sync_Instrument sync_Instrument[MACH_MAX_NUM_PROCESSORS];
Sync_Instrument *sync_InstrumentPtr[MACH_MAX_NUM_PROCESSORS];

/*
 * Statistics related to remote waiting.
 */
int syncProcWakeupRaces = 0;

static void ProcessWakeup _ARGS_((Proc_ControlBlock *procPtr, int waitToken));


/*
 *----------------------------------------------------------------------------
 *
 * Sync_Init --
 *
 *	This initializes the event hash chain.  The hash table is
 *	an array of list headers.
 *
 *	Instrumentation variables are also initialized.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *	The hash chain headers are initialized to be dummy list elements
 *
 *----------------------------------------------------------------------------
 */
void
Sync_Init()
{
    register int i;

    for (i=0 ; i<PROC_HASHBUCKETS ; i++) {
	List_Init(&eventChainHeaders[i]);
    }
    bzero((Address) sync_Instrument, sizeof(sync_Instrument));
    for (i=0; i < MACH_MAX_NUM_PROCESSORS; i++) {
	sync_InstrumentPtr[i] = &sync_Instrument[i];
    }
}


/*
 *----------------------------------------------------------------------
 *
 * Sync_GetLock --
 *
 *	This is the kernel version of the Sync_GetLock routine. The user
 * 	version is written in assembler, but in the kernel we want to
 *	record locking statistics so we have our own version.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The type of the previous lock is added to the array of prior types.
 *	The lock is added to the lock stack in the pcb.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Sync_GetLock(lockPtr)
   Sync_Lock *lockPtr;
{
    ReturnStatus	status = SUCCESS;

    Sync_LockRegister(lockPtr);
    if (Mach_TestAndSet(&(lockPtr->inUse)) != 0) {
	status = Sync_SlowLock(lockPtr); 
    } else {
	Sync_RecordHit(lockPtr);
	Sync_StoreDbgInfo(lockPtr, FALSE);
	Sync_AddPrior(lockPtr);
    }
    return status;
}


/*
 *----------------------------------------------------------------------
 *
 *  Sync_Unlock--
 *
 *	The kernel version of the unlock routine. We have a different
 *	version from the user so we can do locking statistics.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The lock is removed from the lock stack in the pcb.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Sync_Unlock(lockPtr)
    Sync_Lock *lockPtr;
{
    ReturnStatus	status = SUCCESS;

    lockPtr->inUse = 0;
    SyncDeleteCurrent(lockPtr);
    if (lockPtr->waiting) {
	status = Sync_SlowBroadcast((unsigned int)lockPtr, &lockPtr->waiting);
    }
    return status;
}


/*
 *----------------------------------------------------------------------------
 *
 * Sync_SlowLock --
 *
 *	Acquire a lock while holding the synchronization master lock.
 *
 *      Inside the critical section the inUse bit is checked.  If we have
 *      to wait the process is put to sleep waiting on an event associated
 *      with the lock.
 *
 * Results:
 *	SUCCESS		is always returned.
 *
 * Side effects:
 *      The lock is acquired when this procedure returns.  The process may
 *      have been put to sleep while waiting for the lock to become
 *      available.
 *
 *----------------------------------------------------------------------------
 */

ENTRY ReturnStatus
Sync_SlowLock(lockPtr)
    register	Sync_Lock	*lockPtr;
{
    MASTER_LOCK(sched_MutexPtr);

#ifdef spur
    Mach_InstCountStart(0);
#endif

    while (Mach_TestAndSet(&(lockPtr->inUse)) != 0) {
	lockPtr->waiting = TRUE;
	/*
	 * Check the inUse semaphore again after setting the waiting. A zero 
	 * semaphore value means the lock was released after our previous
	 * TestAndSet and possibly before we set the waiting flag. This test
	 * prevents us from waiting if the Sync_Lock missed our waiting flag.
	 */
        if (Mach_TestAndSet(&(lockPtr->inUse)) == 0) {
	    break;
	}
	(void) SyncEventWaitInt((unsigned int)lockPtr, FALSE);
	Sync_RecordMiss(lockPtr);
#ifdef spur
	Mach_InstCountEnd(1);
#endif
	MASTER_UNLOCK(sched_MutexPtr);
	MASTER_LOCK(sched_MutexPtr);
#ifdef spur
	Mach_InstCountStart(0);
#endif
    }
    Sync_RecordHit(lockPtr);
    Sync_StoreDbgInfo(lockPtr, FALSE);
    Sync_AddPrior(lockPtr);
#ifdef spur
    Mach_InstCountOff(0);
    if (Mach_InstCountIsOn(1)) {
	panic("About to unlock sched_Mutex with inst count on.\n");
    }
#endif
    MASTER_UNLOCK(sched_MutexPtr);
    return(SUCCESS);
}


/*
 *----------------------------------------------------------------------------
 *
 * Sync_SlowWait --
 *
 *      Wait on a condition.  The lock is released and the process is blocked
 *      on the event.  A future call to SyncSlowBroadcast will signal the
 *      condition and make this process runnable again.  Before returning
 *	the lock is reaquired.
 *
 *      This can only be called while a lock is held.  This forces our
 *      client to safely check global state while in a monitor.
 *
 * Results:
 *	TRUE if interrupted because of signal, FALSE otherwise.
 *
 * Side effects:
 *      Put the process to sleep and release the monitor lock.  Other
 *      processes waiting on the monitor lock become runnable.
 *
 *----------------------------------------------------------------------------
 */

ENTRY Boolean
Sync_SlowWait(conditionPtr, lockPtr, wakeIfSignal)
    Sync_Condition	*conditionPtr;	/* Condition to wait on. */
    register Sync_Lock 	*lockPtr;	/* Lock to release. */
    Boolean		wakeIfSignal;	/* TRUE => wake if signal pending. */
{
    Boolean	sigPending;

    conditionPtr->waiting = TRUE;
    MASTER_LOCK(sched_MutexPtr);
    /*
     * release the monitor lock and wait on the condition
     */
    lockPtr->inUse = 0;
    lockPtr->waiting = FALSE;
    SyncDeleteCurrent(lockPtr);
    SyncEventWakeupInt((unsigned int)lockPtr);
    sigPending = SyncEventWaitInt((unsigned int) conditionPtr, wakeIfSignal);
#ifdef spur
    Mach_InstCountEnd(1);
#endif
    MASTER_UNLOCK(sched_MutexPtr);

    (void) Sync_GetLock(lockPtr);

    return(sigPending);
}


/*
 *----------------------------------------------------------------------------
 *
 * Sync_SlowBroadcast --
 *
 *      Mark all processes waiting on an event as runable.  The flag that
 *      indicates there are waiters is cleared here inside the protected
 *      critical section.  This has "broadcast" semantics because everyone
 *      waiting is made runable.  We don't yet have a mechanism to wake up
 *      just one waiting process.
 *
 * Results:
 *	SUCCESS		is always returned.
 *
 * Side effects:
 *	Make processes waiting on the event runnable.
 *
 *----------------------------------------------------------------------------
 */

ENTRY ReturnStatus
Sync_SlowBroadcast(event, waitFlagPtr)
    unsigned int event;
    int *waitFlagPtr;
{
    MASTER_LOCK(sched_MutexPtr);

    *waitFlagPtr = FALSE;
    SyncEventWakeupInt(event);
#ifdef spur
    if (Mach_InstCountIsOn(1)) {
	panic("About to unlock sched_Mutex with inst count on.\n");
    }
#endif

    MASTER_UNLOCK(sched_MutexPtr);
    return(SUCCESS);
}


/*
 *----------------------------------------------------------------------------
 *
 * Sync_SlowMasterWait --
 *
 *      Wait on an event.  Like SyncSlowWait except that the lock that
 *	is released is a master lock, not a monitor lock.
 *
 * Results:
 *	TRUE if wake up because of a signal, FALSE otherwise.
 *
 * Side effects:
 *      Put the process to sleep and release the master lock.  Other
 *      processes waiting on the monitor lock become runnable.
 *	
 *
 *----------------------------------------------------------------------------
 */

ENTRY Boolean
Sync_SlowMasterWait(event, mutexPtr, wakeIfSignal)
    unsigned int 	event;		/* Event to wait on. */
    Sync_Semaphore	*mutexPtr;	/* Mutex to release and reaquire. */
    Boolean 		wakeIfSignal;	/* TRUE => wake if signal pending. */
{
    Boolean	sigPending;

    MASTER_LOCK(sched_MutexPtr);

    /*
     * release the master lock and wait on the condition
     */
    MASTER_UNLOCK(mutexPtr);

    sigPending = SyncEventWaitInt(event, wakeIfSignal);

#ifdef spur
    Mach_InstCountEnd(1);
#endif

    MASTER_UNLOCK(sched_MutexPtr);
    /*
     * re-acquire master lock before proceeding
     */
    MASTER_LOCK(mutexPtr);

    return(sigPending);
}


/*
 *----------------------------------------------------------------------------
 *
 * Sync_UnlockAndSwitch --
 *
 *      Release the monitor lock and then perform a context switch to the
 *	given state.
 *
 * Results:
 *	SUCCESS		is always returned.
 *
 * Side effects:
 *      Context switch the process and release the monitor lock.  Other
 *      processes waiting on the monitor lock become runnable.
 *	
 *----------------------------------------------------------------------------
 */

void
Sync_UnlockAndSwitch(lockPtr, state)
    register	Sync_Lock 	*lockPtr;
    Proc_State			state;
{

    MASTER_LOCK(sched_MutexPtr);
    /*
     * release the monitor lock and context switch.
     */
    lockPtr->inUse = 0;
    lockPtr->waiting = FALSE;
    SyncDeleteCurrent(lockPtr);
    SyncEventWakeupInt((unsigned int)lockPtr);
    Sched_ContextSwitchInt(state);
#ifdef spur
    Mach_InstCountEnd(1);
#endif
    MASTER_UNLOCK(sched_MutexPtr);
}


/*
 *----------------------------------------------------------------------------
 *
 * SyncEventWakeupInt --
 *
 *      This looks through the process table for processes waiting on an
 *      event.  For each one it finds it clears its event and marks the
 *      process runnable.  Blocked processes are placed on a hash chain
 *	keyed on the event they are blocked on.  It is this hash chain
 *	that this procedure scans.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *      removes process table entries from their event hash chain and
 *      marks them runnable.
 *
 *----------------------------------------------------------------------------
 */

INTERNAL void
SyncEventWakeupInt(event)
    unsigned int event;
{
    register	Proc_ControlBlock 	*procPtr;
    register	Proc_PCBLink 		*hashChainItemPtr;
    register	List_Links 		*chainHeader;
    register	List_Links		*itemPtr;
    int		pnum;

    if (!sched_MutexPtr->value) {
	panic("SyncEventWakeupInt: master lock not held.\n");
    }
    pnum = Mach_GetProcessorNumber();
    
    sync_Instrument[pnum].numWakeupCalls++;
    chainHeader = &eventChainHeaders[event % PROC_HASHBUCKETS];

    itemPtr = List_First(chainHeader);
    while (!List_IsAtEnd(chainHeader, itemPtr)) {
	hashChainItemPtr = (Proc_PCBLink *)itemPtr;
	itemPtr = List_Next(itemPtr);
	procPtr = hashChainItemPtr->procPtr;
	if (procPtr->event != event) {
	    sync_Collisions++;
	    continue;
	}
	switch (procPtr->state) {
	    case PROC_WAITING:
	        break;
	    case PROC_MIGRATED:
		/*
		 * Need to handle waking up migrated processes.
		 */
		panic("Can't handle waking up a migrated proc.\n");
		break;
	    default:
		panic("%s %s",  
			  "Sync_EventWakeupInt:",
			  "Tried to wakeup a non-waiting proc.\n");
	    break;

	}

	sync_Instrument[pnum].numWakeups++;
	List_Remove((List_Links *) hashChainItemPtr);
	procPtr->event = NIL;
	if (procPtr->state == PROC_WAITING) {
	    procPtr->state = PROC_READY;
	    Sched_InsertInQueue(procPtr, (Proc_ControlBlock **) NIL);
	}
    }
}


/*
 *----------------------------------------------------------------------------
 *
 * Sync_WakeWaitingProcess --
 *
 *      Wake up a particular process as though the local or remote event it is 
 *	awaiting has occurred.
 *
 *	This code was originally written for a uniprocessor. As a result, the
 *	case of signaling a running process was never dealt with. We must
 *	prevent a running process from going to sleep in between the time
 *	we see it is running, and the time it gets the signal. It would seem
 *	we could do this by locking the pcb, but unfortunately 
 *	Sync_EventWaitInt does not grab this lock. This means we have to grab
 *	the sched_MutexPtr. Ideally we would grab the mutex in the sig module
 *	(Sig_Send perhaps). If we did that, then we would deadlock in this
 *	routine. The bottom line is that this routine must do more than its
 *	name implies, due to some weirdness in the way the system is
 *	structured. If a process is ready, nothing is done. If a process
 *	is running, the other processor is interrupted to force it into the
 *	kernel, at which point it sees the signal.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *      If waiting on an event, removes the given process from its event hash 
 *	chain and makes it runnable. If running, interrupts other processor.
 *
 *----------------------------------------------------------------------------
 */

void
Sync_WakeWaitingProcess(procPtr)
    register	Proc_ControlBlock 	*procPtr;
{
    MASTER_LOCK(sched_MutexPtr);
    if (procPtr->event != NIL) {
	List_Remove(&procPtr->eventHashChain.links);
	procPtr->event = NIL;
	procPtr->state = PROC_READY;
	Sched_InsertInQueue(procPtr, (Proc_ControlBlock **) NIL);
    } else if (procPtr->state == PROC_WAITING) {
	    if (!(procPtr->syncFlags & SYNC_WAIT_REMOTE)) {
		panic("Sync_WakeWaitingProcess: Proc waiting but event and remote wait NIL\n");
	    }
	    ProcessWakeup(procPtr, procPtr->waitToken);
    } else if (procPtr->state == PROC_RUNNING &&
	       procPtr->processor != Mach_GetProcessorNumber()) {
	Mach_CheckSpecialHandling(procPtr->processor);
    }
#ifdef spur
    if (Mach_InstCountIsOn(1)) {
	panic("About to unlock sched_Mutex with inst count on.\n");
    }
#endif
    MASTER_UNLOCK(sched_MutexPtr);
}


/*
 *----------------------------------------------------------------------------
 *
 * Sync_RemoveWaiter --
 *
 *      Remove a process from any event chain it may be on.
 *	This is distinguished from Sync_WakeWaitingProcess because
 *	it does not place the process in the ready queue.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------------
 */

void
Sync_RemoveWaiter(procPtr)
    register	Proc_ControlBlock 	*procPtr;
{
    MASTER_LOCK(sched_MutexPtr);
    if (procPtr->event != NIL) {
	List_Remove(&procPtr->eventHashChain.links);
	procPtr->event = NIL;
    } else {
	if (procPtr->state == PROC_WAITING) {
	    if (!(procPtr->syncFlags & SYNC_WAIT_REMOTE)) {
		panic("Sync_RemoveWaiter: Proc waiting but event and remote wait NIL\n");
	    }
	    procPtr->syncFlags |= SYNC_WAIT_COMPLETE;
	}
    }
    MASTER_UNLOCK(sched_MutexPtr);
}


/*
 *----------------------------------------------------------------------------
 *
 * SyncEventWaitInt --
 *
 *	Make a process sleep waiting for an event.  The blocked process is
 *	placed on a hash chain keyed on the event.  This routine will return
 *	without putting the process to sleep if there is a signal pending
 *	and the proper flag is set in the proc table.
 *
 * Results:
 *	TRUE if woke up because of a signal, FALSE otherwise.
 *
 * Side effects:
 *	The event that the process is waiting for is noted in the process
 *	table.  The process is marked as waiting and a new process
 *	is selected to run.
 *
 *----------------------------------------------------------------------------
 */

INTERNAL Boolean
SyncEventWaitInt(event, wakeIfSignal)
    unsigned 	int 	event;		/* Event to wait on. */
    Boolean		wakeIfSignal;	/* TRUE => wake if signal. */
{
    Proc_ControlBlock *procPtr;
    List_Links *chainHeader;

    procPtr = Proc_GetCurrentProc();

    if (wakeIfSignal && Sig_Pending(procPtr)) {
	return(TRUE);
    }

    chainHeader = &eventChainHeaders[event % PROC_HASHBUCKETS];
    List_Insert(&procPtr->eventHashChain.links, LIST_ATREAR(chainHeader));

    procPtr->event = event;
    Sched_ContextSwitchInt(PROC_WAITING);
    return(FALSE);
}


/*
 *----------------------------------------------------------------------------
 *
 * Sync_GetWaitToken --
 *
 *	Return the process id and increment and return wait token for the 
 *	current process.
 *
 * Results:
 *	process ID and wait token for current process.
 *
 * Side effects:
 *	Wait token incremented.
 *
 *----------------------------------------------------------------------------
 */

ENTRY void
Sync_GetWaitToken(pidPtr, tokenPtr)
    Proc_PID	*pidPtr;	/* If non-nil pid of current process. */
    int		*tokenPtr;	/* Wait token of current process. */
{
    register	Proc_ControlBlock	*procPtr;

    procPtr = Proc_GetCurrentProc();

    MASTER_LOCK(sched_MutexPtr);

    procPtr->waitToken++;
    if (pidPtr != (Proc_PID *) NIL) {
	*pidPtr = procPtr->processID;
    }
    *tokenPtr = procPtr->waitToken;

    MASTER_UNLOCK(sched_MutexPtr);
}


/*
 *----------------------------------------------------------------------------
 *
 * Sync_SetWaitToken --
 *
 *	Set the wait token for the given process.  Only exists for process
 *	migration should not be used in general.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Wait token value set in the PCB for the given process.
 *
 *----------------------------------------------------------------------------
 */

ENTRY void
Sync_SetWaitToken(procPtr, waitToken)
    Proc_ControlBlock	*procPtr;	/* Process to set token for. */
    int			waitToken;	/* Token value. */
{
    MASTER_LOCK(sched_MutexPtr);

    procPtr->waitToken = waitToken;

    MASTER_UNLOCK(sched_MutexPtr);
}


/*
 *----------------------------------------------------------------------------
 *
 * Sync_ProcWait --
 *
 *	This is called to block a process after it has been told by a
 *	remote host that it has to wait.  The wait completed flag is
 *	checked here to see if the remote host's wakeup message has raced 
 *	(and won) with this process's decision to call this procedure.
 *
 *	For safety, this routine should be expanded to automatically
 *	set up a timeout event which will wake up the process anyway.
 *
 * Results:
 *	TRUE if woke up because of a signal, FALSE otherwise.
 *
 * Side effects:
 *	The wait complete flag of the process is checked and the process
 *	is blocked if a notify message has not already arrived.
 *
 *----------------------------------------------------------------------------
 */

ENTRY Boolean
Sync_ProcWait(lockPtr, wakeIfSignal)
    Sync_Lock	*lockPtr;	/* If non-nil release this lock before going to
				 * sleep and reaquire it after waking up. */
    Boolean	wakeIfSignal;	/* TRUE => Don't go to sleep if a signal is
				 *         pending. */
{
    register	Proc_ControlBlock 	*procPtr;
    Boolean				releasedLock = FALSE;
    Boolean				sigPending = FALSE;

    MASTER_LOCK(sched_MutexPtr);
    procPtr = Proc_GetCurrentProc();
    if (!(procPtr->syncFlags & SYNC_WAIT_COMPLETE)) {
	if (wakeIfSignal && Sig_Pending(procPtr)) {
	    /*
	     * Check for signals.   If a signal is pending, then bail out.
	     */
	    sigPending = TRUE;
	} else {
	    /*
	     * Block the process.  The wakeup message from the remote host
	     * has not arrived.
	     */
	    procPtr->syncFlags |= SYNC_WAIT_REMOTE;
	    if (lockPtr != (Sync_Lock *) NIL) {
		/*
		 * We were given a monitor lock to release, so release it.
		 */
		lockPtr->inUse = 0;
		lockPtr->waiting = FALSE;
		SyncEventWakeupInt((unsigned int)lockPtr);
		releasedLock = TRUE;
	    }
	    Sched_ContextSwitchInt(PROC_WAITING);
	    if (wakeIfSignal && Sig_Pending(procPtr)) {
		sigPending = TRUE;
	    }
	}
    }
    /*
     * After being notified (and context switching back to existence),
     * or if we have already been notified, clear state about the
     * remote wait.  This means our caller should get a new token
     * (ie. retry whatever remote operation it was) before waiting
     * again.
     */
    procPtr->waitToken++;
    procPtr->syncFlags &= ~(SYNC_WAIT_COMPLETE | SYNC_WAIT_REMOTE);
#ifdef spur
    Mach_InstCountEnd(1);
#endif
    MASTER_UNLOCK(sched_MutexPtr);
    if (releasedLock) {
	(void) Sync_GetLock(lockPtr);
    }
    return(sigPending);
}


/*
 *----------------------------------------------------------------------------
 *
 * Sync_ProcWakeup --
 *
 *	Wakeup a blocked process in response to a message from a remote
 *	host.  Call internal routine to do the work.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------------
 */

ENTRY void
Sync_ProcWakeup(pid, token)
    Proc_PID 	pid;	/* PID of process to wake up. */
    int		token;	/* Token to use to wake up process. */
{
    Proc_ControlBlock 	*procPtr;

    procPtr = Proc_GetPCB(pid);
    if (procPtr != (Proc_ControlBlock *)NIL) {
	MASTER_LOCK(sched_MutexPtr);
	ProcessWakeup(procPtr, token);
	MASTER_UNLOCK(sched_MutexPtr);
    }
}


/*
 *----------------------------------------------------------------------------
 *
 * ProcessWakeup --
 *
 *	Wakeup a blocked process in response to a message from a remote
 *	host.  It is possible that the wakeup message has raced and
 *	won against the local process's call to Sync_ProcWait.  This
 *	protected against with a token and a wakeup complete flag.
 *	(The token provides extra protection against spurious wakeups.
 *	 As we don't make any guarantees about the correctness of a
 *	 wakeup anyway, we ignore the token here.)
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	syncFlags modified.
 *
 *----------------------------------------------------------------------------
 */

/* ARGSUSED */
static INTERNAL void
ProcessWakeup(procPtr, waitToken)
    register	Proc_ControlBlock 	*procPtr;	/* Process to wake up.*/
    int					waitToken;	/* Token to use. Now
							 * this is ignored. */
{
    procPtr->syncFlags |= SYNC_WAIT_COMPLETE;
    if (procPtr->state == PROC_WAITING) {
	/*
	 * Only wakeup if are doing a 'process wait' and not an 'event wait'.
	 */
	if (procPtr->event == NIL) {
	    procPtr->state = PROC_READY;
	    Sched_InsertInQueue(procPtr, (Proc_ControlBlock **) NIL);
	}
    } else {
	/*
	 * This is a notify message which has raced (and won) with the 
	 * process's call to Sync_ProcWait.
	 */
	syncProcWakeupRaces++;
    }
}


/*
 *----------------------------------------------------------------------
 *
 * Sync_RemoteNotify --
 *
 *	Perform an RPC to notify a remote process.
 *
 * Results:
 *	The return code from the RPC.  This enables the caller to decide
 *	if it should wait and retry the notify later if the remote
 *	host is unavailable.
 *
 * Side effects:
 *      This results in a call to Sync_ProcWakeup on the host of the
 *      waiting process.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
Sync_RemoteNotify(waitPtr)
    Sync_RemoteWaiter *waitPtr;		/* Arguments to remote notify. */
{
    Rpc_Storage storage;
    ReturnStatus status;

    storage.requestParamPtr = (Address)waitPtr;
    storage.requestParamSize = sizeof(Sync_RemoteWaiter);
    storage.requestDataSize = 0;
    storage.replyParamSize = 0;
    storage.replyDataSize = 0;
    status = Rpc_Call(waitPtr->hostID, RPC_REMOTE_WAKEUP, &storage);
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * Sync_RemoteNotifyStub --
 *
 *	The service stub for the remote wakeup RPC.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *      A call to Sync_ProcWakeup on the process.
 *
 *----------------------------------------------------------------------
 */

/* ARGSUSED */
ReturnStatus
Sync_RemoteNotifyStub(srvToken, clientID, command, storagePtr)
    ClientData 	srvToken;	/* Handle on server process passed to
				 * Rpc_Reply. */
    int 	clientID;	/* Sprite ID of client host (ignored). */
    int 	command;	/* Command identifier (ignored). */
    Rpc_Storage *storagePtr;    /* The request fields refer to the request
				 * buffers and also indicate the exact amount
				 * of data in the request buffers.  The reply
				 * fields are initialized to NIL for the
				 * pointers and 0 for the lengths.  This can
				 * be passed to Rpc_Reply. */
{
    register Sync_RemoteWaiter *waitPtr;

    waitPtr = (Sync_RemoteWaiter *)storagePtr->requestParamPtr;
    Sync_ProcWakeup(waitPtr->pid, waitPtr->waitToken);
    Rpc_Reply(srvToken, SUCCESS, storagePtr, (int (*) ()) NIL,
	      (ClientData) NIL);
    return(SUCCESS);
}

@


9.12
log
@Removed unused variable.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 9.11 91/09/10 18:43:31 rab Exp Locker: rab $ SPRITE (Berkeley)";
d387 1
a387 2
 *	given state.  The monitor lock is reaquired before this routine 
 *	returns.
@


9.11
log
@Fixed lint errors and removed tracing.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 9.10 91/08/15 19:58:11 kupfer Exp Locker: rab $ SPRITE (Berkeley)";
a125 1
    Proc_ControlBlock	*procPtr;
@


9.10
log
@Fix strange typo.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 9.9 91/05/06 14:49:44 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
a65 5
/* 
 * Locks held during initialization, when there's no "current process".
 */
static nullProcLocks = 0;

a66 1
static void CheckUnlock _ARGS_ ((Sync_Lock *lockPtr));
a135 8

    procPtr = Proc_GetCurrentProc();
    if (procPtr == (Proc_ControlBlock *)NIL) {
	nullProcLocks++;
    } else {
	procPtr->locksHeld++;
    }

a162 2
    CheckUnlock(lockPtr);

a271 2
    CheckUnlock(lockPtr);

a405 1
    CheckUnlock(lockPtr);
a760 1
		CheckUnlock(lockPtr);
a946 53

/*
 *----------------------------------------------------------------------
 *
 * CheckUnlock --
 *
 *	Paranoia checks when releasing a monitor or master lock.  Make 
 *	sure that 
 *	(1) the count of obtained locks is high enough
 *	(2) the lock is actually in use
 *	(3) the process that owns the lock is the process that 
 *	    releases it .
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Decrements the counter in the current process's pcb.  If there 
 *	isn't a current process, decrements the global "no process" 
 *	lock counter.
 *
 *----------------------------------------------------------------------
 */

static void
CheckUnlock(lockPtr)
    Sync_Lock	*lockPtr;
{
    int			locksHeld; /* locks held by current process */
    Proc_ControlBlock	*procPtr;

    procPtr = Proc_GetCurrentProc();
    if (procPtr == (Proc_ControlBlock *)NIL) {
	nullProcLocks--;
	locksHeld = nullProcLocks;
    } else {
	procPtr->locksHeld--;
	locksHeld = procPtr->locksHeld;
    }
    if (locksHeld < 0) {
	panic("more unlocks than locks.\n");
    }
    if (!lockPtr->inUse) {
	panic("unlocking an unlocked lock.\n");
    }

#ifndef CLEAN_LOCK
    if (lockPtr->holderPCBPtr != (Proc_ControlBlock *)NIL &&
	    lockPtr->holderPCBPtr != procPtr) {
	panic("unlocking somebody else's lock.\n");
    }
#endif
}
@


9.10.1.1
log
@Initial branch for Sprite server.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 9.10 91/08/15 19:58:11 kupfer Exp $ SPRITE (Berkeley)";
@


9.9
log
@Add lock paranoia checks.  Minor formatting and comment changes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 9.8 91/04/19 21:56:22 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
d995 1
a995 2
    int			locksHeld; /* 
    int			locksHeld;  * locks held by current process */
@


9.8
log
@PROC_MIGRATING isn't a state, so don't look for it when switching on a
process state.

@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 9.7 91/03/20 11:31:03 kupfer Exp Locker: kupfer $ SPRITE (Berkeley)";
a24 1
#include <sync.h>
d66 5
d72 1
a74 1

d106 1
a106 1

a115 2
 *	If LOCKREG is not defined then don't compile any of this, so that 
 *	the faster user version  is used.
d132 1
d142 8
a160 2
 *	If LOCKREG is not defined then don't compile any of this, so that 
 *	the faster user version  is used.
d176 3
d187 1
d288 1
d424 2
d780 1
d965 55
@


9.7
log
@Flush Sync_EventWait and Sync_EventWakeup.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 9.6 90/10/05 17:50:28 mendel Exp Locker: kupfer $ SPRITE (Berkeley)";
a475 3
	        break;
	    case PROC_MIGRATING:
		panic("Can't handle waking up a migrating proc.\n");
@


9.6
log
@Did function prototypeing and fixed include files.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 9.5 90/10/05 17:35:31 shirriff Exp Locker: mendel $ SPRITE (Berkeley)";
a505 33
 *----------------------------------------------------------------------
 *
 * Sync_EventWakeup --
 *
 *	Perform a broadcast to wake up a process awaiting an arbitrary
 *	event.  Obtain the master lock, then call the internal Wakeup
 *	routine.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Make any processes waiting on this event runnable.
 *
 *----------------------------------------------------------------------
 */

ENTRY void
Sync_EventWakeup(event)
    unsigned int event;	/* arbitrary integer */
{
    MASTER_LOCK(sched_MutexPtr);
    SyncEventWakeupInt(event);
#ifdef spur
    if (Mach_InstCountIsOn(1)) {
	panic("About to unlock sched_Mutex with inst count on.\n");
    }
#endif
    MASTER_UNLOCK(sched_MutexPtr);
}


/*
a643 36
}


/*
 *----------------------------------------------------------------------------
 *
 * Sync_EventWait --
 *
 *	Make a process sleep waiting for an event.  This is an external
 *	version of the routine which is to be called without the sched_MutexPtr
 *	master lock held.
 *
 * Results:
 *	TRUE if woke up because of a signal, FALSE otherwise.
 *
 * Side effects:
 *	The sched_MutexPtr master lock is set, then the "internal" version
 * 	of the EventWait routine is called.
 *
 *----------------------------------------------------------------------------
 */

ENTRY Boolean
Sync_EventWait(event, wakeIfSignal)
    unsigned 	int 	event;		/* Event to wait on. */
    Boolean		wakeIfSignal;	/* TRUE => wait if signal. */
{
    Boolean	sigPending;

    MASTER_LOCK(sched_MutexPtr);
    sigPending = SyncEventWaitInt(event, wakeIfSignal);
#ifdef spur
    Mach_InstCountEnd(1);
#endif
    MASTER_UNLOCK(sched_MutexPtr);
    return(sigPending);
@


9.5
log
@Added include of vmMach.h (mendel checking for ken)
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 9.4 90/09/11 12:17:25 jhh Exp Locker: shirriff $ SPRITE (Berkeley)";
d21 11
a31 10
#include "./sync.h"
#include "sprite.h"
#include "mach.h"
#include "list.h"
#include "sync.h"
#include "syncInt.h"
#include "sched.h"
#include "proc.h"
#include "timer.h"
#include "rpc.h"
d67 1
a67 1
static INTERNAL void	ProcessWakeup();
@


9.4
log
@more prototyping stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 9.3 90/04/03 14:39:57 mgbaker Exp Locker: jhh $ SPRITE (Berkeley)";
a30 1
#include "vmMach.h"
@


9.3
log
@Deleted old debugging statements for sun4s.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 9.2 89/10/23 11:14:08 jhh Exp Locker: mgbaker $ SPRITE (Berkeley)";
d21 1
d136 1
a136 1
	Sync_StoreDbgInfo(lockPtr);
d230 1
a230 1
    Sync_StoreDbgInfo(lockPtr);
@


9.2
log
@Make several macros conform to naming convention
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 9.1 89/10/21 17:26:51 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
a361 8
#ifdef sun4
    Proc_ControlBlock	*curProcPtr;

    curProcPtr = Proc_GetCurrentProc();
    MACH_DEBUG_ADD(0x88888888);
    MACH_DEBUG_ADD(curProcPtr);
    MACH_DEBUG_ADD(mutexPtr);
#endif
a367 4
#ifdef sun4
    MACH_DEBUG_ADD(curProcPtr);
    MACH_DEBUG_ADD(mutexPtr);
#endif
a369 6
#ifdef sun4
    MACH_DEBUG_ADD(0x61616161);
    MACH_DEBUG_ADD(curProcPtr);
    MACH_DEBUG_ADD(mutexPtr);
    MACH_DEBUG_ADD(0x66666666);
#endif
a375 5
#ifdef sun4
    MACH_DEBUG_ADD(0x77777777);
    MACH_DEBUG_ADD(curProcPtr);
    MACH_DEBUG_ADD(mutexPtr);
#endif
a379 5
#ifdef sun4
    MACH_DEBUG_ADD(curProcPtr);
    MACH_DEBUG_ADD(mutexPtr);
    MACH_DEBUG_ADD(0x99999999);
#endif
@


9.1
log
@Lint fixes
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 8.12 89/08/29 15:11:05 jhh Exp $ SPRITE (Berkeley)";
d134 3
a136 3
	SyncRecordHit(lockPtr);
	SyncStoreDbgInfo(lockPtr);
	SyncAddPrior(lockPtr);
d218 1
a218 1
	SyncRecordMiss(lockPtr);
d228 3
a230 3
    SyncRecordHit(lockPtr);
    SyncStoreDbgInfo(lockPtr);
    SyncAddPrior(lockPtr);
@


9.0
log
@Changing version numbers.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 8.12 89/08/29 15:11:05 jhh Exp Locker: douglis $ SPRITE (Berkeley)";
d128 2
d132 1
a132 1
	Sync_SlowLock(lockPtr); 
d138 1
d165 1
d169 1
a169 1
	Sync_SlowBroadcast((int)lockPtr, &lockPtr->waiting);
d171 1
d289 1
a289 1
    Sync_GetLock(lockPtr);
d888 1
a888 1
	Sync_GetLock(lockPtr);
@


8.12
log
@uses new ready queue routines.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /c/src/kernel/sync.jhh/RCS/syncLock.c,v 8.11 89/08/17 17:31:52 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
@


8.11
log
@Added instruction counting for spur
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 8.10 89/08/01 20:43:56 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
d96 1
a96 1
    bzero((Address) &sync_Instrument, sizeof(sync_Instrument));
d521 1
a521 1
	    Sched_MoveInQueue(procPtr);
d601 1
a601 1
	Sched_MoveInQueue(procPtr);
d958 1
a958 1
	    Sched_MoveInQueue(procPtr);
@


8.10
log
@Rewrite of lock information gathering
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 8.9 89/07/23 16:59:00 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
d197 4
d214 3
d219 3
d226 6
d279 3
d319 5
d384 4
d441 3
a443 1

d551 5
d611 5
d730 3
d878 3
@


8.9
log
@Cleaned up implementation
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 8.6 89/02/28 12:27:08 jhh Exp $ SPRITE (Berkeley)";
d58 2
a59 1
Sync_Instrument sync_Instrument;
d96 4
a99 1
    bzero((Address) &sync_Instrument,sizeof(sync_Instrument));
d333 8
d347 4
d353 6
d361 5
d370 5
d447 1
d452 1
d454 1
a454 1
    sync_Instrument.numWakeupCalls++;
d486 1
a486 1
	sync_Instrument.numWakeups++;
@


8.8
log
@added lock registration
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 8.7 89/04/06 12:11:06 jhh Exp $ SPRITE (Berkeley)";
d107 2
d128 3
a130 8
#ifndef CLEAN_LOCK
	lockPtr->holderPC = Mach_GetPC(); 
	lockPtr->holderPCBPtr = Proc_GetCurrentProc();
	lockPtr->hit++;
	SyncAddPrior(lockPtr->type, &(lockPtr->priorCount), 
		     lockPtr->priorTypes,(Address) lockPtr, 
		     lockPtr->holderPCBPtr);
#endif
d142 2
a153 1

d159 1
a159 1
    SyncDeleteCurrent((Address) lockPtr,lockPtr->holderPCBPtr);
a164 1

d205 1
a205 3
#ifndef CLEAN_LOCK
	lockPtr->miss++;
#endif
d209 3
a211 7
#ifndef CLEAN_LOCK
    lockPtr->holderPC = Mach_GetPC(); 
    lockPtr->holderPCBPtr = Proc_GetCurrentProc();
    lockPtr->hit++;
    SyncAddPrior(lockPtr->type, &(lockPtr->priorCount), lockPtr->priorTypes, 
		 (Address) lockPtr, lockPtr->holderPCBPtr);
#endif
d256 1
a256 1
    SyncDeleteCurrent((Address) lockPtr,lockPtr->holderPCBPtr);
d378 1
a378 1
    SyncDeleteCurrent((Address) lockPtr, lockPtr->holderPCBPtr);
@


8.7
log
@changed LOCKREG ifdef to CLEAN_LOCK, call SyncDeleteCurrent instead of
SyncDeleteCurrentLock
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 8.6 89/02/28 12:27:08 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
a117 1
#ifndef spur
d122 1
a135 1
#endif
@


8.6
log
@Added additional compiler flags to control lock statistics
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 8.5 89/02/19 22:15:18 jhh Exp $ SPRITE (Berkeley)";
a106 2
 *	If LOCKREG is not defined then don't compile any of this, so that 
 *	the faster user version  is used.
d118 1
a118 2
#ifdef LOCKREG

d126 1
d133 1
d136 1
a137 1
#endif /* LOCKREG */
a145 2
 *	If LOCKREG is not defined then don't compile any of this, so that 
 *	the faster user version  is used.
a155 1
#ifdef LOCKREG
d162 1
a162 1
    SyncDeleteCurrentLock((Address) lockPtr,lockPtr->holderPCBPtr);
a167 1
#endif /* LOCKREG */
@


8.5
log
@Changes due to lock registration
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 8.4 89/01/06 11:29:07 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
d107 1
a107 1
 *	If CLEAN_LOCK is defined then don't compile any of this, so that 
d120 1
a120 1
#ifndef CLEAN_LOCK
d138 1
a138 1
#endif /* CLEAN_LOCK */
d147 1
a147 1
 *	If CLEAN_LOCK is defined then don't compile any of this, so that 
d159 1
a159 1
#ifndef CLEAN_LOCK
d172 1
a172 1
#endif /* CLEAN_LOCK */
d271 1
a271 3
#ifndef CLEAN_LOCK
    SyncDeleteCurrentLock((Address) lockPtr,lockPtr->holderPCBPtr);
#endif
d393 1
a393 3
#ifndef CLEAN_LOCK
    SyncDeleteCurrentLock((Address) lockPtr, lockPtr->holderPCBPtr);
#endif
@


8.4
log
@New Sync_Lock definition
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 8.3 89/01/05 15:47:07 mendel Exp $ SPRITE (Berkeley)";
d98 21
d120 20
d141 34
d214 1
a214 1
#ifndef CLEAN
d220 1
a220 1
#ifndef CLEAN
d222 1
a222 1
    lockPtr->holderPCBPtr = (char *) Proc_GetCurrentProc();
d224 2
d271 3
d395 3
@


8.3
log
@Check the inUse semaphore again after setting the waiting flag to stop
multiprocessor race condition.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 8.2 88/12/04 15:34:23 ouster Exp Locker: mendel $ SPRITE (Berkeley)";
d130 1
a130 1
 	 * Check the inUse semaphore again after setting the waiting. A zero 
d139 3
d145 5
a149 1

@


8.2
log
@Stop using obsolete header files.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 8.1 88/11/22 19:36:32 jhh Exp $ SPRITE (Berkeley)";
d129 9
@


8.1
log
@new semaphore definition
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 8.0 88/11/11 18:37:57 douglis Stable Locker: jhh $ SPRITE (Berkeley)";
a27 1
#include "byte.h"
@


8.0
log
@Changing version numbers.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 6.4 88/10/30 21:14:22 jhh Exp Locker: douglis $ SPRITE (Berkeley)";
d126 1
a126 1
    MASTER_LOCK(sched_Mutex);
d131 2
a132 2
	MASTER_UNLOCK(sched_Mutex);
	MASTER_LOCK(sched_Mutex);
d135 1
a135 1
    MASTER_UNLOCK(sched_Mutex);
d173 1
a173 1
    MASTER_LOCK(sched_Mutex);
d181 1
a181 1
    MASTER_UNLOCK(sched_Mutex);
d214 1
a214 1
    MASTER_LOCK(sched_Mutex);
d219 1
a219 1
    MASTER_UNLOCK(sched_Mutex);
d246 1
a246 1
    int 		*mutexPtr;	/* Mutex to release and reaquire. */
d251 1
a251 1
    MASTER_LOCK(sched_Mutex);
d256 1
a256 1
    MASTER_UNLOCK(*mutexPtr);
d260 1
a260 1
    MASTER_UNLOCK(sched_Mutex);
d264 1
a264 1
    MASTER_LOCK(*mutexPtr);
d294 1
a294 1
    MASTER_LOCK(sched_Mutex);
d303 1
a303 1
    MASTER_UNLOCK(sched_Mutex);
d337 1
a337 1
    if (!sched_Mutex) {
d406 1
a406 1
    MASTER_LOCK(sched_Mutex);
d408 1
a408 1
    MASTER_UNLOCK(sched_Mutex);
d426 1
a426 1
 *	the sched_Mutex. Ideally we would grab the mutex in the sig module
d448 1
a448 1
    MASTER_LOCK(sched_Mutex);
d463 1
a463 1
    MASTER_UNLOCK(sched_Mutex);
d489 1
a489 1
    MASTER_LOCK(sched_Mutex);
d501 1
a501 1
    MASTER_UNLOCK(sched_Mutex);
d555 1
a555 1
 *	version of the routine which is to be called without the sched_Mutex
d562 1
a562 1
 *	The sched_Mutex master lock is set, then the "internal" version
d575 1
a575 1
    MASTER_LOCK(sched_Mutex);
d577 1
a577 1
    MASTER_UNLOCK(sched_Mutex);
d608 1
a608 1
    MASTER_LOCK(sched_Mutex);
d616 1
a616 1
    MASTER_UNLOCK(sched_Mutex);
d642 1
a642 1
    MASTER_LOCK(sched_Mutex);
d646 1
a646 1
    MASTER_UNLOCK(sched_Mutex);
d684 1
a684 1
    MASTER_LOCK(sched_Mutex);
d722 1
a722 1
    MASTER_UNLOCK(sched_Mutex);
d756 1
a756 1
	MASTER_LOCK(sched_Mutex);
d758 1
a758 1
	MASTER_UNLOCK(sched_Mutex);
@


6.4
log
@multiprocessor port, change to new C lib
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/sync/RCS/syncLock.c,v 6.2 88/08/25 22:39:56 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
@


6.3
log
@Added a Sync_RemoveWaiter call to remove a process from any local or
remote wait list it may be on.
@
text
@d96 1
a96 1
    Byte_Zero(sizeof(sync_Instrument), (Address) &sync_Instrument);
d338 1
a338 1
	Sys_Panic(SYS_FATAL, "SyncEventWakeupInt: master lock not held.\n");
d357 1
a357 2
		Sys_Panic(SYS_FATAL,
			  "Can't handle waking up a migrating proc.\n");
d363 1
a363 2
		Sys_Panic(SYS_FATAL,
			  "Can't handle waking up a migrated proc.\n");
d366 1
a366 1
		Sys_Panic(SYS_FATAL, "%s %s",  
d420 14
d439 1
a439 1
 *	chain and makes it runnable.
d454 1
a454 2
    } else {
	if (procPtr->state == PROC_WAITING) {
d456 1
a456 1
		Sys_Panic(SYS_FATAL, "Sync_WakeWaitingProcess: Proc waiting but event and remote wait NIL\n");
d459 3
a461 1
	}
a492 2
	procPtr->state = PROC_READY;
	Sched_MoveInQueue(procPtr);
d496 1
a496 1
		Sys_Panic(SYS_FATAL, "Sync_RemoveWaiter: Proc waiting but event and remote wait NIL\n");
@


6.2
log
@
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: syncLock.c,v 6.1 88/08/24 14:48:43 douglis Exp $ SPRITE (Berkeley)";
d448 40
@


6.1
log
@got rid of some lint
@
text
@d18 2
a19 2
static char rcsid[] = "$Header: syncLock.c,v 6.0 88/08/11 12:27:04 brent Stable $ SPRITE (Berkeley)";
#endif not lint
@


6.0
log
@Changing version numbers.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: syncLock.c,v 5.8 88/06/27 14:20:59 ouster Exp $ SPRITE (Berkeley)";
d734 1
d810 2
d816 2
a817 2
    int 	clientID;	/* Sprite ID of client host. */
    int 	command;	/* Command identifier. */
d829 2
a830 1
    Rpc_Reply(srvToken, SUCCESS, storagePtr, NIL, NIL);
@


5.8
log
@Eliminate syncMonitor.h, merge with sync.h.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: syncLock.c,v 5.7 88/05/05 18:00:22 nelson Exp $ SPRITE (Berkeley)";
@


5.7
log
@Handles move of functionality from sys to mach.
@
text
@d6 1
a6 1
 *	in syncMonitor.c) to get and release monitor locks, and to wait on
d18 1
a18 1
static char rcsid[] = "$Header: syncLock.c,v 5.6 88/03/22 09:15:47 brent Exp $ SPRITE (Berkeley)";
@


5.6
log
@Protected ProcessWakeup against NIL proc table entries.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: syncLock.c,v 5.5 88/03/09 11:13:37 douglis Exp $ SPRITE (Berkeley)";
d22 1
d369 1
a369 1
			  "Sys_EventWakeupInt:",
d483 1
a483 1
    procPtr = Proc_GetCurrentProc(Sys_GetProcessorNumber());
d555 1
a555 1
    procPtr = Proc_GetCurrentProc(Sys_GetProcessorNumber());
d634 1
a634 1
    procPtr = Proc_GetCurrentProc(Sys_GetProcessorNumber());
@


5.5
log
@Changed declaration for ProcessWakeup to be INTERNAL instead of ENTRY.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: syncLock.c,v 5.4 88/03/08 16:16:08 nelson Exp $ SPRITE (Berkeley)";
d703 5
a707 3
    MASTER_LOCK(sched_Mutex);
    ProcessWakeup(procPtr, token);
    MASTER_UNLOCK(sched_Mutex);
d720 3
d736 2
a737 1
    int					waitToken;	/* Token to use. */
d739 2
a740 3
#ifdef notdef
    if (procPtr->waitToken == waitToken || waitToken == SYNC_BROADCAST_TOKEN) 
#endif notdef
d742 1
a742 1
	 * Token matches process's token.
d744 3
a746 16
	procPtr->syncFlags |= SYNC_WAIT_COMPLETE;
	if (procPtr->state == PROC_WAITING) {
	    if (procPtr->event == NIL) {
		/*
		 * Only wakeup if are doing this type of wait and not an
		 * event wait.
		 */
		procPtr->state = PROC_READY;
		Sched_MoveInQueue(procPtr);
	    }
	} else {
	    /*
	     * This is a notify message which has raced (and won) with the 
	     * process's call to Sync_ProcWait.
	     */
	    syncProcWakeupRaces++;
a747 1
#ifdef notdef
d750 2
a751 1
	 * Wakeup pertains to an old event.
d753 1
a754 1
#endif notdef
@


5.4
log
@Removed un-needed calls to VmMach_SetupContext
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: syncLock.c,v 5.3 87/12/16 13:03:51 nelson Exp $ SPRITE (Berkeley)";
d65 1
a65 1
static void	ProcessWakeup();
d728 1
a728 1
static ENTRY void
d731 1
a731 1
    int					waitToken;	/* Toekn to use. */
@


5.3
log
@Fixed bug in user level synchronization.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: syncLock.c,v 5.2 87/12/15 16:50:12 nelson Exp $ SPRITE (Berkeley)";
a130 1
	VmMach_SetupContext(Proc_GetCurrentProc(Sys_GetProcessorNumber()));
a180 1
    VmMach_SetupContext(Proc_GetCurrentProc(Sys_GetProcessorNumber()));
a259 1
    VmMach_SetupContext(Proc_GetCurrentProc(Sys_GetProcessorNumber()));
a302 1
    VmMach_SetupContext(Proc_GetCurrentProc(Sys_GetProcessorNumber()));
a525 1
    VmMach_SetupContext(Proc_GetCurrentProc(Sys_GetProcessorNumber()));
a670 1
    VmMach_SetupContext(procPtr);
@


5.2
log
@Fixed lint errors.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: syncLock.c,v 5.1 87/12/12 16:41:13 nelson Exp $ SPRITE (Berkeley)";
d130 3
a135 1
    VmMach_SetupContext(Proc_GetCurrentProc(Sys_GetProcessorNumber()));
@


5.1
log
@Moved call to set up the context out of the master lock so that it could
be monitored.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: syncLock.c,v 5.0 87/08/11 10:50:59 sprite Exp $ SPRITE (Berkeley)";
d30 1
@


5.0
log
@First Sprite native copy
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: syncLock.c,v 4.6 87/06/29 11:05:33 nelson Exp $ SPRITE (Berkeley)";
d132 1
d179 1
d259 1
d303 1
d527 1
d673 1
a673 1

@
