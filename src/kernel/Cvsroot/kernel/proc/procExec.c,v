head     9.35;
branch   ;
access   ;
symbols  ds3100:9.35 sun3:9.35 sun4nw:9.32 symm:9.32 spur:9.32 sprited:9.29.1 Summer89:9.0 newlib:8.0 Summer88:6.0 argString:5.9;
locks    ; strict;
comment  @ * @;


9.35
date     92.07.19.22.14.08;  author shirriff;  state Exp;
branches ;
next     9.34;

9.34
date     91.12.13.16.21.53;  author rab;  state Exp;
branches ;
next     9.33;

9.33
date     91.11.15.21.04.15;  author kupfer;  state Exp;
branches ;
next     9.32;

9.32
date     91.09.24.21.27.30;  author shirriff;  state Exp;
branches ;
next     9.31;

9.31
date     91.08.27.18.28.45;  author mottsmth;  state Exp;
branches ;
next     9.30;

9.30
date     91.08.24.19.55.31;  author mottsmth;  state Exp;
branches ;
next     9.29;

9.29
date     91.07.26.16.59.33;  author shirriff;  state Exp;
branches 9.29.1.1;
next     9.28;

9.28
date     91.03.29.17.58.24;  author shirriff;  state Exp;
branches ;
next     9.27;

9.27
date     91.03.29.16.30.54;  author kupfer;  state Exp;
branches ;
next     9.26;

9.26
date     91.03.29.14.38.13;  author shirriff;  state Exp;
branches ;
next     9.25;

9.25
date     91.03.20.20.30.58;  author kupfer;  state Exp;
branches ;
next     9.24;

9.24
date     91.03.19.15.44.02;  author shirriff;  state Exp;
branches ;
next     9.23;

9.23
date     90.12.07.23.44.46;  author rab;  state Exp;
branches ;
next     9.22;

9.22
date     90.11.12.21.44.43;  author shirriff;  state Exp;
branches ;
next     9.21;

9.21
date     90.10.09.11.53.03;  author jhh;  state Exp;
branches ;
next     9.20;

9.20
date     90.10.08.16.02.30;  author shirriff;  state Exp;
branches ;
next     9.19;

9.19
date     90.09.20.16.24.49;  author mgbaker;  state Exp;
branches ;
next     9.18;

9.18
date     90.09.12.13.58.03;  author jhh;  state Exp;
branches ;
next     9.17;

9.17
date     90.09.06.17.57.00;  author jhh;  state Exp;
branches ;
next     9.16;

9.16
date     90.07.29.15.48.08;  author shirriff;  state Exp;
branches ;
next     9.15;

9.15
date     90.06.27.12.43.57;  author douglis;  state Exp;
branches ;
next     9.14;

9.14
date     90.06.14.10.42.17;  author douglis;  state Exp;
branches ;
next     9.13;

9.13
date     90.05.01.12.33.52;  author shirriff;  state Exp;
branches ;
next     9.12;

9.12
date     90.03.30.15.16.18;  author shirriff;  state Exp;
branches ;
next     9.11;

9.11
date     90.03.26.11.51.45;  author shirriff;  state Exp;
branches ;
next     9.10;

9.10
date     90.03.16.14.20.43;  author shirriff;  state Exp;
branches ;
next     9.9;

9.9
date     90.03.14.13.55.23;  author rab;  state Exp;
branches ;
next     9.8;

9.8
date     90.02.11.21.21.12;  author shirriff;  state Exp;
branches ;
next     9.7;

9.7
date     90.02.07.23.04.44;  author shirriff;  state Exp;
branches ;
next     9.6;

9.6
date     90.01.29.18.07.15;  author douglis;  state Exp;
branches ;
next     9.5;

9.5
date     89.11.27.09.50.39;  author douglis;  state Exp;
branches ;
next     9.4;

9.4
date     89.10.26.15.22.31;  author douglis;  state Exp;
branches ;
next     9.3;

9.3
date     89.10.23.10.30.42;  author douglis;  state Exp;
branches ;
next     9.2;

9.2
date     89.10.23.08.38.14;  author brent;  state Exp;
branches ;
next     9.1;

9.1
date     89.09.20.16.16.55;  author mgbaker;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.15.00;  author douglis;  state Stable;
branches ;
next     8.17;

8.17
date     89.08.30.12.56.54;  author mgbaker;  state Exp;
branches ;
next     8.16;

8.16
date     89.08.10.17.15.57;  author douglis;  state Exp;
branches ;
next     8.15;

8.15
date     89.07.20.11.19.23;  author douglis;  state Exp;
branches ;
next     8.14;

8.14
date     89.07.20.11.04.09;  author douglis;  state Exp;
branches ;
next     8.13;

8.13
date     89.07.10.19.11.21;  author nelson;  state Exp;
branches ;
next     8.12;

8.12
date     89.06.22.17.18.36;  author douglis;  state Exp;
branches ;
next     8.11;

8.11
date     89.06.17.15.04.15;  author mendel;  state Exp;
branches ;
next     8.10;

8.10
date     89.06.09.17.49.50;  author douglis;  state Exp;
branches ;
next     8.9;

8.9
date     89.06.07.12.56.57;  author douglis;  state Exp;
branches ;
next     8.8;

8.8
date     89.05.25.15.27.14;  author douglis;  state Exp;
branches ;
next     8.7;

8.7
date     89.05.21.18.27.08;  author mgbaker;  state Exp;
branches ;
next     8.6;

8.6
date     89.03.26.20.17.02;  author mgbaker;  state Exp;
branches ;
next     8.5;

8.5
date     89.03.22.14.08.02;  author mgbaker;  state Exp;
branches ;
next     8.4;

8.4
date     89.03.02.18.41.46;  author douglis;  state Exp;
branches ;
next     8.3;

8.3
date     89.02.19.22.07.06;  author jhh;  state Exp;
branches ;
next     8.2;

8.2
date     88.12.04.15.17.11;  author ouster;  state Exp;
branches ;
next     8.1;

8.1
date     88.11.22.19.32.28;  author jhh;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.29.43;  author douglis;  state Stable;
branches ;
next     6.10;

6.10
date     88.11.10.17.05.58;  author douglis;  state Exp;
branches ;
next     6.9;

6.9
date     88.11.08.15.58.37;  author brent;  state Exp;
branches ;
next     6.8;

6.8
date     88.11.01.16.36.41;  author douglis;  state Exp;
branches ;
next     6.7;

6.7
date     88.10.28.19.01.22;  author mlgray;  state Exp;
branches ;
next     6.6;

6.6
date     88.10.27.20.02.22;  author mlgray;  state Exp;
branches ;
next     6.5;

6.5
date     88.10.18.12.18.42;  author mlgray;  state Exp;
branches ;
next     6.4;

6.4
date     88.09.08.09.14.44;  author brent;  state Exp;
branches ;
next     6.3;

6.3
date     88.08.31.17.55.12;  author douglis;  state Exp;
branches ;
next     6.2;

6.2
date     88.08.24.14.18.10;  author douglis;  state Exp;
branches ;
next     6.1;

6.1
date     88.08.23.17.06.32;  author brent;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.22.07;  author brent;  state Stable;
branches ;
next     5.17;

5.17
date     88.08.04.15.29.15;  author douglis;  state Exp;
branches ;
next     5.16;

5.16
date     88.07.25.17.02.40;  author nelson;  state Exp;
branches ;
next     5.15;

5.15
date     88.06.28.17.35.41;  author nelson;  state Exp;
branches ;
next     5.14;

5.14
date     88.05.05.17.57.30;  author nelson;  state Exp;
branches ;
next     5.13;

5.13
date     88.05.04.16.45.35;  author nelson;  state Exp;
branches ;
next     5.12;

5.12
date     88.04.18.09.07.41;  author ouster;  state Exp;
branches ;
next     5.11;

5.11
date     88.04.12.15.51.57;  author douglis;  state Exp;
branches ;
next     5.10;

5.10
date     88.03.08.14.13.33;  author douglis;  state Exp;
branches ;
next     5.9;

5.9
date     88.03.02.11.54.50;  author douglis;  state Exp;
branches ;
next     5.8;

5.8
date     88.02.29.11.19.00;  author nelson;  state Exp;
branches ;
next     5.7;

5.7
date     88.02.24.12.29.21;  author brent;  state Exp;
branches ;
next     5.6;

5.6
date     88.01.22.15.31.27;  author nelson;  state Exp;
branches ;
next     5.5;

5.5
date     87.12.24.16.28.11;  author douglis;  state Exp;
branches ;
next     5.4;

5.4
date     87.12.12.16.39.15;  author nelson;  state Exp;
branches ;
next     5.3;

5.3
date     87.10.22.14.57.38;  author nelson;  state Exp;
branches ;
next     5.2;

5.2
date     87.10.14.13.45.16;  author brent;  state Exp;
branches ;
next     5.1;

5.1
date     87.09.24.14.54.36;  author brent;  state Exp;
branches ;
next     5.0;

5.0
date     87.08.11.10.46.56;  author sprite;  state Exp;
branches ;
next     ;

9.29.1.1
date     91.08.15.21.15.15;  author kupfer;  state Exp;
branches ;
next     ;


desc
@@


9.35
log
@Added check to see if user is trying to run a random data file, so it
doesn't get passed to the shell.
@
text
@/* procExec.c --
 *
 *	Routines to exec a program.  There is no monitor required in this
 *	file.  Access to the proc table is synchronized by locking the PCB
 *	when modifying the genFlags field.
 *
 * Copyright (C) 1985, 1988 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/proc/procExec.c,v 9.34 91/12/13 16:21:53 rab Exp Locker: shirriff $ SPRITE (Berkeley)";
#endif /* not lint */

#include <sprite.h>
#include <procMach.h>
#include <mach.h>
#include <proc.h>
#include <procInt.h>
#include <sync.h>
#include <sched.h>
#include <fs.h>
#include <fsio.h>
#include <stdlib.h>
#include <sig.h>
#include <spriteTime.h>
#include <list.h>
#include <vm.h>
#include <sys.h>
#include <procMigrate.h>
#include <procUnixStubs.h>
#include <status.h>
#include <string.h>
#include <byte.h>
#include <rpc.h>
#include <prof.h>
#include <fsutil.h>
#include <ctype.h>
#include <stdio.h>
#include <bstring.h>
#include <vmMach.h>
#include <file.h>
/*
 * This will go away when libc is changed.
 */
#ifndef PROC_MAX_ENVIRON_LENGTH
#define PROC_MAX_ENVIRON_LENGTH (PROC_MAX_ENVIRON_NAME_LENGTH + \
				 PROC_MAX_ENVIRON_VALUE_LENGTH)
#endif /*  PROC_MAX_ENVIRON_LENGTH */

/* 
 * Maximum number of argument to an interpreter: script name, interpreter 
 * flags, script name (again), and nil pointer to end the array.
 */
#define MAX_INTERP_ARGS		4

#define UNIX_CODE 1

typedef struct {
    List_Links	links;
    Address	stringPtr;
    int		stringLen;
} ArgListElement;

extern int debugProcStubs;

/*
 * Define the information needed to perform an exec: the user's stack,
 * where to put it, and whether to debug on startup.  We define a structure
 * containing the "meta-info" that isn't actually copied onto the user's
 * stack, and then another structure that also includes argc.  (By
 * separating the header into a separate structure, it's easier to take its
 * size.)
 * 
 * Note that the actual values for argv and envp passed to main() are
 * calculated by _start() based on the address of argc and are not actually
 * put on the stack given to the exec'ed process.  The size of the structure
 * to be copied onto the user's stack is the size in the 'size' field
 * minus the size of the header.
 *
 * The fileName and argString fields are used only when doing a remote exec.
 */
typedef struct {
    Address base;		/* base of the structure in user space */
    int size;			/* size of the entire structure */
    char *fileName;		/* pointer to buffer containing name of file
				 * to exec */
    int fileNameLength;		/* length of file name buffer */
    char *argString;		/* pointer to buffer containing full list of
				 * arguments, for ps listing */
    int argLength;		/* length of argString buffer */
} ExecEncapHeader;

typedef struct {
    ExecEncapHeader hdr;	/* meta-information; see above */
    /*
     * User stack data starts here.
     */
    int argc;			/* Number of arguments */
    /*
     * argv[] goes here
     * envp[] goes here
     * *argv[] goes here
     * *envp[] goes here
     */
} ExecEncapState;

/*
 * Define a structure to hold all the information about arguments
 * and environment variables (pointer and length).  This makes it easier
 * to pass a NIL pointer for the whole thing, and to keep them in one
 * place.  The number of arguments/environment pointers includes the 
 * null pointer at the end of the array.
 */

typedef struct {
    Boolean	userMode;	/* TRUE if the arguments are in user space */
    char	**argPtrArray;	/* The array of argument pointers. */
    int		numArgs;	/* The number of arguments in the argArray. */
    int		argLength;	/* actual size of argArray */
    char	**envPtrArray;	/* The array of environment pointers. */
    int		numEnvs;	/* The number of arguments in the envArray. */
    int		envLength;	/* actual size of envArray */
} UserArgs;

/*
 * Forward declarations.
 */
static ReturnStatus 	DoExec _ARGS_((char fileName[], 
			    UserArgs *userArgsPtr, 
			    ExecEncapState **encapPtrPtr, Boolean debugMe));
static ReturnStatus 	SetupInterpret _ARGS_((char *buffer, 
			    int sizeRead, Fs_Stream **filePtrPtr, 
			    char **interpNamePtr, char **interpFlagsPtr, 
			    ProcObjInfo *objInfoPtr));
static ReturnStatus 	SetupArgs _ARGS_((UserArgs *userArgsPtr, 
			    char **extraArgArray, Address *argStackPtr, 
			    char **argStringPtr));
static ReturnStatus 	GrabArgArray _ARGS_((int maxLength, Boolean userProc, 
			    char **extraArgArray, char **argPtrArray, 
			    int *numArgsPtr, List_Links *argList, 
			    int *realLengthPtr, int *paddedLengthPtr));
static Boolean 		SetupVM _ARGS_((register Proc_ControlBlock *procPtr, 
			    register ProcObjInfo *objInfoPtr, 
			    Fs_Stream *codeFilePtr, Boolean usedFile, 
			    Vm_Segment **codeSegPtrPtr, 
			    register Vm_ExecInfo *execInfoPtr));
static Boolean		ZeroHeapEnd _ARGS_ ((Vm_ExecInfo *execInfoPtr));

#ifdef notdef
/*
 * Define a type to include the information that is passed from
 * the local setup routine to the routine that performs the actual
 * exec.
 */
typedef struct {
    Proc_AOUT				*aoutPtr;
    Vm_ExecInfo				*execInfoPtr;
    Proc_AOUT				aout;
    Vm_Segment				*codeSegPtr = (Vm_Segment *) NIL;
    char				*argString = (char *) NIL;
    Address				argBuffer = (Address) NIL;
    Fs_Stream				*filePtr;
    int					entry;
    Boolean				usedFile;
    int					uid;
    int					gid;
    ExecEncapState			*hdrPtr;
}
#endif    

/*
 * Define entry points for exec.  They are distinct due to compatibility
 * considerations.  We can deal with them better when we convert the
 * system calls to be more unix-like.
 */

/*
 *----------------------------------------------------------------------
 *
 * Proc_RemoteExec --
 *
 *	Process the Exec system call on a remote host.
 *	This does the same setup as Proc_Exec, and then initiates a migration
 *	with the stack of the new process contained in a buffer reachable
 *	from the process control block.
 *
 * Results:
 *	SUCCESS indicates that the process has been signalled to cause it
 *	to migrate before it exits the kernel.  Any other status is
 *	an error that should be returned to the process as usual.
 *
 * Side effects:
 *	Memory is allocated for the buffer containing the exec info.
 *	This should be freed by the migration encapsulation routine.
 *
 *----------------------------------------------------------------------
 */

int
Proc_RemoteExec(fileName, argPtrArray, envPtrArray, host)
    char	*fileName;	/* The name of the file to exec. */
    char	**argPtrArray;	/* The array of arguments to the exec'd 
				 * program. */
    char	**envPtrArray;	/* The array of environment variables for
				 * the exec'd program. */
    int		host;		/* ID of host on which to exec. */
{
    int status;
    
    /*
     * XXX need to check permission to migrate.
     */

    status = Proc_Exec(fileName, argPtrArray, envPtrArray, FALSE, host);
    /*
     * XXX on failure, need to clean up.
     */
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * Proc_ExecEnv --
 *
 *	Here for backward compatibility.  It does an exec on the
 *	local host.
 *
 * Results:
 *	This process will not return unless an error occurs in which case it
 *	returns the error.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Proc_ExecEnv(fileName, argPtrArray, envPtrArray, debugMe)
    char	*fileName;	/* The name of the file to exec. */
    char	**argPtrArray;	/* The array of arguments to the exec'd 
				 * program. */
    char	**envPtrArray;	/* The array of environment variables
				 * of the form NAME=VALUE. */ 
    Boolean	debugMe;	/* TRUE means that the process is 
				 * to be sent a SIG_DEBUG signal before
    				 * executing its first instruction. */
{
    return(Proc_Exec(fileName, argPtrArray, envPtrArray, debugMe, 0));
}


/*
 *----------------------------------------------------------------------
 *
 * Proc_Exec --
 *
 *	The ultimate entry point for the Exec system call.  This
 * 	handles both local and remote exec's.  It calls SetupExec to
 * 	initialize the file pointer, a.out info, user's stack image, etc.
 *	The a.out information is used if the exec is
 * 	performed on this machine, but for a remote exec, the file
 *	is reopened in case of different machine types.  The stack is
 * 	used locally or copied to the remote host.
 *
 * Results:
 *	For local exec's, this procedure will not return unless an error
 *	occurs, in which case it returns the error.  For remote exec's,
 *	SUCCESS is returned, and the calling routine arranges for
 *	the process to hit a migration signal before continuing.
 *
 * Side effects:
 *	The argument & environment arrays are made accessible.  Memory
 *	is allocated for the file name.  
 *	The DoExec routine makes the arrays unaccessible.  It frees the
 *	space for the file name, unless the name is used for a remote
 *	exec, in which case it is left around until after migration.
 *
 *----------------------------------------------------------------------
 */

int
Proc_Exec(fileName, argPtrArray, envPtrArray, debugMe, host)
    char	*fileName;	/* The name of the file to exec. */
    char	**argPtrArray;	/* The array of arguments to the exec'd 
				 * program. */
    char	**envPtrArray;	/* The array of environment variables
				 * of the form NAME=VALUE. */ 
    Boolean	debugMe;	/* TRUE means that the process is 
				 * to be sent a SIG_DEBUG signal before
    				 * executing its first instruction. */
    int		host;		/* Host to which to do remote exec, or 0
				 * for local host. */
{
    char		**newArgPtrArray;
    int			newArgPtrArrayLength;
    char		**newEnvPtrArray;
    int			newEnvPtrArrayLength;
    UserArgs		userArgs;
    int			strLength;
    int			accessLength;
    ReturnStatus	status;
    char 		*execFileName;
    ExecEncapState	*encapPtr;
    ExecEncapState	**encapPtrPtr;
    Proc_ControlBlock 	*procPtr;
    


    /*
     * Make the file name accessible. 
     */

    status = Proc_MakeStringAccessible(FS_MAX_PATH_NAME_LENGTH, &fileName,
				       &accessLength, &strLength);
    if (status != SUCCESS) {
	return(status);
    }

    execFileName = malloc(accessLength);
    (void) strncpy(execFileName, fileName, accessLength);
    Proc_MakeUnaccessible((Address) fileName, accessLength);

    /*
     * Make the arguments array accessible.
     */

    if (argPtrArray != (char **) USER_NIL) {
	Vm_MakeAccessible(VM_READONLY_ACCESS,
			  (PROC_MAX_EXEC_ARGS + 1) * sizeof(Address),
			  (Address) argPtrArray, 
		          &newArgPtrArrayLength, (Address *) &newArgPtrArray);
	if (newArgPtrArrayLength == 0) {
	    return(SYS_ARG_NOACCESS);
	}
    } else {
	newArgPtrArray = (char **) NIL;
	newArgPtrArrayLength = 0;
    }

    /*
     * Make the environments array accessible.
     */

    if (envPtrArray != (char **) USER_NIL) {
	Vm_MakeAccessible(VM_READONLY_ACCESS,
			  (PROC_MAX_ENVIRON_SIZE + 1) * sizeof(Address),
			  (Address) envPtrArray, 
		          &newEnvPtrArrayLength, (Address *) &newEnvPtrArray);
	if (newEnvPtrArrayLength == 0) {
	    return(SYS_ARG_NOACCESS);
	}
    } else {
	newEnvPtrArray = (char **) NIL;
	newEnvPtrArrayLength = 0;
    }
    /*
     * Perform the exec, if local, or setup the user's stack if remote.
     */
    userArgs.userMode = TRUE;
    userArgs.argPtrArray = newArgPtrArray;
    userArgs.numArgs = newArgPtrArrayLength / sizeof(Address);
    userArgs.argLength = newArgPtrArrayLength;
    userArgs.envPtrArray = newEnvPtrArray;
    userArgs.numEnvs = newEnvPtrArrayLength / sizeof(Address);
    userArgs.envLength = newEnvPtrArrayLength;

    /*
     * Check for explicit remote exec onto this host, in which case it's
     * a local exec.
     */
    if (host == rpc_SpriteID) {
	host = 0;
    }

    if (host != 0) {
	encapPtrPtr = &encapPtr;
    } else {
	encapPtrPtr = (ExecEncapState **) NIL;
    }
    status = DoExec(execFileName, &userArgs, encapPtrPtr, debugMe);
    if (status == SUCCESS) {
	if (host != 0) {
	    /*
	     * Set up the process to migrate.
	     */
	    procPtr = Proc_GetCurrentProc();
	    Proc_Lock(procPtr);
	    status = ProcInitiateMigration(procPtr, host);
	    if (status == SUCCESS) {
		procPtr->remoteExecBuffer = (Address) encapPtr;
		Proc_FlagMigration(procPtr, host, TRUE);
	    } else {
		free((Address) encapPtr);
	    }
	    Proc_Unlock(procPtr);
	} else {
	    panic("Proc_Exec: DoExec returned SUCCESS!!!\n");
	}
    }
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * Proc_KernExec --
 *
 *	Do an exec from a kernel process.  This will exec the program and
 *	change the type of process to a user process.
 *
 * Results:
 *	This routine does not return unless an error occurs from DoExec.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

/* 
 * Use the old Proc_KernExec until this gets installed as the sole procExec.c.
 */
int
Proc_KernExec(fileName, argPtrArray)
    char *fileName;
    char **argPtrArray;
{
    register	Proc_ControlBlock	*procPtr;
    ReturnStatus			status;
    UserArgs				userArgs;

    procPtr = Proc_GetCurrentProc();

    /*
     * Set up dummy segments so that DoExec can work properly.
     */

    procPtr->vmPtr->segPtrArray[VM_CODE] = 
				Vm_SegmentNew(VM_CODE, (Fs_Stream *) NIL, 0,
					          1, 0, procPtr);
    if (procPtr->vmPtr->segPtrArray[VM_CODE] == (Vm_Segment *) NIL) {
	return(PROC_NO_SEGMENTS);
    }

    procPtr->vmPtr->segPtrArray[VM_HEAP] =
		    Vm_SegmentNew(VM_HEAP, (Fs_Stream *) NIL, 0, 1, 1, procPtr);
    if (procPtr->vmPtr->segPtrArray[VM_HEAP] == (Vm_Segment *) NIL) {
	Vm_SegmentDelete(procPtr->vmPtr->segPtrArray[VM_CODE], procPtr);
	return(PROC_NO_SEGMENTS);
    }

    procPtr->vmPtr->segPtrArray[VM_STACK] =
		    Vm_SegmentNew(VM_STACK, (Fs_Stream *) NIL, 
				   0 , 1, mach_LastUserStackPage, procPtr);
    if (procPtr->vmPtr->segPtrArray[VM_STACK] == (Vm_Segment *) NIL) {
	Vm_SegmentDelete(procPtr->vmPtr->segPtrArray[VM_CODE], procPtr);
	Vm_SegmentDelete(procPtr->vmPtr->segPtrArray[VM_HEAP], procPtr);
	return(PROC_NO_SEGMENTS);
    }

    /*
     * Change this process to a user process.
     */

    Proc_Lock(procPtr);
    procPtr->genFlags &= ~PROC_KERNEL;
    procPtr->genFlags |= PROC_USER;
    Proc_Unlock(procPtr);

    VmMach_ReinitContext(procPtr);

    userArgs.userMode = FALSE;
    userArgs.argPtrArray = argPtrArray;
    userArgs.numArgs = PROC_MAX_EXEC_ARGS;
    userArgs.argLength = PROC_MAX_EXEC_ARGS * sizeof(Address);
    userArgs.envPtrArray = (char **) NIL;
    userArgs.numEnvs = 0;
    userArgs.envLength = 0;
    status = DoExec(fileName, &userArgs, (ExecEncapState **) NIL, FALSE);
    /*
     * If the exec failed, then delete the extra segments and fix up the
     * proc table entry to put us back into kernel mode.
     */

    Proc_Lock(procPtr);
    procPtr->genFlags &= ~PROC_USER;
    procPtr->genFlags |= PROC_KERNEL;
    Proc_Unlock(procPtr);

    VmMach_ReinitContext(procPtr);

    Vm_SegmentDelete(procPtr->vmPtr->segPtrArray[VM_CODE], procPtr);
    Vm_SegmentDelete(procPtr->vmPtr->segPtrArray[VM_HEAP], procPtr);
    Vm_SegmentDelete(procPtr->vmPtr->segPtrArray[VM_STACK], procPtr);

    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * SetupArgs --
 *
 *	Chase through arrays of character strings (usually in user space)
 *	and copy them into a contiguous array.  This array is later copied
 *	onto the stack of the exec'd program, and it may be used to
 *	pass the arguments to another host for a remote exec.  It
 *	contains argc, argv, envp, and the strings referenced by argv and
 *	envp.  All values in argv and envp are relative to the presumed
 *	start of the data in user space, which is normally set up to end at
 *	mach_MaxUserStackAddr.  If
 *	the exec is performed on a different machine, the pointers in argv and
 *	envp must be adjusted by the relative values of mach_MaxUserStackAddr.
 *
 *	The format of the structure is defined by ExecEncapState above.
 *		
 *
 * Results:
 *	A ReturnStatus is returned.  Any non-SUCCESS result indicates a failure
 *	that should be returned to the user.
 *	In addition, a pointer to the encapsulated stack is returned,
 *	as well as its size.
 *
 * Side effects:
 *	Memory is allocated for the argument stack.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
SetupArgs(userArgsPtr, extraArgArray, argStackPtr, argStringPtr)
    UserArgs *userArgsPtr;	/* Information for taking args
				 * and environment. */ 
    char     **extraArgArray;	/* Any arguments that should be
	     		 	 * inserted prior to argv[1] */
    Address  *argStackPtr; 	/* Pointer to contain address of encapsulated
				 * stack. */
    char     **argStringPtr;	/* Pointer to allocated buffer for argument
				 * list as a single string (for ps) */
{
    int	     numArgs;		/* The number of arguments in the argArray. */
    int	     numEnvs;		/* The number of arguments in the envArray. */
    register	ArgListElement		*argListPtr;
    register	int			argNumber;
    char				**newArgPtrArray;
    char				**newEnvPtrArray;
    List_Links				argList;
    List_Links				envList;
    char				*argBuffer;
    char				*envBuffer;
    register	char			*argString;
    int					argStringLength;
    ReturnStatus			status;
    int					usp;
    int					paddedArgLength;
    int					paddedEnvLength;
    int					bufSize;
    Address				buffer;
    int					stackSize;
    ExecEncapHeader			*hdrPtr;
    ExecEncapState			*encapPtr;

    /*
     * Initialize variables so when if we abort we know what to clean up.
     */
    *argStringPtr = (char *) NIL;
    
    List_Init(&argList);
    List_Init(&envList);

    /*
     * Copy in the arguments.  argStringLength is an upper bound on
     * the total length permitted.
     */
    numArgs = userArgsPtr->numArgs;
    argStringLength = PROC_MAX_EXEC_ARG_LENGTH;
    status = GrabArgArray(PROC_MAX_EXEC_ARG_LENGTH + 1,
			  userArgsPtr->userMode, extraArgArray,
			  userArgsPtr->argPtrArray, &numArgs,
			  &argList, &argStringLength,
			  &paddedArgLength);


    if (status != SUCCESS) {
	goto execError;
    }
    /*
     * Copy in the environment.
     */

    numEnvs = userArgsPtr->numEnvs;
    status = GrabArgArray(PROC_MAX_ENVIRON_LENGTH + 1,
			  userArgsPtr->userMode, (char **) NIL,
			  userArgsPtr->envPtrArray, &numEnvs,
			  &envList, (int *) NIL,
			  &paddedEnvLength);

    if (status != SUCCESS) {
	goto execError;
    }

    /*
     * Now copy all of the arguments and environment variables into a buffer.
     * Allocate the buffer and initialize pointers into it.
     * The stack ends up in the following state:  the top word is argc.
     * Right below this is the array of pointers to arguments (argv).  Right
     * below this is the array of pointers to environment stuff (envp).  So,
     * to figure out the address of argv, one simply adds a word to the address
     * of the top of the stack.  To figure out the address of envp, one
     * looks at argc and skips over the appropriate amount of space to jump
     * over argc and argv = (1 + (argc + 1)) * 4 bytes.  The extra "1" is for
     * the null argument at the end of argv.  Below all that stuff on the
     * stack come the environment and argument strings themselves.
     */
    bufSize = sizeof(ExecEncapState) + (numArgs + numEnvs + 2) * sizeof(Address)
	+ paddedArgLength + paddedEnvLength;
    buffer = malloc(bufSize);
    *argStackPtr = buffer;
    encapPtr = (ExecEncapState *) buffer;
    hdrPtr = &encapPtr->hdr;
    hdrPtr->size = bufSize;
    stackSize = Byte_AlignAddr((bufSize - sizeof(ExecEncapHeader)));
    hdrPtr->base = mach_MaxUserStackAddr - stackSize;
    encapPtr->argc = numArgs;
    newArgPtrArray = (char **) (buffer + sizeof(ExecEncapState));
    newEnvPtrArray = (char **) ((int) newArgPtrArray +
				(numArgs + 1) * sizeof(Address));
    argBuffer = (Address) ((int) newEnvPtrArray +
			   (numEnvs + 1) * sizeof(Address));
    envBuffer =  (argBuffer + paddedArgLength);
				
    argNumber = 0;
    usp = (int)hdrPtr->base + (int) argBuffer - (int) &encapPtr->argc;
    argString = malloc(argStringLength + 1);
    *argStringPtr = argString;

    while (!List_IsEmpty(&argList)) {
	argListPtr = (ArgListElement *) List_First(&argList);
	/*
	 * Copy the argument.
	 */
	bcopy((Address) argListPtr->stringPtr, (Address) argBuffer,
		    argListPtr->stringLen);
	newArgPtrArray[argNumber] = (char *) usp;
	argBuffer += Byte_AlignAddr(argListPtr->stringLen);
	usp += Byte_AlignAddr(argListPtr->stringLen);
	bcopy((Address) argListPtr->stringPtr, argString,
		    argListPtr->stringLen - 1);
	argString[argListPtr->stringLen - 1] = ' ';
	argString += argListPtr->stringLen;
	/*
	 * Clean up
	 */
	List_Remove((List_Links *) argListPtr);
	free((Address) argListPtr->stringPtr);
	free((Address) argListPtr);
	argNumber++;
    }
    argString[0] = '\0';
    newArgPtrArray[argNumber] = (char *) USER_NIL;
    
    argNumber = 0;
    while (!List_IsEmpty(&envList)) {
	argListPtr = (ArgListElement *) List_First(&envList);
	/*
	 * Copy the environment variable.
	 */
	bcopy((Address) argListPtr->stringPtr, (Address) envBuffer,
		    argListPtr->stringLen);
	newEnvPtrArray[argNumber] = (char *) usp;
	envBuffer += Byte_AlignAddr(argListPtr->stringLen);
	usp += Byte_AlignAddr(argListPtr->stringLen);
	/*
	 * Clean up
	 */
	List_Remove((List_Links *) argListPtr);
	free((Address) argListPtr->stringPtr);
	free((Address) argListPtr);
	argNumber++;
    }
    newEnvPtrArray[argNumber] = (char *) USER_NIL;

    /*
     * We're done here.  Leave it to the caller to free the copy of the
     * stack after copying it to user space.
     */
    return(SUCCESS);
    
execError:
    /*
     * The exec failed while copying in the arguments.  Free any
     * arguments or environment variables that were copied in.
     */
    while (!List_IsEmpty(&argList)) {
	argListPtr = (ArgListElement *) List_First(&argList);
	List_Remove((List_Links *) argListPtr);
	free((Address) argListPtr->stringPtr);
	free((Address) argListPtr);
    }
    while (!List_IsEmpty(&envList)) {
	argListPtr = (ArgListElement *) List_First(&envList);
	List_Remove((List_Links *) argListPtr);
	free((Address) argListPtr->stringPtr);
	free((Address) argListPtr);
    }
    return(status);

}


/*
 *----------------------------------------------------------------------
 *
 * GrabArgArray --
 *
 *	Copy a an array of strings from user space and put it in a
 *	linked list of strings.  The terminology for "args" refers
 *	to argv, but the same routine is used for environment variables
 *	as well.
 *
 * Results:
 *	A ReturnStatus indicates any sort of error, indicating immediate
 *	failure that should be reported to the user.  Otherwise, the
 *	arguments and their lengths are returned in the linked list
 *	referred to by argListPtr, and the total length is returned
 *	in *totalLengthPtr.
 *
 * Side effects:
 *	Memory is allocated to hold the strings and the structures
 *	pointing to them.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
GrabArgArray(maxLength, userProc, extraArgArray, argPtrArray, numArgsPtr,
	     argList, realLengthPtr, paddedLengthPtr)
    int	     maxLength;		/* The maximum length of one argument */
    Boolean  userProc;		/* Set if the calling process is a user 
	     			 * process. */
    char     **extraArgArray;	/* Any arguments that should be
	     		 	 * inserted prior to argv[1] */
    char     **argPtrArray;	/* The array of argument pointers. */
    int	     *numArgsPtr;	/* Pointer to the number of arguments in the
				 * argArray. This is updated with the
				 * actual number of arguments. */
    List_Links *argList;	/* Pointer to header of list containing
				 * copied data. Assumed to be initialized by
				 * caller. */
    int      *realLengthPtr; 	/* Pointer to contain combined size, without
				 * padding.   Value passed in contains
				 * maximum. */
    int      *paddedLengthPtr; 	/* Pointer to contain combined size, including
				 * padding. */
{
    int 				totalLength = 0;
    int 				paddedTotalLength = 0;
    int 				extraArgs;
    Boolean 				accessible;
    register	ArgListElement		*argListPtr;
    register	char			**argPtr;
    register	int			argNumber;
    ReturnStatus			status;
    char				*stringPtr;
    int					stringLength;
    int					realLength;
    
    if (extraArgArray != (char **) NIL) {
	for (extraArgs = 0; extraArgArray[extraArgs] != (char *)NIL;
	     extraArgs++) {
	}
    } else {
	extraArgs = 0;
    }
    
    for (argNumber = 0, argPtr = argPtrArray; 
	 argNumber < *numArgsPtr;
	 argNumber++) {

	accessible = FALSE;

	if ((argNumber > 0 || argPtrArray == (char **) NIL) && extraArgs > 0) {
	    stringPtr = extraArgArray[0];
	    realLength = strlen(stringPtr) + 1;
	    extraArgArray++;
	    extraArgs--;
	} else {
	    if (!userProc) {
		if (*argPtr == (char *) NIL) {
		    break;
		}
		stringPtr = *argPtr;
		stringLength = maxLength;
	    } else {
		if (*argPtr == (char *) USER_NIL) {
		    break;
		}
		Vm_MakeAccessible(VM_READONLY_ACCESS,
				  maxLength + 1, 
				  (Address) *argPtr, 
				  &stringLength,
				  (Address *) &stringPtr);
		if (stringLength == 0) {
		    status = SYS_ARG_NOACCESS;
		    goto execError;
		}
		accessible = TRUE;
	    }
	    /*
	     * Find out the length of the argument.  Because of accessibility
	     * limitations the whole string may not be available.
	     */
	    {
		register char *charPtr;
		for (charPtr = stringPtr, realLength = 0;
		     (realLength < stringLength) && (*charPtr != '\0');
		     charPtr++, realLength++) {
		}
		realLength++;
	    }
	    /*
	     * Move to the next argument.
	     */
	    argPtr++;
	}

	/*
	 * Put this string onto the argument list.
	 */
	argListPtr = (ArgListElement *)
		malloc(sizeof(ArgListElement));
	argListPtr->stringPtr =  malloc(realLength);
	argListPtr->stringLen = realLength;
	List_InitElement((List_Links *) argListPtr);
	List_Insert((List_Links *) argListPtr, LIST_ATREAR(argList));
	/*
	 * Calculate the room on the stack needed for this string.
	 * Make it double-word aligned to make access efficient on
	 * all machines.  Increment the amount needed to save the argument
	 * list (the same total length, but without the padding).
	 */
	paddedTotalLength += Byte_AlignAddr(realLength);
	totalLength += realLength;
	/*
	 * Copy over the argument and ensure null termination.
	 */
	bcopy((Address) stringPtr, (Address) argListPtr->stringPtr, realLength);
	argListPtr->stringPtr[realLength-1] = '\0';
	/*
	 * Clean up 
	 */
	if (accessible) {
	    Vm_MakeUnaccessible((Address) stringPtr, stringLength);
	}
	if (realLength > maxLength+1) {
	    status = GEN_E2BIG;
	    goto execError;
	}
    }
    if (realLengthPtr != (int *) NIL) {
	if (totalLength > *realLengthPtr) {
	    /*
	     * Would really like to flag "argument too long" here.
	     * Also, should we check after every argument?
	     */
	    status = GEN_INVALID_ARG;
	    goto execError;
	}
	*realLengthPtr = totalLength;
    }
    if (paddedLengthPtr != (int *) NIL) {
	*paddedLengthPtr = paddedTotalLength;
    }
    *numArgsPtr = argNumber;
    return(SUCCESS);
    
execError:
    /*
     * We hit an error while copying in the arguments.  Free any
     * arguments that were copied in.
     */
    while (!List_IsEmpty(argList)) {
	argListPtr = (ArgListElement *) List_First(argList);
	List_Remove((List_Links *) argListPtr);
	free((Address) argListPtr->stringPtr);
	free((Address) argListPtr);
    }
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * DoExec --
 *
 *	Exec a new program.  If the exec is to be done on this host, the
 *	current process image is overlayed by the 
 *	newly exec'd program.  If not, then set up the image of the
 *	user stack and set *encapPtrPtr to point to it.
 *
 * Results:
 *	In the local case, this routine does not return unless an
 *	error occurs in which case the
 *	error code is returned.  In the remote case, SUCCESS indicates
 *	the remote exec may continue.
 *
 * Side effects:
 *	The state of the calling process is modified for the new image and
 *	the argPtrArray and envPtrArray are made unaccessible if this
 *	is a user process.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
DoExec(fileName, userArgsPtr, encapPtrPtr, debugMe)
    char	fileName[];	/* The name of the file that is to be exec'd */
    UserArgs *userArgsPtr;	/* Information for taking args
				 * and environment, or NIL. */
    ExecEncapState
	**encapPtrPtr;		/* User stack state, either for us to use,
				 * for us to set, or NIL */
    Boolean	debugMe;	/* TRUE means that the process is to be 
				 * sent a SIG_DEBUG signal before
    				 * executing its first instruction. */
{
    register	Proc_ControlBlock	*procPtr;
    Vm_ExecInfo				*execInfoPtr;
    Vm_ExecInfo				execInfo;
    Vm_Segment				*codeSegPtr = (Vm_Segment *) NIL;
    char				*argString = (char *) NIL;
    char				*argStringSave;
    Address				argBuffer = (Address) NIL;
    Fs_Stream				*filePtr;
    ReturnStatus			status;
    char				buffer[PROC_MAX_INTERPRET_SIZE];
    Boolean				interpreted = FALSE;
    char				*interpName;
    char				*interpFlags;
    char				*interpArgs[MAX_INTERP_ARGS];
    int					argBytes;
    Address				userStackPointer;
    Boolean				usedFile;
    int					uid = -1;
    int					gid = -1;
    ExecEncapState			*encapPtr;
    int					importing = 0;
    int					exporting = 0;
    ProcObjInfo				objInfo;

#ifdef notdef
    DBG_CALL;
#endif

    /*
     * Use the encapsulation buffer and arguments arrays to determine
     * whether everything is local, or we're starting a remote exec,
     * or finishing one from another host.
     */
    if (encapPtrPtr != (ExecEncapState **) NIL) {
	if (userArgsPtr != (UserArgs *) NIL) {
	    exporting = TRUE;
	} else {
	    importing = TRUE;
	}
    }
    procPtr = Proc_GetActualProc();

    /*
     * objInfo.unixCompat is set if the header of the file indicates
     * it is a Unix binary.
     */
    objInfo.unixCompat = 0;
    procPtr->unixProgress = PROC_PROGRESS_NOT_UNIX;

    /* Turn off profiling */
    if (procPtr->Prof_Scale != 0) {
	Prof_Disable(procPtr);
    }

    /*
     * Save the argString away, because if we hit an error we always
     * set procPtr->argString back to this value.
     */
    argStringSave = procPtr->argString;

    /*
     * Open the file that is to be exec'd.
     */
    filePtr = (Fs_Stream *) NIL;
    status =  Fs_Open(fileName, FS_EXECUTE | FS_FOLLOW, FS_FILE, 0, &filePtr);
    if (status != SUCCESS) {
	filePtr = (Fs_Stream *) NIL;
	goto execError;
    }

    /*
     * Determine if this file has the set uid or set gid bits set.
     */
    Fs_CheckSetID(filePtr, &uid, &gid);

    /*
     * See if this file is already cached by the virtual memory system.
     */
    execInfoPtr = (Vm_ExecInfo *)NIL;
    codeSegPtr = Vm_FindCode(filePtr, procPtr, &execInfoPtr, &usedFile);
    if (codeSegPtr == (Vm_Segment *) NIL) {
	int	sizeRead;

	/*
	 * Read the file header.
	 */
	sizeRead = PROC_MAX_INTERPRET_SIZE > sizeof(ProcExecHeader) ?
						PROC_MAX_INTERPRET_SIZE :
						sizeof(ProcExecHeader);
	status = Fs_Read(filePtr, buffer, 0, &sizeRead);
	if (status != SUCCESS) {
	    goto execError;
	}
	if (sizeRead >= 2 && buffer[0] == '#' && buffer[1] == '!') {
	    Vm_InitCode(filePtr, (Vm_Segment *) NIL, (Vm_ExecInfo *) NIL);
	    /*
	     * See if this is an interpreter file.
	     */
	    status = SetupInterpret(buffer, sizeRead, &filePtr, 
				    &interpName, &interpFlags, &objInfo); 
	    if (status != SUCCESS) {
		filePtr = (Fs_Stream *)NIL;
		goto execError;
	    }
	    interpreted = TRUE;
	    codeSegPtr = Vm_FindCode(filePtr, procPtr, &execInfoPtr, &usedFile);
	} else {
	    if (sizeRead < sizeof(ProcExecHeader) ||
		ProcGetObjInfo(filePtr, (ProcExecHeader *)buffer, &objInfo) != SUCCESS) {
		    if(ProcIsObj(filePtr,1)==SUCCESS) {
			status = GEN_EINVAL;
		    } else {
			/* Check if it's not an ascii file. */
			int i;
			status = PROC_BAD_AOUT_FORMAT;
			for (i=0;i<sizeRead;i++) {
			    if (buffer[i]&0x80) {
				status = GEN_EINVAL;
				printf("Proc_Exec: can't run data file\n");
				break;
			    }
			}
		    }
		goto execError;
	    }
	}
    }

    if (!importing) {
	/*
	 * Set up whatever special arguments we might have due to an
	 * interpreter file.
	 */
	if (interpreted) {
	    int index = 0;	/* index into array of interpreter args */

	    if (userArgsPtr->argPtrArray == (char **) NIL) {
		interpArgs[index] = fileName;
		++index;
	    }
	    if (interpFlags != (char *)NIL) {
		interpArgs[index] = interpFlags;
		++index;
	    }
	    interpArgs[index] = fileName;
	    ++index;
	    interpArgs[index] = (char *) NIL;
	    if (index >= MAX_INTERP_ARGS) {
		panic("DoExec: need bigger array for interpreter args.\n");
	    }
	} 
	/*
	 * Copy in the argument list and environment into a single contiguous
	 * buffer.
	 */
	status = SetupArgs(userArgsPtr,
			   (interpreted ? interpArgs : (char **)NIL),
			   &argBuffer, &argString);

	if (status != SUCCESS) {
	    goto execError;
	}

	/*
	 * We no longer need access to the old arguments or the environment. 
	 */
	if (userArgsPtr->userMode) {
	    if (userArgsPtr->argPtrArray != (char **) NIL) {
		Vm_MakeUnaccessible((Address) userArgsPtr->argPtrArray,
				    userArgsPtr->argLength);
		userArgsPtr->argPtrArray = (char **)NIL;
		userArgsPtr->argLength = 0;
	    }
	    if (userArgsPtr->envPtrArray != (char **) NIL) {
		Vm_MakeUnaccessible((Address) userArgsPtr->envPtrArray,
				    userArgsPtr->envLength);
		userArgsPtr->envPtrArray = (char **)NIL;
		userArgsPtr->envLength = 0;
	    }
	}

	/*
	 * Close any streams that have been marked close-on-exec.
	 */
	Fs_CloseOnExec(procPtr);
    } else {
	/*
	 * We're "importing" this process.  Use the stack copied over from
	 * its former host.
	 */
	argBuffer = procPtr->remoteExecBuffer;
	procPtr->remoteExecBuffer = (Address) NIL;
	encapPtr = (ExecEncapState *) argBuffer;
	argString = encapPtr->hdr.argString;
    }
    
    /*
     * Change the argument string.
     */
    procPtr->argString = argString;
    /*
     * Do set uid here.  This way, the uid will be set before a remote
     * exec.
     */
    if (uid != -1) {
	procPtr->effectiveUserID = uid;
    }
    /*
     * If we're doing the initial part of a remote exec, time to
     * return to our caller.  Free up whatever virtual memory resources
     * we had set up.
     */
    encapPtr = (ExecEncapState *) argBuffer;
    if (exporting) {
	if (filePtr != (Fs_Stream *) NIL) {
	    if (codeSegPtr != (Vm_Segment *) NIL) {
		Vm_SegmentDelete(codeSegPtr, procPtr);
		if (!usedFile) {
		    /*
		     * If usedFile is TRUE then the file has already been closed
		     * by Vm_SegmentDelete.
		     */
		    (void) Fs_Close(filePtr);
		}
	    } else {
		/*
		 * We're not setting up the segment after all, so let vm
		 * clean up state and wake up anyone waiting for us to
		 * set up the segment.
		 */
		Vm_InitCode(filePtr, (Vm_Segment *) NIL, (Vm_ExecInfo *) NIL);
		(void) Fs_Close(filePtr);
	    }
	}
	*encapPtrPtr = encapPtr;
	encapPtr->hdr.fileName = fileName;
	encapPtr->hdr.argString = argString;
	return(SUCCESS);
    }
    /*
     * The file name has been dynamically allocated if it was copied in
     * on this host from user space.
     */
    if (!importing && userArgsPtr->userMode) {
	free(fileName);
	fileName = (char *) NIL;
    }
    /*
     * Set up virtual memory for the new image.
     */
    if (execInfoPtr == (Vm_ExecInfo *)NIL) {
	execInfoPtr = &execInfo;
    }
    if (!SetupVM(procPtr, &objInfo, filePtr, usedFile, &codeSegPtr, 
		 execInfoPtr)) {
	/*
	 * Setup VM will make sure that the file is closed and that
	 * all new segments are freed up.
	 */
	filePtr = (Fs_Stream *) NIL;
	status = VM_NO_SEGMENTS;
	goto execError;
    }

    /*
     * Now copy all of the arguments and environment variables onto the stack.
     */
    argBytes = encapPtr->hdr.size - sizeof(ExecEncapHeader);
    userStackPointer = encapPtr->hdr.base;
    status = Vm_CopyOut(argBytes, (Address) &encapPtr->argc,
		      userStackPointer);

    if (status != SUCCESS) {
	goto execError;
    }

    /*
     * Free original argString (kept in argStringSave, in case we
     * needed it) here, after last chance to goto execError.
     */
    if (argStringSave != (char *)NIL) {
	free(argStringSave);
    }

    /*
     * Set-gid only needs to be done on the host running the process.
     */
    if (gid != -1) {
	ProcAddToGroupList(procPtr, gid);
    }

    /*
     * Take signal actions for execed process.
     */
    Sig_Exec(procPtr);
    if (debugMe) {
	/*
	 * Debugged processes get a SIG_DEBUG at start up.
	 */
	Sig_SendProc(procPtr, SIG_DEBUG, SIG_NO_CODE, (Address)0);
    }
    if (!importing && (procPtr->genFlags & PROC_FOREIGN)) {
	ProcRemoteExec(procPtr, uid);
    }

    /* If this is a vfork process, wake the parent now */
    if (procPtr->genFlags & PROC_VFORKCHILD) {
	Proc_VforkWakeup(procPtr);
    }

    Proc_Unlock(procPtr);

    free(argBuffer);
    argBuffer = (Address) NIL;
    
    /*
     * Move the stack pointer on the sun4.
     */
    if (execInfoPtr->flags & UNIX_CODE) {
#ifdef sun4
	/*
	 * Unix on the sun4 has the stack in a different location from
	 * Sprite.
	 */
	userStackPointer += 32;
	if (debugProcStubs) {
	    printf("Moving stack pointer for Unix binary.\n");
	}
#endif
	procPtr->unixProgress = PROC_PROGRESS_UNIX;
    }

    /*
     * Disable interrupts.  Note that we don't use the macro DISABLE_INTR 
     * because there is an implicit enable interrupts when we return to user 
     * mode.
     */
    Mach_ExecUserProc(procPtr, userStackPointer, (Address) execInfoPtr->entry);
    panic("DoExec: Proc_RunUserProc returned.\n");

execError:
    /*
     * The exec failed after or while copying in the arguments.  Free any
     * virtual memory allocated and free any arguments or environment
     * variables that were copied in.
     */
    if (filePtr != (Fs_Stream *) NIL) {
	if (codeSegPtr != (Vm_Segment *) NIL) {
	    Vm_SegmentDelete(codeSegPtr, procPtr);
	    if (!usedFile) {
		/*
		 * If usedFile is TRUE then the file has already been closed
		 * by Vm_SegmentDelete.
		 */
		(void) Fs_Close(filePtr);
	    }
	} else {
	    Vm_InitCode(filePtr, (Vm_Segment *) NIL, (Vm_ExecInfo *) NIL);
	    (void) Fs_Close(filePtr);
	}
    }
    if (userArgsPtr != (UserArgs *) NIL && userArgsPtr->userMode) {
	if (userArgsPtr->argPtrArray != (char **) NIL) {
	    Vm_MakeUnaccessible((Address) userArgsPtr->argPtrArray,
				userArgsPtr->argLength);
	    userArgsPtr->argPtrArray = (char **)NIL;
	    userArgsPtr->argLength = 0;
	}
	if (userArgsPtr->envPtrArray != (char **) NIL) {
	    Vm_MakeUnaccessible((Address) userArgsPtr->envPtrArray,
				userArgsPtr->envLength);
	    userArgsPtr->envPtrArray = (char **)NIL;
	    userArgsPtr->envLength = 0;
	}
    }
    if (argBuffer != (Address) NIL) {
	free(argBuffer);
    }
    if (argString != (Address) NIL) {
	free(argString);
    }
    /*
     * Restore original arg string.  If we don't do this, then when
     * DoFork() tries to free() the arg string (after this process
     * exits, when some other process gets the then-empty process
     * slot), free() will panic because the original argString was
     * just freed above.
     */
    procPtr->argString = argStringSave;

    if (!importing && (fileName != (char *) NIL) && userArgsPtr->userMode) {
	free(fileName);
	fileName = (char *) NIL;
    }
    return(status);
}


/*
 *----------------------------------------------------------------------
 *
 * SetupInterpret --
 *
 *	Read in the interpreter name, arguments and object file header.
 *
 * Results:
 *	Error if for some reason could not parse the interpreter name
 *	and arguments are could not open the interpreter object file.
 *
 * Side effects:
 *	*filePtrPtr contains pointer to the interpreter object file, 
 *	*argPtrPtr points to interpreter argument string, *extraArgsPtr
 *	contains number of arguments that have to be prepended to the 
 *	argument vector passed to the interpreter and *aoutPtr contains the
 *	interpreter files a.out header.
 *
 *----------------------------------------------------------------------
 */ 

static ReturnStatus
SetupInterpret(buffer, sizeRead, filePtrPtr, interpNamePtr, 
	       interpFlagsPtr, objInfoPtr)
    register	char	*buffer;	/* Bytes read in from file.*/
    int			sizeRead;	/* Number of bytes in buffer. */	
    register	Fs_Stream **filePtrPtr;	/* IN/OUT parameter: Exec'd file as 
					 * input, interpreter file as output. */
    char		**interpNamePtr; /* OUT: name of interpreter file. */
    char		**interpFlagsPtr;/* OUT: single flags string to 
					  * pass to interpreter, possibly 
					  * NIL */ 
    ProcObjInfo		*objInfoPtr;	/* Place to put obj file info. */
{
    register	char	*strPtr;
    char		*interpName; /* name of the interpreter */
    int			i;
    ReturnStatus	status;
    ProcExecHeader	execHeader;

    (void) Fs_Close(*filePtrPtr);

    /*
     * Make sure the interpreter name and arguments are terminated by a 
     * carriage return.
     */
    for (i = 2, strPtr = &(buffer[2]);
	 i < sizeRead && *strPtr != '\n';
	 i++, strPtr++) {
    }
    if (i == sizeRead) {
	return(PROC_BAD_FILE_NAME);
    }
    *strPtr = '\0';

    /*
     * Get a pointer to the name of the file to exec.
     */

    for (strPtr = &(buffer[2]); isspace(*strPtr); strPtr++) {
    }
    if (*strPtr == '\0') {
	return(PROC_BAD_FILE_NAME);
    }
    interpName = strPtr;
    *interpNamePtr = interpName;
    while (!isspace(*strPtr) && *strPtr != '\0') {
	strPtr++;
    }

    /*
     * Get a pointer to the arguments if there are any.
     */

    *interpFlagsPtr = (char *)NIL;

    if (*strPtr != '\0') {
	*strPtr = '\0';
	strPtr++;
	while (isspace(*strPtr)) {
	    strPtr++;
	}
	if (*strPtr != '\0') {
	    *interpFlagsPtr = strPtr;
	}
    }

    /*
     * Open the interpreter to exec and read the a.out header.
     */

    status = Fs_Open(interpName, FS_EXECUTE | FS_FOLLOW, FS_FILE, 0,
		     filePtrPtr);
    if (status != SUCCESS) {
	return(status);
    }

    sizeRead = sizeof(ProcExecHeader);
    status = Fs_Read(*filePtrPtr, (Address)&execHeader, 0, &sizeRead);
    if (status == SUCCESS && sizeRead != sizeof(ProcExecHeader)) {
	status = PROC_BAD_AOUT_FORMAT;
    } else {
	status = ProcGetObjInfo(*filePtrPtr, &execHeader, objInfoPtr);
    }
    if (status != SUCCESS) {
	if(ProcIsObj(*filePtrPtr,1)==SUCCESS) {
	    status = GEN_EINVAL;
	} else {
	    status = PROC_BAD_AOUT_FORMAT;
	}
	(void) Fs_Close(*filePtrPtr);
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * SetupVM --
 *
 *	Setup virtual memory for this process.
 *
 * Results:
 *	TRUE if could set up VM, false otherwise.
 *
 * Side effects:
 *	*filePtrPtr contains pointer to the interpreter object file, 
 *	*argPtrPtr points to interpreter argument string, *extraArgsPtr
 *	contains number of arguments that have to be prepended to the 
 *	argument vector passed to the interpreter and *aoutPtr contains the
 *	interpreter files a.out header.
 *
 *----------------------------------------------------------------------
 */ 
static Boolean
SetupVM(procPtr, objInfoPtr, codeFilePtr, usedFile, codeSegPtrPtr, execInfoPtr)
    register	Proc_ControlBlock	*procPtr;
    register	ProcObjInfo		*objInfoPtr;
    Fs_Stream				*codeFilePtr;
    Boolean				usedFile;
    Vm_Segment				**codeSegPtrPtr;
    register	Vm_ExecInfo		*execInfoPtr;
{
    register	Vm_Segment	*segPtr;
    int				numPages;
    int				fileOffset;
    int				pageOffset;
    Boolean			notFound;
    Vm_Segment			*heapSegPtr;
    Fs_Stream			*heapFilePtr;
    Address			heapEnd = (Address) NIL;
    int				realCode = 1;

    if (*codeSegPtrPtr == (Vm_Segment *) NIL) {
	if (objInfoPtr->unixCompat) {
	    execInfoPtr->flags = UNIX_CODE;
	} else {
	    execInfoPtr->flags = 0;
	}
	execInfoPtr->entry = (int)objInfoPtr->entry;
	if (objInfoPtr->heapSize != 0) {
	    execInfoPtr->heapPages = 
			(objInfoPtr->heapSize - 1) / vm_PageSize + 1;
	} else { 
	    execInfoPtr->heapPages = 0;
	}
	if (objInfoPtr->bssSize != 0) {
	    execInfoPtr->heapPages += 
			(objInfoPtr->bssSize - 1) / vm_PageSize + 1;
	}
	execInfoPtr->heapPageOffset = 
			(unsigned)objInfoPtr->heapLoadAddr / vm_PageSize;
	execInfoPtr->heapFileOffset = objInfoPtr->heapFileOffset;
	heapEnd = objInfoPtr->heapLoadAddr + objInfoPtr->heapSize;
	execInfoPtr->heapExcess =
		vm_PageSize - ((unsigned)heapEnd&(vm_PageSize-1));
	if (execInfoPtr->heapExcess == vm_PageSize) {
	    execInfoPtr->heapExcess = 0;
	}
	execInfoPtr->bssFirstPage = 
			(unsigned)objInfoPtr->bssLoadAddr / vm_PageSize;
	if ((unsigned)(heapEnd-1) / vm_PageSize >= execInfoPtr->bssFirstPage) {
	    /*
	     * End of heap, start of bss in same page, so move bss.
	     */
	    execInfoPtr->bssFirstPage = (unsigned)(heapEnd-1)/vm_PageSize + 1;
	}

	if (objInfoPtr->bssSize != 0) {
	    execInfoPtr->bssLastPage = (int) (execInfoPtr->bssFirstPage + 
				   (objInfoPtr->bssSize - 1) / vm_PageSize);
	} else {
	    execInfoPtr->bssLastPage = 0;
	}
	/* 
	 * Set up the code image.
	 */
	if (objInfoPtr->codeSize == 0) {
	    /*
	     * Things work better if we have a code segment.
	     * I'm not sure setting realCode=1 is the right thing, but
	     * I'll try it.  If realCode=0 we may have problems when we
	     * try to clean up the file handle.
	     */
	    realCode = 1;
	    objInfoPtr->codeSize = vm_PageSize;
	}
	numPages = (objInfoPtr->codeSize - 1) / vm_PageSize + 1;
	fileOffset = objInfoPtr->codeFileOffset;
	pageOffset = (unsigned)objInfoPtr->codeLoadAddr / vm_PageSize;
	segPtr = Vm_SegmentNew(VM_CODE, codeFilePtr, fileOffset,
			       numPages, pageOffset, procPtr);
	if (segPtr == (Vm_Segment *) NIL) {
	    Vm_InitCode(codeFilePtr, (Vm_Segment *) NIL, (Vm_ExecInfo *) NIL);
	    (void) Fs_Close(codeFilePtr);
	    return(FALSE);
	}
	Vm_ValidatePages(segPtr, pageOffset, pageOffset + numPages - 1,
			 FALSE, TRUE);
	if (realCode) {
	    Vm_InitCode(codeFilePtr, segPtr, execInfoPtr);
	} else {
	    Vm_InitCode(codeFilePtr, (Vm_Segment *) NIL, (Vm_ExecInfo *) NIL);
	}
	*codeSegPtrPtr = segPtr;
	notFound = TRUE;
    } else {
	notFound = FALSE;
    }

    if (usedFile || notFound) {
	Fsio_StreamCopy(codeFilePtr, &heapFilePtr);
    } else {
	heapFilePtr = codeFilePtr;
    }
    /* 
     * Set up the heap image.
     */
    segPtr = Vm_SegmentNew(VM_HEAP, heapFilePtr, execInfoPtr->heapFileOffset,
			       execInfoPtr->heapPages, 
			       execInfoPtr->heapPageOffset, procPtr);
    if (segPtr == (Vm_Segment *) NIL) {
	Vm_SegmentDelete(*codeSegPtrPtr, procPtr);
	(void) Fs_Close(heapFilePtr);
	return(FALSE);
    }
    Vm_ValidatePages(segPtr, execInfoPtr->heapPageOffset,
		     execInfoPtr->bssFirstPage - 1, FALSE, TRUE);
    if (execInfoPtr->bssLastPage > 0) {
	Vm_ValidatePages(segPtr, execInfoPtr->bssFirstPage,
			 execInfoPtr->bssLastPage, TRUE, TRUE);
    }
    heapSegPtr = segPtr;
    /*
     * Set up a new stack.
     */
    segPtr = Vm_SegmentNew(VM_STACK, (Fs_Stream *) NIL, 0, 
			   1, mach_LastUserStackPage, procPtr);
    if (segPtr == (Vm_Segment *) NIL) {
	Vm_SegmentDelete(*codeSegPtrPtr, procPtr);
	Vm_SegmentDelete(heapSegPtr, procPtr);
	return(FALSE);
    }
    Vm_ValidatePages(segPtr, mach_LastUserStackPage, 
		    mach_LastUserStackPage, TRUE, TRUE);

    Proc_Lock(procPtr);
    procPtr->genFlags |= PROC_NO_VM;
#ifdef sun4
    Mach_FlushWindowsToStack();
    VmMach_FlushCurrentContext();
#endif
    Vm_SegmentDelete(procPtr->vmPtr->segPtrArray[VM_CODE], procPtr);
    Vm_SegmentDelete(procPtr->vmPtr->segPtrArray[VM_HEAP], procPtr);
    Vm_SegmentDelete(procPtr->vmPtr->segPtrArray[VM_STACK], procPtr);
    procPtr->vmPtr->segPtrArray[VM_CODE] = *codeSegPtrPtr;
    procPtr->vmPtr->segPtrArray[VM_HEAP] = heapSegPtr;
    procPtr->vmPtr->segPtrArray[VM_STACK] = segPtr;
    procPtr->genFlags &= ~PROC_NO_VM;
    VmMach_ReinitContext(procPtr);

    /*
     * If heap does not match page boundary, prefetch the partial page
     * if necessary, and zero the rest.
     */
    if (execInfoPtr->heapExcess != 0) {
	if (realCode && (execInfoPtr->flags & UNIX_CODE) == 0) {
	    printf("SetupVM: Warning: Program %s has unaligned heap %s\n",
		    Fsutil_HandleName(&codeFilePtr->hdr),
		    "and should be relinked");
	}
	return ZeroHeapEnd(execInfoPtr);
    }
    return(TRUE);
}


/*
 *----------------------------------------------------------------------
 *
 * ZeroHeapEnd --
 *
 *	Zero out the end of the heap (from the given address to the 
 *	next page boundary).  This routine exists for compatibility 
 *	with oddly-linked binaries.
 *
 * Results:
 *	TRUE if we were successful, FALSE if not (e.g., couldn't bring 
 *	in the last heap page).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
    
static Boolean
ZeroHeapEnd(execInfoPtr)
    Vm_ExecInfo	*execInfoPtr;	/* info about the exec file */
{
    ReturnStatus	status;
    Address	heapEnd;	/* kernel address of end of heap */
    int		bytesToZero;	/* number of bytes to zero out */
    int		bytesAvail;	/* number of bytes accessible */
    int		userHeapEnd;
    

    status = Vm_PageIn((Address) ((execInfoPtr->bssFirstPage-1)*vm_PageSize),
		       FALSE);
    if (status != SUCCESS) {
	printf("SetupVM: heap prefetch failure\n");
	return FALSE;
    }
    bytesToZero = execInfoPtr->heapExcess;
    userHeapEnd = execInfoPtr->bssFirstPage*vm_PageSize-bytesToZero;
    if (debugProcStubs) {
	printf("ZeroHeapEnd: zeroing %x at %x\n", bytesToZero, userHeapEnd);
    }
    Vm_MakeAccessible(VM_READWRITE_ACCESS, bytesToZero, (Address)userHeapEnd,
		      &bytesAvail, (Address *)&heapEnd);
    if (bytesAvail != bytesToZero) {
	printf("SetupVM: can't map heap\n");
	return FALSE;
    }
    bzero((char *)heapEnd, bytesToZero);
    Vm_MakeUnaccessible(heapEnd, bytesToZero);

    return TRUE;
}


/*
 *----------------------------------------------------------------------
 *
 * ProcExecGetEncapSize --
 *
 *	Return the size of the encapsulated exec state.
 *
 * Results:
 *	SUCCESS is returned directly; the size of the encapsulated state
 *	is returned in infoPtr->size.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

/* ARGSUSED */
ReturnStatus
ProcExecGetEncapSize(procPtr, hostID, infoPtr)
    Proc_ControlBlock *procPtr;			/* process being migrated */
    int hostID;					/* host to which it migrates */
    Proc_EncapInfo *infoPtr;			/* area w/ information about
						 * encapsulated state */
{
    ExecEncapState *encapPtr;

    encapPtr = (ExecEncapState *) procPtr->remoteExecBuffer;
    encapPtr->hdr.fileNameLength =
	Byte_AlignAddr(strlen(encapPtr->hdr.fileName) + 1);
    encapPtr->hdr.argLength =
	Byte_AlignAddr(strlen(encapPtr->hdr.argString) + 1);
    infoPtr->size = encapPtr->hdr.size + encapPtr->hdr.fileNameLength +
	encapPtr->hdr.argLength;
    return(SUCCESS);	
}


/*
 *----------------------------------------------------------------------
 *
 * ProcExecEncapState --
 *
 *	Encapsulate the information needed to perform a remote exec,
 *	and return it in the buffer provided.
 *
 * Results:
 *	SUCCESS.  The buffer is filled.
 *
 * Side effects:
 *	None.
 *----------------------------------------------------------------------
 */

/* ARGSUSED */
ReturnStatus
ProcExecEncapState(procPtr, hostID, infoPtr, bufPtr)
    register Proc_ControlBlock 	*procPtr;  /* The process being migrated */
    int hostID;				   /* host to which it migrates */
    Proc_EncapInfo *infoPtr;		   /* area w/ information about
					    * encapsulated state */
    Address bufPtr;			   /* Pointer to allocated buffer */
{
    ExecEncapState *encapPtr;

    encapPtr = (ExecEncapState *) procPtr->remoteExecBuffer;

    bcopy((Address) encapPtr, bufPtr, encapPtr->hdr.size);
    bufPtr += encapPtr->hdr.size;
    (void) strncpy(bufPtr, encapPtr->hdr.fileName, encapPtr->hdr.fileNameLength);
    bufPtr += encapPtr->hdr.fileNameLength;
    (void) strncpy(bufPtr, encapPtr->hdr.argString, encapPtr->hdr.argLength);
    return(SUCCESS);
}


/*
 *----------------------------------------------------------------------
 *
 * ProcExecDeencapState --
 *
 *	Get remote exec information from a Proc_ControlBlock from another host.
 *	The information is contained in the parameter ``buffer''.
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Memory is allocated for argString, which is kept around while the
 *	process is alive.
 *----------------------------------------------------------------------
 */

/* ARGSUSED */
ReturnStatus
ProcExecDeencapState(procPtr, infoPtr, bufPtr)
    register Proc_ControlBlock 	*procPtr; /* The process being migrated */
    Proc_EncapInfo *infoPtr;		  /* information about the buffer */
    Address bufPtr;			  /* buffer containing data */
{
    ExecEncapState *encapPtr;
    char *argString;

    procPtr->remoteExecBuffer = malloc(infoPtr->size);
    bcopy(bufPtr, procPtr->remoteExecBuffer, infoPtr->size);

    encapPtr = (ExecEncapState *) procPtr->remoteExecBuffer;
    encapPtr->hdr.fileName = procPtr->remoteExecBuffer + encapPtr->hdr.size;
    argString = encapPtr->hdr.fileName + encapPtr->hdr.fileNameLength;
    encapPtr->hdr.argString = malloc(encapPtr->hdr.argLength);
    (void) strncpy(encapPtr->hdr.argString, argString, encapPtr->hdr.argLength);
    return(SUCCESS);
}


/*
 *----------------------------------------------------------------------
 *
 * ProcExecFinishMigration --
 *
 *	Free up resources after a remote exec.  This includes buffers
 *      used to store information about a remote exec
 *	between the time of the system call and the time the migration
 *	completes: namely, the buffer containing the user's stack,
 *	and the file name to exec (reached via that buffer).  Also,
 *	free the virtual memory segments used by the process. 
 *
 * Results:
 *	SUCCESS.
 *
 * Side effects:
 *	Memory is freed. The segments are freed.
 *----------------------------------------------------------------------
 */

/* ARGSUSED */
ReturnStatus
ProcExecFinishMigration(procPtr, hostID, infoPtr, bufPtr, failure)
    register Proc_ControlBlock 	*procPtr; /* The process being migrated */
    int hostID;				  /* Host to which it migrated */
    Proc_EncapInfo *infoPtr;		  /* Information about the buffer */
    Address bufPtr;			  /* Buffer containing data */
    Boolean failure;			  /* Whether a failure occurred */
{
    ExecEncapState *encapPtr;
    int i;

    encapPtr = (ExecEncapState *) procPtr->remoteExecBuffer;
    free(encapPtr->hdr.fileName);
    free(procPtr->remoteExecBuffer);
    Proc_Lock(procPtr);
    procPtr->remoteExecBuffer = (Address) NIL;
    procPtr->genFlags |= PROC_NO_VM;
    Proc_Unlock(procPtr);
    for (i = VM_CODE; i <= VM_STACK; i++) {
	Vm_SegmentDelete(procPtr->vmPtr->segPtrArray[i], procPtr);
    }
    return(SUCCESS);
}


/*
 *----------------------------------------------------------------------
 *
 * ProcDoRemoteExec --
 *
 *	Do an exec of a process that's come to this machine from another
 *	one.  This is the PC at which the process resumes after migration,
 *	at which point it has no VM set up.
 *
 * Results:
 *	None.  This routine doesn't return, since upon error the process
 *	exits.
 *
 * Side effects:
 *	An exec is performed.
 *
 *----------------------------------------------------------------------
 */

void
ProcDoRemoteExec(procPtr)
    register Proc_ControlBlock *procPtr; /* Process control block, locked
					  * on entry */
{
    char *fileName = (char *) NIL;
    ReturnStatus status;
    ExecEncapState *encapPtr;

    /*
     * Set up dummy segments so that DoExec can work properly.
     */

    procPtr->genFlags &= ~PROC_REMOTE_EXEC_PENDING;
    procPtr->vmPtr->segPtrArray[VM_CODE] = 
				Vm_SegmentNew(VM_CODE, (Fs_Stream *) NIL, 0,
					          1, 0, procPtr);
    if (procPtr->vmPtr->segPtrArray[VM_CODE] == (Vm_Segment *) NIL) {
	status = PROC_NO_SEGMENTS;
	Proc_Unlock(procPtr);
	goto failure;
    }

    procPtr->vmPtr->segPtrArray[VM_HEAP] =
		    Vm_SegmentNew(VM_HEAP, (Fs_Stream *) NIL, 0, 1, 1, procPtr);
    if (procPtr->vmPtr->segPtrArray[VM_HEAP] == (Vm_Segment *) NIL) {
	Vm_SegmentDelete(procPtr->vmPtr->segPtrArray[VM_CODE], procPtr);
	status = PROC_NO_SEGMENTS;
	Proc_Unlock(procPtr);
	goto failure;
    }

    procPtr->vmPtr->segPtrArray[VM_STACK] =
		    Vm_SegmentNew(VM_STACK, (Fs_Stream *) NIL, 
				   0 , 1, mach_LastUserStackPage, procPtr);
    if (procPtr->vmPtr->segPtrArray[VM_STACK] == (Vm_Segment *) NIL) {
	Vm_SegmentDelete(procPtr->vmPtr->segPtrArray[VM_CODE], procPtr);
	Vm_SegmentDelete(procPtr->vmPtr->segPtrArray[VM_HEAP], procPtr);
	status = PROC_NO_SEGMENTS;
	Proc_Unlock(procPtr);
	goto failure;
    }

    VmMach_ReinitContext(procPtr);

    encapPtr = (ExecEncapState *) procPtr->remoteExecBuffer;
    fileName = encapPtr->hdr.fileName;
    Proc_Unlock(procPtr);
    status = DoExec(fileName, (UserArgs *) NIL, &encapPtr, FALSE);
    /*
     * If the exec failed, then exit.  
     */
    failure:
    if (proc_MigDebugLevel > 0) {
	printf("Remote exec of %s failed: %s\n", fileName,
	       Stat_GetMsg(status));
    }
    Proc_ExitInt(PROC_TERM_DESTROYED, SIG_KILL, 0);
    /*
     * NOTREACHED
     */
}


/*
 * The following table contains the functions to check if an executable
 * is of a particular machine type.
 */
int	hostFmt = HOST_FMT;
char * (*machType[]) _ARGS_((int bufferSize, char *buffer, int *magic, 
	int *syms, char **other)) =  {
    machType68k,
    machTypeSparc,
/*  machTypeSpur,   -- No longer supported */
    machTypeMips,
/*  machTypeSymm,   -- No longer supported */
};
/*
 *----------------------------------------------------------------------
 *
 * ProcIsObj -
 *
 *	Check if the process is an a.out file.  If doErr is set, an
 *	error message will be printed if the file is an a.out file.
 *	This routine is to be called if the file cannot be execed, to
 *	see if it's the wrong a.out type.
 *	This code is based on the Sprite a.out checking routines for
 *	the file program.
 *
 * Results:
 *	SUCCESS if the file is an a.out file.
 *	FAILURE if the file is not an a.out file.
 *
 * Side effects:
 *	An error may printed in the syslog if doErr is set.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
ProcIsObj(streamPtr, doErr)
    Fs_Stream	*streamPtr;	/* Stream pointer for obj file. */
    int		doErr;		/* 1 if want error messages. */
{
    ReturnStatus	status;
    char		*buffer;
    int			hdrSize = BUFSIZ;
    int			i;
    int			magic;
    char		*name;
    int			syms;
    char		*other;

    buffer = (char *)malloc(hdrSize);
    status = Fs_Read(streamPtr, (Address)buffer, 0, &hdrSize);
    if (status != SUCCESS) {
	return FAILURE;
    }
    for (i=0; i < sizeof(machType)/sizeof(*machType); i++) {
	name = machType[i](hdrSize, (const char *) buffer, &magic, &syms,
		&other);
	if (name != NULL) {
	    if (doErr) {
		printf("Proc_Exec: Can't run %s ", name);
		switch (magic) {
		    case 0407:
			printf("OMAGIC");
			break;
		    case 0410:
			printf("NMAGIC");
			break;
		    case 0413:
			printf("ZMAGIC");
			break;
		    case 0414:
			printf("SPRITE_ZMAGIC");
			break;
		    case 0415:
			printf("UNIX_ZMAGIC");
			break;
		    case 0443:
			printf("LIBMAGIC");
			break;
		    default:
			printf("(0%03o)", magic);
			break;
		}
		if (*other != '\0') {
		    printf(" %s", other);
		}
		printf(" executable file on %s.\n", mach_MachineType);
	    }
	    return SUCCESS;
	}
    }
    return FAILURE;
}
@


9.34
log
@Removed spur and symm machine types from procExec.c
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/proc/procExec.c,v 9.33 91/11/15 21:04:15 kupfer Exp $ SPRITE (Berkeley)";
d1052 2
d1055 7
@


9.33
log
@Clean up the code that sets up the arguments to pass to a script
interpreter.  
If trying to exec an object file with the wrong machine type, return
GEN_EINVAL instead of FS_NO_ACCESS.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/proc/procExec.c,v 9.32 91/09/24 21:27:30 shirriff Exp $ SPRITE (Berkeley)";
d1933 1
a1933 1
    machTypeSpur,
d1935 1
a1935 1
    machTypeSymm,
@


9.32
log
@Changed behavior if we move the code segment around.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.31 91/08/27 18:28:45 mottsmth Exp Locker: shirriff $ SPRITE (Berkeley)";
d57 6
d138 3
a140 3
static ReturnStatus 	SetupInterpret _ARGS_((register char *buffer, 
			    int sizeRead, register Fs_Stream **filePtrPtr, 
			    char **argPtrPtr, int *extraArgsPtr, 
d950 4
a953 4
    int					extraArgs = 0;
    char				*shellArgPtr;
    char				*extraArgsArray[2];
    char				**extraArgsPtrPtr;
d1039 1
a1039 1
				    &shellArgPtr, &extraArgs, &objInfo); 
d1044 1
d1050 1
a1050 1
			status = FS_NO_ACCESS;
d1062 1
a1062 1
	 * interpreter file.  If the
d1064 2
a1065 3
	if (extraArgs > 0) {
	    int i;
	    int index;
d1068 2
a1069 4
		extraArgsArray[0] = fileName;
		index = 1;
	    } else {
		index = 0;
d1071 9
a1079 6
	    for (i = index; extraArgs > 0; i++, extraArgs--) {
		if (extraArgs == 2) {
		    extraArgsArray[i] = shellArgPtr;
		} else {
		    extraArgsArray[i] = fileName;
		}
d1081 1
a1081 5
	    extraArgsArray[i] = (char *) NIL;
	    extraArgsPtrPtr = extraArgsArray;
	} else {
	    extraArgsPtrPtr = (char **) NIL;
	}
d1086 2
a1087 1
	status = SetupArgs(userArgsPtr, extraArgsPtrPtr,
d1351 2
a1352 2
SetupInterpret(buffer, sizeRead, filePtrPtr, argPtrPtr, 
	       extraArgsPtr, objInfoPtr)
d1357 4
a1360 3
    char		**argPtrPtr;	/* Pointer to shell argument string. */
    int			*extraArgsPtr;	/* Number of arguments that have to be
					 * added for the intepreter. */
d1364 1
a1364 1
    char		*shellNamePtr;
d1393 2
a1394 1
    shellNamePtr = strPtr;
a1397 1
    *extraArgsPtr = 1;
d1403 2
d1412 1
a1412 2
	    *argPtrPtr = strPtr;
	    *extraArgsPtr = 2;
d1420 1
a1420 1
    status = Fs_Open(shellNamePtr, FS_EXECUTE | FS_FOLLOW, FS_FILE, 0,
d1435 1
a1435 1
	    status = FS_NO_ACCESS;
@


9.31
log
@Ooops, put wakeup in wrong place when I added vfork support.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.29 91/07/26 16:59:33 shirriff Exp $ SPRITE (Berkeley)";
d1523 3
d1527 1
a1527 1
	    realCode = 0;
@


9.30
log
@Add true vfork support
@
text
@a385 7
	/* If this is a vfork process, wake the parent now */
	procPtr = Proc_GetCurrentProc();
	Proc_Lock(procPtr);
	if (procPtr->genFlags & PROC_VFORKCHILD) {
	    Proc_VforkWakeup(procPtr);
	}
	Proc_Unlock(procPtr);
d390 1
d1231 6
@


9.29
log
@Large install for unix compatibility
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc.ken/RCS/procExec.c,v 1.1 91/05/30 18:12:40 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d386 7
a396 1
	    procPtr = Proc_GetCurrentProc();
@


9.29.1.1
log
@Initial branch for Sprite server.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.29 91/07/26 16:59:33 shirriff Exp $ SPRITE (Berkeley)";
@


9.28
log
@Added flags to indicate if we're running in Unix mode.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.27 91/03/29 16:30:54 kupfer Exp Locker: shirriff $ SPRITE (Berkeley)";
d37 1
a42 1
#include <file.h>
d48 1
d57 2
d65 2
d148 1
a148 2
static Boolean		ZeroHeapEnd _ARGS_ ((Vm_ExecInfo *execInfoPtr,
					     Address heapEnd));
d977 2
a978 2
     * This should be in the Vm_ExecInfo structure, so it can get reused
     * when a program is re-run.  I'll fix this soon.  --Ken
d981 1
a981 1
    procPtr->unixProgress = -1;
d1237 1
a1237 3
     * Disable interrupts.  Note that we don't use the macro DISABLE_INTR 
     * because there is an implicit enable interrupts when we return to user 
     * mode.
d1239 1
a1239 1
    if (objInfo.unixCompat) {
d1241 4
d1246 3
a1248 1
	printf("Moving stack pointer for Unix binary.\n");
d1250 1
a1250 4
	/*
	 * I'm using a magic number here.  This should be temporary.
	 */
	procPtr->unixProgress = 0x11beef22;
d1252 6
d1471 5
d1491 5
d1599 2
a1600 2
    if (notFound && ((unsigned)heapEnd & (vm_PageSize-1)) != 0) {
	if (realCode) {
a1603 2
	} else {
	    return ZeroHeapEnd(execInfoPtr, heapEnd);
d1605 1
d1631 1
a1631 1
ZeroHeapEnd(execInfoPtr, userHeapEnd)
a1632 1
    Address	userHeapEnd;	/* user address of the end of the heap */
d1638 1
d1647 7
a1653 3
    bytesToZero = vm_PageSize - ((unsigned)userHeapEnd&(vm_PageSize-1));
    Vm_MakeAccessible(VM_READWRITE_ACCESS, bytesToZero, userHeapEnd,
		      &bytesAvail, &heapEnd);
@


9.27
log
@Manage more carefully the references to the user's argument and
environment arrays.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.26 91/03/29 14:38:13 shirriff Exp Locker: kupfer $ SPRITE (Berkeley)";
a958 6
     * This should be in the Vm_ExecInfo structure, so it can get reused
     * when a program is re-run.  I'll fix this soon.  --Ken
     */
    objInfo.unixCompat = 0;

    /*
d972 7
d1237 1
a1238 1
    if (objInfo.unixCompat) {
d1241 5
a1246 1
#endif
@


9.26
log
@Move stack for sun unix compatibility binary.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.25 91/03/20 20:30:58 kupfer Exp $ SPRITE (Berkeley)";
d107 2
a108 1
 * place.
d115 1
d118 1
d362 1
d365 1
d476 1
d479 1
d1091 1
a1091 1
				    userArgsPtr->numArgs * 4);
d1093 1
d1097 1
a1097 1
				    userArgsPtr->numEnvs * 4);
d1099 1
d1269 1
a1269 1
				userArgsPtr->numArgs * 4);
d1271 1
d1275 1
a1275 1
				userArgsPtr->numEnvs * 4);
d1277 1
@


9.25
log
@Disable some UNIX-compatibility stack pointer munging (for Ken).
When zeroing out the end of a misaligned heap segment, use
Vm_MakeAccessible (untested).
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.24 91/03/19 15:44:02 shirriff Exp Locker: kupfer $ SPRITE (Berkeley)";
d952 6
a1227 1
#if 0
d1230 1
a1231 1
#endif
@


9.24
log
@Added changes for unix compatibility:
1. Check for dynamically linked
2. Move stack pointer on sun when running unix program.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.23 90/12/07 23:44:46 rab Exp $ SPRITE (Berkeley)";
d140 2
d1222 1
d1227 1
a1434 1
    ReturnStatus		status;
d1563 2
a1564 10
	    status = Vm_PageIn((Address) 
		    ((execInfoPtr->bssFirstPage-1)*vm_PageSize),
		    FALSE);
	    if (status != SUCCESS) {
		printf("SetupVM: heap prefetch failure\n");
		return FALSE;
	    }
	    bzero((char *)heapEnd,
		    vm_PageSize-((unsigned)heapEnd&(vm_PageSize-1)));
	    }
d1567 50
@


9.23
log
@Unix compatibilty.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.22 90/11/12 21:44:43 shirriff Exp Locker: rab $ SPRITE (Berkeley)";
d1021 1
a1021 1
		ProcGetObjInfo((ProcExecHeader *)buffer, &objInfo) != SUCCESS) {
d1219 5
d1383 1
a1383 1
	status = ProcGetObjInfo(&execHeader, objInfoPtr);
d1825 1
a1825 1
	int *syms)) =  {
d1865 1
d1873 2
a1874 1
	name = machType[i](hdrSize, (const char *) buffer, &magic, &syms);
d1900 3
@


9.22
log
@Returns E2BIG if anything in the environment is too long.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.21 90/10/09 11:53:03 jhh Exp $ SPRITE (Berkeley)";
d1880 6
@


9.21
log
@function prototypes
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.19 90/09/20 16:24:49 mgbaker Exp $ SPRITE (Berkeley)";
d847 4
@


9.20
log
@Added prototyping.
Added symmetry.
@
text
@d47 1
d1815 2
a1816 2
#ifdef __STDC__
procMachType *machType[] =  {
a1822 9
#else
procMachType (*machType[])() =  {
    machType68k,
    machTypeSparc,
    machTypeSpur,
    machTypeMips,
    machTypeSymm,
};
#endif
d1863 1
a1863 1
	name = machType[i](hdrSize, buffer, &magic, &syms);
@


9.19
log
@Fixed a procedure name.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.18 90/09/12 13:58:03 jhh Exp Locker: mgbaker $ SPRITE (Berkeley)";
d1809 4
d1814 10
a1823 1
char *(*(machType[])) () =  {
d1828 1
d1830 1
@


9.18
log
@changed format of #includes to use <>
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.17 90/09/06 17:57:00 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
d1528 2
a1529 2
    MachFlushWindowsToStack();
    VmMachFlushCurrentContext();
@


9.17
log
@First pass at function prototypes
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.16 90/07/29 15:48:08 shirriff Exp Locker: jhh $ SPRITE (Berkeley)";
d21 26
a46 26
#include "sprite.h"
#include "procMach.h"
#include "mach.h"
#include "proc.h"
#include "procInt.h"
#include "sync.h"
#include "sched.h"
#include "fs.h"
#include "fsio.h"
#include "stdlib.h"
#include "sig.h"
#include "spriteTime.h"
#include "list.h"
#include "vm.h"
#include "sys.h"
#include "procMigrate.h"
#include "status.h"
#include "string.h"
#include "byte.h"
#include "rpc.h"
#include "prof.h"
#include "file.h"
#include "fsutil.h"
#include "ctype.h"
#include "stdio.h"
#include "bstring.h"
@


9.16
log
@Added address field to sig_sendproc call.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.15 90/06/27 12:43:57 douglis Exp $ SPRITE (Berkeley)";
d44 3
a46 16
#ifdef notdef
#include "dbg.h"
#endif


/*
 * Forward declarations.
 */
static ReturnStatus	SetupExec();
static ReturnStatus	DoExec();
static ReturnStatus	SetupInterpret();
static ReturnStatus	SetupArgs();
static ReturnStatus	GrabArgArray();
static Boolean		SetupVM();


d117 22
d1422 1
a1422 1
    Address			heapEnd;
d1550 2
a1551 1
	    status = Vm_PageIn((execInfoPtr->bssFirstPage-1)*vm_PageSize,
d1750 1
a1750 1
    char *fileName;
@


9.15
log
@make sure argStringSave is set to procPtr->argString before something 
might cause a jump to execError.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.15 90/06/27 12:23:20 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d1190 1
a1190 1
	Sig_SendProc(procPtr, SIG_DEBUG, SIG_NO_CODE);
@


9.14
log
@applied fubar's change:
|	If the exec fails for some esoteric reason (in our case, the
|machine ran out of free virtual memory segments; you can probably find
|other ways), procPtr->argString is left holding a free()ed pointer.  A
|subsequent fork() by a different process after this one exits will
|attempt to free() this pointer in DoFork(), resulting in a panic.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.13 90/05/01 12:33:52 shirriff Exp Locker: douglis $ SPRITE (Berkeley)";
d912 1
a912 1
    char				*argStringSave = (char *) NIL;
d955 6
a1089 1
    argStringSave = procPtr->argString;
@


9.13
log
@Improved warning for unaligned executable.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.12 90/03/30 15:16:18 shirriff Exp $ SPRITE (Berkeley)";
d912 1
d1084 1
a1084 3
    if (procPtr->argString != (char *) NIL) {
	free(procPtr->argString);
    }
a1085 1

d1163 8
d1242 9
@


9.12
log
@Made "can't run X on Y" message more descriptive.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.11 90/03/26 11:51:45 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d43 1
d1517 13
a1529 12
	    printf("SetupVM: Warning: heap is unaligned for ZMAGIC file\n");
	    printf("Program should be relinked.\n");
	    printf("heapEnd = %x, bssFirstPage = %x, page size =%x\n",
		    heapEnd, execInfoPtr->bssFirstPage, vm_PageSize);
	}
	status = Vm_PageIn((execInfoPtr->bssFirstPage-1)*vm_PageSize, FALSE);
	if (status != SUCCESS) {
	    printf("SetupVM: heap prefetch failure\n");
	    return FALSE;
	}
	bzero((char *)heapEnd,
		vm_PageSize-((unsigned)heapEnd&(vm_PageSize-1)));
@


9.11
log
@Put in print statement to warn about misaligned files.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.10 90/03/16 14:20:43 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
d1827 19
a1845 2
		printf("Proc_Exec: can't run %s (0%03o) a.out file on %s\n",
		    name, magic, mach_MachineType);
@


9.10
log
@I had an extra parameter in the call to Vm_PageIn, which I've removed.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.9 90/03/14 13:55:23 rab Exp Locker: shirriff $ SPRITE (Berkeley)";
d1515 6
@


9.9
log
@Calculate the number of machine types at compile time, rather than
hard coded.  This is because the distribution doesn't support the spur.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.8 90/02/11 21:21:12 shirriff Exp Locker: rab $ SPRITE (Berkeley)";
d1515 1
a1515 2
	status = Vm_PageIn((execInfoPtr->bssFirstPage-1)*vm_PageSize,
		FALSE, procPtr);
@


9.8
log
@!Fixed problems with OMAGIC code.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.7 90/02/07 23:04:44 shirriff Exp Locker: shirriff $ SPRITE (Berkeley)";
a1771 1
#define MACHINECOUNT 4
d1818 1
a1818 1
    for (i=0;i<MACHINECOUNT;i++) {
@


9.7
log
@Changed SetupVM to prefetch heap page if heap and bss overlap.
This is to allow OMAGIC files to be executed.
Added code to check file type if exec fails, so shell won't try
running other machines' a.out files.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.6 90/01/29 18:07:15 douglis Exp Locker: shirriff $ SPRITE (Berkeley)";
d1393 1
d1429 7
d1448 5
a1452 1
	Vm_InitCode(codeFilePtr, segPtr, execInfoPtr);
d1511 2
a1512 1
     * If heap does not match page boundary, prefetch the partial page.
d1514 9
a1522 3
    if (((unsigned)heapEnd & (vm_PageSize-1)) != 0 && notFound) {
	Vm_PageIn(heapEnd, FALSE, procPtr);
	return status;
a1523 1

@


9.6
log
@just changed a comment....
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.5 89/11/27 09:50:39 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d42 1
d1000 5
a1004 1
		status = PROC_BAD_AOUT_FORMAT;
d1346 5
d1391 2
d1409 1
d1412 7
d1498 8
d1753 60
@


9.5
log
@flag error if args too long.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.4 89/10/26 15:22:31 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d207 2
a208 3
 *	Process the Exec system call, including passing environment variables
 *	to the new program, and allowing the process to be thrown into
 *	the debugger on startup.
@


9.4
log
@added void casts for strcpy to make lint happy
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.3 89/10/23 10:30:42 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d554 2
a555 1
     * Copy in the arguments.
d558 1
d733 2
a734 1
				 * padding. */
d839 8
@


9.3
log
@fixed "degenerate unsigned comparison" lint message
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.2 89/10/23 08:38:14 brent Exp Locker: douglis $ SPRITE (Berkeley)";
d29 1
d41 1
d304 1
a304 1
    strncpy(execFileName, fileName, accessLength);
d1418 1
a1418 1
	(void) Fsio_StreamCopy(codeFilePtr, &heapFilePtr);
d1541 1
a1541 1
    strncpy(bufPtr, encapPtr->hdr.fileName, encapPtr->hdr.fileNameLength);
d1543 1
a1543 1
    strncpy(bufPtr, encapPtr->hdr.argString, encapPtr->hdr.argLength);
d1582 1
a1582 1
    strncpy(encapPtr->hdr.argString, argString, encapPtr->hdr.argLength);
@


9.2
log
@Updated calls to new FS modules
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.1 89/09/20 16:16:55 mgbaker Exp Locker: brent $ SPRITE (Berkeley)";
d1387 1
a1387 1
	if (objInfoPtr->bssSize > 0) {
@


9.1
log
@Cache flush changes for sun4
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 9.0 89/09/12 15:15:00 douglis Stable Locker: mgbaker $ SPRITE (Berkeley)";
d1416 1
a1416 1
	(void) Fs_StreamCopy(codeFilePtr, &heapFilePtr);
@


9.0
log
@Changing version numbers.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.17 89/08/30 12:56:54 mgbaker Exp Locker: douglis $ SPRITE (Berkeley)";
d1454 1
@


8.17
log
@sun4 performance opts.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.16 89/08/10 17:15:57 douglis Exp Locker: mgbaker $ SPRITE (Berkeley)";
@


8.16
log
@reset remoteExecBuffer.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.15 89/07/20 11:19:23 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d1453 3
@


8.15
log
@fixed bug relating to Proc_Exec(...., my_host) causing an RPC panic.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.14 89/07/20 11:04:09 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d1057 1
@


8.14
log
@mgbaker: removed sun4 ifdef's.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.13 89/07/10 19:11:21 nelson Exp Locker: mgbaker $ SPRITE (Berkeley)";
d39 1
d191 1
d346 9
@


8.13
log
@Incorporated changes from DECWRL.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.12 89/06/22 17:18:36 douglis Exp $ SPRITE (Berkeley)";
a402 3
#ifdef sun4
    printf("Turning proc 0x%x into a user process.\n", procPtr);
#endif sun4
a979 8
#ifdef notdef
#ifdef sun4
	if ((aoutPtr->machineType & 0x0f) != PROC_SPARC) {
	    status = PROC_BAD_AOUT_FORMAT;
	    goto execError;
	}
#endif sun4
#endif
@


8.12
log
@free up VM resources before a remote exec.  don't free fileName if
it wasn't passed in from user mode, on error.

@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.11 89/06/17 15:04:15 mendel Exp Locker: douglis $ SPRITE (Berkeley)";
d22 1
a34 1
#include "procAOUT.h"
a885 1
    register	Proc_AOUT		*aoutPtr;
d887 1
a887 1
    Proc_AOUT				aout;
a899 1
    int					entry;
d906 1
d949 1
d957 3
a959 1
	sizeRead = PROC_MAX_INTERPRET_SIZE;
d970 1
a970 1
				    &shellArgPtr, &extraArgs, &aout); 
a974 2
	    sizeRead = sizeof(Proc_AOUT);
	    aoutPtr = &aout;
d977 5
a981 1
	    aoutPtr = (Proc_AOUT *) buffer;
d983 1
a983 5
	if (codeSegPtr == (Vm_Segment *) NIL && 
	    (sizeRead < sizeof(Proc_AOUT) || PROC_BAD_MAGIC_NUMBER(*aoutPtr))) {
	    status = PROC_BAD_AOUT_FORMAT;
	    goto execError;
	}
d990 1
d1119 5
a1123 2
    if (!SetupVM(procPtr, aoutPtr, filePtr, usedFile, &codeSegPtr, 
		 execInfoPtr, &entry)) {
d1175 1
a1175 1
    Mach_ExecUserProc(procPtr, userStackPointer, (Address) entry);
d1248 1
a1248 1
	       extraArgsPtr, aoutPtr)
d1256 1
a1256 1
    Proc_AOUT		*aoutPtr;	/* Place to read a.out header into. */
d1262 1
d1320 3
a1322 3
    sizeRead = sizeof(Proc_AOUT);
    status = Fs_Read(*filePtrPtr, (Address) aoutPtr, 0, &sizeRead);
    if (status == SUCCESS && sizeRead != sizeof(Proc_AOUT)) {
d1324 2
a1332 1

d1353 1
a1353 2
SetupVM(procPtr, aoutPtr, codeFilePtr, usedFile, codeSegPtrPtr, execInfoPtr, 
	entryPtr)
d1355 1
a1355 1
    register	Proc_AOUT		*aoutPtr;
a1359 1
    int					*entryPtr;
a1366 1
    Vm_ExecInfo			execInfo;
d1370 4
a1373 4
	execInfoPtr = &execInfo;
	execInfoPtr->entry = aoutPtr->entry;
	if (aoutPtr->data != 0) {
	    execInfoPtr->heapPages = (aoutPtr->data - 1) / vm_PageSize + 1;
d1377 3
a1379 2
	if (aoutPtr->bss != 0) {
	    execInfoPtr->heapPages += (aoutPtr->bss - 1) / vm_PageSize + 1;
d1382 2
a1383 3
			PROC_DATA_LOAD_ADDR(*aoutPtr) / vm_PageSize;
	execInfoPtr->heapFileOffset = 
			(int) PROC_DATA_FILE_OFFSET(*aoutPtr);
d1385 2
a1386 2
			PROC_BSS_LOAD_ADDR(*aoutPtr) / vm_PageSize;
	if (aoutPtr->bss > 0) {
d1388 1
a1388 1
				       (aoutPtr->bss - 1) / vm_PageSize);
d1395 3
a1397 3
	numPages = (aoutPtr->code - 1) / vm_PageSize + 1;
	fileOffset = PROC_CODE_FILE_OFFSET(*aoutPtr);
	pageOffset = PROC_CODE_LOAD_ADDR(*aoutPtr) / vm_PageSize;
a1459 2

    *entryPtr = execInfoPtr->entry;
@


8.11
log
@Added code to insure that user's stack pointer starts aligned.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.10 89/06/09 17:49:50 douglis Exp $ SPRITE (Berkeley)";
d1077 2
a1078 1
     * return to our caller.
d1082 20
d1213 1
a1213 1
    if (!importing && (fileName != (char *) NIL)) {
@


8.10
log
@
changes for remote exec.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.9 89/06/07 12:56:57 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d592 1
a592 1
    stackSize = bufSize - sizeof(ExecEncapHeader);
@


8.9
log
@another interim state.  this has the framework for distinguishing between
local and remote exec's, and returning the encapsulated data for remote
ones, but no way yet to start a foreign process and exec it using the
encapsulated data.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.8 89/05/25 15:27:14 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d35 1
d82 2
d88 6
a93 1
    int debug;			/* whether to debug on startup */
d187 3
d191 3
a193 5
    if (status == SUCCESS) {
	/*
	 * Do something here to cause migration.
	 */
    }
d252 5
a256 2
 *	The argument & environment arrays are made accessible.
 *	The setup routine makes them unaccessible.
d282 1
a282 1
    char 		execFileName[FS_MAX_PATH_NAME_LENGTH];
d285 1
d299 2
a300 1
    strncpy(execFileName, fileName, FS_MAX_PATH_NAME_LENGTH);
a349 3
    if (status != SUCCESS || host != 0) {
	return(status);
    }
d351 17
a367 1
	panic("Proc_Exec: DoExec returned SUCCESS!!!\n");
a368 1

d906 2
d913 12
d992 36
a1027 13
    /*
     * Set up whatever special arguments we might have due to an
     * interpreter file.  If the
     */
    if (extraArgs > 0) {
	int i;
	int index;
	
	if (userArgsPtr->argPtrArray == (char **) NIL) {
	    extraArgsArray[0] = fileName;
	    index = 1;
	} else {
	    index = 0;
d1029 14
a1042 5
	for (i = index; extraArgs > 0; i++, extraArgs--) {
	    if (extraArgs == 2) {
		extraArgsArray[i] = shellArgPtr;
	    } else {
		extraArgsArray[i] = fileName;
d1045 14
a1058 11
	extraArgsArray[i] = (char *) NIL;
	extraArgsPtrPtr = extraArgsArray;
    } else {
	extraArgsPtrPtr = (char **) NIL;
    }
    /*
     * Copy in the argument list and environment into a single contiguous
     * buffer.
     */
    status = SetupArgs(userArgsPtr, extraArgsPtrPtr,
		       &argBuffer, &argString);
a1059 4
    if (status != SUCCESS) {
	goto execError;
    }

d1061 1
a1061 1
     * We no longer need access to the old arguments or the environment. 
d1063 2
a1064 11
    if (userArgsPtr->userMode) {
	if (userArgsPtr->argPtrArray != (char **) NIL) {
	    Vm_MakeUnaccessible((Address) userArgsPtr->argPtrArray,
				userArgsPtr->numArgs * 4);
	    userArgsPtr->argPtrArray = (char **)NIL;
	}
	if (userArgsPtr->envPtrArray != (char **) NIL) {
	    Vm_MakeUnaccessible((Address) userArgsPtr->envPtrArray,
				userArgsPtr->numEnvs * 4);
	    userArgsPtr->envPtrArray = (char **)NIL;
	}
d1066 1
d1069 2
a1070 1
     * Close any streams that have been marked close-on-exec.
d1072 3
a1074 2
    Fs_CloseOnExec(procPtr);

d1079 5
a1083 3
    if ((encapPtrPtr != (ExecEncapState **) NIL) &&
	(userArgsPtr != (UserArgs *) NIL)) {
	*encapPtrPtr = (ExecEncapState *) argBuffer;
d1087 8
a1110 1
    encapPtr = (ExecEncapState *) argBuffer;
d1119 1
a1119 1
    
d1121 1
a1121 1
     * Do set uid and set gid here.
a1122 3
    if (uid != -1) {
	procPtr->effectiveUserID = uid;
    }
d1137 1
a1137 1
    if (procPtr->genFlags & PROC_FOREIGN) {
a1139 4
    if (procPtr->argString != (char *) NIL) {
	free(procPtr->argString);
    }
    procPtr->argString = argString;
d1174 1
a1174 1
    if (userArgsPtr->userMode) {
d1192 4
d1441 245
@


8.8
log
@changes to use an interim buffer for exec, which can now be passed
off for remote exec.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.7 89/05/21 18:27:08 mgbaker Exp $ SPRITE (Berkeley)";
d42 5
d48 4
a51 1
extern char *malloc();
d53 1
a53 1
#define NEWEXEC
d68 49
d118 70
d192 1
a192 1
 * Proc_Exec --
d194 3
a196 4
 *	Process the Exec system call.  This just calls Proc_ExecEnv
 *	with a NULL environment.  This should simulate past behavior,
 *	in which all processes were set up by unixCrt0.s with a NULL
 *	environment on their stack.
d209 1
a209 1
Proc_Exec(fileName, argPtrArray, debugMe)
d213 2
d219 1
a219 3
    int status;			/* status in case Proc_ExecEnv returns */
    status = Proc_ExecEnv(fileName, argPtrArray, (char **) USER_NIL, debugMe);
    return(status);
d226 1
a226 7
 * Proc_ExecEnv --
 *
 *	Process the Exec system call.
 *
 * Results:
 *	This process will not return unless an error occurs in which case it
 *	returns the error.
d228 17
a244 2
 * Side effects:
 *	None.
d250 1
a250 1
Proc_ExecEnv(fileName, argPtrArray, envPtrArray, debugMe)
d259 2
d266 1
d271 3
d286 1
a286 1
    strcpy(execFileName, fileName);
d322 17
a338 3
    status = DoExec(execFileName, newArgPtrArray, 
			   newArgPtrArrayLength / sizeof(Address), newEnvPtrArray, 
			   newEnvPtrArrayLength / sizeof(Address), TRUE, debugMe);
d340 1
a340 1
	panic("Proc_ExecEnv: DoExec returned SUCCESS!!!\n");
d374 1
d419 6
a424 2
    status = DoExec(fileName, argPtrArray,
		    PROC_MAX_EXEC_ARGS, (char **) NIL, 0, FALSE, FALSE);
a443 25
static ReturnStatus	SetupInterpret();
static ReturnStatus	SetupArgs();
static ReturnStatus	GrabArgArray();
static Boolean		SetupVM();

/*
 * Define the header of the structure to be copied onto the user's
 * stack during an exec. The base & size are actually not copied onto
 * the stack, and the remainder of the structure is variable-length.
 */
typedef struct {
    Address base;		/* base of the structure in user space */
    int size;			/* size of the entire structure */
    /*
     * User stack data starts here.
     */
    int argc;			/* Number of arguments */
    /*
     * argv[] goes here
     * envp[] goes here
     * *argv[] goes here
     * *envp[] goes here
     */
} UserStackArgs;

d461 1
a461 1
 *	The format of the structure is defined by UserStackArgs above.
d477 3
a479 9
SetupArgs(argPtrArray, numArgs, envPtrArray,
	  numEnvs, userProc, extraArgArray, argStackPtr, argStackSizePtr,
	  argStringPtr)
    char     **argPtrArray;	/* The array of argument pointers. */
    int	     numArgs;		/* The number of arguments in the argArray. */
    char     **envPtrArray;	/* The array of environment pointers. */
    int	     numEnvs;		/* The number of arguments in the envArray. */
    Boolean  userProc;		/* Set if the calling process is a user 
	     			 * process. */
a483 2
    int      *argStackSizePtr; 	/* Pointer to contain size of encapsulated
				 * stack. */
d487 2
d505 3
a507 1
    UserStackArgs			*hdrPtr;
d520 1
a520 1

d522 2
a523 1
			  userProc, extraArgArray, argPtrArray, &numArgs,
d535 5
a539 2
    status = GrabArgArray(PROC_MAX_ENVIRON_LENGTH + 1, userProc, (char **) NIL,
			  envPtrArray, &numEnvs, &envList, (int *) NIL,
d559 1
a559 1
    bufSize = sizeof(UserStackArgs) + (numArgs + numEnvs + 2) * sizeof(Address)
a560 1
    *argStackSizePtr = bufSize;
d563 7
a569 5
    hdrPtr = (UserStackArgs *) buffer;
    hdrPtr->size = bufSize - ((Address) &hdrPtr->argc - buffer);
    hdrPtr->base = mach_MaxUserStackAddr - hdrPtr->size;
    hdrPtr->argc = numArgs;
    newArgPtrArray = (char **) (buffer + sizeof(UserStackArgs));
d577 1
a577 1
    usp = (int)hdrPtr->base + (int) argBuffer - (int) &hdrPtr->argc;
d828 4
a831 2
 *	Exec a new program.  The current process image is overlayed by the 
 *	newly exec'd program.
d833 5
a837 3
 * Results:
 *	This routine does not return unless an error occurs in which case the
 *	error code is returned.
d848 1
a848 2
DoExec(fileName, argPtrArray, numArgs, envPtrArray, numEnvs,
       userProc, debugMe)
d850 5
a854 6
    char	**argPtrArray;	/* The array of argument pointers. */
    int		numArgs;	/* The number of arguments in the argArray. */
    char	**envPtrArray;	/* The array of environment pointers. */
    int		numEnvs;	/* The number of arguments in the envArray. */
    Boolean	userProc;	/* Set if the calling process is a user 
				 * process. */
a865 1
    int					argBufferSize;
d879 1
a879 1
    UserStackArgs			*hdrPtr;
d960 1
a960 1
	if (argPtrArray == (char **) NIL) {
d982 2
a983 4
    status = SetupArgs(argPtrArray, numArgs, envPtrArray,
		       numEnvs, userProc, extraArgsPtrPtr,
		       &argBuffer, &argBufferSize,
		       &argString);
d992 10
a1001 4
    if (userProc) {
	if (argPtrArray != (char **) NIL) {
	    Vm_MakeUnaccessible((Address) argPtrArray, numArgs * 4);
	    argPtrArray = (char **)NIL;
a1002 4
	if (envPtrArray != (char **) NIL) {
	    Vm_MakeUnaccessible((Address) envPtrArray, numEnvs * 4);
	    envPtrArray = (char **)NIL;
	}
d1006 14
d1036 4
a1039 4
    hdrPtr = (UserStackArgs *) argBuffer;
    argBytes = hdrPtr->size;
    userStackPointer = hdrPtr->base;
    status = Vm_CopyOut(argBytes, (Address) &hdrPtr->argc,
a1046 5
     * Close any streams that have been marked close-on-exec.
     */
    Fs_CloseOnExec(procPtr);

    /*
d1076 1
d1107 5
a1111 3
    if (userProc) {
	if (argPtrArray != (char **) NIL) {
	    Vm_MakeUnaccessible((Address) argPtrArray, numArgs * 4);
d1113 4
a1116 2
	if (envPtrArray != (char **) NIL) {
	    Vm_MakeUnaccessible((Address) envPtrArray, numEnvs * 4);
@


8.7
log
@checkin before sprint cleaning
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.6 89/03/26 20:17:02 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d37 4
d181 3
a183 3
    status = DoExec(execFileName, strLength, newArgPtrArray, 
			   newArgPtrArrayLength / 4, newEnvPtrArray, 
			   newEnvPtrArrayLength / 4, TRUE, debugMe);
d263 1
a263 1
    status = DoExec(fileName, strlen(fileName), argPtrArray,
d285 2
d289 397
a694 4
 *	Note: environments are now being added; after they work, I can
 *	think about coalescing some of the code rather than duplicating
 *	it.
 *
d701 1
a701 1
 *	the argPtrArray and envPtrArray are made unaccessible if they this
d708 1
a708 1
DoExec(fileName, fileNameLength, argPtrArray, numArgs, envPtrArray, numEnvs,
a710 1
    int		fileNameLength;	/* The length of the file name. */
a721 1
    register	ArgListElement	*argListPtr;
a722 7
    register	char			**argPtr;
    register	int			argNumber;
    register	char			**envPtr;
    ArgListElement			*envListPtr;
    int					envNumber;
    int					origNumArgs;
    int					origNumEnvs;
a723 3
    char				**newArgPtrArray;
    char				**newEnvPtrArray;
    int					tArgNumber;
a724 2
    List_Links				argList;
    List_Links				envList;
d726 3
a728 4
    char				*copyAddr;
    int					copyLength;
    register	char			*argString;
    int					argStringLength;
d734 2
a737 1
    int					usp;
d742 1
a742 4
    char				*stringPtr;
    int					stringLength;
    int					realLength;
    Boolean 				accessible;
d744 3
a746 2
    origNumArgs = numArgs;
    origNumEnvs = numEnvs;
a748 2
    List_Init(&argList);
    List_Init(&envList);
d816 2
a817 2
     * The total number of arguments is the number passed in plus the
     * number of extra arguments because is an interpreter file.
d819 11
a829 33
    if (argPtrArray == (char **) NIL) {
	numArgs = extraArgs;
    } else {
	numArgs += extraArgs;
    }
    argStringLength = 0;

    /*
     * Copy in all of the arguments.  If we are executing a normal
     * program then we just copy in the arguments as is.  If this is
     * an interpreter file then we do the following:
     *
     *	1) If the user passed in arguments, then arg[0] is left alone.
     *	2) If arguments were passed to the interpreter program in the
     *	   interpreter file then they are placed in arg[1].
     *  3) The name of the interpreter file is placed in arg[1] or arg[2]
     *	   depending if there were interpreter arguments from step 2.
     *  3) Original arguments arg[1] through arg[n] are shifted over.
     */
    userStackPointer = mach_MaxUserStackAddr;
#ifdef sun4
    /*
     * I'm requiring the user stack pointer to be double-word aligned, for now.
     */
    (unsigned int) userStackPointer &= ~7;
#endif sun4
    for (argNumber = 0, argPtr = argPtrArray; 
	 argNumber < numArgs;
	 argNumber++) {

	accessible = FALSE;

	if ((argNumber > 0 || argPtrArray == (char **) NIL) && extraArgs > 0) {
d831 1
a831 14
		stringPtr = shellArgPtr;
		realLength = strlen(shellArgPtr) + 1;
	    } else {
		stringPtr = fileName;
		realLength = fileNameLength + 1;
	    }
	    extraArgs--;
	} else {
	    if (!userProc) {
		if (*argPtr == (char *) NIL) {
		    break;
		}
		stringPtr = *argPtr;
		stringLength = PROC_MAX_EXEC_ARG_LENGTH;
d833 1
a833 13
		if (*argPtr == (char *) USER_NIL) {
		    break;
		}
		Vm_MakeAccessible(VM_READONLY_ACCESS,
				  PROC_MAX_EXEC_ARG_LENGTH + 1, 
				  (Address) *argPtr, 
				  &stringLength,
				  (Address *) &stringPtr);
		if (stringLength == 0) {
		    status = SYS_ARG_NOACCESS;
		    goto execError;
		}
		accessible = TRUE;
a834 16
	    /*
	     * Find out the length of the argument.  Because of accessibility
	     * limitations the whole string may not be available.
	     */
	    {
		register char *charPtr;
		for (charPtr = stringPtr, realLength = 0;
		     (realLength < stringLength) && (*charPtr != '\0');
		     charPtr++, realLength++) {
		}
		realLength++;
	    }
	    /*
	     * Move to the next argument.
	     */
	    argPtr++;
d836 4
a839 35

	/*
	 * Put this string onto the argument list.
	 */
	argListPtr = (ArgListElement *)
		malloc(sizeof(ArgListElement));
	argListPtr->stringPtr =  malloc(realLength);
	argListPtr->stringLen = realLength;
	List_InitElement((List_Links *) argListPtr);
	List_Insert((List_Links *) argListPtr, LIST_ATREAR(&argList));
	/*
	 * Make room on the stack for this string.  Make it 4 byte aligned.
	 * Also up the amount needed to save the argument list.
	 */
#ifndef sun4
	userStackPointer -= ((realLength) + 3) & ~3;
#else
	/*
	 * For initial sun4 port, I'm requiring the user stack pointer to
	 * be double-word aligned.
	 */
	userStackPointer -= ((realLength) + 7) & ~7;
#endif /* sun4 */
	argStringLength += realLength;
	/*
	 * Copy over the argument and ensure null termination.
	 */
	bcopy((Address) stringPtr, (Address) argListPtr->stringPtr, realLength);
	argListPtr->stringPtr[realLength-1] = '\0';
	/*
	 * Clean up 
	 */
	if (accessible) {
	    Vm_MakeUnaccessible((Address) stringPtr, stringLength);
	}
a840 1

d842 2
a843 1
     * Copy in the environment.
d845 7
a851 76
    for (envNumber = 0, envPtr = envPtrArray; 
	 envNumber < numEnvs;
	 envNumber++) {

	accessible = FALSE;

	if (!userProc) {
	    if (*envPtr == (char *) NIL) {
		break;
	    }
	    stringPtr = *envPtr;
	    stringLength = PROC_MAX_ENVIRON_LENGTH;
	} else {
	    if (*envPtr == (char *) USER_NIL) {
		break;
	    }
	    Vm_MakeAccessible(VM_READONLY_ACCESS,
			      PROC_MAX_ENVIRON_LENGTH + 1, 
			      (Address) *envPtr, 
			      &stringLength,
			      (Address *) &stringPtr);
	    if (stringLength == 0) {
		status = SYS_ARG_NOACCESS;
		goto execError;
	    }
	    accessible = TRUE;
	}
	/*
	 * Find out the length of the environment variable.  Because of
	 * accessibility limits the whole string may not be available.
	 */
	{
	    register char *charPtr;
	    for (charPtr = stringPtr, realLength = 0;
		 (realLength < stringLength) && (*charPtr != '\0');
		 charPtr++, realLength++) {
	    }
	    realLength++;
	}
	/*
	 * Move to the next environment variable.
	 */
	envPtr++;

	/*
	 * Put this string onto the environment variable list.
	 */
	envListPtr = (ArgListElement *) 
		malloc(sizeof(ArgListElement));
	envListPtr->stringPtr =  malloc(realLength);
	envListPtr->stringLen = realLength;
	List_InitElement((List_Links *) envListPtr);
	List_Insert((List_Links *) envListPtr, LIST_ATREAR(&envList));
	/*
	 * Make room on the stack for this string.  Make it 4 byte aligned.
	 */
#ifndef sun4
	userStackPointer -= ((realLength) + 3) & ~3;
#else
	/*
	 * For the initial sun4 port, I'm requiring the user stack pointer
	 * to be double-word aligned.
	 */
	userStackPointer -= ((realLength) + 7) & ~7;
#endif /* sun4 */
	/*
	 * Copy over the environment variable and ensure null termination.
	 */
	bcopy((Address) stringPtr, (Address) envListPtr->stringPtr, realLength);
	envListPtr->stringPtr[realLength-1] = '\0';
	/*
	 * Clean up 
	 */
	if (accessible) {
	    Vm_MakeUnaccessible((Address) stringPtr, stringLength);
	}
d859 1
a859 1
	    Vm_MakeUnaccessible((Address) argPtrArray, origNumArgs * 4);
d863 1
a863 1
	    Vm_MakeUnaccessible((Address) envPtrArray, origNumEnvs * 4);
d885 5
a889 12
    argBytes = mach_MaxUserStackAddr - userStackPointer;
    (void) Vm_MakeAccessible(VM_READWRITE_ACCESS,
			  argBytes, userStackPointer,
			  &copyLength, (Address *) &copyAddr);
    newArgPtrArray = (char **) malloc((argNumber + 1) * sizeof(Address));
    argNumber = 0;
    usp = (int)userStackPointer;
    argString = malloc(argStringLength + 1);
    if (procPtr->argString != (char *) NIL) {
	free(procPtr->argString);
    }
    procPtr->argString = argString;
d891 2
a892 21
    while (!List_IsEmpty(&argList)) {
	argListPtr = (ArgListElement *) List_First(&argList);
	/*
	 * Copy over the argument.
	 */
	bcopy((Address) argListPtr->stringPtr, (Address) copyAddr,
		    argListPtr->stringLen);
	newArgPtrArray[argNumber] = (char *) usp;
	copyAddr += ((argListPtr->stringLen) + 3) & ~3;
	usp += ((argListPtr->stringLen) + 3) & ~3;
	bcopy((Address) argListPtr->stringPtr, argString,
		    argListPtr->stringLen - 1);
	argString[argListPtr->stringLen - 1] = ' ';
	argString += argListPtr->stringLen;
	/*
	 * Clean up
	 */
	List_Remove((List_Links *) argListPtr);
	free((Address) argListPtr->stringPtr);
	free((Address) argListPtr);
	argNumber++;
a893 1
    argString[0] = '\0';
a894 57
    newEnvPtrArray = (char **) malloc((envNumber + 1) * sizeof(Address));
    envNumber = 0;
    while (!List_IsEmpty(&envList)) {
	envListPtr = (ArgListElement *) List_First(&envList);
	/*
	 * Copy over the environment variable.
	 */
	bcopy((Address) envListPtr->stringPtr, (Address) copyAddr,
		    envListPtr->stringLen);
	newEnvPtrArray[envNumber] = (char *) usp;
	copyAddr += ((envListPtr->stringLen) + 3) & ~3;
	usp += ((envListPtr->stringLen) + 3) & ~3;
	/*
	 * Clean up 
	 */
	List_Remove((List_Links *) envListPtr);
	free((Address) envListPtr->stringPtr);
	free((Address) envListPtr);
	envNumber++;
    }
    Vm_MakeUnaccessible(copyAddr - argBytes, argBytes);
    /*
     * The stack ends up in the following state:  the top word is argc.
     * Right below this is the array of pointers to arguments (argv).  Right
     * below this is the array of pointers to environment stuff (envp).  So,
     * to figure out the address of argv, one simply adds a word to the address
     * of the top of the stack.  To figure out the address of envp, one
     * looks at argc and skips over the appropriate amount of space to jump
     * over argc and argv = (1 + (argc + 1)) * 4 bytes.  The extra "1" is for
     * the null argument at the end of argv.  Below all that stuff on the
     * stack, but not necessarily immediately below, are the environment and
     * argument stuff copied there earlier.
     */
    copyLength = (argNumber + envNumber + 2) * sizeof(Address) + sizeof(int);
    newArgPtrArray[argNumber] = (char *) USER_NIL;
    newEnvPtrArray[envNumber] = (char *) USER_NIL;
#ifndef sun4
    userStackPointer -= copyLength;
#else /* sun4 */
    userStackPointer -= ((copyLength) + 7) & ~7;
#endif /* sun4 */
    tArgNumber = argNumber;
    (void) Vm_CopyOut(sizeof(int), (Address) &tArgNumber,
		      userStackPointer);
    (void) Vm_CopyOut((argNumber + 1) * sizeof(Address),
		      (Address) newArgPtrArray,
		      userStackPointer + sizeof(int));
    (void) Vm_CopyOut((envNumber + 1) * sizeof(Address),
		      (Address) newEnvPtrArray,
		      userStackPointer + sizeof(int) +
		      (argNumber + 1) * sizeof(Address));
    /*
     * Free the arrays of arguments and environment variables.
     */
    free((Address) newArgPtrArray);
    free((Address) newEnvPtrArray);

d923 4
d929 2
d962 1
a962 1
	    Vm_MakeUnaccessible((Address) argPtrArray, origNumArgs * 4);
d965 1
a965 1
	    Vm_MakeUnaccessible((Address) envPtrArray, origNumEnvs * 4);
d968 2
a969 5
    while (!List_IsEmpty(&argList)) {
	argListPtr = (ArgListElement *) List_First(&argList);
	List_Remove((List_Links *) argListPtr);
	free((Address) argListPtr->stringPtr);
	free((Address) argListPtr);
d971 2
a972 5
    while (!List_IsEmpty(&envList)) {
	envListPtr = (ArgListElement *) List_First(&envList);
	List_Remove((List_Links *) envListPtr);
	free((Address) envListPtr->stringPtr);
	free((Address) envListPtr);
@


8.6
log
@Seventeenth Kernel for the sun4.  It executes its first system call:
Sys_Shutdown().
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.5 89/03/22 14:08:02 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
a22 3
#ifdef sun4
#include "machMon.h"
#endif sun4
d426 6
d458 6
d740 1
d742 2
a743 2
#ifdef sun4
    userStackPointer -= ((realLength) + 7) & ~7;
a795 3
#ifdef sun4
    Mach_MonPrintf("Calling Mach_ExecUserProc with userStackPtr 0x%x, argc %d\n", userStackPointer, tArgNumber);
#endif sun4
a988 5
#ifdef sun4
    printf("SetupVM for procPtr 0x%x\n", procPtr);
    printf("aoutPtr->data = %d, bss = %d, code = %d\n", aoutPtr->data,
	    aoutPtr->bss, aoutPtr->code);
#endif sun4
a1041 5
#ifdef sun4
	printf("execInfoPtr->heapPages = %d\n", execInfoPtr->heapPages);
	printf("execInfoPtr->heapPageOffset = %d\n",
		execInfoPtr->heapPageOffset);
#endif sun4
@


8.5
log
@For the sun4:  with these changes a user process starts and gets
a successful page fault on its stack.  I don't think it's returning
to the user process correctly, though.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.4 89/03/02 18:41:46 douglis Exp Locker: mgbaker $ SPRITE (Berkeley)";
d220 3
d982 5
d1040 5
@


8.4
log
@fixed some forward declarations to say "static"
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.3 89/02/19 22:07:06 jhh Exp Locker: douglis $ SPRITE (Berkeley)";
d23 3
a260 1

d520 1
d522 7
d602 1
d604 7
d714 10
a723 2
     * Now copy the array of arguments plus argc, the address of argv, and
     * the address of envp onto the stack.
d729 3
d783 3
@


8.3
log
@Changes due to lock registration
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.2 88/12/04 15:17:11 ouster Exp $ SPRITE (Berkeley)";
d278 2
a279 2
ReturnStatus	SetupInterpret();
Boolean		SetupVM();
@


8.2
log
@
Stop using obsolete header files.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.1 88/11/22 19:32:28 jhh Exp $ SPRITE (Berkeley)";
d28 1
a28 1
#include "mem.h"
d366 5
@


8.1
log
@new semaphore definition
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 8.0 88/11/11 18:29:43 douglis Stable Locker: jhh $ SPRITE (Berkeley)";
a31 1
#include "char.h"
a35 1
#include "byte.h"
@


8.0
log
@Changing version numbers.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 6.10 88/11/10 17:05:58 douglis Exp Locker: douglis $ SPRITE (Berkeley)";
d25 2
a28 2
#include "sync.h"
#include "sched.h"
@


6.10
log
@make Proc_Exec go back home to update the argument string and effective userID.
(Group ID is currently ignored since it's used only by the FS on the
remote machine).
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 6.9 88/11/08 15:58:37 brent Exp Locker: douglis $ SPRITE (Berkeley)";
@


6.9
log
@Inlined calls to String_NLength and added in null termination
of overly long arguments or environment variables.
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 6.8 88/11/01 16:36:41 douglis Exp Locker: brent $ SPRITE (Berkeley)";
d740 3
@


6.8
log
@fixed a  compiler complaint due to malloc not being predeclared 
as a char *().
@
text
@d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 6.7 88/10/28 19:01:22 mlgray Exp Locker: douglis $ SPRITE (Berkeley)";
d485 2
a486 1
	     * Find out the length of the argument.
d488 8
a495 1
	    realLength = String_NLength(stringLength, stringPtr) + 1;
d518 1
a518 1
	 * Copy over the argument.
d521 1
d561 2
a562 1
	 * Find out the length of the environment variable.
d564 8
a571 1
	realLength = String_NLength(stringLength, stringPtr) + 1;
d591 1
a591 1
	 * Copy over the environment variable.
d594 1
@


6.7
log
@More conversion to new C library.
@
text
@a6 4
 *	NOTE: this is temporarily coexisting with the original procExec.c.
 *	This file contains a version of Proc_Exec that takes the environment
 *	as an argument.
 *
d18 1
a18 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 6.6 88/10/27 20:02:22 mlgray Exp Locker: mlgray $ SPRITE (Berkeley)";
d41 1
d499 1
a499 1
	argListPtr->stringPtr = (char *) malloc(realLength);
d565 1
a565 1
	envListPtr->stringPtr = (char *) malloc(realLength);
@


6.6
log
@1st pass at multi-processor, conversion to new C library.
@
text
@d22 1
a22 1
static char rcsid[] = "$Header: /sprite/src/kernel/proc/RCS/procExec.c,v 6.5 88/10/18 12:18:42 mlgray Exp $ SPRITE (Berkeley)";
d838 1
a838 1
    for (strPtr = &(buffer[2]); Char_IsSpace(*strPtr); strPtr++) {
d844 1
a844 1
    while (!Char_IsSpace(*strPtr) && *strPtr != '\0') {
d856 1
a856 1
	while (Char_IsSpace(*strPtr)) {
@


6.5
log
@update to new library
@
text
@d22 1
a22 1
static char rcsid[] = "$Header: procExec.c,v 6.4 88/09/08 09:14:44 brent Exp $ SPRITE (Berkeley)";
d146 1
a146 1
    (void) String_Copy(fileName, execFileName);
d186 1
a186 1
	Sys_Panic(SYS_FATAL, "Proc_ExecEnv: DoExec returned SUCCESS!!!\n");
d261 2
a262 3
    status = DoExec(fileName, String_Length(fileName),
		    argPtrArray, PROC_MAX_EXEC_ARGS, (char **) NIL, 0,
		    FALSE, FALSE);
d459 1
a459 1
		realLength = String_Length(shellArgPtr) + 1;
d501 2
a502 2
		Mem_Alloc(sizeof(ArgListElement));
	argListPtr->stringPtr = (char *) Mem_Alloc(realLength);
d515 1
a515 2
	Byte_Copy(realLength, (Address) stringPtr, 
		  (Address) argListPtr->stringPtr);
d567 2
a568 2
		Mem_Alloc(sizeof(ArgListElement));
	envListPtr->stringPtr = (char *) Mem_Alloc(realLength);
d579 1
a579 2
	Byte_Copy(realLength, (Address) stringPtr, 
		  (Address) envListPtr->stringPtr);
d623 1
a623 1
    newArgPtrArray = (char **) Mem_Alloc((argNumber + 1) * sizeof(Address));
d626 1
a626 1
    argString = Mem_Alloc(argStringLength + 1);
d628 1
a628 1
	Mem_Free(procPtr->argString);
d637 2
a638 3
	Byte_Copy(argListPtr->stringLen, 
		  (Address) argListPtr->stringPtr, 
		  (Address) copyAddr);
d642 2
a643 3
	Byte_Copy(argListPtr->stringLen - 1,
		  (Address) argListPtr->stringPtr, 
		  argString);
d650 2
a651 2
	Mem_Free((Address) argListPtr->stringPtr);
	Mem_Free((Address) argListPtr);
d656 1
a656 1
    newEnvPtrArray = (char **) Mem_Alloc((envNumber + 1) * sizeof(Address));
d663 2
a664 3
	Byte_Copy(envListPtr->stringLen, 
		  (Address) envListPtr->stringPtr, 
		  (Address) copyAddr);
d672 2
a673 2
	Mem_Free((Address) envListPtr->stringPtr);
	Mem_Free((Address) envListPtr);
d698 2
a699 2
    Mem_Free((Address) newArgPtrArray);
    Mem_Free((Address) newEnvPtrArray);
d734 1
a734 1
    Sys_Panic(SYS_FATAL, "DoExec: Proc_RunUserProc returned.\n");
d768 2
a769 2
	Mem_Free((Address) argListPtr->stringPtr);
	Mem_Free((Address) argListPtr);
d774 2
a775 2
	Mem_Free((Address) envListPtr->stringPtr);
	Mem_Free((Address) envListPtr);
@


6.4
log
@Fixed exec() so you don't need read permission on a
binary to execute it.
@
text
@d22 1
a22 1
static char rcsid[] = "$Header: procExec.c,v 6.3 88/08/31 17:55:12 douglis Exp $ SPRITE (Berkeley)";
d34 1
a34 1
#include "time.h"
@


6.3
log
@de-linted and endif-fix'ed.
@
text
@d22 1
a22 1
static char rcsid[] = "$Header: procExec.c,v 6.2 88/08/24 14:18:10 douglis Exp $ SPRITE (Berkeley)";
d377 1
a377 2
    status =  Fs_Open(fileName, (FS_READ | FS_EXECUTE | FS_FOLLOW), FS_FILE, 0,
		      &filePtr);
d875 2
a876 2
    status =  Fs_Open(shellNamePtr, (FS_READ | FS_EXECUTE | FS_FOLLOW),
		      FS_FILE, 0, filePtrPtr);
@


6.2
log
@added casts and got rid of an extra arg to Fs_StreamCopy to get rid
of lint complaints. backed out brent's FS_READ change for exec.
@
text
@d22 2
a23 2
static char rcsid[] = "$Header: procExec.c,v 6.1 88/08/23 17:06:32 brent Exp $ SPRITE (Berkeley)";
#endif not lint
d53 1
a53 1
#endif  PROC_MAX_ENVIRON_LENGTH
@


6.1
log
@Took away the need for FS_READ permission when exec'ing
@
text
@d22 1
a22 1
static char rcsid[] = "$Header: procExec.c,v 5.17 88/08/04 15:29:15 douglis Exp $ SPRITE (Berkeley)";
d146 1
a146 1
    String_Copy(fileName, execFileName);
d377 1
a377 1
    status =  Fs_Open(fileName, (FS_EXECUTE | FS_FOLLOW), FS_FILE, 0,
d740 1
a740 1
    Mach_ExecUserProc(procPtr, userStackPointer, entry);
d757 1
a757 1
		Fs_Close(filePtr);
d761 1
a761 1
	    Fs_Close(filePtr);
d826 1
a826 1
    Fs_Close(*filePtrPtr);
d876 2
a877 2
    status =  Fs_Open(shellNamePtr, (FS_EXECUTE | FS_FOLLOW), FS_FILE,
		      0, filePtrPtr);
d888 1
a888 1
	Fs_Close(*filePtrPtr);
d966 1
a966 1
	    Fs_Close(codeFilePtr);
d979 1
a979 1
	Fs_StreamCopy(codeFilePtr, &heapFilePtr, procPtr->processID);
d991 1
a991 1
	Fs_Close(heapFilePtr);
@


6.0
log
@Changing version numbers.
@
text
@d377 1
a377 1
    status =  Fs_Open(fileName, (FS_READ | FS_EXECUTE | FS_FOLLOW), FS_FILE, 0,
d876 1
a876 1
    status =  Fs_Open(shellNamePtr, (FS_READ | FS_EXECUTE | FS_FOLLOW), FS_FILE,
@


5.17
log
@removed duplicate include of mach.h
@
text
@d22 1
a22 1
static char rcsid[] = "$Header: procExec.c,v 5.16 88/07/25 17:02:40 nelson Exp $ SPRITE (Berkeley)";
@


5.16
log
@Minor changes for gcc.
@
text
@d22 1
a22 1
static char rcsid[] = "$Header: procExec.c,v 5.15 88/06/28 17:35:41 nelson Exp $ SPRITE (Berkeley)";
a42 1
#include "mach.h"
@


5.15
log
@Fixed problem when passed bad arg list to exec.
@
text
@d22 1
a22 1
static char rcsid[] = "$Header: procExec.c,v 5.14 88/05/05 17:57:30 nelson Exp $ SPRITE (Berkeley)";
d286 1
a286 1
Boolean		CopyInArgs();
@


5.14
log
@Handles move of functionality from sys to mach.
@
text
@d22 1
a22 1
static char rcsid[] = "$Header: procExec.c,v 5.13 88/05/04 16:45:35 nelson Exp $ SPRITE (Berkeley)";
a188 6
    if (newArgPtrArray != (char **) NIL) {
	Vm_MakeUnaccessible((Address) newArgPtrArray, newArgPtrArrayLength);
    }
    if (newEnvPtrArray != (char **) NIL) {
	Vm_MakeUnaccessible((Address) newEnvPtrArray, newEnvPtrArrayLength);
    }
d306 3
a308 1
 *	The state of the calling process is modified for the new image.
d381 2
a382 1
	return(status);
d413 2
a414 1
		return(status);
a528 7
     * We no longer need access to the old arguments. 
     */
    if (userProc && argPtrArray != (char **) NIL) {
	Vm_MakeUnaccessible((Address) argPtrArray, origNumArgs * 4);
    }

    /*
d594 1
a594 1
     * We no longer need access to the old environment variables. 
d596 9
a604 2
    if (userProc && envPtrArray != (char **) NIL) {
	Vm_MakeUnaccessible((Address) envPtrArray, origNumEnvs * 4);
d606 1
d763 8
@


5.13
log
@Uses new machine dependent routine.
@
text
@d22 1
a22 1
static char rcsid[] = "$Header: procExec.c,v 5.12 88/04/18 09:07:41 ouster Exp $ SPRITE (Berkeley)";
d26 1
d228 1
a228 1
    procPtr = Proc_GetCurrentProc(Sys_GetProcessorNumber());
d374 1
a374 1
    procPtr = Proc_GetActualProc(Sys_GetProcessorNumber());
a741 1
    Sys_DisableIntr();
@


5.12
log
@Lint cleanup, change copyright notices.
@
text
@d22 1
a22 1
static char rcsid[] = "$Header: procExec.c,v 5.11 88/04/12 15:51:57 douglis Exp $ SPRITE (Berkeley)";
a37 1
#include "machine.h"
d42 1
a707 12
    
    /*
     * Finally we are actually ready to start the new process.
     */
    procPtr->genRegs[SP] = (int)userStackPointer;
    procPtr->genFlags |= PROC_DONT_MIGRATE;
    if (debugMe) {
	procPtr->progCounter = entry - 2;
	procPtr->genFlags |= PROC_DEBUG_ON_EXEC;
    } else {
	procPtr->progCounter = entry;
    }
d728 6
d742 1
a742 2
    Proc_RunUserProc(procPtr->genRegs, procPtr->progCounter, Proc_Exit,
		    procPtr->stackStart + mach_ExecStackOffset);
@


5.11
log
@removed extraneous variable declaration of "itemPtr" in DoExec.
@
text
@d11 8
a18 2
 * Copyright (C) 1985 Regents of the University of California
 * All rights reserved.
d22 1
a22 1
static char rcsid[] = "$Header: procExec.c,v 5.10 88/03/08 14:13:33 douglis Exp $ SPRITE (Berkeley)";
d27 1
@


5.10
log
@Changed execFileName not to be static, since it used to be
possible for the name to get clobbered if a Proc_Exec call was suspended
during an Fs_Open and another Exec call took place.
Also, fixed a bug having to do with previous change of keeping null
character in string counts for arguments.
@
text
@d16 1
a16 1
static char rcsid[] = "$Header: procExec.c,v 5.9 88/03/02 11:54:50 douglis Exp $ SPRITE (Berkeley)";
a329 1
    register	List_Links		*itemPtr;
@


5.9
log
@Dynamically allocate a string to hold the list of arguments to
Exec and store it in the PCB.
@
text
@d16 1
a16 1
static char rcsid[] = "$Header: procExec.c,v 5.8 88/02/29 11:19:00 nelson Exp $ SPRITE (Berkeley)";
a38 2
static	char execFileName[FS_MAX_PATH_NAME_LENGTH];

d126 1
d128 1
d457 1
a457 1
		realLength = String_Length(shellArgPtr);
d460 1
a460 1
		realLength = fileNameLength;
@


5.8
log
@Changed VmMach_SetupContext to VmMach_ReinitContext.  [ci by FD]
@
text
@d16 1
a16 1
static char rcsid[] = "$Header: procExec.c,v 5.7 88/02/24 12:29:21 brent Exp $ SPRITE (Berkeley)";
a19 1
#include "../vm/vm.h"
d50 7
a282 6
typedef struct {
    List_Links	links;
    Address	stringPtr;
    int		stringLen;
} ArgListElement;

d325 1
a325 1
    register	ArgListElement		*argListPtr;
d330 1
d345 2
d433 1
d488 1
a488 1
	    realLength = String_NLength(stringLength, stringPtr);
d498 2
a499 1
	argListPtr = (ArgListElement *) Mem_Alloc(sizeof(ArgListElement));
d506 1
d508 2
a509 1
	userStackPointer -= ((realLength + 1) + 3) & ~3;
d563 1
a563 1
	realLength = String_NLength(stringLength, stringPtr);
d572 2
a573 1
	envListPtr = (ArgListElement *) Mem_Alloc(sizeof(ArgListElement));
d581 1
a581 1
	userStackPointer -= ((realLength + 1) + 3) & ~3;
d625 6
d634 1
a634 1
	 * Copy over the environment variable.
a638 1
	copyAddr[argListPtr->stringLen] = '\0';
d640 7
a646 2
	copyAddr += ((argListPtr->stringLen + 1) + 3) & ~3;
	usp += ((argListPtr->stringLen + 1) + 3) & ~3;
d648 1
a648 1
	 * Clean up 
d655 2
a666 1
	copyAddr[envListPtr->stringLen] = '\0';
d668 2
a669 2
	copyAddr += ((envListPtr->stringLen + 1) + 3) & ~3;
	usp += ((envListPtr->stringLen + 1) + 3) & ~3;
a728 6

    /*
     * Save the name of the file, for use during process migration,
     * and generally usefull for debugging and for the procstat program.
     */
    String_Copy(fileName, procPtr->codeFileName);
@


5.7
log
@Fixed bug when cleaning up after exec error.
@
text
@d16 1
a16 1
static char rcsid[] = "$Header: procExec.c,v 5.6 88/01/22 15:31:27 nelson Exp $ SPRITE (Berkeley)";
d252 1
a252 1
    VmMach_SetupContext(procPtr);
@


5.6
log
@Fixed up signals.
@
text
@d16 1
a16 1
static char rcsid[] = "$Header: procExec.c,v 5.5 87/12/24 16:28:11 douglis Exp $ SPRITE (Berkeley)";
d742 7
d751 1
a752 1
	Fs_Close(filePtr);
@


5.5
log
@Added Proc_ExecEnv.  Note: code for copying environment from user space
onto stack is pretty similar to copying arguments and can be 
coalesced into a subroutine or something.  However, I'm installing it
now as is, since it seems to work and I am leaving for vacation.
@
text
@d16 1
a16 1
static char rcsid[] = "$Header: procExec.c,v 5.4 87/12/12 16:39:15 nelson Exp $ SPRITE (Berkeley)";
d718 1
a718 2
     * Set up signal hold masks and default actions, then unlock
     * the process table entry so signals can come in.
d720 1
a720 1
    Sig_ProcInit(procPtr);
@


5.4
log
@Handles moving of hardware dependencies from vm to sun.
@
text
@d7 4
d16 1
a16 1
static char rcsid[] = "$Header: procExec.c,v 5.3 87/10/22 14:57:38 nelson Exp $ SPRITE (Berkeley)";
d38 1
a38 1
extern	ReturnStatus	DoExec();
d42 9
d57 4
a60 1
 *	Process the Exec system call.
d81 34
d117 2
d153 16
d170 2
a171 1
			   newArgPtrArrayLength / 4, TRUE, debugMe);
d173 1
a173 1
	Sys_Panic(SYS_FATAL, "Proc_Exec: DoExec returned SUCCESS!!!\n");
d178 3
d203 3
d255 2
a256 1
			argPtrArray, PROC_MAX_EXEC_ARGS, FALSE, FALSE);
d295 4
d310 2
a311 1
DoExec(fileName, fileNameLength, argPtrArray, numArgs, userProc, debugMe)
d316 2
d329 3
d333 1
d336 1
d340 1
d356 4
d362 1
d366 1
a446 4
	char	*stringPtr;
	int	stringLength;
        int	realLength;
	Boolean accessible;
d524 70
d608 1
a608 1
     * Now copy all of the arguments onto the stack.
d620 1
a620 1
	 * Copy over the argument.
d637 22
d661 2
a662 2
     * Now copy the array of arguments plus argc and the address of argv 
     * onto the stack.
d664 1
a664 1
    copyLength = (argNumber + 1) * sizeof(Address) + sizeof(int);
d666 1
d671 2
a672 1
    (void) Vm_CopyOut(copyLength - sizeof(int), (Address) newArgPtrArray,
d674 4
d679 1
a679 1
     * Free the array of arguments.
d682 1
d737 2
a738 1
     * virtual memory allocated and free the arguments that were copied in.
d753 6
@


5.3
log
@Changed VM to only contain a single pointer.
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: procExec.c,v 5.2 87/10/14 13:45:16 brent Exp $ SPRITE (Berkeley)";
a150 2
    Vm_InitPageTable(procPtr->vmPtr->segPtrArray[VM_CODE], (Vm_PTE *) NIL, 
		     0, -1, FALSE);
d161 1
a161 1
				   0 , 1, MACH_LAST_USER_STACK_PAGE, procPtr);
d177 1
a177 1
    Vm_SetupContext(procPtr);
d192 1
a192 1
    Vm_ReinitContext(procPtr);
d261 1
a261 1
    int					userStackPointer;
d348 1
a348 1
    userStackPointer = MACH_MAX_USER_STACK_ADDR;
d449 1
a449 1
    argBytes = MACH_MAX_USER_STACK_ADDR - userStackPointer;
d451 1
a451 1
			  argBytes, (Address) userStackPointer,
d455 1
a455 1
    usp = userStackPointer;
d486 1
a486 1
		      (Address) userStackPointer);
d488 1
a488 1
	      (Address) (userStackPointer + sizeof(int)));
d497 1
a497 1
    procPtr->genRegs[SP] = userStackPointer;
d541 1
a541 1
		    procPtr->stackStart + MACH_EXEC_STACK_OFFSET);
a703 1
    Vm_PTE			pte;
a711 3
    pte = vm_ZeroPTE;
    pte.validPage = 1;
    pte.zeroFill = 0;
d716 1
a716 1
	    execInfoPtr->heapPages = (aoutPtr->data - 1) / VM_PAGE_SIZE + 1;
d721 1
a721 1
	    execInfoPtr->heapPages += (aoutPtr->bss - 1) / VM_PAGE_SIZE + 1;
d724 1
a724 1
			PROC_DATA_LOAD_ADDR(*aoutPtr) / VM_PAGE_SIZE;
d728 1
a728 1
			PROC_BSS_LOAD_ADDR(*aoutPtr) / VM_PAGE_SIZE;
d731 1
a731 1
				       (aoutPtr->bss - 1) / VM_PAGE_SIZE);
d738 1
a738 1
	numPages = (aoutPtr->code - 1) / VM_PAGE_SIZE + 1;
d740 1
a740 1
	pageOffset = PROC_CODE_LOAD_ADDR(*aoutPtr) / VM_PAGE_SIZE;
d748 2
a749 3
	pte.protection = VM_UR_PROT;
	Vm_InitPageTable(segPtr, &pte, pageOffset,
			 pageOffset + numPages - 1, TRUE);
d773 2
a774 4
    pte.protection = VM_URW_PROT;
    Vm_InitPageTable(segPtr, &pte, execInfoPtr->heapPageOffset,
		     execInfoPtr->bssFirstPage - 1, TRUE);
    pte.zeroFill = 1;
d776 2
a777 2
	Vm_InitPageTable(segPtr, &pte, execInfoPtr->bssFirstPage,
			 execInfoPtr->bssLastPage, TRUE);
d784 1
a784 1
			   1, MACH_LAST_USER_STACK_PAGE, procPtr);
d790 2
a791 2
    Vm_InitPageTable(segPtr, &pte, MACH_LAST_USER_STACK_PAGE, 
		     MACH_LAST_USER_STACK_PAGE, TRUE);
d802 1
a802 1
    Vm_ReinitContext(procPtr);
@


5.2
log
@Fixed open calls so you can execute via a symbolic link
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: procExec.c,v 5.1 87/09/24 14:54:36 brent Exp $ SPRITE (Berkeley)";
d145 2
a146 1
    procPtr->segPtrArray[VM_CODE] = Vm_SegmentNew(VM_CODE, (Fs_Stream *) NIL, 0,
d148 1
a148 1
    if (procPtr->segPtrArray[VM_CODE] == (Vm_Segment *) NIL) {
d151 1
a151 1
    Vm_InitPageTable(procPtr->segPtrArray[VM_CODE], (Vm_PTE *) NIL, 
d154 4
a157 4
    procPtr->segPtrArray[VM_HEAP] = Vm_SegmentNew(VM_HEAP, (Fs_Stream *) NIL, 
					          0, 1, 1, procPtr);
    if (procPtr->segPtrArray[VM_HEAP] == (Vm_Segment *) NIL) {
	Vm_SegmentDelete(procPtr->segPtrArray[VM_CODE], procPtr);
d161 2
a162 1
    procPtr->segPtrArray[VM_STACK] = Vm_SegmentNew(VM_STACK, (Fs_Stream *) NIL, 
d164 3
a166 3
    if (procPtr->segPtrArray[VM_STACK] == (Vm_Segment *) NIL) {
	Vm_SegmentDelete(procPtr->segPtrArray[VM_CODE], procPtr);
	Vm_SegmentDelete(procPtr->segPtrArray[VM_HEAP], procPtr);
a173 2
    procPtr->context = VM_INV_CONTEXT;

d196 3
a198 3
    Vm_SegmentDelete(procPtr->segPtrArray[VM_CODE], procPtr);
    Vm_SegmentDelete(procPtr->segPtrArray[VM_HEAP], procPtr);
    Vm_SegmentDelete(procPtr->segPtrArray[VM_STACK], procPtr);
d804 6
a809 6
    Vm_SegmentDelete(procPtr->segPtrArray[VM_CODE], procPtr);
    Vm_SegmentDelete(procPtr->segPtrArray[VM_HEAP], procPtr);
    Vm_SegmentDelete(procPtr->segPtrArray[VM_STACK], procPtr);
    procPtr->segPtrArray[VM_CODE] = *codeSegPtrPtr;
    procPtr->segPtrArray[VM_HEAP] = heapSegPtr;
    procPtr->segPtrArray[VM_STACK] = segPtr;
@


5.1
log
@Fixed call to Fs_StreamCopy
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: procExec.c,v 5.0 87/08/11 10:46:56 sprite Exp $ SPRITE (Berkeley)";
d279 1
a279 1
    status =  Fs_Open(fileName, (FS_READ | FS_EXECUTE), FS_FILE, 0,
d657 1
a657 1
    status =  Fs_Open(shellNamePtr, (FS_READ | FS_EXECUTE), FS_FILE,
@


5.0
log
@First Sprite native copy
@
text
@d12 1
a12 1
static char rcsid[] = "$Header: procExec.c,v 4.7 87/08/06 14:21:56 nelson Exp $ SPRITE (Berkeley)";
d765 1
a765 1
	Fs_StreamCopy(codeFilePtr, &heapFilePtr);
@
