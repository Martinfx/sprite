head     9.18;
branch   ;
access   ;
symbols  ds3100:9.18 sun3:9.18 sprited:9.15.1 sun4nw:9.17 symm:9.17 spur:9.17 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.18
date     92.06.01.14.45.41;  author kupfer;  state Exp;
branches ;
next     9.17;

9.17
date     91.09.06.15.38.37;  author mgbaker;  state Exp;
branches ;
next     9.16;

9.16
date     91.09.06.13.09.45;  author rab;  state Exp;
branches ;
next     9.15;

9.15
date     91.06.27.17.37.07;  author mgbaker;  state Exp;
branches 9.15.1.1;
next     9.14;

9.14
date     91.06.27.12.10.56;  author mgbaker;  state Exp;
branches ;
next     9.13;

9.13
date     91.03.30.17.02.28;  author mgbaker;  state Exp;
branches ;
next     9.12;

9.12
date     91.02.01.16.20.54;  author mgbaker;  state Exp;
branches ;
next     9.11;

9.11
date     90.12.11.00.17.34;  author mgbaker;  state Exp;
branches ;
next     9.10;

9.10
date     90.07.11.16.34.31;  author douglis;  state Exp;
branches ;
next     9.9;

9.9
date     90.05.14.13.04.24;  author douglis;  state Exp;
branches ;
next     9.8;

9.8
date     89.11.29.14.44.26;  author brent;  state Exp;
branches ;
next     9.7;

9.7
date     89.11.07.10.38.28;  author brent;  state Exp;
branches ;
next     9.6;

9.6
date     89.10.26.19.15.47;  author brent;  state Exp;
branches ;
next     9.5;

9.5
date     89.10.24.19.30.38;  author brent;  state Exp;
branches ;
next     9.4;

9.4
date     89.10.23.17.30.27;  author brent;  state Exp;
branches ;
next     9.3;

9.3
date     89.10.23.13.41.38;  author brent;  state Exp;
branches ;
next     9.2;

9.2
date     89.10.23.13.39.50;  author brent;  state Exp;
branches ;
next     9.1;

9.1
date     89.10.23.13.24.57;  author brent;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.03.13;  author douglis;  state Stable;
branches ;
next     8.10;

8.10
date     89.08.21.15.22.46;  author mendel;  state Exp;
branches ;
next     8.9;

8.9
date     89.08.15.18.43.34;  author rab;  state Exp;
branches ;
next     8.8;

8.8
date     89.06.14.22.52.35;  author brent;  state Exp;
branches ;
next     8.7;

8.7
date     89.02.10.14.22.31;  author brent;  state Exp;
branches ;
next     8.6;

8.6
date     89.02.09.09.13.21;  author brent;  state Exp;
branches ;
next     8.5;

8.5
date     89.02.06.18.28.19;  author brent;  state Exp;
branches ;
next     8.4;

8.4
date     89.02.04.14.47.26;  author brent;  state Exp;
branches ;
next     8.3;

8.3
date     89.01.30.17.25.13;  author brent;  state Exp;
branches ;
next     8.2;

8.2
date     89.01.30.16.45.34;  author brent;  state Exp;
branches ;
next     8.1;

8.1
date     89.01.30.15.42.11;  author brent;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.21.36;  author douglis;  state Stable;
branches ;
next     7.0;

7.0
date     88.11.07.14.48.09;  author brent;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.17.12;  author brent;  state Stable;
branches ;
next     1.2;

1.2
date     88.08.05.14.16.01;  author douglis;  state Exp;
branches ;
next     1.1;

1.1
date     88.04.04.10.42.39;  author brent;  state Exp;
branches ;
next     ;

9.15.1.1
date     91.11.15.13.38.53;  author kupfer;  state Exp;
branches ;
next     ;


desc
@
Definitions of statistics structures.
@


9.18
log
@Tweak some comments.
@
text
@/*
 * fsStat.h --
 *
 *	Declarations for the file system statistics.
 *
 *	Note: since all variables are counters, they are unsigned
 *	in order to make the high-order bit useable.
 *
 * Copyright 1986 Regents of the University of California
 * All rights reserved.
 *
 *
 * $Header: /sprite/src/kernel/Cvsroot/kernel/fs/fsStat.h,v 9.17 91/09/06 15:38:37 mgbaker Exp $ SPRITE (Berkeley)
 */

#ifndef _FSSTAT
#define _FSSTAT

/*
 * Note, both client and server Naming operations are kept.
 */
typedef struct Fs_NameOpStats {
    unsigned int numReadOpens;		/* open(O_RDONLY) on client.  Count
					 * of all server open calls */
    unsigned int numWriteOpens;		/* open(O_WRONLY) */
    unsigned int numReadWriteOpens;	/* open(O_RDWR) */
    unsigned int chdirs;		/* Number Fs_ChangeDir */
    unsigned int makeDevices;		/* Number Fs_MakeDevice */
    unsigned int makeDirs;		/* Number Fs_MakeDirectory */
    unsigned int removes;		/* Number Fs_Remove */
    unsigned int removeDirs;		/* Number Fs_RemoveDirs */
    unsigned int renames;		/* Number Fs_Rename */
    unsigned int hardLinks;		/* Number Fs_HardLink */
    unsigned int symLinks;		/* Number Fs_SymLink */
    unsigned int getAttrs;		/* Number get attrs from name */
    unsigned int setAttrs;		/* Number set attrs by name */
    unsigned int getAttrIDs;		/* Number set attrs by open stream */
    unsigned int setAttrIDs;		/* Number get attrs from open stream */
    unsigned int getIOAttrs;		/* Number get attr from I/O server */
    unsigned int setIOAttrs;		/* Number set attr to I/O server */
} Fs_NameOpStats;

typedef struct Fs_GeneralStats {
    unsigned int physBytesRead;		/* Number of physical (ie descriptors)
				 	 * disk bytes read. */
    unsigned int fileBytesRead;		/* Number of file bytes read from the
					 * disk */
    unsigned int fileReadOverflow;	/* Extra */
    unsigned int remoteBytesRead;	/* Bytes read in Fsrmt_Read. */
    unsigned int remoteReadOverflow;	/* Extra */
    unsigned int deviceBytesRead;	/* Number of bytes read from devices */

    unsigned int physBytesWritten;	/* Number of physical disk bytes
					 * written */
    unsigned int fileBytesWritten;	/* Number of file bytes written to
					 * the disk */
    unsigned int fileWriteOverflow;	/* Extra */
    unsigned int remoteBytesWritten;	/* Bytes written in Fsrmt_Write */
    unsigned int remoteWriteOverflow;	/* Extra */
    unsigned int deviceBytesWritten;	/* Number of bytes written to devices */
    unsigned int fileBytesDeleted;	/* Number of file bytes deleted
					 * (total) */
    unsigned int fileDeleteOverflow;	/* Extra */
} Fs_GeneralStats;

/*
 * Cache statistics.
 */
typedef struct Fs_BlockCacheStats {
    /*
     * Read statistics.
     */
    unsigned int readAccesses;		/* Read fetches on the cache. */
    unsigned int bytesRead;		/* Total bytes read from the cache
					 * including misses read into cache
					 * This doesn't include bytes read
					 * after a failed swap page cache
					 * access, since those bytes aren't
					 * read into the cache. */
    unsigned int bytesReadOverflow;	/* Extra */
    unsigned int readHitsOnDirtyBlock;	/* Fetches that hit on a block that had
				 	 * dirty data in it. */
    unsigned int readHitsOnCleanBlock;	/* Fetches that hit on a block that had
				 	 * clean data in it. */
    unsigned int readZeroFills;		/* Blocks that are zero filled
					 * because read did not fill the
					 * whole block. */
    unsigned int domainReadFails;	/* Number of domain reads from
					 * Fscache_Write and Fscache_Read that
					 * were unsuccessful. */
    unsigned int readAheads;		/* Number of read ahead processes
					 * that were started up. */
    unsigned int readAheadHits;		/* Number of reads that hit on a
					 * block that was read ahead. */
    unsigned int allInCacheCalls;	/* Number of time FscacheAllBlocksInCache routine
					 * was called. */
    unsigned int allInCacheTrue;        /* Number of times that FscacheAllBlocksInCache
					 * returned TRUE. */
    /*
     * Write statistics.  See also WriteBackStats.
     */
    unsigned int writeAccesses;		/* Number of write fetches on the
					 * cache. */
    unsigned int bytesWritten;		/* Total bytes written to the cache
					 * including new blocks */
    unsigned int bytesWrittenOverflow;	/* Extra */
    unsigned int appendWrites;		/* NEVER SET. Blocks written in 
					 * append mode. */
    unsigned int overWrites;		/* Cache blocks that were
					 * overwritten. */
    unsigned int writeZeroFills1;	/* Blocks that are zero filled because
					 * read of old block did not fill
					 * whole block. */
    unsigned int writeZeroFills2;	/* Blocks that are zero filled because
					 * user is only doing a partial write
					 * to a new block. */
    unsigned int partialWriteHits;	/* Read hits in the cache when are
					 * writing to the middle of a block
					 * and have to read in the data that
					 * is already there. */
    unsigned int partialWriteMisses;	/* Misses for above case. */
    unsigned int blocksWrittenThru;	/* Number of dirty blocks that were
					 * written thru. */
    unsigned int dataBlocksWrittenThru;	/* Number of data block that were
					 * written thru. */
    unsigned int indBlocksWrittenThru;	/* Number of indirect blocks that
					 * were written thru. */
    unsigned int descBlocksWrittenThru;	/* Number of descriptor blocks that
					 * were written thru. */
    unsigned int dirBlocksWrittenThru;	/* Number of directory blocks that
					 * were writtenw thru. */
    /*
     * Fragment statistics.
     */
    unsigned int fragAccesses;		/* Cache blocks that were fetched in
					 * order to upgrade fragments. */
    unsigned int fragHits;		/* Hits on fragAccesses. */
    unsigned int fragZeroFills;		/* Cache blocks that had to be zero
					 * filled because of frag upgrades. */
    /*
     * File descriptor accesses.
     */
    unsigned int fileDescReads;		/* File descriptor reads. */
    unsigned int fileDescReadHits;	/* File descriptor hits in the cache. */
    unsigned int fileDescWrites;	/* File descriptor writes. */
    unsigned int fileDescWriteHits;	/* File descriptor write hits in the
					 * cache. */
    /*
     * Indirect block accesses.
     */
    unsigned int indBlockAccesses;	/* Indirect block reads. */
    unsigned int indBlockHits;		/* Access hits in the cache. */
    unsigned int indBlockWrites;	/* Indirect blocks written. */
    /*
     * Directory block accesses.
     */
    unsigned int dirBlockAccesses;	/* Directory block reads. */
    unsigned int dirBlockHits;		/* Directory block hits. */
    unsigned int dirBlockWrites;	/* Directory block writes. */
    unsigned int dirBytesRead;		/* Bytes read from directories */
    unsigned int dirBytesWritten;	/* Bytes written to directories */
    /*
     * Variable size cache statistics.
     */
    unsigned int vmRequests;		/* Number of times virtual memory
					 * requested memory from us. */
    unsigned int triedToGiveToVM;	/* Number of vmRequests that we
					 * tried to satisfy because
					 * we had free blocks */
    unsigned int vmGotPage;		/* Number of vmRequests that we
					 * satisfied after checking LRU times */
    /*
     * Block allocation statistics.
     */
    unsigned int partFree;		/* Got the block off of the partially
					 * free list. */
    unsigned int totFree;		/* Got the block off of the totally
					 * free list. */
    unsigned int unmapped;		/* Created a new block. */
    unsigned int lru;	    		/* Recycled a block. */
    /*
     * Cache size numbers.  These are monitored data, not counters--don't
     * reset them.
     */
    unsigned int minCacheBlocks;	/* The minimum number of blocks that
				 	 * can be in the cache. */
    unsigned int maxCacheBlocks;	/* The maximum number of blocks that
				 	 * can be in the cache. */
    unsigned int maxNumBlocks;		/* The maximum number of blocks that
					 * can ever be in the cache. */
    unsigned int numCacheBlocks;	/* The actual number of blocks that
					 * are in the cache. */
    unsigned int numFreeBlocks;		/* The number of cache blocks that
					 * aren't being used. */
    /*
     * Miscellaneous.
     */
    unsigned int blocksPitched;		/* The number of blocks thrown
					 * out because they duplicated
					 * VM-managed blocks. */
    int blocksFlushed;			/* The number of blocks written back
					   due to consistency. */
    int migBlocksFlushed;		/* The number of blocks written back
					   due to consistency for migrated
					   files. */
} Fs_BlockCacheStats;

/*
 * Block allocation statistics.
 */
typedef struct Fs_AllocStats {
    unsigned int blocksAllocated;	/* Full blocks allocated. */
    unsigned int blocksFreed;		/* Full blocks freed. */
    unsigned int cylsSearched;		/* Cylinders searched to find a good
					 * cylinder.*/
    unsigned int cylHashes;		/* Hashes done to find a starting
					 * cylinder. */
    unsigned int cylBitmapSearches;	/* Cylinder bitmap entries searched. */
    unsigned int fragsAllocated;	/* Fragments allocated. */
    unsigned int fragsFreed;		/* Fragments freed. */
    unsigned int fragToBlock;		/* Fragments that when freed made a
					 * full block free. */
    unsigned int fragUpgrades;		/* Fragments that were attempted to
					 * be extended.*/
    unsigned int fragsUpgraded;		/* Number of fragUpgrades that
					 * were successful. */
    unsigned int badFragList;		/* Fragment list entries that didn't
					 * really have fragments of the
					 * desired size.*/
    unsigned int fullBlockFrags;	/* Full blocks that had to
					 * be fragmented. */
} Fs_AllocStats;

/*
 * Name cache statistics.
 */
typedef struct Fs_NameCacheStats {
    unsigned int accesses;		/* Number of times something was
					 * looked for */
    unsigned int hits;			/* Number of times it was found */
    unsigned int replacements;		/* Number of entries recycled via LRU */
    unsigned int size;			/* Number of entries total */
} Fs_NameCacheStats;

/*
 * Handle statistics.
 */
typedef struct Fs_HandleStats {
    unsigned int maxNumber;	/* Current limit on table size. */
    unsigned int exists;	/* Number of handles currently in existence. */
    unsigned int installCalls;	/* Calls to Fsutil_HandleInstall. */
    unsigned int installHits;	/* installs in which handle was found. */
    unsigned int fetchCalls;	/* Calls to Fsutil_HandleFetch. */
    unsigned int fetchHits;	/* fetches in which handle was found. */
    unsigned int release;	/* Calls to Fsutil_HandleRelease. */
    unsigned int locks;		/* Number of times a handle was locked. */
    unsigned int lockWaits;	/* Number of times had to wait on a lock */
    unsigned int unlocks;	/* Number of times a handle was unlocked. */
    unsigned int created;	/* Handles that have been created. */
    unsigned int lruScans;	/* Number of LRU replacement scans */
    unsigned int lruChecks;	/* Number of handles checked for reclaimation */
    unsigned int lruHits;	/* Number of handles actually reclaimed */
    unsigned int lruEntries;	/* Number of handles in LRU list. */
    unsigned int limbo;		/* Number of handles marked for removal */
    /*
     * The following are specific to regular files.
     */
    unsigned int versionMismatch; /* Version mismatch on file. */
    unsigned int cacheFlushes;	/* Cache flushed because of version mismatch
				 * of not cacheable. */
    unsigned int segmentFetches; /* Calls by VM to see if there is indeed
				  * already a segment with the code file. */
    unsigned int segmentHits;	/* Segment fetches that return non-nil
				 * segment. */
} Fs_HandleStats;

/*
 * Prefix table statistics.  These are client-side statistics
 */
typedef struct Fs_PrefixStats {
    unsigned int relative;	/* Number of relative names encountered */
    unsigned int absolute;	/* Number of absolute names subject to prefix
				 * lookup */
    unsigned int redirects;	/* Number of redirects from the server */
    unsigned int loops;		/* Number of circular redirects */
    unsigned int timeouts;	/* Number of times the server was down */
    unsigned int stale;		/* Number of times server server rejected a
				 * handle */
    unsigned int found;		/* Number of times found a new prefix */
} Fs_PrefixStats;

/*
 * Name lookup statistics.  These are server-side statistics.
 */
typedef struct Fs_LookupStats {
    unsigned int number;	/* Number of pathname lookups */
    unsigned int numComponents;	/* Number of pathname components parsed */
    unsigned int numSpecial;	/* Number of $MACHINE names encounted */
    unsigned int forDelete;	/* Number for deletion */
    unsigned int forLink;	/* Number for linking */
    unsigned int forRename;	/* Number for rename */
    unsigned int forCreate;	/* Number for creation */
    unsigned int symlinks;	/* Number of symbolic links encountered */
    unsigned int redirect;	/* Number of redirects due to symbolic links */
    unsigned int remote;	/* Number of redirects due to remote links */
    unsigned int parent;	/* Number of redirects due to ".." */
    unsigned int notFound;	/* Number of FILE_NOT_FOUND lookups */
} Fs_LookupStats;

/*
 * Counts of various file system objects.
 */
typedef struct Fs_ObjectStats {
    int streams;
    int streamClients;		/* Equal to streams, except during migration */
    int files;			/* Local files, not including directories */
    int rmtFiles;
    int pipes;
    int devices;
    int controls;		/* Pdev and Pfs control streams */
    int pseudoStreams;		/* One count for both client/server handles */
    int remote;			/* All the various remote objects but files*/
    int directory;
    int dirFlushed;		/* Directories that were flushed */
    int fileClients;		/* Number of consist.clientList entries */
    int other;			/* For unknown objects */
} Fs_ObjectStats;

/*
 * File system recovery statistics.
 */
typedef struct Fs_RecoveryStats {
    int number;			/* Number of reopens by this client */
    int wants;			/* Calls to Fsutil_WantRecovery */
    int waitOK;			/* Successful RecoveryWaits */
    int waitFailed;		/* Unnsuccessful RecoveryWaits */
    int waitAbort;		/* Interrupted RecoveryWaits */
    int timeout;		/* Re-open's that timed out */
    int failed;			/* Re-open's that failed */
    int deleted;		/* Re-open's of a file that has been deleted */
    int offline;		/* Re-open's of a file that is now offline */
    int succeeded;		/* Re-open's that worked */
    int clientCrashed;		/* Number of clients that crashed */
    int clientRecovered;	/* Number of clients that re-opened files */
    int	reopensAvoided;		/* Unneeded reopens skipped */
} Fs_RecoveryStats;

/*
 * Cache conistency statistics.
 */
typedef struct Fs_ConsistStats {
    int files;			/* The number of times consistency was checked*/
    int clients;		/* The number of clients considered */
    int notCaching;		/* # of other clients that weren't caching */
    int readCachingMyself;	/* # of clients that were read caching */
    int readCachingOther;	/* # of other clients that were read caching */
    int writeCaching;		/* # of lastWriters that re-opened  */
    int writeBack;		/* # of lastWriters forced to write-back */
    int readInvalidate;		/* # of readers forced to stop caching */
    int writeInvalidate;	/* # of writers forced to stop caching */
    int nonFiles;		/* # of directories, links, etc. */
    int swap;			/* # of uncached swap files. */
    int cacheable;		/* # of files that were cacheable */
    int uncacheable;		/* # of files that were not cacheable */
} Fs_ConsistStats;

/*
 * (More) Write-back statistics.
 */
typedef struct Fs_WriteBackStats {
    int passes;			/* Number of times Fs_CleanBlocks called */
    int files;			/* Number of dirty files processed */
    int blocks;			/* Number of dirty blocks processed */
    int maxBlocks;		/* Max blocks processed in one pass */
} Fs_WriteBackStats;

/*
 * Some miscellaneous stats to determine why we read remote bytes.
 */
typedef struct Fs_RemoteIOStats {
    int blocksReadForVM;	/* Blocks read from Fs_PageRead (old) */
    int bytesReadForCache;	/* Bytes read into the cache for remote files */
    int bytesWrittenFromCache;	/* Bytes written from the cache for rmt files */
    int uncacheableBytesRead;	/* Uncacheable bytes read (not counting swap) *
   				 * (FS_NOT_CACHEABLE flag) */
    int uncacheableBytesWritten;/* Uncacheable bytes written *
   				 * (FS_NOT_CACHEABLE flag) */
    int sharedStreamBytesRead;	/* Bytes read from shared uncacheable streams */
    int sharedStreamBytesWritten;/* Bytes written to shared uncached streams */
    int hitsOnVMBlock;		/* Code and Heap pages found in the cache */
    int missesOnVMBlock;	/* This shoudl be code and heap pages not found
				 * in the cache, but it includes the misses
				 * due to stupid swap page cache accesses.  We
				 * will almost never find those, unless they
				 * are due to a shared page.  So subtract the
				 * number of swap page misses from this to get
				 * a more reasonable value. */
/* We really need a counter for shared page accesses and hits. */
    int bytesReadForVM;		/* Bytes read in RmtFilePageRead */
    int bytesWrittenForVM;	/* Bytes written in RmtFilePageWrite */
    int	hitsOnHeapBlock;	/* Block in cache. */
    int	missesOnHeapBlock;	/* Block not in cache. */
    int	hitsOnCodePage;		/* Block in cache. */
    int	missesOnCodePage;	/* Block not in cache. */
    int	hitsOnSwapPage;		/* Block in cache.  This should be very rare
				 * since it would only be if the "swap" page
				 * is actually a shared page. */
    int	missesOnSwapPage;	/* Block not in cache.  This will be the norn.
				 * Subtract this value from missesOnVMBlock in
				 * order to get the reasonable number of vm
				 * cache misses.  We look in the cache for
				 * all swap pages, and will only find shared
				 * pages. */
    int	bytesReadForHeap;		/* Heap bytes read into cache */
    int	bytesReadForHeapUncached;	/* Uncached heap bytes read.  This
					 * should almost always be zero, since
					 * it's only upon an error that
					 * heap blocks can't be read into
					 * the cache. */
    int	uncacheableDirBytesRead;	/* Directory bytes remotely read are
					 * not cacheable. */
    int	remoteDevicishBytesRead;	/* Device-like bytes read remotely.
					 * This includes devices, pipes,
					 * pseudo devices, pseudo file systems
					 * and their control streams.  It
					 * only includes successful bytes
					 * read. */
    int	remoteDevicishBytesWritten;	/* Devicish bytes written remotely.
					 * This includes devices, pipes,
					 * pseudo devices, pseudo file systems
					 * and their control streams.  It
					 * only includes successful bytes
					 * written. */
				    

} Fs_RemoteIOStats;

/*
 * Statistics relating to migration.
 */
typedef struct Fs_MigStats {
    unsigned int filesEncapsulated; 	/* Total number of files encapsulated
					   by this host */
    unsigned int filesDeencapsulated; 	/* Total number of files deencapsulated
					   by this host */
    unsigned int consistActions; 	/* Total number of files for which
					   this host was the i/o server doing
					   consistency */
    unsigned int readOnlyFiles; 	/* Total number of files deencapsulated
					   read-only */
    unsigned int alreadyThere; 		/* Total number of (writable) files
					   already on target. NOT USED. */
    unsigned int uncacheableFiles; 	/* Total number of files deencapsulated
					   that were uncacheable to begin
					   with, and stayed that way. */
    unsigned int cacheWritableFiles; 	/* Total number of cacheable, writable
					   files that were still cacheable
					   after migration. */
    unsigned int uncacheToCacheFiles; 	/* Total number of uncacheable
					   files that became cacheable after
					   migration. */
    unsigned int cacheToUncacheFiles; 	/* Total number of cacheable
					   files that became uncacheable after
					   migration. */
    unsigned int errorsOnDeencap;	/* Any files that couldn't be
					   deencapsulated due to errors. */
    unsigned int encapSquared; 		/* Sum of squares for
					   filesEncapsulated. */
    unsigned int deencapSquared; 	/* Sum of squares for
					   filesDeencapsulated. */
} Fs_MigStats;

/*
 * File system statistics.  If you change this struct, be sure to verify 
 * that ZeroFsStats is still okay.
 */
#define FS_STAT_VERSION 2
typedef struct Fs_Stats {
    int			statsVersion;   /* Version number of statistics info */
    Fs_NameOpStats	cltName;	/* Client-side naming operations */
    Fs_NameOpStats	srvName;	/* Server-side naming operations */
    Fs_GeneralStats	gen;		/* General I/O operations */
    Fs_BlockCacheStats	blockCache;	/* Block cache operations */
    Fs_AllocStats	alloc;		/* Disk allocation */
    Fs_HandleStats	handle;		/* Handle management */
    Fs_PrefixStats	prefix;		/* Client-side prefix operations */
    Fs_LookupStats	lookup;		/* Server-side lookup operations */
    Fs_NameCacheStats	nameCache;	/* Server name cache */
    Fs_ObjectStats	object;		/* Counts of various objects */
    Fs_RecoveryStats	recovery;	/* Crash recovery and reopening */
    Fs_ConsistStats	consist;	/* Cache consistency actions */
    Fs_WriteBackStats	writeBack;	/* Cache write-back stats */
    Fs_RemoteIOStats	rmtIO;		/* Remote I/O stats */
    Fs_MigStats		mig;		/* Migration */
} Fs_Stats;

/*
 * Keep a histogram of file lifetimes in a three-dimensional matrix,
 * for lifetime, file size, and file type.  Buckets for size are
 * scaled logarithmically.  Buckets for lifetime are determined as
 * follows, where each bucket corresponds to a lifetime less than that
 * value:
 *
 *	seconds: 1, 2, ..., 10, 20, ..., 50
 *	minutes: 1, 2, ..., 10, 20, ..., 50
 *      hours:   1, 2, ..., 10, 15, 20 (<24)
 *	days:    1, 2, ..., 10, 20, .., 60, 90, 120, 180, 240, 300, 360, > 360
 *
 * For example, a file that is 0 seconds old is < 1 second and is in
 * bucket 0; a file that is exactly 15 hours old is in the bucket labeled
 * "20 hours" since that contains everything from 15 hours to
 * (20 hours - 1 second).
 *
 * The divisions are somewhat arbitrary and are subject to change.
 * Define the number of buckets here: 32 size buckets will cover 2 **
 * 32 bytes (max file size); throw in one more bucket for subtotals by
 * time.  For times, define an array containing the number of seconds
 * and number of buckets for each group described above.
 */
#define FS_HIST_SIZE_BUCKETS 	33

typedef struct Fs_HistGroupInfo {
    unsigned int secondsPerBucket;
    unsigned int bucketsPerGroup;
} Fs_HistGroupInfo;


#define FS_HIST_SECONDS		10
#define FS_HIST_TEN_SECONDS	5
#define FS_HIST_MINUTES		9
#define FS_HIST_TEN_MINUTES	5
#define FS_HIST_HOURS		9
#define FS_HIST_FIVE_HOURS	2
#define FS_HIST_REST_HOURS	1
#define FS_HIST_DAYS		9
#define FS_HIST_TEN_DAYS 	5
#define FS_HIST_THIRTY_DAYS 	2
#define FS_HIST_SIXTY_DAYS 	4
#define FS_HIST_REST_DAYS 	1

#define FS_HIST_TIME_BUCKETS (FS_HIST_SECONDS + \
			      FS_HIST_TEN_SECONDS + \
			      FS_HIST_MINUTES + \
			      FS_HIST_TEN_MINUTES + \
			      FS_HIST_HOURS + \
			      FS_HIST_FIVE_HOURS + \
			      FS_HIST_REST_HOURS + \
			      FS_HIST_DAYS + \
			      FS_HIST_TEN_DAYS + \
			      FS_HIST_THIRTY_DAYS + \
			      FS_HIST_SIXTY_DAYS + \
			      FS_HIST_REST_DAYS)

/*
 * The number of types that we gather statistics for.
 */
#define FS_STAT_NUM_TYPES 5

/*
 * Subscripts for arrays that separate data for read and write.
 */
#define FS_STAT_READ 0
#define FS_STAT_WRITE 1

typedef struct Fs_TypeStats {
    unsigned int diskBytes[2][FS_STAT_NUM_TYPES];
    				/* Number of bytes read/written from/to
				 * different types of files on disk */
    unsigned int cacheBytes[2][FS_STAT_NUM_TYPES];
    				/* Number of bytes read or written through
				 * cache */
    unsigned int bytesDeleted[FS_STAT_NUM_TYPES];
    				/* Number of bytes deleted from files due
				 * to truncation or removal */
    unsigned int deleteHist	/* Histogram of deletions, by type */
	    [FS_HIST_TIME_BUCKETS] [FS_HIST_SIZE_BUCKETS] [FS_STAT_NUM_TYPES];
} Fs_TypeStats;

Fs_TypeStats fs_TypeStats;

/*
 * Macro to add to a counter, watching for overflow.  We use unsigned
 * integers and wrap around if the high-order bit gets set.  This assumes
 * that the amount to be added each time is
 * relatively small (so we can't miss the overflow bit).
 */

#define FS_STAT_OVERFLOW (1 << (sizeof(unsigned int) * 8 - 1))
#define Fs_StatAdd(thisCount, counter, overflow) \
    counter += thisCount; \
    if (counter & FS_STAT_OVERFLOW) { \
        overflow += 1; \
        counter &= ~FS_STAT_OVERFLOW; \
    }

/*
 * We've changed things so that heap pages are cacheable.
 * In order to know how much of the vm bytes are found in the cache or not,
 * we need these new counters.  bytesReadForCache now includes heap bytes
 * as does bytesReadForVM, so we use this extra counter to know how much of
 * that is so.
 */

extern	Fs_Stats	fs_Stats;

#endif _FSSTAT
@


9.17
log
@Added needed counters back to fsStat.h.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 9.16 91/09/06 13:09:45 rab Exp Locker: mgbaker $ SPRITE (Berkeley)
d182 2
a183 1
     * Cache size numbers.
d198 3
a200 3
    unsigned int blocksPitched;		/* The number of blocks that were
					 * thrown out at the command of
					 * virtual memory. */
d474 2
a475 1
 * File system statistics.
@


9.16
log
@Mary checking this in for Bob.  He was doing the kernel cleanup changes.
I have a bunch of bugs to fix.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 9.15 91/06/27 17:37:07 mgbaker Exp Locker: rab $ SPRITE (Berkeley)
d75 5
a79 1
					 * including misses read into cache */
d390 8
a397 1
    int missesOnVMBlock;	/* Code and Heap pages not found in the cache */
d400 13
a412 2
    int	hitsOnHeapBlock;	/* Block in cache? */
    int	missesOnHeapBlock;	/* Block not in cache? */
d414 21
a434 1
    int	bytesReadForHeapUncached;	/* Unached heap bytes read */
@


9.15
log
@Another counter.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 9.14 91/06/27 12:10:56 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)
a551 11
#ifdef SOSP91
typedef	struct	Fs_SospMigStats {
    Fs_BlockCacheStats	blockCache;
    Fs_RemoteIOStats	rmtIO;
    Fs_GeneralStats	gen;
} Fs_SospMigStats;
    

extern	Fs_SospMigStats	fs_SospMigStats;
#endif SOSP91

a558 25
#ifdef SOSP91
typedef	struct Fs_NewStats {
    int		uncacheableDirBytesRead;
    int		uncacheableDirBytesReadMig;
    int		CORPageServerRead;
    int		CORPageServerReadM;
    int		hitsOnCodePage;
    int		hitsOnCodePageM;
    int		hitsOnSwapPage;
    int		hitsOnSwapPageM;
    int		missesOnCodePage;
    int		missesOnCodePageM;
    int		missesOnSwapPage;
    int		missesOnSwapPageM;
    int		psFilledM;
    int		fsFilledM;
    int		zeroFilledM;
    int		totalFaultsM;
    int		remoteDevicishBytesRead;
    int		remoteDevicishBytesReadM;
    int		COWCopySwapPage;
    int		COWCopySwapPageM;
} Fs_NewStats;
extern	Fs_NewStats	fs_MoreStats;
#endif SOSP91
@


9.15.1.1
log
@Initial branch for Sprite server.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/Cvsroot/kernel/fs/fsStat.h,v 9.15 91/06/27 17:37:07 mgbaker Exp $ SPRITE (Berkeley)
@


9.14
log
@Added new counters.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 9.13 91/03/30 17:02:28 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)
d590 2
a591 1

@


9.13
log
@More sosp stats.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 9.12 91/02/01 16:20:54 mgbaker Exp $ SPRITE (Berkeley)
d574 17
@


9.12
log
@Fixed some comments.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 9.11 90/12/11 00:17:34 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)
d340 1
d389 4
d556 1
d562 16
@


9.11
log
@Sosp counters
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 9.10 90/07/11 16:34:31 douglis Exp Locker: mgbaker $ SPRITE (Berkeley)
d49 1
a49 2
    unsigned int remoteBytesRead;	/* Number of bytes read from
					 * un-cachable remote files */
d58 1
a58 2
    unsigned int remoteBytesWritten;	/* Number of bytes written to
					 * un-cachable remote files */
d74 2
a75 1
    unsigned int bytesRead;		/* Total bytes read from the cache */
d100 2
a101 1
    unsigned int bytesWritten;		/* Total bytes written to the cache */
d103 2
a104 1
    unsigned int appendWrites;		/* Blocks written in append mode. */
d376 6
a381 4
    int bytesReadForCache;	/* Bytes read into the cache */
    int bytesWrittenFromCache;	/* Bytes written from the cache */
    int uncacheableBytesRead;	/* Uncacheable bytes read (not counting swap) */
    int uncacheableBytesWritten;/* Uncacheable bytes written */
@


9.10
log
@changed migration stats to include squares of files encap/deencap'ed so we
can get std dev of files/process.  bumped stat_version.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 9.9 90/05/14 13:04:24 douglis Exp Locker: douglis $ SPRITE (Berkeley)
d544 9
@


9.9
log
@added migration stats, cache consistency stats.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fd.fs/RCS/fsStat.h,v 9.8 89/11/29 14:44:26 brent Exp Locker: douglis $ SPRITE (Berkeley)
d416 4
d425 1
a425 1
#define FS_STAT_VERSION 1
@


9.8
log
@Update rmtIO statistics to reflect new paging structure
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 9.7 89/11/07 10:38:28 brent Exp $ SPRITE (Berkeley)
d195 5
d388 31
d421 1
d423 1
d438 1
@


9.7
log
@Added RemoteIO stats so we can understand why clients read
so much remote data.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 9.6 89/10/26 19:15:47 brent Exp Locker: brent $ SPRITE (Berkeley)
d369 11
a379 7
    int blocksReadForVM;	/* Count of block reads from Fs_PageRead */
    int bytesReadForCache;	/* Count of bytes read into the cache */
    int bytesWrittenFromCache;	/* Count of bytes written from the cache */
    int uncacheableBytesRead;	/* Count of uncacheable bytes read */
    int uncacheableBytesWritten;/* Count of uncacheable bytes read */
    int sharedStreamBytesRead;	/* Count of bytes read from shared streams */
    int sharedStreamBytesWritten;/* Count of bytes written to shared streams */
@


9.6
log
@Differentiated between read caching by other clients and
read caching by the client doing the open.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 9.5 89/10/24 19:30:38 brent Exp Locker: brent $ SPRITE (Berkeley)
d366 13
d395 1
@


9.5
log
@Added max write-back queue length
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 9.4 89/10/23 17:30:27 brent Exp Locker: brent $ SPRITE (Berkeley)
d343 2
a344 1
    int readCaching;		/* # of other clients that were read caching */
@


9.4
log
@Added cache-write backs stats.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 9.3 89/10/23 13:41:38 brent Exp Locker: brent $ SPRITE (Berkeley)
d361 1
@


9.3
log
@Fixed typo
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 9.2 89/10/23 13:39:50 brent Exp $ SPRITE (Berkeley)
d97 1
a97 1
     * Write statistics.
d355 9
d379 1
@


9.2
log
@Updated consistency stats
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 9.1 89/10/23 13:24:57 brent Exp Locker: brent $ SPRITE (Berkeley)
d351 1
a351 1
    int uncachable;		/* # of files that were not cacheable */
@


9.1
log
@Added consistency stats
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 9.0 89/09/12 15:03:13 douglis Stable Locker: brent $ SPRITE (Berkeley)
d348 4
@


9.0
log
@Changing version numbers.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 8.10 89/08/21 15:22:46 mendel Exp Locker: douglis $ SPRITE (Berkeley)
d337 14
d365 1
@


8.10
log
@Break up fs to sperate modules.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 8.8 89/06/14 22:52:35 brent Exp $ SPRITE (Berkeley)
@


8.9
log
@Commented #endif labels.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 8.8 89/06/14 22:52:35 brent Exp Locker: rab $ SPRITE (Berkeley)
d22 1
a22 1
typedef struct FsNameOpStats {
d41 1
a41 1
} FsNameOpStats;
d43 1
a43 1
typedef struct FsGeneralStats {
d66 1
a66 1
} FsGeneralStats;
d71 1
a71 1
typedef struct FsBlockCacheStats {
d86 1
a86 1
					 * FsCacheWrite and FsCacheRead that
d92 1
a92 1
    unsigned int allInCacheCalls;	/* Number of time FsAllInCache routine
d94 1
a94 1
    unsigned int allInCacheTrue;        /* Number of times that FsAllInCache
d195 1
a195 1
} FsBlockCacheStats;
d200 1
a200 1
typedef struct FsAllocStats {
d221 1
a221 1
} FsAllocStats;
d226 1
a226 1
typedef struct FsNameCacheStats {
d232 1
a232 1
} FsNameCacheStats;
d237 1
a237 1
typedef struct FsHandleStats {
d240 1
a240 1
    unsigned int installCalls;	/* Calls to FsHandleInstall. */
d242 1
a242 1
    unsigned int fetchCalls;	/* Calls to FsHandleFetch. */
d244 1
a244 1
    unsigned int release;	/* Calls to FsHandleRelease. */
d264 1
a264 1
} FsHandleStats;
d269 1
a269 1
typedef struct FsPrefixStats {
d279 1
a279 1
} FsPrefixStats;
d284 1
a284 1
typedef struct FsLookupStats {
d297 1
a297 1
} FsLookupStats;
d302 1
a302 1
typedef struct FsObjectStats {
d316 1
a316 1
} FsObjectStats;
d321 1
a321 1
typedef struct FsRecoveryStats {
d323 1
a323 1
    int wants;			/* Calls to FsWantRecovery */
d334 1
a334 1
} FsRecoveryStats;
d339 13
a351 13
typedef struct FsStats {
    FsNameOpStats	cltName;	/* Client-side naming operations */
    FsNameOpStats	srvName;	/* Server-side naming operations */
    FsGeneralStats	gen;		/* General I/O operations */
    FsBlockCacheStats	blockCache;	/* Block cache operations */
    FsAllocStats	alloc;		/* Disk allocation */
    FsHandleStats	handle;		/* Handle management */
    FsPrefixStats	prefix;		/* Client-side prefix operations */
    FsLookupStats	lookup;		/* Server-side lookup operations */
    FsNameCacheStats	nameCache;	/* Server name cache */
    FsObjectStats	object;		/* Counts of various objects */
    FsRecoveryStats	recovery;	/* Crash recovery and reopening */
} FsStats;
d378 1
a378 1
typedef struct FsHistGroupInfo {
d381 1
a381 1
} FsHistGroupInfo;
d421 1
a421 1
typedef struct FsTypeStats {
d433 1
a433 1
} FsTypeStats;
d435 1
a435 1
FsTypeStats fsTypeStats;
d444 2
a445 2
#define FSSTAT_OVERFLOW (1 << (sizeof(unsigned int) * 8 - 1))
#define FsStat_Add(thisCount, counter, overflow) \
d447 1
a447 1
    if (counter & FSSTAT_OVERFLOW) { \
d449 1
a449 1
        counter &= ~FSSTAT_OVERFLOW; \
d452 1
a452 1
extern	FsStats	fsStats;
d454 1
a454 1
#endif /* _FSSTAT */
@


8.8
log
@Cleaned up the various stats structures.
Added NameOps and LookupOps structures.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 8.7 89/02/10 14:22:31 brent Exp $ SPRITE (Berkeley)
d454 1
a454 1
#endif _FSSTAT
@


8.7
log
@Added a 'limbo' field to count the number of handles that
have been officially removed, but not free'ed because of
lingering references.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 8.6 89/02/09 09:13:21 brent Exp $ SPRITE (Berkeley)
d19 24
a65 7
    unsigned int numReadOpens;		/* Number of calls to open files for
					 * reading */
    unsigned int numWriteOpens;		/* Number of calls to open files for
					 * writing */
    unsigned int numReadWriteOpens;	/* Number of calls to open files for
					 * reading  and writing */
    unsigned int numSetAttrs;		/* Number of calls to set attributes */
d163 2
a164 1
					 * actually tried to satisfy. */
d166 1
a166 4
					 * actually satisfied. */
    unsigned int gavePageToVM;		/* Blocks that we voluntarily gave
					 * back to to virtual memory when a
					 * block was freed.  */
d238 10
a247 1
    unsigned int exists;	/* Handles currently in existence. */
d249 8
a256 3
    unsigned int updateCalls;	/* Number of calls to HandleUpdate */
    unsigned int installCalls;	/* Calls to FsHandleInstall. */
    unsigned int installHits;	/* Number of installs in which handle was found. */
a259 9
    unsigned int maxNumber;	/* Current limit on table size. */
    unsigned int fetchCalls;	/* Calls to FsHandleFetch. */
    unsigned int fetchHits;	/* Number of fetches in which handle was
				 * found. */
    unsigned int lockCalls;	/* Calls to FsHandleLock. */
    unsigned int locks;		/* Number of times a handle was locked. */
    unsigned int lockWaits;	/* Number of times had to wait to lock a
				 * handle. */
    unsigned int releaseCalls;	/* Calls to FsHandleRelease. */
d267 1
a267 1
 * Prefix table statistics
d274 1
a274 2
    unsigned int loops;		/* Number of circular redirects (domain
				 * unavailable) */
d282 18
a302 2
    int lruScans;		/* Number of LRU replacement scans */
    int scavenges;		/* Number of handles actually reclaimed */
a313 2
    int lruChecks;		/* Number of handles checked for reclaimation */
    int lruEntries;		/* Number of handles in LRU list */
d315 1
a315 1
    int limbo;			/* Number of handles marked for removal */
d329 2
d340 11
a350 8
    FsBlockCacheStats	blockCache;
    FsNameCacheStats	nameCache;
    FsAllocStats	alloc;
    FsHandleStats	handle;
    FsGeneralStats	gen;
    FsPrefixStats	prefix;
    FsObjectStats	object;
    FsRecoveryStats	recovery;
@


8.6
log
@Added count of lruEntries and count of fileClients
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 8.5 89/02/06 18:28:19 brent Exp $ SPRITE (Berkeley)
d282 1
@


8.5
log
@Added lruChecks to see how many handles are tested for reclaimation
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 8.4 89/02/04 14:47:26 brent Exp Locker: brent $ SPRITE (Berkeley)
d280 2
@


8.4
log
@Added recovery stats
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 8.3 89/01/30 17:25:13 brent Exp Locker: brent $ SPRITE (Berkeley)
d267 1
a267 1
    int scavenges;		/* Number of handles reclaimed */
d279 1
@


8.3
log
@Put handle table size limit into stats
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 8.2 89/01/30 16:45:34 brent Exp $ SPRITE (Berkeley)
d54 1
a54 1
typedef struct {
d185 1
a185 1
typedef struct {
d211 1
a211 1
typedef struct {
d222 1
a222 1
typedef struct {
d249 1
a249 1
typedef struct {
d265 1
a265 1
typedef struct {
d269 2
a270 2
    int streamClients;
    int files;
d277 2
d281 15
d300 1
a300 1
typedef struct {
d308 1
d336 1
a336 1
typedef struct {
d379 1
a379 1
typedef struct {
@


8.2
log
@Added number of scavenges to object stats.
Moved lruScans from object to handle stats.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 8.1 89/01/30 15:42:11 brent Exp $ SPRITE (Berkeley)
d231 1
a231 1
    unsigned int lruScans;	/* Number of scans through LRU list. */
d266 2
a267 1
    int scavenges;
@


8.1
log
@Added counters of objects by type.
Moved file life time data (which is HUGE!) into another struct
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 7.0 88/11/07 14:48:09 brent Exp $ SPRITE (Berkeley)
d231 1
a231 2
    unsigned int oldHandles;	/* Handles whose creation date is out of
				 * date. */
d266 1
a266 1
    int lruScans;
@


8.0
log
@Changing version numbers.
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 7.0 88/11/07 14:48:09 brent Exp Locker: douglis $ SPRITE (Berkeley)
d264 30
d375 1
a375 13

/*
 * File system statistics.
 */
typedef struct {
    FsBlockCacheStats	blockCache;
    FsNameCacheStats	nameCache;
    FsAllocStats	alloc;
    FsHandleStats	handle;
    FsGeneralStats	gen;
    FsPrefixStats	prefix;
    FsTypeStats		type;
} FsStats;
@


7.0
log
@New version for conversion to new C library
@
text
@d13 1
a13 1
 * $Header: /sprite/src/kernel/fs/RCS/fsStat.h,v 6.0 88/08/11 12:17:12 brent Stable Locker: brent $ SPRITE (Berkeley)
@


6.0
log
@Changing version numbers.
@
text
@d13 1
a13 1
 * $Header: fsStat.h,v 1.2 88/08/05 14:16:01 douglis Exp $ SPRITE (Berkeley)
@


1.2
log
@Changes to support keeping track of file deletions, certain FS system
calls, and large fsStat counters, ported from the old filesystem.
This ci message is generic.
@
text
@d13 1
a13 1
 * $Header: fsStat.h,v 1.1 88/04/04 10:42:39 brent Exp $ SPRITE (Berkeley)
@


1.1
log
@Initial revision
@
text
@d6 3
d13 1
a13 1
 * $Header: fsStat.h,v 5.0 87/08/11 10:41:32 sprite Exp $ SPRITE (Berkeley)
d20 9
a28 8
    int physBytesRead;		/* Number of physical (ie descriptors) disk
				 * bytes read. */
    int fileBytesRead;		/* Number of file bytes read from the disk */
    int fileReadOverflow;	/* Extra */
    int remoteBytesRead;	/* Number of bytes read from un-cachable
   				 * remote files */
    int remoteReadOverflow;	/* Extra */
    int deviceBytesRead;	/* Number of bytes read from devices */
d30 19
a48 7
    int physBytesWritten;	/* Number of physical disk bytes written */
    int fileBytesWritten;	/* Number of file bytes written to the disk */
    int fileWriteOverflow;	/* Extra */
    int remoteBytesWritten;	/* Number of bytes written to un-cachable
   				 * remote files */
    int remoteWriteOverflow;	/* Extra */
    int deviceBytesWritten;	/* Number of bytes written to devices */
d58 21
a78 19
    int	readAccesses;		/* Read fetches on the cache. */
    int bytesRead;		/* Total bytes read from the cache */
    int bytesReadOverflow;	/* Extra */
    int	readHitsOnDirtyBlock;	/* Fetches that hit on a block that had
				 * dirty data in it. */
    int	readHitsOnCleanBlock;	/* Fetches that hit on a block that had
				 * clean data in it. */
    int	readZeroFills;		/* Blocks that are zero filled because read
				 * did not fill the whole block. */
    int	domainReadFails;	/* Number of domain reads from FsCacheWrite
				 * and FsCacheRead that were unsuccessful. */
    int	readAheads;		/* Number of read ahead processes that were
				 * started up. */
    int	readAheadHits;		/* Number of reads that hit on a block that
				 * was read ahead. */
    int	allInCacheCalls;	/* Number of time FsAllInCache routine was
				 * called. */
    int	allInCacheTrue;		/* Number of times that FsAllInCache returned
				 * TRUE. */
d82 28
a109 24
    int	writeAccesses;		/* Number of write fetches on the cache. */
    int bytesWritten;		/* Total bytes written to the cache */
    int bytesWrittenOverflow;	/* Extra */
    int	appendWrites;		/* Blocks written in append mode. */
    int	overWrites;		/* Cache blocks that were overwritten. */
    int	writeZeroFills1;	/* Blocks that are zero filled because read
				 * of old block did not fill whole block. */
    int	writeZeroFills2;	/* Blocks that are zero filled because user
				 * is only doing a partial write to a new 
				 * block. */
    int	partialWriteHits;	/* Read hits in the cache when are writing to 
				 * the middle of a block and have to read in 
				 * the data that is already there. */
    int	partialWriteMisses;	/* Misses for above case. */
    int	blocksWrittenThru;	/* Number of dirty blocks that were written
				 * thru. */
    int	dataBlocksWrittenThru;	/* Number of data block that were written
				 * thru. */
    int	indBlocksWrittenThru;	/* Number of indirect blocks that were written
				 * thru. */
    int	descBlocksWrittenThru;	/* Number of descriptor blocks that were written
				 * thru. */
    int	dirBlocksWrittenThru;	/* Number of directory blocks that were written
				 * thru. */
d113 5
a117 5
    int	fragAccesses;		/* Cache blocks that were fetched in order
				 * to upgrade fragments. */
    int	fragHits;		/* Hits on fragAccesses. */
    int	fragZeroFills;		/* Cache blocks that had to be zero filled
				 * because of frag upgrades. */
d121 5
a125 4
    int	fileDescReads;		/* File descriptor reads. */
    int	fileDescReadHits;	/* File descriptor hits in the cache. */
    int	fileDescWrites;		/* File descriptor writes. */
    int	fileDescWriteHits;	/* File descriptor write hits in the cache. */
d129 3
a131 3
    int	indBlockAccesses;	/* Indirect block reads. */
    int	indBlockHits;		/* Access hits in the cache. */
    int	indBlockWrites;		/* Indirect blocks written. */
d135 5
a139 5
    int	dirBlockAccesses;	/* Directory block reads. */
    int	dirBlockHits;		/* Directory block hits. */
    int	dirBlockWrites;		/* Directory block writes. */
    int dirBytesRead;		/* Bytes read from directories */
    int dirBytesWritten;	/* Bytes written to directories */
d143 9
a151 8
    int	vmRequests;		/* Number of times virtual memory requested
				 * memory from us. */
    int	triedToGiveToVM;	/* Number of vmRequests that we actually tried
				 * to satisfy. */
    int	vmGotPage;		/* Number of vmRequests that we actually 
				 * satisfied. */
    int	gavePageToVM;		/* Blocks that we voluntarily gave back to
				 * to virtual memory when a block was freed.  */
d155 6
a160 5
    int	partFree;		/* Got the block off of the partially free 
				 * list. */
    int	totFree;		/* Got the block off of the totally free list.*/
    int	unmapped;		/* Created a new block. */
    int	lru;	    		/* Recycled a block. */
d164 10
a173 10
    int	minCacheBlocks;		/* The minimum number of blocks that
				 * can be in the cache. */
    int	maxCacheBlocks;		/* The maximum number of blocks that
				 * can be in the cache. */
    int	maxNumBlocks;		/* The maximum number of blocks that can ever
				 * be in the cache. */
    int	numCacheBlocks;		/* The actual number of blocks that are in
				 * the cache. */
    int	numFreeBlocks;		/* The number of cache blocks that aren't being
				 * used. */
d177 3
a179 2
    int	blocksPitched;		/* The number of blocks that were thrown out
				 * at the command of virtual memory. */
d186 20
a205 16
    int	blocksAllocated;	/* Full blocks allocated. */
    int	blocksFreed;		/* Full blocks freed. */
    int	cylsSearched;		/* Cylinders searched to find a good cylinder.*/
    int	cylHashes;		/* Hashes done to find a starting cylinder. */
    int	cylBitmapSearches;	/* Cylinder bitmap entries searched. */
    int	fragsAllocated;		/* Fragments allocated. */
    int	fragsFreed;		/* Fragments freed. */
    int	fragToBlock;		/* Fragments that when freed made a full block
				 * free. */
    int	fragUpgrades;		/* Fragments that were attempted to be 
				 * extended.*/
    int	fragsUpgraded;		/* Number of fragUpgrades that were 
				 * successful. */
    int	badFragList;		/* Fragment list entries that didn't really
				 * have fragments of the desired size.*/
    int	fullBlockFrags;		/* Full blocks that had to be fragmented. */
d212 5
a216 4
    int	accesses;		/* Number of times something was looked for */
    int	hits;			/* Number of times it was found */
    int	replacements;		/* Number of entries recycled via LRU */
    int size;			/* Number of entries total */
d223 22
a244 18
    int	exists;		/* Handles currently in existence. */
    int	created;	/* Handles that have been created. */
    int updateCalls;	/* Number of calls to HandleUpdate */
    int	installCalls;	/* Calls to FsHandleInstall. */
    int	installHits;	/* Number of installs in which handle was found. */
    int	versionMismatch;/* Version mismatch on file. */
    int	cacheFlushes;	/* Cache flushed because of version mismatch of not
			 * cacheable. */
    int	oldHandles;	/* Handles whose creation date is out of date. */
    int	fetchCalls;	/* Calls to FsHandleFetch. */
    int	fetchHits;	/* Number of fetches in which handle was found. */
    int	lockCalls;	/* Calls to FsHandleLock. */
    int	locks;		/* Number of times a handle was locked. */
    int	lockWaits;	/* Number of times had to wait to lock a handle. */
    int	releaseCalls;	/* Calls to FsHandleRelease. */
    int	segmentFetches;	/* Calls by VM to see if there is indeed already a
			 * segment with the code file. */
    int	segmentHits;	/* Segment fetches that return non-nil segment. */
d251 10
a260 7
    int relative;	/* Number of relative names encountered */
    int absolute;	/* Number of absolute names subject to prefix lookup */
    int redirects;	/* Number of redirects from the server */
    int loops;		/* Number of circular redirects (domain unavailable) */
    int timeouts;	/* Number of times the server was down */
    int stale;		/* Number of times server server rejected a handle */
    int found;		/* Number of times found a new prefix */
d262 1
d264 83
d356 1
d358 15
@
