head     9.7;
branch   ;
access   ;
symbols  ds3100:9.7 sun3:9.7 sun4nw:9.6 symm:9.6 spur:9.6 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.7
date     92.06.01.14.51.55;  author kupfer;  state Exp;
branches ;
next     9.6;

9.6
date     91.10.18.01.16.34;  author dlong;  state Exp;
branches ;
next     9.5;

9.5
date     90.10.13.17.05.11;  author mendel;  state Exp;
branches ;
next     9.4;

9.4
date     90.09.11.11.00.13;  author mendel;  state Exp;
branches ;
next     9.3;

9.3
date     90.09.06.18.17.32;  author jhh;  state Exp;
branches ;
next     9.2;

9.2
date     90.01.05.12.06.50;  author mgbaker;  state Exp;
branches ;
next     9.1;

9.1
date     89.10.22.22.54.52;  author jhh;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.15.21.08;  author douglis;  state Stable;
branches ;
next     8.4;

8.4
date     89.09.12.14.41.13;  author jhh;  state Exp;
branches ;
next     8.3;

8.3
date     89.02.19.22.12.18;  author jhh;  state Exp;
branches ;
next     8.2;

8.2
date     89.01.05.15.35.19;  author mendel;  state Exp;
branches ;
next     8.1;

8.1
date     88.11.22.19.37.35;  author jhh;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.39.34;  author douglis;  state Stable;
branches ;
next     6.2;

6.2
date     88.10.11.16.32.39;  author mendel;  state Exp;
branches ;
next     6.1;

6.1
date     88.10.07.10.53.12;  author mendel;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.28.08;  author brent;  state Stable;
branches ;
next     5.3;

5.3
date     88.06.27.10.30.03;  author mendel;  state Exp;
branches ;
next     5.2;

5.2
date     88.05.27.16.24.55;  author mendel;  state Exp;
branches ;
next     5.1;

5.1
date     88.05.05.18.02.02;  author nelson;  state Exp;
branches ;
next     5.0;

5.0
date     87.08.11.10.51.40;  author sprite;  state Exp;
branches ;
next     ;


desc
@@


9.7
log
@Fix include statements ("" to <>).  Add Timer_OkToWhine.
@
text
@/*
 * timerClock.c --
 *
 *	Kernel utility procedures to manipulate clocks values.
 *
 *  The routines in this module provide the interface between routines in 
 *  the human oriented time and the machine dependent representation of 
 *  time, the Timer_Ticks format. The Timer_Ticks format is used
 *  for a specific purpose: to make the operations associated with the
 *  callback timer and timer queue run fast. These operations include
 *  starting the timer, scheduling a routine and calling a routine at its
 *  scheduled time.  Unlike the Time format, which represents time in
 *  seconds and microseconds, the Timer_Ticks format represents time in a
 *  machine-dependent way. Timer_Ticks are defined in timerTicks.h in the 
 *  machine-dependent directorys. Example Timer_Ticks format are as follows:
 *  Sun-2: Timer_Ticks is a value based on the hardware's free-running 
 *  counter and the number of times it has wrapped around. 
 *  Sun-3: the hardware free-running counter format is easily converted
 *  to the Time format, so no distinction is made between Time and Timer_Ticks.
 *
 *  A time value in the Timer_Ticks format is a hardware-dependent 64-bit
 *  number that represents a specific or absolute point in time since some
 *  some event (on the Sun-2, since the system was booted).  A time value
 *  that is relative to an absolute time is called an interval.  By
 *  definition, an interval is a hardware-dependent unsigned 32-bit number.  
 *  The operations * and / can be used on intervals since they are integers.
 *
 *  There are several constraints imposed on the Timer_Ticks format to
 *  decrease complexity and overhead in using the format.  First, it can
 *  not be used to represent negative time values.  Second, the routines
 *  are not general. For example, there are no multiply and divide
 *  routines for Timer_Ticks values.  Full generality is obtained by using
 *  the Time module.
 *
 * Copyright 1985, 1988 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 *
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/timer/timerClock.c,v 9.6 91/10/18 01:16:34 dlong Exp $ SPRITE (Berkeley)";
#endif not lint

#include <sprite.h>
#include <proc.h>
#include <sync.h>
#include <timer.h>
#include <timerInt.h>
#include <spriteTime.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <timerTick.h>
#include <machMon.h>


/*
 *  Universal Time is the number of seconds since 1/1/1970, Greenwich Time.
 *  The time of day is kept in Universal Time. We use the terms "time of
 *  day" and "universal time" interchangably, although the latter is
 *  probably more descriptive. Universal time is mainly used by user-level
 *  programs. "System time" is what the kernel typically uses to measure
 *  time.  System time is the amount of time that the machine has been up.
 *  It is usually maintained by a free-running counter and expressed in
 *  units of ticks. System time is a more useful abstraction since it
 *  is not reset, whereas universal time can be adjusted by a system call.
 *
 *  The term "time" is very overloaded in both the comments and the code.
 *  I've tried to make it as clear as possible which format a particular
 *  time variable is stored in.  Time variables with standard names are
 *  of type "Time".  Time variables with "Tk" appended to their names
 *  are of type "Timer_Ticks".  There may be exceptions to this naming
 *  scheme.
 *
 *  Universal time can be obtained through one of two routines.
 *  Timer_GetRealTimeOfDay is quite accurate but the routine is slow due
 *  to the conversion from internal Timer_Ticks format to Time format.
 *  The other value is timerTimeOfDay and is returned by
 *  Timer_GetTimeOfDay.  The value is updated at every request timer
 *  interrupt by adding the amount of time between interrupts and hence is
 *  very inexpensive to calculate.  Also, the resolution is limited to the
 *  time between interrupts. However, the value is not always accurate
 *  because a timer interrupt can be delayed, therefore it is a close
 *  approximation to the real time of day.  To keep the value roughly
 *  accurate, every 10 seconds timer_UniversalApprox is updated to the real
 *  time of day by a routine called from the timer queue.  The value
 *  of timer_UniversalApprox is guaranteed to be monotonically increasing
 *  between calls to Timer_SetTimeOfDay.
 *
 *  When the universal time is initially set with Timer_SetTimeOfDay, the
 *  current system time is recorded (in systemWhenUniversalSetTk) along with 
 *  the new value for the universal time (in universalWhenSetTk).
 *  This value for universal time is not incremented. When 
 *  Timer_GetTimeOfDay is called, the current universal time is calculated by 
 *  reading the current system time and subtracting from it the system time 
 *  when Timer_SetTimeOfDay was called. This difference is added to the 
 *  recorded universal time to give the current universal time.
 *  
 *  timerUniversalToLocalOffset is used to convert from universal time
 *  to local time. It is the number of minutes to add to universal time
 *  to compute the local time. For example, timerLocalOffset for the 
 *  Pacific time zone is -540 minutes. The local time of day is computed 
 *  by multiplying timerUniversalToLocalOffset by 60 and adding the result 
 *  to the universal time.
 *
 *  timerDSTAllowed is a flag to indicate if Daylight Savings Time is allowed.
 *  A few states, such as Arizona, do not have DST.
 *  (TRUE == DST is allowed, FALSE == DST is not allowed).
 */

static Timer_Ticks systemWhenUniversalSetTk;
static Timer_Ticks universalWhenSetTk;

Time   		timer_UniversalApprox;
int 		timerUniversalToLocalOffset;
Boolean 	timerDSTAllowed;

#ifdef ADJTIME
Time		timer_AdjustDelta;
unsigned	timer_TickAdjust;
int		timer_TickDelta;
#endif

/*
 * Semaphore protecting the above time of day variables.
 */

Sync_Semaphore	timer_ClockMutex;


/* 
 * List of "whining" messages that have been displayed recently.  These are 
 * generally error messages that we want to keep from flooding the console.
 */

#define WHINE_INTERVAL	30	/* time to allow between messages */

typedef struct {
    List_Links links;
    char *message;		/* the message */
    time_t lastDisplayTime;	/* when it was last displayed */
} WhineMsg;

static List_Links whineListHdr;
static List_Links *whineList = &whineListHdr;

static Sync_Lock whineLock = Sync_LockInitStatic("timer:whineLock");
				/* lock to protect whineList */


/*
 * UpdateTimeOfDay() adjusts timerTimeOfDay to the real time of day.
 */

static void UpdateUniversalTimeApprox _ARGS_((Timer_Ticks timeTicks, 
				  ClientData  clientData));
static Timer_QueueElement      updateElement;

/* (More) forward references */

static WhineMsg *NewWhineMsg _ARGS_((char *message));
static void FreeWhineMsg _ARGS_((WhineMsg *msgPtr));



/*
 *----------------------------------------------------------------------
 *
 * TimerClock_Init --
 *
 *	Initializes the data structures necessary to manage the timer
 *	modules' time of day clock.
 *
 * Results:
 *     None.
 *
 * Side effects:
 *     The system counter is initialized and started.
 *
 *----------------------------------------------------------------------
 */

void
TimerClock_Init()
{

    Time	universal;
    int		offset;
    Boolean	DST;

    Sync_SemInitDynamic(&timer_ClockMutex,"Timer:timer_ClockMutex");

    Timer_CounterInit();
#ifdef ADJTIME
    timer_AdjustDelta.seconds = timer_AdjustDelta.microseconds = 0;
    timer_TickAdjust = 10;
    timer_TickDelta = 0;
#endif
    universal.seconds = 0;
    universal.microseconds = 0;
    offset = 0;
    DST = TRUE;
    TimerHardwareUniversalTimeInit(&universal, &offset, &DST);
    TimerSetSoftwareUniversalTime(&universal, offset, DST);
    /*
     * Add the routine to fix the time of day to the timer queue.
     * The routine is called every 10 seconds.
     */

    updateElement.routine = UpdateUniversalTimeApprox;
    updateElement.interval = 10 * timer_IntOneSecond;
    Timer_ScheduleRoutine(&updateElement, TRUE);

    /* 
     * Also initialize the "whine message" list.
     */
    List_Init(whineList);
}



/*
 *----------------------------------------------------------------------
 *
 *  Timer_GetRealTimeOfDay --
 *
 *	Retrieves an accurate value for the time of day. 
 *	This routine is much slower than Timer_GetTimeOfDay but
 *	returns a much more truthful value for the time of day.
 *
 *  Results:
 *	The time of day is returned.
 *
 *  Side Effects:
 *	Updates the global variables that stores the system up-time.
 *
 *----------------------------------------------------------------------
 */

void
Timer_GetRealTimeOfDay(timePtr, timerLocalOffsetPtr, DSTPtr)
    Time *timePtr;		/* Buffer to hold TOD. */
    int  *timerLocalOffsetPtr;	/* Optional buffer to hold local offset. */
    Boolean *DSTPtr;		/* Optional buffer to hold DST allowed flag. */
{
    Timer_Ticks	curSystemTk;	/* current system time */
    Timer_Ticks	diffTk;

    /*
     *  Get the current system time and subtract from it the system time
     *  when the universal time was last set. Add this difference to the value
     *  of the stored universal time to get the current universal time.
     */

    MASTER_LOCK(&timer_ClockMutex);

    Timer_GetCurrentTicks(&curSystemTk);

    Timer_SubtractTicks(curSystemTk, systemWhenUniversalSetTk, &diffTk);
    Timer_AddTicks(diffTk, universalWhenSetTk, &diffTk);
    Timer_TicksToTime(diffTk, timePtr);

    if (timerLocalOffsetPtr != (int *) NIL) {
	*timerLocalOffsetPtr = timerUniversalToLocalOffset;
    }
    if (DSTPtr != (Boolean *) NIL) {
	*DSTPtr = timerDSTAllowed;
    }
    MASTER_UNLOCK(&timer_ClockMutex);

}


/*
 *----------------------------------------------------------------------
 *
 *  Timer_GetRealTimeFromTicks --
 *
 *	Gives an accurate translation of ticks to time.  This routine
 *	returns an absolute time value, rather than the relative time
 *	value since booting returned by Timer_TicksToTime.  This routine
 *	is slower, though.
 *
 *  Results:
 *	The time of the tick value is returned.
 *
 *  Side Effects:
 *	Updates the global variables that stores the system up-time.
 *
 *----------------------------------------------------------------------
 */

void
Timer_GetRealTimeFromTicks(ticks, timePtr, timerLocalOffsetPtr, DSTPtr)
    Timer_Ticks	ticks;		/* Ticks value to convert to time. */
    Time *timePtr;		/* Buffer to hold time value. */
    int  *timerLocalOffsetPtr;	/* Optional buffer to hold local offset. */
    Boolean *DSTPtr;		/* Optional buffer to hold DST allowed flag. */
{
    Timer_Ticks	diffTk;

    /*
     * No masterlock, since we can be called from a call-back and get deadlock.
     */

    /*
     *  Get the tick value and subtract from it the system time
     *  when the universal time was last set. Add this difference to the value
     *  of the stored universal time to get the universal time at that tick
     *  value.
     */

    Timer_SubtractTicks(ticks, systemWhenUniversalSetTk, &diffTk);
    Timer_AddTicks(diffTk, universalWhenSetTk, &diffTk);
    Timer_TicksToTime(diffTk, timePtr);

    if (timerLocalOffsetPtr != (int *) NIL) {
	*timerLocalOffsetPtr = timerUniversalToLocalOffset;
    }
    if (DSTPtr != (Boolean *) NIL) {
	*DSTPtr = timerDSTAllowed;
    }

    return;
}


/*
 *----------------------------------------------------------------------
 *
 *  Timer_GetTimeOfDay--
 *
 *	Retrieves an approximate universal time. 
 *	The value is approximate because it is updated at every
 *	timer interrupt and timer interrupts may be delayed or dropped.
 *	For an accurate value, use Timer_GetRealTimeOfDay.
 *
 *	Though the time of day value may not be accurate, it is
 *	guaranteed to be monotonically increasing (i.e. it never goes
 *	backwards) between calls to Timer_SetTimeOfDay.
 *
 *  Results:
 *	The approximate time of day is returned.
 *
 *  Side Effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
Timer_GetTimeOfDay(timePtr, timerLocalOffsetPtr, DSTPtr)
    Time *timePtr;		/* Buffer to hold TOD. */
    int  *timerLocalOffsetPtr;	/* Optional buffer to hold local offset. */
    Boolean *DSTPtr;		/* Optional buffer to hold DST allowed flag. */
{


    MASTER_LOCK(&timer_ClockMutex);

    *timePtr = timer_UniversalApprox;

    if (timerLocalOffsetPtr != (int *) NIL) {
	*timerLocalOffsetPtr = timerUniversalToLocalOffset;
    }
    if (DSTPtr != (Boolean *) NIL) {
	*DSTPtr = timerDSTAllowed;
    }


    MASTER_UNLOCK(&timer_ClockMutex);

}


/*
 *----------------------------------------------------------------------
 *
 *  Timer_SetTimeOfDay --
 *
 *	Changes the universal time to a new value. This is done in
 *	both the software and hardware clocks (if the machine has one).
 *	IMPORTANT: we don't set the hardware clock because it will won't
 *	work on a ds3100. See the comment in TimerSetHardwareUniversalTime.
 *
 *  Results:
 *	None.
 *
 *  Side Effects:
 *	Universal time is changed.
 *
 *----------------------------------------------------------------------
 */

void
Timer_SetTimeOfDay(newUniversal, newLocalOffset, newDSTAllowed)
    Time newUniversal;		/* New value for time of day. */
    int  newLocalOffset;	/* New value for local offset. */
    Boolean newDSTAllowed;	/* New value for DST allowed flag. */
{
    MASTER_LOCK(&timer_ClockMutex);
    TimerSetSoftwareUniversalTime(&newUniversal, 
	newLocalOffset, newDSTAllowed);
#ifdef NOTDEF
    TimerSetHardwareUniversalTime(&newUniversal, newLocalOffset, 
	newDSTAllowed);
#endif
    MASTER_UNLOCK(&timer_ClockMutex);
}


/*
 *----------------------------------------------------------------------
 *
 *  TimerSetSoftwareUniversalTime --
 *
 *	Changes the universal time to a new value.
 *
 *  Results:
 *	None.
 *
 *  Side Effects:
 *	Updates the global variables that stores the universal time and the 
 *	system time when it was set.
 *
 *----------------------------------------------------------------------
 */

void
TimerSetSoftwareUniversalTime(newUniversal, newLocalOffset, newDSTAllowed)
    Time *newUniversal;		/* New value for time of day. */
    int  newLocalOffset;	/* New value for local offset. */
    Boolean newDSTAllowed;	/* New value for DST allowed flag. */
{

    /*
     *  Record when the universal time was changed by saving the current 
     *  system time.
     *  Also store the new universal time (it has to be converted to ticks),
     *  the new local offset and the DST flag.
     */



    timer_UniversalApprox = *newUniversal;

    Timer_GetCurrentTicks(&systemWhenUniversalSetTk);
    Timer_TimeToTicks(*newUniversal, &universalWhenSetTk);


    timerUniversalToLocalOffset = newLocalOffset;
    timerDSTAllowed = newDSTAllowed;


}

/*
 *----------------------------------------------------------------------
 *
 * UpdateUniversalTimeApprox --
 *
 *	Called from the timer queue to make timer_UniversalApprox close
 *	to the real current time..
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	timerUTApprox is updated.
 *
 *----------------------------------------------------------------------
 */

static void
UpdateUniversalTimeApprox(timeTicks, clientData)
    Timer_Ticks timeTicks;	/* Not used. */
    ClientData	clientData;	/* Not used. */
{
	/* 
	 * No need to get the timerClock Mutex lock because 
	 * Timer_GetRealTimeOfDay gets it for us.
	 */
    Timer_GetRealTimeOfDay(&timer_UniversalApprox, (int *) NIL, (int *) NIL);
    Timer_ScheduleRoutine(&updateElement, TRUE);
}

#ifdef ADJTIME
/*
 *----------------------------------------------------------------------
 *
 * Timer_AdjustTime --
 *
 *	Set a new time delta for adjusting the time, and return
 *	the old one.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	timer_AdjustDelta and timer_TickDelta are updated.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Timer_AdjustTime(newDelta, oldDelta)
    Time	*newDelta;
    Time	*oldDelta;
{
    int negative;

    MASTER_LOCK(&timer_ClockMutex);
    if (oldDelta != USER_NIL) {
	if (Proc_ByteCopy(FALSE, sizeof(Time),
		(Address) &timer_AdjustDelta, (Address) oldDelta) != SUCCESS) {
	    MASTER_UNLOCK(&timer_ClockMutex);
	    return SYS_ARG_NOACCESS;
	}
    }
    if (newDelta == USER_NIL) {
	MASTER_UNLOCK(&timer_ClockMutex);
	return oldDelta == USER_NIL ? SYS_ARG_NOACCESS : SUCCESS;
    } else if (Proc_ByteCopy(TRUE, sizeof(Time),
	    (Address) newDelta, (Address) &timer_AdjustDelta) != SUCCESS) {
	MASTER_UNLOCK(&timer_ClockMutex);
	return SYS_ARG_NOACCESS;
    }
    /* normalize */
    timer_AdjustDelta.seconds += timer_AdjustDelta.microseconds / ONE_SECOND;
    timer_AdjustDelta.microseconds %= ONE_SECOND;
    negative = timer_AdjustDelta.seconds < 0 ||
	(timer_AdjustDelta.seconds == 0 && timer_AdjustDelta.microseconds < 0);
    if (negative && (timer_AdjustDelta.microseconds > 0)) {
	timer_AdjustDelta.microseconds -= ONE_SECOND;
	++timer_AdjustDelta.seconds;
    }
    if (!negative && (timer_AdjustDelta.microseconds < 0)) {
	timer_AdjustDelta.microseconds += ONE_SECOND;
	--timer_AdjustDelta.seconds;
    }
    if (negative) {
	timer_TickDelta = -timer_TickAdjust;
    } else {
	timer_TickDelta = timer_TickAdjust;
    }
    MASTER_UNLOCK(&timer_ClockMutex);
    return SUCCESS;
}

/*
 *----------------------------------------------------------------------
 *
 * Timer_GetParams --
 *
 *	Return the current tick adjustment.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Timer_GetParams(tickadj)
    unsigned	*tickadj;
{
    MASTER_LOCK(&timer_ClockMutex);
    if (tickadj == USER_NIL || Proc_ByteCopy(FALSE, sizeof(unsigned),
	    (Address) &timer_TickAdjust, (Address) tickadj) != SUCCESS) {
	MASTER_UNLOCK(&timer_ClockMutex);
	return(SYS_ARG_NOACCESS);
    }
    MASTER_UNLOCK(&timer_ClockMutex);
    return SUCCESS;
}

/*
 *----------------------------------------------------------------------
 *
 * Timer_SetParams --
 *
 *	Set the tick adjustment.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	timer_TickAdjust and timer_TickDelta are updated.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
ReturnStatus
Timer_SetParams(tickadj)
    unsigned	tickadj;
{
    MASTER_LOCK(&timer_ClockMutex);
    if (tickadj < TIMER_CALLBACK_INTERVAL_APPROX &&
	    tickadj > 0 && (ONE_SECOND % tickadj) == 0) {
	timer_TickAdjust = tickadj;
	if (timer_AdjustDelta.seconds < 0
	    || (timer_AdjustDelta.seconds == 0
		&& timer_AdjustDelta.microseconds < 0)) {
	    timer_TickDelta = -timer_TickAdjust;
	} else {
	    timer_TickDelta = timer_TickAdjust;
	}
	MASTER_UNLOCK(&timer_ClockMutex);
	return SUCCESS;
    } else {
	MASTER_UNLOCK(&timer_ClockMutex);
	return GEN_INVALID_ARG;
    }
}
#endif


/*
 *----------------------------------------------------------------------
 *
 * Timer_OkToWhine --
 *
 *	Keep track of when a given message was last displayed, and tell 
 *	whether it's too soon to display it again.
 *
 * Results:
 *	Returns TRUE if it's been more than WHINE_INTERVAL seconds since
 *	the last time the given message had been displayed.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Boolean
Timer_OkToWhine(message)
    char *message;		/* message to check */
{
    WhineMsg *msgPtr;		/* a message in the list */
    WhineMsg *delPtr;		/* message to remove from the list */
    Boolean okay = TRUE;	/* okay to display the message? */
    Boolean inList = FALSE;	/* is the message already in the list? */
    time_t now = Timer_GetUniversalTimeInSeconds();

    Sync_GetLock(&whineLock);

    /* 
     * If the message was displayed within the last WHINE_INTERVAL seconds, 
     * don't display it again.  Otherwise, note the new display time.
     */
    LIST_FORALL(whineList, (List_Links *)msgPtr) {
	if (strcmp(msgPtr->message, message) == 0) {
	    if (now >= msgPtr->lastDisplayTime + WHINE_INTERVAL) {
		msgPtr->lastDisplayTime = now;
	    } else {
		okay = FALSE;
	    }
	    inList = TRUE;
	    break;
	} 
    }

    /* 
     * If the message isn't in the list, add it.
     */
    if (!inList) {
	msgPtr = NewWhineMsg(message);
	List_Insert((List_Links *)msgPtr, LIST_ATREAR(whineList));
    }

    /* 
     * Garbage collect any old messages.
     */
    msgPtr = (WhineMsg *)List_First(whineList);
    while (!List_IsAtEnd(whineList, (List_Links *)msgPtr)) {
	if (now < msgPtr->lastDisplayTime + WHINE_INTERVAL) {
	    msgPtr = (WhineMsg *)List_Next((List_Links *)msgPtr);
	} else {
	    delPtr = msgPtr;
	    msgPtr = (WhineMsg *)List_Next((List_Links *)msgPtr);
	    List_Remove((List_Links *)delPtr);
	    FreeWhineMsg(delPtr);
	}
    }

    Sync_Unlock(&whineLock);
    return okay;
}


/*
 *----------------------------------------------------------------------
 *
 * NewWhineMsg --
 *
 *	Create and initialize a new WhineMsg.
 *
 * Results:
 *	Returns an initialized WhineMsg.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static WhineMsg *
NewWhineMsg(message)
    char *message;		/* the text of the message to record */
{
    WhineMsg *msgPtr;

    msgPtr = (WhineMsg *)malloc(sizeof(WhineMsg));
    List_InitElement((List_Links *)msgPtr);
    msgPtr->message = strdup(message);
    msgPtr->lastDisplayTime = Timer_GetUniversalTimeInSeconds();

    return msgPtr;
}


/*
 *----------------------------------------------------------------------
 *
 * FreeWhineMsg --
 *
 *	Destroy a WhineMsg.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
FreeWhineMsg(msgPtr)
    WhineMsg *msgPtr;		/* the message to free */
{
    free((Address)msgPtr->message);
    free((Address)msgPtr);
}
@


9.6
log
@added adjust time support
@
text
@d47 1
a47 1
static char rcsid[] = "$Header: /sprite/src/kernel/timer/RCS/timerClock.c,v 9.5 90/10/13 17:05:11 mendel Exp $ SPRITE (Berkeley)";
d50 12
a61 8
#include "sprite.h"
#include "proc.h"
#include "sync.h"
#include "timer.h"
#include "timerInt.h"
#include "spriteTime.h"
#include "timerTick.h"
#include "machMon.h"
d137 20
d165 5
d219 5
d625 130
@


9.5
log
@Removed lint.
@
text
@d47 1
a47 1
static char rcsid[] = "$Header: /sprite/src/kernel/timer/RCS/timerClock.c,v 9.4 90/09/11 11:00:13 mendel Exp $ SPRITE (Berkeley)";
d120 6
d171 5
d459 24
d484 107
@


9.4
log
@Added proc.h include.
@
text
@d47 1
a47 1
static char rcsid[] = "$Header: /sprite/src/kernel/timer/RCS/timerClock.c,v 9.3 90/09/06 18:17:32 jhh Exp Locker: mendel $ SPRITE (Berkeley)";
d131 2
a132 1
static void UpdateUniversalTimeApprox _ARGS_((void));
d436 3
a438 1
UpdateUniversalTimeApprox()
@


9.3
log
@First pass at function prototypes
@
text
@d47 1
a47 1
static char rcsid[] = "$Header: /sprite/src/kernel/timer/RCS/timerClock.c,v 9.2 90/01/05 12:06:50 mgbaker Exp Locker: jhh $ SPRITE (Berkeley)";
d51 1
@


9.2
log
@Added new call to get real time from ticks.
@
text
@d47 1
a47 1
static char rcsid[] = "$Header: /sprite/src/kernel/timer/RCS/timerClock.c,v 9.1 89/10/22 22:54:52 jhh Exp Locker: mgbaker $ SPRITE (Berkeley)";
d130 1
a130 1
static void UpdateUniversalTimeApprox();
@


9.1
log
@Fixed lint errors
@
text
@d47 1
a47 1
static char rcsid[] = "$Header: /sprite/src/kernel/timer/RCS/timerClock.c,v 9.0 89/09/12 15:21:08 douglis Stable Locker: jhh $ SPRITE (Berkeley)";
d230 54
@


9.0
log
@Changing version numbers.
@
text
@d47 1
a47 1
static char rcsid[] = "$Header: /sprite/src/kernel/timer/RCS/timerClock.c,v 8.4 89/09/12 14:41:13 jhh Exp Locker: douglis $ SPRITE (Berkeley)";
a155 1
    char	buffer[100];
@


8.4
log
@renamed things
@
text
@d47 1
a47 1
static char rcsid[] = "$Header: /sprite/src/kernel/timer/RCS/timerClock.c,v 8.3 89/02/19 22:12:18 jhh Exp $ SPRITE (Berkeley)";
@


8.3
log
@Changes due to lock registration
@
text
@d47 1
a47 1
static char rcsid[] = "$Header: /sprite/src/kernel/timer/RCS/timerClock.c,v 8.2 89/01/05 15:35:19 mendel Exp Locker: jhh $ SPRITE (Berkeley)";
d56 1
d59 16
a74 3
 *  The time of day (abbreviated TOD, also called Universal Time
 *  or Greenwich Time) is the number of seconds since 1/1/1970.
 *  It is updated whenever Timer_{S,G}etTimeOfDay is called.
d76 1
a76 9
 *  The TOD time is maintained for human consumption; it is not used by
 *  the kernel for internal time.  Two values are maintained because the TOD
 *  is obtained by an RPC call to the file server. The RPC module relies on
 *  the Sync and Sched modules, which rely on the Timer module.  If the
 *  current time is changed to TOD once the timer queue has been
 *  initialized, then RPCs will hang for a very long time (i.e.  
 *  1986 - 1970 = 16 years).
 *  
 *  Two TOD values are available. The value returned by
d86 1
a86 1
 *  accurate, every 10 seconds timerTimeOfDay is updated to the real
d88 1
a88 1
 *  of timerTimeOfDay is guaranteed to be monotonically increasing
d91 6
a96 5
 *  When the time of day is initially set with Timer_SetTimeOfDay, the
 *  current system up-time is recorded (in timeWhenTODSet) along with 
 *  the new value for the time of day (in timeOfDay).  When 
 *  Timer_GetTimeOfDay is called, the current TOD is calculated by 
 *  reading the current system up-time and subtracting from it the time 
d98 1
a98 1
 *  recorded TOD to give the current TOD.
d100 6
a105 5
 *  LocalOffset is used to convert timeOfDay from Universal Time
 *  to local time. It is the number of minutes to add to Universal Time
 *  to compute the local time. For example, localOffset for the Pacific time 
 *  zone is -540 minutes. The local time of day is computed by multiplying
 *  localOffset by 60 and adding the result added to timeOfDay.
d107 1
a107 1
 *  DSTAllowed is a flag to indicate if Daylight Savings Time is allowed.
d112 2
a113 2
static Timer_Ticks timeWhenTODSet	= { 0, 0 };
static Timer_Ticks timeOfDay		= { 0, 0 };
d115 3
a117 3
Time   timerTimeOfDay			= { 0, 0 };
static int localOffset			= 0;
static Boolean DSTAllowed		= TRUE;
d123 1
a123 1
Sync_Semaphore	timerClockMutex;
d130 1
a130 1
static void UpdateTimeOfDay();
d156 6
a161 1
    Sync_SemInitDynamic(&timerClockMutex,"Timer:timerClockMutex");
d164 6
a169 1

d175 1
a175 1
    updateElement.routine = UpdateTimeOfDay;
d201 1
a201 1
Timer_GetRealTimeOfDay(timePtr, localOffsetPtr, DSTPtr)
d203 1
a203 1
    int  *localOffsetPtr;	/* Optional buffer to hold local offset. */
d206 2
a207 2
    Timer_Ticks	curTime;
    Timer_Ticks	diff;
d210 3
a212 3
     *  Get the current uptime time and subtract from it the uptime when the
     *	the time of day was last set. Add this difference to the value
     *  of the stored time of day to get the current T.O.D.
d215 1
a215 2
    MASTER_LOCK(&timerClockMutex);

d217 1
a217 1
    Timer_GetCurrentTicks(&curTime);
d219 3
a221 3
    Timer_SubtractTicks(curTime, timeWhenTODSet, &diff);
    Timer_AddTicks(diff, timeOfDay, &diff);
    Timer_TicksToTime(diff, timePtr);
d223 2
a224 2
    if (localOffsetPtr != (int *) NIL) {
	*localOffsetPtr = localOffset;
d227 1
a227 1
	*DSTPtr = DSTAllowed;
d229 1
a229 1
    MASTER_UNLOCK(&timerClockMutex);
d237 1
a237 1
 *  Timer_GetTimeOfDay --
d239 1
a239 1
 *	Retrieves an approximate value for the time of day. 
d258 1
a258 1
Timer_GetTimeOfDay(timePtr, localOffsetPtr, DSTPtr)
d260 1
a260 1
    int  *localOffsetPtr;	/* Optional buffer to hold local offset. */
a263 1
    MASTER_LOCK(&timerClockMutex);
d265 1
a265 1
    *timePtr = timerTimeOfDay;
d267 4
a270 2
    if (localOffsetPtr != (int *) NIL) {
	*localOffsetPtr = localOffset;
d273 1
a273 1
	*DSTPtr = DSTAllowed;
d276 2
a277 1
    MASTER_UNLOCK(&timerClockMutex);
d287 35
a321 1
 *	Changes the time of day to a new value.
d323 2
d329 2
a330 2
 *	Updates the global variables that stores the TOD and the time
 *	it was set.
d336 2
a337 2
Timer_SetTimeOfDay(newTOD, newLocalOffset, newDSTAllowed)
    Time newTOD;		/* New value for time of day. */
d343 3
a345 2
     *  Record when the T.O.D was changed by saving the current time.
     *  Also store the new T.O.D (it has to be converted to ticks),
d349 3
a351 1
    MASTER_LOCK(&timerClockMutex);
d353 2
a355 1
    timerTimeOfDay = newTOD;
d357 2
a358 6
    Timer_GetCurrentTicks(&timeWhenTODSet);
    Timer_TimeToTicks(newTOD, &timeOfDay);


    localOffset 	= newLocalOffset;
    DSTAllowed 		= newDSTAllowed;
a359 1
    MASTER_UNLOCK(&timerClockMutex);
d366 1
a366 1
 * UpdateTimeOfDay --
d368 2
a369 2
 *	Called from the timer queue to make timerTimeOfDay close
 *	to the real current time as calculated by Timer_GetTimeOfDay.
d375 1
a375 1
 *	timerTimeOfDay is updated.
d381 1
a381 1
UpdateTimeOfDay()
d387 1
a387 1
    Timer_GetRealTimeOfDay(&timerTimeOfDay, (int *) NIL, (int *) NIL);
@


8.2
log
@Perform timer call back without the timerMutex held to prevent deadlocks
on multiprocessors.
@
text
@d47 1
a47 1
static char rcsid[] = "$Header: /sprite/src/kernel/timer/RCS/timerClock.c,v 8.1 88/11/22 19:37:35 jhh Exp Locker: mendel $ SPRITE (Berkeley)";
d115 1
a115 1
Sync_Semaphore	timerClockMutex = SYNC_SEM_INIT_STATIC("timerClockMutex");
d147 2
@


8.1
log
@new semaphore definition
@
text
@d47 1
a47 1
static char rcsid[] = "$Header: timerClock.c,v 6.2 88/10/11 16:32:39 mendel Exp $ SPRITE (Berkeley)";
d332 1
a332 1
    Timer_RescheduleRoutine(&updateElement, TRUE);
@


8.0
log
@Changing version numbers.
@
text
@d47 1
a47 1
static char rcsid[] = "$Header: /sprite/src/kernel/timer/RCS/timerClock.c,v 6.2 88/10/11 16:32:39 mendel Exp Locker: douglis $ SPRITE (Berkeley)";
d115 1
a115 1
int	timerClockMutex = 0;
d195 1
a195 1
    MASTER_LOCK(timerClockMutex);
d210 1
a210 1
    MASTER_UNLOCK(timerClockMutex);
d245 1
a245 1
    MASTER_LOCK(timerClockMutex);
d256 1
a256 1
    MASTER_UNLOCK(timerClockMutex);
d291 1
a291 1
    MASTER_LOCK(timerClockMutex);
d303 1
a303 1
    MASTER_UNLOCK(timerClockMutex);
@


6.2
log
@Multiprocessor port.
@
text
@d47 1
a47 1
static char rcsid[] = "$Header: timerClock.c,v 6.1 88/10/07 10:53:12 mendel Exp $ SPRITE (Berkeley)";
@


6.1
log
@Moved the devTimer routines into the timer module.
@
text
@d47 1
a47 1
static char rcsid[] = "$Header: timerClock.c,v 6.0 88/08/11 12:28:08 brent Stable $ SPRITE (Berkeley)";
d51 1
a51 1
#include "mach.h"
d54 1
a54 1
#include "time.h"
a55 2
#include "sys.h"
#include "byte.h"
d111 14
d130 35
d195 1
a195 5
    /* 
     * I don't think that we need DISABLE_INTR because Timer_GetCurrentTicks
     * already does a DISABLE_INTR before reading the counter.  On the other
     * hand the timer module works fine with the DISABLE_INTR. 
     */
a196 1
    DISABLE_INTR();
a203 2
    ENABLE_INTR();

d210 2
a243 4
    /*
     *  Get the approximate time with interrupts disabled because
     *  the value is updated at interrupt time.
     */
d245 1
a245 1
    DISABLE_INTR();
a248 2
    ENABLE_INTR();

d255 3
d291 1
a291 1
    DISABLE_INTR();
d293 1
a298 1
    ENABLE_INTR();
d302 3
d306 30
@


6.0
log
@Changing version numbers.
@
text
@d47 1
a47 1
static char rcsid[] = "$Header: timerClock.c,v 5.3 88/06/27 10:30:03 mendel Exp $ SPRITE (Berkeley)";
d55 1
a55 1
#include "devTimer.h"
@


5.3
log
@Updated Copyright notice.
@
text
@d47 1
a47 1
static char rcsid[] = "$Header: timerClock.c,v 5.2 88/05/27 16:24:55 mendel Exp $ SPRITE (Berkeley)";
@


5.2
log
@Removed machine depentent routines.
@
text
@d35 9
a43 2
 * Copyright 1986 Regents of the University of California
 * All rights reserved.
d47 1
a47 1
static char rcsid[] = "$Header: timerClock.c,v 5.1 88/05/05 18:02:02 nelson Exp $ SPRITE (Berkeley)";
@


5.1
log
@Handles move of stuff from sys to mach.
@
text
@d4 1
a4 1
 *	Kernel utility procedures to manipulate clocks and time values.
d6 3
a8 2
 *  The routines in this module manipulate time values that are
 *  represented in the Timer_Ticks format.  The Timer_Ticks format is used
d14 6
a19 6
 *  machine-dependent way. On the Sun-2, Timer_Ticks is a value based on
 *  the hardware's free-running counter and the number of times it has
 *  wrapped around.  The overhead in using Timer_Ticks is much smaller
 *  than using the Time format.  On the Sun-3, the hardware free-running
 *  counter format is easily converted to the Time format, so no
 *  distinction is made between Time and Timer_Ticks.
d40 1
a40 1
static char rcsid[] = "$Header: timerClock.c,v 5.0 87/08/11 10:51:40 sprite Exp $ SPRITE (Berkeley)";
a50 22

/*
 *  Definition of the maximum number of seconds and microseconds that the
 *  hardware free-running counter can count to.  To make intervals fit in
 *  a 32-bit integer, they are constrained to be less than or equal to
 *  timer_MaxIntervalTime.seconds. To use intervals greater than this
 *  value, one must use the Time_ module arithmetic routines.
 */

Time timer_MaxIntervalTime;

/*
 * Some commonly used values for intervals.
 */

Timer_Ticks	timer_TicksZeroSeconds;
unsigned int    timer_IntZeroSeconds;
unsigned int    timer_IntOneSecond;
unsigned int    timer_IntOneMillisecond;
unsigned int    timer_IntOneMinute;
unsigned int    timer_IntOneHour;

a52 290
 *----------------------------------------------------------------------
 *
 * TimerTicksInit --
 *
 *	Initializes the various tick and interval values.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
TimerTicksInit()
{
    Time tmp;

    Dev_CounterIntToTime((unsigned int) 0xFFFFFFFF, &timer_MaxIntervalTime);

    tmp.seconds = 1;
    tmp.microseconds = 0;
    Dev_CounterTimeToInt(tmp, &timer_IntOneSecond);

    tmp.seconds = 0;
    tmp.microseconds = 1000;
    Dev_CounterTimeToInt(tmp, &timer_IntOneMillisecond);

    timer_IntZeroSeconds	= 0;
    timer_IntOneMinute		= timer_IntOneSecond * 60;
    timer_IntOneHour		= timer_IntOneSecond * 3600;

    Byte_Zero(sizeof(timer_TicksZeroSeconds), (Address)&timer_TicksZeroSeconds);
}


/*
 *----------------------------------------------------------------------
 *
 *  Timer_AddTicks --
 *
 * 	Adds two tick values together.
 *	For the Sun-3, this routine is #defined to be Time_Add().
 *
 *
 *  Results:
 *	A time in ticks.
 *
 *  Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

#ifdef SUN2

void
Timer_AddTicks(a, b, resultPtr)
    Timer_Ticks		a;		/* Addend 1 */
    Timer_Ticks		b;		/* Addend 2 */
    Timer_Ticks		*resultPtr;	/* Sum */
{
    resultPtr->low	= a.low  + b.low;
    resultPtr->high	= a.high + b.high;

    if (resultPtr->low < b.low) {
	resultPtr->high++;
    }

}
#endif SUN2



/*
 *----------------------------------------------------------------------
 *
 *  Timer_SubtractTicks --
 *
 * 	Subtracts the second parameter from the first parameter. 
 *	The second parameter must be less than the first, otherwise 
 *	a zero tick value is returned.
 *	For the Sun-3, this routine is #defined to be Time_Subtract().
 *
 *  Results:
 *	An absolute time in ticks.
 *
 *  Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

#ifdef SUN2

void
Timer_SubtractTicks(a, b, resultPtr)
    Timer_Ticks		a;		/* Minuhend */
    Timer_Ticks		b;		/* Subtrahend */
    Timer_Ticks		*resultPtr;	/* Difference */
{
    if (Timer_TickLE(a, b)) {
	*resultPtr = timer_TicksZeroSeconds;
    } else {
	resultPtr->low = a.low - b.low;

	/*
	 * See if a borrow is necessary from the high-order part.
	 */
	if (a.low < b.low) {
	    resultPtr->high = a.high - b.high - 1;
	} else {
	    resultPtr->high = a.high - b.high;
	}
    }
}
#endif SUN2



/*
 *----------------------------------------------------------------------
 *
 *  Timer_AddIntervalToTicks --
 *
 * 	Adds an interval (32-bit value) to an absolute time (64-bit value).
 *
 *  Results:
 *	An absolute time in ticks.
 *
 *  Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
Timer_AddIntervalToTicks(absolute, interval, resultPtr)
    Timer_Ticks		absolute;	/* Addend 1 */
    unsigned int	interval;	/* Addend 2 */
    Timer_Ticks		*resultPtr;	/* Sum */
{
#ifdef SUN2
    resultPtr->low = absolute.low + interval;

    if (resultPtr->low < interval) {
	resultPtr->high = absolute.high + 1;
    } else {
	resultPtr->high = absolute.high;
    }
#endif SUN2

#ifdef SUN3
    Time	tmp;

    Dev_CounterIntToTime(interval, &tmp);
    Time_Add(absolute, tmp, resultPtr);
#endif SUN3
}


/*
 *----------------------------------------------------------------------
 *
 *  Timer_GetCurrentTicks --
 *
 *  	Computes the number of ticks since the system was booted
 *	by reading the free-running counter.
 *
 *
 *  Results:
 *	The system up-time in ticks.
 *
 *  Side effects:
 *	The value of counter and the number of counter cycles are updated.
 *
 *----------------------------------------------------------------------
 */


void
Timer_GetCurrentTicks(ticksPtr)
    Timer_Ticks	*ticksPtr;	/* Buffer to place current time. */
{
#ifdef SUN2
    unsigned int	counter;
    static Timer_Ticks 		previousTime = {0,0}; 

    DISABLE_INTR();

    Dev_CounterRead(&counter);

    /*
     *	See if the counter has wrapped around since the last reading.
     *  This assumes that we read the counter at least once per
     *  counter cycle.
     */

    if (counter < previousTime.low) {
	previousTime.high++;
    }
    previousTime.low	= counter;
    *ticksPtr 		= previousTime;

    ENABLE_INTR();
#endif SUN2

#ifdef SUN3
    DISABLE_INTR();
    Dev_CounterRead(ticksPtr);
    ENABLE_INTR();
#endif SUN3
}



/*
 *----------------------------------------------------------------------
 *
 *  Timer_TicksToTime --
 *
 *  	Converts a Timer_Ticks value into a Time value.
 *	For the Sun-3, this routine is #defined to be *timePtr = tick;
 *
 *  Results:
 *	A time value in Time format.
 *
 *  Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

#ifdef SUN2

void
Timer_TicksToTime(tick, timePtr)
    Timer_Ticks	tick;		/* Value to be converted. */
    Time	*timePtr;	/* Buffer to hold converted value. */
{
    Time  tmp;
    Dev_CounterIntToTime(tick.low, timePtr);
    Time_Multiply(timer_MaxIntervalTime, (int) tick.high, &tmp);
    Time_Add(*timePtr, tmp, timePtr);
}
#endif SUN2


/*
 *----------------------------------------------------------------------
 *
 *  Timer_TimeToTicks --
 *
 *  	Converts a Time value into a Timer_Ticks value.
 *
 *	For the Sun-3, this routine is #defined to be *ticksPtr = time;
 *
 *  Results:
 *	A time value in ticks.
 *
 *  Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

#ifdef SUN2

void
Timer_TimeToTicks(time, ticksPtr)
    Time	time;		/* Value to be converted. */
    Timer_Ticks	*ticksPtr;	/* Buffer to hold converted value. */
{
    ticksPtr->high = 0;
    while (TRUE) {
	if (Time_LE(time, timer_MaxIntervalTime)) {
	    Dev_CounterTimeToInt(time, &(ticksPtr->low));
	    break;
	} else {
	    Time_Subtract(time, timer_MaxIntervalTime, &time);
	    ticksPtr->high++;
	}
    }
}
#endif SUN2


/*
d141 6
a148 1
#ifdef SUN2
a149 1
#endif SUN2
a150 4
#ifdef SUN3
    Dev_CounterRead(&curTime);
#endif SUN3

a248 1
#ifdef SUN2
a250 6
#endif SUN2

#ifdef SUN3
    Dev_CounterRead(&timeWhenTODSet);
    timeOfDay = newTOD;
#endif SUN3
@


5.0
log
@First Sprite native copy
@
text
@d39 1
a39 1
static char rcsid[] = "$Header: timerClock.c,v 3.2 86/11/09 17:21:43 andrew Exp $ SPRITE (Berkeley)";
d43 1
@
