head     9.22;
branch   ;
access   ;
symbols  ds3100:9.22 sun3:9.22 sun4nw:9.20 symm:9.20 spur:9.20 Summer89:9.0 newlib:8.0 Summer88:6.0 sbc:5.3;
locks    ; strict;
comment  @ * @;


9.22
date     92.03.20.13.47.48;  author jhh;  state Exp;
branches ;
next     9.21;

9.21
date     91.12.11.17.58.44;  author jhh;  state Exp;
branches ;
next     9.20;

9.20
date     91.10.23.11.42.05;  author mendel;  state Exp;
branches ;
next     9.19;

9.19
date     91.10.08.14.06.07;  author mendel;  state Exp;
branches ;
next     9.18;

9.18
date     91.09.17.14.50.48;  author jhh;  state Exp;
branches ;
next     9.17;

9.17
date     91.08.19.13.42.57;  author jhh;  state Exp;
branches ;
next     9.16;

9.16
date     91.06.06.11.21.38;  author mendel;  state Exp;
branches ;
next     9.15;

9.15
date     91.05.29.15.04.28;  author mendel;  state Exp;
branches ;
next     9.14;

9.14
date     91.04.12.17.54.20;  author jhh;  state Exp;
branches ;
next     9.13;

9.13
date     91.03.30.17.01.29;  author jhh;  state Exp;
branches ;
next     9.12;

9.12
date     90.09.11.13.54.32;  author rab;  state Exp;
branches ;
next     9.11;

9.11
date     90.09.11.12.25.11;  author rab;  state Exp;
branches ;
next     9.10;

9.10
date     90.05.14.14.20.27;  author mgbaker;  state Exp;
branches ;
next     9.9;

9.9
date     90.04.30.19.58.05;  author mgbaker;  state Exp;
branches ;
next     9.8;

9.8
date     90.02.16.17.07.44;  author shirriff;  state Exp;
branches ;
next     9.7;

9.7
date     90.02.14.12.46.54;  author jhh;  state Exp;
branches ;
next     9.6;

9.6
date     90.02.13.23.19.51;  author shirriff;  state Exp;
branches ;
next     9.5;

9.5
date     89.12.11.17.41.44;  author brent;  state Exp;
branches ;
next     9.4;

9.4
date     89.10.26.11.29.47;  author mgbaker;  state Exp;
branches ;
next     9.3;

9.3
date     89.10.12.11.09.58;  author mendel;  state Exp;
branches ;
next     9.2;

9.2
date     89.09.28.16.53.41;  author mgbaker;  state Exp;
branches ;
next     9.1;

9.1
date     89.09.18.13.59.33;  author brent;  state Exp;
branches ;
next     9.0;

9.0
date     89.09.12.14.57.33;  author douglis;  state Stable;
branches ;
next     8.10;

8.10
date     89.09.12.14.09.04;  author mendel;  state Exp;
branches ;
next     8.9;

8.9
date     89.08.01.18.46.34;  author nelson;  state Exp;
branches ;
next     8.8;

8.8
date     89.06.16.12.08.09;  author brent;  state Exp;
branches ;
next     8.7;

8.7
date     89.06.15.08.46.36;  author brent;  state Exp;
branches ;
next     8.6;

8.6
date     89.05.23.09.59.42;  author mendel;  state Exp;
branches ;
next     8.5;

8.5
date     89.05.01.16.05.42;  author mendel;  state Exp;
branches ;
next     8.4;

8.4
date     89.02.19.22.02.06;  author jhh;  state Exp;
branches ;
next     8.3;

8.3
date     88.11.28.08.21.33;  author brent;  state Exp;
branches ;
next     8.2;

8.2
date     88.11.21.09.04.14;  author brent;  state Exp;
branches ;
next     8.1;

8.1
date     88.11.16.14.38.24;  author brent;  state Exp;
branches ;
next     8.0;

8.0
date     88.11.11.18.13.55;  author douglis;  state Stable;
branches ;
next     6.2;

6.2
date     88.10.30.21.37.26;  author jhh;  state Exp;
branches ;
next     6.1;

6.1
date     88.09.05.12.45.13;  author mendel;  state Exp;
branches ;
next     6.0;

6.0
date     88.08.11.12.30.15;  author douglis;  state Stable;
branches ;
next     5.5;

5.5
date     88.07.12.18.02.52;  author douglis;  state Exp;
branches ;
next     5.4;

5.4
date     88.06.08.17.01.27;  author douglis;  state Exp;
branches ;
next     5.3;

5.3
date     88.05.25.19.39.12;  author douglis;  state Exp;
branches ;
next     5.2;

5.2
date     88.05.23.21.44.45;  author douglis;  state Exp;
branches ;
next     5.1;

5.1
date     87.09.29.15.48.22;  author nelson;  state Exp;
branches ;
next     5.0;

5.0
date     87.08.11.10.40.09;  author sprite;  state Exp;
branches ;
next     ;


desc
@@


9.22
log
@Removed a couple of annoying printfs.
SCSI commands that abort are retried.
@
text
@/* 
 * devScsiDisk.c --
 *
 *      SCSI Command formatter for SCSI type 0 (Direct Access Devices.) 
 *	This file implements the BlockDevice interface to SCSI disk.
 *
 * Copyright 1986 Regents of the University of California
 * All rights reserved.
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/dev/devSCSIDisk.c,v 9.21 91/12/11 17:58:44 jhh Exp $ SPRITE (Berkeley)";
#endif not lint


#include <sprite.h>
#include <stdio.h>
#include <fs.h>
#include <dev.h>
#include <devInt.h>
#include <sys/scsi.h>
#include <scsiDevice.h>
#include <devDiskLabel.h>
#include <devDiskStats.h>
#include <devBlockDevice.h>
#include <stdlib.h>
#include <bstring.h>
#include <dev/scsi.h>
#include <dbg.h>
#include <fsdm.h>

typedef struct DiskMap {
    int	 firstSector;
    int	 sizeInSectors;
} DiskMap;

/*
 * Maximum size of the disk in sectors. 
 */
#define	MAX_DISK_SIZE	0x7fffffff
/*
 * State info for an SCSI Disk.  This gets allocated and filled in by
 * the attach procedure. 
 */
typedef struct ScsiDisk {
    DevBlockDeviceHandle blockHandle; /* Must be FIRST field. */
    ScsiDevice	*devPtr;	      /* SCSI Device we have open. */
    int	        partition;  /* What partition we want. A partition number
			     * of -1 means the whole disk.
			     */
    int sizeInSectors;	    /* The number of sectors on disk. This number is
			     * MAX_DISK_SIZE if partition == -1. */
    DiskMap map[DEV_NUM_DISK_PARTS];	/* The partition map */
    DevDiskStats *diskStatsPtr;	/* Area for disk stats. */	
    int retries;		/* Number of times current command has been
				 * retried. */
} ScsiDisk;

typedef struct ScsiDiskCmd {
    ScsiDisk	*diskPtr;	/* Target disk of command. */
    ScsiCmd	scsiCmd;	/* SCSI command to send to disk. */
} ScsiDiskCmd;


#define	SCSI_DISK_SECTOR_SIZE	DEV_BYTES_PER_SECTOR

#define	RequestDone(requestPtr,status,byteCount) \
	((requestPtr)->doneProc)((requestPtr),(status),(byteCount))

static ReturnStatus DiskError _ARGS_((ScsiDevice *devPtr,
			    ScsiCmd *scsiCmdPtr));
static Boolean	ScsiDiskIdleCheck _ARGS_((ClientData clientData,
			    DevDiskStats *diskStatsPtr));
static int DiskDoneProc _ARGS_((struct ScsiCmd *scsiCmdPtr, 
			    ReturnStatus status, int statusByte, 
			    int byteCount, int senseLength, 
			    Address senseDataPtr));


/*
 *----------------------------------------------------------------------
 *
 * FillInLabel --
 *
 *	Read the label of the disk and record the partitioning info.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Define the disk partitions that determine which part of the
 *	disk each different disk device uses.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
FillInLabel(devPtr,diskPtr)
    ScsiDevice		 *devPtr; /* SCSI Handle for device. */
    ScsiDisk		 *diskPtr;  /* Disk state stucture to read label. */
{
    register ReturnStatus	status;
    ScsiCmd			labelReadCmd;
    Sun_DiskLabel		*sunLabelPtr;
    Dec_DiskLabel		*decLabelPtr;
    Fsdm_DiskHeader		*diskHdrPtr;
    char			labelBuffer[SCSI_DISK_SECTOR_SIZE];
    int				byteCount;
    int				part;
    Boolean			printLabel = FALSE;

#ifdef DEBUG
    printLabel = TRUE;
#endif

    /*
     * The label of a SCSI disk normally resides in the first sector. Format
     * and send a SCSI READ command to fetch the sector.
     */
    DevScsiGroup0Cmd(devPtr, SCSI_READ, 0, 1,&labelReadCmd);
    labelReadCmd.buffer = labelBuffer;
    labelReadCmd.dataToDevice = FALSE;
    labelReadCmd.bufferLen = SCSI_DISK_SECTOR_SIZE;
    diskPtr->retries = 0;
    status = DevScsiSendCmdSync(devPtr,&labelReadCmd, &byteCount);
    if ((status == SUCCESS) && (byteCount < sizeof(Sun_DiskLabel))) {
	status = DEV_EARLY_CMD_COMPLETION;
    }
    if (status != SUCCESS) {
	return(status);
    }
    sunLabelPtr = (Sun_DiskLabel *) labelBuffer;
    if (sunLabelPtr->magic == SUN_DISK_MAGIC) {
	/*
	 * XXX - Should really check if label is valid.
	 */
	if (printLabel) {
	    printf("%s: %s\n", devPtr->locationName, sunLabelPtr->asciiLabel);
	}

	diskPtr->sizeInSectors = sunLabelPtr->numSectors * 
			    sunLabelPtr->numHeads * sunLabelPtr->numCylinders;
    
	if (printLabel) {
	    printf(" Partitions ");
	}
	for (part = 0; part < DEV_NUM_DISK_PARTS; part++) {
	    diskPtr->map[part].firstSector = sunLabelPtr->map[part].cylinder *
					     sunLabelPtr->numHeads * 
					     sunLabelPtr->numSectors;
	    diskPtr->map[part].sizeInSectors =
					sunLabelPtr->map[part].numBlocks;
	    if (printLabel) {
		printf(" (%d,%d)", diskPtr->map[part].firstSector,
				       diskPtr->map[part].sizeInSectors);
	    }
	}
	if (printLabel) {
	    printf("\n");
	}

	return(SUCCESS);
    }
    /*
     * The disk isn't in SUN format so try Sprite format.
     */
    diskHdrPtr = (Fsdm_DiskHeader *)labelBuffer;
    if (diskHdrPtr->magic == FSDM_DISK_MAGIC) {
	/*
	 * XXX - Should really check if label is valid.
	 */
	if (printLabel) {
	    printf("%s: %s\n", devPtr->locationName, diskHdrPtr->asciiLabel);
	}

	diskPtr->sizeInSectors = diskHdrPtr->numSectors * 
				 diskHdrPtr->numHeads *
			         diskHdrPtr->numCylinders;

	if (printLabel) {
	    printf(" Partitions ");
	}
	for (part = 0; part < DEV_NUM_DISK_PARTS; part++) {
	    diskPtr->map[part].firstSector = 
				diskHdrPtr->map[part].firstCylinder *
				diskHdrPtr->numHeads * diskHdrPtr->numSectors;
	    diskPtr->map[part].sizeInSectors =
				diskHdrPtr->map[part].numCylinders *
				diskHdrPtr->numHeads * diskHdrPtr->numSectors;
	    if (printLabel) {
		printf(" (%d,%d)", diskPtr->map[part].firstSector,
				   diskPtr->map[part].sizeInSectors);
	    }
	}
	if (printLabel) {
	    printf("\n");
	}
	return(SUCCESS);
    }
    /*
     * The disk isn't in SUN or Sprite format so try Dec format.
     * We have to read the right sector first.
     */
    DevScsiGroup0Cmd(devPtr, SCSI_READ, DEC_LABEL_SECTOR, 1,&labelReadCmd);
    labelReadCmd.buffer = labelBuffer;
    labelReadCmd.dataToDevice = FALSE;
    labelReadCmd.bufferLen = SCSI_DISK_SECTOR_SIZE;
    diskPtr->retries = 0;
    status = DevScsiSendCmdSync(devPtr,&labelReadCmd, &byteCount);
    if ((status == SUCCESS) && (byteCount < sizeof(Dec_DiskLabel))) {
	status = DEV_EARLY_CMD_COMPLETION;
    }
    if (status != SUCCESS) {
	return(status);
    }
    decLabelPtr = (Dec_DiskLabel *) labelBuffer;
    if (decLabelPtr->magic == DEC_LABEL_MAGIC) {
	/*
	 * XXX - Should really check if label is valid.
	 */
	if (decLabelPtr->spriteMagic != FSDM_DISK_MAGIC) {
	    printf("Disk needs Sprite-modified Dec label\n");
	}
	if (decLabelPtr->version != DEC_LABEL_VERSION) {
	    printf("Disk label version mismatch: %x vs %x\n",
		    decLabelPtr->version, DEC_LABEL_VERSION);
	}
	if (printLabel) {
	    printf("%s: %s\n", devPtr->locationName, decLabelPtr->asciiLabel);
	}

	diskPtr->sizeInSectors = decLabelPtr->numSectors * 
			    decLabelPtr->numHeads * decLabelPtr->numCylinders;
    
	if (printLabel) {
	    printf(" Partitions ");
	}
	for (part = 0; part < DEV_NUM_DISK_PARTS; part++) {
	    diskPtr->map[part].firstSector =
		    decLabelPtr->map[part].offsetBytes / DEV_BYTES_PER_SECTOR;
	    diskPtr->map[part].sizeInSectors =
		    decLabelPtr->map[part].numBytes / DEV_BYTES_PER_SECTOR;
	    if (printLabel) {
		printf(" (%d,%d)", diskPtr->map[part].firstSector,
				       diskPtr->map[part].sizeInSectors);
	    }
	}
	if (printLabel) {
	    printf("\n");
	}

	return(SUCCESS);
    }
    return(FAILURE);
}

/*
 *----------------------------------------------------------------------
 *
 * ScsiDiskIdleCheck --
 *
 *	Routine for the Disk Stats module to use to determine the idleness
 *	for a disk.
 *
 * Results:
 *	TRUE if the disk pointed to by clientData is idle, FALSE otherwise.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
static Boolean
ScsiDiskIdleCheck(clientData, diskStatsPtr) 
    ClientData		clientData;		/* Unused for SCSI disks. */
    DevDiskStats	*diskStatsPtr;
{
    Boolean		retVal;

    MASTER_LOCK(&(diskStatsPtr->mutex));
    retVal = !(diskStatsPtr->busy);
    MASTER_UNLOCK(&(diskStatsPtr->mutex));

    return retVal;

}

/*
 *----------------------------------------------------------------------
 *
 * InitDisk --
 *
 *	Initialize the device driver state for a SCSI Disk. 
 *
 * Results:
 *	The ScsiDisk structure. NIL - if there is an error attaching the
 *	disk.
 *
 * Side effects:
 *	The disk's label is read and saved in a ScsiDisk structure.  This
 *	is allocated here.
 *
 *----------------------------------------------------------------------
 */
static ScsiDisk *
InitDisk(devPtr,readLabel)
    ScsiDevice	*devPtr; /* SCSI Handle for device. */
    Boolean	readLabel;   /* TRUE if we should read and fill in label 
			      * fields. */
{
    ScsiDisk	disk, *diskPtr;
    ReturnStatus status;
    int		retry = 3;
    bzero((char *) &disk, sizeof(ScsiDisk));
    /*
     * Check that the disk is on-line.  
     * We do this check twice because it appears that dec rz55 
     * drives always indicate that they are ready after powerup,
     * even if their not.
     */
    status = DevScsiTestReady(devPtr);
    status = DevScsiTestReady(devPtr);
    if (status != SUCCESS) {
	if (status != DEV_OFFLINE) {
	    return((ScsiDisk *) NIL);
	}
	/*
	 * Do this loop a few times because Quantum drives appear to respond
	 * to the first start request before they are actually on-line.
	 */
	while (retry > 0) {
	    /*
	     * Try and start the unit.
	     */
	    status = DevScsiStartStopUnit(devPtr, TRUE);
	    if (status != SUCCESS) {
		return((ScsiDisk *) NIL);
	    }
	    /*
	     * Make sure the unit is ready.
	     */
	    status = DevScsiTestReady(devPtr);
	    if (status == SUCCESS) {
		break;
	    }
	    retry--;
	}
    }
    disk.devPtr = devPtr;
    if (readLabel) {
	status = FillInLabel(devPtr,&disk);
	if (status != SUCCESS) {
	    return((ScsiDisk *) NIL);
	}
    } else {
	disk.sizeInSectors = MAX_DISK_SIZE;
    }

    /*
     * Return a malloced copy of the structure we filled in.
     */
    diskPtr = (ScsiDisk *) malloc(sizeof(ScsiDisk));
    *diskPtr = disk;
    return(diskPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * DiskDoneProc --
 *
 *	Call back routine for request to SCSI Disk. 
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Request call may be woken up.
 *
 *----------------------------------------------------------------------
 */
/*ARGSUSED*/
static int
DiskDoneProc(scsiCmdPtr, status, statusByte, byteCount, senseLength, 
	     senseDataPtr)
    ScsiCmd	*scsiCmdPtr;	/* Request that finished. */
    ReturnStatus  status;	/* Error of request. */
    unsigned char statusByte;	/* SCSI status byte of request. */
    int		byteCount;	/* Number of bytes transferred. */
    int		senseLength;	/* Length of sense data returned. */
    Address	senseDataPtr;	/* Sense data. */
{
    DevBlockDeviceRequest *requestPtr;
    ScsiDisk	*diskPtr;

    requestPtr = (DevBlockDeviceRequest *) (scsiCmdPtr->clientData);
    diskPtr = ((ScsiDiskCmd *) (requestPtr->ctrlData))->diskPtr;

    MASTER_LOCK(&(diskPtr->diskStatsPtr->mutex));
    diskPtr->diskStatsPtr->busy--;
    if (requestPtr->operation == FS_READ) {
	diskPtr->diskStatsPtr->diskStats.diskReads += 
				byteCount/DEV_BYTES_PER_SECTOR;
    } else {
	diskPtr->diskStatsPtr->diskStats.diskWrites += 
				byteCount/DEV_BYTES_PER_SECTOR;
    }
    MASTER_UNLOCK(&(diskPtr->diskStatsPtr->mutex));

    /*
     * We need to copy the sense data out of the buffer given to us by
     * the HBA into the buffer in ScsiCmd.  Someday we should get rid
     * of all sense buffers except those in the ScsiCmd.  JHH
     */

     bcopy((char *) senseDataPtr, scsiCmdPtr->senseBuffer, senseLength);
     scsiCmdPtr->senseLen = senseLength;
     scsiCmdPtr->statusByte = statusByte;

    /*
     * If request suffered an HBA error or got no error we notify the
     * caller that the request is done.
     */
    if ((status != SUCCESS) || (statusByte == 0)) {
	RequestDone(requestPtr,status,byteCount);
	return 0;
    }
    /*
     * Otherwise we have a SCSI command that returned an error. 
     */
    status = DiskError(diskPtr->devPtr, scsiCmdPtr);
    /*
     * If the device was reset then retry the command.  This isn't quite
     * correct, but works in the majority of cases because most of the
     * time the scsi bus is reset by the device driver.  In reality the
     * bus could be reset because someone replaced one drive with another.
     * If you really want to handle that situation then you have to pass
     * the status up to the higher level code and let it decide what to do.
     * Of course that means you have to handle it in many different places,
     * whereas this solution only requires modification to this routine.
     * JHH 6/7/91
     *
     * If the command aborted then retry it as well. 
     */
    if ((status == DEV_RESET) || (status == DEV_RETRY_ERROR)) {
	if (diskPtr->retries < 4) {
	    printf("WARNING: device %s, command did not complete. Retrying.\n", 
		diskPtr->devPtr->locationName);
	    scsiCmdPtr->senseLen = sizeof(scsiCmdPtr->senseBuffer);
	    DevScsiSendCmd(diskPtr->devPtr, scsiCmdPtr);
	    diskPtr->retries++;
	} else {
	    printf("WARNING: device %s, too many retries\n", 
		diskPtr->devPtr->locationName);
	    RequestDone(requestPtr,status,byteCount);
	}
    } else {
	RequestDone(requestPtr,status,byteCount);
    }
    return 0;

}

/*
 *----------------------------------------------------------------------
 *
 * SendCmdToDevice --
 *
 *	Translate a Block Device request into and SCSI command and send it
 *	to the disk device.
 *
 * Results:
 *	SUCCESS is the command is sent otherwise a Sprite Error code.
 *
 * Side effects:
 *	Disk may be read or written.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
SendCmdToDevice(diskPtr, requestPtr, firstSector, lengthInSectors)
    ScsiDisk	*diskPtr;
    DevBlockDeviceRequest *requestPtr;
    unsigned int	firstSector;
    unsigned int	lengthInSectors;
{
    int		cmd;
    ScsiDiskCmd	 *diskCmdPtr = (ScsiDiskCmd *) (requestPtr->ctrlData);
    ReturnStatus status;

    if (sizeof(ScsiDiskCmd) > sizeof((requestPtr->ctrlData))) {
	panic("ScsiDISK: command block bigger than controller data\n");
	return FAILURE;
    }
    if (firstSector <= 0x1fffff) {
	cmd = (requestPtr->operation == FS_READ) ? SCSI_READ : SCSI_WRITE;
	status = DevScsiGroup0Cmd(diskPtr->devPtr,cmd, firstSector, 
		    lengthInSectors, &(diskCmdPtr->scsiCmd));
	if (status != SUCCESS) {
	    return FAILURE;
	}
    } else {
	ScsiReadExtCmd	*cmdPtr;
	/*
	 * The offset is too big for the standard 6-byte SCSI read and
	 * write commands.  We have to use the extended version.  Perhaps
	 * we should always use the extended version?
	 */
	if (lengthInSectors > 0xffff) {
	    printf("SendCmdToDevice: too many sectors (%d > %d)\n",
		lengthInSectors, 0xffff);
	    return FAILURE;
	}
	bzero((char *) &(diskCmdPtr->scsiCmd), sizeof(ScsiCmd));
	diskCmdPtr->scsiCmd.commandBlockLen = sizeof(ScsiReadExtCmd);
	cmdPtr = (ScsiReadExtCmd *) (diskCmdPtr->scsiCmd.commandBlock);
	cmdPtr->command = (requestPtr->operation == FS_READ) ? 
	    SCSI_READ_EXT : SCSI_WRITE_EXT;
	cmdPtr->unitNumber = diskPtr->devPtr->LUN;
	cmdPtr->highAddr = ((firstSector >> 24) & 0xff);
	cmdPtr->highMidAddr = ((firstSector >> 16) & 0xff);
	cmdPtr->lowMidAddr = ((firstSector >> 8) & 0xff);
	cmdPtr->lowAddr = ((firstSector) & 0xff);
	cmdPtr->highCount = ((lengthInSectors >> 8) & 0xff);
	cmdPtr->lowCount = ((lengthInSectors) & 0xff);
    }
    diskCmdPtr->scsiCmd.buffer = requestPtr->buffer;
    diskCmdPtr->scsiCmd.bufferLen = lengthInSectors * SCSI_DISK_SECTOR_SIZE;
    diskCmdPtr->scsiCmd.dataToDevice = (requestPtr->operation == FS_WRITE);
    diskCmdPtr->scsiCmd.doneProc = DiskDoneProc;
    diskCmdPtr->scsiCmd.clientData = (ClientData) requestPtr;
    diskCmdPtr->scsiCmd.senseLen = sizeof(diskCmdPtr->scsiCmd.senseBuffer);
    diskCmdPtr->diskPtr = diskPtr;

    MASTER_LOCK(&(diskPtr->diskStatsPtr->mutex));
    diskPtr->diskStatsPtr->busy++;
    MASTER_UNLOCK(&(diskPtr->diskStatsPtr->mutex));

    diskPtr->retries = 0;
    DevScsiSendCmd(diskPtr->devPtr,&(diskCmdPtr->scsiCmd));
    return SUCCESS;
}

/*
 *----------------------------------------------------------------------
 *
 * DiskError --
 *
 *	Map SCSI errors indicated by the sense data into Sprite ReturnStatus
 *	and error message. This proceedure handles two types of 
 *	sense data Class 0 and class 7.
 *
 * Results:
 *	A sprite error code.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
DiskError(devPtr, scsiCmdPtr)
    ScsiDevice	 *devPtr;	/* SCSI device that's complaining. */
    ScsiCmd	*scsiCmdPtr;	/* SCSI command that had the problem. */
{
    unsigned char statusByte = scsiCmdPtr->statusByte;
    ReturnStatus status;
    ScsiStatus *statusPtr = (ScsiStatus *) &statusByte;
    ScsiClass0Sense *sensePtr = (ScsiClass0Sense *) scsiCmdPtr->senseBuffer;
    int	senseLength = scsiCmdPtr->senseLen;
    char	*name = devPtr->locationName;
    char	errorString[MAX_SCSI_ERROR_STRING];

    /*
     * Check for status byte to see if the command returned sense
     * data. If no sense data exists then we only have the status
     * byte to look at.
     */
    if (!statusPtr->check) {
	if (SCSI_RESERVED_STATUS(statusByte) || statusPtr->intStatus) {
	    printf("Warning: SCSI Disk at %s unknown status byte 0x%x\n",
		   name, statusByte);
	    return SUCCESS;
	} 
	if (statusPtr->busy) {
	    return DEV_OFFLINE;
	}
	return SUCCESS;
    }
    if (senseLength == 0) {
	 printf("Warning: SCSI Disk %s error: no sense data\n", name);
	 return DEV_NO_SENSE;
    }
    if (DevScsiMapClass7Sense(senseLength, scsiCmdPtr->senseBuffer,
	    &status, errorString)) {
	if (errorString[0]) {
	     printf("Warning: SCSI Disk %s error: %s\n", name, errorString);
	}
	return status;
    }

    /*
     * If its not a class 7 error it must be Old style sense data..
     */
    if (sensePtr->error == SCSI_NO_SENSE_DATA) {	    
	status = SUCCESS;
    } else {
	int class = (sensePtr->error & 0x70) >> 4;
	int code = sensePtr->error & 0xF;
	int addr;
	addr = ((unsigned int) sensePtr->highAddr << 16) |
		((unsigned int) sensePtr->midAddr << 8) |
		sensePtr->lowAddr;
	printf("Warning: SCSI disk at %s sense error (%d-%d) at <%x> ",
			name, class, code, addr);
	if (devScsiNumErrors[class] > code) {
		printf("%s", devScsiErrors[class][code]);
	 }
	 printf("\n");
	 status = DEV_HARD_ERROR;
    }
    return status;
}
/*
 * This code is for the raid people to test out HBA/disks pairs 
 * by bypassing most of Sprite.
 * Mendel 9/12/89
 */

#include <dev/hbatest.h>
/*ARGSUSED*/
static int
DiskHBATestDoneProc(scsiCmdPtr, status, statusByte, byteCount, senseLength, 
	     senseDataPtr)
    ScsiCmd	*scsiCmdPtr;	/* Request that finished. */
    ReturnStatus  status;	/* Error of request. */
    unsigned char statusByte;	/* SCSI status byte of request. */
    int		byteCount;	/* Number of bytes transferred. */
    int		senseLength;	/* Length of sense data returned. */
    Address	senseDataPtr;	/* Sense data. */
{
    ReturnStatus *errorStatusPtr = (ReturnStatus *) (scsiCmdPtr->clientData);
    ScsiStatus *statusPtr = (ScsiStatus *) &statusByte;
    char	errorString[MAX_SCSI_ERROR_STRING];
    ScsiClass0Sense *sensePtr = (ScsiClass0Sense *) senseDataPtr;
    /*
     * Check for status byte to see if the command returned sense
     * data. If no sense data exists then we only have the status
     * byte to look at.
     */
    if ((status == SUCCESS) && !statusPtr->check) {
	return 0;
    }
    if (senseLength == 0) {
	 printf("Warning: SCSI Disk error: no sense data\n");
	 *errorStatusPtr = DEV_NO_SENSE;
	 return DEV_NO_SENSE;
    }
    if (DevScsiMapClass7Sense(senseLength, senseDataPtr,&status, errorString)) {
	if (errorString[0]) {
	     printf("Warning: SCSI Disk  error: %s\n", errorString);
	}
        *errorStatusPtr = status;
	return status;
    }

    /*
     * If its not a class 7 error it must be Old style sense data..
     */
    if (sensePtr->error == SCSI_NO_SENSE_DATA) {	    
	status = SUCCESS;
    } else {
	int class = (sensePtr->error & 0x70) >> 4;
	int code = sensePtr->error & 0xF;
	int addr;
	addr = ((unsigned int) sensePtr->highAddr << 16) |
		((unsigned int) sensePtr->midAddr << 8) |
		sensePtr->lowAddr;
	printf("Warning: SCSI disk sense error (%d-%d) at <%x> ",
			class, code, addr);
	if (devScsiNumErrors[class] > code) {
		printf("%s", devScsiErrors[class][code]);
	 }
	 printf("\n");
	 status = DEV_HARD_ERROR;
    }
    *errorStatusPtr = status;
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * IOControlProc --
 *
 *      Do a special operation on a raw SCSI Disk.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
static ReturnStatus
IOControlProc(handlePtr, ioctlPtr, replyPtr)
    DevBlockDeviceHandle	*handlePtr; /* Handle pointer of device. */
    Fs_IOCParam *ioctlPtr;	/* Standard I/O Control parameter block */
    Fs_IOReply *replyPtr;	/* Size of outBuffer and returned signal */
{
     ScsiDisk	*diskPtr = (ScsiDisk *) handlePtr;
     ReturnStatus	status = FAILURE;

     if ((ioctlPtr->command & ~0xffff) == IOC_SCSI) {
	 status = DevScsiIOControl(diskPtr->devPtr, ioctlPtr, replyPtr);
	 return status;

     }
     switch (ioctlPtr->command) {
	case	IOC_REPOSITION:
	    /*
	     * Reposition is ok
	     */
	    return(SUCCESS);
	    /*
	     * No disk specific bits are set this way.
	     */
	case	IOC_GET_FLAGS:
	case	IOC_SET_FLAGS:
	case	IOC_SET_BITS:
	case	IOC_CLEAR_BITS:
	    return(SUCCESS);

	case	IOC_GET_OWNER:
	case	IOC_SET_OWNER:
	    return(GEN_NOT_IMPLEMENTED);

	case	IOC_TRUNCATE:
	    return(GEN_INVALID_ARG);

	case	IOC_LOCK:
	case	IOC_UNLOCK:
	    return(GEN_NOT_IMPLEMENTED);

	case	IOC_NUM_READABLE:
	    return(GEN_NOT_IMPLEMENTED);

	case	IOC_MAP:
	    return(GEN_NOT_IMPLEMENTED);

    /*
     * This code is for the raid people to test out HBA/disks pairs 
     * by bypassing most of Sprite.
     * Mendel 9/12/89
     */
	case   IOC_HBA_DISK_IO_TEST: {
	    register int count, i;
	    register DevHBADiskTest  *cmds;
	    ScsiCmd	*scsiCmds;
	    ReturnStatus       errorStatus;
	    static  char *dmaMem, *dmem;
	    char *mem;
	    static int referCount = 0;

	    if ((ioctlPtr->inBufSize % sizeof(DevHBADiskTest)) || 
		!ioctlPtr->inBufSize) {
		return(GEN_INVALID_ARG);
	    }
	    count = ioctlPtr->inBufSize / sizeof(DevHBADiskTest);
	    cmds = (DevHBADiskTest  * ) ioctlPtr->inBuffer;
	    mem = malloc(sizeof(ScsiCmd)*count);
	    if (referCount == 0) { 
		    dmem = malloc(128*1024);
#if defined(sun4) || defined(sun3)
		    dmaMem = VmMach_DMAAlloc(128*1024, dmem);
		    if (dmaMem == (Address) NIL) {
			panic("IOControlProc: unable to allocate dma memory.");
		    }
#else
		    dmaMem = dmem;
#endif
	    } 
	    referCount++;
	    scsiCmds = (ScsiCmd *) (mem);
	    errorStatus = 0;
	    for (i = 0; i < count; i++) {
		DevScsiGroup0Cmd(diskPtr->devPtr, 
			    cmds[i].writeOperation ? SCSI_WRITE : SCSI_READ,
			    cmds[i].firstSector, cmds[i].lengthInSectors,
			    &(scsiCmds[i]));
		scsiCmds[i].buffer = dmaMem;
		scsiCmds[i].bufferLen = cmds[i].lengthInSectors * 
							SCSI_DISK_SECTOR_SIZE;
	        scsiCmds[i].dataToDevice = cmds[i].writeOperation;
		scsiCmds[i].clientData = (ClientData) &errorStatus;
	        scsiCmds[i].doneProc = DiskHBATestDoneProc;
	        scsiCmds[i].senseLen = sizeof(scsiCmds[i].senseBuffer);
		if (i < count - 1) {
		    diskPtr->retries = 0;
		    DevScsiSendCmd(diskPtr->devPtr, &(scsiCmds[i]));
		} else {
		    int	byteCount;
		    diskPtr->retries = 0;
		    status = DevScsiSendCmdSync(diskPtr->devPtr,
			    &(scsiCmds[i]),&byteCount);
		}
	   }
	   referCount--;
	   if (referCount == 0) {
#if defined(sun4) || defined(sun3)
		   VmMach_DMAFree(128*1024, dmaMem);
#endif
		   free(dmem);
	   }
	   free(mem);
	   if (status) {
	       return status;
	    }
	   return errorStatus;

	}
	case   IOC_HBA_DISK_UNIT_TEST: {
	    register int count, i;
	    register ScsiCmd	*scsiCmds;
	    ReturnStatus       errorStatus;

	    if (ioctlPtr->inBufSize != sizeof(int)) {
		return(GEN_INVALID_ARG);
	    }
	    count = *(int *) ioctlPtr->inBuffer;
	    if ((count < 0) || (count > MAX_HBA_UNIT_TESTS)) {
		return(GEN_INVALID_ARG);
	    }
	    scsiCmds = (ScsiCmd *) malloc(sizeof(ScsiCmd)*count);
	    errorStatus = 0;
	    for (i = 0; i < count; i++) {
		DevScsiGroup0Cmd(diskPtr->devPtr, SCSI_TEST_UNIT_READY,
			    0, 0, scsiCmds + i);
		scsiCmds[i].buffer = (char *) NIL;
		scsiCmds[i].bufferLen = 0;
	        scsiCmds[i].dataToDevice = 0;
		scsiCmds[i].clientData = (ClientData) &errorStatus;
	        scsiCmds[i].doneProc = DiskHBATestDoneProc;
	        scsiCmds[i].senseLen = sizeof(scsiCmds[i].senseBuffer);
		if (i < count - 1) {
		    diskPtr->retries = 0;
		    DevScsiSendCmd(diskPtr->devPtr, &(scsiCmds[i]));
		} else {
		    int	byteCount;
		    diskPtr->retries = 0;
		    status = DevScsiSendCmdSync(diskPtr->devPtr,
			    &(scsiCmds[i]), &byteCount);
		}
	   }
	   free((char *) scsiCmds);
	   if (status) {
	       return status;
	    }
	   return errorStatus;

	}
	default:
	    return(GEN_INVALID_ARG);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ReleaseProc --
 *
 *	Block device release proc.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/*ARGUSED*/
static ReturnStatus
ReleaseProc(handlePtr)
    DevBlockDeviceHandle	*handlePtr; /* Handle pointer of device. */
{
    ReturnStatus status;	
    ScsiDisk	*diskPtr = (ScsiDisk *) handlePtr;

    status = DevScsiReleaseDevice(diskPtr->devPtr);
    DevDiskUnregister(diskPtr->diskStatsPtr);
    free((char *) diskPtr);

    return status;
}

/*
 *----------------------------------------------------------------------
 *
 * BlockIOProc --
 *
 *	Convert a Block device IO request in a SCSI command block and 
 *	submit it to the HBA.
 *
 * Results:
 *	The return code from the I/O operation.
 *
 * Side effects:
 *	The disk write, if operation == FS_WRITE.
 *
 *----------------------------------------------------------------------
 */

static ReturnStatus
BlockIOProc(handlePtr, requestPtr) 
    DevBlockDeviceHandle	*handlePtr; /* Handle pointer of device. */
    DevBlockDeviceRequest *requestPtr; /* IO Request to be performed. */
{
    ReturnStatus status;	
    ScsiDisk	*diskPtr = (ScsiDisk *) handlePtr;
    unsigned int	firstSector, lengthInSectors, sizeInSectors;


    if (!((requestPtr->operation == FS_READ) ||
          (requestPtr->operation == FS_WRITE))) {
	panic("Unknown operation %d in ScsiDisk blockIOProc.\n", 
		requestPtr->operation);
	return DEV_INVALID_ARG;
    }
    /*
     * Insure that the request is within the bounds of the partition.
     */
    firstSector = requestPtr->startAddress/DEV_BYTES_PER_SECTOR;
    lengthInSectors = requestPtr->bufferLen/DEV_BYTES_PER_SECTOR;
    sizeInSectors = (diskPtr->partition == WHOLE_DISK_PARTITION) ?
				diskPtr->sizeInSectors   :
		            diskPtr->map[diskPtr->partition].sizeInSectors;
    if (firstSector >= sizeInSectors) {
	/*
	 * The offset is past the end of the partition.
	 */
	RequestDone(requestPtr,SUCCESS,0);
	return SUCCESS;
    } 
    if (((firstSector + lengthInSectors - 1) >= sizeInSectors)) {
	/*
	 * The transfer is at the end of the partition.  Reduce the
	 * sector count so there is no overrun.
	 */
	lengthInSectors = sizeInSectors - firstSector;
    } 
    if (diskPtr->partition != WHOLE_DISK_PARTITION) {
	/*
	 * Relocate the disk address to be relative to this partition.
	 */
	firstSector += diskPtr->map[diskPtr->partition].firstSector;
    }

    status = SendCmdToDevice(diskPtr, requestPtr, firstSector, lengthInSectors);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * DevScsiDiskAttach --
 *
 *	Attach a SCSI Disk device to the system.
 *
 * Results:
 *	The DevBlockDeviceHandle of the device.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

DevBlockDeviceHandle *
DevScsiDiskAttach(devicePtr)
    Fs_Device	*devicePtr;	/* The device to attach. */
{
    ScsiDevice	*devPtr;
    ScsiDisk	*diskPtr;

    /*
     * Ask the HBA to set up the path to the device. For the time being
     * we will not sort the disk requests.
     */
    devPtr = DevScsiAttachDevice(devicePtr, DEV_QUEUE_FIFO_INSERT);
    if (devPtr == (ScsiDevice *) NIL) {
	return (DevBlockDeviceHandle *) NIL;
    }
    /*
     * Determine the type of device from the inquiry return by the
     * attach. Reject device if not of disk type. If the target 
     * didn't respond to the INQUIRY command we assume that it
     * just a stupid disk.
     */
    if ((devPtr->inquiryLength > 0) &&
	(((ScsiInquiryData *) (devPtr->inquiryDataPtr))->type != 
							SCSI_DISK_TYPE)) {
	(void) DevScsiReleaseDevice(devPtr);
	return (DevBlockDeviceHandle *) NIL;
    }
    devPtr->errorProc = DiskError;
    /*
     * Initialize the ScsiDisk structure. We don't need to read the label
     * if the user is opening the device in raw (non partitioned) mode.
     */
    diskPtr = InitDisk(devPtr,DISK_IS_PARTITIONED(devicePtr));
    if (diskPtr == (ScsiDisk *) NIL) {
	return (DevBlockDeviceHandle *) NIL;
    }
    /*
     * Register this disk with the Disk stat routines.
     */
    {
	Fs_Device rawDevice;

	rawDevice = *devicePtr;
	rawDevice.unit = rawDevice.unit & ~0xf;
	diskPtr->diskStatsPtr = DevRegisterDisk(&rawDevice,
					      devPtr->locationName,
					      ScsiDiskIdleCheck, 
					      (ClientData) diskPtr);
    }
    diskPtr->partition = DISK_IS_PARTITIONED(devicePtr) ? 
					DISK_PARTITION(devicePtr) :
					WHOLE_DISK_PARTITION;
    diskPtr->blockHandle.blockIOProc = BlockIOProc;
    diskPtr->blockHandle.releaseProc = ReleaseProc;
    diskPtr->blockHandle.IOControlProc = IOControlProc;
    diskPtr->blockHandle.minTransferUnit = SCSI_DISK_SECTOR_SIZE;
    diskPtr->blockHandle.maxTransferSize = devPtr->maxTransferSize;
    return (DevBlockDeviceHandle *) diskPtr;
}


@


9.21
log
@New mips cc requires casting of char's that are shifted more than 8.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/Cvsroot/kernel/dev/devSCSIDisk.c,v 9.20 91/10/23 11:42:05 mendel Exp $ SPRITE (Berkeley)";
a447 2
     * Also note that it is possible to go into an infinite loop if the
     * device always returns unit attention.
d449 2
d452 3
a454 3
    if (status == DEV_RESET) {
	if ((diskPtr->retries > 0) && (diskPtr->retries % 10 == 0)) {
	    printf("WARNING: device %s always returns unit attention?\n",
d456 7
a462 1
	    diskPtr->retries = 0;
a463 3
	scsiCmdPtr->senseLen = sizeof(scsiCmdPtr->senseBuffer);
	DevScsiSendCmd(diskPtr->devPtr, scsiCmdPtr);
	diskPtr->retries++;
a951 2
	printf("ScsiDisk request: firstSector(%d) >= size (%d)\n",
						 firstSector, sizeInSectors);
@


9.20
log
@Don't trust label info on disk opened for not partitioned mode.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.19 91/10/08 14:06:07 mendel Exp $ SPRITE (Berkeley)";
d615 2
a616 2
	addr = (sensePtr->highAddr << 16) |
		(sensePtr->midAddr << 8) |
d680 2
a681 2
	addr = (sensePtr->highAddr << 16) |
		(sensePtr->midAddr << 8) |
@


9.19
log
@Patched bound checking on partitions to work for zero length partitions.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.18 91/09/17 14:50:48 jhh Exp Locker: mendel $ SPRITE (Berkeley)";
d45 4
d58 2
a59 1
    int sizeInSectors;	    /* The number of sectors on disk */
a60 1
    int type;		/* Type of the drive, needed for error checking */
d362 3
a364 1
    } 
@


9.18
log
@scsi errors weren't handled properly for disks.  The sense data and
status byte must be copied into the ScsiCmd structure.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.17 91/08/19 13:42:57 jhh Exp $ SPRITE (Berkeley)";
d922 1
a922 1
    unsigned int	firstSector, lengthInSectors, lastSector;
d936 4
a939 5
    lastSector = (diskPtr->partition == WHOLE_DISK_PARTITION) ?
				(diskPtr->sizeInSectors - 1)  :
			diskPtr->map[diskPtr->partition].firstSector +
		            diskPtr->map[diskPtr->partition].sizeInSectors - 1;
    if (firstSector > lastSector) {
d943 2
a944 2
	printf("BlockIOProc: firstSector(%d) > lastSector (%d)\n",
						    firstSector, lastSector);
d948 1
a948 1
    if (((firstSector + lengthInSectors - 1) > lastSector)) {
d953 1
a953 1
	lengthInSectors = lastSector - firstSector + 1;
@


9.17
log
@retries commands that abort due to a reset, new format for
DevScsiSendCmdSync
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev.jhh/RCS/devSCSIDisk.c,v 9.15 91/05/29 15:04:28 mendel Exp Locker: jhh $ SPRITE (Berkeley)";
d410 10
@


9.16
log
@Removed extra & symbol that was causing the MIPS compiler to complain.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.15 91/05/29 15:04:28 mendel Exp $ SPRITE (Berkeley)";
d23 15
a37 15
#include "sprite.h"
#include "stdio.h"
#include "fs.h"
#include "dev.h"
#include "devInt.h"
#include "scsi.h"
#include "scsiDevice.h"
#include "devDiskLabel.h"
#include "devDiskStats.h"
#include "devBlockDevice.h"
#include "stdlib.h"
#include "bstring.h"
#include "dev/scsi.h"
#include "dbg.h"
#include "fsdm.h"
d58 2
d73 8
a80 2
static ReturnStatus DiskError();
static Boolean	ScsiDiskIdleCheck();
a109 3
    unsigned char		statusByte;
    int				senseLength;
    char			senseBuffer[SCSI_MAX_SENSE_LEN];
d126 2
a127 6
    senseLength = SCSI_MAX_SENSE_LEN;
    status = DevScsiSendCmdSync(devPtr,&labelReadCmd,&statusByte,&byteCount,
				&senseLength, senseBuffer);
    if (status == SUCCESS) {
	status = DiskError(diskPtr,statusByte, senseLength, senseBuffer);
    }
d210 2
a211 6
    senseLength = SCSI_MAX_SENSE_LEN;
    status = DevScsiSendCmdSync(devPtr,&labelReadCmd,&statusByte,&byteCount,
				&senseLength, senseBuffer);
    if (status == SUCCESS) {
	status = DiskError(diskPtr,statusByte, senseLength, senseBuffer);
    }
d383 1
a383 1

d422 26
a447 2
    status = DiskError(diskPtr, statusByte, senseLength, senseDataPtr);
    RequestDone(requestPtr,status,byteCount);
d520 1
d527 1
d550 3
a552 5
DiskError(diskPtr, statusByte, senseLength, senseDataPtr)
    ScsiDisk	 *diskPtr;	/* SCSI disk that's complaining. */
    unsigned char statusByte;	/* The status byte of the command. */
    int		 senseLength;	/* Length of SCSI sense data in bytes. */
    char	 *senseDataPtr;	/* Sense data. */
d554 1
d557 3
a559 2
    ScsiClass0Sense *sensePtr = (ScsiClass0Sense *) senseDataPtr;
    char	*name = diskPtr->devPtr->locationName;
d582 2
a583 1
    if (DevScsiMapClass7Sense(senseLength, senseDataPtr,&status, errorString)) {
d788 1
d790 1
a792 1
		    unsigned char statusByte;
d794 1
d796 1
a796 2
			    &(scsiCmds[i]),&statusByte,&byteCount,
				 (int *) NIL, (char *) NIL);
d835 1
d837 1
a839 1
		    unsigned char statusByte;
d841 1
d843 1
a843 2
			    &(scsiCmds[i]),&statusByte,&byteCount,
				 (int *) NIL, (char *) NIL);
d1000 1
@


9.15
log
@Converted Sys_DiskStats to be sector rather than request count.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.14 91/04/12 17:54:20 jhh Exp $ SPRITE (Berkeley)";
d483 1
a483 1
	cmdPtr = (ScsiReadExtCmd *) &(diskCmdPtr->scsiCmd.commandBlock);
@


9.14
log
@use extended read/write commands for big devices
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.13 91/03/30 17:01:29 jhh Exp $ SPRITE (Berkeley)";
d406 2
a407 1
	diskPtr->diskStatsPtr->diskStats.diskReads++;
d409 2
a410 1
	diskPtr->diskStatsPtr->diskStats.diskWrites++;
@


9.13
log
@Mary checking this in for John H.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.12 90/09/11 13:54:32 rab Exp $ SPRITE (Berkeley)";
d454 1
d460 32
a491 3
    cmd = (requestPtr->operation == FS_READ) ? SCSI_READ : SCSI_WRITE;
    DevScsiGroup0Cmd(diskPtr->devPtr,cmd, firstSector, lengthInSectors,
		      &(diskCmdPtr->scsiCmd));
d494 1
a494 1
    diskCmdPtr->scsiCmd.dataToDevice = (cmd == SCSI_WRITE);
@


9.12
log
@ #include "stdio.h" for forward decl of printf.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.11 90/09/11 12:25:11 rab Exp Locker: rab $ SPRITE (Berkeley)";
d556 5
a560 6
#if defined(sun4) || defined(sun3)
    /*
     * This code is for the raid people to test out HBA/disks pairs 
     * by bypassing most of Sprite.
     * Mendel 9/12/89
     */
a621 1
#endif
a685 1
#if defined(sun4) || defined(sun3)
d709 1
d714 3
d744 1
d746 1
a794 1
#endif
@


9.11
log
@Fixed uninitialized variable.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.10 90/05/14 14:20:27 mgbaker Exp Locker: rab $ SPRITE (Berkeley)";
d24 1
@


9.10
log
@Fixed io stats testing to avoid accessing freed space.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.9 90/04/30 19:58:05 mgbaker Exp Locker: mgbaker $ SPRITE (Berkeley)";
d33 1
d648 1
a648 1
     ReturnStatus	status;
@


9.9
log
@Added SCSI disk usage gathering.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.8 90/02/16 17:07:44 shirriff Exp Locker: mgbaker $ SPRITE (Berkeley)";
d55 1
a55 2
    Sys_DiskStats *diskStatsPtr;	/* Area for disk stats. */	
    int	busy;		/* Whether disk is busy or not. */
d143 3
a145 1
	if (printLabel) printf(" Partitions ");
d157 3
a159 1
	if (printLabel)	printf("\n");
d179 3
a181 1
	if (printLabel) printf(" Partitions ");
d194 3
a196 1
	if (printLabel) printf("\n");
d238 3
a240 1
	if (printLabel) printf(" Partitions ");
d251 3
a253 1
	if (printLabel)	printf("\n");
d276 1
a276 1

d278 3
a280 2
ScsiDiskIdleCheck(clientData) 
    ClientData	clientData;
d282 8
a289 3
    ScsiDisk *diskPtr = (ScsiDisk *) clientData;

    return !(diskPtr->busy);
d400 3
a402 1
    diskPtr->busy--;
d404 1
a404 1
	diskPtr->diskStatsPtr->diskReads++;
d406 1
a406 1
	diskPtr->diskStatsPtr->diskWrites++;
d408 2
d466 5
a470 1
    diskPtr->busy++;
d562 1
a562 1

d820 1
@


9.8
log
@Removed debugging statements.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.7 90/02/14 12:46:54 jhh Exp Locker: shirriff $ SPRITE (Berkeley)";
d56 1
d270 3
a272 6
    ScsiDevice *devPtr = (ScsiDevice *) clientData;
#ifdef lint
    devPtr = devPtr;
#endif /* lint */
	/* need to fix this. */
    return TRUE;
d383 1
d445 1
d931 1
a931 1
					      (ClientData) devPtr);
@


9.7
log
@took out debugging printfs
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.6 90/02/13 23:19:51 shirriff Exp $ SPRITE (Berkeley)";
a109 2
    printLabel = TRUE;
    printf("Getting a label\n");
a128 1
	printf("Disk: error: %x\n",status);
a208 1
	printf("Disk: error: %x\n",status);
@


9.6
log
@Has changes for dec disk.
Has jhh's changes to make sure disk is started.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.5 89/12/11 17:41:44 brent Exp Locker: shirriff $ SPRITE (Berkeley)";
a324 1
	    printf("Device is not ready.\n");
a329 1
		printf("Attempt to start unit failed.\n");
a334 1
	    printf("Attempt to start unit succeeded.\n");
a341 1
    printf("Device is ready\n");
@


9.5
log
@Nuked print statement made when opening a raw disk.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.4 89/10/26 11:29:47 mgbaker Exp $ SPRITE (Berkeley)";
d96 2
a97 1
    Sun_DiskLabel		*diskLabelPtr;
d110 2
d114 1
a114 1
     * The label of a SCSI command resides in the first sector. Format
d131 1
d134 2
a135 2
    diskLabelPtr = (Sun_DiskLabel *) labelBuffer;
    if (diskLabelPtr->magic == SUN_DISK_MAGIC) {
d140 1
a140 1
	    printf("%s: %s\n", devPtr->locationName, diskLabelPtr->asciiLabel);
d143 2
a144 2
	diskPtr->sizeInSectors = diskLabelPtr->numSectors * 
			    diskLabelPtr->numHeads * diskLabelPtr->numCylinders;
d148 3
a150 3
	    diskPtr->map[part].firstSector = diskLabelPtr->map[part].cylinder *
					     diskLabelPtr->numHeads * 
					     diskLabelPtr->numSectors;
d152 1
a152 1
					diskLabelPtr->map[part].numBlocks;
d194 55
d306 1
d309 4
a312 2
     * Check that the disk is on-line.  This means we won't find a disk
     * if its powered down.
d315 1
d317 27
a343 1
	return((ScsiDisk *) NIL);
d345 1
@


9.4
log
@fixing lint
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.3 89/10/12 11:09:58 mendel Exp Locker: mgbaker $ SPRITE (Berkeley)";
d104 1
d106 4
d135 4
a138 2
	printf("%s: %s\n", devPtr->locationName, diskLabelPtr->asciiLabel);
    
d142 1
a142 1
	printf(" Partitions ");
d149 2
a150 1
	    printf(" (%d,%d)", diskPtr->map[part].firstSector,
d152 1
d154 2
a155 1
	printf("\n");
d166 3
a168 1
	printf("%s: %s\n", devPtr->locationName, diskHdrPtr->asciiLabel);
d174 1
a174 1
	printf(" Partitions ");
d182 2
a183 1
	    printf(" (%d,%d)", diskPtr->map[part].firstSector,
d185 1
d187 1
a187 1
	printf("\n");
@


9.3
log
@Hacked hack to allow all devices doing an iotest to use the same DMA
buffer.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.2 89/09/28 16:53:41 mgbaker Exp $ SPRITE (Berkeley)";
d201 3
a572 1
	    int	     max = 0;
d624 1
a624 1
	   if (status)
d626 1
d663 1
a663 1
	   if (status)
d665 1
@


9.2
log
@Added panic if DMAAllocate fails.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.1 89/09/18 13:59:33 brent Exp Locker: mgbaker $ SPRITE (Berkeley)";
a572 1
	    Address    mem, dmaMem;
d574 3
d584 10
a593 14
	    for (i = 0; i < count; i++) {
		if (max < cmds[i].lengthInSectors) {
		    max = cmds[i].lengthInSectors;
	        }
	    }
	    if (max == 0) {
		return(GEN_INVALID_ARG);
	    }
	    mem = malloc(DEV_BYTES_PER_SECTOR * max + sizeof(ScsiCmd)*count);
	    scsiCmds = (ScsiCmd *) (mem + DEV_BYTES_PER_SECTOR * max);
	    dmaMem = VmMach_DMAAlloc(DEV_BYTES_PER_SECTOR * max, mem);
	    if (dmaMem == (Address) NIL) {
		panic("IOControlProc: unable to allocate dma memory.");
	    }
d616 5
a620 1
	   VmMach_DMAFree(DEV_BYTES_PER_SECTOR * max, dmaMem);
@


9.1
log
@Updated to new FS typedefs and constants
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 9.0 89/09/12 14:57:33 douglis Stable Locker: brent $ SPRITE (Berkeley)";
d593 3
@


9.0
log
@Changing version numbers.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 8.10 89/09/12 14:09:04 mendel Exp Locker: douglis $ SPRITE (Berkeley)";
d35 1
a35 1
#include "fsDisk.h"
d97 1
a97 1
    FsDiskHeader		*diskHdrPtr;
d151 2
a152 2
    diskHdrPtr = (FsDiskHeader *)labelBuffer;
    if (diskHdrPtr->magic == FS_DISK_MAGIC) {
@


8.10
log
@Added stuff for raid people.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 8.9 89/08/01 18:46:34 nelson Exp $ SPRITE (Berkeley)";
@


8.9
log
@Added check for sprite labels.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 8.8 89/06/16 12:08:09 brent Exp $ SPRITE (Berkeley)";
d430 68
d561 100
a660 1
	    
@


8.8
log
@Updated I/O Control interface
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 8.7 89/06/15 08:46:36 brent Exp Locker: brent $ SPRITE (Berkeley)";
d35 1
d94 10
a103 9
    register ReturnStatus status;
    ScsiCmd     labelReadCmd;
    Sun_DiskLabel *diskLabelPtr;
    char	labelBuffer[SCSI_DISK_SECTOR_SIZE];
    unsigned char statusByte;
    int		senseLength;
    char	senseBuffer[SCSI_MAX_SENSE_LEN];
    int	byteCount;
    int part;
d126 22
d149 1
a149 1
     * XXX - Should really check if label is valid.
d151 6
a156 1
    printf("%s: %s\n", devPtr->locationName, diskLabelPtr->asciiLabel);
d158 13
a170 10
    diskPtr->sizeInSectors = diskLabelPtr->numSectors * diskLabelPtr->numHeads *
			  diskLabelPtr->numCylinders;

    printf(" Partitions ");
    for (part = 0; part < DEV_NUM_DISK_PARTS; part++) {
	diskPtr->map[part].firstSector = diskLabelPtr->map[part].cylinder *
					 diskLabelPtr->numHeads * 
					 diskLabelPtr->numSectors;
	diskPtr->map[part].sizeInSectors = diskLabelPtr->map[part].numBlocks;
	printf(" (%d,%d)", diskPtr->map[part].firstSector,
d172 3
d176 1
a176 2
    printf("\n");
    return(SUCCESS);
d574 2
@


8.7
log
@Updated to new DEV / FS interface
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/RCS/devSCSIDisk.c,v 8.6 89/05/23 09:59:42 mendel Exp Locker: brent $ SPRITE (Berkeley)";
d415 1
a415 2
IOControlProc(handlePtr, command, byteOrder, inBufSize, inBuffer,
                                 outBufSize, outBuffer)
d417 2
a418 6
    int command;
    int byteOrder;
    int inBufSize;
    char *inBuffer;
    int outBufSize;
    char *outBuffer;
d423 2
a424 3
     if ((command&~0xffff) == IOC_SCSI) {
	 status = DevScsiIOControl(diskPtr->devPtr, command, byteOrder,
			 inBufSize, inBuffer, outBufSize, outBuffer);
d428 1
a428 1
     switch (command) {
@


8.6
log
@Added disk stats collection routines.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev.new/RCS/devSCSIDisk.c,v 8.5 89/05/01 16:05:42 mendel Exp Locker: mendel $ SPRITE (Berkeley)";
d415 1
a415 1
IOControlProc(handlePtr, command, inBufSize, inBuffer,
d419 1
d429 2
a430 2
	 status = DevScsiIOControl(diskPtr->devPtr, command, inBufSize,
				inBuffer, outBufSize, outBuffer);
@


8.5
log
@Convert to support new block IO interface and new async HBA interface.
@
text
@d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/sun3.md/RCS/devScsiDisk.c,v 8.4 89/02/19 22:02:06 jhh Exp $ SPRITE (Berkeley)";
d30 1
d54 1
d69 1
d144 17
d162 8
d212 1
d252 5
d290 1
a290 1
ReturnStatus
a561 5
    if (lengthInSectors * DEV_BYTES_PER_SECTOR > DEV_MAX_TRANSFER_SIZE) {
	panic("Request size too large (%d Bytes) in ScsiDisk blockIO\n",
	       lengthInSectors * DEV_BYTES_PER_SECTOR);
	return DEV_INVALID_ARG;
    }
d616 13
@


8.4
log
@Changes due to lock registration
@
text
@d2 1
a2 1
 * devSCSIDisk.c --
d4 2
a5 3
 *      The standard Open, Read, Write, IOControl, and Close operations
 *      are defined here for the SCSI disk.  This ``raw'' access to the
 *      disk is used during formatting and disk recovery.
d19 1
a19 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/sun3.md/RCS/devSCSIDisk.c,v 8.3 88/11/28 08:21:33 brent Exp $ SPRITE (Berkeley)";
d27 2
a28 2
#include "devSCSI.h"
#include "devSCSIDisk.h"
d30 1
d32 2
d35 4
a38 2
#include "dbg.h"
static int SCSIdebug = FALSE;
d40 29
a68 71
/*
 * State for each SCSI disk.  The state for all SCSI disks are kept
 * together so that the driver can easily find the disk and partition
 * that correspond to a filesystem unit number.
 */

DevSCSIDevice *scsiDisk[SCSI_MAX_DISKS];
int scsiDiskIndex = -1;


/*
 *----------------------------------------------------------------------
 *
 * DevSCSIDiskInit --
 *
 *	Initialize the device driver state for a SCSI Disk.
 *	In order for filesystem unit numbers to correctly match up
 *	with different disks we depend on Dev_SCSIInitDevice to
 *	increment the scsiDiskIndex properly.
 *
 * Results:
 *	SUCCESS if the disk is on-line.
 *
 * Side effects:
 *	The disk's label is read and saved in a DevSCSIDisk structure.  This
 *	is allocated here and referneced by the private data pointer in
 *	the generic DevSCSIDevice structure.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
DevSCSIDiskInit(devPtr)
    DevSCSIDevice *devPtr;		/* Device state to complete */
{
    register DevSCSIDisk *diskPtr;
    ReturnStatus status;
    /*
     * Check that the disk is on-line.  This means we won't find a disk
     * if its powered down upon boot.
     */
    devPtr->type = SCSI_DISK;
    devPtr->errorProc = DevSCSIDiskError;
    devPtr->sectorSize = DEV_BYTES_PER_SECTOR;
    diskPtr = (DevSCSIDisk *) malloc(sizeof(DevSCSIDisk));
    devPtr->data = (ClientData)diskPtr;
    diskPtr->type = SCSI_GENERIC_DISK;
    status = DevSCSITest(devPtr);
    if (status != SUCCESS) {
	free((char *)diskPtr);
	return(status);
    }
    /*
     * Set up a slot in the disk list. The slot number has to correspond
     * to a file system device unit number, so we depend on Dev_SCSIInitDevice
     * to increment scsiDiskIndex each time it is called, and on the
     * layout of the DevConfig device table.  (This should be improved).
     */
    if (scsiDiskIndex >= SCSI_MAX_DISKS) {
	printf("SCSIDiskInit: Too many disks configured\n");
	free((char *)diskPtr);
	return(FAILURE);
    }
    status = DevSCSIDoLabel(devPtr);
    if (status != SUCCESS) {
	free((char *)diskPtr);
	return(status);
    }
    scsiDisk[scsiDiskIndex] = devPtr;
    return(SUCCESS);
}

d72 1
a72 1
 * DevSCSIDoLabel --
d85 4
a88 3
ReturnStatus
DevSCSIDoLabel(devPtr)
    DevSCSIDevice *devPtr;
a89 2
    register DevSCSIController *scsiPtr = devPtr->scsiPtr;
    DevSCSIDisk *diskPtr;
d91 1
d93 5
d101 2
a102 3
     * Synchronize with the interrupt handling routine and with other
     * processes that are trying to initiate I/O with this controller.
     * FIX HERE TO ENQUEUE REQUESTS - GOES WITH CONNECT/DIS-CONNECT
d104 13
a116 16
    scsiPtr = devPtr->scsiPtr;
    MASTER_LOCK(&scsiPtr->mutex);
    while (scsiPtr->flags & SCSI_CNTRLR_BUSY) {
	Sync_MasterWait(&scsiPtr->readyForIO, &scsiPtr->mutex, FALSE);
    }
    scsiPtr->flags |= SCSI_CNTRLR_BUSY;

	DevSCSISetupCommand(SCSI_READ, devPtr, 0, 1);
    
	status = (*scsiPtr->commandProc)(devPtr->targetID, scsiPtr,
			DEV_BYTES_PER_SECTOR, scsiPtr->labelBuffer, WAIT);

    scsiPtr->flags &= ~SCSI_CNTRLR_BUSY;
    Sync_MasterBroadcast(&scsiPtr->readyForIO);
    MASTER_UNLOCK(&scsiPtr->mutex);

a117 2
	printf("SCSI-%d: couldn't read the disk%d-%d label\n",
			     scsiPtr->number, devPtr->targetID, devPtr->LUN);
d120 5
a124 3
    diskLabelPtr = (Sun_DiskLabel *)scsiPtr->labelBuffer;
    printf("SCSI-%d disk%d-%d: %s\n", scsiPtr->number, devPtr->targetID,
			devPtr->LUN, diskLabelPtr->asciiLabel);
d126 2
a127 4
    diskPtr = (DevSCSIDisk *)devPtr->data;
    diskPtr->numCylinders = diskLabelPtr->numCylinders;
    diskPtr->numHeads = diskLabelPtr->numHeads;
    diskPtr->numSectors = diskLabelPtr->numSectors;
d131 6
a136 7
	diskPtr->map[part].firstCylinder =
		diskLabelPtr->map[part].cylinder;
	diskPtr->map[part].numCylinders =
		diskLabelPtr->map[part].numBlocks /
		(diskLabelPtr->numHeads * diskLabelPtr->numSectors) ;
	printf(" (%d,%d)", diskPtr->map[part].firstCylinder,
				   diskPtr->map[part].numCylinders);
d141 1
d146 1
a146 1
 * DevSCSIDiskIO --
d148 1
a148 13
 *      Read or Write (to/from) a raw SCSI disk file. The deviceUnit
 *      number is mapped to a particular partition on a particular disk.
 *      The starting coordinate, firstSector,  is relocated to be relative
 *      to the corresponding disk partition.  The transfer is checked
 *      against the partition size to make sure that the I/O doesn't cross
 *      a disk partition.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The number of sectors to transfer gets trimmed down if it would
 *	cross into the next partition.
d150 15
a164 14
 *----------------------------------------------------------------------
 */
ReturnStatus
DevSCSIDiskIO(command, deviceUnit, buffer, firstSector, numSectorsPtr)
    int command;			/* SCSI_READ or SCSI_WRITE */
    int deviceUnit;			/* Unit from the filesystem that
					 * indicates a disk and partition */
    char *buffer;			/* Target buffer */
    int firstSector;			/* First sector to transfer. Should be
					 * relative to the start of the disk
					 * partition corresponding to the unit*/
    int *numSectorsPtr;			/* Upon entry, the number of sectors to
					 * transfer.  Upon return, the number
					 * of sectors actually transferred. */
d166 1
d168 4
a171 18
    int disk;		/* Disk number of disk that has the partition that
			 * corresponds to the unit number */
    int part;		/* Partition of disk that corresponds to unit number */
    DevSCSIDevice *devPtr;		/* Generic SCSI device state */
    register DevSCSIDisk *diskPtr;	/* State of the disk */
    int totalSectors;		/* The total number of sectors to transfer */
    int numSectors;		/* The number of sectors to transfer at
				 * one time, up to a blocks worth. */
    int lastSector;	/* Last sector of the partition */
    int totalRead;	/* The total number of sectors actually transferred */

    disk = deviceUnit / DEV_NUM_DISK_PARTS;
    part = deviceUnit % DEV_NUM_DISK_PARTS;
    devPtr = scsiDisk[disk];
    diskPtr = (DevSCSIDisk *)devPtr->data;

    /*
     * Do bounds checking to keep the I/O within the partition.
d173 3
a175 16
    lastSector = diskPtr->map[part].numCylinders *
		 (diskPtr->numHeads * diskPtr->numSectors) - 1;
    totalSectors = *numSectorsPtr;

    if (firstSector > lastSector) {
	/*
	 * The offset is past the end of the partition.
	 */
	*numSectorsPtr = 0;
	return(SUCCESS);
    } else if ((firstSector + totalSectors - 1) > lastSector) {
	/*
	 * The transfer is at the end of the partition.  Reduce the
	 * sector count so there is no overrun.
	 */
	totalSectors = lastSector - firstSector + 1;
d177 7
d185 121
a305 55
     * Relocate the disk address to be relative to this partition.
     */
    firstSector += diskPtr->map[part].firstCylinder *
		    (diskPtr->numHeads * diskPtr->numSectors);
    /*
     * Chop up the IO into blocksize pieces.
     */
    totalRead = 0;
    do {
	if (totalSectors > SECTORS_PER_BLOCK) {
	    numSectors = SECTORS_PER_BLOCK;
	} else {
	    numSectors = totalSectors;
	}
	status = DevSCSISectorIO(command, devPtr, firstSector, &numSectors, buffer);
	if (status == SUCCESS) {
	    firstSector += numSectors;
	    totalSectors -= numSectors;
	    buffer += numSectors * DEV_BYTES_PER_SECTOR;
	    totalRead += numSectors;
	}
    } while (status == SUCCESS && totalSectors > 0);
    *numSectorsPtr = totalRead;
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * DevSCSISectorIO --
 *
 *      Lower level routine to read or write an SCSI device.  The
 *      interface here is in terms of a particular SCSI disk and the
 *      number of sectors to transfer.  This routine takes care of mapping
 *      its buffer into the special multibus memory area that is set up
 *      for Sun DMA.  It retries in the event of errors.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
DevSCSISectorIO(command, devPtr, firstSector, numSectorsPtr, buffer)
    int command;			/* SCSI_READ or SCSI_WRITE */
    DevSCSIDevice *devPtr;		/* Which disk to do I/O with */
    int firstSector;			/* The sector at which the transfer
					 * begins. */
    int *numSectorsPtr;			/* Upon entry, the number of sectors to
					 * transfer.  Upon return, the number
					 * of sectors transferred. */
    char *buffer;			/* Target buffer */
d308 4
a311 2
    register DevSCSIController *scsiPtr; /* Controller for the disk */
    int i;
d314 28
a341 3
     * Synchronize with the interrupt handling routine and with other
     * processes that are trying to initiate I/O with this controller.
     * FIX HERE TO ENQUEUE REQUESTS - GOES WITH CONNECT/DIS-CONNECT
d343 2
a344 4
    scsiPtr = devPtr->scsiPtr;
    MASTER_LOCK(&scsiPtr->mutex);
    if (command == SCSI_READ) {
	scsiPtr->configPtr->diskReads++;
d346 29
a374 71
	scsiPtr->configPtr->diskWrites++;
    }
    /*
     * Here we are using a condition variable and the scheduler to
     * synchronize access to the controller.  An alternative would be
     * to have a command queue associated with the controller.  We can't
     * rely on the mutex variable because that is relinquished later
     * when the process using the controller waits for the I/O to complete.
     */
    while (scsiPtr->flags & SCSI_CNTRLR_BUSY) {
	Sync_MasterWait(&scsiPtr->readyForIO, &scsiPtr->mutex, FALSE);
    }
    scsiPtr->flags |= SCSI_CNTRLR_BUSY;

    /*
     * Map the buffer into the special area of multibus memory that
     * the device can DMA into.
     */
    buffer = VmMach_DevBufferMap(*numSectorsPtr * devPtr->sectorSize,
			     buffer, scsiPtr->IOBuffer);
    /*
     * Retry the operation if we hit a hard error. This is because
     * many hard errors seem to work when retried.  Retry recovered
     * errors too, though that may not be necessary.  (Alternatively,
     * convert the error status to success on a recovered error.)
     */
    i = -1;
    do {
	i++;

	scsiPtr->flags &= ~SCSI_IO_COMPLETE;
	DevSCSISetupCommand(command, devPtr, firstSector, *numSectorsPtr);
	status = (*scsiPtr->commandProc)(devPtr->targetID, scsiPtr,
				 *numSectorsPtr * devPtr->sectorSize,
				 buffer, INTERRUPT);
	/*
	 * Wait for the command to complete.  The interrupt handler checks
	 * for I/O errors, computes the residual, and notifies us.
	 */
	if (status == SUCCESS) {
	    while((scsiPtr->flags & SCSI_IO_COMPLETE) == 0) {
		Sync_MasterWait(&scsiPtr->IOComplete, &scsiPtr->mutex,
				      FALSE);
	    }
	    status = scsiPtr->status;
	}
    } while ((status == DEV_HARD_ERROR || status == DEV_RETRY_ERROR ||
	      status == DEV_DMA_FAULT) && i < SCSI_NUM_HARD_ERROR_RETRIES);
    if (i >= SCSI_NUM_HARD_ERROR_RETRIES) {
	if (devSCSIDebug > 2) {
	    panic("SCSI: Too many retries after error.\n");
	} else {
	    printf("Warning: SCSI: Too many retries after error.\n");
	}
    }
    *numSectorsPtr -= (scsiPtr->residual / devPtr->sectorSize);
    scsiPtr->flags &= ~SCSI_CNTRLR_BUSY;
    Sync_MasterBroadcast(&scsiPtr->readyForIO);
    MASTER_UNLOCK(&scsiPtr->mutex);
    /*
     * Voluntarily give up the CPU in case anyone else wants to use the
     * disk.  The combination of the readyForIO and ioComplete 
     */
    Sched_ContextSwitch(PROC_READY);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * Dev_SCSIDiskOpen --
a375 149
 *	Open a partition of an SCSI disk as a file.  This merely
 *	checks to see if the disk is on-line before succeeding.
 *
 * Results:
 *	SUCCESS if the disk is on-line.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
/* ARGSUSED */
ReturnStatus
Dev_SCSIDiskOpen(devicePtr, useFlags, token)
    Fs_Device *devicePtr;	/* Device info, unit number etc. */
    int useFlags;		/* Flags from the stream being opened */
    ClientData token;		/* Call-back token for input, unused here */
{
    ReturnStatus error;
    int disk;		/* Disk number of disk that has the partition that
			 * corresponds to the unit number */
    DevSCSIDevice *diskPtr;	/* State of the disk */

    disk = devicePtr->unit / DEV_NUM_DISK_PARTS;
    if (disk >= SCSI_MAX_DISKS) {
	return(DEV_INVALID_UNIT);
    }
    diskPtr = scsiDisk[disk];
    if ((diskPtr == (DevSCSIDevice *)NIL) || (diskPtr == (DevSCSIDevice *)0)) {
	return(DEV_INVALID_UNIT);
    }

    error = DevSCSITest(diskPtr);
    return(error);
}

/*
 *----------------------------------------------------------------------
 *
 * Dev_SCSIDiskRead --
 *
 *	Read from a raw SCSI Disk.  This understands about sectors and
 *	may break the read up to account for user offsets into the disk
 *	file that don't correspond to the start of a sector.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The process will sleep waiting for the I/O to complete.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
Dev_SCSIDiskRead(devicePtr, offset, bufSize, buffer, lenPtr)
    Fs_Device *devicePtr;	/* Handle for raw SCSI disk device */
    int offset;			/* Indicates starting point for read.  This
				 * is rounded down to the start of a sector */
    int bufSize;		/* Number of bytes to read,  rounded down
				 * do a multiple of the sector size */
    char *buffer;		/* Buffer for the read */
    int *lenPtr;		/* How many bytes actually read */
{
    ReturnStatus error;	/* Error code */
    int firstSector;	/* The first sector to read */
    int numSectors;	/* The number of sectors to read */

    /*
     * For simplicity the offset is rouned down to the start of the sector
     * and the amount to read is also rounded down to a whole number of
     * sectors.  This should break misaligned reads up so the first and
     * last sectors are read into an extra buffer and copied into the
     * user's buffer.
     */
    if (SCSIdebug) {
	DBG_CALL;
    }
    offset &= ~(DEV_BYTES_PER_SECTOR-1);
    bufSize &= ~(DEV_BYTES_PER_SECTOR-1);
    firstSector = offset / DEV_BYTES_PER_SECTOR;
    numSectors = bufSize / DEV_BYTES_PER_SECTOR;
    error = DevSCSIDiskIO(SCSI_READ, devicePtr->unit, buffer,
			firstSector, &numSectors);
    *lenPtr = numSectors * DEV_BYTES_PER_SECTOR;
    return(error);
}

/*
 *----------------------------------------------------------------------
 *
 * Dev_SCSIDiskWrite --
 *
 *	Write to a raw SCSI disk.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
Dev_SCSIDiskWrite(devicePtr, offset, bufSize, buffer, lenPtr)
    Fs_Device *devicePtr;	/* Handle of raw disk device */
    int offset;			/* Indicates the starting point of the write.
				 * Rounded down to the start of a sector */
    int bufSize;		/* Number of bytes to write.  Rounded down
				 * to a multiple of the sector size */
    char *buffer;		/* Write buffer */
    int *lenPtr;		/* How much was actually written */
{
    ReturnStatus error;
    int firstSector;
    int numSectors;

    /*
     * For simplicity the offset is rouned down to the start of the sector
     * and the amount to write is also rounded down to a whole number of
     * sectors.  For misaligned writes we need to first read in the sector
     * and then overwrite part of it.
     */
    if (SCSIdebug) {
	DBG_CALL;
    }
    offset &= ~(DEV_BYTES_PER_SECTOR-1);
    bufSize &= ~(DEV_BYTES_PER_SECTOR-1);
    firstSector = offset / DEV_BYTES_PER_SECTOR;
    numSectors = bufSize / DEV_BYTES_PER_SECTOR;
    error = DevSCSIDiskIO(SCSI_WRITE, devicePtr->unit, buffer,
			firstSector, &numSectors);
    *lenPtr = numSectors * DEV_BYTES_PER_SECTOR;

    return(error);
}

/*
 *----------------------------------------------------------------------
 *
 * Dev_SCSIDiskIOControl --
 *
 *	Do a special operation on a raw SCSI Disk.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
d380 4
a383 4
ReturnStatus
Dev_SCSIDiskIOControl(devicePtr, command, inBufSize, inBuffer,
				 outBufSize, outBuffer)
    Fs_Device *devicePtr;
d390 10
a399 8
#ifdef not_used_yet
    ReturnStatus error;
    int disk;		/* Disk number of disk that has the partition that
			 * corresponds to the unit number */
    int part;		/* Partition of disk that corresponds to unit number */
    DevSCSIDisk *diskPtr;	/* State of the disk */
#endif
    switch (command) {
d439 1
a439 1
 * Dev_SCSIDiskClose --
d441 1
a441 1
 *	Close a raw SCSI disk file.
d451 4
a454 7
/*ARGSUSED*/
ReturnStatus
Dev_SCSIDiskClose(devicePtr, useFlags, openCount, writerCount)
    Fs_Device	*devicePtr;
    int 	useFlags;
    int		openCount;
    int		writerCount;
d456 7
a462 1
    return(SUCCESS);
d468 1
a468 1
 * DevSCSIDiskError --
d470 2
a471 1
 *	Handle errors indicated by the sense data returned from the disk.
d474 1
a474 1
 *	None.
d477 1
a477 1
 *	None.
a480 8
ReturnStatus
DevSCSIDiskError(devPtr, sensePtr)
    DevSCSIDevice *devPtr;
    DevSCSISense *sensePtr;
{
    register ReturnStatus status;
    DevSCSIDisk *diskPtr = (DevSCSIDisk *)devPtr->data;
    int command = devPtr->scsiPtr->command;
d482 26
a507 1
    if (sensePtr->error == 0x70) {
d509 1
a509 2
	 * Class 7 Extended sense data.  Set disk type so we
	 * switch out to extended sense handling below.
d511 4
a514 26
	diskPtr->type = SCSI_CLASS7_DISK;
    }
    switch (diskPtr->type) {
	case SCSI_GENERIC_DISK: {
	    /*
	     * Old style sense data.
	     */
	    if (sensePtr->error == SCSI_NO_SENSE_DATA) {	    
		status = SUCCESS;
	    } else {
		register int class = (sensePtr->error & 0x70) >> 4;
		register int code = sensePtr->error & 0xF;
		register int addr;
		addr = (sensePtr->highAddr << 16) |
			(sensePtr->midAddr << 8) |
			sensePtr->lowAddr;
		printf("SCSI-%d: Sense error (%d-%d) at <%x> ",
				 devPtr->scsiPtr->number, class, code, addr);
		if (scsiNumErrors[class] > code) {
		    printf("%s", scsiErrors[class][code]);
		}
		printf("\n");
		status = DEV_HARD_ERROR;
	    }
	    break;
	}
d516 2
a517 1
	 * Standard error handling for class7 extended sense data.
d519 13
a531 105
	case SCSI_CLASS7_DISK: {
	    register DevSCSIExtendedSense *extSensePtr;
	    extern Boolean devSCSIDebug;
	    DevSCSIController *scsiPtr;

	    extSensePtr = (DevSCSIExtendedSense *)sensePtr;
	    scsiPtr = devPtr->scsiPtr;
	    
	    switch (extSensePtr->key) {
		case SCSI_NO_SENSE:
		    status = SUCCESS;
		    break;
		case SCSI_RECOVERABLE:
		    /*
		     * The drive recovered from an error.
		     */
		    if (devSCSIDebug > 2) {
			printf("Warning: SCSI-%d drive %d LUN %d, recoverable error\n",
				  scsiPtr->number, devPtr->targetID,
				  devPtr->LUN);
			printf("\tInfo bytes 0x%x 0x%x 0x%x 0x%x\n",
				   extSensePtr->info1 & 0xff,
				   extSensePtr->info2 & 0xff,
				   extSensePtr->info3 & 0xff,
				   extSensePtr->info4 & 0xff);
		    }
		    scsiPtr->numRecoverableErrors++;
		    status = DEV_RETRY_ERROR;
		    break;
		case SCSI_NOT_READY_KEY:
		    status = DEV_OFFLINE;
		    break;
		case SCSI_ILLEGAL_REQUEST:
		    /*
		     * Probably a programming error.
		     */
		    printf("SCSI-%d drive %d LUN %d, illegal request %d\n",
				scsiPtr->number, devPtr->targetID,
				devPtr->LUN, command);
		    status = DEV_INVALID_ARG;
		    break;
		case SCSI_MEDIA_ERROR:
		case SCSI_HARDWARE_ERROR:
		    if (devSCSIDebug > 2) {
			panic("SCSI-%d drive %d LUN %d, hard class7 key %x\n",
			      scsiPtr->number, devPtr->targetID,
			      devPtr->LUN, extSensePtr->key);
		    } else {
			printf("SCSI-%d drive %d LUN %d, hard class7 key %x\n",
			      scsiPtr->number, devPtr->targetID, devPtr->LUN,
			      extSensePtr->key);
		    }
		    printf("\tInfo bytes 0x%x 0x%x 0x%x 0x%x\n",
			extSensePtr->info1 & 0xff,
			extSensePtr->info2 & 0xff,
			extSensePtr->info3 & 0xff,
			extSensePtr->info4 & 0xff);
		    scsiPtr->numHardErrors++;
		    status = DEV_HARD_ERROR;
		    break;
		case SCSI_UNIT_ATTN_KEY:
		    /*
		     * This is an error that occurs after the drive is reset.
		     * It can probably be ignored.
		     */
		    scsiPtr->numUnitAttns++;
		    status = SUCCESS;
		    break;
		case SCSI_WRITE_PROTECT_KEY:
		    printf("SCSI-%d drive %d LUN %d is write protected\n",
			scsiPtr->number, devPtr->targetID, devPtr->LUN);
		    status = FS_NO_ACCESS;
		    break;
		case SCSI_BLANK_CHECK:
		    /*
		     * Shouldn't encounter blank media on a disk.
		     */
		    printf("SCSI-%d drive %d LUN %d, \"blank check\"\n",
			scsiPtr->number, devPtr->targetID, devPtr->LUN);
		    printf("\tInfo bytes 0x%x 0x%x 0x%x 0x%x\n",
			extSensePtr->info1 & 0xff,
			extSensePtr->info2 & 0xff,
			extSensePtr->info3 & 0xff,
			extSensePtr->info4 & 0xff);
		    status = DEV_HARD_ERROR;
		    break;
		case SCSI_VENDOR:
		case SCSI_POWER_UP_FAILURE:
		case SCSI_ABORT_KEY:
		case SCSI_EQUAL:
		case SCSI_OVERFLOW:
		    printf("Warning: SCSI-%d drive %d-%d, unsupported class7 error %d\n",
			scsiPtr->number, devPtr->targetID, devPtr->LUN,
			extSensePtr->key);
		    status = DEV_HARD_ERROR;
		    break;
		default:
		    printf("Warning: SCSI-%d drive %d-%d, can't handle error %d\n",
			scsiPtr->number, devPtr->targetID, devPtr->LUN,
			extSensePtr->key);
		    status = DEV_HARD_ERROR;
		    break;
	    }
	    break;
	}
d533 1
d540 1
a540 1
 * Dev_SCSIDiskBlockIOInit --
d542 1
a542 1
 *	Initialization routine for the Block I/O interface to the SCSI disk.
d545 52
a596 15
 *	SUCCESS.
 *
 * Side effects:
 *	Saves a pointer to the geometry information for the ClientData
 *	field of the Fs_Device object passed in.
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
ReturnStatus
Dev_SCSIDiskBlockIOInit(devicePtr)
    Fs_Device *devicePtr;	/* Use the unit number to specify partition */
{
    return(SUCCESS);		/* NOT CALLED */
a597 39

/*
 *----------------------------------------------------------------------
 *
 * Dev_SCSIDiskBlockIO --
 *
 *	Do block I/O on the SCSI disk.  This uses the disk geometry
 *	information to map from filesystem fragments indexes to filesystem
 *	block indexes, and finally to disk sectors.
 *
 * Results:
 *	The return code from the I/O operation.
 *
 * Side effects:
 *	The disk write, if readWrite == FS_WRITE.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Dev_SCSIDiskBlockIO(readWrite, devicePtr, fragNumber, numFrags, buffer)
    int readWrite;		/* FS_READ or FS_WRITE */
    Fs_Device *devicePtr;	/* Use the unit number to specify partition */
    int fragNumber;		/* Index of first fragment to transfer*/
    int numFrags;		/* Number of fragments to transfer */
    Address buffer;		/* I/O buffer */
{
    ReturnStatus status;	/* General return code */
    int firstSector;		/* Starting sector of transfer */
    int numSectors;		/* Number of sectors to transfer */
    int scsiCommand;		/* SCSI_READ or SCSI_WRITE */

    scsiCommand = (readWrite == FS_READ) ? SCSI_READ : SCSI_WRITE;
    if ((fragNumber % FS_FRAGMENTS_PER_BLOCK) != 0) {
	/*
	 * The I/O doesn't start on a block boundary.  Transfer the
	 * first few extra fragments to get things going on a block boundary.
	 */
	register int extraFrags;
a598 43
	extraFrags = FS_FRAGMENTS_PER_BLOCK -
		    (fragNumber % FS_FRAGMENTS_PER_BLOCK);
	if (extraFrags > numFrags) {
	    extraFrags = numFrags;
	}
	firstSector = Fs_BlocksToSectors(fragNumber, devicePtr->data);
	numSectors = extraFrags * SECTORS_PER_FRAGMENT;
	status = DevSCSIDiskIO(scsiCommand, devicePtr->unit, buffer,
					    firstSector, &numSectors);
	extraFrags = numSectors / SECTORS_PER_FRAGMENT;
	fragNumber += extraFrags;
	buffer += extraFrags * FS_FRAGMENT_SIZE;
	numFrags -= extraFrags;
	if (status != SUCCESS) {
	    return(status);
	}
    }
    while (numFrags >= FS_FRAGMENTS_PER_BLOCK) {
	/*
	 * Transfer whole blocks.
	 */
	firstSector = Fs_BlocksToSectors(fragNumber, devicePtr->data);
	numSectors = SECTORS_PER_FRAGMENT * FS_FRAGMENTS_PER_BLOCK;
	status = DevSCSIDiskIO(scsiCommand, devicePtr->unit, buffer,
					    firstSector, &numSectors);
	fragNumber += FS_FRAGMENTS_PER_BLOCK;
	buffer += FS_BLOCK_SIZE;
	numFrags -= FS_FRAGMENTS_PER_BLOCK;
	if (status != SUCCESS) {
	    return(status);
	}
    }
    if (numFrags > 0) {
	/*
	 * Transfer the left over fragments.
	 */
	firstSector = Fs_BlocksToSectors(fragNumber, devicePtr->data);
	numSectors = numFrags * SECTORS_PER_FRAGMENT;
	status = DevSCSIDiskIO(scsiCommand, devicePtr->unit, buffer,
					    firstSector, &numSectors);
    }
    return(status);
}
@


8.3
log
@Added synchronization to DevSCSIDoLabel so it doesn't hit a busy SCSI bus.
Also fixed error handling so it can handle class7 error returns,
in particular the "no sense" nominal return.
@
text
@d20 1
a20 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/sun3.md/RCS/devSCSIDisk.c,v 8.2 88/11/21 09:04:14 brent Exp $ SPRITE (Berkeley)";
d31 1
@


8.2
log
@Stable version after code reorganization
@
text
@d20 1
a20 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/sun3.md/RCS/devSCSIDisk.c,v 8.1 88/11/16 14:38:24 brent Exp $ SPRITE (Berkeley)";
d80 1
a80 1
    diskPtr->type = SCSI_SHOEBOX_DISK;
d97 1
a97 1
     status = DevSCSIDoLabel(devPtr);
d132 11
a142 1
    DevSCSISetupCommand(SCSI_READ, devPtr, 0, 1);
d144 9
a152 2
    status = (*scsiPtr->commandProc)(devPtr->targetID, scsiPtr,
		    DEV_BYTES_PER_SECTOR, scsiPtr->labelBuffer, WAIT);
d648 1
a648 1
    register ReturnStatus status = SUCCESS;
d652 1
a652 1
    switch (diskPtr->type) {
d654 2
a655 2
	 * The shoebox apparently just returns the unextended sense
	 * format.
d657 10
a666 2
	case SCSI_SHOEBOX_DISK: {
	    if (sensePtr->error != SCSI_NO_SENSE_DATA) {	    
d684 1
a684 5
	 * The SCSIBOX Emulex drives will transfer in extended sense format.
	 *
	 * Unit attention, at least in one case, is potentially ignorable.
	 * Also, the Emulex SCSIBOX drive doesn't set an extra error code,
	 * it just sets the key to SCSI_UNIT_ATTN_KEY.
d686 1
a686 1
	case SCSI_EMULEX_DISK: {
d696 1
a696 5
		    if (devSCSIDebug) {
			printf("Warning: SCSI-%d drive %d-%d, no sense?\n",
				  scsiPtr->number, devPtr->targetID,
				  devPtr->LUN);
		    }
d703 1
a703 1
			printf("Warning: SCSI-%d drive %d-%d, recoverable error\n",
d722 1
a722 1
		    printf("SCSI-%d drive %d-%d, illegal request %d\n",
d724 1
a724 1
				devPtr->LUN,command);
d730 1
a730 1
			panic("SCSI-%d drive %d-%d, hard class7 key %x\n",
d732 1
a732 1
			      devPtr->LUN,extSensePtr->key);
d734 1
a734 1
			printf("SCSI-%d drive %d-%d, hard class7 key %x\n",
d743 1
a744 1
		    scsiPtr->numHardErrors++;
d752 1
d755 3
a757 5
		    if (command == SCSI_WRITE ||
			command == SCSI_WRITE_EOF ||
			command == SCSI_ERASE_TAPE) {
			status = FS_NO_ACCESS;
		    }
d760 4
a763 1
		    printf("SCSI-%d drive %d-%d, \"blank check\"\n",
d770 1
@


8.1
log
@Added various lower level routines specific to Disk I/O
@
text
@d20 1
a20 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/sun3.md/RCS/devSCSIDisk.c,v 6.2 88/10/30 21:37:26 jhh Exp $ SPRITE (Berkeley)";
d30 1
d42 1
a42 1
static int scsiDiskIndex = -1;
d66 1
a66 2
DevSCSIDiskInit(scsiPtr, devPtr)
    DevSCSIController *scsiPtr;		/* Controller state */
d70 1
d78 3
d83 1
d94 1
d97 1
a97 4
    diskPtr = (DevSCSIDisk *) malloc(sizeof(DevSCSIDisk));
    devPtr->data = (ClientData)diskPtr;
    diskPtr->type = SCSI_SHOEBOX_DISK;
    status = DevSCSIDoLabel(devPtr);
d134 2
a135 2
    status = DevSCSICommand(devPtr->slaveID, scsiPtr, DEV_BYTES_PER_SECTOR,
			    scsiPtr->labelBuffer, WAIT);
d137 2
a138 2
	printf("SCSI-%d: couldn't read the disk%d label\n",
			     scsiPtr->number, devPtr->slaveID);
d142 2
a143 2
    printf("SCSI-%d disk%d: %s\n", scsiPtr->number, devPtr->slaveID,
			diskLabelPtr->asciiLabel);
d161 1
d302 1
a302 1
    MASTER_LOCK(scsiPtr->mutex);
d338 1
a338 1
	status = (*scsiPtr->commandProc)(devPtr->slaveID, scsiPtr,
d364 1
a364 1
    MASTER_UNLOCK(scsiPtr->mutex);
a659 1
	 * Note: "gs/emulux/emulex/" will follow.
a663 2
	 *
	 * FIXME: the relationship between SCSI and SBC is pretty confused.
a665 1
	    register DevSBCSense *sbcSensePtr;
d667 2
a668 3
	    extern Boolean devSBCDebug;
	    DevSBCDevice *sbcDevPtr;
	    DevSBCController *sbcPtr;
a669 1
	    sbcSensePtr = (DevSBCSense *)sensePtr;
d671 1
a671 2
	    sbcDevPtr = (DevSBCDevice *) devPtr;
	    sbcPtr = sbcDevPtr->sbcPtr;
d675 4
a678 3
		    if (devSBCDebug) {
			printf("Warning: SCSI-%d drive %d, no sense?\n",
				  devPtr->scsiPtr->number, devPtr->slaveID);
d685 4
a688 4
		    if (devSBCDebug > 2) {
			printf("Warning: SCSI-%d drive %d, recoverable error, code %x\n",
				  devPtr->scsiPtr->number, devPtr->slaveID,
				  sbcSensePtr->code2);
d695 1
a695 1
		    sbcPtr->stats.numRecoverableErrors++;
d705 3
a707 3
		    printf("Warning: SCSI-%d drive %d, illegal request %d\n",
				devPtr->scsiPtr->number, devPtr->slaveID,
				command);
d712 4
a715 4
		    if (devSBCDebug > 2) {
			panic("SCSI-%d drive %d, hard class7 error %x code %x\n",
			      devPtr->scsiPtr->number, devPtr->slaveID,
			      extSensePtr->key, sbcSensePtr->code2);
d717 3
a719 3
			printf("Warning: SCSI-%d drive %d, hard class7 error %x code %x\n",
			      devPtr->scsiPtr->number, devPtr->slaveID,
			      extSensePtr->key, sbcSensePtr->code2);
d727 1
a727 1
		    sbcPtr->stats.numHardErrors++;
d734 1
a734 3
		    printf("Warning: SCSI-%d drive %d, unit attention\n",
			    devPtr->scsiPtr->number, devPtr->slaveID);
		    sbcPtr->stats.numUnitAttns++;
d744 2
a745 2
		    printf("SCSI-%d drive %d, \"blank check\"\n",
			devPtr->scsiPtr->number, devPtr->slaveID);
d754 1
a754 1
		case SCSI_ABORT:
d757 2
a758 2
		    printf("Warning: SCSI-%d drive %d, unsupported class7 error %d\n",
			devPtr->scsiPtr->number, devPtr->slaveID,
d763 2
a764 2
		    printf("Warning: SCSI-%d drive %d, can't handle error %d\n",
			devPtr->scsiPtr->number, devPtr->slaveID,
a768 46
#ifdef notdef
	    if (emuluxSensePtr->extSense.key != SCSI_UNIT_ATTN_KEY) {
		switch (emuluxSensePtr->error) {
		    case SCSI_NOT_READY:
			status = DEV_OFFLINE;
			break;
		    case SCSI_INSUF_CAPACITY:
			printf("Warning: Emulex: Insufficient disk capacity");
			/* fall thru */
		    case SCSI_END_OF_MEDIA:
			status = DEV_END_OF_TAPE;  /* ??? */
			break;
		    case SCSI_HARD_DATA_ERROR:
			status = DEV_HARD_ERROR;
			break;
		    case SCSI_WRITE_PROTECT:
			if (command == SCSI_WRITE) {
			    status = FS_NO_ACCESS;
			}
			break;
		    case SCSI_CORRECTABLE_ERROR:
			printf("Warning: SCSI-%d drive %d, correctable error",
				devPtr->scsiPtr->number, devPtr->slaveID);
			break;
		    case SCSI_INVALID_COMMAND:
			printf("Warning: SCSI-%d drive %d, invalid command 0x%x",
				devPtr->scsiPtr->number, devPtr->slaveID,
				command);
			break;

		    default:
			panic("SCSI-%d drive %d, unknown error %x\n",
				  devPtr->scsiPtr->number, devPtr->slaveID,
				  emuluxSensePtr->error);
			status = DEV_NO_MEDIA;
			break;
		}
	    } else {
	      /*
	       * The drive has been reset sinse the last command.
	       * Looks like we get this at startup.
	       */
		printf("Warning: SCSI-%d drive %d, unit attention\n",
			devPtr->scsiPtr->number, devPtr->slaveID);
	    }
#endif notdef
@


8.0
log
@Changing version numbers.
@
text
@d10 7
d20 1
a20 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/sun3.md/RCS/devSCSIDisk.c,v 6.2 88/10/30 21:37:26 jhh Exp Locker: douglis $ SPRITE (Berkeley)";
a28 1
#include "devSBC.h"		/* FIXME: need to merge this */
d32 1
a32 1
int SCSIdebug = FALSE;
d34 334
a367 1
#define SECTORS_PER_FRAGMENT	(FS_FRAGMENT_SIZE / DEV_BYTES_PER_SECTOR)
@


6.2
log
@multiprocessor port, change to new C lib
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: /sprite/src/kernel/dev/sun3.md/RCS/devSCSIDisk.c,v 6.1 88/09/05 12:45:13 mendel Exp Locker: jhh $ SPRITE (Berkeley)";
@


6.1
log
@Removed lint
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: devSCSIDisk.c,v 6.0 88/08/11 12:30:15 douglis Stable $ SPRITE (Berkeley)";
d305 1
a305 1
		Sys_Printf("SCSI-%d: Sense error (%d-%d) at <%x> ",
d308 1
a308 1
		    Sys_Printf("%s", scsiErrors[class][code]);
d310 1
a310 1
		Sys_Printf("\n");
d340 1
a340 2
			Sys_Panic(SYS_WARNING,
				  "SCSI-%d drive %d, no sense?\n",
d349 1
a349 2
			Sys_Panic(SYS_WARNING,
				  "SCSI-%d drive %d, recoverable error, code %x\n",
d352 1
a352 1
			Sys_Printf("\tInfo bytes 0x%x 0x%x 0x%x 0x%x\n",
d368 1
a368 2
		    Sys_Panic(SYS_WARNING,
				"SCSI-%d drive %d, illegal request %d\n",
d375 2
a376 2
		    Sys_Panic((devSBCDebug > 2) ? SYS_FATAL : SYS_WARNING,
			      "SCSI-%d drive %d, hard class7 error %x code %x\n",
d379 6
a384 1
		    Sys_Printf("\tInfo bytes 0x%x 0x%x 0x%x 0x%x\n",
d397 1
a397 2
		    Sys_Panic(SYS_WARNING,
			    "SCSI-%d drive %d, unit attention\n",
d409 1
a409 2
		    Sys_Panic(SYS_WARNING,
			"SCSI-%d drive %d, \"blank check\"\n",
d411 1
a411 1
		    Sys_Printf("\tInfo bytes 0x%x 0x%x 0x%x 0x%x\n",
d422 1
a422 2
		    Sys_Panic(SYS_WARNING,
			"SCSI-%d drive %d, unsupported class7 error %d\n",
d428 1
a428 2
		    Sys_Panic(SYS_WARNING,
			"SCSI-%d drive %d, can't handle error %d\n",
d441 1
a441 2
			Sys_Panic(SYS_WARNING,
				    "Emulex: Insufficient disk capacity");
d455 1
a455 2
			Sys_Panic(SYS_WARNING,
				"SCSI-%d drive %d, correctable error",
d459 1
a459 2
			Sys_Panic(SYS_WARNING,
				"SCSI-%d drive %d, invalid command 0x%x",
d465 1
a465 2
			Sys_Panic(SYS_FATAL,
				"SCSI-%d drive %d, unknown error %x\n",
d476 1
a476 2
		Sys_Panic(SYS_WARNING,
			"SCSI-%d drive %d, unit attention\n",
@


6.0
log
@Changing version numbers.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: devSCSIDisk.c,v 5.5 88/07/12 18:02:52 douglis Exp $ SPRITE (Berkeley)";
d46 1
@


5.5
log
@on hard error before, DEV_INVALID_ARG was being returned.  Now 
DEV_HARD_ERROR is returned :)
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: devSCSIDisk.c,v 5.4 88/06/08 17:01:27 douglis Exp $ SPRITE (Berkeley)";
@


5.4
log
@use DevSBCSense for the emulex scsibox drives, and print the nonextended
error code along with the more general extended code.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: devSCSIDisk.c,v 5.3 88/05/25 19:39:12 douglis Exp $ SPRITE (Berkeley)";
d310 1
a310 1
		status = DEV_INVALID_ARG;
@


5.3
log
@look at the key rather than the error value (always 0 for the new drives).
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: devSCSIDisk.c,v 5.2 88/05/23 21:44:45 douglis Exp $ SPRITE (Berkeley)";
d325 1
a325 1
	    register DevEmuluxSense *emuluxSensePtr;
d331 1
a331 1
	    emuluxSensePtr = (DevEmuluxSense *)sensePtr;
d350 3
a352 2
				  "SCSI-%d drive %d, recoverable error\n",
				  devPtr->scsiPtr->number, devPtr->slaveID);
d360 1
d377 4
a380 4
		    Sys_Panic(SYS_WARNING,
				"SCSI-%d drive %d, hard class7 error %d\n",
				devPtr->scsiPtr->number, devPtr->slaveID,
				extSensePtr->key);
@


5.2
log
@Made the disk error handler distinguish between the old shoebox disks,
which return the scsi nonextended error format, and the new emulex drives,
which return extended format when given a size parameter.
still needs work (to use "key" rather than "error"), but this version
goes along with devSBC.c, which is being checked in now because it
is limping along.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: devSCSIDisk.c,v 5.1 87/09/29 15:48:22 nelson Exp $ SPRITE (Berkeley)";
d22 1
d321 2
d327 4
d333 101
d483 1
@


5.1
log
@Changed to handle new close interface.
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: devSCSIDisk.c,v 5.0 87/08/11 10:40:09 sprite Exp $ SPRITE (Berkeley)";
d286 26
a311 11
    if (sensePtr->error != SCSI_NO_SENSE_DATA) {	    
	register int class = (sensePtr->error & 0x70) >> 4;
	register int code = sensePtr->error & 0xF;
	register int addr;
	addr = (sensePtr->highAddr << 16) |
		(sensePtr->midAddr << 8) |
		sensePtr->lowAddr;
	Sys_Printf("SCSI-%d: Sense error (%d-%d) at <%x> ",
			 devPtr->scsiPtr->number, class, code, addr);
	if (scsiNumErrors[class] > code) {
	    Sys_Printf("%s", scsiErrors[class][code]);
d313 44
a356 1
	Sys_Printf("\n");
d358 19
a376 3
	return (DEV_INVALID_ARG);
    } else {
	return(SUCCESS);
d378 1
@


5.0
log
@First Sprite native copy
@
text
@d13 1
a13 1
static char rcsid[] = "$Header: devSCSIDisk.c,v 4.5 87/07/01 17:37:28 brent Exp $ SPRITE (Berkeley)";
d257 5
a261 3
Dev_SCSIDiskClose(devicePtr, useFlags)
    Fs_Device *devicePtr;
    int useFlags;
@
