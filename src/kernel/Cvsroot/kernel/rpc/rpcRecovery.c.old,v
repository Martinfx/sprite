head     9.0;
branch   ;
access   ;
symbols  ds3100:9.0 sun3:9.0 sun4nw:9.0 symm:9.0 spur:9.0 Summer89:9.0 newlib:8.0 Summer88:6.0;
locks    ; strict;
comment  @ * @;


9.0
date     89.09.12.15.18.27;  author douglis;  state Stable;
branches ;
next     8.0;

8.0
date     88.11.11.18.36.01;  author douglis;  state Stable;
branches ;
next     6.0;

6.0
date     88.08.11.12.25.38;  author brent;  state Stable;
branches ;
next     5.9;

5.9
date     87.10.08.10.51.35;  author brent;  state Exp;
branches ;
next     5.8;

5.8
date     87.10.04.16.00.38;  author brent;  state Exp;
branches ;
next     5.7;

5.7
date     87.10.01.14.30.41;  author brent;  state Exp;
branches ;
next     5.6;

5.6
date     87.09.29.14.22.56;  author brent;  state Exp;
branches ;
next     5.5;

5.5
date     87.09.23.15.22.03;  author brent;  state Exp;
branches ;
next     5.4;

5.4
date     87.09.21.16.26.08;  author brent;  state Exp;
branches ;
next     5.3;

5.3
date     87.09.16.11.47.59;  author brent;  state Exp;
branches ;
next     5.2;

5.2
date     87.09.11.09.54.39;  author brent;  state Exp;
branches ;
next     5.1;

5.1
date     87.09.09.10.48.36;  author brent;  state Exp;
branches ;
next     5.0;

5.0
date     87.09.04.02.22.34;  author brent;  state Exp;
branches ;
next     ;


desc
@First Sprite native copy
@


9.0
log
@Changing version numbers.
@
text
@/* 
 * rpcRecovery.c --
 *
 *	The routines here maintain up/down state about other hosts.
 *	Recovery actions that are registered via Rpc_HostNotify are
 *	called-back when a host crashes and when it reboots.
 *	Regular message	traffic plus explicit pings are used to determine
 *	the state of other hosts.  The main external procedures are
 *	Rpc_HostIsDown, used to query the state of another host, and
 *	Rpc_WaitForHost, used to block a process until a host reboots.
 *	(Rpc_WaitForHost isn't used much.  Instead, modules rely on the
 *	recovery callbacks to indicate that a host is back to life, and
 *	they block processes in their own way.)
 *
 *	One impact of these recovery hooks on the RPC system is that service
 *	requests from a client that is just rebooting are blocked until
 *	the recovery actions complete.
 *
 * Copyright 1987 Regents of the University of California
 * All rights reserved.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcRecovery.c,v 8.0 88/11/11 18:36:01 douglis Stable Locker: douglis $ SPRITE (Berkeley)";
#endif not lint


#include "sprite.h"
#include "rpc.h"
#include "rpcInt.h"
#include "sync.h"
#include "hash.h"
#include "mem.h"
#include "trace.h"

/*
 * The state of other hosts is kept in a hash table keyed on SpriteID.
 * This state is maintained by RpcHostAlive and RpcHostDead, which are
 * called in turn after packet reception or RPC timeout, respectively.
 * RpcHostDead is also called by the Rpc_Daemon if it can't get an
 * explicit acknowledgment from a client.
 */
static Hash_Table	recoveryHashTableStruct;
static Hash_Table	*recovHashTable = &recoveryHashTableStruct;

typedef struct RecovHostState {
    int			state;		/* flags defined below */
    int			clientState;	/* flags defined in rpc.h */
    int			spriteID;	/* Sprite Host ID */
    int			bootID;		/* Timestamp from RPC header */
    Time		time;		/* Time of last message */
    Sync_Condition	alive;		/* Notified when host comes up */
    Sync_Condition	recovery;	/* Notified when recovery is complete */
} RecovHostState;

/*
 * Access to the hash table is monitored.
 */
Sync_Lock rpcRecoveryLock;
#define LOCKPTR (&rpcRecoveryLock)

/*
 * Host state:
 *	RECOV_STATE_UNKNOWN	Initial state.
 *	RECOV_HOST_ALIVE	Set when we receive a message from the host
 *	RECOV_HOST_DEAD		Set when an RPC times out.
 *
 *	RECOV_CRASH_CALLBACKS	Set during the crash call-backs, this is used
 *				to block RPC server processes until the
 *				crash recovery actions have completed.
 *	RECOV_HOST_PINGING	Set while there are pinging call-backs scheduled
 *	RECOV_HOST_BOOTING	Set while there are pinging call-backs scheduled
 *
 *	RECOV_WAITING		artificial state to trace Rpc_WaitForHost
 *	RECOV_CRASH		artificial state to trace RpcCrashCallBacks
 *	RECOV_REBOOT		artificial state to trace RpcRebootCallBacks
 */
#define RECOV_STATE_UNKNOWN	0x0
#define RECOV_HOST_ALIVE	0x1
#define RECOV_HOST_DEAD		0x2

#define RECOV_CRASH_CALLBACKS	0x0100
#define RECOV_HOST_PINGING	0x0200
#define RECOV_HOST_BOOTING	0x0400

#define RECOV_WAITING		0x4
#define RECOV_CRASH		0x8
#define RECOV_REBOOT		0x10

/*
 * A host is "pinged" (to see when it reboots) at an interval determined by
 * rpcPingSeconds.
 */
int rpcPingSeconds = 30;

/*
 * After a host reboots we pause a bit before attempting recovery.  This
 * allows a host to complete boot-time start up.  If we don't pause the
 * ping done by the recovery call backs may fail and we may erroneously
 * think that the other guy crashed right away.
 */
int rpcRecoveryPause = 30;	/* Seconds */

/*
 * Other kernel modules can arrange call-backs when a host reboots.
 * The following list structure is used to keep these.  The calling
 * sequence of the callback is as follows:
 *	(*proc)(spriteID, clientData, when)
 * where 'when' is RPC_WHEN_HOST_DOWN or RPC_WHEN_HOST_REBOOTS (never both).
 */

typedef struct {
    List_Links	links;
    void	(*proc)();
    int		flags;		/* RPC_WHEN_HOST_DOWN, RPC_WHEN_HOST_REBOOTS */
    ClientData	clientData;
} NotifyElement;

List_Links	rpcNotifyList;

/*
 * A trace is kept for debugging/understanding the host state transisions.
 */
typedef struct RpcRecovTraceRecord {
    int		spriteID;		/* Host ID whose state changed */
    int		state;			/* Their new state */
} RpcRecovTraceRecord;

/*
 * Tracing events, these describe the trace record.  Note that some
 *	trace types are defined in rpc.h for use with Rpc_HostTrace.
 *
 *	RECOV_CUZ_WAIT		Wait in Rpc_WaitForHost
 *	RECOV_CUZ_WAKEUP	Wakeup in Rpc_WaitForHost
 *	RECOV_CUZ_INIT		First time we were interested in the host
 *	RECOV_CUZ_REBOOT	We detected a reboot
 *	RECOV_CUZ_CRASH		We detected a crash
 *	RECOV_CUZ_DONE		Recovery actions completed
 *	RECOV_CUZ_PING_CHK	We are pinging the host to check it out
 *	RECOV_CUZ_PING_ASK	We are pinging the host because we were asked
 */
#define RECOV_CUZ_WAIT		0x1
#define RECOV_CUZ_WAKEUP	0x2
#define RECOV_CUZ_INIT		0x4
#define RECOV_CUZ_REBOOT	0x8
#define RECOV_CUZ_CRASH		0x10
#define RECOV_CUZ_DONE		0x20
#define RECOV_CUZ_PING_CHK	0x40
#define RECOV_CUZ_PING_ASK	0x80

Trace_Header rpcRecovTraceHdr;
Trace_Header *rpcRecovTraceHdrPtr = &rpcRecovTraceHdr;
int rpcRecovTraceLength = 50;
Boolean rpcRecovTracing = TRUE;

#ifndef CLEAN

#define RECOV_TRACE(zspriteID, zstate, event) \
    if (rpcRecovTracing) {\
	RpcRecovTraceRecord rec;\
	rec.spriteID = zspriteID;\
	rec.state = zstate;\
	Trace_Insert(rpcRecovTraceHdrPtr, event, &rec);\
    }
#else

#define RECOV_TRACE(zspriteID, zstate, event)

#endif not CLEAN
/*
 * Forward declarations.
 */
void RpcRebootCallBacks();
void RpcCrashCallBacks();
void MarkRecoveryComplete();
int  GetHostState();
void StartPinging();
void CheckHost();
void StopPinging();


/*
 *----------------------------------------------------------------------
 *
 * RpcInitRecovery --
 *
 *	Set up the data structures used by the RpcRecovery module.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
RpcInitRecovery()
{
    Hash_Init(recovHashTable, 8, HASH_ONE_WORD_KEYS);
    List_Init(&rpcNotifyList);
    Trace_Init(rpcRecovTraceHdrPtr, rpcRecovTraceLength,
		sizeof(RpcRecovTraceRecord), 0);
}

/*
 *----------------------------------------------------------------------
 *
 * Rpc_HostNotify --
 *
 *	Add a call-back for other modules to use when a host crashes/reboots.
 *	The 'when' parameter specifies when to callback the client procedure.
 *	If RPC_WHEN_HOST_DOWN then the procedure is called when the RPC
 *	module has gotten a timeout trying to reach the host.  If it is
 *	RPC_WHEN_HOST_REBOOTS then the call-back is made when the RPC
 *	module detects a reboot due to the bootID changing.  If both
 *	are specified then the call-back is made at both times.
 *	
 * Results:
 *	None.
 *
 * Side effects:
 *	Entry added to notify list.
 *
 *----------------------------------------------------------------------
 */
void
Rpc_HostNotify(proc, clientData, when)
    void	(*proc)();
    ClientData	clientData;
    int		when;		/* RPC_WHEN_HOST_DOWN, RPC_WHEN_HOST_REBOOTS */
{
    register	NotifyElement	*notifyPtr;

    notifyPtr = (NotifyElement *) Mem_Alloc(sizeof(NotifyElement));
    notifyPtr->proc = proc;
    notifyPtr->clientData = clientData;
    notifyPtr->flags = when;
    List_InitElement((List_Links *) notifyPtr);
    List_Insert((List_Links *) notifyPtr, LIST_ATREAR(&rpcNotifyList));
}

/*
 *----------------------------------------------------------------------
 *
 * Rpc_HostIsDown --
 *
 *	This decides if the specified host is down, and will make sure
 *	that the host is being "pinged" if the caller wants to find
 *	out (via the callbacks setup in Rpc_HostNotify) when the host
 *	comes back to life.  If the host is known to be down this routine
 *	returns TRUE and makes sure pinging is initiated (if needed).
 *	Otherwise, if there hasn't been recent message traffic 
 *	(within the last 10 seconds) then this will ping the host to find
 *	out if it's still up.  There are two cases then, the host isn't
 *	up, or it is booting but it's RPC service is not ready yet.
 *	We return FALSE so that our caller doesn't think the host
 *	has crashed
 *
 * Results:
 *	SUCCESS if the host is up, FAILURE if it doesn't respond to
 *	pings or is known to be down, and RPC_SERVICE_DISABLED if
 *	the host says so.
 *
 * Side effects:
 *	May do a ping.  If the 'ping' parameter is TRUE this will make
 *	sure that pinging is in progress if the host is down.
 *
 *----------------------------------------------------------------------
 */

ReturnStatus
Rpc_HostIsDown(spriteID, ping)
    int spriteID;
    Boolean ping;	/* If TRUE, we make sure the host is being pinged
			 * if it is down now */
{
    register ReturnStatus status = SUCCESS;

    if (spriteID == NET_BROADCAST_HOSTID) {
	Sys_Panic(SYS_WARNING, "Rpc_HostIsDown, got broadcast address\n");
	return(SUCCESS);
    }
    switch (GetHostState(spriteID)) {
	case RECOV_STATE_UNKNOWN:
	    RECOV_TRACE(spriteID, RECOV_STATE_UNKNOWN, RECOV_CUZ_PING_ASK);
	    status = Rpc_Ping(spriteID);
	    break;
	case RECOV_HOST_ALIVE:
	    status = SUCCESS;
	    break;
	case RECOV_HOST_DEAD:
	    status = FAILURE;
	    break;
    }
    if (status != SUCCESS && ping) {
	StartPinging(spriteID);
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * Rpc_WaitForHost --
 *
 *	Block the current process (at an interruptable priority) until
 *	the given host comes back up.  This is used when retrying
 *	filesystem operations when a fileserver goes down, for example.
 *
 * Results:
 *	TRUE if the wait was interrupted.
 *
 * Side effects:
 *	The current process is blocked
 *	until messages from the host indicate it is up.
 *
 *----------------------------------------------------------------------
 */
Boolean
Rpc_WaitForHost(spriteID)
    int spriteID;			/* Host to monitor */
{
    /*
     * Set up the hosts state (dead or alive) by pinging it.
     * If it's down we drop into a monitored routine to do 
     * the actual waiting.  It will check again to make sure
     * we don't sleep on an alive host.
     */
    if (Rpc_HostIsDown(spriteID, TRUE) == FAILURE) {
	RECOV_TRACE(spriteID, RECOV_STATE_UNKNOWN, RECOV_CUZ_WAIT);
	return(RpcWaitForHostInt(spriteID));
    } else {
	return(FALSE);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * RpcWaitForHostInt --
 *
 *	Block the current process (at an interruptable priority) until
 *	the given host comes back up.  Our caller should have already
 *	probed to host with Rpc_HostIsDown so that pinging is already
 *	initiated.
 *
 * Results:
 *	TRUE is the wait was interrupted by a signal.
 *
 * Side effects:
 *	If the host is thought down, the current process is blocked
 *	until messages from the host indicate it is up.
 *
 *----------------------------------------------------------------------
 */
ENTRY Boolean
RpcWaitForHostInt(spriteID)
    int spriteID;			/* Host to monitor */
{
    Hash_Entry *hashPtr;
    RecovHostState *hostPtr;
    Boolean sigPending = FALSE;

    LOCK_MONITOR;

    if (spriteID <= 0 || spriteID == rpc_SpriteID) {
	Sys_Panic(SYS_FATAL, "RpcWaitForHostInt, bad hostID %d\n", spriteID);
	UNLOCK_MONITOR;
	return(FALSE);
    }

    hashPtr = Hash_Find(recovHashTable, spriteID);
    if (hashPtr->value == (Address)NIL) {
	Sys_Panic(SYS_FATAL, "RpcWaitForHostInt, no host state\n");
	UNLOCK_MONITOR;
	return;
    } else {
	hostPtr = (RecovHostState *)hashPtr->value;
    }
    while (!sigPending && (hostPtr->state & RECOV_HOST_DEAD)) {
	sigPending = Sync_Wait(&hostPtr->alive, TRUE);
    }
    RECOV_TRACE(hostPtr->spriteID, hostPtr->state, RECOV_CUZ_WAKEUP);

    UNLOCK_MONITOR;
    return(sigPending);
}

/*
 *----------------------------------------------------------------------
 *
 * Rpc_HostPrint --
 *
 *	Print out a statement concerning a host.  This maps to a
 *	string hostname if possible, and prints out the message.
 *	The strings come from netAddresses.c (but should be imported
 *	via Net_RouteInstall system call).
 *
 *	MOVE THIS TO NET
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sys_Printf.
 *
 *----------------------------------------------------------------------
 */

void
Rpc_HostPrint(spriteID, string)
    int spriteID;
    char *string;
{
    char *hostName;

    Net_SpriteIDToName(spriteID, &hostName);
    if (hostName == (char *)NIL) {
	Sys_Printf("Sprite Host <%d> %s\n", spriteID, string);
    } else {
	Sys_Printf("Sprite Host %s (%d) %s\n", hostName, spriteID, string);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Rpc_HostTrace --
 *
 *	Add an entry to the rpc recovery trace.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ENTRY void
Rpc_HostTrace(spriteID, event)
    int spriteID;
    int event;
{
    LOCK_MONITOR;

    RECOV_TRACE(spriteID, RECOV_STATE_UNKNOWN, event);

    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * Rpc_HostGetState --
 *
 *	Return the client state associated with a host.  The recovery host
 *	table is a convenient object keyed on spriteID.  Other modules can
 *	set their own state in the table (beyond the simple up/down state
 *	mainted by the rest of this module), and retrieve it with this call.
 *
 * Results:
 *	A copy of the clientState field.  0 is returned if there is no
 *	host table entry.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ENTRY int
Rpc_HostGetState(spriteID)
    int spriteID;
{
    Hash_Entry *hashPtr;
    RecovHostState *hostPtr;
    int result = 0;

    LOCK_MONITOR;

    hashPtr = Hash_LookOnly(recovHashTable, spriteID);
    if (hashPtr != (Hash_Entry *)NIL) {
	hostPtr = (RecovHostState *)hashPtr->value;
	if (hostPtr != (RecovHostState *)NIL) {
	    result = hostPtr->clientState;
	}
    }
    UNLOCK_MONITOR;
    return(result);
}

/*
 *----------------------------------------------------------------------
 *
 * Rpc_HostSetState --
 *
 *	Set the client state associated with a host.  This completely
 *	overwrites the previous value of the client state.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sets the clientState field of the host state.  This will add an
 *	entry to the host table if one doesn't alreay exist.  Its RPC
 *	up/down state is set to "unknown" in this case.
 *
 *----------------------------------------------------------------------
 */

ENTRY void
Rpc_HostSetState(spriteID, state)
    int spriteID;
    int state;
{
    Hash_Entry *hashPtr;
    RecovHostState *hostPtr;

    LOCK_MONITOR;

    hashPtr = Hash_Find(recovHashTable, spriteID);
    hostPtr = (RecovHostState *)hashPtr->value;
    if (hostPtr == (RecovHostState *)NIL) {
	hostPtr = Mem_New(RecovHostState);
	hashPtr->value = (Address)hostPtr;

	Byte_Zero(sizeof(RecovHostState), (Address)hostPtr);
	hostPtr->state = RECOV_STATE_UNKNOWN;
	hostPtr->spriteID = spriteID;
    }
    hostPtr->clientState = state;
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * RpcHostAlive --
 *
 *	Mark the host as being alive.  This is called when we've received
 *	a message from the host.  It uses state from the host table and
 *	the bootID parameter to detect reboots.  If a reboot is detected
 *	but we thought the host was up then the Crash call-backs are invoked.
 *	In any case, a reboot invokes the Reboot call-backs.  (Call-backs
 *	are installed with Rpc_HostNotify.)  Finally, a time stamp is
 *	kept so we can check when we last got a message from a host.
 *
 *	This procedure is called from client RPC upon successful completion
 *	of an RPC, and by server RPC upon reciept of a client request.
 *	These two cases are identified by the 'asyncRecovery' parameter.
 *	Servers want synchronous recovery so they don't service anything
 *	until state associated with that client has been cleaned up via
 *	the Crash call-backs.  So RpcHostAlive blocks (if !asyncRecovery)
 *	until the crash call-backs are complete.  Clients don't have the
 *	same worries so they let the crash call-backs complete in the
 *	background (asyncRecovery is TRUE).
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Updates the boot timestamp of the other host.  Procedures installed
 *	with Rpc_HostNotify are called when the bootID changes.  A timestamp
 *	of when this message was received is obtained from the "cheap" clock
 *	so we can tell later if there has been recent message traffic.
 *
 *----------------------------------------------------------------------
 */

ENTRY void
RpcHostAlive(spriteID, bootID, asyncRecovery)
    int spriteID;		/* Host ID of the message sender */
    int bootID;			/* Boot time stamp from message header */
    Boolean asyncRecovery;	/* TRUE means do recovery call-backs in
				 * the background. FALSE causes the process
				 * to wait until crash recovery is complete. */
{
    register Hash_Entry *hashPtr;
    register RecovHostState *hostPtr;
    Boolean reboot = FALSE;	/* Used to control print statements at reboot */

    LOCK_MONITOR;
    if (spriteID == NET_BROADCAST_HOSTID || bootID == 0) {
	/*
	 * Don't track the broadcast address.  Also ignore zero valued
	 * bootIDs.  These come from hosts at early boot time, or
	 * in certain error conditions like trying to send too much
	 * data in a single RPC.
	 */
	UNLOCK_MONITOR;
	return;
    }

    hashPtr = Hash_Find(recovHashTable, spriteID);
    if (hashPtr->value == (Address)NIL) {
	/*
	 * Initialize the host's state. This is the first time we've talked
	 * to it since we've been up, so take no action.
	 */
	hostPtr = Mem_New(RecovHostState);
	hashPtr->value = (Address)hostPtr;

	Byte_Zero(sizeof(RecovHostState), (Address)hostPtr);
	hostPtr->state = RECOV_HOST_ALIVE;
	hostPtr->spriteID = spriteID;
	hostPtr->bootID = bootID;

	Rpc_HostPrint(spriteID, "is up");
	RECOV_TRACE(spriteID, RECOV_HOST_ALIVE, RECOV_CUZ_INIT);
    } else {
	hostPtr = (RecovHostState *)hashPtr->value;
    }
    if (hostPtr != (RecovHostState *)NIL) {
	/*
	 * Have to read the clock in order to suppress repeated pings,
	 * see GetHostState and Rpc_HostIsDown.
	 */
	Timer_GetTimeOfDay(&hostPtr->time, (int *)NIL, (Boolean *)NIL);
	/*
	 * Check for a rebooted peer by comparing boot time stamps.
	 * The first process to detect this initiates recovery actions.
	 */
	if (hostPtr->bootID != bootID) {
	    Rpc_HostPrint(spriteID, "rebooted");
	    hostPtr->bootID = bootID;
	    reboot = TRUE;
	    RECOV_TRACE(spriteID, hostPtr->state, RECOV_CUZ_REBOOT);
	    if (hostPtr->state & RECOV_HOST_ALIVE) {
		/*
		 * A crash occured un-detected.  We do the crash call-backs
		 * first, and block server processes in the meantime.
		 * RECOV_CRASH_CALLBACKS flag is reset by RpcCrashCallBacks.
		 * The host is marked dead here so we fall into the
		 * switch below and call the reboot callbacks.
		 */
		RECOV_TRACE(spriteID, RECOV_CRASH, RECOV_CUZ_REBOOT);
		hostPtr->state &= ~RECOV_HOST_ALIVE;
		hostPtr->state |= (RECOV_HOST_DEAD | RECOV_CRASH_CALLBACKS);
		Proc_CallFunc(RpcCrashCallBacks, spriteID, 0);
	    }
	}
	/*
	 * Block servers until crash recovery actions complete.
	 * Servers are synchronous with respect to reboot recovery.
	 * This blocks requests from clients until after the
	 * recovery actions complete.
	 */
	if (! asyncRecovery) {
	    while (hostPtr->state & RECOV_CRASH_CALLBACKS) {
		Sync_Wait(&hostPtr->recovery, FALSE);
		if (sys_ShuttingDown) {
		    Sys_Printf("Warning, Server exiting from RpcHostAlive\n");
		    Proc_Exit(1);
		}
	    }
	}
	/*
	 * Now that we've taken care of crash recovery, we see if the host
	 * is newly up.  If so, invoke the reboot call-backs and then notify
	 * waiting processes. This means clientA (us) may start
	 * re-opening files from serverB (the other guy) at the same time
	 * as clientA (us) is closing files that serverB had had open.
	 * ie. both the crash and reboot call backs may proceed in parallel.
	 */
	switch(hostPtr->state & ~(RECOV_CRASH_CALLBACKS|RECOV_HOST_PINGING)) {
	    case RECOV_HOST_ALIVE:
		/*
		 * Host already alive.
		 */
		break;
	    case RECOV_HOST_DEAD: {
		register int wait;
		/*
		 * Notify interested parties that the host is up.  If the host
		 * has done a full reboot we wait a bit before pounding on
		 * it with our re-open requests.  This gives it a chance
		 * to create RPC server processes, etc. so we don't think
		 * it crashed because we tried to talk to it too soon.
		 */
		if ( !reboot ) {
		    Rpc_HostPrint(spriteID, "is back again");
		    wait = 0;
		} else {
		    wait = timer_IntOneSecond * rpcRecoveryPause;
		}
		hostPtr->state &= ~RECOV_HOST_DEAD;
		hostPtr->state |= RECOV_HOST_ALIVE;
		Sync_Broadcast(&hostPtr->alive)
		Proc_CallFunc(RpcRebootCallBacks, spriteID, wait);
		break;
	    default:
		Sys_Panic(SYS_WARNING, "Unexpected state <%x> for ",
			hostPtr->state);
		Rpc_HostPrint(spriteID, "");
		break;
	    }
	}
    }
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * RpcHostDead --
 *
 *	Change the host's state to "dead".  This is called from client RPC
 *	when an RPC timed out with no response.  It is also called by the
 *	Rpc_Daemon when it can't recontact a client to get an explicit
 *	acknowledgment.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sets the state in the host state table to dead.  Pings are not
 *	initiated here because we may or may not be interested in
 *	the other host.  See Rpc_HostIsDown.
 *
 *----------------------------------------------------------------------
 */

ENTRY void
RpcHostDead(spriteID)
    int spriteID;
{
    register Hash_Entry *hashPtr;
    register RecovHostState *hostPtr;

    LOCK_MONITOR;
    if (spriteID == NET_BROADCAST_HOSTID || rpc_NoTimeouts) {
	/*
	 * If rpcNoTimeouts is set the Rpc_Daemon may still call us if
	 * it can't get an acknowledgment from a host to close down
	 * a connection.  We ignore this so that we don't take action
	 * against the offending host (who is probably in the debugger)
	 */
	UNLOCK_MONITOR;
	return;
    }

    hashPtr = Hash_LookOnly(recovHashTable, spriteID);
    if (hashPtr != (Hash_Entry *)NIL) {
	hostPtr = (RecovHostState *)hashPtr->value;
	if (hostPtr != (RecovHostState *)NIL) {
	    switch(hostPtr->state & ~(RECOV_CRASH_CALLBACKS|
				      RECOV_HOST_PINGING)) {
		case RECOV_HOST_DEAD:
		    /*
		     * Host already dead.
		     */
		    break;
		case RECOV_STATE_UNKNOWN:
		case RECOV_HOST_ALIVE:
		    hostPtr->state &= ~(RECOV_HOST_ALIVE|RECOV_STATE_UNKNOWN);
		    hostPtr->state |= RECOV_HOST_DEAD|RECOV_CRASH_CALLBACKS;
		    Rpc_HostPrint(spriteID, "is down");
		    RECOV_TRACE(spriteID, hostPtr->state, RECOV_CUZ_CRASH);
		    Proc_CallFunc(RpcCrashCallBacks, spriteID, 0);
		    break;
	    }
	}
    }
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * RpcRebootCallBacks --
 *
 *	This calls the call-back procedures installed by other modules
 *	via Rpc_HostNotify.  It is invoked asynchronously from RpcHostAlive
 *	when that procedure detects a reboot.  It does an explict ping
 *	of the other host to make sure it is ready for our recovery actions.
 *	This will reschedule itself for later if the host isn't ready.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Invoke the call-backs.
 *
 *----------------------------------------------------------------------
 */

void
RpcRebootCallBacks(data, callInfoPtr)
    ClientData data;
    Proc_CallInfo *callInfoPtr;
{
    ReturnStatus status;
    register NotifyElement *notifyPtr;
    register int spriteID = (int)data;

    status = Rpc_Ping(spriteID);
    switch(status) {
	case RPC_SERVICE_DISABLED:
	    Rpc_HostPrint(spriteID, "still booting");
	    callInfoPtr->interval = rpcRecoveryPause * timer_IntOneSecond;
	    break;
	case RPC_TIMEOUT:
	    Rpc_HostPrint(spriteID, "not responding");
	    callInfoPtr->interval = rpcRecoveryPause * timer_IntOneSecond;
	    break;
	case SUCCESS:
	    LIST_FORALL(&rpcNotifyList, (List_Links *)notifyPtr) {
		if (notifyPtr->flags & RPC_WHEN_HOST_REBOOTS) {
		    (*notifyPtr->proc)(spriteID, notifyPtr->clientData,
						 RPC_WHEN_HOST_REBOOTS);
		 }
	    }
	    RECOV_TRACE(spriteID, RECOV_REBOOT, RECOV_CUZ_DONE);
	    callInfoPtr->interval = 0;	/* Don't call again */
	    break;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * RpcCrashCallBacks --
 *
 *	Invoked asynchronously from RpcHostDead so that other modules
 *	can clean up behind the crashed host.  When done the host
 *	is marked as having recovery complete.  This unblocks server
 *	processes stalled in RpcHostAlive.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Invoke the call-backs with the RPC_WHEN_HOST_DOWN flag.
 *	Clears the recovery in progress flag checked in RpcHostAlive.
 *
 *----------------------------------------------------------------------
 */

void
RpcCrashCallBacks(data, callInfoPtr)
    ClientData data;
    Proc_CallInfo *callInfoPtr;
{
    register NotifyElement *notifyPtr;
    register int spriteID = (int)data;

    LIST_FORALL(&rpcNotifyList, (List_Links *)notifyPtr) {
	if (notifyPtr->flags & RPC_WHEN_HOST_DOWN) {
	    (*notifyPtr->proc)(spriteID, notifyPtr->clientData,
					 RPC_WHEN_HOST_DOWN);
	 }
    }
    MarkRecoveryComplete(spriteID);
    RECOV_TRACE(spriteID, RECOV_CRASH, RECOV_CUZ_DONE);
    callInfoPtr->interval = 0;	/* Don't call again */
}

/*
 *----------------------------------------------------------------------
 *
 * MarkRecoveryComplete --
 *
 *	The recovery call-backs have completed, and this procedure's
 *	job is to mark that fact in the host hash table and to notify
 *	any processes that are blocked in RpcHostAlive waiting for this.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sets the state, if any, in the host state table.
 *	Notifies the hostPtr->recovery condition
 *
 *----------------------------------------------------------------------
 */

ENTRY static void
MarkRecoveryComplete(spriteID)
{
    register Hash_Entry *hashPtr;
    register RecovHostState *hostPtr;

    LOCK_MONITOR;

    hashPtr = Hash_LookOnly(recovHashTable, spriteID);
    if (hashPtr != (Hash_Entry *)NIL) {
	hostPtr = (RecovHostState *)hashPtr->value;
	if (hostPtr != (RecovHostState *)NIL) {
	    hostPtr->state &= ~RECOV_CRASH_CALLBACKS;
	    Sync_Broadcast(&hostPtr->recovery);
	}
    }
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * GetHostState --
 *
 *	This looks into	the host table to see and provides a guess
 *	as to the host's current state.  It uses a timestamp kept in
 *	the host state to see if there's been recent message traffic.
 *	If so, RECOV_HOST_ALIVE is returned.  If not, RECOV_STATE_UNKNOWN
 *	is returned and the caller should ping to make sure.  Finally,
 *	if it is known that the host is down already, then RECOV_HOST_DEAD
 *	is returned.
 *
 * Results:
 *	RECOV_STATE_UNKNOWN if the caller should ping to make sure.
 *	RECOV_HOST_ALIVE if the host is up (recent message traffic).
 *	RECOV_HOST_DEAD if the host is down (recent timeouts).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ENTRY int
GetHostState(spriteID)
    int spriteID;
{
    register Hash_Entry *hashPtr;
    register RecovHostState *hostPtr;
    register int state = RECOV_STATE_UNKNOWN;
    Time time;

    LOCK_MONITOR;

    hashPtr = Hash_LookOnly(recovHashTable, spriteID);
    if (hashPtr != (Hash_Entry *)NIL) {
	hostPtr = (RecovHostState *)hashPtr->value;
	if (hostPtr != (RecovHostState *)NIL) {
	    state = hostPtr->state &
		    ~(RECOV_CRASH_CALLBACKS|RECOV_HOST_PINGING);
	    if (state == RECOV_HOST_ALIVE) {
		/*
		 * Check for recent message traffic before admitting
		 * that the other machine is up.
		 */
		Timer_GetTimeOfDay(&time, (int *)NIL, (Boolean *)NIL);
		Time_Subtract(time, hostPtr->time, &time);
		if (Time_GT(time, time_TenSeconds)) {
		    state = RECOV_STATE_UNKNOWN;
		}
	    }
	}
    }
    UNLOCK_MONITOR;
    return(state);
}

/*
 *----------------------------------------------------------------------
 *
 * StartPinging --
 *
 *	Make sure there is a background pinging process for the host.
 *	The state bit used to indicate pinging is reset by RpcHostCheck
 *	after it finally gets in a good ping.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Starts the pinging callback if not already in progress.
 *
 *----------------------------------------------------------------------
 */

ENTRY void
StartPinging(spriteID)
    int spriteID;
{
    register Hash_Entry *hashPtr;
    register RecovHostState *hostPtr;

    LOCK_MONITOR;

    hashPtr = Hash_LookOnly(recovHashTable, spriteID);
    hostPtr = (RecovHostState *)hashPtr->value;
    if ((hostPtr->state & RECOV_HOST_PINGING) == 0) {
	hostPtr->state |= RECOV_HOST_PINGING;
	Proc_CallFunc(CheckHost, spriteID, 0);
    }
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * CheckHost --
 *
 *	This is the call back setup when a host is detected as crashed
 *	and we want to find out when it comes back up.  This pings
 *	the remote host if it's down or there hasn't been recent traffic.
 *	A side effect of a successful ping is a call to RpcHostAlive which
 *	triggers the recovery actions.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	This will pings the host unless there has been recent message
 *	traffic.  It reschedules itself if the ping fails.
 *
 *----------------------------------------------------------------------
 */

static void
CheckHost(data, callInfoPtr)
    ClientData data;
    Proc_CallInfo *callInfoPtr;
{
    register int spriteID = (int)data;
    register int state;
    ReturnStatus status = SUCCESS;

    state = GetHostState(spriteID);
    switch (state) {
	case RECOV_HOST_DEAD:
	case RECOV_STATE_UNKNOWN:
	    RECOV_TRACE(spriteID, state, RECOV_CUZ_PING_CHK);
	    status = Rpc_Ping(spriteID);
	    break;
	case RECOV_HOST_ALIVE:
	    break;
    }
    if (status != SUCCESS) {
	/*
	 * Try again later if the host is still down.
	 */
	callInfoPtr->interval = rpcPingSeconds * timer_IntOneSecond;
    } else {
	StopPinging(spriteID);
	callInfoPtr->interval = 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * StartPinging --
 *
 *	Make sure there is a background pinging process for the host.
 *	The state bit used to indicate pinging is reset by RpcHostCheck
 *	after it finally gets in a good ping.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Starts the pinging callback if not already in progress.
 *
 *----------------------------------------------------------------------
 */

ENTRY void
StopPinging(spriteID)
    int spriteID;
{
    register Hash_Entry *hashPtr;
    register RecovHostState *hostPtr;

    LOCK_MONITOR;

    hashPtr = Hash_LookOnly(recovHashTable, spriteID);
    hostPtr = (RecovHostState *)hashPtr->value;
    if ((hostPtr->state & RECOV_HOST_PINGING) == 0) {
	Sys_Panic(SYS_WARNING, "StopPinging found bad state\n");
    }
    hostPtr->state &= ~RECOV_HOST_PINGING;
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * Rpc_PrintRecovTraceRecord --
 *
 *	Format and print the client data part of a recovery trace record.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sys_Printf to the display.
 *
 *----------------------------------------------------------------------
 */
int
Rpc_PrintRecovTraceRecord(clientData, event, printHeaderFlag)
    ClientData clientData;	/* Client data in the trace record */
    int event;			/* Type, or event, from the trace record */
    Boolean printHeaderFlag;	/* If TRUE, a header line is printed */
{
    RpcRecovTraceRecord *recPtr = (RpcRecovTraceRecord *)clientData;
    char *name;
    if (printHeaderFlag) {
	/*
	 * Print column headers and a newline.
	 */
	Sys_Printf("%10s %10s %17s\n", "Host", "State", "Event ");
    }
    if (clientData != (ClientData)NIL) {
	Net_SpriteIDToName(recPtr->spriteID, &name);
	if (name == (char *)NIL) {
	    Sys_Printf("%10d ", recPtr->spriteID);
	} else {
	    Sys_Printf("%10s ", name);
	}
	switch(recPtr->state & ~(RECOV_CRASH_CALLBACKS|RECOV_HOST_PINGING)) {
	    case RECOV_STATE_UNKNOWN:
		Sys_Printf("%-8s", "Unknown");
		break;
	    case RECOV_HOST_ALIVE:
		Sys_Printf("%-8s ", "Alive");
		break;
	    case RECOV_HOST_DEAD:
		Sys_Printf("%-8s ", "Dead");
		break;
	    case RECOV_WAITING:
		Sys_Printf("%-8s ", "Waiting");
		break;
	    case RECOV_CRASH:
		Sys_Printf("%-8s ", "Crash callbacks");
		break;
	    case RECOV_REBOOT:
		Sys_Printf("%-8s ", "Reboot callbacks");
		break;
	}
	Sys_Printf("%3s", (recPtr->state & RECOV_CRASH_CALLBACKS) ?
			    " C " : "   ");
	Sys_Printf("%3s", (recPtr->state & RECOV_HOST_PINGING) ?
			    " P " : "   ");
	switch(event) {
	    case RECOV_CUZ_WAIT:
		Sys_Printf("waiting");
		break;
	    case RECOV_CUZ_WAKEUP:
		Sys_Printf("wakeup");
		break;
	    case RECOV_CUZ_INIT:
		Sys_Printf("init");
		break;
	    case RECOV_CUZ_REBOOT:
		Sys_Printf("reboot");
		break;
	    case RECOV_CUZ_CRASH:
		Sys_Printf("crash");
		break;
	    case RECOV_CUZ_DONE:
		Sys_Printf("done");
		break;
	    case RECOV_CUZ_PING_ASK:
		Sys_Printf("ping (ask)");
		break;
	    case RECOV_CUZ_PING_CHK:
		Sys_Printf("ping (check)");
		break;
	    case RPC_RECOV_TRACE_STALE:
		Sys_Printf("stale FS handle");
		break;
	    default:
		Sys_Printf("(%x)", event);
		break;
	}
	/* Our caller prints a newline */
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Rpc_PrintRecovTrace --
 *
 *	Dump out the recovery trace.  Called via a console L1 keystroke.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Prints to the console.
 *
 *----------------------------------------------------------------------
 */

void
Rpc_PrintRecovTrace(numRecs)
    int numRecs;
{
    if (numRecs <= 0 || numRecs > rpcRecovTraceLength) {
	numRecs = rpcRecovTraceLength;
    }
    Sys_Printf("RECOVERY TRACE\n");
    Trace_Print(rpcRecovTraceHdrPtr, numRecs, Rpc_PrintRecovTraceRecord);
}


@


8.0
log
@Changing version numbers.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: /sprite/src/kernel/rpc/RCS/rpcRecovery.c,v 6.0 88/08/11 12:25:38 brent Stable Locker: douglis $ SPRITE (Berkeley)";
@


6.0
log
@Changing version numbers.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: rpcRecovery.c,v 5.9 87/10/08 10:51:35 brent Exp $ SPRITE (Berkeley)";
@


5.9
log
@Moving this to it's own module
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: rpcRecovery.c,v 5.8 87/10/04 16:00:38 brent Exp $ SPRITE (Berkeley)";
@


5.8
log
@Inserted pause before recovery callbacks.  Changed Rpc_HostIsDown to
return status's so the caller can tell if the peer host has its
RPC service disabled.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: rpcRecovery.c,v 5.7 87/10/01 14:30:41 brent Exp $ SPRITE (Berkeley)";
@


5.7
log
@Fixed pinging.
@
text
@d24 1
a24 1
static char rcsid[] = "$Header: rpcRecovery.c,v 5.6 87/09/29 14:22:56 brent Exp $ SPRITE (Berkeley)";
a35 2
extern Boolean rpcNoTimeouts;

d72 1
d84 1
d97 8
d256 4
a259 1
 *	out if it's still up.
d262 3
a264 1
 *	TRUE is the host is apparently down.
d273 1
a273 1
Boolean
d279 1
a279 2
    register Boolean down = FALSE;
    register ReturnStatus status;
d283 1
a283 1
	return(FALSE);
a288 3
	    if (status != SUCCESS) {
		down = TRUE;
	    }
d291 1
d294 1
a294 1
	    down = TRUE;
d297 1
a297 1
    if (down && ping) {
d300 1
a300 1
    return(down);
d331 1
a331 1
    if (Rpc_HostIsDown(spriteID, TRUE)) {
d676 1
d678 5
a682 1
		 * Notify interested parties that the host is up.
d685 4
a688 1
		    Rpc_HostPrint(spriteID, "is now up");
d693 1
a693 1
		Proc_CallFunc(RpcRebootCallBacks, spriteID, 0);
d735 1
a735 2
    if (spriteID == NET_BROADCAST_HOSTID ||
	rpcNoTimeouts) {
d778 3
a780 1
 *	when that procedure detects a reboot.
d796 1
d800 20
a819 5
    LIST_FORALL(&rpcNotifyList, (List_Links *)notifyPtr) {
	if (notifyPtr->flags & RPC_WHEN_HOST_REBOOTS) {
	    (*notifyPtr->proc)(spriteID, notifyPtr->clientData,
					 RPC_WHEN_HOST_REBOOTS);
	 }
a820 2
    RECOV_TRACE(spriteID, RECOV_REBOOT, RECOV_CUZ_DONE);
    callInfoPtr->interval = 0;	/* Don't call again */
@


5.6
log
@Added a ping count to the host state to suppress excess pings.
@
text
@d4 3
a6 1
 *	The routines here monitor other hosts on behalf interested parties.
d8 6
a13 5
 *	the state of other hosts.  RpcHostAlive is the main internal
 *	entry point.  It is called when a message arrives from another host.
 *	Rpc_RebootNotify is used to arrange a call-back when a host reboots.
 *	Rpc_WaitForHost is used to block a process until a host comes back up.
 *	Rpc_HostIdDown is a boolean function that's TRUE if the host is down.
d15 1
a15 1
 *	The impact of these recovery hooks on the RPC system is that service
d24 1
a24 1
static char rcsid[] = "$Header: rpcRecovery.c,v 5.5 87/09/23 15:22:03 brent Exp $ SPRITE (Berkeley)";
d33 1
d36 2
d40 4
a43 3
 * The host state records if the host is up or down, keeps a boot time stamp
 * so you can watch for reboots, and includes a
 * condition variable to notify when the host's state changes.
a53 1
    int			numPings;	/* Number ping callbacks scheduled */
d69 6
a74 3
 *	RECOV_STATE_RECOVERING	Set when the boot time stamp of a peer host
 *				changes, or the host appears down.  Reset
 *				when the recovery actions have completed.
d83 2
a84 1
#define RECOV_STATE_RECOVERING	0x0100
d91 1
a91 1
 * A host is "pinged" when it goes down, at an interval determined by
d98 4
a101 1
 * The following list structure is used to keep these.
d122 3
a124 1
 * Tracing events, these describe the trace record.
d131 2
a132 1
 *	RECOV_CUZ_PING		We are pinging the host
d140 2
a141 1
#define RECOV_CUZ_PING		0x40
a164 1
void RpcHostCheck();
a166 1
void MarkHostDead();
d168 4
d239 57
d321 1
a321 1
    if (Rpc_HostIsDown(spriteID)) {
d335 3
a337 2
 *	the given host comes back up.  This is used when retrying
 *	filesystem operations when a fileserver goes down, for example.
a363 4
    /*
     * Make sure the host table entry exists, then mark the host down.
     * That triggers a backgound pinging to detect when the host comes up.
     */
d366 3
a368 5
	hashPtr->value = (Address)Mem_Alloc(sizeof(RecovHostState));
	hostPtr = (RecovHostState *)hashPtr->value;
	hostPtr->state = RECOV_STATE_UNKNOWN;
	hostPtr->spriteID = spriteID;
	hostPtr->bootID = 0;
d384 148
d537 4
a540 3
 *	but we though the host was up then the Crash call-backs are invoked.
 *	Otherwise a reboot just invokes the Reboot call-backs.  All call-backs
 *	are installed with Rpc_RebootNotify.
d542 9
a550 4
 *	RPC Server processes are blocked in this procedure if they
 *	trigger the Crash call-backs, or if the Crash call-backs are
 *	in progress.  This prevents servicing requests from clients
 *	until the crash recovery actions have completed.
d557 3
a559 1
 *	with Rpc_RebootNotify are called when the bootID changes.
d570 1
a570 1
				 * to wait until the recovery is complete. */
d574 1
a574 2
    char *name;
    Boolean reboot = FALSE;
d577 1
a577 2
    if (spriteID == NET_BROADCAST_HOSTID ||
	bootID == 0) {
d591 2
a592 3
	 * Initialize the host's state.
	 * This is the first time we've talked to it since we've been up,
	 * so take no action.
d594 2
d597 1
a597 2
	hashPtr->value = (Address)Mem_Alloc(sizeof(RecovHostState));
	hostPtr = (RecovHostState *)hashPtr->value;
d601 2
a602 6
	Net_SpriteIDToName(spriteID, &name);
	if (name == (char *)NIL) {
	    Sys_Printf("Sprite Host <%d> is up\n", spriteID);
	} else {
	    Sys_Printf("Sprite Host %s (%d) is up\n", name, spriteID);
	}
d610 1
a610 1
	 * see Rpc_HostIsDown.
a612 1

a615 2
	 * Subsequent (server) processes are blocked during this time unless
	 * they (clients) specify asynchronous recovery.
a616 1

d618 1
a618 8
	    Net_SpriteIDToName(spriteID, &name);
	    if (name == (char *)NIL) {
		Sys_Printf("Sprite Host <%d> rebooted %d->%d\n", spriteID,
			hostPtr->bootID, bootID);
	    } else {
		Sys_Printf("Sprite Host %s (%d) rebooted %d->%d\n", name,
			hostPtr->spriteID, hostPtr->bootID, bootID);
	    }
d626 1
a626 1
		 * RECOV_STATE_RECOVERING flag is reset by RpcCrashCallBacks.
d631 2
a632 1
		hostPtr->state = RECOV_HOST_DEAD | RECOV_STATE_RECOVERING;
a635 1

d643 1
a643 1
	    while (hostPtr->state & RECOV_STATE_RECOVERING) {
d652 3
a654 4
	 * Now that we've taken care of reboot recovery,
	 * we see if the host is newly up.  If so, invoke the reboot
	 * call-backs and then notify waiting processes.
	 * This means clientA (us) may start
d656 2
a657 1
	 * as clientA is closing files that serverB had had open.
d659 1
a659 1
	switch(hostPtr->state & ~RECOV_STATE_RECOVERING) {
a668 2
		char *name;
		Net_SpriteIDToName(spriteID, &name);
d670 1
a670 6
		    if (name == (char *)NIL) {
			Sys_Printf("Sprite Host <%d> is now up\n", spriteID);
		    } else {
			Sys_Printf("Sprite Host %s (%d) is now up\n", name,
				    spriteID);
		    }
d672 2
a673 1
		hostPtr->state = RECOV_HOST_ALIVE;
d678 3
a680 2
		Sys_Panic(SYS_WARNING, "Unexpected state <%x> for host %d\n",
			hostPtr->state, spriteID);
d691 66
d760 1
a760 1
 *	via Rpc_RebootNotify.  It is invoked asynchronously from RpcHostAlive
d797 1
a797 1
 *	is marked as having recovery complete.  This unblock server
d860 1
a860 1
	    hostPtr->state &= ~RECOV_STATE_RECOVERING;
d870 1
a870 1
 * RpcHostDead --
d872 7
a878 1
 *	Change the host's state to "dead".
d881 3
a883 1
 *	None.
d886 1
a886 1
 *	Sets the state, if any, in the host state table.
d891 2
a892 2
ENTRY void
RpcHostDead(spriteID)
d897 2
a900 4
    if (spriteID == NET_BROADCAST_HOSTID) {
	UNLOCK_MONITOR;
	return;
    }
d906 13
a918 1
	    MarkHostDead(hostPtr);
d922 1
d928 1
a928 1
 * MarkHostDead --
d930 3
a932 2
 *	Mark the host as down and call-back to other modules.  This
 *	also set up a background pinging process to detect reboot.
d938 1
a938 1
 *	Sets the state in the host state table, starts RpcHostCheck callback.
d943 3
a945 3
INTERNAL static void
MarkHostDead(hostPtr)
    RecovHostState *hostPtr;
d947 10
a956 25
    char *name;
    switch(hostPtr->state) {
	case RECOV_HOST_DEAD:
	    /*
	     * Host already dead.
	     */
	    break;
	case RECOV_STATE_UNKNOWN:
	case RECOV_HOST_ALIVE:
	    hostPtr->state = RECOV_HOST_DEAD;
	    Net_SpriteIDToName(hostPtr->spriteID, &name);
	    if (name == (char *)NIL) {
		Sys_Printf("Sprite Host <%d> is down\n", hostPtr->spriteID);
	    } else {
		Sys_Printf("Sprite Host %s (%d) is down\n", name,
			    hostPtr->spriteID);
	    }
	    RECOV_TRACE(hostPtr->spriteID, hostPtr->state, RECOV_CUZ_CRASH);
	    if (hostPtr->numPings <= 0) {
		Proc_CallFunc(RpcHostCheck, hostPtr->spriteID, 0);
		hostPtr->numPings = 1;
	    }
	    hostPtr->state |= RECOV_STATE_RECOVERING;
	    Proc_CallFunc(RpcCrashCallBacks, hostPtr->spriteID, 0);
	    break;
d958 1
d964 1
a964 1
 * RpcHostCheck --
d966 5
a970 4
 *	This is the call back setup when a process blocks on a down host.
 *	This simply pings the remote host and lets the RpcHostAlive
 *	call from Rpc_Call take care of triggering the wakeups of
 *	processes blocked on the host.
d976 2
a977 1
 *	This will ping the host.
d982 2
a983 2
void
RpcHostCheck(data, callInfoPtr)
d988 2
a989 1
    ReturnStatus status;
d991 11
a1001 3
    RECOV_TRACE(spriteID, RECOV_STATE_UNKNOWN, RECOV_CUZ_PING);
    IncPings(spriteID, -1);
    if (Rpc_Ping(spriteID) != SUCCESS) {
a1005 1
	IncPings(spriteID, 1);
d1007 1
d1015 1
a1015 1
 * Rpc_HostIsDown --
d1017 3
a1019 4
 *	This decides if the specified host is down.  It will look into
 *	the host table to see if there aren't already processes waiting
 *	for the host to reboot.  If that is not the case and explicit
 *	ping is done to see if the host is still up.
a1021 54
 *	TRUE is the host is apparently down.
 *
 * Side effects:
 *	May do a ping.
 *
 *----------------------------------------------------------------------
 */

ENTRY Boolean
Rpc_HostIsDown(spriteID)
    int spriteID;
{
    register Boolean down = FALSE;
    register ReturnStatus status;

    if (spriteID == NET_BROADCAST_HOSTID) {
	Sys_Panic(SYS_WARNING, "Rpc_HostIsDown, got broadcast address\n");
	return(FALSE);
    }
    switch (GetHostState(spriteID)) {
	case RECOV_STATE_UNKNOWN:
	    status = Rpc_Ping(spriteID);
	    if (status != SUCCESS) {
		down = TRUE;
	    }
	    break;
	case RECOV_HOST_ALIVE:
	    break;
	case RECOV_HOST_DEAD:
	    down = TRUE;
	    break;
    }
    return(down);
}

/*
 *----------------------------------------------------------------------
 *
 * GetHostState --
 *
 *	This looks into	the host table to see and provides a guess
 *	as to the host's current state.  It uses a timestamp kept in
 *	the host state to see if there's been recent message traffic.
 *	If so, RECOV_HOST_ALIVE is returned.  If not, RECOV_STATE_UNKNOWN
 *	is returned and the caller should ping to make sure.  Finally,
 *	if it is known that the host is down already, then RECOV_HOST_DEAD
 *	is returned.
 *
 * Results:
 *	RECOV_STATE_UNKNOWN if the caller should ping to make sure.
 *	RECOV_HOST_ALIVE if the host is up (recent message traffic).
 *	RECOV_HOST_DEAD if the host is down (recent timeouts).
 *
 * Side effects:
a1023 47
 *----------------------------------------------------------------------
 */

ENTRY int
GetHostState(spriteID)
    int spriteID;
{
    register Hash_Entry *hashPtr;
    register RecovHostState *hostPtr;
    register int state = RECOV_STATE_UNKNOWN;
    Time time;

    LOCK_MONITOR;

    hashPtr = Hash_LookOnly(recovHashTable, spriteID);
    if (hashPtr != (Hash_Entry *)NIL) {
	hostPtr = (RecovHostState *)hashPtr->value;
	if (hostPtr != (RecovHostState *)NIL) {
	    state = hostPtr->state & ~RECOV_STATE_RECOVERING;
	    if (state == RECOV_HOST_ALIVE) {
		/*
		 * Check for recent message traffic before admitting
		 * that the other machine is up.
		 */
		Timer_GetTimeOfDay(&time, (int *)NIL, (Boolean *)NIL);
		Time_Subtract(time, hostPtr->time, &time);
		if (Time_GT(time, time_TenSeconds)) {
		    state = RECOV_STATE_UNKNOWN;
		}
	    }
	}
    }
    UNLOCK_MONITOR;
    return(state);
}

/*
 *----------------------------------------------------------------------
 *
 * IncPings --
 *
 *	Increment (decrement) the number of pings that are scheduled
 *	for a host.
 *
 * Results:
 *	None.
 *
d1025 1
a1025 1
 *	Adds the increment paramenter to hostPtr->numPings.
d1030 2
a1031 2
ENTRY int
IncPings(spriteID, increment)
a1032 1
    int increment;
d1040 3
a1042 5
    if (hashPtr != (Hash_Entry *)NIL) {
	hostPtr = (RecovHostState *)hashPtr->value;
	if (hostPtr != (RecovHostState *)NIL) {
	    hostPtr->numPings += increment;
	}
d1044 1
d1084 1
a1084 1
	switch(recPtr->state & ~RECOV_STATE_RECOVERING) {
d1104 4
a1107 2
	Sys_Printf("%3s", (recPtr->state & RECOV_STATE_RECOVERING) ?
			    " R " : "   ");
d1127 8
a1134 2
	    case RECOV_CUZ_PING:
		Sys_Printf("ping");
@


5.5
log
@Makde RpcHostAlive ignore zero valued server bootIDs.
This is because they can arise if there is an error
in RpcOutput and nothing ever gets sent.
@
text
@d21 1
a21 1
static char rcsid[] = "$Header: rpcRecovery.c,v 5.4 87/09/21 16:26:08 brent Exp $ SPRITE (Berkeley)";
d47 1
d461 7
a467 5
		if (name == (char *)NIL) {
		    Sys_Printf("Sprite Host <%d> is now up\n", spriteID);
		} else {
		    Sys_Printf("Sprite Host %s (%d) is now up\n", name,
				spriteID);
d674 4
a677 1
	    Proc_CallFunc(RpcHostCheck, hostPtr->spriteID, 0);
d712 1
d718 1
d825 37
@


5.4
log
@Added tracing
@
text
@d21 1
a21 1
static char rcsid[] = "$Header: rpcRecovery.c,v 5.3 87/09/16 11:47:59 brent Exp $ SPRITE (Berkeley)";
d350 8
a357 1
    if (spriteID == NET_BROADCAST_HOSTID) {
@


5.3
log
@Updated the recovery support, reboots, crashes, and boots detected.
@
text
@d21 1
a21 1
static char rcsid[] = "$Header: rpcRecovery.c,v 5.2 87/09/11 09:54:39 brent Exp $ SPRITE (Berkeley)";
d30 1
d43 1
d65 3
a71 1
#define RECOV_STATE_RECOVERING	0x10
d73 6
d100 45
d175 2
a191 1
 *
d226 1
a226 1
 *	None.
d234 1
a234 1
ENTRY Boolean
d238 36
d276 1
a276 1
    Boolean sigPending;
d278 2
d281 2
a282 1
	Sys_Panic(SYS_FATAL, "Rpc_WaitForHost, bad hostID %d\n", spriteID);
a284 1
    LOCK_MONITOR;
d300 4
a303 1
    MarkHostDead(hostPtr);
a304 2
    sigPending = Sync_Wait(&hostPtr->alive, TRUE);

d349 1
d351 1
a353 1
    LOCK_MONITOR;
d372 1
a372 1
	    Sys_Printf("Sprite Host %s is up\n", name);
d374 1
d398 2
a399 2
		Sys_Printf("Sprite Host %s rebooted %d->%d\n", name,
			hostPtr->bootID, bootID);
d403 1
d412 1
d456 2
a457 1
		    Sys_Printf("Sprite Host %s is now up\n", name);
d505 1
d544 1
d609 1
d611 1
a613 1
    LOCK_MONITOR;
d660 2
a661 1
		Sys_Printf("Sprite Host %s is down\n", name);
d663 1
d698 1
d811 117
@


5.2
log
@Redo of RpcHostAlive so it takes care of everything,
including detecting reboots and invoking the recovery procedures.
It also blocks server processes from handling requests until
the recovery procedures have completed.
@
text
@d21 1
a21 1
static char rcsid[] = "$Header: rpcRecovery.c,v 5.1 87/09/09 10:48:36 brent Exp $ SPRITE (Berkeley)";
d83 1
d93 2
a94 1
void RpcRecovCallBacks();
d125 1
a125 1
 * Rpc_RebootNotify --
d127 8
a134 2
 *	Add the given function and client data to the list of call backs when
 *	clients reboot.
d145 1
a145 1
Rpc_RebootNotify(proc, clientData)
d148 1
d155 1
d220 5
a224 8
 *	a message from the host.  This uses the boot timestamp of the
 *	other host to catch reboots.  If no processes are waiting on
 *	the hosts recovery, and the bootID doesn't indicate a reboot,
 *	this procedure does no work.  Upon reboot a set of call-backs
 *	are made to clients of the RPC system.  These are done
 *	synchronously by the process calling this procedure, or by a
 *	background helper process.  Finally, there may be processes
 *	blocked on the host's recovery, and they'll get notified.
d226 5
d251 2
a260 1
	char *name;
d296 8
a303 1
	    hostPtr->state |= RECOV_STATE_RECOVERING;
d305 12
a316 4
	    Proc_CallFunc(RpcRecovCallBacks, spriteID, 0);
	    /*
	     * The RECOV_STATE_RECOVERING flag is reset by RpcRecovCallBacks.
	     */
d318 7
a325 6
	    /*
	     * Block servers until recovery actions complete.
	     * Servers are synchronous with respect to reboot recovery.
	     * This blocks requests from clients until after the
	     * recovery actions complete.
	     */
d336 3
a338 2
	 * we see if the host is newly up.  If so, we notify
	 * waiting processes.  This means clientA (us) may start
d361 1
d376 1
a376 1
 * RpcRecovCallBacks --
d392 1
a392 1
RpcRecovCallBacks(data, callInfoPtr)
d400 4
a403 1
	(*notifyPtr->proc)(spriteID, notifyPtr->clientData);
d405 37
d527 2
a528 2
 *	Mark the host as down and set up a background pinging process
 *	to detect its reboot.
d560 2
d591 1
d593 8
a600 2
    (void)Rpc_Ping(spriteID);
    callInfoPtr->interval = rpcPingSeconds * timer_IntOneSecond;
@


5.1
log
@Cleaned up some lint
@
text
@d5 6
a10 6
 *	Another kernel module (eg. fs) can ask the rpc system to block
 *	the current process until a particular host reboots.  Regular message
 *	traffic plus explicit pings are used to determine the state
 *	of other hosts.
 *	There are also entry points for the rest of the RPC system for
 *	updating the current state of other hosts (RpcHostAlive, RpcHostDead).
d12 4
d21 1
a21 1
static char rcsid[] = "$Header: rpcRecovery.c,v 5.0 87/09/04 02:22:34 brent Exp $ SPRITE (Berkeley)";
d32 4
a35 1
 * A list of waiters is kept hanging off a hash by host ID
a36 8
Sync_Lock rpcRecoveryLock;
#define LOCKPTR (&rpcRecoveryLock)

/*
 * The hash table.  Each hash table entry references some "host state".
 * The host state records if the host is up or down, and includes a
 * list of conditionPtrs to notify when the state changes.
 */
d41 6
a46 2
    List_Links		waitList;
    int			state;
d50 6
d60 3
a62 2
 *	RECOV_STATE_CHECKED	Set by RpcHostCheck, cleared by RpcHostAlive
 *				and RpcHostDead.  Used to prevent excess pings.
d67 1
a67 1
#define RECOV_STATE_CHECKED	0x8
a68 5
typedef struct RecovWait {
    List_Links		links;
    Sync_Condition	*conditionPtr;
} RecovWait;

d73 18
a90 1
int rpcPingSeconds = 15;
d92 3
d117 1
d123 30
d163 1
a163 1
 *	The current process is blocked on the given condition pointer
d168 2
a169 2
ENTRY void
Rpc_WaitForHost(spriteID, conditionPtr)
a170 1
    Sync_Condition *conditionPtr;	/* Event on which to block */
d174 1
a174 1
    RecovWait *waitPtr;
d177 2
a178 1
	return;
d183 2
a184 3
     * Add the waiter to the list associated with the host.
     * If this is the first interest in the host then a call back
     * is initiated to check up on the host's state.
d188 59
d248 6
a253 1
	
d256 3
a258 4
	hostPtr->state = RECOV_HOST_DEAD;
	List_Init(&hostPtr->waitList);
	Proc_CallFunc(RpcHostCheck, spriteID, 0);

d261 1
a261 1
	    Sys_Printf("Sprite Host <%d> is down\n", spriteID);
d263 1
a263 1
	    Sys_Printf("Sprite Host %s is down\n", name);
d268 6
a273 4
    waitPtr = (RecovWait *)Mem_Alloc(sizeof(RecovWait));
    waitPtr->conditionPtr = conditionPtr;
    List_InitElement((List_Links *) waitPtr);
    List_Insert((List_Links *)waitPtr, LIST_ATREAR(&hostPtr->waitList));
d275 64
d345 1
a345 1
 * RpcHostAlive --
d347 3
a349 4
 *	Mark the host as being alive.  This is called when we've received
 *	a message from the host.  If the host had been thought to be
 *	down, this change to "aliveness" causes the waiting processes
 *	blocked on the host to be notified.
d355 1
a355 2
 *	Will notify the waiters in the waitList
 *	if the host's state changed from down to up.
d360 4
a363 2
ENTRY void
RpcHostAlive(spriteID)
d365 32
a398 1
    register RecovWait *waitPtr;
d406 2
a407 42
	    hostPtr->state &= ~RECOV_STATE_CHECKED;
	    switch(hostPtr->state) {
		case RECOV_STATE_UNKNOWN:
		    /*
		     * Just update state and take no action.  We can't
		     * tell at this point if the host was up or down
		     * previously.
		     */
		    hostPtr->state = RECOV_HOST_ALIVE;
		    break;
		case RECOV_HOST_ALIVE:
		    /*
		     * Host already alive.
		     */
		    break;
		case RECOV_HOST_DEAD: {
		    /*
		     * Notify interested parties that the host is up.
		     */
		    char *name;
		    Net_SpriteIDToName(spriteID, &name);
		    if (name == (char *)NIL) {
			Sys_Printf("Sprite Host <%d> is now up\n", spriteID);
		    } else {
			Sys_Printf("Sprite Host %s is now up\n", name);
		    }
		    hostPtr->state = RECOV_HOST_ALIVE;
		    while (! List_IsEmpty(&hostPtr->waitList)) {
			waitPtr = (RecovWait *)List_First(&hostPtr->waitList);
			Sync_Broadcast(waitPtr->conditionPtr);
			List_Remove((List_Links *)waitPtr);
			Mem_Free(waitPtr);
		    }
		    /*
		     * Wipe out the host state so we don't bother keeping
		     * it up to date now that the host is up.
		     */
		    Mem_Free(hostPtr);
		    hashPtr->value = (Address)NIL;
		    break;
		}
	    }
a418 1
 *	THIS MAY BE USELESS NOW, 6/87
d431 1
d436 3
d445 1
a445 27
	    hostPtr->state &= ~RECOV_STATE_CHECKED;
	    switch(hostPtr->state) {
		case RECOV_STATE_UNKNOWN:
		    /*
		     * Just update state, but don't invoke
		     * the callBacks. We can't tell at this point if the
		     * host was up or down previously.
		     */
		    hostPtr->state = RECOV_HOST_DEAD;
		    break;
		case RECOV_HOST_DEAD:
		    /*
		     * Host already dead.
		     */
		    break;
		case RECOV_HOST_ALIVE: {
		    char *name;
		    Net_SpriteIDToName(spriteID, &name);
		    if (name == (char *)NIL) {
			Sys_Printf("Sprite Host <%d> is down\n", spriteID);
		    } else {
			Sys_Printf("Sprite Host %s is down\n", name);
		    }
		    hostPtr->state = RECOV_HOST_DEAD;
		    break;
		}
	    }
d454 42
d549 14
a562 6
    if (RpcHostIsDownInt(spriteID)) {
	down = TRUE;
    } else {
	status = Rpc_Ping(spriteID);
	if (status != SUCCESS) {
	    Sys_Printf("Rpc_Ping, host %d is down: %x\n", spriteID, status);
d564 1
a564 1
	}
d572 1
a572 1
 * RpcHostIsDownInt --
d574 7
a580 3
 *	This looks into
 *	the host table to see if there aren't already processes waiting
 *	for the host to reboot.
d583 3
a585 1
 *	TRUE if the host has already been marked down.
d593 2
a594 2
ENTRY Boolean
RpcHostIsDownInt(spriteID)
d599 2
a600 1
    register Boolean down = FALSE;
d608 11
a618 2
	    if (hostPtr->state & RECOV_HOST_DEAD) {
		down = TRUE;
d623 1
a623 1
    return(down);
@


5.0
log
@First Sprite native copy
@
text
@d17 1
a17 1
static char rcsid[] = "$Header: rpcRecovery.c,v 5.0 87/08/11 10:48:58 sprite Exp $ SPRITE (Berkeley)";
a116 1
    Boolean created = FALSE;
a259 1
    register RecovWait *waitPtr;
@
