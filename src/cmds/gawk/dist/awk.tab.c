
/*  A Bison parser, made from awk.y  */

#define	FUNC_CALL	258
#define	NAME	259
#define	REGEXP	260
#define	ERROR	261
#define	NUMBER	262
#define	YSTRING	263
#define	RELOP	264
#define	APPEND_OP	265
#define	ASSIGNOP	266
#define	MATCHOP	267
#define	NEWLINE	268
#define	CONCAT_OP	269
#define	LEX_BEGIN	270
#define	LEX_END	271
#define	LEX_IF	272
#define	LEX_ELSE	273
#define	LEX_RETURN	274
#define	LEX_DELETE	275
#define	LEX_WHILE	276
#define	LEX_DO	277
#define	LEX_FOR	278
#define	LEX_BREAK	279
#define	LEX_CONTINUE	280
#define	LEX_PRINT	281
#define	LEX_PRINTF	282
#define	LEX_NEXT	283
#define	LEX_EXIT	284
#define	LEX_FUNCTION	285
#define	LEX_GETLINE	286
#define	LEX_IN	287
#define	LEX_AND	288
#define	LEX_OR	289
#define	INCREMENT	290
#define	DECREMENT	291
#define	LEX_BUILTIN	292
#define	LEX_LENGTH	293
#define	UNARY	294

#line 26 "awk.y"

#ifdef DEBUG
#define YYDEBUG 12
#endif

#include "awk.h"

/*
 * This line is necessary since the Bison parser skeleton uses bcopy.
 * Systems without memcpy should use -DMEMCPY_MISSING, per the Makefile.
 * It should not hurt anything if Yacc is being used instead of Bison.
 */
#define bcopy(s,d,n)	memcpy((d),(s),(n))

extern void msg();
extern struct re_pattern_buffer *mk_re_parse();

NODE *node();
NODE *lookup();
NODE *install();

static NODE *snode();
static NODE *mkrangenode();
static FILE *pathopen();
static NODE *make_for_loop();
static NODE *append_right();
static void func_install();
static NODE *make_param();
static int hashf();
static void pop_params();
static void pop_var();
static int yylex ();
static void yyerror();

static int want_regexp;		/* lexical scanning kludge */
static int want_assign;		/* lexical scanning kludge */
static int can_return;		/* lexical scanning kludge */
static int io_allowed = 1;	/* lexical scanning kludge */
static int lineno = 1;		/* for error msgs */
static char *lexptr;		/* pointer to next char during parsing */
static char *lexptr_begin;	/* keep track of where we were for error msgs */
static int curinfile = -1;	/* index into sourcefiles[] */
static int param_counter;

NODE *variables[HASHSIZE];

extern int errcount;
extern NODE *begin_block;
extern NODE *end_block;

#line 77 "awk.y"
typedef union {
	long lval;
	AWKNUM fval;
	NODE *nodeval;
	NODETYPE nodetypeval;
	char *sval;
	NODE *(*ptrval)();
} YYSTYPE;

#ifndef YYLTYPE
typedef
  struct yyltype
    {
      int timestamp;
      int first_line;
      int first_column;
      int last_line;
      int last_column;
      char *text;
   }
  yyltype;

#define YYLTYPE yyltype
#endif

#define	YYACCEPT	return(0)
#define	YYABORT	return(1)
#define	YYERROR	goto yyerrlab
#include <stdio.h>

#ifndef __STDC__
#define const
#endif



#define	YYFINAL		298
#define	YYFLAG		-32768
#define	YYNTBASE	61

#define YYTRANSLATE(x) ((unsigned)(x) <= 294 ? yytranslate[x] : 105)

static const char yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,    49,     2,     2,    52,    48,     2,     2,    53,
    54,    46,    44,    60,    45,     2,    47,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,    40,    59,    41,
     2,    42,    39,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    55,     2,    56,    51,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,    57,    43,    58,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
    36,    37,    38,    50
};

static const short yyrline[] = {     0,
   136,   141,   149,   165,   166,   170,   172,   186,   188,   202,
   208,   214,   216,   218,   220,   229,   231,   236,   240,   248,
   257,   259,   268,   270,   281,   286,   291,   293,   301,   303,
   308,   310,   316,   318,   320,   322,   324,   326,   328,   333,
   337,   342,   345,   348,   350,   352,   355,   356,   358,   360,
   362,   364,   369,   371,   376,   381,   388,   390,   395,   397,
   402,   404,   409,   411,   413,   415,   420,   422,   427,   429,
   431,   433,   435,   441,   443,   448,   450,   455,   457,   463,
   465,   467,   469,   474,   476,   481,   483,   489,   491,   493,
   495,   500,   503,   504,   506,   511,   520,   522,   524,   526,
   528,   530,   532,   534,   536,   538,   540,   542,   547,   550,
   551,   553,   555,   564,   566,   568,   570,   572,   574,   576,
   578,   583,   585,   587,   589,   591,   593,   597,   599,   601,
   603,   605,   607,   609,   613,   615,   617,   619,   621,   623,
   625,   627,   632,   634,   639,   641,   643,   648,   652,   656,
   660,   661,   665,   668
};

static const char * const yytname[] = {     0,
"error","$illegal.","FUNC_CALL","NAME","REGEXP","ERROR","NUMBER","YSTRING","RELOP","APPEND_OP",
"ASSIGNOP","MATCHOP","NEWLINE","CONCAT_OP","LEX_BEGIN","LEX_END","LEX_IF","LEX_ELSE","LEX_RETURN","LEX_DELETE",
"LEX_WHILE","LEX_DO","LEX_FOR","LEX_BREAK","LEX_CONTINUE","LEX_PRINT","LEX_PRINTF","LEX_NEXT","LEX_EXIT","LEX_FUNCTION",
"LEX_GETLINE","LEX_IN","LEX_AND","LEX_OR","INCREMENT","DECREMENT","LEX_BUILTIN","LEX_LENGTH","'?'","':'",
"'<'","'>'","'|'","'+'","'-'","'*'","'/'","'%'","'!'","UNARY",
"'^'","'$'","'('","')'","'['","']'","'{'","'}'","';'","','",
"start"
};

static const short yyr1[] = {     0,
    61,    62,    62,    62,    62,    64,    63,    65,    63,    63,
    63,    63,    63,    63,    63,    66,    66,    68,    67,    69,
    70,    70,    72,    71,    73,    73,    74,    74,    74,    74,
    75,    75,    76,    76,    76,    76,    76,    76,    76,    76,
    76,    76,    76,    76,    76,    77,    76,    76,    78,    76,
    76,    76,    79,    79,    80,    80,    81,    81,    82,    82,
    83,    83,    84,    84,    84,    84,    85,    85,    86,    86,
    86,    86,    86,    87,    87,    88,    88,    89,    89,    89,
    89,    89,    89,    90,    90,    91,    91,    91,    91,    91,
    91,    93,    92,    92,    92,    92,    92,    92,    92,    92,
    92,    92,    92,    92,    92,    92,    92,    92,    95,    94,
    94,    94,    94,    94,    94,    94,    94,    94,    94,    94,
    94,    96,    96,    96,    96,    96,    96,    96,    96,    96,
    96,    96,    96,    96,    96,    96,    96,    96,    96,    96,
    96,    96,    97,    97,    98,    98,    98,    99,   100,   101,
   102,   102,   103,   104
};

static const short yyr2[] = {     0,
     3,     1,     2,     1,     2,     0,     3,     0,     3,     2,
     2,     2,     1,     2,     2,     1,     1,     0,     7,     3,
     1,     3,     0,     4,     3,     4,     1,     2,     1,     2,
     1,     2,     2,     2,     3,     1,     6,     8,     8,    10,
     9,     2,     2,     6,     4,     0,     3,     3,     0,     4,
     6,     2,     1,     1,     6,     9,     1,     2,     0,     1,
     0,     2,     0,     2,     2,     2,     0,     1,     1,     3,
     1,     2,     3,     0,     1,     0,     1,     1,     3,     1,
     2,     3,     3,     0,     1,     1,     3,     1,     2,     3,
     3,     0,     4,     5,     4,     3,     3,     3,     3,     1,
     2,     3,     3,     3,     3,     5,     1,     2,     0,     4,
     3,     3,     3,     1,     2,     3,     3,     3,     5,     1,
     2,     2,     3,     4,     4,     1,     4,     2,     2,     2,
     2,     1,     1,     1,     3,     3,     3,     3,     3,     3,
     2,     2,     0,     1,     1,     4,     2,     2,     2,     1,
     0,     1,     1,     2
};

static const short yydefact[] = {    59,
    57,    60,     0,    58,     4,     0,   145,   133,   134,     6,
     8,    18,   143,     0,     0,     0,   126,     0,     0,    23,
     0,     0,     0,    59,     0,     2,     0,     0,   100,    13,
    21,   107,   132,     0,     0,     0,   153,     0,    10,    31,
    59,     0,    11,     0,    61,   144,   128,   129,     0,     0,
     0,     0,   142,   132,   141,     0,   101,   122,   147,    88,
     0,    86,   148,     5,     3,     1,    15,     0,    12,    14,
     0,     0,     0,     0,     0,     0,     0,     0,     0,    59,
   108,     0,     0,     0,     0,     0,     0,     0,    92,   130,
   131,    29,     0,    49,     0,     0,    59,     0,     0,     0,
    53,    54,    46,    74,    59,     0,    27,     0,    36,     0,
     0,   151,    59,     0,     0,    86,     0,     7,    32,     9,
    17,    16,     0,     0,    96,     0,     0,     0,     0,    89,
   150,     0,     0,   123,     0,   103,    99,   102,    97,    98,
     0,   104,   105,   143,   154,    22,   139,   140,   136,   137,
   138,   135,     0,     0,    74,     0,     0,     0,    74,    42,
    43,     0,     0,    75,   149,    30,    28,   151,    80,   143,
     0,     0,   114,    63,     0,    78,   120,   132,    52,     0,
    34,    25,   152,    33,   127,   146,     0,    62,   124,   125,
    24,    90,     0,    91,    87,    20,     0,    95,    93,     0,
     0,     0,     0,     0,   145,     0,    47,    48,    26,    61,
   115,     0,     0,     0,     0,     0,    81,     0,     0,     0,
     0,     0,     0,     0,   121,   109,    35,    71,    69,     0,
     0,    94,   106,    59,    50,     0,    59,     0,     0,     0,
   113,    63,    65,    64,    66,    45,    82,    83,    79,   118,
   116,   117,   111,   112,     0,     0,    59,    72,     0,     0,
     0,     0,     0,     0,     0,    74,     0,     0,   110,    19,
    73,    70,    55,    51,    37,     0,    59,    74,     0,    44,
   119,    59,    59,     0,     0,    59,     0,    38,    39,    59,
     0,    56,     0,    41,    40,     0,     0,     0
};

static const short yydefgoto[] = {   296,
    25,    26,    38,    42,   123,    27,    44,    67,    28,    29,
    56,    30,   106,    39,   107,   162,   155,   108,   109,     2,
     3,   125,   216,   230,   231,   163,   174,   175,   114,   115,
    81,   153,   225,   256,    32,    45,    33,   111,   112,   134,
   182,   113,   133
};

static const short yypact[] = {    21,
-32768,    37,  1020,-32768,-32768,   -32,     1,-32768,-32768,    17,
    17,-32768,    11,    11,    11,    31,    45,  1757,  1757,-32768,
  1738,  1757,  1112,    21,   540,-32768,    13,    40,-32768,-32768,
   816,   142,    55,   612,  1092,  1112,-32768,    13,-32768,    37,
    21,    13,-32768,    51,    59,-32768,-32768,-32768,  1092,  1092,
  1757,  1625,    27,    -7,    27,    97,-32768,    27,-32768,-32768,
     4,  1225,-32768,-32768,-32768,-32768,-32768,   706,-32768,-32768,
  1625,  1625,   100,  1625,  1625,  1625,  1625,  1625,    76,    21,
   300,  1625,  1757,  1757,  1757,  1757,  1757,  1757,-32768,-32768,
-32768,-32768,    52,-32768,   109,    62,    21,    64,    17,    17,
-32768,-32768,-32768,  1625,    21,   659,-32768,   763,-32768,   920,
   612,    65,    21,    67,     7,  1324,    25,-32768,-32768,-32768,
-32768,-32768,    70,  1757,-32768,    67,    67,  1225,    84,  1625,
-32768,   101,  1159,-32768,   659,  1811,  1796,-32768,  1465,  1371,
  1277,  1811,  1811,    11,-32768,  1324,   -10,   -10,    27,    27,
    27,    27,  1625,  1625,  1625,    87,  1625,   863,  1672,-32768,
-32768,    17,    17,  1324,-32768,-32768,-32768,    65,-32768,    11,
  1738,  1112,-32768,     9,     0,  1512,   142,    83,-32768,   659,
-32768,-32768,-32768,-32768,-32768,-32768,     8,   142,-32768,-32768,
-32768,  1324,   134,-32768,  1324,-32768,  1625,-32768,  1324,  1225,
    17,  1112,  1225,   122,   -16,    65,-32768,-32768,-32768,    59,
-32768,     4,  1625,  1625,  1625,    17,  1691,  1178,  1691,  1691,
   140,  1691,  1691,  1691,   939,-32768,-32768,-32768,-32768,    67,
    23,-32768,  1324,    21,-32768,    26,    21,    94,   144,  1045,
-32768,     9,  1324,  1324,  1324,-32768,  1512,-32768,  1512,   782,
  1858,-32768,  1606,  1559,  1418,  1691,    21,-32768,    44,   863,
    17,   863,  1625,    67,   973,  1625,    17,  1691,  1512,-32768,
-32768,-32768,   131,-32768,-32768,  1225,    21,  1625,    67,-32768,
  1512,    21,    21,   863,    67,    21,   863,-32768,-32768,    21,
   863,-32768,   863,-32768,-32768,   163,   166,-32768
};

static const short yypgoto[] = {-32768,
-32768,   145,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   201,
-32768,    78,   -54,    12,   225,-32768,-32768,-32768,-32768,   363,
   104,   -39,   -70,-32768,-32768,  -152,-32768,-32768,    60,   -19,
    -3,-32768,   -83,-32768,   146,  -126,    74,   178,  -100,   319,
    10,   329,   -29
};


#define	YYLAST		1911


static const short yytable[] = {    31,
   217,    82,   201,    61,   130,   168,   206,   130,   228,   -77,
   181,   229,   -77,   135,     7,   239,   117,   198,   213,    62,
    35,    31,    43,   258,   176,   130,   130,    90,    91,     1,
   110,   116,   116,     1,   196,    85,    86,    87,    36,    70,
    88,   -77,   -77,   210,   271,   116,   116,   272,   128,     4,
   214,   215,     1,   121,   122,    36,   180,   131,   -77,    80,
   -85,   -67,    22,    80,   110,    89,    80,   136,   137,    24,
   139,   140,   141,   142,   143,    37,   -68,    88,   146,   227,
   186,   261,    80,    49,    80,    80,    46,    47,    48,    90,
    91,    54,    54,   226,    54,    54,    24,    50,    37,   124,
   164,   129,   110,   138,   154,    69,   144,   110,   126,   127,
   160,   161,   156,   279,   157,   118,   159,    90,    91,   120,
   131,   179,   187,    37,    54,   285,   192,    63,    66,   195,
   191,   110,   193,   247,   249,   250,   251,   232,   253,   254,
   255,   202,   238,   252,   119,   218,   263,   264,   282,   199,
   200,   164,   212,   203,   110,   164,    54,    54,    54,    54,
    54,    54,   297,    53,    55,   298,    58,    59,    62,    65,
   241,   267,   269,   207,   208,     0,   110,   209,     0,     0,
    34,   178,   236,   145,   281,    83,    84,    85,    86,    87,
     0,     0,    88,   233,     0,     0,    58,    54,   116,     0,
   158,   259,    34,     0,    68,    34,     0,     0,   165,   243,
   244,   245,   235,     0,     0,    34,   184,    46,     0,    34,
     0,    57,     0,     0,     0,     0,     0,   246,   147,   148,
   149,   150,   151,   152,     0,     0,   265,     0,     0,     0,
     0,     0,     0,    46,    54,     0,     0,     0,     0,   178,
     0,     0,     0,   177,     0,     0,   110,     0,   110,   276,
     0,     0,   164,     0,     0,     0,     0,     0,     0,   188,
     0,     0,   274,     0,   164,     0,     0,     0,   280,     0,
   110,     0,     0,   110,     0,     0,     0,   110,     0,   110,
   178,   178,   178,   178,     0,   178,   178,   178,   178,     0,
     0,     0,     0,     7,     0,     0,     8,     9,   173,     0,
     0,     0,     0,     0,     0,     0,    58,     0,     0,     0,
   178,   177,   178,   178,   178,     0,   178,   178,   178,   178,
   167,     0,     0,     0,    14,    15,     0,   260,    41,    41,
   262,   178,   178,    18,    19,     0,    20,     0,    21,     0,
     0,    22,    23,     0,   178,     0,    41,     0,     0,   167,
   270,     0,   177,   177,   177,   177,     0,   177,   177,   177,
   177,   211,    40,    40,     0,     0,   173,     0,     0,   132,
   284,     0,   204,     0,     0,   287,   288,     0,     0,   291,
    40,     0,   177,   293,   177,   177,   177,     0,   177,   177,
   177,   177,     0,     0,   167,     0,     0,     0,     0,     0,
     0,     0,     0,   177,   177,     0,     0,   173,   173,   173,
   173,     0,   173,   173,   173,   173,   177,    41,    41,     0,
     0,     0,   185,     0,     0,     0,     0,     0,    41,     0,
   183,     0,     0,     0,   189,   190,     0,   173,     0,   173,
   173,   173,     0,   173,   173,   173,   173,     0,     0,     0,
     0,    40,    40,     0,     0,     0,     0,     0,   173,   173,
     0,     0,    40,     0,     0,     0,     0,     0,     0,     0,
     0,   173,     0,     0,   273,     0,   275,     0,     0,     0,
    41,    41,     0,     0,     0,     0,   183,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,   289,     0,
     0,   292,     0,     0,     0,   294,     0,   295,   234,     0,
     0,   237,     0,     0,    40,    40,     0,     0,     0,    41,
   242,     0,     0,     0,   240,     0,     0,     0,     0,   -59,
    64,     0,     6,     7,    41,     0,     8,     9,   257,     0,
     0,     0,     1,     0,    10,    11,     0,     0,     0,     0,
     0,     0,     0,    40,     0,     0,     0,     0,   266,    12,
    13,     0,     0,     0,    14,    15,    16,    17,    40,     0,
     0,     0,   277,    18,    19,     0,    20,     0,    21,    41,
     0,    22,    23,   278,   283,    41,    24,   286,     0,     0,
     0,     0,     0,   290,     0,     0,     0,     0,     0,     0,
     0,     0,    92,     0,     6,     7,     0,     0,     8,     9,
     0,     0,     0,    40,     0,     0,     0,     0,    93,    40,
    94,    95,    96,    97,    98,    99,   100,   101,   102,   103,
   104,     0,    13,     0,     0,     0,    14,    15,    16,    17,
     0,     0,     0,     0,     0,    18,    19,     0,    20,   166,
    21,     6,     7,    22,    23,     8,     9,     0,    24,   105,
    37,     0,     0,     0,     0,    93,     0,    94,    95,    96,
    97,    98,    99,   100,   101,   102,   103,   104,     0,    13,
     0,     0,     0,    14,    15,    16,    17,     0,     0,     0,
     0,     0,    18,    19,     0,    20,    92,    21,     6,     7,
    22,    23,     8,     9,     0,    24,   105,    37,     0,     0,
     0,     0,    93,     0,    94,    95,    96,    97,    98,    99,
   100,   101,   102,   103,   104,     0,    13,     0,     0,     0,
    14,    15,    16,    17,     0,     0,     0,     0,     0,    18,
    19,     0,    20,     0,    21,     0,     0,    22,    23,     0,
     0,     0,    24,   169,    37,     6,     7,     0,     0,     8,
     9,     0,   -76,     0,     0,   -76,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     7,     0,     0,     8,     9,
-32768,     0,     0,   170,     0,     0,     0,    14,    15,    16,
    17,     0,     0,     0,   -76,   -76,    18,    19,     0,    20,
     0,   171,     0,     0,    22,   172,    14,    15,     6,     7,
     0,   -76,     8,     9,    71,    18,    19,    72,    20,     0,
   171,     0,     0,    22,    52,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,    13,    73,    74,    75,
    14,    15,    16,    17,    76,     0,    77,    78,    79,    18,
    19,     0,    20,     0,    21,     6,     7,    22,    23,     8,
     9,     0,     0,     0,     0,    80,     0,     0,     0,    93,
     0,    94,    95,    96,    97,    98,    99,   100,   101,   102,
   103,   104,     0,    13,     0,     0,     0,    14,    15,    16,
    17,     0,     0,     0,     0,     0,    18,    19,     0,    20,
     0,    21,     0,     0,    22,    23,     0,     0,     0,    24,
     0,    37,     6,     7,     0,     0,     8,     9,    71,     0,
     0,    72,     1,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     7,     0,     0,     8,     9,     0,     0,     0,
    13,    73,    74,    75,    14,    15,    16,    17,    76,     0,
    77,    78,    79,    18,    19,     0,    20,     0,    21,     0,
     0,    22,    23,    14,    15,     6,     7,     0,    37,     8,
     9,    71,    18,    19,    72,    20,     0,   171,     0,     0,
    22,    52,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,    13,    73,    74,    75,    14,    15,    16,
    17,    76,     0,    77,    78,    79,    18,    19,     0,    20,
     5,    21,     6,     7,    22,    23,     8,     9,     0,     0,
     0,    37,     0,     0,    10,    11,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     6,     7,    12,
    13,     8,     9,     0,    14,    15,    16,    17,     0,     0,
     0,     0,     0,    18,    19,     0,    20,     0,    21,     0,
     0,    22,    23,     0,     0,    13,    24,     0,     0,    14,
    15,    16,    17,     0,     0,     0,     0,     0,    18,    19,
     0,    20,    60,    21,     6,     7,    22,    23,     8,     9,
     0,     0,     0,    37,     0,     0,     0,     0,     0,     0,
     0,     0,    60,     0,     6,     7,     0,     0,     8,     9,
     0,     0,    13,     0,     0,     0,    14,    15,    16,    17,
     0,     0,     0,     0,     0,    18,    19,     0,    20,     0,
    21,     0,    13,    22,    23,   -84,    14,    15,    16,    17,
     0,     0,     0,     0,     0,    18,    19,     0,    20,   194,
    21,     6,     7,    22,    23,     8,     9,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,   248,     0,
     6,     7,     0,     0,     8,     9,     0,     0,     0,    13,
     0,     0,     0,    14,    15,    16,    17,     0,     0,     0,
     0,     0,    18,    19,     0,    20,     0,    21,   170,     0,
    22,    23,    14,    15,    16,    17,     0,     0,     0,     0,
     0,    18,    19,     0,    20,     0,   171,     6,     7,    22,
    52,     8,     9,    71,     0,     0,    72,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,    13,    73,    74,    75,    14,
    15,    16,    17,    76,     0,    77,    78,    79,    18,    19,
     0,    20,     0,    21,     0,     0,    22,    23,   131,     6,
     7,     0,     0,     8,     9,    71,     0,     0,    72,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,    13,    73,    74,
    75,    14,    15,    16,    17,    76,   197,    77,    78,    79,
    18,    19,     0,    20,     0,    21,     6,     7,    22,    23,
     8,     9,    71,     0,     0,    72,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,    13,    73,    74,    75,    14,    15,
    16,    17,    76,     0,    77,    78,    79,    18,    19,     0,
    20,     0,    21,     6,     7,    22,    23,     8,     9,    71,
     0,     0,    72,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,    13,    73,    74,     0,    14,    15,    16,    17,     0,
     0,    77,    78,    79,    18,    19,     0,    20,     0,    21,
     6,     7,    22,    23,     8,     9,   219,     0,     0,   220,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,   170,   221,
   222,   223,    14,    15,    16,    17,   224,   268,     0,     0,
     0,    18,    19,     0,    20,     0,   171,     6,     7,    22,
    52,     8,     9,    71,     0,     0,    72,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,    13,    73,     0,     0,    14,
    15,    16,    17,     0,     0,    77,    78,    79,    18,    19,
     0,    20,     0,    21,     6,     7,    22,    23,     8,     9,
   219,     0,     0,   220,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,   170,   221,   222,   223,    14,    15,    16,    17,
   224,     0,     0,     0,     0,    18,    19,     0,    20,     0,
   171,     6,     7,    22,    52,     8,     9,   219,     0,     0,
   220,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   170,
   221,   222,     0,    14,    15,    16,    17,     0,     0,     0,
     0,     0,    18,    19,     0,    20,     0,   171,     6,     7,
    22,    52,     8,     9,   219,     0,     0,   220,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     6,     7,     0,
     0,     8,     9,     0,     0,     0,   170,   221,     0,     0,
    14,    15,    16,    17,     0,     0,     0,     0,     0,    18,
    19,     0,    20,     0,   171,    13,     0,    22,    52,    14,
    15,    16,    17,     0,     0,     0,     0,     0,    18,    19,
     0,    20,     0,    21,     6,   205,    22,    23,     8,     9,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     6,     7,     0,     0,     8,     9,     0,
     0,     0,    13,     0,     0,     0,    14,    15,    16,    17,
     0,     0,     0,     0,     0,    18,    19,     0,    20,     0,
    21,   170,     0,    22,    23,    14,    15,    16,    17,     0,
     0,     0,     0,     0,    18,    19,     0,    20,     0,   171,
     6,     7,    22,    52,     8,     9,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     6,
     7,     0,     0,     8,     9,     0,     0,     0,     0,     0,
     0,     0,    14,    15,    16,    17,     0,     0,     0,     0,
     0,    18,    19,     0,    20,     0,    51,     0,     0,    22,
    52,    14,    15,    16,    17,     0,     0,     0,     0,     7,
    18,    19,     8,     9,    71,    51,     0,-32768,    22,    52,
     0,     0,     0,     0,     7,     0,     0,     8,     9,-32768,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
    14,    15,     0,     0,     0,     0,    77,    78,    79,    18,
    19,     0,    20,     0,    21,    14,    15,    22,    23,     0,
     0,-32768,-32768,-32768,    18,    19,     0,    20,     0,    21,
     0,     7,    22,    23,     8,     9,   219,     0,     0,-32768,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,    14,    15,     0,     0,     0,     0,     0,     0,
     0,    18,    19,     0,    20,     0,   171,     0,     0,    22,
    52
};

static const short yycheck[] = {     3,
     1,    31,   155,    23,     1,   106,   159,     1,     1,    10,
   111,     4,    13,    68,     4,    32,    36,   144,    10,    23,
    53,    25,    11,     1,   108,     1,     1,    35,    36,    13,
    34,    35,    36,    13,   135,    46,    47,    48,    55,    28,
    51,    42,    43,   170,     1,    49,    50,     4,    52,    13,
    42,    43,    13,     3,     4,    55,   111,    54,    59,    60,
    54,    54,    52,    60,    68,    11,    60,    71,    72,    57,
    74,    75,    76,    77,    78,    59,    54,    51,    82,   180,
    56,    56,    60,    53,    60,    60,    13,    14,    15,    35,
    36,    18,    19,    11,    21,    22,    57,    53,    59,    41,
   104,     5,   106,     4,    53,    28,    31,   111,    49,    50,
    99,   100,     4,   266,    53,    38,    53,    35,    36,    42,
    54,   110,    53,    59,    51,   278,   130,    24,    25,   133,
    47,   135,    32,   217,   218,   219,   220,     4,   222,   223,
   224,    55,    21,     4,    41,   175,    53,     4,    18,   153,
   154,   155,   172,   157,   158,   159,    83,    84,    85,    86,
    87,    88,     0,    18,    19,     0,    21,    22,   172,    25,
   210,   242,   256,   162,   163,    -1,   180,   168,    -1,    -1,
     3,   108,   202,    80,   268,    44,    45,    46,    47,    48,
    -1,    -1,    51,   197,    -1,    -1,    51,   124,   202,    -1,
    97,   231,    25,    -1,    27,    28,    -1,    -1,   105,   213,
   214,   215,   201,    -1,    -1,    38,   113,   144,    -1,    42,
    -1,    21,    -1,    -1,    -1,    -1,    -1,   216,    83,    84,
    85,    86,    87,    88,    -1,    -1,   240,    -1,    -1,    -1,
    -1,    -1,    -1,   170,   171,    -1,    -1,    -1,    -1,   176,
    -1,    -1,    -1,   108,    -1,    -1,   260,    -1,   262,   263,
    -1,    -1,   266,    -1,    -1,    -1,    -1,    -1,    -1,   124,
    -1,    -1,   261,    -1,   278,    -1,    -1,    -1,   267,    -1,
   284,    -1,    -1,   287,    -1,    -1,    -1,   291,    -1,   293,
   217,   218,   219,   220,    -1,   222,   223,   224,   225,    -1,
    -1,    -1,    -1,     4,    -1,    -1,     7,     8,   108,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,   171,    -1,    -1,    -1,
   247,   176,   249,   250,   251,    -1,   253,   254,   255,   256,
   106,    -1,    -1,    -1,    35,    36,    -1,   234,    10,    11,
   237,   268,   269,    44,    45,    -1,    47,    -1,    49,    -1,
    -1,    52,    53,    -1,   281,    -1,    28,    -1,    -1,   135,
   257,    -1,   217,   218,   219,   220,    -1,   222,   223,   224,
   225,   171,    10,    11,    -1,    -1,   176,    -1,    -1,    61,
   277,    -1,   158,    -1,    -1,   282,   283,    -1,    -1,   286,
    28,    -1,   247,   290,   249,   250,   251,    -1,   253,   254,
   255,   256,    -1,    -1,   180,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,   268,   269,    -1,    -1,   217,   218,   219,
   220,    -1,   222,   223,   224,   225,   281,    99,   100,    -1,
    -1,    -1,   114,    -1,    -1,    -1,    -1,    -1,   110,    -1,
   112,    -1,    -1,    -1,   126,   127,    -1,   247,    -1,   249,
   250,   251,    -1,   253,   254,   255,   256,    -1,    -1,    -1,
    -1,    99,   100,    -1,    -1,    -1,    -1,    -1,   268,   269,
    -1,    -1,   110,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,   281,    -1,    -1,   260,    -1,   262,    -1,    -1,    -1,
   162,   163,    -1,    -1,    -1,    -1,   168,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   284,    -1,
    -1,   287,    -1,    -1,    -1,   291,    -1,   293,   200,    -1,
    -1,   203,    -1,    -1,   162,   163,    -1,    -1,    -1,   201,
   212,    -1,    -1,    -1,   206,    -1,    -1,    -1,    -1,     0,
     1,    -1,     3,     4,   216,    -1,     7,     8,   230,    -1,
    -1,    -1,    13,    -1,    15,    16,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,   201,    -1,    -1,    -1,    -1,   240,    30,
    31,    -1,    -1,    -1,    35,    36,    37,    38,   216,    -1,
    -1,    -1,   264,    44,    45,    -1,    47,    -1,    49,   261,
    -1,    52,    53,   265,   276,   267,    57,   279,    -1,    -1,
    -1,    -1,    -1,   285,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,     1,    -1,     3,     4,    -1,    -1,     7,     8,
    -1,    -1,    -1,   261,    -1,    -1,    -1,    -1,    17,   267,
    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
    29,    -1,    31,    -1,    -1,    -1,    35,    36,    37,    38,
    -1,    -1,    -1,    -1,    -1,    44,    45,    -1,    47,     1,
    49,     3,     4,    52,    53,     7,     8,    -1,    57,    58,
    59,    -1,    -1,    -1,    -1,    17,    -1,    19,    20,    21,
    22,    23,    24,    25,    26,    27,    28,    29,    -1,    31,
    -1,    -1,    -1,    35,    36,    37,    38,    -1,    -1,    -1,
    -1,    -1,    44,    45,    -1,    47,     1,    49,     3,     4,
    52,    53,     7,     8,    -1,    57,    58,    59,    -1,    -1,
    -1,    -1,    17,    -1,    19,    20,    21,    22,    23,    24,
    25,    26,    27,    28,    29,    -1,    31,    -1,    -1,    -1,
    35,    36,    37,    38,    -1,    -1,    -1,    -1,    -1,    44,
    45,    -1,    47,    -1,    49,    -1,    -1,    52,    53,    -1,
    -1,    -1,    57,     1,    59,     3,     4,    -1,    -1,     7,
     8,    -1,    10,    -1,    -1,    13,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,     4,    -1,    -1,     7,     8,
     9,    -1,    -1,    31,    -1,    -1,    -1,    35,    36,    37,
    38,    -1,    -1,    -1,    42,    43,    44,    45,    -1,    47,
    -1,    49,    -1,    -1,    52,    53,    35,    36,     3,     4,
    -1,    59,     7,     8,     9,    44,    45,    12,    47,    -1,
    49,    -1,    -1,    52,    53,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
    35,    36,    37,    38,    39,    -1,    41,    42,    43,    44,
    45,    -1,    47,    -1,    49,     3,     4,    52,    53,     7,
     8,    -1,    -1,    -1,    -1,    60,    -1,    -1,    -1,    17,
    -1,    19,    20,    21,    22,    23,    24,    25,    26,    27,
    28,    29,    -1,    31,    -1,    -1,    -1,    35,    36,    37,
    38,    -1,    -1,    -1,    -1,    -1,    44,    45,    -1,    47,
    -1,    49,    -1,    -1,    52,    53,    -1,    -1,    -1,    57,
    -1,    59,     3,     4,    -1,    -1,     7,     8,     9,    -1,
    -1,    12,    13,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,     4,    -1,    -1,     7,     8,    -1,    -1,    -1,
    31,    32,    33,    34,    35,    36,    37,    38,    39,    -1,
    41,    42,    43,    44,    45,    -1,    47,    -1,    49,    -1,
    -1,    52,    53,    35,    36,     3,     4,    -1,    59,     7,
     8,     9,    44,    45,    12,    47,    -1,    49,    -1,    -1,
    52,    53,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    31,    32,    33,    34,    35,    36,    37,
    38,    39,    -1,    41,    42,    43,    44,    45,    -1,    47,
     1,    49,     3,     4,    52,    53,     7,     8,    -1,    -1,
    -1,    59,    -1,    -1,    15,    16,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,    30,
    31,     7,     8,    -1,    35,    36,    37,    38,    -1,    -1,
    -1,    -1,    -1,    44,    45,    -1,    47,    -1,    49,    -1,
    -1,    52,    53,    -1,    -1,    31,    57,    -1,    -1,    35,
    36,    37,    38,    -1,    -1,    -1,    -1,    -1,    44,    45,
    -1,    47,     1,    49,     3,     4,    52,    53,     7,     8,
    -1,    -1,    -1,    59,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,     1,    -1,     3,     4,    -1,    -1,     7,     8,
    -1,    -1,    31,    -1,    -1,    -1,    35,    36,    37,    38,
    -1,    -1,    -1,    -1,    -1,    44,    45,    -1,    47,    -1,
    49,    -1,    31,    52,    53,    54,    35,    36,    37,    38,
    -1,    -1,    -1,    -1,    -1,    44,    45,    -1,    47,     1,
    49,     3,     4,    52,    53,     7,     8,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     1,    -1,
     3,     4,    -1,    -1,     7,     8,    -1,    -1,    -1,    31,
    -1,    -1,    -1,    35,    36,    37,    38,    -1,    -1,    -1,
    -1,    -1,    44,    45,    -1,    47,    -1,    49,    31,    -1,
    52,    53,    35,    36,    37,    38,    -1,    -1,    -1,    -1,
    -1,    44,    45,    -1,    47,    -1,    49,     3,     4,    52,
    53,     7,     8,     9,    -1,    -1,    12,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,    35,
    36,    37,    38,    39,    -1,    41,    42,    43,    44,    45,
    -1,    47,    -1,    49,    -1,    -1,    52,    53,    54,     3,
     4,    -1,    -1,     7,     8,     9,    -1,    -1,    12,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,
    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
    44,    45,    -1,    47,    -1,    49,     3,     4,    52,    53,
     7,     8,     9,    -1,    -1,    12,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    31,    32,    33,    34,    35,    36,
    37,    38,    39,    -1,    41,    42,    43,    44,    45,    -1,
    47,    -1,    49,     3,     4,    52,    53,     7,     8,     9,
    -1,    -1,    12,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    31,    32,    33,    -1,    35,    36,    37,    38,    -1,
    -1,    41,    42,    43,    44,    45,    -1,    47,    -1,    49,
     3,     4,    52,    53,     7,     8,     9,    -1,    -1,    12,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    31,    32,
    33,    34,    35,    36,    37,    38,    39,    40,    -1,    -1,
    -1,    44,    45,    -1,    47,    -1,    49,     3,     4,    52,
    53,     7,     8,     9,    -1,    -1,    12,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    31,    32,    -1,    -1,    35,
    36,    37,    38,    -1,    -1,    41,    42,    43,    44,    45,
    -1,    47,    -1,    49,     3,     4,    52,    53,     7,     8,
     9,    -1,    -1,    12,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    31,    32,    33,    34,    35,    36,    37,    38,
    39,    -1,    -1,    -1,    -1,    44,    45,    -1,    47,    -1,
    49,     3,     4,    52,    53,     7,     8,     9,    -1,    -1,
    12,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    31,
    32,    33,    -1,    35,    36,    37,    38,    -1,    -1,    -1,
    -1,    -1,    44,    45,    -1,    47,    -1,    49,     3,     4,
    52,    53,     7,     8,     9,    -1,    -1,    12,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,    -1,
    -1,     7,     8,    -1,    -1,    -1,    31,    32,    -1,    -1,
    35,    36,    37,    38,    -1,    -1,    -1,    -1,    -1,    44,
    45,    -1,    47,    -1,    49,    31,    -1,    52,    53,    35,
    36,    37,    38,    -1,    -1,    -1,    -1,    -1,    44,    45,
    -1,    47,    -1,    49,     3,     4,    52,    53,     7,     8,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,     3,     4,    -1,    -1,     7,     8,    -1,
    -1,    -1,    31,    -1,    -1,    -1,    35,    36,    37,    38,
    -1,    -1,    -1,    -1,    -1,    44,    45,    -1,    47,    -1,
    49,    31,    -1,    52,    53,    35,    36,    37,    38,    -1,
    -1,    -1,    -1,    -1,    44,    45,    -1,    47,    -1,    49,
     3,     4,    52,    53,     7,     8,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,
     4,    -1,    -1,     7,     8,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    35,    36,    37,    38,    -1,    -1,    -1,    -1,
    -1,    44,    45,    -1,    47,    -1,    49,    -1,    -1,    52,
    53,    35,    36,    37,    38,    -1,    -1,    -1,    -1,     4,
    44,    45,     7,     8,     9,    49,    -1,    12,    52,    53,
    -1,    -1,    -1,    -1,     4,    -1,    -1,     7,     8,     9,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    35,    36,    -1,    -1,    -1,    -1,    41,    42,    43,    44,
    45,    -1,    47,    -1,    49,    35,    36,    52,    53,    -1,
    -1,    41,    42,    43,    44,    45,    -1,    47,    -1,    49,
    -1,     4,    52,    53,     7,     8,     9,    -1,    -1,    12,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    35,    36,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    44,    45,    -1,    47,    -1,    49,    -1,    -1,    52,
    53
};
#define YYPURE 1

/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
#line 3 "bison.simple"

/* Skeleton output parser for bison,
   Copyright (C) 1984 Bob Corbett and Richard Stallman

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 1, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */


#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__)
#include <alloca.h>
#endif

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYFAIL		goto yyerrlab;
#define YYACCEPT	return(0)
#define YYABORT 	return(1)
#define YYERROR		goto yyerrlab

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYIMPURE
#define YYLEX		yylex()
#endif

#ifndef YYPURE
#define YYLEX		yylex(&yylval, &yylloc)
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYIMPURE

int	yychar;			/*  the lookahead symbol		*/
YYSTYPE	yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

YYLTYPE yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/

int yynerrs;			/*  number of parse errors so far       */
#endif  /* YYIMPURE */

#if YYDEBUG != 0
int yydebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYMAXDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYMAXDEPTH
#define YYMAXDEPTH 200
#endif

/*  YYMAXLIMIT is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#ifndef YYMAXLIMIT
#define YYMAXLIMIT 10000
#endif


#line 90 "bison.simple"
int
yyparse()
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YYSTYPE *yyvsp;
  YYLTYPE *yylsp;
  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int yychar1;		/*  lookahead token as an internal (translated) token number */

  short	yyssa[YYMAXDEPTH];	/*  the state stack			*/
  YYSTYPE yyvsa[YYMAXDEPTH];	/*  the semantic value stack		*/
  YYLTYPE yylsa[YYMAXDEPTH];	/*  the location stack			*/

  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
  YYLTYPE *yyls = yylsa;

  int yymaxdepth = YYMAXDEPTH;

#ifndef YYPURE
  int yychar;
  YYSTYPE yylval;
  YYLTYPE yylloc;
  int yynerrs;
#endif

  YYSTYPE yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int yylen;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
  yylsp = yyls;

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yymaxdepth - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *yyvs1 = yyvs;
      YYLTYPE *yyls1 = yyls;
      short *yyss1 = yyss;

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yyls1, size * sizeof (*yylsp),
		 &yymaxdepth);

      yyss = yyss1; yyvs = yyvs1; yyls = yyls1;
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yymaxdepth >= YYMAXLIMIT)
	yyerror("parser stack overflow");
      yymaxdepth *= 2;
      if (yymaxdepth > YYMAXLIMIT)
	yymaxdepth = YYMAXLIMIT;
      yyss = (short *) alloca (yymaxdepth * sizeof (*yyssp));
      bcopy ((char *)yyss1, (char *)yyss, size * sizeof (*yyssp));
      yyvs = (YYSTYPE *) alloca (yymaxdepth * sizeof (*yyvsp));
      bcopy ((char *)yyvs1, (char *)yyvs, size * sizeof (*yyvsp));
#ifdef YYLSP_NEEDED
      yyls = (YYLTYPE *) alloca (yymaxdepth * sizeof (*yylsp));
      bcopy ((char *)yyls1, (char *)yyls, size * sizeof (*yylsp));
#endif
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
#ifdef YYLSP_NEEDED
      yylsp = yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Stack size increased to %d\n", yymaxdepth);
#endif

      if (yyssp >= yyss + yymaxdepth - 1)
	YYABORT;
    }

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Entering state %d\n", yystate);
#endif

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
yyresume:

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (yychar == YYEMPTY)
    {
#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Reading a token: ");
#endif
      yychar = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)		/* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Next token is %d (%s)\n", yychar, yytname[yychar1]);
#endif
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;

/* Do the default action for the current state.  */
yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
yyreduce:
  yylen = yyr2[yyn];
  yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (yydebug)
    {
      if (yylen == 1)
	fprintf (stderr, "Reducing 1 value via line %d, ",
		 yyrline[yyn]);
      else
	fprintf (stderr, "Reducing %d values via line %d, ",
		 yylen, yyrline[yyn]);
    }
#endif


  switch (yyn) {

case 1:
#line 137 "awk.y"
{ expression_value = yyvsp[-1].nodeval; ;
    break;}
case 2:
#line 142 "awk.y"
{ 
			if (yyvsp[0].nodeval != NULL)
				yyval.nodeval = yyvsp[0].nodeval;
			else
				yyval.nodeval = NULL;
			yyerrok;
		;
    break;}
case 3:
#line 151 "awk.y"
{
			if (yyvsp[0].nodeval == NULL)
				yyval.nodeval = yyvsp[-1].nodeval;
			else if (yyvsp[-1].nodeval == NULL)
				yyval.nodeval = yyvsp[0].nodeval;
			else {
				if (yyvsp[-1].nodeval->type != Node_rule_list)
					yyvsp[-1].nodeval = node(yyvsp[-1].nodeval, Node_rule_list,
						(NODE*)NULL);
				yyval.nodeval = append_right (yyvsp[-1].nodeval,
				   node(yyvsp[0].nodeval, Node_rule_list,(NODE *) NULL));
			}
			yyerrok;
		;
    break;}
case 4:
#line 165 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 5:
#line 166 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 6:
#line 170 "awk.y"
{ io_allowed = 0; ;
    break;}
case 7:
#line 172 "awk.y"
{
		if (begin_block) {
			if (begin_block->type != Node_rule_list)
				begin_block = node(begin_block, Node_rule_list,
					(NODE *)NULL);
			append_right (begin_block, node(
			    node((NODE *)NULL, Node_rule_node, yyvsp[0].nodeval),
			    Node_rule_list, (NODE *)NULL) );
		} else
			begin_block = node((NODE *)NULL, Node_rule_node, yyvsp[0].nodeval);
		yyval.nodeval = NULL;
		io_allowed = 1;
		yyerrok;
	  ;
    break;}
case 8:
#line 186 "awk.y"
{ io_allowed = 0; ;
    break;}
case 9:
#line 188 "awk.y"
{
		if (end_block) {
			if (end_block->type != Node_rule_list)
				end_block = node(end_block, Node_rule_list,
					(NODE *)NULL);
			append_right (end_block, node(
			    node((NODE *)NULL, Node_rule_node, yyvsp[0].nodeval),
			    Node_rule_list, (NODE *)NULL));
		} else
			end_block = node((NODE *)NULL, Node_rule_node, yyvsp[0].nodeval);
		yyval.nodeval = NULL;
		io_allowed = 1;
		yyerrok;
	  ;
    break;}
case 10:
#line 203 "awk.y"
{
		msg ("error near line %d: BEGIN blocks must have an action part", lineno);
		errcount++;
		yyerrok;
	  ;
    break;}
case 11:
#line 209 "awk.y"
{
		msg ("error near line %d: END blocks must have an action part", lineno);
		errcount++;
		yyerrok;
	  ;
    break;}
case 12:
#line 215 "awk.y"
{ yyval.nodeval = node (yyvsp[-1].nodeval, Node_rule_node, yyvsp[0].nodeval); yyerrok; ;
    break;}
case 13:
#line 217 "awk.y"
{ yyval.nodeval = node ((NODE *)NULL, Node_rule_node, yyvsp[0].nodeval); yyerrok; ;
    break;}
case 14:
#line 219 "awk.y"
{ if(yyvsp[-1].nodeval) yyval.nodeval = node (yyvsp[-1].nodeval, Node_rule_node, (NODE *)NULL); yyerrok; ;
    break;}
case 15:
#line 221 "awk.y"
{
			func_install(yyvsp[-1].nodeval, yyvsp[0].nodeval);
			yyval.nodeval = NULL;
			yyerrok;
		;
    break;}
case 16:
#line 230 "awk.y"
{ yyval.sval = yyvsp[0].sval; ;
    break;}
case 17:
#line 232 "awk.y"
{ yyval.sval = yyvsp[0].sval; ;
    break;}
case 18:
#line 237 "awk.y"
{
			param_counter = 0;
		;
    break;}
case 19:
#line 241 "awk.y"
{
			yyval.nodeval = append_right(make_param(yyvsp[-4].sval), yyvsp[-2].nodeval);
			can_return = 1;
		;
    break;}
case 20:
#line 249 "awk.y"
{
		yyval.nodeval = yyvsp[-1].nodeval;
		can_return = 0;
	  ;
    break;}
case 21:
#line 258 "awk.y"
{ yyval.nodeval = yyvsp[0].nodeval; ;
    break;}
case 22:
#line 260 "awk.y"
{ yyval.nodeval = mkrangenode ( node(yyvsp[-2].nodeval, Node_cond_pair, yyvsp[0].nodeval) ); ;
    break;}
case 23:
#line 269 "awk.y"
{ ++want_regexp; ;
    break;}
case 24:
#line 271 "awk.y"
{
		  want_regexp = 0;
		  yyval.nodeval = node((NODE *)NULL,Node_regex,(NODE *)mk_re_parse(yyvsp[-1].sval, 0));
		  yyval.nodeval -> re_case = 0;
		  emalloc (yyval.nodeval -> re_text, char *, strlen(yyvsp[-1].sval)+1, "regexp");
		  strcpy (yyval.nodeval -> re_text, yyvsp[-1].sval);
		;
    break;}
case 25:
#line 282 "awk.y"
{
			/* empty actions are different from missing actions */
			yyval.nodeval = node ((NODE *) NULL, Node_illegal, (NODE *) NULL);
		;
    break;}
case 26:
#line 287 "awk.y"
{ yyval.nodeval = yyvsp[-2].nodeval ; ;
    break;}
case 27:
#line 292 "awk.y"
{ yyval.nodeval = yyvsp[0].nodeval; ;
    break;}
case 28:
#line 294 "awk.y"
{
			if (yyvsp[-1].nodeval == NULL || yyvsp[-1].nodeval->type != Node_statement_list)
				yyvsp[-1].nodeval = node(yyvsp[-1].nodeval, Node_statement_list,(NODE *)NULL);
	    		yyval.nodeval = append_right(yyvsp[-1].nodeval,
				node( yyvsp[0].nodeval, Node_statement_list, (NODE *)NULL));
	    		yyerrok;
		;
    break;}
case 29:
#line 302 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 30:
#line 304 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 31:
#line 309 "awk.y"
{ yyval.nodetypeval = Node_illegal; ;
    break;}
case 32:
#line 311 "awk.y"
{ yyval.nodetypeval = Node_illegal; ;
    break;}
case 33:
#line 317 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 34:
#line 319 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 35:
#line 321 "awk.y"
{ yyval.nodeval = yyvsp[-1].nodeval; ;
    break;}
case 36:
#line 323 "awk.y"
{ yyval.nodeval = yyvsp[0].nodeval; ;
    break;}
case 37:
#line 325 "awk.y"
{ yyval.nodeval = node (yyvsp[-3].nodeval, Node_K_while, yyvsp[0].nodeval); ;
    break;}
case 38:
#line 327 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, Node_K_do, yyvsp[-5].nodeval); ;
    break;}
case 39:
#line 329 "awk.y"
{
		yyval.nodeval = node (yyvsp[0].nodeval, Node_K_arrayfor, make_for_loop(variable(yyvsp[-5].sval),
			(NODE *)NULL, variable(yyvsp[-3].sval)));
	  ;
    break;}
case 40:
#line 334 "awk.y"
{
		yyval.nodeval = node(yyvsp[0].nodeval, Node_K_for, (NODE *)make_for_loop(yyvsp[-7].nodeval, yyvsp[-5].nodeval, yyvsp[-3].nodeval));
	  ;
    break;}
case 41:
#line 338 "awk.y"
{
		yyval.nodeval = node (yyvsp[0].nodeval, Node_K_for,
			(NODE *)make_for_loop(yyvsp[-6].nodeval, (NODE *)NULL, yyvsp[-3].nodeval));
	  ;
    break;}
case 42:
#line 344 "awk.y"
{ yyval.nodeval = node ((NODE *)NULL, Node_K_break, (NODE *)NULL); ;
    break;}
case 43:
#line 347 "awk.y"
{ yyval.nodeval = node ((NODE *)NULL, Node_K_continue, (NODE *)NULL); ;
    break;}
case 44:
#line 349 "awk.y"
{ yyval.nodeval = node (yyvsp[-3].nodeval, yyvsp[-5].nodetypeval, yyvsp[-1].nodeval); ;
    break;}
case 45:
#line 351 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, yyvsp[-3].nodetypeval, yyvsp[-1].nodeval); ;
    break;}
case 46:
#line 353 "awk.y"
{ if (! io_allowed) yyerror("next used in BEGIN or END action"); ;
    break;}
case 47:
#line 355 "awk.y"
{ yyval.nodeval = node ((NODE *)NULL, Node_K_next, (NODE *)NULL); ;
    break;}
case 48:
#line 357 "awk.y"
{ yyval.nodeval = node (yyvsp[-1].nodeval, Node_K_exit, (NODE *)NULL); ;
    break;}
case 49:
#line 359 "awk.y"
{ if (! can_return) yyerror("return used outside function context"); ;
    break;}
case 50:
#line 361 "awk.y"
{ yyval.nodeval = node (yyvsp[-1].nodeval, Node_K_return, (NODE *)NULL); ;
    break;}
case 51:
#line 363 "awk.y"
{ yyval.nodeval = node (variable(yyvsp[-4].sval), Node_K_delete, yyvsp[-2].nodeval); ;
    break;}
case 52:
#line 365 "awk.y"
{ yyval.nodeval = yyvsp[-1].nodeval; ;
    break;}
case 53:
#line 370 "awk.y"
{ yyval.nodetypeval = yyvsp[0].nodetypeval; ;
    break;}
case 54:
#line 372 "awk.y"
{ yyval.nodetypeval = yyvsp[0].nodetypeval; ;
    break;}
case 55:
#line 377 "awk.y"
{
		yyval.nodeval = node(yyvsp[-3].nodeval, Node_K_if, 
			node(yyvsp[0].nodeval, Node_if_branches, (NODE *)NULL));
	  ;
    break;}
case 56:
#line 383 "awk.y"
{ yyval.nodeval = node (yyvsp[-6].nodeval, Node_K_if,
				node (yyvsp[-3].nodeval, Node_if_branches, yyvsp[0].nodeval)); ;
    break;}
case 57:
#line 389 "awk.y"
{ yyval.nodetypeval = NULL; ;
    break;}
case 58:
#line 391 "awk.y"
{ yyval.nodetypeval = NULL; ;
    break;}
case 59:
#line 396 "awk.y"
{ yyval.nodetypeval = NULL; ;
    break;}
case 60:
#line 398 "awk.y"
{ yyval.nodetypeval = NULL; ;
    break;}
case 61:
#line 403 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 62:
#line 405 "awk.y"
{ yyval.nodeval = node (yyvsp[0].nodeval, Node_redirect_input, (NODE *)NULL); ;
    break;}
case 63:
#line 410 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 64:
#line 412 "awk.y"
{ yyval.nodeval = node (yyvsp[0].nodeval, Node_redirect_output, (NODE *)NULL); ;
    break;}
case 65:
#line 414 "awk.y"
{ yyval.nodeval = node (yyvsp[0].nodeval, Node_redirect_append, (NODE *)NULL); ;
    break;}
case 66:
#line 416 "awk.y"
{ yyval.nodeval = node (yyvsp[0].nodeval, Node_redirect_pipe, (NODE *)NULL); ;
    break;}
case 67:
#line 421 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 68:
#line 423 "awk.y"
{ yyval.nodeval = yyvsp[0].nodeval; ;
    break;}
case 69:
#line 428 "awk.y"
{ yyval.nodeval = make_param(yyvsp[0].sval); ;
    break;}
case 70:
#line 430 "awk.y"
{ yyval.nodeval = append_right(yyvsp[-2].nodeval, make_param(yyvsp[0].sval)); yyerrok; ;
    break;}
case 71:
#line 432 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 72:
#line 434 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 73:
#line 436 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 74:
#line 442 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 75:
#line 444 "awk.y"
{ yyval.nodeval = yyvsp[0].nodeval; ;
    break;}
case 76:
#line 449 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 77:
#line 451 "awk.y"
{ yyval.nodeval = yyvsp[0].nodeval; ;
    break;}
case 78:
#line 456 "awk.y"
{ yyval.nodeval = node (yyvsp[0].nodeval, Node_expression_list, (NODE *)NULL); ;
    break;}
case 79:
#line 458 "awk.y"
{
		yyval.nodeval = append_right(yyvsp[-2].nodeval,
			node( yyvsp[0].nodeval, Node_expression_list, (NODE *)NULL));
		yyerrok;
	  ;
    break;}
case 80:
#line 464 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 81:
#line 466 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 82:
#line 468 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 83:
#line 470 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 84:
#line 475 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 85:
#line 477 "awk.y"
{ yyval.nodeval = yyvsp[0].nodeval; ;
    break;}
case 86:
#line 482 "awk.y"
{ yyval.nodeval = node (yyvsp[0].nodeval, Node_expression_list, (NODE *)NULL); ;
    break;}
case 87:
#line 484 "awk.y"
{
			yyval.nodeval = append_right(yyvsp[-2].nodeval,
				node( yyvsp[0].nodeval, Node_expression_list, (NODE *)NULL));
			yyerrok;
		;
    break;}
case 88:
#line 490 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 89:
#line 492 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 90:
#line 494 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 91:
#line 496 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 92:
#line 501 "awk.y"
{ want_assign = 0; ;
    break;}
case 93:
#line 503 "awk.y"
{ yyval.nodeval = node (yyvsp[-3].nodeval, yyvsp[-2].nodetypeval, yyvsp[0].nodeval); ;
    break;}
case 94:
#line 505 "awk.y"
{ yyval.nodeval = node (variable(yyvsp[0].sval), Node_in_array, yyvsp[-3].nodeval); ;
    break;}
case 95:
#line 507 "awk.y"
{
		  yyval.nodeval = node (yyvsp[0].nodeval, Node_K_getline,
			 node (yyvsp[-3].nodeval, Node_redirect_pipein, (NODE *)NULL));
		;
    break;}
case 96:
#line 512 "awk.y"
{
		  /* "too painful to do right" */
		  /*
		  if (! io_allowed && $3 == NULL)
			yyerror("non-redirected getline illegal inside BEGIN or END action");
		  */
		  yyval.nodeval = node (yyvsp[-1].nodeval, Node_K_getline, yyvsp[0].nodeval);
		;
    break;}
case 97:
#line 521 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, Node_and, yyvsp[0].nodeval); ;
    break;}
case 98:
#line 523 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, Node_or, yyvsp[0].nodeval); ;
    break;}
case 99:
#line 525 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, yyvsp[-1].nodetypeval, yyvsp[0].nodeval); ;
    break;}
case 100:
#line 527 "awk.y"
{ yyval.nodeval = yyvsp[0].nodeval; ;
    break;}
case 101:
#line 529 "awk.y"
{ yyval.nodeval = node((NODE *) NULL, Node_nomatch, yyvsp[0].nodeval); ;
    break;}
case 102:
#line 531 "awk.y"
{ yyval.nodeval = node (variable(yyvsp[0].sval), Node_in_array, yyvsp[-2].nodeval); ;
    break;}
case 103:
#line 533 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, yyvsp[-1].nodetypeval, yyvsp[0].nodeval); ;
    break;}
case 104:
#line 535 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, Node_less, yyvsp[0].nodeval); ;
    break;}
case 105:
#line 537 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, Node_greater, yyvsp[0].nodeval); ;
    break;}
case 106:
#line 539 "awk.y"
{ yyval.nodeval = node(yyvsp[-4].nodeval, Node_cond_exp, node(yyvsp[-2].nodeval, Node_if_branches, yyvsp[0].nodeval));;
    break;}
case 107:
#line 541 "awk.y"
{ yyval.nodeval = yyvsp[0].nodeval; ;
    break;}
case 108:
#line 543 "awk.y"
{ yyval.nodeval = node (yyvsp[-1].nodeval, Node_concat, yyvsp[0].nodeval); ;
    break;}
case 109:
#line 548 "awk.y"
{ want_assign = 0; ;
    break;}
case 110:
#line 550 "awk.y"
{ yyval.nodeval = node (yyvsp[-3].nodeval, yyvsp[-2].nodetypeval, yyvsp[0].nodeval); ;
    break;}
case 111:
#line 552 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, Node_and, yyvsp[0].nodeval); ;
    break;}
case 112:
#line 554 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, Node_or, yyvsp[0].nodeval); ;
    break;}
case 113:
#line 556 "awk.y"
{
		  /* "too painful to do right" */
		  /*
		  if (! io_allowed && $3 == NULL)
			yyerror("non-redirected getline illegal inside BEGIN or END action");
		  */
		  yyval.nodeval = node (yyvsp[-1].nodeval, Node_K_getline, yyvsp[0].nodeval);
		;
    break;}
case 114:
#line 565 "awk.y"
{ yyval.nodeval = yyvsp[0].nodeval; ;
    break;}
case 115:
#line 567 "awk.y"
{ yyval.nodeval = node((NODE *) NULL, Node_nomatch, yyvsp[0].nodeval); ;
    break;}
case 116:
#line 569 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, yyvsp[-1].nodetypeval, yyvsp[0].nodeval); ;
    break;}
case 117:
#line 571 "awk.y"
{ yyval.nodeval = node (variable(yyvsp[0].sval), Node_in_array, yyvsp[-2].nodeval); ;
    break;}
case 118:
#line 573 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, yyvsp[-1].nodetypeval, yyvsp[0].nodeval); ;
    break;}
case 119:
#line 575 "awk.y"
{ yyval.nodeval = node(yyvsp[-4].nodeval, Node_cond_exp, node(yyvsp[-2].nodeval, Node_if_branches, yyvsp[0].nodeval));;
    break;}
case 120:
#line 577 "awk.y"
{ yyval.nodeval = yyvsp[0].nodeval; ;
    break;}
case 121:
#line 579 "awk.y"
{ yyval.nodeval = node (yyvsp[-1].nodeval, Node_concat, yyvsp[0].nodeval); ;
    break;}
case 122:
#line 584 "awk.y"
{ yyval.nodeval = node (yyvsp[0].nodeval, Node_not,(NODE *) NULL); ;
    break;}
case 123:
#line 586 "awk.y"
{ yyval.nodeval = yyvsp[-1].nodeval; ;
    break;}
case 124:
#line 588 "awk.y"
{ yyval.nodeval = snode (yyvsp[-1].nodeval, Node_builtin, yyvsp[-3].ptrval); ;
    break;}
case 125:
#line 590 "awk.y"
{ yyval.nodeval = snode (yyvsp[-1].nodeval, Node_builtin, yyvsp[-3].ptrval); ;
    break;}
case 126:
#line 592 "awk.y"
{ yyval.nodeval = snode ((NODE *)NULL, Node_builtin, yyvsp[0].ptrval); ;
    break;}
case 127:
#line 594 "awk.y"
{
		yyval.nodeval = node (yyvsp[-1].nodeval, Node_func_call, make_string(yyvsp[-3].sval, strlen(yyvsp[-3].sval)));
	  ;
    break;}
case 128:
#line 598 "awk.y"
{ yyval.nodeval = node (yyvsp[0].nodeval, Node_preincrement, (NODE *)NULL); ;
    break;}
case 129:
#line 600 "awk.y"
{ yyval.nodeval = node (yyvsp[0].nodeval, Node_predecrement, (NODE *)NULL); ;
    break;}
case 130:
#line 602 "awk.y"
{ yyval.nodeval = node (yyvsp[-1].nodeval, Node_postincrement, (NODE *)NULL); ;
    break;}
case 131:
#line 604 "awk.y"
{ yyval.nodeval = node (yyvsp[-1].nodeval, Node_postdecrement, (NODE *)NULL); ;
    break;}
case 132:
#line 606 "awk.y"
{ yyval.nodeval = yyvsp[0].nodeval; ;
    break;}
case 133:
#line 608 "awk.y"
{ yyval.nodeval = yyvsp[0].nodeval; ;
    break;}
case 134:
#line 610 "awk.y"
{ yyval.nodeval = yyvsp[0].nodeval; ;
    break;}
case 135:
#line 614 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, Node_exp, yyvsp[0].nodeval); ;
    break;}
case 136:
#line 616 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, Node_times, yyvsp[0].nodeval); ;
    break;}
case 137:
#line 618 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, Node_quotient, yyvsp[0].nodeval); ;
    break;}
case 138:
#line 620 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, Node_mod, yyvsp[0].nodeval); ;
    break;}
case 139:
#line 622 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, Node_plus, yyvsp[0].nodeval); ;
    break;}
case 140:
#line 624 "awk.y"
{ yyval.nodeval = node (yyvsp[-2].nodeval, Node_minus, yyvsp[0].nodeval); ;
    break;}
case 141:
#line 626 "awk.y"
{ yyval.nodeval = node (yyvsp[0].nodeval, Node_unary_minus, (NODE *)NULL); ;
    break;}
case 142:
#line 628 "awk.y"
{ yyval.nodeval = yyvsp[0].nodeval; ;
    break;}
case 143:
#line 633 "awk.y"
{ yyval.nodeval = NULL; ;
    break;}
case 144:
#line 635 "awk.y"
{ yyval.nodeval = yyvsp[0].nodeval; ;
    break;}
case 145:
#line 640 "awk.y"
{ want_assign = 1; yyval.nodeval = variable (yyvsp[0].sval); ;
    break;}
case 146:
#line 642 "awk.y"
{ want_assign = 1; yyval.nodeval = node (variable(yyvsp[-3].sval), Node_subscript, yyvsp[-1].nodeval); ;
    break;}
case 147:
#line 644 "awk.y"
{ want_assign = 1; yyval.nodeval = node (yyvsp[0].nodeval, Node_field_spec, (NODE *)NULL); ;
    break;}
case 149:
#line 652 "awk.y"
{ yyerrok; ;
    break;}
case 150:
#line 656 "awk.y"
{ yyval.nodetypeval = Node_illegal; yyerrok; ;
    break;}
case 153:
#line 665 "awk.y"
{ yyerrok; ;
    break;}
case 154:
#line 668 "awk.y"
{ yyval.nodetypeval = Node_illegal; yyerrok; ;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */
#line 327 "bison.simple"

  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YYLSP_NEEDED
  yylsp -= yylen;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++yyvsp = yyval;

#ifdef YYLSP_NEEDED
  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = yylloc.first_line;
      yylsp->first_column = yylloc.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  goto yynewstate;

yyerrlab:   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++yynerrs;
      yyerror("parse error");
    }

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (yychar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
#endif

      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto yyerrhandle;

yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) goto yydefault;
#endif

yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YYLSP_NEEDED
  yylsp--;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yyerrdefault;

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  yystate = yyn;
  goto yynewstate;
}
#line 671 "awk.y"


struct token {
	char *operator;		/* text to match */
	NODETYPE value;		/* node type */
	int class;		/* lexical class */
	short nostrict;		/* ignore if in strict compatibility mode */
	NODE *(*ptr) ();	/* function that implements this keyword */
};

extern NODE
	*do_exp(),	*do_getline(),	*do_index(),	*do_length(),
	*do_sqrt(),	*do_log(),	*do_sprintf(),	*do_substr(),
	*do_split(),	*do_system(),	*do_int(),	*do_close(),
	*do_atan2(),	*do_sin(),	*do_cos(),	*do_rand(),
	*do_srand(),	*do_match(),	*do_tolower(),	*do_toupper(),
	*do_sub(),	*do_gsub();

/* Special functions for debugging */
#ifdef DEBUG
NODE *do_prvars(), *do_bp();
#endif

/* Tokentab is sorted ascii ascending order, so it can be binary searched. */

static struct token tokentab[] = {
	{ "BEGIN",	Node_illegal,		LEX_BEGIN,	0,	0 },
	{ "END",	Node_illegal,		LEX_END,	0,	0 },
	{ "atan2",	Node_builtin,		LEX_BUILTIN,	0,	do_atan2 },
#ifdef DEBUG
	{ "bp",		Node_builtin,		LEX_BUILTIN,	0,	do_bp },
#endif
	{ "break",	Node_K_break,		LEX_BREAK,	0,	0 },
	{ "close",	Node_builtin,		LEX_BUILTIN,	0,	do_close },
	{ "continue",	Node_K_continue,	LEX_CONTINUE,	0,	0 },
	{ "cos",	Node_builtin,		LEX_BUILTIN,	0,	do_cos },
	{ "delete",	Node_K_delete,		LEX_DELETE,	0,	0 },
	{ "do",		Node_K_do,		LEX_DO,		0,	0 },
	{ "else",	Node_illegal,		LEX_ELSE,	0,	0 },
	{ "exit",	Node_K_exit,		LEX_EXIT,	0,	0 },
	{ "exp",	Node_builtin,		LEX_BUILTIN,	0,	do_exp },
	{ "for",	Node_K_for,		LEX_FOR,	0,	0 },
	{ "func",	Node_K_function,	LEX_FUNCTION,	0,	0 },
	{ "function",	Node_K_function,	LEX_FUNCTION,	0,	0 },
	{ "getline",	Node_K_getline,		LEX_GETLINE,	0,	0 },
	{ "gsub",	Node_builtin,		LEX_BUILTIN,	0,	do_gsub },
	{ "if",		Node_K_if,		LEX_IF,		0,	0 },
	{ "in",		Node_illegal,		LEX_IN,		0,	0 },
	{ "index",	Node_builtin,		LEX_BUILTIN,	0,	do_index },
	{ "int",	Node_builtin,		LEX_BUILTIN,	0,	do_int },
	{ "length",	Node_builtin,		LEX_LENGTH,	0,	do_length },
	{ "log",	Node_builtin,		LEX_BUILTIN,	0,	do_log },
	{ "match",	Node_builtin,		LEX_BUILTIN,	0,	do_match },
	{ "next",	Node_K_next,		LEX_NEXT,	0,	0 },
	{ "print",	Node_K_print,		LEX_PRINT,	0,	0 },
	{ "printf",	Node_K_printf,		LEX_PRINTF,	0,	0 },
#ifdef DEBUG
	{ "prvars",	Node_builtin,		LEX_BUILTIN,	0,	do_prvars },
#endif
	{ "rand",	Node_builtin,		LEX_BUILTIN,	0,	do_rand },
	{ "return",	Node_K_return,		LEX_RETURN,	0,	0 },
	{ "sin",	Node_builtin,		LEX_BUILTIN,	0,	do_sin },
	{ "split",	Node_builtin,		LEX_BUILTIN,	0,	do_split },
	{ "sprintf",	Node_builtin,		LEX_BUILTIN,	0,	do_sprintf },
	{ "sqrt",	Node_builtin,		LEX_BUILTIN,	0,	do_sqrt },
	{ "srand",	Node_builtin,		LEX_BUILTIN,	0,	do_srand },
	{ "sub",	Node_builtin,		LEX_BUILTIN,	0,	do_sub },
	{ "substr",	Node_builtin,		LEX_BUILTIN,	0,	do_substr },
	{ "system",	Node_builtin,		LEX_BUILTIN,	0,	do_system },
	{ "tolower",	Node_builtin,		LEX_BUILTIN,	0,	do_tolower },
	{ "toupper",	Node_builtin,		LEX_BUILTIN,	0,	do_toupper },
	{ "while",	Node_K_while,		LEX_WHILE,	0,	0 },
};

static char *token_start;

/* VARARGS0 */
static void
yyerror(va_alist)
va_dcl
{
	va_list args;
	char *mesg;
	register char *ptr, *beg;
	char *scan;

	errcount++;
	va_start(args);
	mesg = va_arg(args, char *);
	va_end(args);
	/* Find the current line in the input file */
	if (! lexptr) {
		beg = "(END OF FILE)";
		ptr = beg + 13;
	} else {
		if (*lexptr == '\n' && lexptr != lexptr_begin)
			--lexptr;
		for (beg = lexptr; beg != lexptr_begin && *beg != '\n'; --beg)
			;
		/* NL isn't guaranteed */
		for (ptr = lexptr; *ptr && *ptr != '\n'; ptr++)
			;
		if (beg != lexptr_begin)
			beg++;
	}
	msg("syntax error near line %d:\n%.*s", lineno, ptr - beg, beg);
	scan = beg;
	while (scan < token_start)
		if (*scan++ == '\t')
			putc('\t', stderr);
		else
			putc(' ', stderr);
	putc('^', stderr);
	putc(' ', stderr);
	vfprintf(stderr, mesg, args);
	putc('\n', stderr);
	exit(1);
}

/*
 * Parse a C escape sequence.  STRING_PTR points to a variable containing a
 * pointer to the string to parse.  That pointer is updated past the
 * characters we use.  The value of the escape sequence is returned. 
 *
 * A negative value means the sequence \ newline was seen, which is supposed to
 * be equivalent to nothing at all. 
 *
 * If \ is followed by a null character, we return a negative value and leave
 * the string pointer pointing at the null character. 
 *
 * If \ is followed by 000, we return 0 and leave the string pointer after the
 * zeros.  A value of 0 does not mean end of string.  
 */

int
parse_escape(string_ptr)
char **string_ptr;
{
	register int c = *(*string_ptr)++;
	register int i;
	register int count = 0;

	switch (c) {
	case 'a':
		return BELL;
	case 'b':
		return '\b';
	case 'f':
		return '\f';
	case 'n':
		return '\n';
	case 'r':
		return '\r';
	case 't':
		return '\t';
	case 'v':
		return '\v';
	case '\n':
		return -2;
	case 0:
		(*string_ptr)--;
		return -1;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
		i = c - '0';
		count = 0;
		while (++count < 3) {
			if ((c = *(*string_ptr)++) >= '0' && c <= '7') {
				i *= 8;
				i += c - '0';
			} else {
				(*string_ptr)--;
				break;
			}
		}
		return i;
	case 'x':
		i = 0;
		while (1) {
			if (isxdigit((c = *(*string_ptr)++))) {
				if (isdigit(c))
					i += c - '0';
				else if (isupper(c))
					i += c - 'A' + 10;
				else
					i += c - 'a' + 10;
			} else {
				(*string_ptr)--;
				break;
			}
		}
		return i;
	default:
		return c;
	}
}

/*
 * Read the input and turn it into tokens. Input is now read from a file
 * instead of from malloc'ed memory. The main program takes a program
 * passed as a command line argument and writes it to a temp file. Otherwise
 * the file name is made available in an external variable.
 */

static int
yylex()
{
	register int c;
	register int namelen;
	register char *tokstart;
	char *tokkey;
	static did_newline = 0;	/* the grammar insists that actions end
				 * with newlines.  This was easier than
				 * hacking the grammar. */
	int seen_e = 0;		/* These are for numbers */
	int seen_point = 0;
	int esc_seen;
	extern char **sourcefile;
	extern int tempsource, numfiles;
	static int file_opened = 0;
	static FILE *fin;
	static char cbuf[BUFSIZ];
	int low, mid, high;
#ifdef DEBUG
	extern int debugging;
#endif

	if (! file_opened) {
		file_opened = 1;
#ifdef DEBUG
		if (debugging) {
			int i;

			for (i = 0; i <= numfiles; i++)
				fprintf (stderr, "sourcefile[%d] = %s\n", i,
						sourcefile[i]);
		}
#endif
	nextfile:
		if ((fin = pathopen (sourcefile[++curinfile])) == NULL)
			fatal("cannot open `%s' for reading (%s)",
				sourcefile[curinfile],
				strerror(errno));
		*(lexptr = cbuf) = '\0';
		/*
		 * immediately unlink the tempfile so that it will
		 * go away cleanly if we bomb.
		 */
		if (tempsource && curinfile == 0)
			(void) unlink (sourcefile[curinfile]);
	}

retry:
	if (! *lexptr)
		if (fgets (cbuf, sizeof cbuf, fin) == NULL) {
			if (fin != NULL)
				fclose (fin);	/* be neat and clean */
			if (curinfile < numfiles)
				goto nextfile;
			return 0;
		} else
			lexptr = lexptr_begin = cbuf;

	if (want_regexp) {
		int in_brack = 0;

		want_regexp = 0;
		token_start = tokstart = lexptr;
		while (c = *lexptr++) {
			switch (c) {
			case '[':
				in_brack = 1;
				break;
			case ']':
				in_brack = 0;
				break;
			case '\\':
				if (*lexptr++ == '\0') {
					yyerror("unterminated regexp ends with \\");
					return ERROR;
				} else if (lexptr[-1] == '\n')
					goto retry;
				break;
			case '/':	/* end of the regexp */
				if (in_brack)
					break;

				lexptr--;
				yylval.sval = tokstart;
				return REGEXP;
			case '\n':
				lineno++;
			case '\0':
				lexptr--;	/* so error messages work */
				yyerror("unterminated regexp");
				return ERROR;
			}
		}
	}

	if (*lexptr == '\n') {
		lexptr++;
		lineno++;
		return NEWLINE;
	}

	while (*lexptr == ' ' || *lexptr == '\t')
		lexptr++;

	token_start = tokstart = lexptr;

	switch (c = *lexptr++) {
	case 0:
		return 0;

	case '\n':
		lineno++;
		return NEWLINE;

	case '#':		/* it's a comment */
		while (*lexptr != '\n' && *lexptr != '\0')
			lexptr++;
		goto retry;

	case '\\':
		if (*lexptr == '\n') {
			lineno++;
			lexptr++;
			goto retry;
		} else
			break;
	case ')':
	case ']':
	case '(':	
	case '[':
	case '$':
	case ';':
	case ':':
	case '?':

		/*
		 * set node type to ILLEGAL because the action should set it
		 * to the right thing 
		 */
		yylval.nodetypeval = Node_illegal;
		return c;

	case '{':
	case ',':
		yylval.nodetypeval = Node_illegal;
		return c;

	case '*':
		if (*lexptr == '=') {
			yylval.nodetypeval = Node_assign_times;
			lexptr++;
			return ASSIGNOP;
		} else if (*lexptr == '*') {	/* make ** and **= aliases
						 * for ^ and ^= */
			if (lexptr[1] == '=') {
				yylval.nodetypeval = Node_assign_exp;
				lexptr += 2;
				return ASSIGNOP;
			} else {
				yylval.nodetypeval = Node_illegal;
				lexptr++;
				return '^';
			}
		}
		yylval.nodetypeval = Node_illegal;
		return c;

	case '/':
		if (want_assign && *lexptr == '=') {
			yylval.nodetypeval = Node_assign_quotient;
			lexptr++;
			return ASSIGNOP;
		}
		yylval.nodetypeval = Node_illegal;
		return c;

	case '%':
		if (*lexptr == '=') {
			yylval.nodetypeval = Node_assign_mod;
			lexptr++;
			return ASSIGNOP;
		}
		yylval.nodetypeval = Node_illegal;
		return c;

	case '^':
		if (*lexptr == '=') {
			yylval.nodetypeval = Node_assign_exp;
			lexptr++;
			return ASSIGNOP;
		}
		yylval.nodetypeval = Node_illegal;
		return c;

	case '+':
		if (*lexptr == '=') {
			yylval.nodetypeval = Node_assign_plus;
			lexptr++;
			return ASSIGNOP;
		}
		if (*lexptr == '+') {
			yylval.nodetypeval = Node_illegal;
			lexptr++;
			return INCREMENT;
		}
		yylval.nodetypeval = Node_illegal;
		return c;

	case '!':
		if (*lexptr == '=') {
			yylval.nodetypeval = Node_notequal;
			lexptr++;
			return RELOP;
		}
		if (*lexptr == '~') {
			yylval.nodetypeval = Node_nomatch;
			lexptr++;
			return MATCHOP;
		}
		yylval.nodetypeval = Node_illegal;
		return c;

	case '<':
		if (*lexptr == '=') {
			yylval.nodetypeval = Node_leq;
			lexptr++;
			return RELOP;
		}
		yylval.nodetypeval = Node_less;
		return c;

	case '=':
		if (*lexptr == '=') {
			yylval.nodetypeval = Node_equal;
			lexptr++;
			return RELOP;
		}
		yylval.nodetypeval = Node_assign;
		return ASSIGNOP;

	case '>':
		if (*lexptr == '=') {
			yylval.nodetypeval = Node_geq;
			lexptr++;
			return RELOP;
		} else if (*lexptr == '>') {
			yylval.nodetypeval = Node_redirect_append;
			lexptr++;
			return APPEND_OP;
		}
		yylval.nodetypeval = Node_greater;
		return c;

	case '~':
		yylval.nodetypeval = Node_match;
		return MATCHOP;

	case '}':
		/*
		 * Added did newline stuff.  Easier than
		 * hacking the grammar
		 */
		if (did_newline) {
			did_newline = 0;
			return c;
		}
		did_newline++;
		--lexptr;
		return NEWLINE;

	case '"':
		esc_seen = 0;
		while (*lexptr != '\0') {
			switch (*lexptr++) {
			case '\\':
				esc_seen = 1;
				if (*lexptr == '\n')
					yyerror("newline in string");
				if (*lexptr++ != '\0')
					break;
				/* fall through */
			case '\n':
				lexptr--;
				yyerror("unterminated string");
				return ERROR;
			case '"':
				yylval.nodeval = make_str_node(tokstart + 1,
						lexptr-tokstart-2, esc_seen);
				yylval.nodeval->flags |= PERM;
				return YSTRING;
			}
		}
		return ERROR;

	case '-':
		if (*lexptr == '=') {
			yylval.nodetypeval = Node_assign_minus;
			lexptr++;
			return ASSIGNOP;
		}
		if (*lexptr == '-') {
			yylval.nodetypeval = Node_illegal;
			lexptr++;
			return DECREMENT;
		}
		yylval.nodetypeval = Node_illegal;
		return c;

	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case '.':
		/* It's a number */
		for (namelen = 0; (c = tokstart[namelen]) != '\0'; namelen++) {
			switch (c) {
			case '.':
				if (seen_point)
					goto got_number;
				++seen_point;
				break;
			case 'e':
			case 'E':
				if (seen_e)
					goto got_number;
				++seen_e;
				if (tokstart[namelen + 1] == '-' ||
				    tokstart[namelen + 1] == '+')
					namelen++;
				break;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				break;
			default:
				goto got_number;
			}
		}

got_number:
		lexptr = tokstart + namelen;
		/*
		yylval.nodeval = make_string(tokstart, namelen);
		(void) force_number(yylval.nodeval);
		*/
		yylval.nodeval = make_number(atof(tokstart));
		yylval.nodeval->flags |= PERM;
		return NUMBER;

	case '&':
		if (*lexptr == '&') {
			yylval.nodetypeval = Node_and;
			while (c = *++lexptr) {
				if (c == '#')
					while ((c = *++lexptr) != '\n'
					       && c != '\0')
						;
				if (c == '\n')
					lineno++;
				else if (! isspace(c))
					break;
			}
			return LEX_AND;
		}
		return ERROR;

	case '|':
		if (*lexptr == '|') {
			yylval.nodetypeval = Node_or;
			while (c = *++lexptr) {
				if (c == '#')
					while ((c = *++lexptr) != '\n'
					       && c != '\0')
						;
				if (c == '\n')
					lineno++;
				else if (! isspace(c))
					break;
			}
			return LEX_OR;
		}
		yylval.nodetypeval = Node_illegal;
		return c;
	}

	if (c != '_' && ! isalpha(c)) {
		yyerror("Invalid char '%c' in expression\n", c);
		return ERROR;
	}

	/* it's some type of name-type-thing.  Find its length */
	for (namelen = 0; is_identchar(tokstart[namelen]); namelen++)
		/* null */ ;
	emalloc(tokkey, char *, namelen+1, "yylex");
	memcpy(tokkey, tokstart, namelen);
	tokkey[namelen] = '\0';

	/* See if it is a special token.  */
	low = 0;
	high = (sizeof (tokentab) / sizeof (tokentab[0])) - 1;
	while (low <= high) {
		int i, c;

		mid = (low + high) / 2;
		c = *tokstart - tokentab[mid].operator[0];
		i = c ? c : strcmp (tokkey, tokentab[mid].operator);

		if (i < 0) {		/* token < mid */
			high = mid - 1;
		} else if (i > 0) {	/* token > mid */
			low = mid + 1;
		} else {
			lexptr = tokstart + namelen;
			if (strict && tokentab[mid].nostrict)
				break;
			if (tokentab[mid].class == LEX_BUILTIN
			    || tokentab[mid].class == LEX_LENGTH)
				yylval.ptrval = tokentab[mid].ptr;
			else
				yylval.nodetypeval = tokentab[mid].value;
			return tokentab[mid].class;
		}
	}

	/* It's a name.  See how long it is.  */
	yylval.sval = tokkey;
	lexptr = tokstart + namelen;
	if (*lexptr == '(')
		return FUNC_CALL;
	else
		return NAME;
}

#ifndef DEFPATH
#ifdef MSDOS
#define DEFPATH	"."
#define ENVSEP	';'
#else
#define DEFPATH	".:/usr/lib/awk:/usr/local/lib/awk"
#define ENVSEP	':'
#endif
#endif

static FILE *
pathopen (file)
char *file;
{
	static char *savepath = DEFPATH;
	static int first = 1;
	char *awkpath, *cp;
	char trypath[BUFSIZ];
	FILE *fp;
#ifdef DEBUG
	extern int debugging;
#endif
	int fd;

	if (strcmp (file, "-") == 0)
		return (stdin);

	if (strict)
		return (fopen (file, "r"));

	if (first) {
		first = 0;
		if ((awkpath = getenv ("AWKPATH")) != NULL && *awkpath)
			savepath = awkpath;	/* used for restarting */
	}
	awkpath = savepath;

	/* some kind of path name, no search */
#ifndef MSDOS
	if (strchr (file, '/') != NULL)
#else
	if (strchr (file, '/') != NULL || strchr (file, '\\') != NULL
			|| strchr (file, ':') != NULL)
#endif
		return ( (fd = devopen (file, "r")) >= 0 ?
				fdopen(fd, "r") :
				NULL);

	do {
		trypath[0] = '\0';
		/* this should take into account limits on size of trypath */
		for (cp = trypath; *awkpath && *awkpath != ENVSEP; )
			*cp++ = *awkpath++;

		if (cp != trypath) {	/* nun-null element in path */
			*cp++ = '/';
			strcpy (cp, file);
		} else
			strcpy (trypath, file);
#ifdef DEBUG
		if (debugging)
			fprintf(stderr, "trying: %s\n", trypath);
#endif
		if ((fd = devopen (trypath, "r")) >= 0
		    && (fp = fdopen(fd, "r")) != NULL)
			return (fp);

		/* no luck, keep going */
		if(*awkpath == ENVSEP && awkpath[1] != '\0')
			awkpath++;	/* skip colon */
	} while (*awkpath);
#ifdef MSDOS
	/*
	 * Under DOS (and probably elsewhere) you might have one of the awk
	 * paths defined, WITHOUT the current working directory in it.
	 * Therefore you should try to open the file in the current directory.
	 */
	return ( (fd = devopen(file, "r")) >= 0 ? fdopen(fd, "r") : NULL);
#else
	return (NULL);
#endif
}

static NODE *
node_common(op)
NODETYPE op;
{
	register NODE *r;
	extern int numfiles;
	extern int tempsource;
	extern char **sourcefile;

	r = newnode(op);
	r->source_line = lineno;
	if (numfiles > -1 && ! tempsource)
		r->source_file = sourcefile[curinfile];
	else
		r->source_file = NULL;
	return r;
}

/*
 * This allocates a node with defined lnode and rnode. 
 * This should only be used by yyparse+co while reading in the program 
 */
NODE *
node(left, op, right)
NODE *left, *right;
NODETYPE op;
{
	register NODE *r;

	r = node_common(op);
	r->lnode = left;
	r->rnode = right;
	return r;
}

/*
 * This allocates a node with defined subnode and proc
 * Otherwise like node()
 */
static NODE *
snode(subn, op, procp)
NODETYPE op;
NODE *(*procp) ();
NODE *subn;
{
	register NODE *r;

	r = node_common(op);
	r->subnode = subn;
	r->proc = procp;
	return r;
}

/*
 * This allocates a Node_line_range node with defined condpair and
 * zeroes the trigger word to avoid the temptation of assuming that calling
 * 'node( foo, Node_line_range, 0)' will properly initialize 'triggered'. 
 */
/* Otherwise like node() */
static NODE *
mkrangenode(cpair)
NODE *cpair;
{
	register NODE *r;

	r = newnode(Node_line_range);
	r->condpair = cpair;
	r->triggered = 0;
	return r;
}

/* Build a for loop */
static NODE *
make_for_loop(init, cond, incr)
NODE *init, *cond, *incr;
{
	register FOR_LOOP_HEADER *r;
	NODE *n;

	emalloc(r, FOR_LOOP_HEADER *, sizeof(FOR_LOOP_HEADER), "make_for_loop");
	n = newnode(Node_illegal);
	r->init = init;
	r->cond = cond;
	r->incr = incr;
	n->sub.nodep.r.hd = r;
	return n;
}

/*
 * Install a name in the hash table specified, even if it is already there.
 * Name stops with first non alphanumeric. Caller must check against
 * redefinition if that is desired. 
 */
NODE *
install(table, name, value)
NODE **table;
char *name;
NODE *value;
{
	register NODE *hp;
	register int len, bucket;
	register char *p;

	len = 0;
	p = name;
	while (is_identchar(*p))
		p++;
	len = p - name;

	hp = newnode(Node_hashnode);
	bucket = hashf(name, len, HASHSIZE);
	hp->hnext = table[bucket];
	table[bucket] = hp;
	hp->hlength = len;
	hp->hvalue = value;
	emalloc(hp->hname, char *, len + 1, "install");
	memcpy(hp->hname, name, len);
	hp->hname[len] = '\0';
	return hp->hvalue;
}

/*
 * find the most recent hash node for name name (ending with first
 * non-identifier char) installed by install 
 */
NODE *
lookup(table, name)
NODE **table;
char *name;
{
	register char *bp;
	register NODE *bucket;
	register int len;

	for (bp = name; is_identchar(*bp); bp++)
		;
	len = bp - name;
	bucket = table[hashf(name, len, HASHSIZE)];
	while (bucket) {
		if (bucket->hlength == len && STREQN(bucket->hname, name, len))
			return bucket->hvalue;
		bucket = bucket->hnext;
	}
	return NULL;
}

#define HASHSTEP(old, c) ((old << 1) + c)
#define MAKE_POS(v) (v & ~0x80000000)	/* make number positive */

/*
 * return hash function on name.
 */
static int
hashf(name, len, hashsize)
register char *name;
register int len;
int hashsize;
{
	register int r = 0;

	while (len--)
		r = HASHSTEP(r, *name++);

	r = MAKE_POS(r) % hashsize;
	return r;
}

/*
 * Add new to the rightmost branch of LIST.  This uses n^2 time, so we make
 * a simple attempt at optimizing it.
 */
static NODE *
append_right(list, new)
NODE *list, *new;

{
	register NODE *oldlist;
	static NODE *savefront = NULL, *savetail = NULL;

	oldlist = list;
	if (savefront == oldlist) {
		savetail = savetail->rnode = new;
		return oldlist;
	} else
		savefront = oldlist;
	while (list->rnode != NULL)
		list = list->rnode;
	savetail = list->rnode = new;
	return oldlist;
}

/*
 * check if name is already installed;  if so, it had better have Null value,
 * in which case def is added as the value. Otherwise, install name with def
 * as value. 
 */
static void
func_install(params, def)
NODE *params;
NODE *def;
{
	NODE *r;

	pop_params(params->rnode);
	pop_var(params, 0);
	r = lookup(variables, params->param);
	if (r != NULL) {
		fatal("function name `%s' previously defined", params->param);
	} else
		(void) install(variables, params->param,
			node(params, Node_func, def));
}

static void
pop_var(np, freeit)
NODE *np;
int freeit;
{
	register char *bp;
	register NODE *bucket, **save;
	register int len;
	char *name;

	name = np->param;
	for (bp = name; is_identchar(*bp); bp++)
		;
	len = bp - name;
	save = &(variables[hashf(name, len, HASHSIZE)]);
	for (bucket = *save; bucket; bucket = bucket->hnext) {
		if (len == bucket->hlength && STREQN(bucket->hname, name, len)) {
			*save = bucket->hnext;
			freenode(bucket);
			free(bucket->hname);
			if (freeit)
				free(np->param);
			return;
		}
		save = &(bucket->hnext);
	}
}

static void
pop_params(params)
NODE *params;
{
	register NODE *np;

	for (np = params; np != NULL; np = np->rnode)
		pop_var(np, 1);
}

static NODE *
make_param(name)
char *name;
{
	NODE *r;

	r = newnode(Node_param_list);
	r->param = name;
	r->rnode = NULL;
	r->param_cnt = param_counter++;
	return (install(variables, name, r));
}

/* Name points to a variable name.  Make sure its in the symbol table */
NODE *
variable(name)
char *name;
{
	register NODE *r;

	if ((r = lookup(variables, name)) == NULL)
		r = install(variables, name,
			node(Nnull_string, Node_var, (NODE *) NULL));
	return r;
}
