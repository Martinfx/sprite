head     1.19;
branch   ;
access   ;
symbols  ;
locks    shirriff:1.19; strict;
comment  @ * @;


1.19
date     92.11.04.16.53.31;  author jhh;  state Exp;
branches ;
next     1.18;

1.18
date     90.11.01.23.24.48;  author jhh;  state Exp;
branches ;
next     1.17;

1.17
date     90.10.10.15.59.33;  author rab;  state Exp;
branches ;
next     1.16;

1.16
date     90.09.12.08.47.49;  author jhh;  state Exp;
branches ;
next     1.15;

1.15
date     90.02.16.16.14.31;  author jhh;  state Exp;
branches ;
next     1.14;

1.14
date     89.10.03.13.13.03;  author jhh;  state Exp;
branches 1.14.1.1;
next     1.13;

1.13
date     89.08.29.17.12.52;  author jhh;  state Exp;
branches ;
next     1.12;

1.12
date     89.08.29.17.03.06;  author jhh;  state Exp;
branches ;
next     1.11;

1.11
date     89.08.25.11.33.54;  author jhh;  state Exp;
branches ;
next     1.10;

1.10
date     89.08.15.16.06.57;  author jhh;  state Exp;
branches ;
next     1.9;

1.9
date     89.07.13.10.44.59;  author jhh;  state Exp;
branches ;
next     1.8;

1.8
date     89.06.16.08.46.10;  author brent;  state Exp;
branches ;
next     1.7;

1.7
date     89.05.22.15.15.19;  author jhh;  state Exp;
branches ;
next     1.6;

1.6
date     89.03.03.17.08.18;  author jhh;  state Exp;
branches ;
next     1.5;

1.5
date     89.01.26.11.02.18;  author jhh;  state Exp;
branches ;
next     1.4;

1.4
date     89.01.25.13.39.46;  author jhh;  state Exp;
branches ;
next     1.3;

1.3
date     89.01.06.08.16.54;  author brent;  state Exp;
branches ;
next     1.2;

1.2
date     88.03.31.10.09.00;  author brent;  state Exp;
branches ;
next     1.1;

1.1
date     87.10.20.11.01.23;  author brent;  state Exp;
branches ;
next     ;

1.14.1.1
date     90.07.02.22.15.18;  author jhh;  state Exp;
branches ;
next     ;


desc
@Make a filesystem on a disk
@


1.19
log
@didn't lay things out properly on small disks
@
text
@/* 
 * fsmake.c --
 *
 *	Format a domain to be an empty domain.
 *
 * Copyright (C) 1986 Regents of the University of California
 * All rights reserved.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/admin/fsmake/RCS/fsmake.c,v 1.18 90/11/01 23:24:48 jhh Exp $ SPRITE (Berkeley)";
#endif

#include "fsmake.h"
#include <assert.h>

/*
 * Constants settable via the command line.
 */
static int kbytesToFileDesc = 4;/* The ratio of kbytes to
				 * the number of file descriptors */
Boolean printOnly = TRUE;       /* Stop after computing the domain header
				 * and just print it out. No disk writes */
static Boolean overlapBlocks = FALSE;
                                /* Allow filesystem blocks to overlap track
				 * boundaries.  Some disk systems can't deal. */
static Boolean scsiDisk = TRUE;	/* If TRUE then simpler geometry is computed
				 * that knows that SCSI controllers don't
				 * think in terms of cylinders, heads, and
				 * sectors.  Instead, they think in terms of
				 * logical sector numbers, so we punt on finding
				 * rotationally optimal block positions. */
static int bootSectors = -1;	/* Number of boot sectors. */
static int hostID = 0;		/* Host id to write into domain header. 
				 * A host id of 0 means use local host id. */
static Boolean repartition = FALSE;
                                /* If TRUE then the partition map is changed. */
static Boolean reconfig = FALSE;	/* If TRUE then the disk configuration
				 * is changed. */
static Boolean partdisktab = FALSE;
                                /* If TRUE then read the partition map from
				 * the disktab file. */
static Boolean configdisktab = FALSE;
                                /* If TRUE then read the config information
				 * from the disktab file, otherwise get the
				 * disk size information directly from the
				 * disk and compute the "best" configuration..*/
static char *disktabName = "/etc/disktab"; /* Name of disktab file. */
static char *sizeString = NULL;	/* Size of partitions. */
static char *diskType = NULL;	/* Type of disk (e.g.rz55). */
static char *labelTypeName = NULL; /* Type of label (e.g. sun). */
static char *dirName = NULL;	/* Name of directory that contains files to
				 * copy to the disk. */
extern char *hostFileName;      /* Name of file to get host info from.  By
                                   default it is /etc/spritehosts.  It is 
				   defined in Host_Start.c. */

/*
 * The following are used to go from a command line like
 * makeFilesystem -D rsd0 -P b
 * to /dev/rsd0a 	- for the partition that has the disk label
 * and to /dev/rsd0b	- for the partition to format.
 */
static char *deviceName;	/* Set to "rsd0" or "rxy1", etc. */
static char *partName;		/* Set to "a", "b", "c" ... "g" */
static char *rawDeviceName;	/* Set to "raw_rsd00", etc */
static char defaultFirstPartName[] = "a";
static char *firstPartName = defaultFirstPartName;
static char defaultDevDirectory[] = "/dev";
static char *devDirectory = defaultDevDirectory;

static char *hostIDString = NULL;

static Option optionArray[] = {
    {OPT_STRING, "dev", (Address)&deviceName,
	"Required: Name of device, eg \"rsd0\" or \"rxy1\""},
    {OPT_STRING, "part", (Address)&partName,
	"Required: Partition ID: (a, b, c, d, e, f, g)"},
    {OPT_STRING, "rawdev", (Address)&rawDeviceName,
	"Required: Name of raw device, eg \"raw_rsd00\""},
    {OPT_TRUE, "scsi", (Address)&scsiDisk,
	"Compute geometry for SCSI type disk (TRUE)"},
    {OPT_FALSE, "noscsi", (Address)&scsiDisk,
	"Compute geometry for non-SCSI disk (FALSE)"},
    {OPT_TRUE, "overlap", (Address)&overlapBlocks,
	"Overlap filesystem blocks across track boundaries (FALSE)"},
    {OPT_INT, "ratio", (Address)&kbytesToFileDesc,
	"Ratio of Kbytes to file descriptors (4)"},
    {OPT_TRUE, "test", (Address)&printOnly,
	"Test: print results, don't write disk (TRUE)"},
    {OPT_FALSE, "write", (Address)&printOnly,
	"Write the disk (FALSE)"},
    {OPT_STRING, "devDir", (Address)&devDirectory,
	"Name of device directory (\"/dev\")"},
    {OPT_STRING, "initialPart", (Address)&firstPartName,
	"Name of initial partition (\"a\")"},
    {OPT_INT, "boot", (Address)&bootSectors,
	"Number of boot sectors in root partition"},
    {OPT_STRING, "host", (Address)&hostIDString,
	"Host id or name of machine domain is attached to."},
    {OPT_TRUE, "repartition", (Address)&repartition,
	"Change the partitioning of the disk.  USE ONLY ON EMPTY DISKS"},
    {OPT_TRUE, "reconfig", (Address) &reconfig,
	"Change the disk configuration info in label. USE ONLY ON EMPTY DISKS"},
    {OPT_TRUE, "configdisktab", (Address)&configdisktab,
	"Reconfigure according to info in disktab file"},
    {OPT_TRUE, "partdisktab", (Address)&partdisktab,
	"Repartition according to info in disktab file"},
    {OPT_STRING, "disktabName", (Address)&disktabName,
	"Name of the disktab file"},
    {OPT_STRING, "sizes", (Address)&sizeString,
	"Size of partitions (as a percentage), eg \"a:25,g:75\""},
    {OPT_STRING, "disktype", (Address)&diskType,
	"Type of disk. Used to look up information in disktab file"},
    {OPT_STRING, "labeltype", (Address)&labelTypeName,
	"Type of native disk label (sun or dec)"},
    {OPT_STRING, "dir", (Address)&dirName,
	"Directory to copy files from"},
    {OPT_STRING, "spritehosts", (Address)&hostFileName,
        "File to get host information from"},
};
#define numOptions (sizeof(optionArray) / sizeof(Option))

/*
 * Time of day when this program runs.
 */

static struct timeval curTime;

static int		freeFDNum;	/* The currently free file descriptor.*/
static int		freeBlockNum;	/* The currently free data block. */
static unsigned char	*fdBitmapPtr;	/* Pointer to the file descriptor
					 * bitmap. */
static unsigned char	*cylBitmapPtr;	/* Pointer to the cylinder bit map. */
static int	        bytesPerCylinder;/* The number of bytes in
					  * the bitmap for a cylinder.*/
static Ofs_DomainHeader *headerPtr;	/* The domain header. */
static Ofs_SummaryInfo *summaryPtr;	/* The summary info. */

static char *myName;
/*
 * Forward Declarations.
 */

static void Usage _ARGS_((void));
static ReturnStatus MakeFilesystem _ARGS_((int firstPartFID, int partFID,
    int partition, int spriteID, Disk_Label **labelPtrPtr));
static void CopyTree _ARGS_((int partFID, char *dirName, int dirFDNum,
    Fsdm_FileDescriptor *dirFDPtr, int parentFDNum,
    Boolean createDir, char *path));
static ReturnStatus SetDomainHeader _ARGS_((Disk_Label *labelPtr,
    Ofs_DomainHeader *headerPtr, int spriteID, int partition));
static void SetSCSIDiskGeometry _ARGS_((Disk_Label *labelPtr,
    Ofs_Geometry *geoPtr));
static void SetDiskGeometry _ARGS_((Disk_Label *labelPtr,
    Ofs_Geometry *geoPtr));
static void SetDomainParts _ARGS_((Disk_Label *labelPtr, int partition,
    Ofs_DomainHeader *headerPtr));
static void SetSummaryInfo _ARGS_((Ofs_DomainHeader *headerPtr,
    Ofs_SummaryInfo *summaryPtr));
static ReturnStatus WriteAllFileDescs _ARGS_((int partFID,
    Ofs_DomainHeader *headerPtr));
static char *MakeFileDescBitmap _ARGS_((Ofs_DomainHeader *headerPtr));
static ReturnStatus WriteBitmap _ARGS_((int partFID,
    Ofs_DomainHeader *headerPtr));
static ReturnStatus WriteRootDirectory _ARGS_((int partFID,
    Ofs_DomainHeader *headerPtr, Fsdm_FileDescriptor *fdPtr));
static ReturnStatus WriteLostFoundDirectory _ARGS_((int partFID,
    Ofs_DomainHeader *headerPtr));
static void InitDesc _ARGS_((Fsdm_FileDescriptor *fileDescPtr, int fileType,
    int numBytes, int devServer, int devType, int devUnit,
    int uid, int gid, int permissions, long time));
static ReturnStatus AddToDirectory _ARGS_((int fid,
    Ofs_DomainHeader *headerPtr, Boolean writeDisk, DirIndexInfo *dirIndexPtr,
    Fslcl_DirEntry **dirEntryPtrPtr, int fileNumber, char *fileName));
static ReturnStatus OpenDir _ARGS_((int fid, Ofs_DomainHeader *headerPtr,
    Fsdm_FileDescriptor *fdPtr, DirIndexInfo *indexInfoPtr,
    Fslcl_DirEntry **dirEntryPtrPtr));
static ReturnStatus NextDirEntry _ARGS_((int fid, Ofs_DomainHeader *headerPtr,
    Boolean writeDisk, DirIndexInfo *indexInfoPtr,
    Fslcl_DirEntry **dirEntryPtrPtr));
static ReturnStatus CloseDir _ARGS_((int fid, Ofs_DomainHeader *headerPtr,
    Boolean writeDisk, DirIndexInfo *indexInfoPtr));
static ReturnStatus ReadFileDesc _ARGS_((int fid, Ofs_DomainHeader *headerPtr,
    int fdNum, Fsdm_FileDescriptor *fdPtr));
static ReturnStatus WriteFileDesc _ARGS_((int fid, Ofs_DomainHeader *headerPtr,
    int fdNum, Fsdm_FileDescriptor *fdPtr));
static void CreateDir _ARGS_((Address blocks, int numBlocks,
    int dot, int dotDot));
static void MarkDataBitmap _ARGS_((Ofs_DomainHeader *headerPtr,
    unsigned char *cylBitmapPtr, int blockNum, int numFrags));
static unsigned char *ReadFileDescBitmap _ARGS_((int fid,
    Ofs_DomainHeader *headerPtr));
static unsigned char *ReadBitmap _ARGS_((int fid,
    Ofs_DomainHeader *headerPtr));
static void WriteFileDescBitmap _ARGS_((int fid, Ofs_DomainHeader *headerPtr,
    unsigned char *bitmap));

extern char *getwd();


/*
 *----------------------------------------------------------------------
 *
 * main --
 *
 *	Create the required file names from the command line
 *	arguments.  Then open the first partition on the disk
 *	because it contains the disk label, and open the partition
 *	that is to be formatted.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Calls MakeFilesystem
 *
 *----------------------------------------------------------------------
 */
void
main(argc, argv)
    int argc;
    char *argv[];
{
    ReturnStatus status;	/* status of system calls */
    int firstPartFID;		/* File ID for first parition on the disk */
    int partFID;		/* File ID for partiton to format */
    int rawFID = -1;
    char firstPartitionName[64];
    char partitionName[64];
    int partition;		/* Index of partition derived from the
				 * partition name */
    int spriteID;		/* Host ID of the machine with the disks */
    Fs_Attributes attrs;
    Disk_NativeLabelType	labelType;	
    Disk_Label			*labelPtr = NULL;
    int	sizes[8];
    int i;

    myName = argv[0];
    argc = Opt_Parse(argc, argv,optionArray, numOptions, 0);
    if (argc > 1) {
	Usage();
    }
    status = SUCCESS;
    if (deviceName == (char *)0) {
	fprintf(stderr,"Specify device name with -dev option\n");
	status = FAILURE;
    }
    if (partName == (char *)0) {
	fprintf(stderr,"Specify partition with -part option\n");
	status = FAILURE;
    }
    if (bootSectors > FSDM_MAX_BOOT_SECTORS) {
	fprintf(stderr,"Maximum number of boot sectors is %d.\n", 
	    FSDM_MAX_BOOT_SECTORS);
	status = FAILURE;
    }
    if ((bootSectors != -1) && (bootSectors % FSDM_BOOT_SECTOR_INC != 0)) {
	fprintf(stderr, "Number of boot sectors must be a multiple of %d.\n",
	    FSDM_BOOT_SECTOR_INC);
	status = FAILURE;
    }
    for (i = 0; i < 8; i++) {
	sizes[i] = 0;
    }
    if (sizeString != NULL) {
	char *cPtr;
	int part;
	int size;
	int n;
	cPtr = sizeString;
	while (*cPtr != '\0') {
	    part = (int) (*cPtr - 'a');
	    if (part < 0 || part > 7) {
		fprintf(stderr, 
	    "Argument to -sizes parameter must start with partition.\n");
		Usage();
	    }
	    cPtr++;
	    if (*cPtr != ':') {
		fprintf(stderr, 
	    "Argument to -sizes parameter is missing a ':'.\n");
		Usage();
	    }
	    cPtr++;
	    n = sscanf(cPtr,"%d",&size);
	    if (n != 1) {
		fprintf(stderr, 
    "Argument to -sizes parameter must have an integer following the ':'\n");
		Usage();
	    }
	    sizes[part] = size;
	    cPtr = strchr(cPtr, ',');
	    if (cPtr == NULL) {
		break;
	    }
	    cPtr++;
	}
    }
    if (hostIDString != (char *) NULL) {
	int		scanned;
	int		temp;
	Host_Entry	*entryPtr;

	scanned = sscanf(hostIDString, " %d", &temp);
	if (scanned == 1) {
	    entryPtr = Host_ByID(temp);
	    if (entryPtr == NULL) {
		fprintf(stderr, 
		    "WARNING: Host %d is not in /etc/spritehosts.\n", temp);
	    }
	    hostID = temp;
	} else {
	    entryPtr = Host_ByName(hostIDString);
	    if (entryPtr == NULL) {
		fprintf(stderr, 
		    "Host %s is not in /etc/spritehosts.\n", temp);
		status = FAILURE;
	    }
	    hostID = entryPtr->id;
	}
    }
    labelType = DISK_NO_LABEL;
    if (labelTypeName != NULL) {
	if (!strcasecmp(labelTypeName, "sun")) {
	    labelType = DISK_SUN_LABEL;
	} else if (!strcasecmp(labelTypeName, "dec")) {
	    labelType = DISK_DEC_LABEL;
	} else {
	    fprintf(stderr, 
		"Argument to -labeltype must be \"sun\" or \"dec\"\n");
	    status = FAILURE;
	}
    }
    if (status != SUCCESS) {
	exit(status);
    }
    /*
     * Gen up the name of the first partition on the disk,
     * and the name of the parition that needs to be formatted.
     */
    sprintf(firstPartitionName, "%s/%s%c", devDirectory, deviceName,
	*firstPartName);
    sprintf(partitionName, "%s/%s%c", devDirectory, deviceName,
	*partName);
    if (rawDeviceName != NULL) {
	char buffer[64];
	sprintf(buffer, "%s/%s", devDirectory, rawDeviceName);
	if (!printOnly) {
	    rawFID = open(buffer, O_RDWR);
	} else {
	    rawFID = open(buffer, O_RDONLY);
	}
	if (rawFID < 0) {
	    fprintf(stderr, "Can't open raw device %s: ", buffer);
	    perror((char *) NULL);
	    exit(FAILURE);
	}
    }
    if (!printOnly) {
	firstPartFID = open(firstPartitionName, O_RDWR);
    } else {
	firstPartFID = open(firstPartitionName, O_RDONLY);
    }
    if (firstPartFID < 0 ) {
	fprintf(stderr, "Can't open first partition %s: ", firstPartitionName);
	perror((char *) NULL);
	exit(FAILURE);
    }
    if (!printOnly) {
	partFID = open(partitionName, O_RDWR);
    } else {
	partFID = open(partitionName, O_RDONLY);
    }
    if (partFID < 0) {
	perror("Can't open partition to format");
	exit(FAILURE);
    }

    partition = partName[0] - 'a';
    if (partition < 0 || partition > 7) {
	fprintf(stderr,
	       "Can't determine partition index from the partition name\n");
	exit(FAILURE);
    }
    if (reconfig) {
	if (rawFID < 0) {
	    fprintf(stderr, 
	"You must specify a raw device with the -reconfig flag\n");
	    exit(FAILURE);
	}
	status = Reconfig(rawFID, configdisktab, disktabName, diskType,
	    labelType, scsiDisk, &labelPtr);
	if (status != SUCCESS) {
	    fprintf(stderr, "Reconfiguration of disk failed.\n");
	    exit(1);
	}
    }
    if (repartition || reconfig) {
	if (rawFID < 0) {
	    fprintf(stderr, 
	"You must specify a raw device with the -repartition flag\n");
	    exit(FAILURE);
	}
	status = Repartition(rawFID, partdisktab, disktabName, diskType,
	    labelType, partition,
	    sizes, &labelPtr);
	if (status != SUCCESS) {
	    fprintf(stderr, "Repartition of disk failed.\n");
	    exit(1);
	}
	printf("New disk label:\n");
	Disk_PrintLabel(labelPtr);
	status = ConfirmDiskSize(rawFID, labelPtr, sizes);
	if (status != SUCCESS) {
	    exit(status);
	}
	if (!printOnly) {
	    status = Disk_WriteLabel(rawFID, labelPtr);
	    if (status != SUCCESS) {
		fprintf(stderr, "Can't write label to raw device\n");
		exit(status);
	    }
	}
    }
#ifdef sprite  /* This stuff will not work if run under Unix. */
    if (hostID == 0) {

	/*
	 * Determine where the disk is located so we can set the
	 * spriteID in the header correctly.
	 */
	Fs_GetAttributesID(firstPartFID, &attrs);
	if (attrs.devServerID == FS_LOCALHOST_ID) {
	    Proc_GetHostIDs((int *) NULL, &spriteID);
	    printf("Making filesystem for local host, ID = 0x%x\n", spriteID);
	} else {
	    spriteID = attrs.devServerID;
	    printf("Making filesystem for remote host 0x%x\n", spriteID);
	}
    } else
#endif
    {
	spriteID = hostID;
	printf("Making filesystem for host, ID = 0x%x\n", spriteID);
    }
    gettimeofday(&curTime, (struct timezone *) NULL);
    printf("MakeFilesystem based on 4K filesystem blocks\n");
    status = MakeFilesystem(firstPartFID, partFID, partition, spriteID, 
	&labelPtr);
    if ((status == SUCCESS) && (dirName != NULL)) {
	Fsdm_FileDescriptor	rootDesc;
	printf("Copying %s to new filesystem.\n", dirName);
	fdBitmapPtr = ReadFileDescBitmap(partFID, headerPtr);
	cylBitmapPtr = ReadBitmap(partFID, headerPtr);
	ReadFileDesc(partFID, headerPtr, FSDM_ROOT_FILE_NUMBER, &rootDesc);
	CopyTree(partFID, dirName, FSDM_ROOT_FILE_NUMBER, &rootDesc,
	    FSDM_ROOT_FILE_NUMBER, FALSE, "/");
	WriteFileDesc(partFID, headerPtr, FSDM_ROOT_FILE_NUMBER, &rootDesc);
	if (!printOnly) {
	    status = Disk_WriteSummaryInfo(partFID, labelPtr, summaryPtr);
	    if (status != 0) {
		perror("Summary sector write failed (2)");
		exit(status);
	    }
	    WriteFileDescBitmap(partFID, headerPtr, fdBitmapPtr);
	    WriteBitmap(partFID, headerPtr);
	}
    }
    fflush(stderr);
    fflush(stdout);
    (void)close(firstPartFID);
    (void)close(partFID);
    exit(status);
}

/*
 *----------------------------------------------------------------------
 *
 * Usage --
 *
 *	Prints out the correct command syntax and exits..
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The program exits.
 *
 *----------------------------------------------------------------------
 */

static void
Usage()
{
    Opt_PrintUsage(myName, optionArray, Opt_Number(optionArray));
    exit(1);
}

/*
 *----------------------------------------------------------------------
 *
 * MakeFilesystem --
 *
 *	Format a disk partition, or domain, to be an empty filesystem.
 *
 * Results:
 *	An error code.
 *
 * Side effects:
 *	Write all over the disk partition.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
MakeFilesystem(firstPartFID, partFID, partition, spriteID, labelPtrPtr)
    int firstPartFID;	/* Handle on the first partition of the disk */
    int partFID;	/* Handle on the partition of the disk to format */
    int partition;	/* Index of parition that is to be formatted */
    int spriteID;	/* Host ID of the machine with the disks, this
			 * gets written on the disk and used at boot time */
    Disk_Label	**labelPtrPtr; /* Ptr to ptr to disk label. */
{
    ReturnStatus 	status;
    Ofs_DomainHeader	oldDomainHeader;
    Ofs_SummaryInfo	oldSummaryInfo;
    Fsdm_FileDescriptor rootFD;
    Fsdm_FileDescriptor *rootFDPtr = &rootFD;
    Disk_Label	*labelPtr = *labelPtrPtr;

    if (labelPtr == NULL) {
	labelPtr = Disk_ReadLabel(firstPartFID);
	if (labelPtr == NULL) {
	    fprintf(stderr, "Unable to read disk label.\n");
	    return FAILURE;
	}
    }
    *labelPtrPtr = labelPtr;
    summaryPtr = Disk_ReadSummaryInfo(partFID, labelPtr);
    if (summaryPtr != NULL) {
	if (!printOnly) {
	    char answer[10];

	    printf("\nYou are about to overwrite the \"%s\" filesystem.\n", 
		summaryPtr->domainPrefix);
	    printf("Do you really want to do this?[y/n] ");
	    if (scanf("%10s",answer) != 1) {
		exit(SUCCESS);
	    }
	    if ((*answer != 'y') && (*answer != 'Y')) {
		return SUCCESS;
	    }
	}
    }
    bzero((char *) &oldDomainHeader, sizeof(oldDomainHeader));
    bzero((char *) &oldSummaryInfo, sizeof(oldSummaryInfo));
    if (!printOnly) {
	status = Disk_WriteDomainHeader(partFID, labelPtr, &oldDomainHeader);
	if (status != SUCCESS) {
	    printf("Clear of old domain header failed\n");
	}
	status = Disk_WriteSummaryInfo(partFID, labelPtr, &oldSummaryInfo);
	if (status != SUCCESS) {
	    printf("Clear of old summary info failed\n");
	}
    }
    /*
     * The user has specified the number of boot sectors.
     */
    if (bootSectors >= 0) {
	labelPtr->summarySector = bootSectors + 1;
	labelPtr->domainSector = bootSectors + 2;
	labelPtr->numBootSectors = bootSectors;
    } else {
	Disk_Label *newLabelPtr;
	newLabelPtr = Disk_NewLabel(labelPtr->labelType);
	labelPtr->summarySector = newLabelPtr->summarySector;
	labelPtr->domainSector = newLabelPtr->domainSector;
	labelPtr->numBootSectors = newLabelPtr->numBootSectors;
	free((char *) newLabelPtr);
    }
    headerPtr = (Ofs_DomainHeader *) malloc(sizeof(Ofs_DomainHeader));
    status = SetDomainHeader(labelPtr, headerPtr, spriteID, partition);
    if (status != SUCCESS) {
	return FAILURE;
    }
    Disk_PrintDomainHeader(headerPtr);

    if (!printOnly) {
	status = Disk_WriteLabel(partFID, labelPtr);
	if (status != SUCCESS) {
	    perror("Disk label write failed"); 
	    return(status);
	}
	status = Disk_WriteDomainHeader(partFID, labelPtr, headerPtr);
	if (status != SUCCESS) {
	    perror("DomainHeader write failed");
	    return(status);
	}
    }
    summaryPtr = (Ofs_SummaryInfo *) malloc(DEV_BYTES_PER_SECTOR);
    SetSummaryInfo(headerPtr, summaryPtr);
    if (!printOnly) {
	status = Disk_WriteSummaryInfo(partFID, labelPtr, summaryPtr);
	if (status != SUCCESS) {
	    perror("Summary sector write failed");
	    return(status);
	}
    }
    status = WriteAllFileDescs(partFID, headerPtr);
    if (status != SUCCESS) {
	perror("WriteAllFileDescs failed");
	return(status);
    }
    status = WriteBitmap(partFID, headerPtr);
    if (status != SUCCESS) {
	perror("WriteBitmap failed");
	return(status);
    }
    ReadFileDesc(partFID, headerPtr, FSDM_ROOT_FILE_NUMBER, rootFDPtr);
    status = WriteRootDirectory(partFID, headerPtr, rootFDPtr);
    WriteFileDesc(partFID, headerPtr, FSDM_ROOT_FILE_NUMBER, rootFDPtr);
    if (status != SUCCESS) {
	perror("WriteRootDirectory failed");
	return(status);
    }
    status = WriteLostFoundDirectory(partFID, headerPtr);
    if (status != SUCCESS) {
	perror("WriteLostFoundDirectory failed");
	return(status);
    }
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * CopyTree --
 *
 *	Copy the tree of files in the given directory
 *	the disk table.
 *
 * Results:
 *	A pointer to a disk info struct.
 *
 * Side effects:
 *	Disk info struct malloc'd and initialized.  The disk header will be
 *	written if is successfully set up.
 *
 *----------------------------------------------------------------------
 */
static void
CopyTree(partFID, dirName, dirFDNum, dirFDPtr, parentFDNum, createDir, path)
    int			partFID;	/* Handle on raw disk. */
    char		*dirName;	/* Name of directory to copy. */
    int			dirFDNum;	/* File number of directory. */
    Fsdm_FileDescriptor	*dirFDPtr;	/* File descriptor of directory. */
    int			parentFDNum;	/* File number of parent. */
    Boolean		createDir;	/* Should create the directory. */
    char		*path;
{
    DIR			*unixDirPtr;
    struct direct	*unixDirEntPtr;
    DirIndexInfo	indexInfo;
    Fslcl_DirEntry	*spriteDirEntPtr;
    char		fileName[FS_MAX_NAME_LENGTH + 1];
    int			newFDNum;
    Fsdm_FileDescriptor	newFD;
    Fsdm_FileDescriptor	*newFDPtr;
    struct	stat	statBuf;
    int			followLinks;
    char		pathName[1024];
    char		fileBlock[FS_BLOCK_SIZE];
    char		indirectBlock[FS_BLOCK_SIZE];
    int			*indIndexPtr = (int *)indirectBlock;
    char		*suffix;
    Boolean		makeDevice;
    int			devType;
    int			devUnit;
    int			devServer;
    ReturnStatus	status;


    /*
     * Get our absolute path name so we can get back if we follow a
     * symbolic link.
     */
    (void) getwd(pathName);

    if (chdir(dirName) < 0) {
	perror(dirName);
	exit(1);
    }

    /*
     * Get a pointer to the UNIX directory.
     */
    unixDirPtr = opendir(".");
    if (unixDirPtr == NULL) {
	fprintf(stderr, "Can't open directory %s\n", dirName);
	exit(1);
    }
    /*
     * Open the Sprite directory.
     */
    status = OpenDir(partFID, headerPtr, dirFDPtr, &indexInfo,&spriteDirEntPtr);
    if (status != SUCCESS) {
	if (chdir(pathName) < 0) {
	    perror(pathName);
	    exit(1);
	}
    }
    /*
     * See if there is a "follow.links" file in this directory.  If so
     * we are supposed to follow symbolic links rather than just copying
     * the links.
     */
    if (stat("follow.links", &statBuf) < 0) {
	followLinks = 0;
    } else {
	printf("Following links ...\n");
	followLinks = 1;
    }
    if (createDir) {
	CreateDir(indexInfo.dirBlock, 1, dirFDNum, parentFDNum);
    }

    while ((unixDirEntPtr = readdir(unixDirPtr)) != NULL) {
	if (unixDirEntPtr->d_namlen == 1 && 
	    strncmp(unixDirEntPtr->d_name, ".", 1) == 0) {
	    continue;
	}
	if (unixDirEntPtr->d_namlen == 2 && 
	    strncmp(unixDirEntPtr->d_name, "..", 2) == 0) {
	    continue;
	}
	strncpy(fileName, unixDirEntPtr->d_name, unixDirEntPtr->d_namlen);
	fileName[unixDirEntPtr->d_namlen] = 0;
	if (followLinks) {
	    if (stat(fileName, &statBuf) < 0) {
		perror(fileName);
		exit(1);
	    }
	} else {
	    if (lstat(fileName, &statBuf) < 0) {
		perror(fileName);
		exit(1);
	    }
	}
	makeDevice = FALSE;
	suffix = strstr(fileName, DEVICE_SUFFIX);
	if ((suffix != NULL) && (!strcmp(suffix, DEVICE_SUFFIX)) &&
	    ((statBuf.st_mode & S_GFMT) == S_GFREG)) {
	    FILE	*fp;
	    char	buffer[128];
	    int		ok = 0;

	    fp = fopen(fileName, "r");
	    if (fp == NULL) {
		fprintf(stderr, "WARNING: Can't open %s%s: ", pathName,
		    fileName);
		perror((char *) NULL);
		continue;
	    }
	    while (fgets(buffer, 128, fp) != NULL) {
		char	tmp[128];
		int	n;

		n = sscanf(buffer, " %128s", tmp);
		if (n < 1 || *tmp == '#') {
		    continue;
		}
		if (sscanf(buffer, " %d %d %d", &devServer, &devType, &devUnit)
		    != 3) {
		    fprintf(stderr, 
		    "WARNING: Device file %s%s has bad format. Skipping.\n",
			pathName, fileName);
		    break;
		}
		ok = 1;
		break;
	    }
	    fclose(fp);
	    if (!ok) {
		continue;
	    }
	    makeDevice = TRUE;
	    *suffix = '\0';
	}
	newFDNum = freeFDNum;
	freeFDNum++;
	MarkFDBitmap(newFDNum, fdBitmapPtr);
	summaryPtr->numFreeFileDesc--;
	ReadFileDesc(partFID, headerPtr, newFDNum, &newFD);
	newFDPtr = &newFD;

	status = AddToDirectory(partFID, headerPtr, !printOnly, &indexInfo, 
	    &spriteDirEntPtr, newFDNum, fileName);
	if (status != SUCCESS) {
	    fprintf(stderr, "%s is full\n", dirName);
	    break;
	}
	if (makeDevice) {
	    InitDesc(newFDPtr, FS_DEVICE, 0, devServer, devType, devUnit, 0, 0,
		(int) statBuf.st_mode & 07777, curTime.tv_sec);
	    printf("Device: %s%s (S %d, T %d, U %d)\n", path, fileName,
		devServer, devType, devUnit);
#ifdef sprite
	} else if ((statBuf.st_mode & S_GFMT) == S_IFPDEV) {
	    printf("Skipping pseudo-device %s%s\n", path, fileName);
#endif
	} else if ((statBuf.st_mode & S_GFMT) == S_GFREG ||
#ifdef sprite
		   ((statBuf.st_mode & S_GFMT) == S_IFRLNK)  || 
#endif
		   (statBuf.st_mode & S_GFMT) == S_GFLNK) {
	    int	fd = -1;
	    int	blockNum;
	    int	toRead;
	    int	len;

	    blockNum = 0;
	    if ((statBuf.st_mode & S_GFMT) == S_GFREG) {
		printf("File: %s%s\n", path, fileName);
		InitDesc(newFDPtr, FS_FILE, (int) statBuf.st_size, -1, -1, -1,
			 0, 0, (int) statBuf.st_mode & 07777, statBuf.st_mtime);
		/*
		 * Copy the file over.
		 */
		fd = open(fileName, 0);
		if (fd < 0) {
		    fprintf(stderr, "WARNING: Can't open %s%s: ", pathName,
			fileName);
		    perror((char *) NULL);
		    freeFDNum--;
		    summaryPtr->numFreeFileDesc++;
		    continue;
		}
		len = read(fd, fileBlock, FS_BLOCK_SIZE);
		if (len < 0) {
		    fprintf(stderr, "WARNING: Can't read %s%s: ", pathName,
			fileName);
		    perror((char *) NULL);
		    freeFDNum--;
		    summaryPtr->numFreeFileDesc++;
		    continue;
		}
		toRead = statBuf.st_size;
	    } else {
		len = readlink(fileName, fileBlock, FS_BLOCK_SIZE);
		if (len < 0) {
		    fprintf(stderr, "WARNING: Can't readlink %s%s: ", pathName,
			fileName);
		    perror((char *) NULL);
		    freeFDNum--;
		    summaryPtr->numFreeFileDesc++;
		    continue;
		}
		fileBlock[len] = '\0';
		InitDesc(newFDPtr, FS_SYMBOLIC_LINK, len + 1, -1, -1, -1, 
			 0, 0, 0777, statBuf.st_mtime);
#ifdef sprite
		if ((statBuf.st_mode & S_GFMT) == S_IFRLNK) { 
		    printf("Remote link: %s%s\n", path, fileName);
		} else {
		    printf("Symbolic link: %s%s -> %s\n", 
			    path, fileName, fileBlock);
		}
#else
		printf("Symbolic link: %s%s -> %s\n", 
			path, fileName, fileBlock);
#endif
		toRead = len + 1;
	    }

	    while (len > 0) {
		if (blockNum == FSDM_NUM_DIRECT_BLOCKS) {
		    int	i;
		    int	*intPtr;
		    /*
		     * Must allocate an indirect block.
		     */
		    newFDPtr->indirect[0] =
			VirtToPhys(freeBlockNum * FS_FRAGMENTS_PER_BLOCK);
		    MarkDataBitmap(headerPtr, cylBitmapPtr, freeBlockNum,
				   FS_FRAGMENTS_PER_BLOCK);
		    freeBlockNum++;
		    summaryPtr->numFreeKbytes -= FS_FRAGMENTS_PER_BLOCK;
		    for (i = 0, intPtr = (int *)indirectBlock; 
			 i < FS_BLOCK_SIZE / sizeof(int); 
			 i++, intPtr++) {
			 *intPtr = FSDM_NIL_INDEX;
		    }
		}
		if (blockNum >= FSDM_NUM_DIRECT_BLOCKS) {
		    indIndexPtr[blockNum - FSDM_NUM_DIRECT_BLOCKS] = 
					freeBlockNum * FS_FRAGMENTS_PER_BLOCK;
		    MarkDataBitmap(headerPtr, cylBitmapPtr, freeBlockNum,
				   FS_FRAGMENTS_PER_BLOCK);
		    summaryPtr->numFreeKbytes -= FS_FRAGMENTS_PER_BLOCK;
		} else {
		    newFDPtr->direct[blockNum] = 
					freeBlockNum * FS_FRAGMENTS_PER_BLOCK;
		    if (toRead > FS_BLOCK_SIZE) {
			MarkDataBitmap(headerPtr, cylBitmapPtr, freeBlockNum,
				       FS_FRAGMENTS_PER_BLOCK);
			summaryPtr->numFreeKbytes -= FS_FRAGMENTS_PER_BLOCK;
		    } else {
			MarkDataBitmap(headerPtr, cylBitmapPtr, freeBlockNum,
				       (toRead - 1) / FS_FRAGMENT_SIZE + 1);
			summaryPtr->numFreeKbytes -= 
					(toRead - 1) / FS_FRAGMENT_SIZE + 1;
		    }
		}
		/*
		 * Write the block out to disk.
		 */
		if (Disk_BlockWrite(partFID, headerPtr, 
				    headerPtr->dataOffset + freeBlockNum,
				    1, (Address)fileBlock) != 0) {
		    fprintf(stderr, "Couldn't write file block\n");
		    exit(1);
		}
		blockNum++;
		freeBlockNum++;
		if ((statBuf.st_mode & S_GFMT) == S_GFLNK) {
		    break;
		}
		toRead -= len;
		len = read(fd, fileBlock, FS_BLOCK_SIZE);
		if (len < 0) {
		    perror(fileName);
		    exit(1);
		}
	    }
	    if (newFDPtr->indirect[0] != FSDM_NIL_INDEX) {
		if (Disk_BlockWrite(partFID, headerPtr,
			    newFDPtr->indirect[0] / FS_FRAGMENTS_PER_BLOCK,
			    1, (Address)indirectBlock) != 0) {
		    fprintf(stderr, "Couldn't write indirect block\n");
		    exit(1);
		}
	    }
	    close(fd);
	} else if (statBuf.st_mode & S_GFDIR) {
	    char	newPath[FS_MAX_NAME_LENGTH];

	    /*
	     * Increment the current directories link count because once
	     * the child gets created it will point to the parent.
	     */
	    dirFDPtr->numLinks++;
	    /*
	     * Allocate the currently free file descriptor to this directory.
	     */
	    InitDesc(newFDPtr, FS_DIRECTORY, FS_BLOCK_SIZE, -1, -1, -1, 
		     0, 0, (int) statBuf.st_mode & 07777, statBuf.st_mtime);
	    /*
	     * Give the directory one full block.  The directory will
	     * be initialized by CopyTree when we call it recursively.
	     */
	    newFDPtr->direct[0] = freeBlockNum * FS_FRAGMENTS_PER_BLOCK;
	    MarkDataBitmap(headerPtr, cylBitmapPtr, freeBlockNum,
			   FS_FRAGMENTS_PER_BLOCK);
	    freeBlockNum++;
	    sprintf(newPath, "%s%s/", path, fileName);
	    printf("Directory: %s\n", newPath);
	    CopyTree(partFID, fileName, newFDNum, newFDPtr, dirFDNum, TRUE, 
		newPath);
	} else {
	    fprintf(stderr, "WARNING: %s%s is not a file or directory\n",
		pathName, fileName);
	    freeFDNum--;
	    summaryPtr->numFreeFileDesc++;
	    continue;
	}
	WriteFileDesc(partFID, headerPtr, newFDNum, newFDPtr);

    }

    CloseDir(partFID, headerPtr, !printOnly, &indexInfo);

    if (chdir(pathName) < 0) {
	perror(pathName);
	exit(1);
    }
    closedir(unixDirPtr);
    return;
}


/*
 *----------------------------------------------------------------------
 *
 * SetDomainHeader --
 *
 *	Compute the domain header based on the partition size and
 *	other basic disk parameters.
 *
 * Results:
 *	A return code.
 *
 * Side effects:
 *	Fill in the domain header.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
SetDomainHeader(labelPtr, headerPtr, spriteID, partition)
    Disk_Label		*labelPtr;	/* The disk label. */
    Ofs_DomainHeader 	*headerPtr;	/* Domain header to fill in */
    int 		spriteID;	/* Host ID of machine with the disks */
    int 		partition;	/* Index of partition to format */
{
    register Ofs_Geometry *geoPtr;/* The layout information for the disk */

    headerPtr->magic = OFS_DOMAIN_MAGIC;
    headerPtr->firstCylinder = labelPtr->partitions[partition].firstCylinder;
    headerPtr->numCylinders = labelPtr->partitions[partition].numCylinders;
    if (headerPtr->numCylinders <= 0) {
	fprintf(stderr, "Invalid partition size: %d cylinders.\n", 
	    headerPtr->numCylinders);
	return FAILURE;
    }
    /*
     * The device.serverID from the disk is used during boot to discover
     * the host"s spriteID if reverse arp couldn't find a host ID.  The
     * unit number of disk indicates what partition of the disk this
     * domain header applies to.  For example, both the "a" and "c" partitions
     * typically start at sector zero, but only one is valid.  During boot
     * time the unit number is used to decide which partition should be
     * attached.
     */
    headerPtr->device.serverID = spriteID;
    headerPtr->device.type = -1;
    headerPtr->device.unit = partition;
    headerPtr->device.data = (ClientData)-1;

    geoPtr = &headerPtr->geometry;
    if (scsiDisk) {
	SetSCSIDiskGeometry(labelPtr, geoPtr);
    } else {
	SetDiskGeometry(labelPtr, geoPtr);
    }

    SetDomainParts(labelPtr, partition, headerPtr);
    return SUCCESS;
}

/*
 *----------------------------------------------------------------------
 *
 * SetSCSIDiskGeometry --
 *
 *	This computes the rotational set arrangment depending on the
 *	disk geometry.  No fancy block skewing is done.  The cylinders
 *	are divided into rotational sets that minimize the amount of
 *	wasted space.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Fill in the geometry struct.
 *
 *----------------------------------------------------------------------
 */
static void
SetSCSIDiskGeometry(labelPtr, geoPtr)
    register Disk_Label		*labelPtr;	/* The disk label. */
    register Ofs_Geometry 	*geoPtr;	/* Fancy geometry information */
{
    register int index;		/* Array index */
    int blocksPerCyl;		/* The number of blocks in a cylinder */

    geoPtr->numHeads = labelPtr->numHeads;
    geoPtr->sectorsPerTrack = labelPtr->numSectors;

    blocksPerCyl = geoPtr->sectorsPerTrack * geoPtr->numHeads /
		DISK_SECTORS_PER_BLOCK;

    printf("Disk has %d tracks/cyl, %d sectors/track\n",
	    geoPtr->numHeads, geoPtr->sectorsPerTrack);
    printf("%d 4K Blocks fit on a cylinder with %d 512 byte sectors wasted\n",
	    blocksPerCyl, geoPtr->sectorsPerTrack * geoPtr->numHeads - 
	    blocksPerCyl * DISK_SECTORS_PER_BLOCK);
    geoPtr->rotSetsPerCyl = OFS_SCSI_MAPPING;
    geoPtr->blocksPerRotSet = 0;
    geoPtr->blocksPerCylinder = blocksPerCyl;
    geoPtr->tracksPerRotSet = 0;
    /*
     * Don't use rotational sorting anyway.
     */
    for (index = 0 ; index < OFS_MAX_ROT_POSITIONS ; index++) {
	geoPtr->sortedOffsets[index] = -1;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * SetDiskGeometry --
 *
 *	This computes the rotational set arrangment depending on the
 *	disk geometry.  The basic rules for this are that filesystem blocks
 *	are skewed on successive tracks, and that the skewing pattern
 *	repeats in either 2 or 4 tracks.  This is specific to the fact that
 *	filesystem blocks are 4Kbytes.  This means that one disk track
 *	contains N/4 filesystem blocks and that one sector per track
 *	is wasted if there are an odd number of sectors per track.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Fill in the geometry struct.
 *
 *----------------------------------------------------------------------
 */
static void
SetDiskGeometry(labelPtr, geoPtr)
    register Disk_Label		*labelPtr;	/* The disk label. */
    register Ofs_Geometry 	*geoPtr;	/* Fancy geometry information */
{
    register int index;		/* Array index */
    int numBlocks;		/* The number of blocks in a rotational set */
    int tracksPerSet = 0;	/* Total number of tracks in a rotational set */
    int numTracks;		/* The number of tracks in the set so far */
    int extraSectors;		/* The number of leftover sectors in a track */
    int offset;			/* The sector offset within a track */
    int startingOffset;		/* The offset of the first block in a track */
    int offsetIncrement = 0;	/* The skew of the starting offset on each
				 * successive track of the rotational set */
    Boolean overlap = FALSE;	/* TRUE if filesystem blocks overlap tracks */

    geoPtr->numHeads = labelPtr->numHeads;
    geoPtr->sectorsPerTrack = labelPtr->numSectors;

    /*
     * Figure out some basic parameters of the rotational set.  The number
     * of tracks in the set is either 2 or 4.  If 2, then the blocks on
     * successive tracks are skewed by 1/2 a filesystem block.  If 4,
     * blocks are skewed by 1/4 block.  A 4 track rotational set is best
     * becasue there are more rotational positions.  If, however, it
     * causes 2 or 3 wasted tracks at the end, or if blocks naturally
     * overlap by 1/2 block, then only 2 tracks per rotational set are
     * used.
     */
    switch(geoPtr->numHeads % 4) {
	case 0:
	case 1: {
	    extraSectors = geoPtr->sectorsPerTrack % DISK_SECTORS_PER_BLOCK;
	    if (extraSectors < DISK_SECTORS_PER_BLOCK/4) {
		/*
		 * Not enough extra sectors to overlap blocks onto the
		 * next track.  The blocks will fit evenly on a track,
		 * but the blocks on the following tracks will be skewed.
		 */
		tracksPerSet = 4;
		overlap = FALSE;
		offsetIncrement = DISK_SECTORS_PER_BLOCK/4;
	    } else if (extraSectors < DISK_SECTORS_PER_BLOCK/2) {
		/*
		 * Enough to overlap the first 1/4 block onto the next track.
		 */
		tracksPerSet = 4;
		overlap = TRUE;
		offsetIncrement = DISK_SECTORS_PER_BLOCK * 3/4;
	    } else if (extraSectors < DISK_SECTORS_PER_BLOCK * 3/4) {
		/*
		 * Enough to overlap 1/2 block.
		 */
		tracksPerSet = 2;
		overlap = TRUE;
		offsetIncrement = DISK_SECTORS_PER_BLOCK/2;
	    } else {
		/*
		 * Enough to overlap 3/4 block.
		 */
		tracksPerSet = 4;
		overlap = TRUE;
		offsetIncrement = DISK_SECTORS_PER_BLOCK/4;
	    }
	    break;
	}
	case 2:
	case 3: {
	    /*
	     * Instead of wasting 2 or 3 tracks to have a 4 track rotational
	     * set, the rotational set is only 2 tracks long.  Also see if
	     * the blocks naturally overlap by 1/2 block.
	     */
	    tracksPerSet = 2;
	    offsetIncrement = DISK_SECTORS_PER_BLOCK/2;
	    if ((geoPtr->sectorsPerTrack % DISK_SECTORS_PER_BLOCK) <
		      DISK_SECTORS_PER_BLOCK/2) {
		overlap = FALSE;
	    } else {
		overlap = TRUE;
	    }
	}
    }
    if (!overlapBlocks) {
	overlap = FALSE;
	offsetIncrement = 0;
    }
    printf("overlap %s, offsetIncrement %d\n", (overlap ? "TRUE" : "FALSE"),
		      offsetIncrement);
    /*
     * Determine rotational position of the blocks in the rotational set.
     */
    extraSectors = geoPtr->sectorsPerTrack;
    startingOffset = 0;
    offset = startingOffset;
    for (numBlocks = 0, numTracks = 0 ; ; ) {
	if (extraSectors >= DISK_SECTORS_PER_BLOCK) {
	    /*
	     * Ok to fit in another filesystem block on this track.
	     */
	    geoPtr->blockOffset[numBlocks] = offset;
	    numBlocks++;	
	    offset += DISK_SECTORS_PER_BLOCK;
	    extraSectors -= DISK_SECTORS_PER_BLOCK;
	} else {
	    /*
	     * The current block has to take up room on the next track.
	     */
	    numTracks++;
	    if (numTracks < tracksPerSet) {
		/*
		 * Ok to go to the next track.
		 */
		startingOffset += offsetIncrement;
		if (overlap) {
		    /*
		     * If the current block can overlap to the next track,
		     * use the current offset.  Because of the overlap
		     * there are fewer sectors available for blocks on
		     * the next track.
		     */
		    geoPtr->blockOffset[numBlocks] = offset;
		    numBlocks++;
		    extraSectors = geoPtr->sectorsPerTrack - startingOffset;
		}
		offset = startingOffset + numTracks * geoPtr->sectorsPerTrack;
		if (!overlap) {
		    /*
		     * If no overlap the whole next track is available.
		     */
		    extraSectors = geoPtr->sectorsPerTrack;
		}
	    } else {
		/*
		 * Done.
		 */
		for (index = numBlocks; index < OFS_MAX_ROT_POSITIONS; index++){
		    geoPtr->blockOffset[index] = -1;
		}
		break;
	    }
	}
    }
    geoPtr->blocksPerRotSet = numBlocks;
    geoPtr->tracksPerRotSet = tracksPerSet;
    geoPtr->rotSetsPerCyl = geoPtr->numHeads / tracksPerSet;
    geoPtr->blocksPerCylinder = numBlocks * geoPtr->rotSetsPerCyl;

    /*
     * Now the rotational positions have to be sorted so that rotationally
     * optimal blocks can be found.  The array sortedOffsets is set so
     * that the I'th element has the index into blockOffset which contains
     * the I'th rotational position, eg.
     *	blockOffset	sortedOffsets
     *	    0 (+0)		0
     *	    8 (+0)		2
     *	    4 (+17)		1
     *	   12 (+17)		3
     */

    offsetIncrement = DISK_SECTORS_PER_BLOCK / tracksPerSet;
    for (index = 0 ; index < OFS_MAX_ROT_POSITIONS ; index++) {
	geoPtr->sortedOffsets[index] = -1;
    }
    for (index = 0 ; index < numBlocks ; index++) {
	offset = geoPtr->blockOffset[index] % geoPtr->sectorsPerTrack;
	geoPtr->sortedOffsets[offset/offsetIncrement] = index;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * SetDomainParts --
 *
 *	Set up the way the domain is divided into 4 areas:  the bitmap
 *	for the file descriptors, the file descriptors, the bitmap for
 *	the data blocks, and the data blocks.
 *
 * Results:
 *	The geometry information is completed.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static void
SetDomainParts(labelPtr, partition, headerPtr)
    register Disk_Label		*labelPtr;	/* The disk label. */
    int partition;
    register Ofs_DomainHeader *headerPtr;
{
    register Ofs_Geometry *geoPtr;
    int numFiles;		/* Number of files computed from the size */
    int numBlocks;		/* Number of blocks in the partition.  This
				 * is computed and then dolled out to the
				 * different things stored in the partition */
    int offset;			/* Block offset within partition */
    int bitmapBytes;		/* Number of bytes taken up by a bitmap */
    int reservedBlocks;		/* Number of blocks reserved at beginning
				 * of partition */
    int maxSector;
    int numCylinders;
    int bytesPerCylinder;

    /*
     * Set aside a number of blocks at the begining of the partition for
     * things like the super block, the boot program, and the domain header.
     */
    geoPtr = &headerPtr->geometry;
    maxSector = labelPtr->labelSector;
    maxSector = Max(maxSector,labelPtr->bootSector + labelPtr->numBootSectors);
    maxSector = Max(maxSector,labelPtr->summarySector
	+ labelPtr->numSummarySectors);
    maxSector = Max(maxSector,labelPtr->domainSector
	+ labelPtr->numDomainSectors);
    numCylinders = labelPtr->partitions[partition].numCylinders;
    if (scsiDisk) {
	/*
	 * For a scsi disk just reserve whole cylinders.
	 */
	int cylinders;
	cylinders = maxSector / (geoPtr->sectorsPerTrack * geoPtr->numHeads);
	if ((maxSector % (geoPtr->sectorsPerTrack * geoPtr->numHeads)) != 0) {
	    cylinders++;
	}
	reservedBlocks = cylinders * geoPtr->blocksPerCylinder;
	numBlocks = geoPtr->blocksPerCylinder * numCylinders - reservedBlocks;
     } else {
	/*
	 * If we are using rotational sets then reserve whole sets.
	 */
	int sets;
	sets = maxSector / (geoPtr->tracksPerRotSet * geoPtr->sectorsPerTrack);
	if ((maxSector % (geoPtr->tracksPerRotSet * geoPtr->sectorsPerTrack)) 
	!= 0) {
	    sets++;
	}
	reservedBlocks = sets * geoPtr->blocksPerRotSet;
	numBlocks = geoPtr->blocksPerCylinder * numCylinders - reservedBlocks;
    }
    printf("Reserving %d blocks for domain header, etc.\n", reservedBlocks);
    /*
     * Determine the number of filesystem blocks available and compute a
     * first guess at the number of file descriptors.  If at the end of
     * the computation things don't fit nicely, then the number of files
     * is changed and the computation is repeated.
     */
    numFiles = 0;
    do {
	if (numFiles == 0) {
	    numFiles = numBlocks * DISK_KBYTES_PER_BLOCK / kbytesToFileDesc;
	}
	numFiles		  &= ~(FSDM_FILE_DESC_PER_BLOCK-1);
	offset			  = reservedBlocks;

	assert(numFiles > 0);
	headerPtr->fdBitmapOffset = offset;
	bitmapBytes		  = (numFiles - 1) / BITS_PER_BYTE + 1;
	headerPtr->fdBitmapBlocks = (bitmapBytes - 1) / FS_BLOCK_SIZE + 1;
	numBlocks		  -= headerPtr->fdBitmapBlocks;
	offset			  += headerPtr->fdBitmapBlocks;

	headerPtr->fileDescOffset = offset;
	headerPtr->numFileDesc	  = numFiles;
	numBlocks		  -= numFiles / FSDM_FILE_DESC_PER_BLOCK;
	offset			  += numFiles / FSDM_FILE_DESC_PER_BLOCK;
	/*
	 * The data blocks will start on a cylinder.  Try the next
	 * cylinder boundary after the start of the bitmap. If the
	 * bitmap won't fit in a cylinder then steal a cylinder from the
	 * data blocks.
	 */
	headerPtr->bitmapOffset	  = offset;
	headerPtr->dataOffset	  = ((offset-1) / geoPtr->blocksPerCylinder + 1)
				     * geoPtr->blocksPerCylinder;
	headerPtr->dataBlocks	  = headerPtr->numCylinders *
					  geoPtr->blocksPerCylinder -
					  headerPtr->dataOffset;
	bytesPerCylinder	  = (geoPtr->blocksPerCylinder + 1) / 2;
	bitmapBytes		  = bytesPerCylinder * (headerPtr->dataBlocks / 
					geoPtr->blocksPerCylinder); 

	headerPtr->bitmapBlocks	  = (bitmapBytes - 1) / FS_BLOCK_SIZE + 1;
	while (headerPtr->bitmapBlocks > 
		headerPtr->dataOffset - headerPtr->bitmapOffset) {
	    /*
	     * If the bit map blocks won't fit in the number cylinders
	     * we've allocated to them then we need to
	     * steal a cylinder from the data blocks.
	     */
	    headerPtr->dataOffset += geoPtr->blocksPerCylinder;
	    headerPtr->dataBlocks -= geoPtr->blocksPerCylinder;
	    bitmapBytes -= geoPtr->blocksPerCylinder * bytesPerCylinder;
	    bitmapBytes		  = bytesPerCylinder * (headerPtr->dataBlocks / 
				    geoPtr->blocksPerCylinder); 
	    headerPtr->bitmapBlocks = (bitmapBytes - 1) / FS_BLOCK_SIZE + 1;
	}
	/*
	 * Check the size of the bit map against space available for it
	 * between the end of the file descriptors and the start of the
	 * data blocks.
	 */
	if (headerPtr->dataOffset - headerPtr->bitmapOffset <
	    headerPtr->bitmapBlocks) {
	    int numBlocksNeeded;
	    /*
	     * Need more blocks to hold the bitmap.  Reduce the number
	     * of file descriptors to get the blocks and re-iterate.
	     */
	    numBlocksNeeded = headerPtr->bitmapBlocks -
		(headerPtr->dataOffset - headerPtr->bitmapOffset);
	    numFiles -= numBlocksNeeded * FSDM_FILE_DESC_PER_BLOCK;
	} else if (headerPtr->dataOffset - headerPtr->bitmapOffset >
		    headerPtr->bitmapBlocks) {
	    int extraBlocks;
	    /*
	     * There are extra blocks between the end of the file descriptors
	     * and the start of the bitmap.  Increase the number of
	     * file descriptors and re-iterate.
	     */
	    extraBlocks = headerPtr->dataOffset - headerPtr->bitmapOffset -
		    headerPtr->bitmapBlocks;
	    numFiles += extraBlocks * FSDM_FILE_DESC_PER_BLOCK;
	}
    } while (headerPtr->dataOffset - headerPtr->bitmapOffset !=
		headerPtr->bitmapBlocks);
    headerPtr->dataCylinders	= headerPtr->dataBlocks /
				  geoPtr->blocksPerCylinder ;
}

/*
 *----------------------------------------------------------------------
 *
 * SetSummaryInfo --
 *
 *	Initialize the summary information for the domain.  
 *
 * Results:
 *	A return code.
 *
 * Side effects:
 *	Fill in the summary info.
 *
 *----------------------------------------------------------------------
 */
static void
SetSummaryInfo(headerPtr, summaryPtr)
    Ofs_DomainHeader *headerPtr;	/* Domain header to summarize */
    Ofs_SummaryInfo *summaryPtr;	/* Summary info to fill in */
{

    bzero((Address)summaryPtr, sizeof(Ofs_SummaryInfo));

    strcpy(summaryPtr->domainPrefix, "(new domain)");
    /*
     * 20 KB is already allocated, 4 for the root directory,
     * 8 for lost+found, and 8 for .fscheck.out
     */
    summaryPtr->numFreeKbytes = headerPtr->dataBlocks * (FS_BLOCK_SIZE / 1024)
				- 20;
    /*
     * 5 file descriptors are already used, 0 and 1 are reserved,
     * 2 is for the root, 3 is for lost+found, and 4 is for .fscheck.out
     */
    summaryPtr->numFreeFileDesc = headerPtr->numFileDesc - 5;
    /*
     * The summary state field is unused.
     */
    summaryPtr->state = 0;
    /*
     * The domain number under which this disk partition is mounted is
     * recorded on disk so servers re-attach disks under the same "name".
     * We set it to the special value so it gets a new number assigned
     * when it is first attached.
     */
    summaryPtr->domainNumber = -1;
    /*
     * The flags field is used to record whether or not the disk has been
     * safely "sync"ed to disk upon shutdown.
     */
    summaryPtr->flags = 0;
    summaryPtr->attachSeconds = 0;
    summaryPtr->detachSeconds = 0;
    summaryPtr->fixCount = 0;
}

/*
 *----------------------------------------------------------------------
 *
 * WriteAllFileDescs --
 *
 *	Write out all of the file descriptors to disk.
 *
 * Results:
 *	SUCCESS if the descriptors were written, FAILURE otherwise.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
WriteAllFileDescs(partFID, headerPtr)
    int partFID;	/* File handle for partition to format */
    register Ofs_DomainHeader *headerPtr;
{
    ReturnStatus status;
    char *bitmap;
    char block[FS_BLOCK_SIZE];
    register Fsdm_FileDescriptor *fileDescPtr;
    register int index;
    int j;

    bitmap = MakeFileDescBitmap(headerPtr);
    if (!printOnly) {
	status = Disk_BlockWrite(partFID, headerPtr, headerPtr->fdBitmapOffset,
				headerPtr->fdBitmapBlocks, (Address)bitmap);
	if (status != SUCCESS) {
	    printf("Couldn't write bitmap\n");
	    return(status);
	}
    }
    /*
     * Make the first block of file descriptors.  This contains some
     * canned file descriptors for the root, bad block file, the
     * lost and found directory and fscheck's output file.  
     */
    bzero(block, FS_BLOCK_SIZE);
    for (index = 0;
         index < FSDM_FILE_DESC_PER_BLOCK;
	 index++ ) {
	fileDescPtr = (Fsdm_FileDescriptor *)((int)block +
					   index * FSDM_MAX_FILE_DESC_SIZE);
	fileDescPtr->magic = FSDM_FD_MAGIC;
	if (index < FSDM_BAD_BLOCK_FILE_NUMBER) {
	    fileDescPtr->flags = FSDM_FD_RESERVED;
	} else if (index == FSDM_BAD_BLOCK_FILE_NUMBER) {
	    InitDesc(fileDescPtr, FS_FILE, 0, -1, -1, -1, 0, 0, 0, 
		curTime.tv_sec);
	} else if (index == FSDM_ROOT_FILE_NUMBER) {
	    InitDesc(fileDescPtr, FS_DIRECTORY, FS_BLOCK_SIZE, -1, -1, -1, 0,
		    0, 0755, curTime.tv_sec);
	    /*
	     * Place the data in the first file system block.
	     */
	    fileDescPtr->direct[0] = 0;
	} else if (index == FSDM_LOST_FOUND_FILE_NUMBER) {
	    InitDesc(fileDescPtr, FS_DIRECTORY, 2 * FS_BLOCK_SIZE,-1, -1, -1, 0,
		    0, 0777, curTime.tv_sec);
	    for (j = 0; j < OFS_NUM_LOST_FOUND_BLOCKS ; j++) {
		fileDescPtr->direct[j] = FS_FRAGMENTS_PER_BLOCK 
		    * (j + 1);
	    }
	} else if (index == FSDM_LOST_FOUND_FILE_NUMBER+1) {
	    InitDesc(fileDescPtr, FS_FILE, 2 * FS_BLOCK_SIZE, -1, -1, -1, 0,
		    0, 0755, curTime.tv_sec);
	    for (j = 0; j < 2 ; j++) {
		fileDescPtr->direct[j] = FS_FRAGMENTS_PER_BLOCK 
		    * (j + 1 + OFS_NUM_LOST_FOUND_BLOCKS);
	    }
	} else {
	    fileDescPtr->flags = FSDM_FD_FREE;
	}
    }
    if (!printOnly) {
	/*
	 * Write out the first, specially hand crafted, block of file
	 * descriptors.
	 */
	status = Disk_BlockWrite(partFID, headerPtr, headerPtr->fileDescOffset,
				    1, (Address)block);
	if (status != SUCCESS) {
	    return(status);
	}
	/*
	 * Redo the block for the remaining file descriptors
	 */
	bzero(block, FS_BLOCK_SIZE);
	for (index = 0;
	     index < FSDM_FILE_DESC_PER_BLOCK;
	     index++ ) {
	    fileDescPtr = (Fsdm_FileDescriptor *)((int)block + index *
					       FSDM_MAX_FILE_DESC_SIZE);
	    fileDescPtr->magic = FSDM_FD_MAGIC;
	    fileDescPtr->flags = FSDM_FD_FREE;
	}
	/*
	 * Write out the remaining file descriptors.
	 */
	for (index = FSDM_FILE_DESC_PER_BLOCK;
	     index < headerPtr->numFileDesc;
	     index += FSDM_FILE_DESC_PER_BLOCK) {
	    status = Disk_BlockWrite(partFID, headerPtr,
		     headerPtr->fileDescOffset + (index/FSDM_FILE_DESC_PER_BLOCK),
		     1, (Address)block);
	    if (status != SUCCESS) {
		return(status);
	    }
	}
    } else {
	status = SUCCESS;
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * MakeFileDescBitmap --
 *
 *	Compute out the bitmap for file descriptor array to disk.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static char *
MakeFileDescBitmap(headerPtr)
    register Ofs_DomainHeader *headerPtr;
{
    register char *bitmap;
    register int index;

    /*
     * Allocate and initialize the bitmap to all 0"s to mean all free.
     */
    bitmap = (char *)malloc((unsigned) headerPtr->fdBitmapBlocks *
				 FS_BLOCK_SIZE);
    bzero((Address)bitmap, headerPtr->fdBitmapBlocks * FS_BLOCK_SIZE);

    /*
     * Reserve file descriptors 0, 1, 2, 3, and 4. File number 0 is not used at 
     * all in the filesystem.  File number 1 is for the file with bad blocks.
     * File number 2 (FSDM_ROOT_FILE_NUMBER) is the domain's root directory.
     * File number 3 (FS_LOST_FOUND_NUMBER) is the directory where lost
     * files are stored.
     * File number 4 is for fscheck's output.
     *
     * IF THIS CHANGES remember to fix SetSummaryInfo
     */
    bitmap[0] |= 0xf8;
    freeFDNum = 5;
    /*
     * Set the bits in the map at the end that don't correspond to
     * any existing file descriptors.
     */
    index = headerPtr->numFileDesc / BITS_PER_BYTE;
    if (headerPtr->numFileDesc % BITS_PER_BYTE) {
	register int bitIndex;
	/*
	 * Take care the last byte that only has part of its bits set.
	 */
	for (bitIndex = headerPtr->numFileDesc % BITS_PER_BYTE;
	     bitIndex < BITS_PER_BYTE;
	     bitIndex++) {
	    bitmap[index] |= 1 << ((BITS_PER_BYTE - 1) - bitIndex);
	}
	index++;
    }
    index++;
    for ( ; index < headerPtr->fdBitmapBlocks * FS_BLOCK_SIZE; index++) {
	bitmap[index] = 0xff;
    }

    if (printOnly) {
	Disk_PrintFileDescBitmap(headerPtr, bitmap);
    }
    return(bitmap);
}

/*
 *----------------------------------------------------------------------
 *
 * WriteBitmap --
 *
 *	Write out the bitmap for the data blocks.  This knows that the
 *	first 4K is allocated to the root directory, 8K is
 *	allocated to lost and found, and 8K to .fscheck.out.
 *
 * Results:
 *	A return code from the writes.
 *
 * Side effects:
 *	Write the bitmap.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
WriteBitmap(partFID, headerPtr)
    int partFID;
    register Ofs_DomainHeader *headerPtr;
{
    ReturnStatus status;
    char *bitmap;

    bitmap = (char *)malloc((unsigned) headerPtr->bitmapBlocks * FS_BLOCK_SIZE);
    bzero(bitmap, headerPtr->bitmapBlocks * FS_BLOCK_SIZE);
    /*
     * Set the bits corresponding to the 4K used for the root directory,
     * the 8K reserved for lost and found, and the 8K reserved for
     * .fscheck.out.
     *   ________
     *	|0______7|	Bits are numbered like this in a byte.
     *
     * IF THIS CHANGES remember to fix SetSummaryInfo()
     */
    bitmap[0] |= 0xff;
    bitmap[1] |= 0xff;
    bitmap[2] |= 0xf0;
    freeBlockNum = 5;
    if (printOnly) {
	Disk_PrintDataBlockBitmap(headerPtr, bitmap);
	status = SUCCESS;
    } else {
	status = Disk_BlockWrite(partFID, headerPtr, headerPtr->bitmapOffset,
			    headerPtr->bitmapBlocks, (Address)bitmap);
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * WriteRootDirectory --
 *
 *	Write the data blocks of the root directory.
 *
 * Results:
 *	A return code from the writes.
 *
 * Side effects:
 *	Write the root directory"s data block.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
WriteRootDirectory(partFID, headerPtr, fdPtr)
    int 			partFID;	/* Raw disk handle. */
    register Ofs_DomainHeader 	*headerPtr;	/* Domain header. */
    Fsdm_FileDescriptor		*fdPtr;		/* Root file desc */
{
    ReturnStatus 	status;
    char 		block[FS_BLOCK_SIZE];
    Fslcl_DirEntry 	*dirEntryPtr;
    int 		i;
    DirIndexInfo	indexInfo;

    CreateDir(block, 1, FSDM_ROOT_FILE_NUMBER, FSDM_ROOT_FILE_NUMBER);
    if (printOnly) {
	int offset;
	printf("Root Directory\n");
	offset = 0;
	for (i = 0; i < 4; i++) {
	    dirEntryPtr = (Fslcl_DirEntry *)((int)block + offset);
	    Disk_PrintDirEntry(dirEntryPtr);
	    offset += dirEntryPtr->recordLength;
	}
    } else {
	status = Disk_BlockWrite(partFID, headerPtr, headerPtr->dataOffset,
	    1, block);
	if (status != 0) {
	    fprintf(stderr, "WriteRootDirectory: Couldn't write directory\n");
	}
    }
    status = OpenDir(partFID, headerPtr, fdPtr, &indexInfo, &dirEntryPtr);
    if (status != SUCCESS) {
	fprintf(stderr, "Can't open root file descriptor\n");
	return status;
    }
    status = AddToDirectory(partFID, headerPtr, !printOnly, &indexInfo, 
			&dirEntryPtr, FSDM_LOST_FOUND_FILE_NUMBER, 
			"lost+found");
    if (status != SUCCESS) {
	fprintf(stderr, "Can't add lost+found to root directory.\n");
	return status;
    }
    fdPtr->numLinks++;
    status = AddToDirectory(partFID, headerPtr, !printOnly, &indexInfo,
			&dirEntryPtr, FSDM_LOST_FOUND_FILE_NUMBER + 1, 
			".fscheck.out");
    if (status != SUCCESS) {
	fprintf(stderr, "Can't add .fscheck.out to root directory.\n");
	return status;
    }
    CloseDir(partFID, headerPtr, !printOnly, &indexInfo);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * WriteLostFoundDirectory --
 *
 *	Write the data blocks of the lost and found directory.
 *
 * Results:
 *	A return code from the writes.
 *
 * Side effects:
 *	Write the root directory"s data block.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
WriteLostFoundDirectory(partFID, headerPtr)
    int partFID;
    register Ofs_DomainHeader *headerPtr;
{
    ReturnStatus 	status = SUCCESS;
    char 		block[OFS_NUM_LOST_FOUND_BLOCKS * FS_BLOCK_SIZE];
    Fslcl_DirEntry 	*dirEntryPtr;
    int 		i;

    CreateDir(block, OFS_NUM_LOST_FOUND_BLOCKS, FSDM_LOST_FOUND_FILE_NUMBER, 
	FSDM_ROOT_FILE_NUMBER);
    if (printOnly) {
	int offset;
	printf("lost+found Directory\n");
	offset = 0;
	for (i = 0; i < 4; i++) {
	    dirEntryPtr = (Fslcl_DirEntry *)((int)block + offset);
	    Disk_PrintDirEntry(dirEntryPtr);
	    offset += dirEntryPtr->recordLength;
	}
    } else {
	status = Disk_BlockWrite(partFID, headerPtr, headerPtr->dataOffset + 1,
			OFS_NUM_LOST_FOUND_BLOCKS, block);
	if (status != 0) {
	    fprintf(stderr, 
		"WriteLostFoundDirectory: Couldn't write directory\n");
	}
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * InitDesc --
 *
 *	Set up a file descriptor as allocated.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	File descriptor fields filled in.
 *
 *----------------------------------------------------------------------
 */
static void
InitDesc(fileDescPtr, fileType, numBytes, devServer, devType, devUnit, uid,
	gid, permissions, time)
    Fsdm_FileDescriptor	*fileDescPtr;
    int			fileType;
    int			numBytes;
    int			devServer;
    int			devType;
    int			devUnit;
    int			uid;
    int			gid;
    int			permissions;
    long		time;
{
    int		index;

    fileDescPtr->flags = FSDM_FD_ALLOC;
    fileDescPtr->fileType = fileType;
    fileDescPtr->permissions = permissions;
    fileDescPtr->uid = uid;
    fileDescPtr->gid = gid;
    fileDescPtr->lastByte = numBytes - 1;
    fileDescPtr->firstByte = -1;
    if (fileType == FS_DIRECTORY) {
	fileDescPtr->numLinks = 2;
    } else {
	fileDescPtr->numLinks = 1;
    }
    fileDescPtr->devServerID = devServer;
    fileDescPtr->devType = devType;
    fileDescPtr->devUnit = devUnit;

    /*
     * Set the time stamps.  This assumes that universal time,
     * not local time, is used for time stamps.
     */
    fileDescPtr->createTime = (int) time;
    fileDescPtr->accessTime = (int) time;
    fileDescPtr->descModifyTime = (int) time;
    fileDescPtr->dataModifyTime = (int) time;

    /*
     * Place the data in the first filesystem block.
     */
    for (index = 0; index < FSDM_NUM_DIRECT_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FSDM_NIL_INDEX;
    }
    for (index = 0; index < FSDM_NUM_INDIRECT_BLOCKS ; index++) {
	fileDescPtr->indirect[index] = FSDM_NIL_INDEX;
    }
    if (numBytes > 0) {
	int	numBlocks;

	numBlocks = (numBytes - 1) / FS_BLOCK_SIZE + 1;
	if (numBlocks > FSDM_NUM_DIRECT_BLOCKS) {
	    fileDescPtr->numKbytes = (numBlocks + 1) * (FS_BLOCK_SIZE / 1024);
	} else {
	    fileDescPtr->numKbytes = (numBytes + 1023) / 1024;
	}
    } else {
	fileDescPtr->numKbytes = 0;
    }

    fileDescPtr->version = 1;
}

/*
 *----------------------------------------------------------------------
 *
 * AddToDirectory --
 *
 *	Add the file descriptor to a directory.  
 *
 * Results:
 *	SUCCESS if the desciptor was added ok, FAILURE otherwise
 *
 * Side effects:
 *	The directory is modified to contain the file.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
AddToDirectory(fid, headerPtr, writeDisk, dirIndexPtr, dirEntryPtrPtr, 
    fileNumber, fileName)
    int			fid;		/* Handle on raw disk. */
    Ofs_DomainHeader 	*headerPtr;	/* Domain header. */
    Boolean		writeDisk;	/* Write the disk? */
    DirIndexInfo	*dirIndexPtr;	/* Index information. */
    Fslcl_DirEntry	**dirEntryPtrPtr; /* Directory entry. */
    int		 	fileNumber;	/* File number to add. */
    char 		*fileName;	/* Name of file to add. */
{
    int		 	nameLength;
    int		 	recordLength;
    int		 	leftOver;
    int			oldRecLength;
    Fslcl_DirEntry	*dirEntryPtr;
    ReturnStatus 	status = SUCCESS;

    dirEntryPtr = *dirEntryPtrPtr;

    nameLength = strlen(fileName);
    recordLength = Fslcl_DirRecLength(nameLength);

    while (1) {
	if (dirEntryPtr->fileNumber != 0) {
	    oldRecLength = Fslcl_DirRecLength(dirEntryPtr->nameLength);
	    leftOver = dirEntryPtr->recordLength - oldRecLength;
	    if (leftOver >= recordLength) {
		dirEntryPtr->recordLength = oldRecLength;
		dirEntryPtr = 
			(Fslcl_DirEntry *) ((int) dirEntryPtr + oldRecLength);
		dirEntryPtr->recordLength = leftOver;
		dirIndexPtr->dirOffset += oldRecLength;
	    } else {
		status = NextDirEntry(fid, headerPtr, writeDisk,
			    dirIndexPtr, &dirEntryPtr);
		if (status != SUCCESS) {
		    fprintf(stderr, "Can't add to directory\n");
		    return status;
		}
		continue;
	    }
	} else if (dirEntryPtr->recordLength < recordLength) {
	    status = NextDirEntry(fid, headerPtr, writeDisk,
			dirIndexPtr, &dirEntryPtr);
	    if (status != SUCCESS) {
		fprintf(stderr, "Can't add to directory\n");
		return status;
	    }
	    continue;
	}
	dirEntryPtr->fileNumber = fileNumber;
	dirEntryPtr->nameLength = nameLength;
	(void)strcpy(dirEntryPtr->fileName, fileName);
	leftOver = dirEntryPtr->recordLength - recordLength;
	if (leftOver > FSLCL_DIR_ENTRY_HEADER) {
	    dirEntryPtr->recordLength = recordLength;
	    dirEntryPtr =(Fslcl_DirEntry *) ((int) dirEntryPtr + recordLength);
	    dirEntryPtr->fileNumber = 0;
	    dirEntryPtr->recordLength = leftOver;
	    dirIndexPtr->dirOffset += recordLength;
	} else {
	    status = NextDirEntry(fid, headerPtr, writeDisk, 
			    dirIndexPtr, &dirEntryPtr);
	    if (status != SUCCESS) {
		fprintf(stderr, "Can't add to directory\n");
		return status;
	    }
	}
	*dirEntryPtrPtr = dirEntryPtr;
	return status;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * OpenDir --
 *
 *	Set up the structure to allow moving through the given directory.
 *
 * Results:
 *	SUCCESS if the open was successful, FAILURE otherwise
 *
 * Side effects:
 *	The index structure is set up and *dirEntryPtrPtr set to point to
 *	the first directory entry.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
OpenDir(fid, headerPtr, fdPtr, indexInfoPtr, dirEntryPtrPtr)
    int			fid;		/* Handle on raw disk. */
    Ofs_DomainHeader 	*headerPtr;	/* Domain header. */
    Fsdm_FileDescriptor	*fdPtr;		/* The file descriptor for the
					 * directory. */
    DirIndexInfo 	*indexInfoPtr;	/* Index info struct */
    Fslcl_DirEntry	**dirEntryPtrPtr; /* Current directory entry */
{

    *dirEntryPtrPtr = NULL;
    if (fdPtr->lastByte == -1) {
	/*
	 * Empty directory.
	 */
	return SUCCESS;
    } else if ((fdPtr->lastByte + 1) % FSLCL_DIR_BLOCK_SIZE != 0) {
	fprintf(stderr, "Directory not multiple of directory block size.\n");
	return FAILURE;
    } else if (fdPtr->fileType != FS_DIRECTORY) {
	fprintf(stderr, "OpenDir: Not a directory\n");
	return FAILURE;
    }

    /*
     * Initialize the index structure.
     */
    indexInfoPtr->fdPtr = fdPtr;
    indexInfoPtr->blockNum = 0;
    indexInfoPtr->blockAddr = fdPtr->direct[0] / FS_FRAGMENTS_PER_BLOCK + 
			      headerPtr->dataOffset;
    /*
     * Read in the directory block.
     */
    if (fdPtr->lastByte != FS_BLOCK_SIZE - 1) {
	fprintf(stderr, "We created a directory that's not 4K?\n");
	return FAILURE;
    }
    if (Disk_BlockRead(fid, headerPtr,
		       indexInfoPtr->blockAddr,
		       1, indexInfoPtr->dirBlock) < 0) {
	fprintf(stderr, "OpenDir: Read failed block %d\n",
			indexInfoPtr->blockAddr);
	return FAILURE;
    } 
    indexInfoPtr->dirOffset = 0;
    *dirEntryPtrPtr = (Fslcl_DirEntry *) indexInfoPtr->dirBlock;
    return SUCCESS;
}


/*
 *----------------------------------------------------------------------
 *
 * NextDirEntry --
 *
 *	Get a pointer to the next directory entry.
 *
 * Results:
 *	SUCCESS if the next entry was found ok, FAILURE otherwise
 *
 * Side effects:
 *	The index structure is modified and *dirEntryPtrPtr set to point
 *	to the next directory entry.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
NextDirEntry(fid, headerPtr, writeDisk, indexInfoPtr, dirEntryPtrPtr)
    int			fid;		/* Handle on raw disk. */
    Ofs_DomainHeader 	*headerPtr;	/* Domain header. */
    Boolean		writeDisk;	/* Write the disk? */
    DirIndexInfo 	*indexInfoPtr;	/* Index information. */
    Fslcl_DirEntry	**dirEntryPtrPtr; /* Current directory entry */
{
    Fslcl_DirEntry	*dirEntryPtr;	

    dirEntryPtr = *dirEntryPtrPtr;
    indexInfoPtr->dirOffset += dirEntryPtr->recordLength;
    if (indexInfoPtr->dirOffset < FS_BLOCK_SIZE) {
	/*
	 * The next directory entry is in the current block.
	 */
	*dirEntryPtrPtr = (Fslcl_DirEntry *)
			&(indexInfoPtr->dirBlock[indexInfoPtr->dirOffset]);
	return SUCCESS;
    } else {
	Fsdm_FileDescriptor	*fdPtr;
	int			i;

	printf("Adding new block to directory ...\n");

	/*
	 * Write out the current block and set up the next one.
	 */
	if (writeDisk) {
	    if (Disk_BlockWrite(fid, headerPtr, indexInfoPtr->blockAddr,
				1, indexInfoPtr->dirBlock) < 0) {
		fprintf(stderr, "NextDirEntry: Write failed block %d\n",
				indexInfoPtr->blockAddr);
		return FAILURE;
	    }
	}
	fdPtr = indexInfoPtr->fdPtr;
	fdPtr->lastByte += FS_BLOCK_SIZE;
	fdPtr->numKbytes += FS_FRAGMENTS_PER_BLOCK;
	indexInfoPtr->blockNum++;
	fdPtr->direct[indexInfoPtr->blockNum] = 
				freeBlockNum * FS_FRAGMENTS_PER_BLOCK;
	MarkDataBitmap(headerPtr, cylBitmapPtr, freeBlockNum,
		       FS_FRAGMENTS_PER_BLOCK);
	indexInfoPtr->blockAddr = freeBlockNum + headerPtr->dataOffset;
	freeBlockNum++;
	for (i = 0, dirEntryPtr = (Fslcl_DirEntry *)indexInfoPtr->dirBlock; 
	     i < FS_BLOCK_SIZE / FSLCL_DIR_BLOCK_SIZE;
     i++,dirEntryPtr=(Fslcl_DirEntry *)((unsigned)dirEntryPtr+FSLCL_DIR_BLOCK_SIZE)) {
	    dirEntryPtr->fileNumber = 0;
	    dirEntryPtr->recordLength = FSLCL_DIR_BLOCK_SIZE;
	    dirEntryPtr->nameLength = 0;
	}
	indexInfoPtr->dirOffset = 0;
	*dirEntryPtrPtr = (Fslcl_DirEntry *) indexInfoPtr->dirBlock;
	return SUCCESS;
    }
}


/*
 *----------------------------------------------------------------------
 *
 * CloseDir --
 *
 *	Flushes the current directory block to disk, if necessary.
 *
 * Results:
 *	SUCCESS if the directory was closed ok, FAILURE otherwise
 *
 * Side effects:
 *	Stuff is written to disk.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
CloseDir(fid, headerPtr, writeDisk, indexInfoPtr)
    int			fid;		/* Handle on raw disk. */
    Ofs_DomainHeader 	*headerPtr;	/* Domain header. */
    Boolean		writeDisk;	/* Write the disk? */
    DirIndexInfo 	*indexInfoPtr;	/* Index information. */
{

    if (writeDisk) {
	if (Disk_BlockWrite(fid, headerPtr, indexInfoPtr->blockAddr,
			    1, indexInfoPtr->dirBlock) < 0) {
	    fprintf(stderr, "CloseDir: Write (2) failed block %d\n",
			    indexInfoPtr->blockAddr);
	    return FAILURE;
	}
    }
    return SUCCESS;
}

/*
 *----------------------------------------------------------------------
 *
 * ReadFileDesc --
 *
 *	Return the given file descriptor.
 *
 * Results:
 *	SUCCESS if file descriptor was read ok, FAILURE otherwise
 *
 * Side effects:
 *	The file descriptor struct is filled in.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
ReadFileDesc(fid, headerPtr, fdNum, fdPtr)
    int			fid;		/* Handle on raw disk. */
    Ofs_DomainHeader 	*headerPtr;	/* Domain header. */
    int			fdNum;		/* File number. */
    Fsdm_FileDescriptor	*fdPtr;		/* Place to store fd. */
{
    static char		block[FS_BLOCK_SIZE];
    int			blockNum;
    int			offset;

    blockNum = headerPtr->fileDescOffset + fdNum / FSDM_FILE_DESC_PER_BLOCK;
    offset = (fdNum & (FSDM_FILE_DESC_PER_BLOCK - 1)) * FSDM_MAX_FILE_DESC_SIZE;
    if (Disk_BlockRead(fid, headerPtr, blockNum, 1, 
		       (Address) block) < 0) {
	fprintf(stderr, "ReadFileDesc: Read failed\n");
	return FAILURE;
    }
    bcopy((Address)&block[offset], (Address)fdPtr, sizeof(Fsdm_FileDescriptor));
    return SUCCESS;
}


/*
 *----------------------------------------------------------------------
 *
 * WriteFileDesc --
 *
 *	Write the given file descriptor.
 *
 * Results:
 *	SUCCESS if the write was successful, FAILURE otherwise
 *
 * Side effects:
 *	Stuff is written to disk.
 *
 *----------------------------------------------------------------------
 */
static ReturnStatus
WriteFileDesc(fid, headerPtr, fdNum, fdPtr)
    int			fid;		/* Handle on raw disk. */
    Ofs_DomainHeader 	*headerPtr;	/* Domain header. */
    int			fdNum;		/* File number. */
    Fsdm_FileDescriptor	*fdPtr;		/* Place to store fd. */
{
    static char		block[FS_BLOCK_SIZE];
    int			blockNum;
    int			offset;

    blockNum = headerPtr->fileDescOffset + fdNum / FSDM_FILE_DESC_PER_BLOCK;
    offset = (fdNum & (FSDM_FILE_DESC_PER_BLOCK - 1)) * FSDM_MAX_FILE_DESC_SIZE;
    if (Disk_BlockRead(fid, headerPtr, blockNum, 1, 
		       (Address) block) < 0) {
	fprintf(stderr, "WriteFileDesc: Read failed\n");
	return FAILURE;
    }
    bcopy((Address)fdPtr, (Address)&block[offset], sizeof(Fsdm_FileDescriptor));
    if (Disk_BlockWrite(fid, headerPtr, blockNum, 1, 
		       (Address) block) < 0) {
	fprintf(stderr, "WriteFileDesc: Write failed\n");
	return FAILURE;
    }
    return SUCCESS;
}
/*
 *----------------------------------------------------------------------
 *
 * CreateDir --
 *
 *	Create a directory out of file system blocks.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	File system block set up as a directory.
 *
 *----------------------------------------------------------------------
 */
static void
CreateDir(blocks, numBlocks, dot, dotDot)
    Address	blocks;		/* Blocks to create directory in. */
    int		numBlocks;	/* Number of blocks. */
    int		dot;		/* File number of directory. */
    int		dotDot;		/* File number of parent. */
{
    Fslcl_DirEntry	*dirEntryPtr;
    char	*fileName;
    int		offset;
    int		length;
    int		i;

    dirEntryPtr = (Fslcl_DirEntry *)blocks;
    fileName = ".";
    length = strlen(fileName);
    dirEntryPtr->fileNumber = dot;
    dirEntryPtr->recordLength = Fslcl_DirRecLength(length);
    dirEntryPtr->nameLength = length;
    strcpy(dirEntryPtr->fileName, fileName);
    offset = dirEntryPtr->recordLength;

    dirEntryPtr = (Fslcl_DirEntry *)((int)blocks + offset);
    fileName = "..";
    length = strlen(fileName);
    dirEntryPtr->fileNumber = dotDot;
    dirEntryPtr->recordLength = FSLCL_DIR_BLOCK_SIZE - offset;
    dirEntryPtr->nameLength = length;
    strcpy(dirEntryPtr->fileName, fileName);
    /*
     * Fill out the rest of the directory with empty blocks.
     */
    for (dirEntryPtr = (Fslcl_DirEntry *)&blocks[FSLCL_DIR_BLOCK_SIZE], i = 1; 
	 i < (FS_BLOCK_SIZE * numBlocks) / FSLCL_DIR_BLOCK_SIZE;
	 i++,dirEntryPtr=(Fslcl_DirEntry *)((int)dirEntryPtr + FSLCL_DIR_BLOCK_SIZE)) {
	 dirEntryPtr->fileNumber = 0;
	 dirEntryPtr->recordLength = FSLCL_DIR_BLOCK_SIZE;
	 dirEntryPtr->nameLength = 0;
    }
}
int fragMasks[FS_FRAGMENTS_PER_BLOCK + 1] = {0x0, 0x08, 0x0c, 0x0e, 0x0f};


/*
 *----------------------------------------------------------------------
 *
 * MarkDataBitmap --
 *
 *	Mark the appropriate bits in the data block bitmap.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Data block marked.
 *
 *----------------------------------------------------------------------
 */
static void
MarkDataBitmap(headerPtr, cylBitmapPtr, blockNum, numFrags)
    Ofs_DomainHeader	*headerPtr;
    unsigned char	*cylBitmapPtr;
    int			blockNum;
    int			numFrags;
{
    unsigned char	*bitmapPtr;

    bitmapPtr = GetBitmapPtr(headerPtr, cylBitmapPtr, blockNum);
    if ((blockNum % headerPtr->geometry.blocksPerCylinder) & 0x1) {
	*bitmapPtr |= fragMasks[numFrags];
    } else {
	*bitmapPtr |= fragMasks[numFrags] << 4;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ReadFileDescBitmap --
 *
 *	Read in the file descriptor bitmap.
 *
 * Results:
 *	A pointer to the file descriptor bit map.
 *
 * Side effects:
 *	Memory allocated for the bit map.
 *
 *----------------------------------------------------------------------
 */
static unsigned char *
ReadFileDescBitmap(fid, headerPtr)
    int			fid;		/* Handle on raw disk. */
    Ofs_DomainHeader 	*headerPtr;	/* Domain header. */
{
    register unsigned char *bitmap;

    /*
     * Allocate the bitmap.
     */
    bitmap = (unsigned char *)malloc(
	(unsigned) headerPtr->fdBitmapBlocks * FS_BLOCK_SIZE);
    if (Disk_BlockRead(fid, headerPtr, headerPtr->fdBitmapOffset,
		  headerPtr->fdBitmapBlocks, (Address)bitmap) < 0) {
	fprintf(stderr, "ReadFileDescBitmap: Read failed");
	exit(1);
    }
    return(bitmap);
}

/*
 *----------------------------------------------------------------------
 *
 * ReadBitmap --
 *
 *	Read the bitmap off disk.
 *
 * Results:
 *	A pointer to the bitmap.
 *
 * Side effects:
 *	Memory allocated for the bit map.
 *
 *----------------------------------------------------------------------
 */
static unsigned char *
ReadBitmap(fid, headerPtr)
    int			fid;		/* Handle on raw disk. */
    Ofs_DomainHeader 	*headerPtr;	/* Domain header. */
{
    unsigned char *bitmap;

    bitmap = (unsigned char *)malloc((unsigned) 
	    headerPtr->bitmapBlocks * FS_BLOCK_SIZE);
    if (Disk_BlockRead(fid, headerPtr, headerPtr->bitmapOffset,
		  headerPtr->bitmapBlocks, (Address) bitmap) < 0) {
	fprintf(stderr, "ReadBitmap: Read failed");
	exit(1);
    }
    return(bitmap);
}

/*
 *----------------------------------------------------------------------
 *
 * WriteFileDescBitmap --
 *
 *	Write out the file descriptor bitmap.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static void
WriteFileDescBitmap(fid, headerPtr, bitmap)
    int			fid;		/* Handle on raw disk. */
    Ofs_DomainHeader 	*headerPtr;	/* Domain header. */
    unsigned char 	*bitmap;	/* Bitmap to write. */
{
    if (Disk_BlockWrite(fid, headerPtr, headerPtr->fdBitmapOffset,
		   headerPtr->fdBitmapBlocks, (Address)bitmap) < 0) {
	fprintf(stderr, "WriteFileDescBitmap: Write failed");
	exit(1);
    }
}

@


1.18
log
@lost+found has correct permissions, fixed bug in calculating number
of bitmap blocks, uses ofs.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/admin/fsmake/RCS/fsmake.c,v 1.17 90/10/10 15:59:33 rab Exp $ SPRITE (Berkeley)";
d15 1
d1378 1
d1391 3
a1393 1
	 * cylinder boundary after the start of the bitmap.
d1399 2
a1400 2
				      geoPtr->blocksPerCylinder -
				      headerPtr->dataOffset;
d1403 1
a1403 1
				    geoPtr->blocksPerCylinder); 
d1406 14
@


1.17
log
@Made changes so that fsmake will compile and run under unix.
Added an option to allow alternative spritehosts file.
Added static declarations.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/admin/fsmake/RCS/fsmake.c,v 1.16 90/09/12 08:47:49 jhh Exp Locker: rab $ SPRITE (Berkeley)";
d136 2
a137 2
static Fsdm_DomainHeader *headerPtr;	/* The domain header. */
static Fsdm_SummaryInfo *summaryPtr;	/* The summary info. */
d151 1
a151 1
    Fsdm_DomainHeader *headerPtr, int spriteID, int partition));
d153 1
a153 1
    Fsdm_Geometry *geoPtr));
d155 1
a155 1
    Fsdm_Geometry *geoPtr));
d157 3
a159 3
    Fsdm_DomainHeader *headerPtr));
static void SetSummaryInfo _ARGS_((Fsdm_DomainHeader *headerPtr,
    Fsdm_SummaryInfo *summaryPtr));
d161 2
a162 2
    Fsdm_DomainHeader *headerPtr));
static char *MakeFileDescBitmap _ARGS_((Fsdm_DomainHeader *headerPtr));
d164 1
a164 1
    Fsdm_DomainHeader *headerPtr));
d166 1
a166 1
    Fsdm_DomainHeader *headerPtr, Fsdm_FileDescriptor *fdPtr));
d168 1
a168 1
    Fsdm_DomainHeader *headerPtr));
d173 1
a173 1
    Fsdm_DomainHeader *headerPtr, Boolean writeDisk, DirIndexInfo *dirIndexPtr,
d175 1
a175 1
static ReturnStatus OpenDir _ARGS_((int fid, Fsdm_DomainHeader *headerPtr,
d178 1
a178 1
static ReturnStatus NextDirEntry _ARGS_((int fid, Fsdm_DomainHeader *headerPtr,
d181 1
a181 1
static ReturnStatus CloseDir _ARGS_((int fid, Fsdm_DomainHeader *headerPtr,
d183 1
a183 1
static ReturnStatus ReadFileDesc _ARGS_((int fid, Fsdm_DomainHeader *headerPtr,
d185 1
a185 1
static ReturnStatus WriteFileDesc _ARGS_((int fid, Fsdm_DomainHeader *headerPtr,
d189 1
a189 1
static void MarkDataBitmap _ARGS_((Fsdm_DomainHeader *headerPtr,
d192 1
a192 1
    Fsdm_DomainHeader *headerPtr));
d194 2
a195 2
    Fsdm_DomainHeader *headerPtr));
static void WriteFileDescBitmap _ARGS_((int fid, Fsdm_DomainHeader *headerPtr,
d525 2
a526 2
    Fsdm_DomainHeader	oldDomainHeader;
    Fsdm_SummaryInfo	oldSummaryInfo;
d582 1
a582 1
    headerPtr = (Fsdm_DomainHeader *) malloc(sizeof(Fsdm_DomainHeader));
d601 1
a601 1
    summaryPtr = (Fsdm_SummaryInfo *) malloc(DEV_BYTES_PER_SECTOR);
d603 7
d1011 1
a1011 1
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header to fill in */
d1015 1
a1015 1
    register Fsdm_Geometry *geoPtr;/* The layout information for the disk */
d1017 1
a1017 1
    headerPtr->magic = FSDM_DOMAIN_MAGIC;
d1071 1
a1071 1
    register Fsdm_Geometry 	*geoPtr;	/* Fancy geometry information */
d1087 1
a1087 1
    geoPtr->rotSetsPerCyl = FSDM_SCSI_MAPPING;
d1094 1
a1094 1
    for (index = 0 ; index < FSDM_MAX_ROT_POSITIONS ; index++) {
d1123 1
a1123 1
    register Fsdm_Geometry 	*geoPtr;	/* Fancy geometry information */
d1256 1
a1256 1
		for (index = numBlocks; index < FSDM_MAX_ROT_POSITIONS; index++){
d1281 1
a1281 1
    for (index = 0 ; index < FSDM_MAX_ROT_POSITIONS ; index++) {
d1311 1
a1311 1
    register Fsdm_DomainHeader *headerPtr;
d1313 1
a1313 1
    register Fsdm_Geometry *geoPtr;
d1324 1
d1397 4
a1400 2
	bitmapBytes		  = (headerPtr->dataBlocks * DISK_KBYTES_PER_BLOCK -
				       1) / BITS_PER_BYTE + 1;
d1452 2
a1453 2
    Fsdm_DomainHeader *headerPtr;	/* Domain header to summarize */
    Fsdm_SummaryInfo *summaryPtr;	/* Summary info to fill in */
d1456 1
a1456 1
    bzero((Address)summaryPtr, sizeof(Fsdm_SummaryInfo));
d1509 1
a1509 1
    register Fsdm_DomainHeader *headerPtr;
d1553 2
a1554 2
		    0, 0755, curTime.tv_sec);
	    for (j = 0; j < FSDM_NUM_LOST_FOUND_BLOCKS ; j++) {
d1563 1
a1563 1
		    * (j + 1 + FSDM_NUM_LOST_FOUND_BLOCKS);
d1627 1
a1627 1
    register Fsdm_DomainHeader *headerPtr;
d1699 1
a1699 1
    register Fsdm_DomainHeader *headerPtr;
d1747 1
a1747 1
    register Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
d1815 1
a1815 1
    register Fsdm_DomainHeader *headerPtr;
d1818 1
a1818 1
    char 		block[FSDM_NUM_LOST_FOUND_BLOCKS * FS_BLOCK_SIZE];
d1822 1
a1822 1
    CreateDir(block, FSDM_NUM_LOST_FOUND_BLOCKS, FSDM_LOST_FOUND_FILE_NUMBER, 
d1835 1
a1835 1
			FSDM_NUM_LOST_FOUND_BLOCKS, block);
d1944 1
a1944 1
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
d2033 1
a2033 1
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
d2100 1
a2100 1
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
d2175 1
a2175 1
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
d2209 1
a2209 1
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
d2247 1
a2247 1
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
d2345 1
a2345 1
    Fsdm_DomainHeader	*headerPtr;
d2378 1
a2378 1
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
d2413 1
a2413 1
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
d2445 1
a2445 1
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
@


1.16
log
@Lots and lots of changes.
@
text
@d11 2
a12 2
static char rcsid[] = "$Header: /sprite/src/admin/fsmake/RCS/fsmake.c,v 1.14.1.1 90/07/02 22:15:18 jhh Exp $ SPRITE (Berkeley)";
#endif not lint
d19 1
a19 1
int kbytesToFileDesc = 4;	/* The ratio of kbytes to
d21 1
a21 1
Boolean printOnly = TRUE;	/* Stop after computing the domain header
d23 2
a24 1
Boolean overlapBlocks = FALSE;	/* Allow filesystem blocks to overlap track
d26 1
a26 1
Boolean scsiDisk = TRUE;	/* If TRUE then simpler geometry is computed
d32 2
a33 2
int	bootSectors = -1;	/* Number of boot sectors. */
int	hostID	= 0;		/* Host id to write into domain header. 
d35 3
a37 2
Boolean repartition = FALSE;	/* If TRUE then the partition map is changed. */
Boolean reconfig = FALSE;	/* If TRUE then the disk configuration
d39 2
a40 1
Boolean partdisktab = FALSE;	/* If TRUE then read the partition map from
d42 2
a43 1
Boolean configdisktab = FALSE;	/* If TRUE then read the config information
d47 5
a51 5
char *disktabName = "/etc/disktab"; /* Name of disktab file. */
char *sizeString = NULL;	/* Size of partitions. */
char *diskType = NULL;		/* Type of disk (e.g.rz55). */
char *labelTypeName = NULL;	/* Type of label (e.g. sun). */
char *dirName = NULL;		/* Name of directory that contains files to
d53 3
d63 7
a69 7
char *deviceName;		/* Set to "rsd0" or "rxy1", etc. */
char *partName;			/* Set to "a", "b", "c" ... "g" */
char *rawDeviceName;		/* Set to "raw_rsd00", etc */
char defaultFirstPartName[] = "a";
char *firstPartName = defaultFirstPartName;
char defaultDevDirectory[] = "/dev";
char *devDirectory = defaultDevDirectory;
d71 1
a71 1
char *hostIDString = NULL;
d73 1
a73 1
Option optionArray[] = {
d118 2
a119 1

d121 1
a121 1
int numOptions = sizeof(optionArray) / sizeof(Option);
d127 1
a127 1
struct timeval curTime;
d129 3
a131 3
int			freeFDNum;	/* The currently free file descriptor.*/
int			freeBlockNum;	/* The currently free data block. */
unsigned char		*fdBitmapPtr;	/* Pointer to the file descriptor
d133 2
a134 2
unsigned char		*cylBitmapPtr;	/* Pointer to the cylinder bit map. */
int			bytesPerCylinder;/* The number of bytes in
d136 2
a137 2
Fsdm_DomainHeader 	*headerPtr;	/* The domain header. */
Fsdm_SummaryInfo 	*summaryPtr;	/* The summary info. */
d139 1
a139 1
char *myName;
d143 54
a196 15
void SetSummaryInfo();
ReturnStatus SetDomainHeader();
void SetDiskGeometry();
void SetSCSIDiskGeometry();
void SetDomainParts();
void SetRootFileDescriptor();
void SetBadBlockFileDescriptor();
void SetLostFoundFileDescriptor();
void SetEmptyFileDescriptor();
void SetFscheckOutFileDescriptor();
ReturnStatus WriteFileDesc();
void WriteFileDescBitmap();
ReturnStatus WriteBitmap();
char *MakeFileDescBitmap();
void Usage();
d219 1
d304 1
d426 1
d428 1
a428 1
    
d441 3
a443 1
    } else {
d493 1
a493 1
void
d515 1
a515 1
ReturnStatus
d645 1
a645 1
void
d656 1
a656 1
    Fslcl_DirEntry	*unixDirEntPtr;
a674 1
    
d676 1
d721 3
a723 6
    for (unixDirEntPtr = (Fslcl_DirEntry *)readdir(unixDirPtr);
	   unixDirEntPtr != NULL;
	   unixDirEntPtr = (Fslcl_DirEntry *)readdir(unixDirPtr)) {

	if (unixDirEntPtr->nameLength == 1 && 
	    strncmp(unixDirEntPtr->fileName, ".", 1) == 0) {
d726 2
a727 2
	if (unixDirEntPtr->nameLength == 2 && 
	    strncmp(unixDirEntPtr->fileName, "..", 2) == 0) {
d730 2
a731 2
	strncpy(fileName, unixDirEntPtr->fileName, unixDirEntPtr->nameLength);
	fileName[unixDirEntPtr->nameLength] = 0;
d810 1
a810 1
	    int	fd;
d1001 1
a1001 1
ReturnStatus
d1061 1
a1061 1
void
d1113 1
a1113 1
void
d1120 1
a1120 1
    int tracksPerSet;		/* Total number of tracks in a rotational set */
d1125 1
a1125 1
    int offsetIncrement;	/* The skew of the starting offset on each
d1127 1
a1127 1
    Boolean overlap;		/* TRUE if filesystem blocks overlap tracks */
d1300 1
a1300 1
void
d1440 1
a1440 1
void
d1496 1
a1496 1
ReturnStatus
d1615 1
a1615 1
char *
d1686 1
a1686 1
ReturnStatus
d1734 1
a1734 1
ReturnStatus
d1802 1
a1802 1
ReturnStatus
d1849 1
a1849 1
void
d1930 1
a1930 1
ReturnStatus
d2020 1
a2020 1
ReturnStatus
d2087 1
a2087 1
ReturnStatus
d2162 1
a2162 1
ReturnStatus
d2196 1
a2196 1
ReturnStatus
d2234 1
a2234 1
ReturnStatus
d2275 1
a2275 1
void
d2333 1
a2333 1
void
d2365 1
a2365 1
unsigned char *
d2400 1
a2400 1
unsigned char *
d2432 1
a2432 1
void
@


1.15
log
@started interactive stuff
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /user1/jhh/src/cmds/fsmake/RCS/fsmake.c,v 1.14 89/10/03 13:13:03 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
d14 1
a14 21
#include "sprite.h"
#include "option.h"
#include "diskUtils.h"
#include <stdio.h>
#include <sys/file.h>
#include <stdlib.h>
#include <string.h>
#include <host.h>
#include <sys/time.h>
#include <assert.h>

/*
 * Some number of sectors in the root partition must be allocated to the
 * boot program. The default is for the new filesystem to have the same
 * number of boot sectors as the old filesystem. If the disk did not
 * previously have a filesystem, or if the domain header cannot be found,
 * then the following number of boot sectors are allocated. The standard
 * Sun format is for the summary sector to be in sector #17. 16 boot sectors
 * and one disk label fill the first 17 sectors.
 */
int	defaultBootSectors = 16;
a22 2
Boolean makeFile = FALSE;	/* Make a file in the root directory,
				 * this is used when testing the filesystem */
d34 16
d58 1
d71 2
a76 2
    {OPT_TRUE, "file", (Address)&makeFile,
	"Make a file in the root directory (FALSE)"},
d85 2
a86 2
    {OPT_STRING, "dir", (Address)&devDirectory,
	"Name of device directory (\"/dev/\")"},
d93 19
a115 7
 * Information for setting up the .fscheck.out file.
 */

Boolean makeFscheckOut = FALSE;
char *fscheckOutName = ".fscheck.out";

/*
d119 1
a119 1
struct timeval currentTime;
d121 9
a129 5
#ifdef sprite
Boolean sprite = TRUE;
#else
Boolean sprite = FALSE;
#endif
d131 1
d136 1
a136 1
void SetDomainHeader();
d146 1
a146 1
ReturnStatus WriteFileDescBitmap();
d149 3
d179 1
d186 4
a189 4
    Boolean interactive;
    char	*partitions;
    char	*answer;
    char	buffer[100];
d191 4
a194 203
    gettimeofday(&currentTime, NULL);
    if (argc == 1) {
	interactive = TRUE;
	deviceName = NULL;
	partitions = NULL;
	printf("Please answer the following questions.\n");
	printf("Options are in square brackets []\n");
	printf("Default answers are in parenthesis ()\n");
	printf("\n");
startQuestions:
	(void) Prompt("Name of the device directory", NULL, NULL, FALSE, TRUE,
	    &devDirectory);
	while(! Prompt("Device", NULL, "raw_rsd00", TRUE, TRUE, &deviceName)) {
	    printf("You must specify a device name\n");
	}
	while(1) {
	    Boolean done = FALSE;
	    int choice;
	    answer = buffer;
	    *answer = '1';
labelA:
	    (void) Prompt(
"Do you want to:\n\t1) Put one filesystem on partition c\n\t2) Put a filesystem on both partitions a and g\n\t3) Specify the partitions yourself?", 
		"1,2,3", NULL, FALSE, FALSE, &answer));
	    n = sscanf(answer, "%d", choice);
	    if (n == 0 || choice < 1 || choice > 3) {
		printf("Please answer with 1,2, or 3\n");
		goto labelA;
	    }
	    switch (choice) {
		case 1 : {
		    partitions = malloc(2);
		    strcpy(partitions, "c");
		    numPartitons = 1;
		    done = TRUE;
		    break;
		}
		case 2 : {
		    partitions = malloc(3);
		    strcpy(partitions, "ag");
		    numPartitions = 2;
		    done = TRUE;
		    break;
		}
		case 3 : {
		    while(1) {
			while(! Prompt("Partitions", "a,b,c,d,e,f,g", "ag", 
			    TRUE, TRUE, &partitions)) {
			    printf("You must specify at least one partition\n");
			}
			if (strspn(partitions, "abcdefg") == 
			    strlen(partitions)) {
			    numPartitions = strlen(partitions);
			    done = TRUE;
			    break;
			}
			printf("A partition letter is one of a,b,c,d,e,f,g\n");
			*partitions = '\0';
		    }
		    break;
		}
		default: {
		    printf("You must answer 1,2, or 3\n");
		}
	    }
	    if (done) {
		break;
	    }
	}
#if 0
	for (i = 0; i < numPartitions; i++) {
	    int		fd;
	    char	buffer[100];
	    sprintf(buffer, "%s/%s%c", devDirectory, deviceName, partitions[i]);
	    fd = open(buffer,printOnly ? O_RDONLY : O_RDWR);
	    if (fid < 0) {
		perror("Can't open %s\n", buffer);
		goto startQuestions;
	    }
	    close(fd);
	}
#endif
	answer = buffer;
	*answer = 'n';
	(void) Prompt(
    "Do any of the disk partitions contain filesystems that you wish to keep?",
	    "y/n", NULL, FALSE, FALSE, &answer);
	if (strcmp(answer, "n")) {
	    okToChangeLabel = FALSE;
	}
	answer = buffer;
	*answer = 'y';
	(void) Prompt("Is this a scsi disk?", "y/n", NULL, FALSE, FALSE, 
	    &answer);
	if (!strcmp(answer, "n")) {
	    scsiDisk = FALSE;
	}
	sprintf(buffer, "%s/%sa", devDirectory, deviceName);
	fd = open(buffer, printOnly ? O_RDONLY : O_RDWR);
	diskInfoPtr = Disk_ReadDiskInfo(fd, 'a');
	if (diskInfoPtr == NULL) {
	    answer = buffer;
	    *answer = '1';
	    printf("The disk does not appear to have a label.\n");
	    printf("I'll have to write one on it.\n");
	    printf("Please enter the disk type (one word) as it appears\n");
	    printf("in /etc/disktab.\n");
	    if (sprite && scsiDisk) {
		char *diskType = NULL;

		(void) Prompt(NULL, NULL, "rz55", TRUE, TRUE, &diskType); 
labelB:
		printf("You have a choice.\n");
		printf("I can either create a label from /etc/disktab,\n");
		printf("or I can make one up to maximize disk usage.\n"
		printf("The made up label will contain incorrect values\n");
		printf("for the number of heads, sector/track, etc,\n");
		printf("but it will give you more disk and probably won't\n");
		printf("affect the performance.\n");
		(void) Prompt(
	"Which to you prefer? 1) make up a good label. 2) use /etc/disktab\n",
			    "1,2", NULL, FALSE, FALSE, &answer);
		n = sscanf(answer, "%d", choice);
		if (n == 0 || choice < 1 || choice > 2) {
		    printf("Please answer with 1 or 2\n");
		    goto labelB;
		if (choice == 1) {
		    diskInfoPtr = FindBestLayout(diskType, NULL);
		} else {
		    diskInfoPtr = ScanDiskTab(diskType, NULL);
		}
	    } else {
		diskInfoPtr = ScanDiskTab(diskType, NULL);
	    }
	} else if (sprite && okToChangeLabel) {
	    printf("I may be able to modify the disk label to allow\n");
	    printf("better utilization of the disk.\n");
	    answer = buffer;
	    *answer = 'y';
	    (void) Prompt("Do you want me to do this?", "y/n", NULL, 
		FALSE, FALSE, &answer);
	    if (!strcmp(answer, 'y')) {
		    char *diskType = NULL;
		(void) Prompt(
			"Please enter a one-word name for the disk type",
			NULL, "wrenIV", TRUE, TRUE, &diskType); 
		diskInfoPtr = FindBestLayout(diskType, diskInfoPtr);
	    }
	}
	if (okToChangeLabel) {
	    char	question[100];
	    int		free = 100;
labelC;
	    answer = buffer;
	    sprintf(answer, "%d", free);
	    for (i = 0; i < numPartitions; i++) {
		sprintf(question, 
	"What percentage of the disk should partition %c represent (approx)",
		    partitions[i]);
		while(1) {
		    (void) Prompt(question, NULL, NULL, FALSE, FALSE, &answer);
		    n = sscanf(answer, "%d", amount);
		    if (n != 0 && amount >= 0 && amount <= free) {
			break;
		    }
		    if (amount > free) {
			printf("There is only %d percent free on the disk\n",
			    free);
		    }
		}
		partitionInfo[i].name = partitions[i];
		partitionInfo[i].pct = amount;
		free -= amount;
	    }
	    for (i = 0; i < numPartitions; i++) {
		printf("Partition: %c, pct: %d\n", partitionInfo[i].name,
		    partitionInfo[i].pct);
	    }
	    answer = buffer;
	    strcpy(answer, "y");
	    (void) Prompt("These look ok?", "y/n", NULL, FALSE, FALSE,
		&answer);
	    if (!strcmp(answer, "n")) {
		goto labelC;
	    }
	}






    } else {
	interactive = FALSE;
	(void)Opt_Parse(argc, argv,optionArray, numOptions, 0);
	if (deviceName == (char *)0) {
	    fprintf(stderr,"Specify device name with -dev option\n");
	    status = FAILURE;
	}
	if (partName == (char *)0) {
	    fprintf(stderr,"Specify partition with -part option\n");
	    status = FAILURE;
	}
a195 1

d197 8
d215 37
d255 1
a255 1
	Host_Entry	*entry;
d258 6
a263 1
	    entry = Host_ByID(temp);
d265 18
a282 4
	    entry = Host_ByName(hostIDString);
	}
	if (entry == NULL) {
	    fprintf(stderr, "No such host \"%s\"\n", hostIDString);
a283 2
	} else {
	    hostID = entry->id;
a285 1

d293 23
a315 9
    (void) strcpy(firstPartitionName, devDirectory);	/* eg. /dev/ */
    (void) strcpy(partitionName, devDirectory);
    (void) strcat(firstPartitionName, deviceName);	/* eg. /dev/rxy0 */
    (void) strcat(partitionName, deviceName);
    (void) strcat(firstPartitionName, firstPartName);	/* eg. /dev/rxy0a */
    (void) strcat(partitionName, partName);		/* eg. /dev/rxy0b */


    firstPartFID = open(firstPartitionName, O_RDONLY);
d317 2
a318 1
	perror("Can't open first partition");
d337 39
a375 9
    /*
     * Put a .fscheck.out file in all 'a' and 'c' partitions. We really only
     * need one in the root partition for the fileserver, but it is more 
     * convienient to just put one in all potential root partitions than 
     * it is to add a new option and have the users remember to use it.
     *
     */
    if ((partition == 0) || (partition == 2)) {
	makeFscheckOut = TRUE;
d395 1
d397 21
a417 2
    status = MakeFilesystem(firstPartFID, partFID, partition, spriteID);

d428 23
d464 1
a464 1
MakeFilesystem(firstPartFID, partFID, partition, spriteID)
d470 1
d473 11
a483 23
    Disk_Info 		*diskInfoPtr;
    Fsdm_DomainHeader 	*headerPtr;
    Fsdm_SummaryInfo 	*summaryPtr;
    Fsdm_SummaryInfo 	*oldSummaryPtr;
    char 		answer[10];
    char 		block[DEV_BYTES_PER_SECTOR];
    int			i;

    /*
     * Read the copy of the super block at the beginning of the partition
     * to find out basic disk geometry and where to write the domain header.
     */
    diskInfoPtr = Disk_ReadDiskInfo(firstPartFID, partition);
    if (diskInfoPtr == (Disk_Info *)0) {
	fprintf(stderr,"MakeFilesystem: Unable to read super block.\n");
	return(FAILURE);
    }
    if (diskInfoPtr->summarySector > 0) {

	status = Disk_SectorRead(partFID, diskInfoPtr->summarySector, 1, block);
	if (status != SUCCESS) {
	    perror("Summary sector read failed");
	    return status;
d485 4
a488 1
	oldSummaryPtr = (Fsdm_SummaryInfo *) block;
d490 2
d493 1
a493 1
		oldSummaryPtr->domainPrefix);
d499 1
a499 1
		exit(SUCCESS);
d503 4
a506 7
    bzero(block, DEV_BYTES_PER_SECTOR);
    /*
     * Clear out the old summary sector and domain header. This is especially
     * important if we are going to move them.
     */
    if ((!printOnly) && (diskInfoPtr->summarySector != -1)) {
	status = Disk_SectorWrite(partFID, diskInfoPtr->summarySector,1, block);
d508 1
a508 2
	    perror("Clear of old summary sector failed"); 
	    return(status);
d510 3
a512 7
	for (i = 0; i < diskInfoPtr->numDomainSectors; i++) {
	    status = Disk_SectorWrite(partFID, diskInfoPtr->domainSector+i,
			    1, block);
	    if (status != SUCCESS) {
		perror("Clear of old domain header failed"); 
		return(status);
	    }
d519 15
a533 2
	diskInfoPtr->summarySector = bootSectors + 1;
	diskInfoPtr->domainSector = bootSectors + 2;
a534 11
    /* 
     * The user has not specified the number of boot sectors, and the disk
     * did not previously have a filesystem on it.
     */
    if (diskInfoPtr->summarySector == -1) {
	diskInfoPtr->summarySector = defaultBootSectors + 1;
	diskInfoPtr->domainSector = defaultBootSectors + 2;
    }
    headerPtr = (Fsdm_DomainHeader *)
	malloc((unsigned) diskInfoPtr->numDomainSectors * DEV_BYTES_PER_SECTOR);
    SetDomainHeader(diskInfoPtr, headerPtr, spriteID, partition);
d538 4
a541 6
	if (partition != 0) {
	    status = CopySuperBlock(firstPartFID, partFID);
	    if (status != SUCCESS) {
		perror("CopySuperBlock failed"); 
		return(status);
	    }
d543 1
a543 2
	status = Disk_SectorWrite(partFID, diskInfoPtr->domainSector,
			    diskInfoPtr->numDomainSectors, (Address)headerPtr);
d550 2
a551 12
    SetSummaryInfo(diskInfoPtr, headerPtr, summaryPtr);
    Disk_PrintSummaryInfo(summaryPtr);
    if (!printOnly) {
	status = Disk_SectorWrite(partFID, diskInfoPtr->summarySector, 1,
			    (Address)summaryPtr);
	if (status != SUCCESS) {
	    perror("Summary sector  write failed");
	    return(status);
	}
    }

    status = WriteFileDesc(headerPtr, partFID);
d553 1
a553 1
	perror("WriteFileDesc failed");
d556 1
a556 1
    status = WriteBitmap(headerPtr, partFID);
d561 3
a563 1
    status = WriteRootDirectory(headerPtr, partFID);
d568 1
a568 1
    status = WriteLostFoundDirectory(headerPtr, partFID);
d579 1
a579 1
 * CopySuperBlock --
d581 2
a582 2
 *	Copy the super block from the first sector of the disk to
 *	the first sector of the partition being formatted.
d584 307
a890 15
 * Results:
 *	A return code from the I/O.
 *
 * Side effects:
 *	Writes on the zero'th sector of the partition.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
CopySuperBlock(firstPartFID, partFID)
    int firstPartFID;
    int partFID;
{
    ReturnStatus status;
    char *block;
d892 42
a933 1
    block = (char *)malloc(DEV_BYTES_PER_SECTOR);
a934 7
    status = Disk_SectorRead(firstPartFID, 0, 1, block);
    if (status != SUCCESS) {
	return(status);
    }
    status = Disk_SectorWrite(partFID, 0, 1, block);
    return(status);
}
d952 6
a957 6
void
SetDomainHeader(diskInfoPtr, headerPtr, spriteID, partition)
    Disk_Info *diskInfoPtr;	/* Information from the super block */
    Fsdm_DomainHeader *headerPtr;	/* Reference to domain header to fill in */
    int spriteID;		/* Host ID of machine with the disks */
    int partition;		/* Index of partition to format */
d962 7
a968 2
    headerPtr->firstCylinder = diskInfoPtr->firstCylinder;
    headerPtr->numCylinders = diskInfoPtr->numCylinders;
d985 1
a985 1
	SetSCSIDiskGeometry(diskInfoPtr, geoPtr);
d987 1
a987 1
	SetDiskGeometry(diskInfoPtr, geoPtr);
d990 2
a991 1
    SetDomainParts(diskInfoPtr, headerPtr);
d1013 3
a1015 3
SetSCSIDiskGeometry(diskInfoPtr, geoPtr)
    register Disk_Info *diskInfoPtr;/* Basic geometry information */
    register Fsdm_Geometry *geoPtr;	/* Fancy geometry information */
d1020 2
a1021 2
    geoPtr->numHeads = diskInfoPtr->numHeads;
    geoPtr->sectorsPerTrack = diskInfoPtr->numSectors;
d1065 3
a1067 3
SetDiskGeometry(diskInfoPtr, geoPtr)
    register Disk_Info *diskInfoPtr;/* Basic geometry information */
    register Fsdm_Geometry *geoPtr;	/* Fancy geometry information */
d1080 2
a1081 2
    geoPtr->numHeads = diskInfoPtr->numHeads;
    geoPtr->sectorsPerTrack = diskInfoPtr->numSectors;
d1252 3
a1254 2
SetDomainParts(diskInfoPtr, headerPtr)
    register Disk_Info *diskInfoPtr;
d1266 2
d1274 7
d1286 2
a1287 5
	cylinders = (diskInfoPtr->domainSector + 
		    diskInfoPtr->numDomainSectors) /
		    (geoPtr->sectorsPerTrack * geoPtr->numHeads);
	if (((diskInfoPtr->domainSector + diskInfoPtr->numDomainSectors) %
	    (geoPtr->sectorsPerTrack * geoPtr->numHeads)) != 0) {
d1291 1
a1291 2
	numBlocks = geoPtr->blocksPerCylinder * diskInfoPtr->numCylinders -
		    reservedBlocks;
d1297 3
a1299 5
	sets = (diskInfoPtr->domainSector + 
		 diskInfoPtr->numDomainSectors) /
		 (geoPtr->tracksPerRotSet * geoPtr->sectorsPerTrack);
	if (((diskInfoPtr->domainSector + diskInfoPtr->numDomainSectors) %
	    (geoPtr->tracksPerRotSet * geoPtr->sectorsPerTrack)) != 0) {
d1303 1
a1303 2
	numBlocks = geoPtr->blocksPerCylinder * diskInfoPtr->numCylinders -
		    reservedBlocks;
d1381 1
a1381 2
 *	Initialize the summary information for the domain.  It is well
 *	known that this occupies one sector.
d1392 1
a1392 2
SetSummaryInfo(diskInfoPtr, headerPtr, summaryPtr)
    Disk_Info *diskInfoPtr;	/* Information from the super block */
d1394 1
a1394 1
    Fsdm_SummaryInfo *summaryPtr;	/* Reference to summary info to fill in */
d1397 1
a1397 1
    bzero((Address)summaryPtr, DEV_BYTES_PER_SECTOR);
d1401 2
a1402 2
     * 12 blocks are already allocated, 4 for the root directory,
     * and 8 more for lost+found.
d1405 1
a1405 4
				- 12;
    if (makeFscheckOut) {
	summaryPtr->numFreeKbytes -= 8;
    }
d1407 2
a1408 2
     * 4 file descriptors are already used, 0 and 1 are reserved,
     * 2 is for the root, and 3 is for lost+found.
d1410 1
a1410 7
    summaryPtr->numFreeFileDesc = headerPtr->numFileDesc - 4;
    if (makeFile) {
	summaryPtr->numFreeFileDesc--;
    }
    if (makeFscheckOut) {
	summaryPtr->numFreeFileDesc--;
    }
d1435 1
a1435 1
 * WriteFileDesc --
d1437 1
a1437 1
 *	Write out the file descriptor array to disk.
d1440 1
a1440 1
 *	None.
d1448 2
a1449 1
WriteFileDesc(headerPtr, partFID)
a1450 1
    int partFID;	/* File handle for partition to format */
d1454 1
a1454 1
    char *block;
d1457 1
d1464 1
d1470 2
a1471 3
     * canned file descriptors for the root, bad block file, and the
     * lost and found directory.  For (early system) testing an empty file
     * can also be created.
a1472 1
    block = (char *)malloc(FS_BLOCK_SIZE);
d1483 2
a1484 1
	    SetBadBlockFileDescriptor(fileDescPtr);
d1486 6
a1491 1
	    SetRootFileDescriptor(fileDescPtr);
d1493 13
a1505 5
	    SetLostFoundFileDescriptor(fileDescPtr);
	} else if ((index == FSDM_LOST_FOUND_FILE_NUMBER+1) && makeFile) {
	    SetEmptyFileDescriptor(fileDescPtr);
	} else if ((index == FSDM_LOST_FOUND_FILE_NUMBER+2) && makeFscheckOut) {
	    SetFscheckOutFileDescriptor(fileDescPtr);
a1553 303
 * SetRootFileDescriptor --
 *
 *	Set up the file descriptor for the root directory.
 *
 * Results:
 *	Fill in the file descriptor.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
SetRootFileDescriptor(fileDescPtr)
    register Fsdm_FileDescriptor *fileDescPtr;
{
    Time time;
    int index;

    fileDescPtr->flags = FSDM_FD_ALLOC;
    fileDescPtr->fileType = FS_DIRECTORY;
    fileDescPtr->permissions = 0755;
    fileDescPtr->uid = 0;
    fileDescPtr->gid = 0;
    fileDescPtr->lastByte = FS_BLOCK_SIZE-1;
    fileDescPtr->firstByte = -1;
    fileDescPtr->numLinks = 3;
    /*
     * Can't know device information because that depends on
     * the way the system is configured.
     */
    fileDescPtr->devServerID = -1;
    fileDescPtr->devType = -1;
    fileDescPtr->devUnit = -1;

    /*
     * Set the time stamps.  This assumes that universal time, not local
     * time, is used for time stamps.
     */
    Sys_GetTimeOfDay(&time, NULL, NULL);
    fileDescPtr->createTime = time.seconds;
    fileDescPtr->accessTime = 0;
    fileDescPtr->descModifyTime = time.seconds;
    fileDescPtr->dataModifyTime = time.seconds;

    /*
     * Place the data in the first filesystem block.
     */
    fileDescPtr->direct[0] = 0;
    for (index = 1; index < FSDM_NUM_DIRECT_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FSDM_NIL_INDEX;
    }
    for (index = 0; index < FSDM_NUM_INDIRECT_BLOCKS ; index++) {
	fileDescPtr->indirect[index] = FSDM_NIL_INDEX;
    }
    fileDescPtr->numKbytes = 4;
    fileDescPtr->version = 1;
}

/*
 *----------------------------------------------------------------------
 *
 * SetBadBlockFileDescriptor --
 *
 *	Set up the file descriptor for the bad block file.
 *
 * Results:
 *	Fill in the file descriptor.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
SetBadBlockFileDescriptor(fileDescPtr)
    register Fsdm_FileDescriptor *fileDescPtr;
{
    Time time;
    int index;

    fileDescPtr->flags = FSDM_FD_ALLOC;
    fileDescPtr->fileType = FS_FILE;
    fileDescPtr->permissions = 0000;
    fileDescPtr->uid = 0;
    fileDescPtr->gid = 0;
    fileDescPtr->lastByte = -1;
    fileDescPtr->firstByte = -1;
    fileDescPtr->numLinks = 0;		/* Intentionally unreferenced */
    /*
     * Can't know device information because that depends on
     * the way the system is configured.
     */
    fileDescPtr->devServerID = -1;
    fileDescPtr->devType = -1;
    fileDescPtr->devUnit = -1;

    /*
     * Set the time stamps.  This assumes that universal time, not local
     * time, is used for time stamps.
     */
    Sys_GetTimeOfDay(&time, NULL, NULL);
    fileDescPtr->createTime = time.seconds;
    fileDescPtr->accessTime = 0;
    fileDescPtr->descModifyTime = time.seconds;
    fileDescPtr->dataModifyTime = time.seconds;

    /*
     * Place the data in the first filesystem block.
     */
    for (index = 0; index < FSDM_NUM_DIRECT_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FSDM_NIL_INDEX;
    }
    for (index = 0; index < FSDM_NUM_INDIRECT_BLOCKS ; index++) {
	fileDescPtr->indirect[index] = FSDM_NIL_INDEX;
    }
    fileDescPtr->numKbytes = 0;
    fileDescPtr->version = 1;
}

/*
 *----------------------------------------------------------------------
 *
 * SetLostFoundFileDescriptor --
 *
 *	Set up the file descriptor for the lost and found directory.
 *
 * Results:
 *	Fill in the file descriptor.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
SetLostFoundFileDescriptor(fileDescPtr)
    register Fsdm_FileDescriptor *fileDescPtr;
{
    Time time;
    int index;

    fileDescPtr->flags = FSDM_FD_ALLOC;
    fileDescPtr->fileType = FS_DIRECTORY;
    fileDescPtr->permissions = 0755;
    fileDescPtr->uid = 0;
    fileDescPtr->gid = 0;
    fileDescPtr->lastByte = FSDM_NUM_LOST_FOUND_BLOCKS * FS_BLOCK_SIZE - 1;
    fileDescPtr->firstByte = -1;
    fileDescPtr->numLinks = 2;
    /*
     * Can't know device information because that depends on
     * the way the system is configured.
     */
    fileDescPtr->devServerID = -1;
    fileDescPtr->devType = -1;
    fileDescPtr->devUnit = -1;

    /*
     * Set the time stamps.  This assumes that universal time, not local
     * time, is used for time stamps.
     */
    Sys_GetTimeOfDay(&time, NULL, NULL);
    fileDescPtr->createTime = time.seconds;
    fileDescPtr->accessTime = 0;
    fileDescPtr->descModifyTime = time.seconds;
    fileDescPtr->dataModifyTime = time.seconds;

    for (index = 0; index < FSDM_NUM_LOST_FOUND_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FS_FRAGMENTS_PER_BLOCK * (index + 1);
    }
    for (; index < FSDM_NUM_DIRECT_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FSDM_NIL_INDEX;
    }
    for (index = 0; index < FSDM_NUM_INDIRECT_BLOCKS ; index++) {
	fileDescPtr->indirect[index] = FSDM_NIL_INDEX;
    }
    fileDescPtr->numKbytes = 8;
    fileDescPtr->version = 1;
}

/*
 *----------------------------------------------------------------------
 *
 * SetEmptyFileDescriptor --
 *
 *	Set up a file descriptor for an empty file.
 *
 * Results:
 *	Fill in the file descriptor.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
SetEmptyFileDescriptor(fileDescPtr)
    register Fsdm_FileDescriptor *fileDescPtr;
{
    Time time;
    int index;

    fileDescPtr->flags = FSDM_FD_ALLOC;
    fileDescPtr->fileType = FS_FILE;
    fileDescPtr->permissions = 0666;
    fileDescPtr->uid = 0;
    fileDescPtr->gid = 0;
    fileDescPtr->lastByte = -1;
    fileDescPtr->firstByte = -1;
    fileDescPtr->numLinks = 1;
    /*
     * Can't know device information because that depends on
     * the way the system is configured.
     */
    fileDescPtr->devServerID = -1;
    fileDescPtr->devType = -1;
    fileDescPtr->devUnit = -1;

    /*
     * Set the time stamps.  This assumes that universal time, not local
     * time, is used for time stamps.
     */
    Sys_GetTimeOfDay(&time, NULL, NULL);
    fileDescPtr->createTime = time.seconds;
    fileDescPtr->accessTime = 0;
    fileDescPtr->descModifyTime = time.seconds;
    fileDescPtr->dataModifyTime = time.seconds;

    for (index = 0; index < FSDM_NUM_DIRECT_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FSDM_NIL_INDEX;
    }
    for (index = 0; index < FSDM_NUM_INDIRECT_BLOCKS ; index++) {
	fileDescPtr->indirect[index] = FSDM_NIL_INDEX;
    }
    fileDescPtr->numKbytes = 0;
    fileDescPtr->version = 1;
}

/*
 *----------------------------------------------------------------------
 *
 * SetFscheckOutFileDescriptor --
 *
 *	Set up the file descriptor for the .fscheck.out file.
 *
 * Results:
 *	Fill in the file descriptor.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
SetFscheckOutFileDescriptor(fileDescPtr)
    register Fsdm_FileDescriptor *fileDescPtr;
{
    Time time;
    int index;

    fileDescPtr->flags = FSDM_FD_ALLOC;
    fileDescPtr->fileType = FS_FILE;
    fileDescPtr->permissions = 0755;
    fileDescPtr->uid = 0;
    fileDescPtr->gid = 0;
    fileDescPtr->lastByte = 2 * FS_BLOCK_SIZE - 1;
    fileDescPtr->firstByte = -1;
    fileDescPtr->numLinks = 1;
    /*
     * Can't know device information because that depends on
     * the way the system is configured.
     */
    fileDescPtr->devServerID = -1;
    fileDescPtr->devType = -1;
    fileDescPtr->devUnit = -1;

    /*
     * Set the time stamps.  This assumes that universal time, not local
     * time, is used for time stamps.
     */
    Sys_GetTimeOfDay(&time, NULL, NULL);
    fileDescPtr->createTime = time.seconds;
    fileDescPtr->accessTime = 0;
    fileDescPtr->descModifyTime = time.seconds;
    fileDescPtr->dataModifyTime = time.seconds;

    for (index = 0; index < 2 ; index++) {
	fileDescPtr->direct[index] = FS_FRAGMENTS_PER_BLOCK * (index + 3);
    }
    for (; index < FSDM_NUM_DIRECT_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FSDM_NIL_INDEX;
    }
    for (index = 0; index < FSDM_NUM_INDIRECT_BLOCKS ; index++) {
	fileDescPtr->indirect[index] = FSDM_NIL_INDEX;
    }
    fileDescPtr->numKbytes = 8;
    fileDescPtr->version = 1;
}

/*
 *----------------------------------------------------------------------
 *
d1581 1
a1581 1
     * Reserve file descriptors 0, 1, 2, and 3.  File number 0 is not used at 
d1583 1
a1583 1
     * File number 2 (FSDM_ROOT_FILE_NUMBER) is the root directory of the domain.
d1586 1
d1590 2
a1591 14
    bitmap[0] |= 0xf0;

    /*
     * Reserve file descriptor # 4 for an empty file.
     */
    if (makeFile) {
	bitmap[0] |= 0x08;
    }
    /*
     * Reserve file descriptor #5 for .fscheck.out.
     */
    if (makeFscheckOut) {
	bitmap[0] |= 0x04;
    }
d1626 2
a1627 2
 *	first 1K fragment is allocated to the root directory and 8K is
 *	allocated to lost and found.
d1638 2
a1639 1
WriteBitmap(headerPtr, partFID)
a1640 1
    int partFID;
d1648 3
a1650 2
     * Set the bit corresponding to the 4K used for the root directory
     * and the next 8K reserved for lost and found.
d1657 3
a1659 5
    bitmap[1] |= 0xf0;
    if (makeFscheckOut) {
	bitmap[1] |= 0x0f;
	bitmap[2] |= 0xf0;
    }
d1686 4
a1689 3
WriteRootDirectory(headerPtr, partFID)
    register Fsdm_DomainHeader *headerPtr;
    int partFID;
d1691 5
a1695 80
    ReturnStatus status;
    char *block;
    Fslcl_DirEntry *dirEntryPtr;
    char *fileName;
    int length;
    int offset;
    int i;

    block = (char *)malloc(FS_BLOCK_SIZE);
    dirEntryPtr = (Fslcl_DirEntry *)block;

    fileName = ".";
    length = strlen(fileName);
    dirEntryPtr->fileNumber = FSDM_ROOT_FILE_NUMBER;
    dirEntryPtr->recordLength = Fslcl_DirRecLength(length);
    dirEntryPtr->nameLength = length;
    strcpy(dirEntryPtr->fileName, fileName);
    offset = dirEntryPtr->recordLength;

    dirEntryPtr = (Fslcl_DirEntry *)((int)block + offset);
    fileName = "..";
    length = strlen(fileName);
    dirEntryPtr->fileNumber = FSDM_ROOT_FILE_NUMBER;
    dirEntryPtr->recordLength = Fslcl_DirRecLength(length);
    dirEntryPtr->nameLength = length;
    strcpy(dirEntryPtr->fileName, fileName);
    offset += dirEntryPtr->recordLength;

    /*
     * Add lost and found.
     */

    dirEntryPtr = (Fslcl_DirEntry *) ((int)block + offset);
    fileName = "lost+found";
    length = strlen(fileName);
    dirEntryPtr->fileNumber = FSDM_LOST_FOUND_FILE_NUMBER;
    dirEntryPtr->nameLength = length;
    strcpy(dirEntryPtr->fileName, fileName);

    /*
     * Add empty file.
     */
    if (makeFile) {
	dirEntryPtr->recordLength = Fslcl_DirRecLength(length);
	offset += dirEntryPtr->recordLength;
	dirEntryPtr = (Fslcl_DirEntry *)((int)block + offset);
	fileName = "testFile";
	length = strlen(fileName);
	dirEntryPtr->fileNumber = FSDM_LOST_FOUND_FILE_NUMBER + 1;
	dirEntryPtr->nameLength = length;
	strcpy(dirEntryPtr->fileName, fileName);
    }
    /*
     * Add .fscheck.out
     */
    if (!makeFscheckOut) {
	dirEntryPtr->recordLength = FSLCL_DIR_BLOCK_SIZE - offset;
    } else {
	dirEntryPtr->recordLength = Fslcl_DirRecLength(length);
	offset += dirEntryPtr->recordLength;
	dirEntryPtr = (Fslcl_DirEntry *)((int)block + offset);
	fileName = fscheckOutName;
	length = strlen(fileName);
	dirEntryPtr->fileNumber = FSDM_LOST_FOUND_FILE_NUMBER + 2;
	dirEntryPtr->nameLength = length;
	strcpy(dirEntryPtr->fileName, fileName);
	dirEntryPtr->recordLength = FSLCL_DIR_BLOCK_SIZE - offset;
    }

    /*
     * Fill out the rest of the directory with empty blocks.
     */

    for (dirEntryPtr = (Fslcl_DirEntry *)&block[FSLCL_DIR_BLOCK_SIZE], i = 1; 
	 i < FS_BLOCK_SIZE / FSLCL_DIR_BLOCK_SIZE;
	 i++,dirEntryPtr=(Fslcl_DirEntry *)((int)dirEntryPtr + FSLCL_DIR_BLOCK_SIZE)) {
	 dirEntryPtr->fileNumber = 0;
	 dirEntryPtr->recordLength = FSLCL_DIR_BLOCK_SIZE;
	 dirEntryPtr->nameLength = 0;
    }
d1697 1
d1699 1
d1702 1
a1702 10
	dirEntryPtr = (Fslcl_DirEntry *)block;
	Disk_PrintDirEntry(dirEntryPtr);
	offset += dirEntryPtr->recordLength;
	dirEntryPtr = (Fslcl_DirEntry *)((int)block + offset);
	Disk_PrintDirEntry(dirEntryPtr);
	offset += dirEntryPtr->recordLength;
	dirEntryPtr = (Fslcl_DirEntry *)((int)block + offset);
	Disk_PrintDirEntry(dirEntryPtr);
	if (makeFile) {
	    offset += dirEntryPtr->recordLength;
a1704 2
	}
	if (makeFscheckOut) {
a1705 2
	    dirEntryPtr = (Fslcl_DirEntry *)((int)block + offset);
	    Disk_PrintDirEntry(dirEntryPtr);
a1706 1
	status = SUCCESS;
d1708 25
a1732 7
	/*
	 * This write trounces the data beyond the stuff allocated to
	 * the root directory.  Currently this is ok and is done because
	 * BlockWrite writes whole numbers of filesystem blocks.
	 */
	status = Disk_BlockWrite(partFID, headerPtr, headerPtr->dataOffset, 1,
				       block);
d1734 1
d1754 2
a1755 1
WriteLostFoundDirectory(headerPtr, partFID)
d1757 56
a1812 1
    int partFID;
d1814 354
a2167 7
    ReturnStatus status;
    char *block;
    Fslcl_DirEntry *dirEntryPtr;
    char *fileName;
    int length;
    int offset;
    int	i;
d2169 69
a2237 2
    block = (char *)malloc(FSDM_NUM_LOST_FOUND_BLOCKS * FS_BLOCK_SIZE);
    dirEntryPtr = (Fslcl_DirEntry *)block;
d2239 1
d2242 1
a2242 1
    dirEntryPtr->fileNumber = FSDM_LOST_FOUND_FILE_NUMBER;
d2248 1
a2248 1
    dirEntryPtr = (Fslcl_DirEntry *)((int)block + offset);
d2251 1
a2251 1
    dirEntryPtr->fileNumber = FSDM_ROOT_FILE_NUMBER;
a2254 1

d2258 2
a2259 3

    for (dirEntryPtr = (Fslcl_DirEntry *)&block[FSLCL_DIR_BLOCK_SIZE], i = 1; 
	 i < FSDM_NUM_LOST_FOUND_BLOCKS * FS_BLOCK_SIZE / FSLCL_DIR_BLOCK_SIZE;
d2265 31
a2295 9
    if (printOnly) {
	printf("Lost+found Directory\n");
	offset = 0;
	dirEntryPtr = (Fslcl_DirEntry *)block;
	Disk_PrintDirEntry(dirEntryPtr);
	offset += dirEntryPtr->recordLength;
	dirEntryPtr = (Fslcl_DirEntry *)((int)block + offset);
	Disk_PrintDirEntry(dirEntryPtr);
	status = SUCCESS;
d2297 1
a2297 2
	status = Disk_BlockWrite(partFID, headerPtr, headerPtr->dataOffset + 1,
			    FSDM_NUM_LOST_FOUND_BLOCKS, block);
a2298 1
    return(status);
d2300 22
d2323 44
d2371 1
a2371 1
 * Prompt --
d2373 1
a2373 1
 *	Used to prompt the user for an answer. 
d2376 18
a2393 53
 *	1 if the user actually entered something, 0 if he just pressed
 *	return.  If 0 is returned then answerPtr is untouched.
 *
 * Side effects:
 *	Stuff is written to stdout and read from stdin.
 *	Memory is allocated.
 *
 *----------------------------------------------------------------------
 */

int
Prompt(prompt, options, example, canFree, canAllocate, answerPtr)
    char 	*prompt;	/* Stuff to print first.*/
    char	*options;	/* Printed inside []'s. */
    char	*example;	/* Example answer. */
    Boolean	canFree;	/* Can I free the memory associated with the
				 * answerPtr? */
    Boolean	canAllocate;	/* Can I allocate memory to be pointed to by
				 * answerPtr? */
    char	**answerPtr;	/* Ptr to place to store answer. */
{
    int		n;
    static char	buffer[100];
    static char	buffer2[100];

    assert(!((canFree == TRUE) && (canAllocate == FALSE)));
    printf("%s", prompt);
    if (example != NULL && *example != '\0') {
	printf(", ex. \"%s\"", example);
    }
    if (options != NULL && *options != '\0') {
	printf(", [%s]", options);
    }
    if (*answerPtr != NULL && **answerPtr != '\0') {
	printf(" (%s)", *answerPtr);
    }
    printf(" : ");
    if (fgets(buffer, 100, stdin) == NULL) {
	exit(0);
    }
    n = sscanf(buffer, "%s", buffer2);
    if (n < 1) {
	return 0;
    }
    if (canFree) {
	free(*answerPtr);
    }
    if (canAllocate) {
	*answerPtr = malloc(strlen(buffer)+1);
    }  
    assert(*answerPtr != NULL);
    strcpy(*answerPtr, buffer2);
    return 1;
@


1.14
log
@new scsi disk mapping, converted to new fs structure
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/admin/fsmake/RCS/fsmake.c,v 1.13 89/08/29 17:12:52 jhh Exp $ SPRITE (Berkeley)";
d22 2
d66 1
a66 1
char defaultDevDirectory[] = "/dev/";
d107 13
d170 4
d175 204
a378 1
    (void)Opt_Parse(argc, argv,optionArray, numOptions, 0);
a380 8
    if (deviceName == (char *)0) {
	fprintf(stderr,"Specify device name with -dev option\n");
	status = FAILURE;
    }
    if (partName == (char *)0) {
	fprintf(stderr,"Specify partition with -part option\n");
	status = FAILURE;
    }
d1913 65
@


1.14.1.1
log
@New and improved. Includes functionality from fsinstall
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /user1/jhh/src/cmds/fsmake/RCS/fsmake.c,v 1.14 89/10/03 13:13:03 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
d14 19
a32 1
#include "fsmake.h"
d41 2
a53 16
Boolean repartition = FALSE;	/* If TRUE then the partition map is changed. */
Boolean reconfig = FALSE;	/* If TRUE then the disk configuration
				 * is changed. */
Boolean partdisktab = FALSE;	/* If TRUE then read the partition map from
				 * the disktab file. */
Boolean configdisktab = FALSE;	/* If TRUE then read the config information
				 * from the disktab file, otherwise get the
				 * disk size information directly from the
				 * disk and compute the "best" configuration..*/
char *disktabName = "/etc/disktab"; /* Name of disktab file. */
char *sizeString = NULL;	/* Size of partitions. */
char *diskType = NULL;		/* Type of disk (e.g.rz55). */
char *labelTypeName = NULL;	/* Type of label (e.g. sun). */
char *dirName = NULL;		/* Name of directory that contains files to
				 * copy to the disk. */

a61 1
char *rawDeviceName;		/* Set to "raw_rsd00", etc */
d64 1
a64 1
char defaultDevDirectory[] = "/dev";
a73 2
    {OPT_STRING, "rawdev", (Address)&rawDeviceName,
	"Required: Name of raw device, eg \"raw_rsd00\""},
d78 2
d88 2
a89 2
    {OPT_STRING, "devDir", (Address)&devDirectory,
	"Name of device directory (\"/dev\")"},
a95 19
    {OPT_TRUE, "repartition", (Address)&repartition,
	"Change the partitioning of the disk.  USE ONLY ON EMPTY DISKS"},
    {OPT_TRUE, "reconfig", (Address) &reconfig,
	"Change the disk configuration info in label. USE ONLY ON EMPTY DISKS"},
    {OPT_TRUE, "configdisktab", (Address)&configdisktab,
	"Reconfigure according to info in disktab file"},
    {OPT_TRUE, "partdisktab", (Address)&partdisktab,
	"Repartition according to info in disktab file"},
    {OPT_STRING, "disktabName", (Address)&disktabName,
	"Name of the disktab file"},
    {OPT_STRING, "sizes", (Address)&sizeString,
	"Size of partitions (as a percentage), eg \"a:25,g:75\""},
    {OPT_STRING, "disktype", (Address)&diskType,
	"Type of disk. Used to look up information in disktab file"},
    {OPT_STRING, "labeltype", (Address)&labelTypeName,
	"Type of native disk label (sun or dec)"},
    {OPT_STRING, "dir", (Address)&dirName,
	"Directory to copy files from"},

d100 1
a100 1
 * Time of day when this program runs.
d103 2
a104 13
struct timeval curTime;

int			freeFDNum;	/* The currently free file descriptor.*/
int			freeBlockNum;	/* The currently free data block. */
unsigned char		*fdBitmapPtr;	/* Pointer to the file descriptor
					 * bitmap. */
unsigned char		*cylBitmapPtr;	/* Pointer to the cylinder bit map. */
int			bytesPerCylinder;/* The number of bytes in
					  * the bitmap for a cylinder.*/
Fsdm_DomainHeader 	*headerPtr;	/* The domain header. */
Fsdm_SummaryInfo 	*summaryPtr;	/* The summary info. */

char *myName;
d109 1
a109 1
ReturnStatus SetDomainHeader();
d119 1
a119 1
void WriteFileDescBitmap();
a121 1
void Usage();
a122 2
extern char *getwd();

a148 1
    int rawFID = -1;
d155 2
a156 4
    Disk_NativeLabelType	labelType;	
    Disk_Label			*labelPtr = NULL;
    int	sizes[8];
    int i;
a157 5
    myName = argv[0];
    argc = Opt_Parse(argc, argv,optionArray, numOptions, 0);
    if (argc > 1) {
	Usage();
    }
a176 37
    for (i = 0; i < 8; i++) {
	sizes[i] = 0;
    }
    if (sizeString != NULL) {
	char *cPtr;
	int part;
	int size;
	int n;
	cPtr = sizeString;
	while (*cPtr != '\0') {
	    part = (int) (*cPtr - 'a');
	    if (part < 0 || part > 7) {
		fprintf(stderr, 
	    "Argument to -sizes parameter must start with partition.\n");
		Usage();
	    }
	    cPtr++;
	    if (*cPtr != ':') {
		fprintf(stderr, 
	    "Argument to -sizes parameter is missing a ':'.\n");
		Usage();
	    }
	    cPtr++;
	    n = sscanf(cPtr,"%d",&size);
	    if (n != 1) {
		fprintf(stderr, 
    "Argument to -sizes parameter must have an integer following the ':'\n");
		Usage();
	    }
	    sizes[part] = size;
	    cPtr = strchr(cPtr, ',');
	    if (cPtr == NULL) {
		break;
	    }
	    cPtr++;
	}
    }
d180 1
a180 1
	Host_Entry	*entryPtr;
d183 1
a183 6
	    entryPtr = Host_ByID(temp);
	    if (entryPtr == NULL) {
		fprintf(stderr, 
		    "WARNING: Host %d is not in /etc/spritehosts.\n", temp);
	    }
	    hostID = temp;
d185 5
a189 15
	    entryPtr = Host_ByName(hostIDString);
	    if (entryPtr == NULL) {
		fprintf(stderr, 
		    "Host %s is not in /etc/spritehosts.\n", temp);
		status = FAILURE;
	    }
	    hostID = entryPtr->id;
	}
    }
    labelType = DISK_NO_LABEL;
    if (labelTypeName != NULL) {
	if (!strcasecmp(labelTypeName, "sun")) {
	    labelType = DISK_SUN_LABEL;
	} else if (!strcasecmp(labelTypeName, "dec")) {
	    labelType = DISK_DEC_LABEL;
d191 1
a191 3
	    fprintf(stderr, 
		"Argument to -labeltype must be \"sun\" or \"dec\"\n");
	    status = FAILURE;
d194 1
d202 9
a210 23
    sprintf(firstPartitionName, "%s/%s%c", devDirectory, deviceName,
	*firstPartName);
    sprintf(partitionName, "%s/%s%c", devDirectory, deviceName,
	*partName);
    if (rawDeviceName != NULL) {
	char buffer[64];
	sprintf(buffer, "%s/%s", devDirectory, rawDeviceName);
	if (!printOnly) {
	    rawFID = open(buffer, O_RDWR);
	} else {
	    rawFID = open(buffer, O_RDONLY);
	}
	if (rawFID < 0) {
	    fprintf(stderr, "Can't open raw device %s: ", buffer);
	    perror((char *) NULL);
	    exit(FAILURE);
	}
    }
    if (!printOnly) {
	firstPartFID = open(firstPartitionName, O_RDWR);
    } else {
	firstPartFID = open(firstPartitionName, O_RDONLY);
    }
d212 1
a212 2
	fprintf(stderr, "Can't open first partition %s: ", firstPartitionName);
	perror((char *) NULL);
d231 9
a239 39
    if (reconfig) {
	if (rawFID < 0) {
	    fprintf(stderr, 
	"You must specify a raw device with the -reconfig flag\n");
	    exit(FAILURE);
	}
	status = Reconfig(rawFID, configdisktab, disktabName, diskType,
	    labelType, scsiDisk, &labelPtr);
	if (status != SUCCESS) {
	    fprintf(stderr, "Reconfiguration of disk failed.\n");
	    exit(1);
	}
    }
    if (repartition || reconfig) {
	if (rawFID < 0) {
	    fprintf(stderr, 
	"You must specify a raw device with the -repartition flag\n");
	    exit(FAILURE);
	}
	status = Repartition(rawFID, partdisktab, disktabName, diskType,
	    labelType, partition,
	    sizes, &labelPtr);
	if (status != SUCCESS) {
	    fprintf(stderr, "Repartition of disk failed.\n");
	    exit(1);
	}
	printf("New disk label:\n");
	Disk_PrintLabel(labelPtr);
	status = ConfirmDiskSize(rawFID, labelPtr, sizes);
	if (status != SUCCESS) {
	    exit(status);
	}
	if (!printOnly) {
	    status = Disk_WriteLabel(rawFID, labelPtr);
	    if (status != SUCCESS) {
		fprintf(stderr, "Can't write label to raw device\n");
		exit(status);
	    }
	}
a258 1
    gettimeofday(&curTime, (struct timezone *) NULL);
d260 2
a261 21
    status = MakeFilesystem(firstPartFID, partFID, partition, spriteID, 
	&labelPtr);
    if ((status == SUCCESS) && (dirName != NULL)) {
	Fsdm_FileDescriptor	rootDesc;
	printf("Copying %s to new filesystem.\n", dirName);
	fdBitmapPtr = ReadFileDescBitmap(partFID, headerPtr);
	cylBitmapPtr = ReadBitmap(partFID, headerPtr);
	ReadFileDesc(partFID, headerPtr, FSDM_ROOT_FILE_NUMBER, &rootDesc);
	CopyTree(partFID, dirName, FSDM_ROOT_FILE_NUMBER, &rootDesc,
	    FSDM_ROOT_FILE_NUMBER, FALSE, "/");
	WriteFileDesc(partFID, headerPtr, FSDM_ROOT_FILE_NUMBER, &rootDesc);
	if (!printOnly) {
	    status = Disk_WriteSummaryInfo(partFID, labelPtr, summaryPtr);
	    if (status != 0) {
		perror("Summary sector write failed (2)");
		exit(status);
	    }
	    WriteFileDescBitmap(partFID, headerPtr, fdBitmapPtr);
	    WriteBitmap(partFID, headerPtr);
	}
    }
a271 23
 * Usage --
 *
 *	Prints out the correct command syntax and exits..
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The program exits.
 *
 *----------------------------------------------------------------------
 */

void
Usage()
{
    Opt_PrintUsage(myName, optionArray, Opt_Number(optionArray));
    exit(1);
}

/*
 *----------------------------------------------------------------------
 *
d285 1
a285 1
MakeFilesystem(firstPartFID, partFID, partition, spriteID, labelPtrPtr)
a290 1
    Disk_Label	**labelPtrPtr; /* Ptr to ptr to disk label. */
d293 23
a315 11
    Fsdm_DomainHeader	oldDomainHeader;
    Fsdm_SummaryInfo	oldSummaryInfo;
    Fsdm_FileDescriptor rootFD;
    Fsdm_FileDescriptor *rootFDPtr = &rootFD;
    Disk_Label	*labelPtr = *labelPtrPtr;

    if (labelPtr == NULL) {
	labelPtr = Disk_ReadLabel(firstPartFID);
	if (labelPtr == NULL) {
	    fprintf(stderr, "Unable to read disk label.\n");
	    return FAILURE;
d317 1
a317 4
    }
    *labelPtrPtr = labelPtr;
    summaryPtr = Disk_ReadSummaryInfo(partFID, labelPtr);
    if (summaryPtr != NULL) {
a318 2
	    char answer[10];

d320 1
a320 1
		summaryPtr->domainPrefix);
d326 1
a326 1
		return SUCCESS;
d330 7
a336 4
    bzero((char *) &oldDomainHeader, sizeof(oldDomainHeader));
    bzero((char *) &oldSummaryInfo, sizeof(oldSummaryInfo));
    if (!printOnly) {
	status = Disk_WriteDomainHeader(partFID, labelPtr, &oldDomainHeader);
d338 2
a339 1
	    printf("Clear of old domain header failed\n");
d341 7
a347 3
	status = Disk_WriteSummaryInfo(partFID, labelPtr, &oldSummaryInfo);
	if (status != SUCCESS) {
	    printf("Clear of old summary info failed\n");
d354 10
a363 15
	labelPtr->summarySector = bootSectors + 1;
	labelPtr->domainSector = bootSectors + 2;
	labelPtr->numBootSectors = bootSectors;
    } else {
	Disk_Label *newLabelPtr;
	newLabelPtr = Disk_NewLabel(labelPtr->labelType);
	labelPtr->summarySector = newLabelPtr->summarySector;
	labelPtr->domainSector = newLabelPtr->domainSector;
	labelPtr->numBootSectors = newLabelPtr->numBootSectors;
	free((char *) newLabelPtr);
    }
    headerPtr = (Fsdm_DomainHeader *) malloc(sizeof(Fsdm_DomainHeader));
    status = SetDomainHeader(labelPtr, headerPtr, spriteID, partition);
    if (status != SUCCESS) {
	return FAILURE;
d365 3
d371 9
a379 1
	status = Disk_WriteLabel(partFID, labelPtr);
d381 1
a381 1
	    perror("Disk label write failed"); 
d384 7
a390 1
	status = Disk_WriteDomainHeader(partFID, labelPtr, headerPtr);
d392 1
a392 1
	    perror("DomainHeader write failed");
d396 2
a397 3
    summaryPtr = (Fsdm_SummaryInfo *) malloc(DEV_BYTES_PER_SECTOR);
    SetSummaryInfo(headerPtr, summaryPtr);
    status = WriteAllFileDescs(partFID, headerPtr);
d399 1
a399 1
	perror("WriteAllFileDescs failed");
d402 1
a402 1
    status = WriteBitmap(partFID, headerPtr);
d407 1
a407 3
    ReadFileDesc(partFID, headerPtr, FSDM_ROOT_FILE_NUMBER, rootFDPtr);
    status = WriteRootDirectory(partFID, headerPtr, rootFDPtr);
    WriteFileDesc(partFID, headerPtr, FSDM_ROOT_FILE_NUMBER, rootFDPtr);
d412 1
a412 1
    status = WriteLostFoundDirectory(partFID, headerPtr);
d423 1
a423 1
 * CopyTree --
d425 8
a432 2
 *	Copy the tree of files in the given directory
 *	the disk table.
d434 9
a442 46
 * Results:
 *	A pointer to a disk info struct.
 *
 * Side effects:
 *	Disk info struct malloc'd and initialized.  The disk header will be
 *	written if is successfully set up.
 *
 *----------------------------------------------------------------------
 */
void
CopyTree(partFID, dirName, dirFDNum, dirFDPtr, parentFDNum, createDir, path)
    int			partFID;	/* Handle on raw disk. */
    char		*dirName;	/* Name of directory to copy. */
    int			dirFDNum;	/* File number of directory. */
    Fsdm_FileDescriptor	*dirFDPtr;	/* File descriptor of directory. */
    int			parentFDNum;	/* File number of parent. */
    Boolean		createDir;	/* Should create the directory. */
    char		*path;
{
    DIR			*unixDirPtr;
    Fslcl_DirEntry	*unixDirEntPtr;
    DirIndexInfo	indexInfo;
    Fslcl_DirEntry	*spriteDirEntPtr;
    char		fileName[FS_MAX_NAME_LENGTH + 1];
    int			newFDNum;
    Fsdm_FileDescriptor	newFD;
    Fsdm_FileDescriptor	*newFDPtr;
    struct	stat	statBuf;
    int			followLinks;
    char		pathName[1024];
    char		fileBlock[FS_BLOCK_SIZE];
    char		indirectBlock[FS_BLOCK_SIZE];
    int			*indIndexPtr = (int *)indirectBlock;
    char		*suffix;
    Boolean		makeDevice;
    int			devType;
    int			devUnit;
    int			devServer;
    ReturnStatus	status;
    

    /*
     * Get our absolute path name so we can get back if we follow a
     * symbolic link.
     */
    (void) getwd(pathName);
d444 1
a444 81
    if (chdir(dirName) < 0) {
	perror(dirName);
	exit(1);
    }

    /*
     * Get a pointer to the UNIX directory.
     */
    unixDirPtr = opendir(".");
    if (unixDirPtr == NULL) {
	fprintf(stderr, "Can't open directory %s\n", dirName);
	exit(1);
    }
    /*
     * Open the Sprite directory.
     */
    status = OpenDir(partFID, headerPtr, dirFDPtr, &indexInfo,&spriteDirEntPtr);
    if (status != SUCCESS) {
	if (chdir(pathName) < 0) {
	    perror(pathName);
	    exit(1);
	}
    }
    /*
     * See if there is a "follow.links" file in this directory.  If so
     * we are supposed to follow symbolic links rather than just copying
     * the links.
     */
    if (stat("follow.links", &statBuf) < 0) {
	followLinks = 0;
    } else {
	printf("Following links ...\n");
	followLinks = 1;
    }
    if (createDir) {
	CreateDir(indexInfo.dirBlock, 1, dirFDNum, parentFDNum);
    }

    for (unixDirEntPtr = (Fslcl_DirEntry *)readdir(unixDirPtr);
	   unixDirEntPtr != NULL;
	   unixDirEntPtr = (Fslcl_DirEntry *)readdir(unixDirPtr)) {

	if (unixDirEntPtr->nameLength == 1 && 
	    strncmp(unixDirEntPtr->fileName, ".", 1) == 0) {
	    continue;
	}
	if (unixDirEntPtr->nameLength == 2 && 
	    strncmp(unixDirEntPtr->fileName, "..", 2) == 0) {
	    continue;
	}
	strncpy(fileName, unixDirEntPtr->fileName, unixDirEntPtr->nameLength);
	fileName[unixDirEntPtr->nameLength] = 0;
	if (followLinks) {
	    if (stat(fileName, &statBuf) < 0) {
		perror(fileName);
		exit(1);
	    }
	} else {
	    if (lstat(fileName, &statBuf) < 0) {
		perror(fileName);
		exit(1);
	    }
	}
	makeDevice = FALSE;
	suffix = strstr(fileName, DEVICE_SUFFIX);
	if ((suffix != NULL) && (!strcmp(suffix, DEVICE_SUFFIX)) &&
	    ((statBuf.st_mode & S_GFMT) == S_GFREG)) {
	    FILE	*fp;
	    char	buffer[128];
	    int		ok = 0;

	    fp = fopen(fileName, "r");
	    if (fp == NULL) {
		fprintf(stderr, "WARNING: Can't open %s%s: ", pathName,
		    fileName);
		perror((char *) NULL);
		continue;
	    }
	    while (fgets(buffer, 128, fp) != NULL) {
		char	tmp[128];
		int	n;
d446 7
a452 222
		n = sscanf(buffer, " %128s", tmp);
		if (n < 1 || *tmp == '#') {
		    continue;
		}
		if (sscanf(buffer, " %d %d %d", &devServer, &devType, &devUnit)
		    != 3) {
		    fprintf(stderr, 
		    "WARNING: Device file %s%s has bad format. Skipping.\n",
			pathName, fileName);
		    break;
		}
		ok = 1;
		break;
	    }
	    fclose(fp);
	    if (!ok) {
		continue;
	    }
	    makeDevice = TRUE;
	    *suffix = '\0';
	}
	newFDNum = freeFDNum;
	freeFDNum++;
	MarkFDBitmap(newFDNum, fdBitmapPtr);
	summaryPtr->numFreeFileDesc--;
	ReadFileDesc(partFID, headerPtr, newFDNum, &newFD);
	newFDPtr = &newFD;

	status = AddToDirectory(partFID, headerPtr, !printOnly, &indexInfo, 
	    &spriteDirEntPtr, newFDNum, fileName);
	if (status != SUCCESS) {
	    fprintf(stderr, "%s is full\n", dirName);
	    break;
	}
	if (makeDevice) {
	    InitDesc(newFDPtr, FS_DEVICE, 0, devServer, devType, devUnit, 0, 0,
		(int) statBuf.st_mode & 07777, curTime.tv_sec);
	    printf("Device: %s%s (S %d, T %d, U %d)\n", path, fileName,
		devServer, devType, devUnit);
#ifdef sprite
	} else if ((statBuf.st_mode & S_GFMT) == S_IFPDEV) {
	    printf("Skipping pseudo-device %s%s\n", path, fileName);
#endif
	} else if ((statBuf.st_mode & S_GFMT) == S_GFREG ||
#ifdef sprite
		   ((statBuf.st_mode & S_GFMT) == S_IFRLNK)  || 
#endif
		   (statBuf.st_mode & S_GFMT) == S_GFLNK) {
	    int	fd;
	    int	blockNum;
	    int	toRead;
	    int	len;

	    blockNum = 0;
	    if ((statBuf.st_mode & S_GFMT) == S_GFREG) {
		printf("File: %s%s\n", path, fileName);
		InitDesc(newFDPtr, FS_FILE, (int) statBuf.st_size, -1, -1, -1,
			 0, 0, (int) statBuf.st_mode & 07777, statBuf.st_mtime);
		/*
		 * Copy the file over.
		 */
		fd = open(fileName, 0);
		if (fd < 0) {
		    fprintf(stderr, "WARNING: Can't open %s%s: ", pathName,
			fileName);
		    perror((char *) NULL);
		    freeFDNum--;
		    summaryPtr->numFreeFileDesc++;
		    continue;
		}
		len = read(fd, fileBlock, FS_BLOCK_SIZE);
		if (len < 0) {
		    fprintf(stderr, "WARNING: Can't read %s%s: ", pathName,
			fileName);
		    perror((char *) NULL);
		    freeFDNum--;
		    summaryPtr->numFreeFileDesc++;
		    continue;
		}
		toRead = statBuf.st_size;
	    } else {
		len = readlink(fileName, fileBlock, FS_BLOCK_SIZE);
		if (len < 0) {
		    fprintf(stderr, "WARNING: Can't readlink %s%s: ", pathName,
			fileName);
		    perror((char *) NULL);
		    freeFDNum--;
		    summaryPtr->numFreeFileDesc++;
		    continue;
		}
		fileBlock[len] = '\0';
		InitDesc(newFDPtr, FS_SYMBOLIC_LINK, len + 1, -1, -1, -1, 
			 0, 0, 0777, statBuf.st_mtime);
#ifdef sprite
		if ((statBuf.st_mode & S_GFMT) == S_IFRLNK) { 
		    printf("Remote link: %s%s\n", path, fileName);
		} else {
		    printf("Symbolic link: %s%s -> %s\n", 
			    path, fileName, fileBlock);
		}
#else
		printf("Symbolic link: %s%s -> %s\n", 
			path, fileName, fileBlock);
#endif
		toRead = len + 1;
	    }

	    while (len > 0) {
		if (blockNum == FSDM_NUM_DIRECT_BLOCKS) {
		    int	i;
		    int	*intPtr;
		    /*
		     * Must allocate an indirect block.
		     */
		    newFDPtr->indirect[0] =
			VirtToPhys(freeBlockNum * FS_FRAGMENTS_PER_BLOCK);
		    MarkDataBitmap(headerPtr, cylBitmapPtr, freeBlockNum,
				   FS_FRAGMENTS_PER_BLOCK);
		    freeBlockNum++;
		    summaryPtr->numFreeKbytes -= FS_FRAGMENTS_PER_BLOCK;
		    for (i = 0, intPtr = (int *)indirectBlock; 
			 i < FS_BLOCK_SIZE / sizeof(int); 
			 i++, intPtr++) {
			 *intPtr = FSDM_NIL_INDEX;
		    }
		}
		if (blockNum >= FSDM_NUM_DIRECT_BLOCKS) {
		    indIndexPtr[blockNum - FSDM_NUM_DIRECT_BLOCKS] = 
					freeBlockNum * FS_FRAGMENTS_PER_BLOCK;
		    MarkDataBitmap(headerPtr, cylBitmapPtr, freeBlockNum,
				   FS_FRAGMENTS_PER_BLOCK);
		    summaryPtr->numFreeKbytes -= FS_FRAGMENTS_PER_BLOCK;
		} else {
		    newFDPtr->direct[blockNum] = 
					freeBlockNum * FS_FRAGMENTS_PER_BLOCK;
		    if (toRead > FS_BLOCK_SIZE) {
			MarkDataBitmap(headerPtr, cylBitmapPtr, freeBlockNum,
				       FS_FRAGMENTS_PER_BLOCK);
			summaryPtr->numFreeKbytes -= FS_FRAGMENTS_PER_BLOCK;
		    } else {
			MarkDataBitmap(headerPtr, cylBitmapPtr, freeBlockNum,
				       (toRead - 1) / FS_FRAGMENT_SIZE + 1);
			summaryPtr->numFreeKbytes -= 
					(toRead - 1) / FS_FRAGMENT_SIZE + 1;
		    }
		}
		/*
		 * Write the block out to disk.
		 */
		if (Disk_BlockWrite(partFID, headerPtr, 
				    headerPtr->dataOffset + freeBlockNum,
				    1, (Address)fileBlock) != 0) {
		    fprintf(stderr, "Couldn't write file block\n");
		    exit(1);
		}
		blockNum++;
		freeBlockNum++;
		if ((statBuf.st_mode & S_GFMT) == S_GFLNK) {
		    break;
		}
		toRead -= len;
		len = read(fd, fileBlock, FS_BLOCK_SIZE);
		if (len < 0) {
		    perror(fileName);
		    exit(1);
		}
	    }
	    if (newFDPtr->indirect[0] != FSDM_NIL_INDEX) {
		if (Disk_BlockWrite(partFID, headerPtr,
			    newFDPtr->indirect[0] / FS_FRAGMENTS_PER_BLOCK,
			    1, (Address)indirectBlock) != 0) {
		    fprintf(stderr, "Couldn't write indirect block\n");
		    exit(1);
		}
	    }
	    close(fd);
	} else if (statBuf.st_mode & S_GFDIR) {
	    char	newPath[FS_MAX_NAME_LENGTH];

	    /*
	     * Increment the current directories link count because once
	     * the child gets created it will point to the parent.
	     */
	    dirFDPtr->numLinks++;
	    /*
	     * Allocate the currently free file descriptor to this directory.
	     */
	    InitDesc(newFDPtr, FS_DIRECTORY, FS_BLOCK_SIZE, -1, -1, -1, 
		     0, 0, (int) statBuf.st_mode & 07777, statBuf.st_mtime);
	    /*
	     * Give the directory one full block.  The directory will
	     * be initialized by CopyTree when we call it recursively.
	     */
	    newFDPtr->direct[0] = freeBlockNum * FS_FRAGMENTS_PER_BLOCK;
	    MarkDataBitmap(headerPtr, cylBitmapPtr, freeBlockNum,
			   FS_FRAGMENTS_PER_BLOCK);
	    freeBlockNum++;
	    sprintf(newPath, "%s%s/", path, fileName);
	    printf("Directory: %s\n", newPath);
	    CopyTree(partFID, fileName, newFDNum, newFDPtr, dirFDNum, TRUE, 
		newPath);
	} else {
	    fprintf(stderr, "WARNING: %s%s is not a file or directory\n",
		pathName, fileName);
	    freeFDNum--;
	    summaryPtr->numFreeFileDesc++;
	    continue;
	}
	WriteFileDesc(partFID, headerPtr, newFDNum, newFDPtr);

    }

    CloseDir(partFID, headerPtr, !printOnly, &indexInfo);

    if (chdir(pathName) < 0) {
	perror(pathName);
	exit(1);
    }
    closedir(unixDirPtr);
    return;
}

d470 6
a475 6
ReturnStatus
SetDomainHeader(labelPtr, headerPtr, spriteID, partition)
    Disk_Label		*labelPtr;	/* The disk label. */
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header to fill in */
    int 		spriteID;	/* Host ID of machine with the disks */
    int 		partition;	/* Index of partition to format */
d480 2
a481 7
    headerPtr->firstCylinder = labelPtr->partitions[partition].firstCylinder;
    headerPtr->numCylinders = labelPtr->partitions[partition].numCylinders;
    if (headerPtr->numCylinders <= 0) {
	fprintf(stderr, "Invalid partition size: %d cylinders.\n", 
	    headerPtr->numCylinders);
	return FAILURE;
    }
d498 1
a498 1
	SetSCSIDiskGeometry(labelPtr, geoPtr);
d500 1
a500 1
	SetDiskGeometry(labelPtr, geoPtr);
d503 1
a503 2
    SetDomainParts(labelPtr, partition, headerPtr);
    return SUCCESS;
d525 3
a527 3
SetSCSIDiskGeometry(labelPtr, geoPtr)
    register Disk_Label		*labelPtr;	/* The disk label. */
    register Fsdm_Geometry 	*geoPtr;	/* Fancy geometry information */
d532 2
a533 2
    geoPtr->numHeads = labelPtr->numHeads;
    geoPtr->sectorsPerTrack = labelPtr->numSectors;
d577 3
a579 3
SetDiskGeometry(labelPtr, geoPtr)
    register Disk_Label		*labelPtr;	/* The disk label. */
    register Fsdm_Geometry 	*geoPtr;	/* Fancy geometry information */
d592 2
a593 2
    geoPtr->numHeads = labelPtr->numHeads;
    geoPtr->sectorsPerTrack = labelPtr->numSectors;
d764 2
a765 3
SetDomainParts(labelPtr, partition, headerPtr)
    register Disk_Label		*labelPtr;	/* The disk label. */
    int partition;
a776 2
    int maxSector;
    int numCylinders;
a782 7
    maxSector = labelPtr->labelSector;
    maxSector = Max(maxSector,labelPtr->bootSector + labelPtr->numBootSectors);
    maxSector = Max(maxSector,labelPtr->summarySector
	+ labelPtr->numSummarySectors);
    maxSector = Max(maxSector,labelPtr->domainSector
	+ labelPtr->numDomainSectors);
    numCylinders = labelPtr->partitions[partition].numCylinders;
d788 5
a792 2
	cylinders = maxSector / (geoPtr->sectorsPerTrack * geoPtr->numHeads);
	if ((maxSector % (geoPtr->sectorsPerTrack * geoPtr->numHeads)) != 0) {
d796 2
a797 1
	numBlocks = geoPtr->blocksPerCylinder * numCylinders - reservedBlocks;
d803 5
a807 3
	sets = maxSector / (geoPtr->tracksPerRotSet * geoPtr->sectorsPerTrack);
	if ((maxSector % (geoPtr->tracksPerRotSet * geoPtr->sectorsPerTrack)) 
	!= 0) {
d811 2
a812 1
	numBlocks = geoPtr->blocksPerCylinder * numCylinders - reservedBlocks;
d890 2
a891 1
 *	Initialize the summary information for the domain.  
d902 2
a903 1
SetSummaryInfo(headerPtr, summaryPtr)
d905 1
a905 1
    Fsdm_SummaryInfo *summaryPtr;	/* Summary info to fill in */
d908 1
a908 1
    bzero((Address)summaryPtr, sizeof(Fsdm_SummaryInfo));
d912 2
a913 2
     * 20 KB is already allocated, 4 for the root directory,
     * 8 for lost+found, and 8 for .fscheck.out
d916 4
a919 1
				- 20;
d921 2
a922 2
     * 5 file descriptors are already used, 0 and 1 are reserved,
     * 2 is for the root, 3 is for lost+found, and 4 is for .fscheck.out
d924 7
a930 1
    summaryPtr->numFreeFileDesc = headerPtr->numFileDesc - 5;
d955 1
a955 1
 * WriteAllFileDescs --
d957 1
a957 1
 *	Write out all of the file descriptors to disk.
d960 1
a960 1
 *	SUCCESS if the descriptors were written, FAILURE otherwise.
d968 2
a969 1
WriteAllFileDescs(partFID, headerPtr)
a970 1
    register Fsdm_DomainHeader *headerPtr;
d974 1
a974 1
    char block[FS_BLOCK_SIZE];
a976 1
    int j;
a982 1
	    printf("Couldn't write bitmap\n");
d988 3
a990 2
     * canned file descriptors for the root, bad block file, the
     * lost and found directory and fscheck's output file.  
d992 1
d1003 1
a1003 2
	    InitDesc(fileDescPtr, FS_FILE, 0, -1, -1, -1, 0, 0, 0, 
		curTime.tv_sec);
d1005 1
a1005 6
	    InitDesc(fileDescPtr, FS_DIRECTORY, FS_BLOCK_SIZE, -1, -1, -1, 0,
		    0, 0755, curTime.tv_sec);
	    /*
	     * Place the data in the first file system block.
	     */
	    fileDescPtr->direct[0] = 0;
d1007 5
a1011 13
	    InitDesc(fileDescPtr, FS_DIRECTORY, 2 * FS_BLOCK_SIZE,-1, -1, -1, 0,
		    0, 0755, curTime.tv_sec);
	    for (j = 0; j < FSDM_NUM_LOST_FOUND_BLOCKS ; j++) {
		fileDescPtr->direct[j] = FS_FRAGMENTS_PER_BLOCK 
		    * (j + 1);
	    }
	} else if (index == FSDM_LOST_FOUND_FILE_NUMBER+1) {
	    InitDesc(fileDescPtr, FS_FILE, 2 * FS_BLOCK_SIZE, -1, -1, -1, 0,
		    0, 0755, curTime.tv_sec);
	    for (j = 0; j < 2 ; j++) {
		fileDescPtr->direct[j] = FS_FRAGMENTS_PER_BLOCK 
		    * (j + 1 + FSDM_NUM_LOST_FOUND_BLOCKS);
	    }
d1060 303
d1390 1
a1390 1
     * Reserve file descriptors 0, 1, 2, 3, and 4. File number 0 is not used at 
d1392 1
a1392 1
     * File number 2 (FSDM_ROOT_FILE_NUMBER) is the domain's root directory.
a1394 1
     * File number 4 is for fscheck's output.
d1398 14
a1411 2
    bitmap[0] |= 0xf8;
    freeFDNum = 5;
d1446 2
a1447 2
 *	first 4K is allocated to the root directory, 8K is
 *	allocated to lost and found, and 8K to .fscheck.out.
d1458 2
a1459 1
WriteBitmap(partFID, headerPtr)
a1460 1
    register Fsdm_DomainHeader *headerPtr;
d1468 2
a1469 3
     * Set the bits corresponding to the 4K used for the root directory,
     * the 8K reserved for lost and found, and the 8K reserved for
     * .fscheck.out.
d1476 5
a1480 3
    bitmap[1] |= 0xff;
    bitmap[2] |= 0xf0;
    freeBlockNum = 5;
d1507 3
a1509 4
WriteRootDirectory(partFID, headerPtr, fdPtr)
    int 			partFID;	/* Raw disk handle. */
    register Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
    Fsdm_FileDescriptor		*fdPtr;		/* Root file desc */
d1511 80
a1590 5
    ReturnStatus 	status;
    char 		block[FS_BLOCK_SIZE];
    Fslcl_DirEntry 	*dirEntryPtr;
    int 		i;
    DirIndexInfo	indexInfo;
a1591 1
    CreateDir(block, 1, FSDM_ROOT_FILE_NUMBER, FSDM_ROOT_FILE_NUMBER);
a1592 1
	int offset;
d1595 10
a1604 1
	for (i = 0; i < 4; i++) {
d1607 2
d1610 2
d1613 1
d1615 7
a1621 25
	status = Disk_BlockWrite(partFID, headerPtr, headerPtr->dataOffset,
	    1, block);
	if (status != 0) {
	    fprintf(stderr, "WriteRootDirectory: Couldn't write directory\n");
	}
    }
    status = OpenDir(partFID, headerPtr, fdPtr, &indexInfo, &dirEntryPtr);
    if (status != SUCCESS) {
	fprintf(stderr, "Can't open root file descriptor\n");
	return status;
    }
    status = AddToDirectory(partFID, headerPtr, !printOnly, &indexInfo, 
			&dirEntryPtr, FSDM_LOST_FOUND_FILE_NUMBER, 
			"lost+found");
    if (status != SUCCESS) {
	fprintf(stderr, "Can't add lost+found to root directory.\n");
	return status;
    }
    fdPtr->numLinks++;
    status = AddToDirectory(partFID, headerPtr, !printOnly, &indexInfo,
			&dirEntryPtr, FSDM_LOST_FOUND_FILE_NUMBER + 1, 
			".fscheck.out");
    if (status != SUCCESS) {
	fprintf(stderr, "Can't add .fscheck.out to root directory.\n");
	return status;
a1622 1
    CloseDir(partFID, headerPtr, !printOnly, &indexInfo);
d1642 2
a1643 1
WriteLostFoundDirectory(partFID, headerPtr)
a1644 1
    register Fsdm_DomainHeader *headerPtr;
d1646 7
a1652 410
    ReturnStatus 	status = SUCCESS;
    char 		block[FSDM_NUM_LOST_FOUND_BLOCKS * FS_BLOCK_SIZE];
    Fslcl_DirEntry 	*dirEntryPtr;
    int 		i;

    CreateDir(block, FSDM_NUM_LOST_FOUND_BLOCKS, FSDM_LOST_FOUND_FILE_NUMBER, 
	FSDM_ROOT_FILE_NUMBER);
    if (printOnly) {
	int offset;
	printf("lost+found Directory\n");
	offset = 0;
	for (i = 0; i < 4; i++) {
	    dirEntryPtr = (Fslcl_DirEntry *)((int)block + offset);
	    Disk_PrintDirEntry(dirEntryPtr);
	    offset += dirEntryPtr->recordLength;
	}
    } else {
	status = Disk_BlockWrite(partFID, headerPtr, headerPtr->dataOffset + 1,
			FSDM_NUM_LOST_FOUND_BLOCKS, block);
	if (status != 0) {
	    fprintf(stderr, 
		"WriteLostFoundDirectory: Couldn't write directory\n");
	}
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * InitDesc --
 *
 *	Set up a file descriptor as allocated.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	File descriptor fields filled in.
 *
 *----------------------------------------------------------------------
 */
void
InitDesc(fileDescPtr, fileType, numBytes, devServer, devType, devUnit, uid,
	gid, permissions, time)
    Fsdm_FileDescriptor	*fileDescPtr;
    int			fileType;
    int			numBytes;
    int			devServer;
    int			devType;
    int			devUnit;
    int			uid;
    int			gid;
    int			permissions;
    long		time;
{
    int		index;

    fileDescPtr->flags = FSDM_FD_ALLOC;
    fileDescPtr->fileType = fileType;
    fileDescPtr->permissions = permissions;
    fileDescPtr->uid = uid;
    fileDescPtr->gid = gid;
    fileDescPtr->lastByte = numBytes - 1;
    fileDescPtr->firstByte = -1;
    if (fileType == FS_DIRECTORY) {
	fileDescPtr->numLinks = 2;
    } else {
	fileDescPtr->numLinks = 1;
    }
    fileDescPtr->devServerID = devServer;
    fileDescPtr->devType = devType;
    fileDescPtr->devUnit = devUnit;

    /*
     * Set the time stamps.  This assumes that universal time,
     * not local time, is used for time stamps.
     */
    fileDescPtr->createTime = (int) time;
    fileDescPtr->accessTime = (int) time;
    fileDescPtr->descModifyTime = (int) time;
    fileDescPtr->dataModifyTime = (int) time;

    /*
     * Place the data in the first filesystem block.
     */
    for (index = 0; index < FSDM_NUM_DIRECT_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FSDM_NIL_INDEX;
    }
    for (index = 0; index < FSDM_NUM_INDIRECT_BLOCKS ; index++) {
	fileDescPtr->indirect[index] = FSDM_NIL_INDEX;
    }
    if (numBytes > 0) {
	int	numBlocks;

	numBlocks = (numBytes - 1) / FS_BLOCK_SIZE + 1;
	if (numBlocks > FSDM_NUM_DIRECT_BLOCKS) {
	    fileDescPtr->numKbytes = (numBlocks + 1) * (FS_BLOCK_SIZE / 1024);
	} else {
	    fileDescPtr->numKbytes = (numBytes + 1023) / 1024;
	}
    } else {
	fileDescPtr->numKbytes = 0;
    }

    fileDescPtr->version = 1;
}

/*
 *----------------------------------------------------------------------
 *
 * AddToDirectory --
 *
 *	Add the file descriptor to a directory.  
 *
 * Results:
 *	SUCCESS if the desciptor was added ok, FAILURE otherwise
 *
 * Side effects:
 *	The directory is modified to contain the file.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
AddToDirectory(fid, headerPtr, writeDisk, dirIndexPtr, dirEntryPtrPtr, 
    fileNumber, fileName)
    int			fid;		/* Handle on raw disk. */
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
    Boolean		writeDisk;	/* Write the disk? */
    DirIndexInfo	*dirIndexPtr;	/* Index information. */
    Fslcl_DirEntry	**dirEntryPtrPtr; /* Directory entry. */
    int		 	fileNumber;	/* File number to add. */
    char 		*fileName;	/* Name of file to add. */
{
    int		 	nameLength;
    int		 	recordLength;
    int		 	leftOver;
    int			oldRecLength;
    Fslcl_DirEntry	*dirEntryPtr;
    ReturnStatus 	status = SUCCESS;

    dirEntryPtr = *dirEntryPtrPtr;

    nameLength = strlen(fileName);
    recordLength = Fslcl_DirRecLength(nameLength);

    while (1) {
	if (dirEntryPtr->fileNumber != 0) {
	    oldRecLength = Fslcl_DirRecLength(dirEntryPtr->nameLength);
	    leftOver = dirEntryPtr->recordLength - oldRecLength;
	    if (leftOver >= recordLength) {
		dirEntryPtr->recordLength = oldRecLength;
		dirEntryPtr = 
			(Fslcl_DirEntry *) ((int) dirEntryPtr + oldRecLength);
		dirEntryPtr->recordLength = leftOver;
		dirIndexPtr->dirOffset += oldRecLength;
	    } else {
		status = NextDirEntry(fid, headerPtr, writeDisk,
			    dirIndexPtr, &dirEntryPtr);
		if (status != SUCCESS) {
		    fprintf(stderr, "Can't add to directory\n");
		    return status;
		}
		continue;
	    }
	} else if (dirEntryPtr->recordLength < recordLength) {
	    status = NextDirEntry(fid, headerPtr, writeDisk,
			dirIndexPtr, &dirEntryPtr);
	    if (status != SUCCESS) {
		fprintf(stderr, "Can't add to directory\n");
		return status;
	    }
	    continue;
	}
	dirEntryPtr->fileNumber = fileNumber;
	dirEntryPtr->nameLength = nameLength;
	(void)strcpy(dirEntryPtr->fileName, fileName);
	leftOver = dirEntryPtr->recordLength - recordLength;
	if (leftOver > FSLCL_DIR_ENTRY_HEADER) {
	    dirEntryPtr->recordLength = recordLength;
	    dirEntryPtr =(Fslcl_DirEntry *) ((int) dirEntryPtr + recordLength);
	    dirEntryPtr->fileNumber = 0;
	    dirEntryPtr->recordLength = leftOver;
	    dirIndexPtr->dirOffset += recordLength;
	} else {
	    status = NextDirEntry(fid, headerPtr, writeDisk, 
			    dirIndexPtr, &dirEntryPtr);
	    if (status != SUCCESS) {
		fprintf(stderr, "Can't add to directory\n");
		return status;
	    }
	}
	*dirEntryPtrPtr = dirEntryPtr;
	return status;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * OpenDir --
 *
 *	Set up the structure to allow moving through the given directory.
 *
 * Results:
 *	SUCCESS if the open was successful, FAILURE otherwise
 *
 * Side effects:
 *	The index structure is set up and *dirEntryPtrPtr set to point to
 *	the first directory entry.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
OpenDir(fid, headerPtr, fdPtr, indexInfoPtr, dirEntryPtrPtr)
    int			fid;		/* Handle on raw disk. */
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
    Fsdm_FileDescriptor	*fdPtr;		/* The file descriptor for the
					 * directory. */
    DirIndexInfo 	*indexInfoPtr;	/* Index info struct */
    Fslcl_DirEntry	**dirEntryPtrPtr; /* Current directory entry */
{

    *dirEntryPtrPtr = NULL;
    if (fdPtr->lastByte == -1) {
	/*
	 * Empty directory.
	 */
	return SUCCESS;
    } else if ((fdPtr->lastByte + 1) % FSLCL_DIR_BLOCK_SIZE != 0) {
	fprintf(stderr, "Directory not multiple of directory block size.\n");
	return FAILURE;
    } else if (fdPtr->fileType != FS_DIRECTORY) {
	fprintf(stderr, "OpenDir: Not a directory\n");
	return FAILURE;
    }

    /*
     * Initialize the index structure.
     */
    indexInfoPtr->fdPtr = fdPtr;
    indexInfoPtr->blockNum = 0;
    indexInfoPtr->blockAddr = fdPtr->direct[0] / FS_FRAGMENTS_PER_BLOCK + 
			      headerPtr->dataOffset;
    /*
     * Read in the directory block.
     */
    if (fdPtr->lastByte != FS_BLOCK_SIZE - 1) {
	fprintf(stderr, "We created a directory that's not 4K?\n");
	return FAILURE;
    }
    if (Disk_BlockRead(fid, headerPtr,
		       indexInfoPtr->blockAddr,
		       1, indexInfoPtr->dirBlock) < 0) {
	fprintf(stderr, "OpenDir: Read failed block %d\n",
			indexInfoPtr->blockAddr);
	return FAILURE;
    } 
    indexInfoPtr->dirOffset = 0;
    *dirEntryPtrPtr = (Fslcl_DirEntry *) indexInfoPtr->dirBlock;
    return SUCCESS;
}


/*
 *----------------------------------------------------------------------
 *
 * NextDirEntry --
 *
 *	Get a pointer to the next directory entry.
 *
 * Results:
 *	SUCCESS if the next entry was found ok, FAILURE otherwise
 *
 * Side effects:
 *	The index structure is modified and *dirEntryPtrPtr set to point
 *	to the next directory entry.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
NextDirEntry(fid, headerPtr, writeDisk, indexInfoPtr, dirEntryPtrPtr)
    int			fid;		/* Handle on raw disk. */
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
    Boolean		writeDisk;	/* Write the disk? */
    DirIndexInfo 	*indexInfoPtr;	/* Index information. */
    Fslcl_DirEntry	**dirEntryPtrPtr; /* Current directory entry */
{
    Fslcl_DirEntry	*dirEntryPtr;	

    dirEntryPtr = *dirEntryPtrPtr;
    indexInfoPtr->dirOffset += dirEntryPtr->recordLength;
    if (indexInfoPtr->dirOffset < FS_BLOCK_SIZE) {
	/*
	 * The next directory entry is in the current block.
	 */
	*dirEntryPtrPtr = (Fslcl_DirEntry *)
			&(indexInfoPtr->dirBlock[indexInfoPtr->dirOffset]);
	return SUCCESS;
    } else {
	Fsdm_FileDescriptor	*fdPtr;
	int			i;

	printf("Adding new block to directory ...\n");

	/*
	 * Write out the current block and set up the next one.
	 */
	if (writeDisk) {
	    if (Disk_BlockWrite(fid, headerPtr, indexInfoPtr->blockAddr,
				1, indexInfoPtr->dirBlock) < 0) {
		fprintf(stderr, "NextDirEntry: Write failed block %d\n",
				indexInfoPtr->blockAddr);
		return FAILURE;
	    }
	}
	fdPtr = indexInfoPtr->fdPtr;
	fdPtr->lastByte += FS_BLOCK_SIZE;
	fdPtr->numKbytes += FS_FRAGMENTS_PER_BLOCK;
	indexInfoPtr->blockNum++;
	fdPtr->direct[indexInfoPtr->blockNum] = 
				freeBlockNum * FS_FRAGMENTS_PER_BLOCK;
	MarkDataBitmap(headerPtr, cylBitmapPtr, freeBlockNum,
		       FS_FRAGMENTS_PER_BLOCK);
	indexInfoPtr->blockAddr = freeBlockNum + headerPtr->dataOffset;
	freeBlockNum++;
	for (i = 0, dirEntryPtr = (Fslcl_DirEntry *)indexInfoPtr->dirBlock; 
	     i < FS_BLOCK_SIZE / FSLCL_DIR_BLOCK_SIZE;
     i++,dirEntryPtr=(Fslcl_DirEntry *)((unsigned)dirEntryPtr+FSLCL_DIR_BLOCK_SIZE)) {
	    dirEntryPtr->fileNumber = 0;
	    dirEntryPtr->recordLength = FSLCL_DIR_BLOCK_SIZE;
	    dirEntryPtr->nameLength = 0;
	}
	indexInfoPtr->dirOffset = 0;
	*dirEntryPtrPtr = (Fslcl_DirEntry *) indexInfoPtr->dirBlock;
	return SUCCESS;
    }
}


/*
 *----------------------------------------------------------------------
 *
 * CloseDir --
 *
 *	Flushes the current directory block to disk, if necessary.
 *
 * Results:
 *	SUCCESS if the directory was closed ok, FAILURE otherwise
 *
 * Side effects:
 *	Stuff is written to disk.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
CloseDir(fid, headerPtr, writeDisk, indexInfoPtr)
    int			fid;		/* Handle on raw disk. */
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
    Boolean		writeDisk;	/* Write the disk? */
    DirIndexInfo 	*indexInfoPtr;	/* Index information. */
{

    if (writeDisk) {
	if (Disk_BlockWrite(fid, headerPtr, indexInfoPtr->blockAddr,
			    1, indexInfoPtr->dirBlock) < 0) {
	    fprintf(stderr, "CloseDir: Write (2) failed block %d\n",
			    indexInfoPtr->blockAddr);
	    return FAILURE;
	}
    }
    return SUCCESS;
}

/*
 *----------------------------------------------------------------------
 *
 * ReadFileDesc --
 *
 *	Return the given file descriptor.
 *
 * Results:
 *	SUCCESS if file descriptor was read ok, FAILURE otherwise
 *
 * Side effects:
 *	The file descriptor struct is filled in.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
ReadFileDesc(fid, headerPtr, fdNum, fdPtr)
    int			fid;		/* Handle on raw disk. */
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
    int			fdNum;		/* File number. */
    Fsdm_FileDescriptor	*fdPtr;		/* Place to store fd. */
{
    static char		block[FS_BLOCK_SIZE];
    int			blockNum;
    int			offset;

    blockNum = headerPtr->fileDescOffset + fdNum / FSDM_FILE_DESC_PER_BLOCK;
    offset = (fdNum & (FSDM_FILE_DESC_PER_BLOCK - 1)) * FSDM_MAX_FILE_DESC_SIZE;
    if (Disk_BlockRead(fid, headerPtr, blockNum, 1, 
		       (Address) block) < 0) {
	fprintf(stderr, "ReadFileDesc: Read failed\n");
	return FAILURE;
    }
    bcopy((Address)&block[offset], (Address)fdPtr, sizeof(Fsdm_FileDescriptor));
    return SUCCESS;
}
d1654 2
a1655 69

/*
 *----------------------------------------------------------------------
 *
 * WriteFileDesc --
 *
 *	Write the given file descriptor.
 *
 * Results:
 *	SUCCESS if the write was successful, FAILURE otherwise
 *
 * Side effects:
 *	Stuff is written to disk.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
WriteFileDesc(fid, headerPtr, fdNum, fdPtr)
    int			fid;		/* Handle on raw disk. */
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
    int			fdNum;		/* File number. */
    Fsdm_FileDescriptor	*fdPtr;		/* Place to store fd. */
{
    static char		block[FS_BLOCK_SIZE];
    int			blockNum;
    int			offset;

    blockNum = headerPtr->fileDescOffset + fdNum / FSDM_FILE_DESC_PER_BLOCK;
    offset = (fdNum & (FSDM_FILE_DESC_PER_BLOCK - 1)) * FSDM_MAX_FILE_DESC_SIZE;
    if (Disk_BlockRead(fid, headerPtr, blockNum, 1, 
		       (Address) block) < 0) {
	fprintf(stderr, "WriteFileDesc: Read failed\n");
	return FAILURE;
    }
    bcopy((Address)fdPtr, (Address)&block[offset], sizeof(Fsdm_FileDescriptor));
    if (Disk_BlockWrite(fid, headerPtr, blockNum, 1, 
		       (Address) block) < 0) {
	fprintf(stderr, "WriteFileDesc: Write failed\n");
	return FAILURE;
    }
    return SUCCESS;
}
/*
 *----------------------------------------------------------------------
 *
 * CreateDir --
 *
 *	Create a directory out of file system blocks.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	File system block set up as a directory.
 *
 *----------------------------------------------------------------------
 */
void
CreateDir(blocks, numBlocks, dot, dotDot)
    Address	blocks;		/* Blocks to create directory in. */
    int		numBlocks;	/* Number of blocks. */
    int		dot;		/* File number of directory. */
    int		dotDot;		/* File number of parent. */
{
    Fslcl_DirEntry	*dirEntryPtr;
    char	*fileName;
    int		offset;
    int		length;
    int		i;
a1656 1
    dirEntryPtr = (Fslcl_DirEntry *)blocks;
d1659 1
a1659 1
    dirEntryPtr->fileNumber = dot;
d1665 1
a1665 1
    dirEntryPtr = (Fslcl_DirEntry *)((int)blocks + offset);
d1668 1
a1668 1
    dirEntryPtr->fileNumber = dotDot;
d1672 1
d1676 3
a1678 2
    for (dirEntryPtr = (Fslcl_DirEntry *)&blocks[FSLCL_DIR_BLOCK_SIZE], i = 1; 
	 i < (FS_BLOCK_SIZE * numBlocks) / FSLCL_DIR_BLOCK_SIZE;
d1684 9
a1692 31
}
int fragMasks[FS_FRAGMENTS_PER_BLOCK + 1] = {0x0, 0x08, 0x0c, 0x0e, 0x0f};


/*
 *----------------------------------------------------------------------
 *
 * MarkDataBitmap --
 *
 *	Mark the appropriate bits in the data block bitmap.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Data block marked.
 *
 *----------------------------------------------------------------------
 */
void
MarkDataBitmap(headerPtr, cylBitmapPtr, blockNum, numFrags)
    Fsdm_DomainHeader	*headerPtr;
    unsigned char	*cylBitmapPtr;
    int			blockNum;
    int			numFrags;
{
    unsigned char	*bitmapPtr;

    bitmapPtr = GetBitmapPtr(headerPtr, cylBitmapPtr, blockNum);
    if ((blockNum % headerPtr->geometry.blocksPerCylinder) & 0x1) {
	*bitmapPtr |= fragMasks[numFrags];
d1694 2
a1695 1
	*bitmapPtr |= fragMasks[numFrags] << 4;
d1697 1
a1697 95
}

/*
 *----------------------------------------------------------------------
 *
 * ReadFileDescBitmap --
 *
 *	Read in the file descriptor bitmap.
 *
 * Results:
 *	A pointer to the file descriptor bit map.
 *
 * Side effects:
 *	Memory allocated for the bit map.
 *
 *----------------------------------------------------------------------
 */
unsigned char *
ReadFileDescBitmap(fid, headerPtr)
    int			fid;		/* Handle on raw disk. */
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
{
    register unsigned char *bitmap;

    /*
     * Allocate the bitmap.
     */
    bitmap = (unsigned char *)malloc(
	(unsigned) headerPtr->fdBitmapBlocks * FS_BLOCK_SIZE);
    if (Disk_BlockRead(fid, headerPtr, headerPtr->fdBitmapOffset,
		  headerPtr->fdBitmapBlocks, (Address)bitmap) < 0) {
	fprintf(stderr, "ReadFileDescBitmap: Read failed");
	exit(1);
    }
    return(bitmap);
}

/*
 *----------------------------------------------------------------------
 *
 * ReadBitmap --
 *
 *	Read the bitmap off disk.
 *
 * Results:
 *	A pointer to the bitmap.
 *
 * Side effects:
 *	Memory allocated for the bit map.
 *
 *----------------------------------------------------------------------
 */
unsigned char *
ReadBitmap(fid, headerPtr)
    int			fid;		/* Handle on raw disk. */
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
{
    unsigned char *bitmap;

    bitmap = (unsigned char *)malloc((unsigned) 
	    headerPtr->bitmapBlocks * FS_BLOCK_SIZE);
    if (Disk_BlockRead(fid, headerPtr, headerPtr->bitmapOffset,
		  headerPtr->bitmapBlocks, (Address) bitmap) < 0) {
	fprintf(stderr, "ReadBitmap: Read failed");
	exit(1);
    }
    return(bitmap);
}

/*
 *----------------------------------------------------------------------
 *
 * WriteFileDescBitmap --
 *
 *	Write out the file descriptor bitmap.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
WriteFileDescBitmap(fid, headerPtr, bitmap)
    int			fid;		/* Handle on raw disk. */
    Fsdm_DomainHeader 	*headerPtr;	/* Domain header. */
    unsigned char 	*bitmap;	/* Bitmap to write. */
{
    if (Disk_BlockWrite(fid, headerPtr, headerPtr->fdBitmapOffset,
		   headerPtr->fdBitmapBlocks, (Address)bitmap) < 0) {
	fprintf(stderr, "WriteFileDescBitmap: Write failed");
	exit(1);
    }
a1698 1

@


1.13
log
@fixed a couple of bugs in printfs
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/admin/fsmake/RCS/fsmake.c,v 1.12 89/08/29 17:03:06 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
d167 1
a167 1
    if (bootSectors > FS_MAX_BOOT_SECTORS) {
d169 1
a169 1
	    FS_MAX_BOOT_SECTORS);
d172 1
a172 1
    if ((bootSectors != -1) && (bootSectors % FS_BOOT_SECTOR_INC != 0)) {
d174 1
a174 1
	    FS_BOOT_SECTOR_INC);
d215 5
a219 1
    partFID = open(partitionName, O_RDWR);
d294 3
a296 3
    FsDomainHeader 	*headerPtr;
    FsSummaryInfo 	*summaryPtr;
    FsSummaryInfo 	*oldSummaryPtr;
d317 1
a317 1
	oldSummaryPtr = (FsSummaryInfo *) block;
d365 1
a365 1
    headerPtr = (FsDomainHeader *)
d385 1
a385 1
    summaryPtr = (FsSummaryInfo *) malloc(DEV_BYTES_PER_SECTOR);
d473 1
a473 1
    FsDomainHeader *headerPtr;	/* Reference to domain header to fill in */
d477 1
a477 1
    register FsGeometry *geoPtr;/* The layout information for the disk */
d479 1
a479 1
    headerPtr->magic = FS_DOMAIN_MAGIC;
d527 1
a527 1
    register FsGeometry *geoPtr;	/* Fancy geometry information */
a530 1
    int numRotSets;		/* Rotational sets per cylinder */
a537 1
retry:
d543 4
a546 61
    /*
     * Currently the Fs_Geometry typedef has a limit on the number
     * of blocks per rotational set.  Ideally, for a SCSI disk, we'd
     * just have one rotational set per cylinder, but we might have
     * to have several to get around this (silly) restriction.
     */
    numRotSets = blocksPerCyl / FS_MAX_ROT_POSITIONS;
    if (numRotSets < 1) {
	/*
	 * Simple case.  Less than FS_MAX_ROT_POSITIONS number of blocks.
	 * Make the cylinder into one rotational set.
	 */
	geoPtr->rotSetsPerCyl = 1;
	geoPtr->blocksPerRotSet = blocksPerCyl;
	geoPtr->blocksPerCylinder = blocksPerCyl;
	geoPtr->tracksPerRotSet = geoPtr->numHeads;
	for (index = 0; index < blocksPerCyl; index++){
	    geoPtr->blockOffset[index] = index * DISK_SECTORS_PER_BLOCK;
	}
	for (index = blocksPerCyl; index < FS_MAX_ROT_POSITIONS; index++){
	    geoPtr->blockOffset[index] = -1;
	}
    } else {
	/*
	 * Sigh, have to figure out a good number of tracks for
	 * each rotational set.  In the worst case each track is
	 * its own rotational set.
	 */
	for (numRotSets += 1; numRotSets <= geoPtr->numHeads; numRotSets++) {
	    if (blocksPerCyl % numRotSets == 0) {
		/*
		 * Found a number of rotational sets that evenly divides
		 * the total possible number of blocks in the cylinder.
		 */
		goto foundNumSets;
	    }
	}
	printf("No good number of rotational sets with %d blocks/cyl.\n",
		blocksPerCyl);
	blocksPerCyl--;
	if (blocksPerCyl < 1) {
	    panic("Can't determine file system block layout.\n");
	}
	goto retry;

foundNumSets:
	printf("Using %d rotational sets, %d blocks/set, %d sectors/cyl wasted\n",
		numRotSets, blocksPerCyl / numRotSets,
		geoPtr->sectorsPerTrack * geoPtr->numHeads - 
		blocksPerCyl * DISK_SECTORS_PER_BLOCK);
	geoPtr->rotSetsPerCyl = numRotSets;
	geoPtr->blocksPerRotSet = blocksPerCyl / numRotSets;
	geoPtr->blocksPerCylinder = blocksPerCyl;
	geoPtr->tracksPerRotSet = geoPtr->numHeads / numRotSets;
	for (index = 0; index < geoPtr->blocksPerRotSet; index++){
	    geoPtr->blockOffset[index] = index * DISK_SECTORS_PER_BLOCK;
	}
	for ( ; index < FS_MAX_ROT_POSITIONS; index++){
	    geoPtr->blockOffset[index] = -1;
	}
    }
d550 1
a550 1
    for (index = 0 ; index < FS_MAX_ROT_POSITIONS ; index++) {
d579 1
a579 1
    register FsGeometry *geoPtr;	/* Fancy geometry information */
d712 1
a712 1
		for (index = numBlocks; index < FS_MAX_ROT_POSITIONS; index++){
d737 1
a737 1
    for (index = 0 ; index < FS_MAX_ROT_POSITIONS ; index++) {
d766 1
a766 1
    register FsDomainHeader *headerPtr;
d768 1
a768 1
    register FsGeometry *geoPtr;
a773 2
    int numSectors;		/* Sectors per rotational set */
    int numSets;		/* Number of reserved rotational sets */
d775 2
a780 1
     * It is easiest to do this by reserving one or more rotational sets.
d783 26
a808 5
    numSectors = geoPtr->tracksPerRotSet * geoPtr->sectorsPerTrack;
    for ( numSets = 1; ; numSets++ ) {
	if (numSets * numSectors >
	    diskInfoPtr->domainSector + diskInfoPtr->numDomainSectors) {
	    break;
d810 3
d814 1
a814 2
    printf("Reserving %d blocks for domain header, etc.\n",
		    numSets*geoPtr->blocksPerRotSet);
a822 2
	numBlocks = geoPtr->blocksPerCylinder * diskInfoPtr->numCylinders -
		    numSets * geoPtr->blocksPerRotSet;
d826 2
a827 2
	numFiles		  &= ~(FS_FILE_DESC_PER_BLOCK-1);
	offset			  = numSets * geoPtr->blocksPerRotSet;
d837 2
a838 2
	numBlocks		  -= numFiles / FS_FILE_DESC_PER_BLOCK;
	offset			  += numFiles / FS_FILE_DESC_PER_BLOCK;
d866 1
a866 1
	    numFiles -= numBlocksNeeded * FS_FILE_DESC_PER_BLOCK;
d877 1
a877 1
	    numFiles += extraBlocks * FS_FILE_DESC_PER_BLOCK;
d904 2
a905 2
    FsDomainHeader *headerPtr;	/* Domain header to summarize */
    FsSummaryInfo *summaryPtr;	/* Reference to summary info to fill in */
d969 1
a969 1
    register FsDomainHeader *headerPtr;
d975 1
a975 1
    register FsFileDescriptor *fileDescPtr;
d995 1
a995 1
         index < FS_FILE_DESC_PER_BLOCK;
d997 6
a1002 6
	fileDescPtr = (FsFileDescriptor *)((int)block +
					   index * FS_MAX_FILE_DESC_SIZE);
	fileDescPtr->magic = FS_FD_MAGIC;
	if (index < FS_BAD_BLOCK_FILE_NUMBER) {
	    fileDescPtr->flags = FS_FD_RESERVED;
	} else if (index == FS_BAD_BLOCK_FILE_NUMBER) {
d1004 1
a1004 1
	} else if (index == FS_ROOT_FILE_NUMBER) {
d1006 1
a1006 1
	} else if (index == FS_LOST_FOUND_FILE_NUMBER) {
d1008 1
a1008 1
	} else if ((index == FS_LOST_FOUND_FILE_NUMBER+1) && makeFile) {
d1010 1
a1010 1
	} else if ((index == FS_LOST_FOUND_FILE_NUMBER+2) && makeFscheckOut) {
d1013 1
a1013 1
	    fileDescPtr->flags = FS_FD_FREE;
d1031 1
a1031 1
	     index < FS_FILE_DESC_PER_BLOCK;
d1033 4
a1036 4
	    fileDescPtr = (FsFileDescriptor *)((int)block + index *
					       FS_MAX_FILE_DESC_SIZE);
	    fileDescPtr->magic = FS_FD_MAGIC;
	    fileDescPtr->flags = FS_FD_FREE;
d1041 1
a1041 1
	for (index = FS_FILE_DESC_PER_BLOCK;
d1043 1
a1043 1
	     index += FS_FILE_DESC_PER_BLOCK) {
d1045 1
a1045 1
		     headerPtr->fileDescOffset + (index/FS_FILE_DESC_PER_BLOCK),
d1074 1
a1074 1
    register FsFileDescriptor *fileDescPtr;
d1079 1
a1079 1
    fileDescPtr->flags = FS_FD_ALLOC;
d1109 2
a1110 2
    for (index = 1; index < FS_NUM_DIRECT_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FS_NIL_INDEX;
d1112 2
a1113 2
    for (index = 0; index < FS_NUM_INDIRECT_BLOCKS ; index++) {
	fileDescPtr->indirect[index] = FS_NIL_INDEX;
d1136 1
a1136 1
    register FsFileDescriptor *fileDescPtr;
d1141 1
a1141 1
    fileDescPtr->flags = FS_FD_ALLOC;
d1170 2
a1171 2
    for (index = 0; index < FS_NUM_DIRECT_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FS_NIL_INDEX;
d1173 2
a1174 2
    for (index = 0; index < FS_NUM_INDIRECT_BLOCKS ; index++) {
	fileDescPtr->indirect[index] = FS_NIL_INDEX;
d1197 1
a1197 1
    register FsFileDescriptor *fileDescPtr;
d1202 1
a1202 1
    fileDescPtr->flags = FS_FD_ALLOC;
d1207 1
a1207 1
    fileDescPtr->lastByte = FS_NUM_LOST_FOUND_BLOCKS * FS_BLOCK_SIZE - 1;
d1228 1
a1228 1
    for (index = 0; index < FS_NUM_LOST_FOUND_BLOCKS ; index++) {
d1231 2
a1232 2
    for (; index < FS_NUM_DIRECT_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FS_NIL_INDEX;
d1234 2
a1235 2
    for (index = 0; index < FS_NUM_INDIRECT_BLOCKS ; index++) {
	fileDescPtr->indirect[index] = FS_NIL_INDEX;
d1258 1
a1258 1
    register FsFileDescriptor *fileDescPtr;
d1263 1
a1263 1
    fileDescPtr->flags = FS_FD_ALLOC;
d1289 2
a1290 2
    for (index = 0; index < FS_NUM_DIRECT_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FS_NIL_INDEX;
d1292 2
a1293 2
    for (index = 0; index < FS_NUM_INDIRECT_BLOCKS ; index++) {
	fileDescPtr->indirect[index] = FS_NIL_INDEX;
d1316 1
a1316 1
    register FsFileDescriptor *fileDescPtr;
d1321 1
a1321 1
    fileDescPtr->flags = FS_FD_ALLOC;
d1350 2
a1351 2
    for (; index < FS_NUM_DIRECT_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FS_NIL_INDEX;
d1353 2
a1354 2
    for (index = 0; index < FS_NUM_INDIRECT_BLOCKS ; index++) {
	fileDescPtr->indirect[index] = FS_NIL_INDEX;
d1377 1
a1377 1
    register FsDomainHeader *headerPtr;
d1392 1
a1392 1
     * File number 2 (FS_ROOT_FILE_NUMBER) is the root directory of the domain.
d1429 1
d1459 1
a1459 1
    register FsDomainHeader *headerPtr;
d1508 1
a1508 1
    register FsDomainHeader *headerPtr;
d1513 1
a1513 1
    FsDirEntry *dirEntryPtr;
d1520 1
a1520 1
    dirEntryPtr = (FsDirEntry *)block;
d1524 2
a1525 2
    dirEntryPtr->fileNumber = FS_ROOT_FILE_NUMBER;
    dirEntryPtr->recordLength = FsDirRecLength(length);
d1530 1
a1530 1
    dirEntryPtr = (FsDirEntry *)((int)block + offset);
d1533 2
a1534 2
    dirEntryPtr->fileNumber = FS_ROOT_FILE_NUMBER;
    dirEntryPtr->recordLength = FsDirRecLength(length);
d1543 1
a1543 1
    dirEntryPtr = (FsDirEntry *) ((int)block + offset);
d1546 1
a1546 1
    dirEntryPtr->fileNumber = FS_LOST_FOUND_FILE_NUMBER;
d1554 1
a1554 1
	dirEntryPtr->recordLength = FsDirRecLength(length);
d1556 1
a1556 1
	dirEntryPtr = (FsDirEntry *)((int)block + offset);
d1559 1
a1559 1
	dirEntryPtr->fileNumber = FS_LOST_FOUND_FILE_NUMBER + 1;
d1567 1
a1567 1
	dirEntryPtr->recordLength = FS_DIR_BLOCK_SIZE - offset;
d1569 1
a1569 1
	dirEntryPtr->recordLength = FsDirRecLength(length);
d1571 1
a1571 1
	dirEntryPtr = (FsDirEntry *)((int)block + offset);
d1574 1
a1574 1
	dirEntryPtr->fileNumber = FS_LOST_FOUND_FILE_NUMBER + 2;
d1577 1
a1577 1
	dirEntryPtr->recordLength = FS_DIR_BLOCK_SIZE - offset;
d1584 3
a1586 3
    for (dirEntryPtr = (FsDirEntry *)&block[FS_DIR_BLOCK_SIZE], i = 1; 
	 i < FS_BLOCK_SIZE / FS_DIR_BLOCK_SIZE;
	 i++,dirEntryPtr=(FsDirEntry *)((int)dirEntryPtr + FS_DIR_BLOCK_SIZE)) {
d1588 1
a1588 1
	 dirEntryPtr->recordLength = FS_DIR_BLOCK_SIZE;
d1595 1
a1595 1
	dirEntryPtr = (FsDirEntry *)block;
d1598 1
a1598 1
	dirEntryPtr = (FsDirEntry *)((int)block + offset);
d1601 1
a1601 1
	dirEntryPtr = (FsDirEntry *)((int)block + offset);
d1605 1
a1605 1
	    dirEntryPtr = (FsDirEntry *)((int)block + offset);
d1610 1
a1610 1
	    dirEntryPtr = (FsDirEntry *)((int)block + offset);
d1643 1
a1643 1
    register FsDomainHeader *headerPtr;
d1648 1
a1648 1
    FsDirEntry *dirEntryPtr;
d1654 2
a1655 2
    block = (char *)malloc(FS_NUM_LOST_FOUND_BLOCKS * FS_BLOCK_SIZE);
    dirEntryPtr = (FsDirEntry *)block;
d1659 2
a1660 2
    dirEntryPtr->fileNumber = FS_LOST_FOUND_FILE_NUMBER;
    dirEntryPtr->recordLength = FsDirRecLength(length);
d1665 1
a1665 1
    dirEntryPtr = (FsDirEntry *)((int)block + offset);
d1668 2
a1669 2
    dirEntryPtr->fileNumber = FS_ROOT_FILE_NUMBER;
    dirEntryPtr->recordLength = FS_DIR_BLOCK_SIZE - offset;
d1677 3
a1679 3
    for (dirEntryPtr = (FsDirEntry *)&block[FS_DIR_BLOCK_SIZE], i = 1; 
	 i < FS_NUM_LOST_FOUND_BLOCKS * FS_BLOCK_SIZE / FS_DIR_BLOCK_SIZE;
	 i++,dirEntryPtr=(FsDirEntry *)((int)dirEntryPtr + FS_DIR_BLOCK_SIZE)) {
d1681 1
a1681 1
	 dirEntryPtr->recordLength = FS_DIR_BLOCK_SIZE;
d1687 1
a1687 1
	dirEntryPtr = (FsDirEntry *)block;
d1690 1
a1690 1
	dirEntryPtr = (FsDirEntry *)((int)block + offset);
d1695 1
a1695 1
			    FS_NUM_LOST_FOUND_BLOCKS, block);
@


1.12
log
@added -host option
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/admin/fsmake/RCS/fsmake.c,v 1.11 89/08/25 11:33:54 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
d539 2
a540 2
	    blocksPerCyl, geoPtr->sectorsPerTrack * geoPtr->numHeads %
			DISK_SECTORS_PER_BLOCK);
d589 2
a590 2
		blocksPerCyl * DISK_SECTORS_PER_BLOCK -
		geoPtr->sectorsPerTrack * geoPtr->numHeads);
@


1.11
log
@changed Sys_GetMachineInfo call to Proc_GetHostIDs
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/admin/fsmake/RCS/fsmake.c,v 1.10 89/08/15 16:06:57 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
d21 1
d52 2
d67 2
d94 2
d177 18
d237 14
a250 9

    /*
     * Determine where the disk is located so we can set the
     * spriteID in the header correctly.
     */
    Fs_GetAttributesID(firstPartFID, &attrs);
    if (attrs.devServerID == FS_LOCALHOST_ID) {
	Proc_GetHostIDs((int *) NULL, &spriteID);
	printf("Making filesystem for local host, ID = 0x%x\n", spriteID);
d252 2
a253 2
	spriteID = attrs.devServerID;
	printf("Making filesystem for remote host 0x%x\n", spriteID);
@


1.10
log
@now does a variable number of boot sectors.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/admin/fsmake/RCS/fsmake.c,v 1.9 89/07/13 10:44:59 jhh Exp $ SPRITE (Berkeley)";
d219 1
a219 1
	Sys_GetMachineInfo(NULL, NULL, &spriteID);
@


1.9
log
@creates .fscheck.out
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/admin/fsmake/RCS/fsmake.c,v 1.8 89/06/16 08:46:10 brent Exp $ SPRITE (Berkeley)";
d23 11
d50 1
d87 2
d160 10
d258 8
a265 7
    ReturnStatus status;
    Disk_Info *diskInfoPtr;
    FsDomainHeader *headerPtr;
    FsSummaryInfo *summaryPtr;
    FsSummaryInfo *oldSummaryPtr;
    char answer[10];
    char block[DEV_BYTES_PER_SECTOR];
d276 39
a314 4
    status = Disk_SectorRead(partFID, diskInfoPtr->summarySector, 1, block);
    if (status != SUCCESS) {
	perror("Summary sector read failed");
	return status;
d316 14
a329 11
    oldSummaryPtr = (FsSummaryInfo *) block;
    if (!printOnly) {
	printf("\nYou are about to overwrite the \"%s\" filesystem.\n", 
	    oldSummaryPtr->domainPrefix);
	printf("Do you really want to do this?[y/n] ");
	if (scanf("%10s",answer) != 1) {
	    exit(SUCCESS);
	}
	if ((*answer != 'y') && (*answer != 'Y')) {
	    exit(SUCCESS);
	}
a330 1

d802 1
a1467 3
    int kbytesPerCyl;
    int bitmapBytesPerCyl;
    int index;
@


1.8
log
@Added a notion of SCSI formatting in order to
fully utilize SCSI disks.  Previously I was
throwing away lots of tracks in order to
do (unusable) fancy block skewing.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/admin/fsmake/RCS/fsmake.c,v 1.6 89/03/03 17:08:18 jhh Exp $ SPRITE (Berkeley)";
d79 6
d90 1
d96 1
a133 1
    char answer[10];
a148 9
    if (!printOnly) {
	printf("The \"-write\" option will cause fsmake to overwrite the current filesystem.\nDo you really want to do this?[y/n] ");
	if (scanf("%10s",answer) != 1) {
	    exit(SUCCESS);
	}
	if ((*answer != 'y') && (*answer != 'Y')) {
	    exit(SUCCESS);
	}
    }
d178 10
d238 3
d251 17
d859 3
d870 3
d952 2
d1244 61
d1349 6
d1421 3
a1423 29
    /*
     * The bitmap is organized by cylinder.  There are whole number of
     * bytes in the bitmap for each cylinder.  Each bit in the bitmap
     * corresponds to 1 kbyte on the disk.
     */
    kbytesPerCyl = headerPtr->geometry.blocksPerCylinder * DISK_KBYTES_PER_BLOCK;
    bitmapBytesPerCyl = (kbytesPerCyl - 1) / BITS_PER_BYTE + 1;
    if ((kbytesPerCyl % BITS_PER_BYTE) != 0) {
	/*
	 * There are bits in the last byte of the bitmap for each cylinder
	 * that don't have kbytes behind them.  Set those bits here so
	 * the blocks don't get allocated.
	 */
	register int extraBits;
	register int mask;

	extraBits = kbytesPerCyl % BITS_PER_BYTE;
	/*
	 * Set up a mask that has the right part filled with 1"s.
	 */
	mask = 0x0;
	for ( ; extraBits < BITS_PER_BYTE ; extraBits++) {
	    mask |= 1 << ((BITS_PER_BYTE - 1) - extraBits);
	}
	for (index = 0;
	     index < headerPtr->dataBlocks * DISK_KBYTES_PER_BLOCK / BITS_PER_BYTE;
	     index += bitmapBytesPerCyl) {
	    bitmap[index + bitmapBytesPerCyl - 1] |= mask;
	}
a1424 11
    /*
     * Set the bits in the bitmap that correspond to non-existent cylinders;
     * the bitmap is allocated a whole number of blocks on the disk
     * so there are bytes at its end that don't have blocks behind them.
     */
 
    for (index = headerPtr->dataCylinders * bitmapBytesPerCyl;
	 index < headerPtr->bitmapBlocks * FS_BLOCK_SIZE;
	 index++) {
	bitmap[index] = 0xff;
    }
d1494 17
a1510 1
    if (!makeFile) {
d1516 1
a1516 1
	fileName = "testFile";
d1518 1
a1518 1
	dirEntryPtr->fileNumber = FS_LOST_FOUND_FILE_NUMBER + 1;
d1523 1
d1548 5
@


1.7
log
@Eliminated the copySuperBlock option because you always want
to copy the super block.
@
text
@d2 1
a2 1
 * makeFilesystem.c --
d33 6
d57 4
d373 5
a377 1
    SetDiskGeometry(diskInfoPtr, geoPtr);
d380 108
@


1.6
log
@fills in attachSeconds, detachSeconds, and fixCount in summary sector
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/admin/fsmake/RCS/fsmake.c,v 1.5 89/01/26 11:02:18 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
a28 2
Boolean copySuperBlock = FALSE;	/* Copy the super block from the first
				 * disk partition to the one being formatted */
a54 2
    {OPT_TRUE, "copy", (Address)&copySuperBlock,
	"Copy the super block to the partition (FALSE)"},
d237 1
a237 1
	if (copySuperBlock && partition != 0) {
@


1.5
log
@root directory is now allocated all of block 0, rather than one fragment.
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/admin/fsmake/RCS/fsmake.c,v 1.4 89/01/25 13:39:46 jhh Exp Locker: jhh $ SPRITE (Berkeley)";
d737 3
@


1.4
log
@ported to new C library, fixed a few minor bugs 
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: /sprite/src/cmds.ancient/makeFilesystem/RCS/makeFilesystem.c,v 1.3 89/01/06 08:16:54 brent Exp $ SPRITE (Berkeley)";
d708 1
a708 1
     * 9 blocks are already allocated, one for the root directory,
d712 1
a712 1
				- 9;
d869 1
a869 1
    fileDescPtr->lastByte = FS_DIR_BLOCK_SIZE-1;
d900 1
a900 1
    fileDescPtr->numKbytes = 1;
d1188 1
a1188 1
     * Set the bit corresponding to the kbyte used for the root directory
d1195 1
a1195 1
    bitmap[0] |= 0x8f;
d1274 1
d1319 11
@


1.3
log
@Fixed include
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: makeFilesystem.c,v 1.2 88/03/31 10:09:00 brent Exp $ SPRITE (Berkeley)";
a15 1
#include "io.h"
d17 4
d49 1
a49 1
    {OPT_STRING, 'D', (Address)&deviceName,
d51 1
a51 1
    {OPT_STRING, 'P', (Address)&partName,
d53 1
a53 1
    {OPT_TRUE, 'f', (Address)&makeFile,
d55 3
a57 3
    {OPT_TRUE, 'O', (Address)&overlapBlocks,
	"Overlap filesystem blocks accross track boundaries (FALSE)"},
    {OPT_TRUE, 'c', (Address)&copySuperBlock,
d59 1
a59 1
    {OPT_INT, 'r', (Address)&kbytesToFileDesc,
d61 1
a61 1
    {OPT_TRUE, 't', (Address)&printOnly,
d63 1
a63 1
    {OPT_FALSE, 'W', (Address)&printOnly,
d65 1
a65 1
    {OPT_STRING, 'd', (Address)&devDirectory,
d67 1
a67 1
    {OPT_STRING, 'p', (Address)&firstPartName,
d120 1
d122 1
a122 1
    (void)Opt_Parse(&argc, argv, numOptions, optionArray);
d124 1
d126 1
a126 1
	Io_Print("Specify device name with -D option\n");
d130 1
a130 1
	Io_Print("Specify partition with -P option\n");
d134 1
a134 1
	Proc_Exit(status);
d136 9
a144 1

d149 6
a154 6
    String_Copy(devDirectory, firstPartitionName);	/* eg. /dev/ */
    String_Copy(devDirectory, partitionName);
    String_Cat(deviceName, firstPartitionName);		/* eg. /dev/rxy0 */
    String_Cat(deviceName, partitionName);
    String_Cat(firstPartName, firstPartitionName);	/* eg. /dev/rxy0a */
    String_Cat(partName, partitionName);		/* eg. /dev/rxy0b */
d156 5
a160 5
    status = Fs_Open(firstPartitionName, FS_READ, 0, &firstPartFID);
    if (status != SUCCESS) {
	Io_PrintStream(io_StdErr, "Can't open first partition \"%s\" <%x>\n",
				  firstPartitionName, status);
	Proc_Exit(status);
d162 4
a165 5
    status = Fs_Open(partitionName, FS_READ|FS_WRITE, 0, &partFID);
    if (status != SUCCESS) {
	Io_PrintStream(io_StdErr,"Can't open partition to format \"%s\" <%x>\n",
				  partitionName, status);
	Proc_Exit(status);
d170 1
a170 1
	Io_PrintStream(io_StdErr,
d172 1
a172 1
	Proc_Exit(FAILURE);
d182 1
a182 1
	Io_Print("Making filesystem for local host, ID = 0x%x\n", spriteID);
d185 1
a185 1
	Io_Print("Making filesystem for remote host 0x%x\n", spriteID);
d187 1
a187 1
    Io_Print("MakeFilesystem based on 4K filesystem blocks\n");
d190 5
a194 5
    Io_Flush(io_StdErr);
    Io_Flush(io_StdOut);
    (void)Fs_Close(firstPartFID);
    (void)Fs_Close(partFID);
    Proc_Exit(status);
d221 1
a221 2
    register int numBlocks;
    BasicDiskInfo *diskInfoPtr;
d229 3
a231 2
    diskInfoPtr = ReadBasicDiskInfo(firstPartFID, partition);
    if (diskInfoPtr == (BasicDiskInfo *)0) {
d235 2
a236 2
    headerPtr = (FsDomainHeader *) Mem_Alloc(diskInfoPtr->numDomainSectors *
					     DEV_BYTES_PER_SECTOR);
d238 1
a238 1
    PrintDomainHeader(headerPtr);
d244 1
a244 2
		Io_PrintStream(io_StdErr, "CopySuperBlock failed <%x>\n",
					  status);
d248 1
a248 1
	status = SectorWrite(partFID, diskInfoPtr->domainSector,
d251 1
a251 2
	    Io_PrintStream(io_StdErr, "DomainHeader write failed <%x>\n",
				      status);
d255 1
a255 1
    summaryPtr = (FsSummaryInfo *) Mem_Alloc(DEV_BYTES_PER_SECTOR);
d257 1
a257 1
    PrintSummaryInfo(summaryPtr);
d259 1
a259 1
	status = SectorWrite(partFID, diskInfoPtr->summarySector, 1,
d262 1
a262 2
	    Io_PrintStream(io_StdErr, "DomainHeader write failed <%x>\n",
				      status);
d269 1
a269 1
	Io_PrintStream(io_StdErr, "WriteFileDesc failed <%x>\n", status);
d274 1
a274 1
	Io_PrintStream(io_StdErr, "WriteBitmap failed <%x>\n", status);
d279 1
a279 1
	Io_PrintStream(io_StdErr, "WriteRootDirectory failed <%x>\n", status);
d284 1
a284 2
	Io_PrintStream(io_StdErr, "WriteLostFoundDirectory failed <%x>\n", 
			status);
d314 1
a314 1
    block = (char *)Mem_Alloc(DEV_BYTES_PER_SECTOR);
d316 1
a316 1
    status = SectorRead(firstPartFID, 0, 1, block);
d320 1
a320 1
    status = SectorWrite(partFID, 0, 1, block);
d342 1
a342 1
    BasicDiskInfo *diskInfoPtr;	/* Information from the super block */
a346 1
    ReturnStatus status;	/* General return code. */
d354 1
a354 1
     * the host's spriteID if reverse arp couldn't find a host ID.  The
d356 1
a356 1
     * domain header applies to.  For example, both the 'a' and 'c' partitions
d395 1
a395 1
    register BasicDiskInfo *diskInfoPtr;/* Basic geometry information */
d425 2
a426 2
	    extraSectors = geoPtr->sectorsPerTrack % SECTORS_PER_BLOCK;
	    if (extraSectors < SECTORS_PER_BLOCK/4) {
d434 2
a435 2
		offsetIncrement = SECTORS_PER_BLOCK/4;
	    } else if (extraSectors < SECTORS_PER_BLOCK/2) {
d441 2
a442 2
		offsetIncrement = SECTORS_PER_BLOCK * 3/4;
	    } else if (extraSectors < SECTORS_PER_BLOCK * 3/4) {
d448 1
a448 1
		offsetIncrement = SECTORS_PER_BLOCK/2;
d455 1
a455 1
		offsetIncrement = SECTORS_PER_BLOCK/4;
d467 3
a469 3
	    offsetIncrement = SECTORS_PER_BLOCK/2;
	    if ((geoPtr->sectorsPerTrack % SECTORS_PER_BLOCK) <
		      SECTORS_PER_BLOCK/2) {
d480 1
a480 1
    Io_Print("overlap %s, offsetIncrement %d\n", (overlap ? "TRUE" : "FALSE"),
d489 1
a489 1
	if (extraSectors >= SECTORS_PER_BLOCK) {
d495 2
a496 2
	    offset += SECTORS_PER_BLOCK;
	    extraSectors -= SECTORS_PER_BLOCK;
d553 1
a553 1
    offsetIncrement = SECTORS_PER_BLOCK / tracksPerSet;
d582 1
a582 1
    register BasicDiskInfo *diskInfoPtr;
a593 1
    int index;			/* Array index */
d607 1
a607 1
    Io_Print("Reserving %d blocks for domain header, etc.\n",
d620 1
a620 1
	    numFiles = numBlocks * KBYTES_PER_BLOCK / kbytesToFileDesc;
d622 1
a622 1
	numFiles		  &= ~(FILE_DESC_PER_BLOCK-1);
d633 2
a634 2
	numBlocks		  -= numFiles / FILE_DESC_PER_BLOCK;
	offset			  += numFiles / FILE_DESC_PER_BLOCK;
d645 1
a645 1
	bitmapBytes		  = (headerPtr->dataBlocks * KBYTES_PER_BLOCK -
d662 1
a662 1
	    numFiles -= numBlocksNeeded * FILE_DESC_PER_BLOCK;
d673 1
a673 1
	    numFiles += extraBlocks * FILE_DESC_PER_BLOCK;
d699 1
a699 1
    BasicDiskInfo *diskInfoPtr;	/* Information from the super block */
a702 1
    ReturnStatus status;	/* General return code. */
d704 1
a704 1
    Byte_Zero(DEV_BYTES_PER_SECTOR, (Address)summaryPtr);
d706 1
a706 1
    String_Copy("(new domain)", summaryPtr->domainPrefix);
d727 1
a727 1
     * recorded on disk so servers re-attach disks under the same 'name'.
d734 1
a734 1
     * safely 'sync'ed to disk upon shutdown.
d767 1
a767 1
	status = BlockWrite(partFID, headerPtr, headerPtr->fdBitmapOffset,
d779 2
a780 2
    block = (char *)Mem_Alloc(FS_BLOCK_SIZE);
    Byte_Zero(FS_BLOCK_SIZE, block);
d782 1
a782 1
         index < FILE_DESC_PER_BLOCK;
d806 1
a806 1
	status = BlockWrite(partFID, headerPtr, headerPtr->fileDescOffset,
d814 1
a814 1
	Byte_Zero(FS_BLOCK_SIZE, block);
d816 1
a816 1
	     index < FILE_DESC_PER_BLOCK;
d826 1
a826 1
	for (index = FILE_DESC_PER_BLOCK;
d828 3
a830 3
	     index += FILE_DESC_PER_BLOCK) {
	    status = BlockWrite(partFID, headerPtr,
		     headerPtr->fileDescOffset + (index/FILE_DESC_PER_BLOCK),
a1102 1
    ReturnStatus status;
d1107 1
a1107 1
     * Allocate and initialize the bitmap to all 0's to mean all free.
d1109 1
a1109 1
    bitmap = (char *)Mem_Alloc(headerPtr->fdBitmapBlocks *
d1111 1
a1111 1
    Byte_Zero(headerPtr->fdBitmapBlocks * FS_BLOCK_SIZE, (Address)bitmap);
d1152 1
a1152 1
	PrintFileDescBitmap(headerPtr, bitmap);
d1185 2
a1186 2
    bitmap = (char *)Mem_Alloc(headerPtr->bitmapBlocks * FS_BLOCK_SIZE);
    Byte_Zero(headerPtr->bitmapBlocks * FS_BLOCK_SIZE, bitmap);
d1202 1
a1202 1
    kbytesPerCyl = headerPtr->geometry.blocksPerCylinder * KBYTES_PER_BLOCK;
d1215 1
a1215 1
	 * Set up a mask that has the right part filled with 1's.
d1222 1
a1222 1
	     index < headerPtr->dataBlocks * KBYTES_PER_BLOCK / BITS_PER_BYTE;
d1239 1
a1239 1
	PrintDataBlockBitmap(headerPtr, bitmap);
d1242 1
a1242 1
	status = BlockWrite(partFID, headerPtr, headerPtr->bitmapOffset,
d1259 1
a1259 1
 *	Write the root directory's data block.
d1275 1
a1275 1
    block = (char *)Mem_Alloc(FS_BLOCK_SIZE);
d1279 1
a1279 1
    length = String_Length(fileName);
d1283 1
a1283 1
    String_Copy(fileName, dirEntryPtr->fileName);
d1288 1
a1288 1
    length = String_Length(fileName);
d1292 1
a1292 1
    String_Copy(fileName, dirEntryPtr->fileName);
d1301 1
a1301 1
    length = String_Length(fileName);
d1304 1
a1304 1
    String_Copy(fileName, dirEntryPtr->fileName);
d1313 1
a1313 1
	length = String_Length(fileName);
d1316 1
a1316 1
	String_Copy(fileName, dirEntryPtr->fileName);
d1321 1
a1321 1
	Io_Print("Root Directory\n");
d1324 1
a1324 1
	PrintDirEntry(dirEntryPtr);
d1327 4
a1330 1
	PrintDirEntry(dirEntryPtr);
d1334 1
a1334 1
	    PrintDirEntry(dirEntryPtr);
d1343 1
a1343 1
	status = BlockWrite(partFID, headerPtr, headerPtr->dataOffset, 1,
d1360 1
a1360 1
 *	Write the root directory's data block.
d1377 1
a1377 1
    block = (char *)Mem_Alloc(FS_NUM_LOST_FOUND_BLOCKS * FS_BLOCK_SIZE);
d1381 1
a1381 1
    length = String_Length(fileName);
d1385 1
a1385 1
    String_Copy(fileName, dirEntryPtr->fileName);
d1390 1
a1390 1
    length = String_Length(fileName);
d1394 1
a1394 1
    String_Copy(fileName, dirEntryPtr->fileName);
d1408 1
a1408 1
	Io_Print("Lost+found Directory\n");
d1411 1
a1411 1
	PrintDirEntry(dirEntryPtr);
d1414 1
a1414 1
	PrintDirEntry(dirEntryPtr);
d1417 1
a1417 1
	status = BlockWrite(partFID, headerPtr, headerPtr->dataOffset + 1,
@


1.2
log
@Added bad block file descriptor and summary sector
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: makeFilesystem.c,v 1.1 87/10/20 11:01:23 brent Exp $ SPRITE (Berkeley)";
d17 1
a17 1
#include "fsDisk.h"
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: makeFilesystem.c,v 1.7 87/07/14 11:43:34 brent Exp $ SPRITE (Berkeley)";
d77 1
d225 1
a225 1
    SetDomainHeader(diskInfoPtr, headerPtr, spriteID);
d333 1
a333 1
SetDomainHeader(diskInfoPtr, headerPtr, spriteID)
d337 1
d346 7
a352 3
     * Only the device.serverID from the disk is used.  It is examined
     * during boot to discover the host's spriteID if reverse arp
     * couldn't find a host ID.
d356 1
a356 1
    headerPtr->device.unit = -1;
d717 1
a717 1
     * The summary state is unused.
d720 12
d769 4
a772 1
     * Make the first block of file descriptors.
d782 1
a782 1
	if (index < ROOT_FILE_NUMBER) {
d784 3
a786 1
	} else if (index == ROOT_FILE_NUMBER) {
d902 61
d1112 1
a1112 1
     * File number 2 (ROOT_FILE_NUMBER) is the root directory of the domain.
d1276 1
a1276 1
    dirEntryPtr->fileNumber = ROOT_FILE_NUMBER;
d1285 1
a1285 1
    dirEntryPtr->fileNumber = ROOT_FILE_NUMBER;
@
