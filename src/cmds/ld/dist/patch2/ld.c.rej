***************
*** 27,37 ****
  #include <fcntl.h>
  #endif
  
  #ifdef COFF_ENCAPSULATE
  #include "a.out.encap.h"
  #else
  #include <a.out.h>
  #endif
  
  #ifndef N_SET_MAGIC
  #define N_SET_MAGIC(exec, val)  ((exec).a_magic = val)
--- 27,170 ----
  #include <fcntl.h>
  #endif
  
+ #define NO_C_PLUS_PLUS
+ 
+ #define TARGET_SUN2             2
+ #define TARGET_SUN3             3
+ #define TARGET_SUN4             4
+ #define TARGET_ALTOS            5
+ #define TARGET_I386             6   
+ #define TARGET_HPUX             7
+ #define TARGET_SONY_NEWS        8
+ #define TARGET_SEQUENT          9
+ #define TARGET_VAX              10
+ 
+ /*
+  * If `TARGET_MACHINE' was not defined on the compiler command line,
+  * then set it equal to the host machine.
+  */
+ #ifndef TARGET_MACHINE
+ #if defined(sun) && defined(sparc)
+ #define TARGET_MACHINE  TARGET_SUN4
+ #endif
+ #if defined(sun) && (defined(m68020) || defined(mc68020))
+ #define TARGET_MACHINE  TARGET_SUN3
+ #endif
+ #if defined(sun) && (defined(m68010) || defined(mc68010))
+ #define TARGET_MACHINE  TARGET_SUN2
+ #endif
+ #if defined(ALTOS)
+ #define TARGET_MACHINE  TARGET_ALTOS
+ #endif
+ #if defined(hpux)
+ #define TARGET_MACHINE  TARGET_HPUX
+ #endif
+ #if defined(is386)
+ #define TARGET_MACHINE  TARGET_I386
+ #endif
+ #if defined(sony_news)
+ #define TARGET_MACHINE  TARGET_SONY_NEWS
+ #endif
+ #if defined(sequent)
+ #define TARGET_MACHINE  TARGET_SEQUENT
+ #endif
+ #if defined(is68k) && !defined(TARGET_MACHINE)
+ #define TARGET_MACHINE  TARGET_68K
+ #endif
+ #endif
+ 
+ #ifndef TARGET_MACHINE
+     CANNOT COMPILE, NO TARGET MACHINE SPECIFIED
+ #endif
+ 
+ #ifndef BIG_ENDIAN
+ #define BIG_ENDIAN      4321
+ #endif
+ #ifndef LITTLE_ENDIAN
+ #define LITTLE_ENDIAN   1234
+ #endif
+ #ifndef PDP_ENDIAN
+ /* I think it is unlikely that anybody will try to cross compile
+  * to or from a pdp, so only big-endian and little-endian are supported. */
+ #define PDP_ENDIAN   3412
+ #endif
+ 
+ #if TARGET_MACHINE==TARGET_SUN4         || \
+     TARGET_MACHINE==TARGET_SUN3         || \
+     TARGET_MACHINE==TARGET_SUN2         || \
+     TARGET_MACHINE==TARGET_ALTOS        || \
+     TARGET_MACHINE==TARGET_HPUX         || \
+     TARGET_MACHINE==TARGET_SONY_NEWS    || \
+     TARGET_MACHINE==TARGET_68K
+ #define TARGET_BYTE_ORDER       BIG_ENDIAN
+ #endif
+ 
+ #if TARGET_MACHINE==TARGET_VAX          || \
+     TARGET_MACHINE==TARGET_I386         || \
+     TARGET_MACHINE==TARGET_SEQUENT
+ #define TARGET_BYTE_ORDER       LITTLE_ENDIAN
+ #endif
+ 
+ #if TARGET_MACHINE==TARGET_SUN3
+ #define TARGET_PAGE_SIZE    0x2000
+ #endif
+ 
+ #if defined(sparc)      || \
+     defined(m68000)     || \
+     defined(mc68000)    || \
+     defined(m68010)     || \
+     defined(mc68010)    || \
+     defined(m68020)     || \
+     defined(mc68020)    || \
+     defined(is68k)      || \
+     defined(hpux)       || \
+     defined(sony_news)
+ #define HOST_BYTE_ORDER     BIG_ENDIAN
+ #endif
+ 
+ #if defined(vax)        || \
+     defined(is386)      || \
+     defined(ds3100)     || \
+     defined(sequent)
+ #define HOST_BYTE_ORDER     LITTLE_ENDIAN
+ #endif
+ 
+ #if HOST_BYTE_ORDER != TARGET_BYTE_ORDER
+ static void fix_byte_order();
+ static void fix_exec_header_byte_order();
+ static void fix_symbol_byte_order();
+ static void target_to_host_reloc_byte_order();
+ static void host_to_target_reloc_byte_order();
+ static void fix_symbol_root_byte_order();
+ #endif
+ 
  #ifdef COFF_ENCAPSULATE
  #include "a.out.encap.h"
  #else
+ #ifdef sprite
+ #if TARGET_MACHINE==TARGET_SUN4
+ #include <sun4.md/a.out.h>
+ #elif TARGET_MACHINE==TARGET_SUN3
+ #include <sun3.md/a.out.h>
+ #elif TARGET_MACHINE==TARGET_SEQUENT
+ #include <symm.md/a.out.h>
+ #else
+     no a.out.h specified
+ #endif
+ #else
  #include <a.out.h>
  #endif
+ #endif
+ 
+ #ifdef sprite
+ #undef NEW_SEG_SIZE
+ #if TARGET_MACHINE==TARGET_SUN4
+ #define NEW_SEG_SIZE    0x40000
+ #endif
+ #if TARGET_MACHINE==TARGET_SUN3
+ #define NEW_SEG_SIZE    0x20000
+ #endif
+ #endif  /* sprite */
  
  #ifndef N_SET_MAGIC
  #define N_SET_MAGIC(exec, val)  ((exec).a_magic = val)
***************
*** 85,91 ****
  
  /* Define this to specify the default executable format.  */
  
! #ifdef hpux
  #define DEFAULT_MAGIC NMAGIC  /* hpux bugs screw ZMAGIC */
  #endif
  
--- 218,224 ----
  
  /* Define this to specify the default executable format.  */
  
! #if TARGET_MACHINE==TARGET_HPUX
  #define DEFAULT_MAGIC NMAGIC  /* hpux bugs screw ZMAGIC */
  #endif
  
***************
*** 96,125 ****
  /* Ordinary 4.3bsd lacks these macros in a.out.h.  */
  
  #ifndef N_TXTADDR
! #if defined(vax) || defined(sony_news)
  #define N_TXTADDR(X) 0
  #endif
! #ifdef is68k
  #define N_TXTADDR(x)  (sizeof (struct exec))
  #endif
! #ifdef sequent
  #define	N_TXTADDR(x) (N_ADDRADJ(x))
  #endif
  #endif
  
  #ifndef N_DATADDR
! #if defined(vax) || defined(sony_news)
  #define N_DATADDR(x) \
  	(((x).a_magic==OMAGIC)? (N_TXTADDR(x)+(x).a_text) \
  	: (page_size+((N_TXTADDR(x)+(x).a_text-1) & ~(page_size-1))))
  #endif
! #ifdef is68k
  #define SEGMENT_SIZE 0x20000
  #define N_DATADDR(x) \
!     (((x).a_magic==Omagic)? (N_TXTADDR(x)+(x).a_text) \
       : (SEGMENT_SIZE + ((N_TXTADDR(x)+(x).a_text-1) & ~(SEGMENT_SIZE-1))))
  #endif
! #ifdef sequent
  #define N_DATADDR(x) \
  	(((x).a_magic==OMAGIC)? (N_TXTADDR(x)+(x).a_text) \
  	: (page_size+(((x).a_text-1) & ~(page_size-1))))
--- 229,258 ----
  /* Ordinary 4.3bsd lacks these macros in a.out.h.  */
  
  #ifndef N_TXTADDR
! #if TARGET_MACHINE==TARGET_VAX || TARGET_MACHINE==TARGET_SONY_NEWS
  #define N_TXTADDR(X) 0
  #endif
! #if TARGET_MACHINE==TARGET_SUN3 || TARGET_MACHINE==TARGET_SUN2
  #define N_TXTADDR(x)  (sizeof (struct exec))
  #endif
! #if TARGET_MACHINE==TARGET_SEQUENT
  #define	N_TXTADDR(x) (N_ADDRADJ(x))
  #endif
  #endif
  
  #ifndef N_DATADDR
! #if TARGET_MACHINE==TARGET_VAX || TARGET_MACHINE==TARGET_SONY_NEWS
  #define N_DATADDR(x) \
  	(((x).a_magic==OMAGIC)? (N_TXTADDR(x)+(x).a_text) \
  	: (page_size+((N_TXTADDR(x)+(x).a_text-1) & ~(page_size-1))))
  #endif
! #if TARGET_MACHINE==TARGET_SUN3 || TARGET_MACHINE==TARGET_SUN2
  #define SEGMENT_SIZE 0x20000
  #define N_DATADDR(x) \
!     (((x).a_magic==OMAGIC)? (N_TXTADDR(x)+(x).a_text) \
       : (SEGMENT_SIZE + ((N_TXTADDR(x)+(x).a_text-1) & ~(SEGMENT_SIZE-1))))
  #endif
! #if TARGET_MACHINE==TARGET_SEQUENT
  #define N_DATADDR(x) \
  	(((x).a_magic==OMAGIC)? (N_TXTADDR(x)+(x).a_text) \
  	: (page_size+(((x).a_text-1) & ~(page_size-1))))
***************
*** 127,168 ****
  #endif
  
  /* Define how to initialize system-dependent header fields.  */
! #ifdef sun
! #ifdef sparc
  #define INITIALIZE_HEADER \
    {outheader.a_machtype = M_SPARC; outheader.a_toolversion = 1;}
  #endif
! #if defined(mc68010) || defined(m68010)
  #define INITIALIZE_HEADER outheader.a_machtype = M_68010
  #endif
! #ifndef INITIALIZE_HEADER
  #define INITIALIZE_HEADER outheader.a_machtype = M_68020
  #endif
! #endif
! #ifdef ALTOS
  #define INITIALIZE_HEADER N_SET_MACHTYPE (outheader, M_68020)
  #endif
! #ifdef is68k
! #ifdef M_68020
! /* ISI rel 4.0D doesn't use it, and rel 3.05 doesn't have an
!    a_machtype field and so won't recognize the magic number.  To keep
!    binary compatibility for now, just ignore it */
! #define INITIALIZE_HEADER outheader.a_machtype = 0;
! #endif
! #endif
! #ifdef hpux
  #define INITIALIZE_HEADER N_SET_MACHTYPE (outheader, HP9000S200_ID)
  #endif
! #if defined(i386) && !defined(sequent)
  #define INITIALIZE_HEADER N_SET_MACHTYPE (outheader, M_386)
  #endif
! 
! #ifdef is68k
  /* This enables code to take care of an ugly hack in the ISI OS.
     If a symbol beings with _$, then the object file is included only
     if the rest of the symbol name has been referenced. */
  #define DOLLAR_KLUDGE
  #endif
  
  /*
   * Alloca include.
--- 260,312 ----
  #endif
  
  /* Define how to initialize system-dependent header fields.  */
! #if TARGET_MACHINE==TARGET_SUN4
  #define INITIALIZE_HEADER \
    {outheader.a_machtype = M_SPARC; outheader.a_toolversion = 1;}
  #endif
! #if TARGET_MACHINE==TARGET_SUN2
  #define INITIALIZE_HEADER outheader.a_machtype = M_68010
  #endif
! #if TARGET_MACHINE==TARGET_SUN3
  #define INITIALIZE_HEADER outheader.a_machtype = M_68020
  #endif
! #if TARGET_MACHINE==TARGET_ALTOS
  #define INITIALIZE_HEADER N_SET_MACHTYPE (outheader, M_68020)
  #endif
! #if TARGET_MACHINE==TARGET_HPUX
  #define INITIALIZE_HEADER N_SET_MACHTYPE (outheader, HP9000S200_ID)
  #endif
! #if TARGET_MACHINE==TARGET_I386
  #define INITIALIZE_HEADER N_SET_MACHTYPE (outheader, M_386)
  #endif
! #if TARGET_MACHINE==TARGET_68K
! #define INITIALIZE_HEADER outheader.a_machtype = 0;  
  /* This enables code to take care of an ugly hack in the ISI OS.
     If a symbol beings with _$, then the object file is included only
     if the rest of the symbol name has been referenced. */
  #define DOLLAR_KLUDGE
  #endif
+ #if TARGET==TARGET_SEQUENT
+ /* This is all stuff needed to make standalone binaries */
+ static struct gdtbl gdt_filler = {
+ 	{ 0x0000FFFF, 0x00CF9A00 },	/* code entry */
+ 	{ 0x0000FFFF, 0x00CF9200 },	/* data entry */
+ 	{ 0x00180017, 0x00000000 },	/* 6 byte descriptor */
+ };
+ 
+ static char instr[] = {
+ 	0x67, 0x66, 0x0f, 0x01, 0x15, 0x30, 0x00, 0x00, 0x00,
+ 	0x0f, 0x20, 0xc3,
+ 	0x80, 0xcb, 0x01,
+ 	0x0f, 0x22, 0xc3,
+ 	0xea, 0x5b, 0x00, 0x08, 0x00,
+ 	0xbb, 0x10, 0x00, 0x00, 0x00,
+ 	0x8e, 0xdb,
+ 	0x8e, 0xd3,
+ 	0x8e, 0xc3,
+ 	0xff, 0x25, 0x6c, 0x00, 0x00, 0x00,
+ 	0x00, 0x00, 0x00, 0x00, };
+ #endif   
  
  /*
   * Alloca include.
***************
*** 319,330 ****
  #define RELOC_MEMORY_SUB_P(r)		0
  #define RELOC_MEMORY_ADD_P(r)           0
  #define RELOC_ADD_EXTRA(r)              ((r)->r_addend)       
! #define RELOC_PCREL_P(r)             \
!         ((r)->r_type >= RELOC_DISP8 && (r)->r_type <= RELOC_WDISP22)
! #define RELOC_VALUE_RIGHTSHIFT(r)       (reloc_target_rightshift[(r)->r_type])
! #define RELOC_TARGET_SIZE(r)            (reloc_target_size[(r)->r_type])
  #define RELOC_TARGET_BITPOS(r)          0
! #define RELOC_TARGET_BITSIZE(r)         (reloc_target_bitsize[(r)->r_type])
  
  /* Note that these are very dependent on the order of the enums in
     enum reloc_type (in a.out.h); if they change the following must be
--- 463,477 ----
  #define RELOC_MEMORY_SUB_P(r)		0
  #define RELOC_MEMORY_ADD_P(r)           0
  #define RELOC_ADD_EXTRA(r)              ((r)->r_addend)       
! #define RELOC_PCREL_P(r)                \
!     ((int) (r)->r_type >= (int) RELOC_DISP8 && \
!      (int) (r)->r_type <= (int) RELOC_WDISP22)
! #define RELOC_VALUE_RIGHTSHIFT(r) \
! 	(reloc_target_rightshift[(int) (r)->r_type])
! #define RELOC_TARGET_SIZE(r)            (reloc_target_size[(int) (r)->r_type])
  #define RELOC_TARGET_BITPOS(r)          0
! #define RELOC_TARGET_BITSIZE(r) \
! 	(reloc_target_bitsize[(int) (r)->r_type])
  
  /* Note that these are very dependent on the order of the enums in
     enum reloc_type (in a.out.h); if they change the following must be
***************
*** 813,818 ****
     and reduce the size of the bss section to match.  */
  int specified_data_size;
  
  /* Magic number to use for the output file, set by switch.  */
  int magic;
  
--- 974,985 ----
     and reduce the size of the bss section to match.  */
  int specified_data_size;
  
+ /* Gap to insert between end of bss and start of data seg */
+ int data_gap;
+ 
+ /* Nonzero if -Z was specified (for data_gap) */
+ int Z_flag_specified;
+ 
  /* Magic number to use for the output file, set by switch.  */
  int magic;
  
***************
*** 905,921 ****
  char *concat ();
  char *get_file_name ();
  symbol *getsym (), *getsym_soft ();
! 
  int
  main (argc, argv)
       char **argv;
       int argc;
  {
    page_size = getpagesize ();
    progname = argv[0];
  
    /* Clear the cumulative info on the output file.  */
- 
    text_size = 0;
    data_size = 0;
    bss_size = 0;
--- 1072,1105 ----
  char *concat ();
  char *get_file_name ();
  symbol *getsym (), *getsym_soft ();
! 
  int
  main (argc, argv)
       char **argv;
       int argc;
  {
+ /*   Added this to stop ld core-dumping on very large .o files.    */
+ #ifdef RLIMIT_STACK
+   /* Get rid of any avoidable limit on stack size.  */
+   {
+       struct rlimit rlim;
+ 
+       /* Set the stack limit huge so that alloca does not fail. */
+       getrlimit (RLIMIT_STACK, &rlim);
+       rlim.rlim_cur = rlim.rlim_max;
+       setrlimit (RLIMIT_STACK, &rlim);
+   }
+ #endif /* RLIMIT_STACK */
+ 
+ #ifdef TARGET_PAGE_SIZE
+   page_size = TARGET_PAGE_SIZE;
+ #else
    page_size = getpagesize ();
+ #endif
+ 
    progname = argv[0];
  
    /* Clear the cumulative info on the output file.  */
    text_size = 0;
    data_size = 0;
    bss_size = 0;
***************
*** 994,999 ****
  
    text_size -= N_TXTOFF (outheader);
  
    if (text_size < 0)
      text_size = 0;
    entry_offset = text_size;
--- 1179,1187 ----
  
    text_size -= N_TXTOFF (outheader);
  
+   if (T_flag_specified)
+       text_size = 0;	/* don't add sizeof(exec) at -T location */
+ 
    if (text_size < 0)
      text_size = 0;
    entry_offset = text_size;
***************
*** 1056,1061 ****
      case 'u':
      case 'V':
      case 'y':
        if (arg[2])
  	return 1;
        return 2;
--- 1244,1250 ----
      case 'u':
      case 'V':
      case 'y':
+     case 'Z':
        if (arg[2])
  	return 1;
        return 2;
***************
*** 1072,1077 ****
        if (! strcmp (&arg[2], "data"))
  	return 2;
        return 1;
      }
  
    return 1;
--- 1261,1275 ----
        if (! strcmp (&arg[2], "data"))
  	return 2;
        return 1;
+ 
+ #if TARGET==TARGET_SEQUENT      
+       /* k == Symmetry standalone,
+        * p == don't align text/data boundary (for 8K disk bootstraps).
+        */
+    case 'k':
+    case 'p':
+        return 1;
+ #endif       
      }
  
    return 1;
***************
*** 1168,1180 ****
  
    /* Now check some option settings for consistency.  */
  
  #ifdef NMAGIC
    if ((magic == ZMAGIC || magic == NMAGIC)
  #else
!   if ((magic == ZMAGIC)
  #endif
        && (text_start - text_start_alignment) & (page_size - 1))
      fatal ("-T argument not multiple of page size, with sharable output", 0);
  
    /* Append the standard search directories to the user-specified ones.  */
    {
--- 1366,1384 ----
  
    /* Now check some option settings for consistency.  */
  
+ #ifndef sprite
  #ifdef NMAGIC
    if ((magic == ZMAGIC || magic == NMAGIC)
  #else
! #ifdef SMAGIC
!     if ((magic == SMAGIC || magic == ZMAGIC)
! #else
!     if ((magic == ZMAGIC)
! #endif /* SMAGIC */
  #endif
        && (text_start - text_start_alignment) & (page_size - 1))
      fatal ("-T argument not multiple of page size, with sharable output", 0);
+ #endif
  
    /* Append the standard search directories to the user-specified ones.  */
    {
***************
*** 1250,1255 ****
      return;
    if (! strcmp (swt + 1, "Ttext"))
      {
        text_start = parse (arg, "%x", "invalid argument to -Ttext");
        T_flag_specified = 1;
        return;
--- 1454,1462 ----
      return;
    if (! strcmp (swt + 1, "Ttext"))
      {
+ #ifdef sprite 
+       magic = OMAGIC;
+ #endif
        text_start = parse (arg, "%x", "invalid argument to -Ttext");
        T_flag_specified = 1;
        return;
***************
*** 1290,1296 ****
        add_cmdline_ref (entry_symbol);
        return;
  
      case 'l':
        return;
  
      case 'L':
--- 1497,1518 ----
        add_cmdline_ref (entry_symbol);
        return;
  
+ #if TARGET==TARGET_SEQUENT
+     case 'k':
+ #ifdef SMAGIC
+       magic = SMAGIC;
+ #else
+       fatal("No SMAGIC defined for -k");
+ #endif
+       return;
+ #endif
+ 
      case 'l':
+ #ifndef NO_C_PLUS_PLUS
+       /* If linking with libg++, use the C++ demangler. */
+       if (arg != NULL && strcmp (arg, "g++") == 0)
+ 	  demangler = cplus_demangle;
+ #endif /* NO_C_PLUS_PLUS */
        return;
  
      case 'L':
***************
*** 1333,1338 ****
        return;
  
      case 'T':
        text_start = parse (arg, "%x", "invalid argument to -T");
        T_flag_specified = 1;
        return;
--- 1555,1563 ----
        return;
  
      case 'T':
+ #ifdef sprite
+       magic = OMAGIC;
+ #endif      
        text_start = parse (arg, "%x", "invalid argument to -T");
        T_flag_specified = 1;
        return;
***************
*** 4288,4294 ****
  
     FUNCTION receives two arguments: the entry, and ARG.  It must be a
     function returning unsigned long (though this can probably be fudged). */
! 
  unsigned long
  check_each_file (function, arg)
       register unsigned long (*function)();
--- 4520,4526 ----
  
     FUNCTION receives two arguments: the entry, and ARG.  It must be a
     function returning unsigned long (though this can probably be fudged). */
! #if 0
  unsigned long
  check_each_file (function, arg)
       register unsigned long (*function)();
***************
*** 1493,1499 ****
  
    if (entry->search_dirs_flag)
      {
-       register char **p = search_dirs;
        int i;
  
        for (i = 0; i < n_search_dirs; i++)
--- 1726,1731 ----
  
    if (entry->search_dirs_flag)
      {
        int i;
  
        for (i = 0; i < n_search_dirs; i++)
***************
*** 1593,1598 ****
    len = read (desc, loc, sizeof (struct exec));
    if (len != sizeof (struct exec))
      fatal_with_file ("failure reading header of ", entry);
    if (N_BADMAG (*loc))
      fatal_with_file ("bad magic number in ", entry);
  
--- 1825,1833 ----
    len = read (desc, loc, sizeof (struct exec));
    if (len != sizeof (struct exec))
      fatal_with_file ("failure reading header of ", entry);
+ #if HOST_BYTE_ORDER != TARGET_BYTE_ORDER
+   fix_exec_header_byte_order(loc);
+ #endif
    if (N_BADMAG (*loc))
      fatal_with_file ("bad magic number in ", entry);
  
***************
*** 1619,1629 ****
    lseek (desc, N_SYMOFF (entry->header) + entry->starting_offset, 0);
    if (entry->header.a_syms != read (desc, entry->symbols, entry->header.a_syms))
      fatal_with_file ("premature end of file in symbols of ", entry);
! 
    lseek (desc, N_STROFF (entry->header) + entry->starting_offset, 0);
    if (sizeof str_size != read (desc, &str_size, sizeof str_size))
      fatal_with_file ("bad string table size in ", entry);
! 
    entry->string_size = str_size;
  }
  
--- 1854,1868 ----
    lseek (desc, N_SYMOFF (entry->header) + entry->starting_offset, 0);
    if (entry->header.a_syms != read (desc, entry->symbols, entry->header.a_syms))
      fatal_with_file ("premature end of file in symbols of ", entry);
! #if HOST_BYTE_ORDER != TARGET_BYTE_ORDER
!   fix_symbol_byte_order(entry->symbols, entry->header.a_syms);
! #endif
    lseek (desc, N_STROFF (entry->header) + entry->starting_offset, 0);
    if (sizeof str_size != read (desc, &str_size, sizeof str_size))
      fatal_with_file ("bad string table size in ", entry);
! #if HOST_BYTE_ORDER != TARGET_BYTE_ORDER
!   fix_byte_order(&str_size, sizeof(str_size));
! #endif
    entry->string_size = str_size;
  }
  
***************
*** 1703,1709 ****
    len = read (desc, &hdr, sizeof hdr);
    if (len != sizeof hdr)
      fatal_with_file ("failure reading header of ", entry);
! 
    if (!N_BADMAG (hdr))
      {
        read_entry_symbols (desc, entry);
--- 1942,1950 ----
    len = read (desc, &hdr, sizeof hdr);
    if (len != sizeof hdr)
      fatal_with_file ("failure reading header of ", entry);
! #if HOST_BYTE_ORDER != TARGET_BYTE_ORDER
!   fix_exec_header_byte_order(&hdr);
! #endif
    if (!N_BADMAG (hdr))
      {
        read_entry_symbols (desc, entry);
***************
*** 1735,1741 ****
    register struct nlist
      *p,
      *end = entry->symbols + entry->header.a_syms / sizeof (struct nlist);
-   int lowest_set_vector = -1;
  
    if (trace_files) prline_file_name (entry, stderr);
  
--- 1976,1981 ----
    register struct nlist
      *p,
      *end = entry->symbols + entry->header.a_syms / sizeof (struct nlist);
  
    if (trace_files) prline_file_name (entry, stderr);
  
***************
*** 2179,2185 ****
     all such structs that refer to the same global symbol.
     This chain starts in the `refs' field of the symbol table entry
     and is chained through the `n_name'.  */
- 
  void
  enter_global_ref (nlist_p, name, entry)
       register struct nlist *nlist_p;
--- 2418,2423 ----
     all such structs that refer to the same global symbol.
     This chain starts in the `refs' field of the symbol table entry
     and is chained through the `n_name'.  */
  void
  enter_global_ref (nlist_p, name, entry)
       register struct nlist *nlist_p;
***************
*** 2232,2239 ****
  	{
  	  /* Indirect symbols value should be modified to point
  	     a symbol being equivalenced to. */
! 	  nlist_p->n_value
! 	    = (unsigned int) getsym ((nlist_p + 1)->n_un.n_strx
  				     + entry->strings);
  	  if ((symbol *) nlist_p->n_value == sp)
  	    {
--- 2470,2477 ----
  	{
  	  /* Indirect symbols value should be modified to point
  	     a symbol being equivalenced to. */
! 	  nlist_p->n_value =
! 	    (unsigned int) getsym ((nlist_p + 1)->n_un.n_strx
  				     + entry->strings);
  	  if ((symbol *) nlist_p->n_value == sp)
  	    {
***************
*** 2703,2709 ****
  	 potentially want it.  */
        if (type & N_EXT
  	  && (type != (N_UNDF | N_EXT) || p->n_value
! 	      
  #ifdef DOLLAR_KLUDGE
  	       || name[1] == '$'
  #endif
--- 2955,2961 ----
  	 potentially want it.  */
        if (type & N_EXT
  	  && (type != (N_UNDF | N_EXT) || p->n_value
! 
  #ifdef DOLLAR_KLUDGE
  	       || name[1] == '$'
  #endif
***************
*** 2435,2443 ****
  
  #ifdef NMAGIC
    if (magic == ZMAGIC || magic == NMAGIC)
! #else
    if (magic == ZMAGIC)
! #endif
      {
        int text_end = text_size + N_TXTOFF (outheader);
        text_pad = ((text_end + page_size - 1) & (- page_size)) - text_end;
--- 2712,2724 ----
  
  #ifdef NMAGIC
    if (magic == ZMAGIC || magic == NMAGIC)
! #else /* NMAGIC */
! #ifdef SMAGIC
!   if (magic == ZMAGIC || magic == SMAGIC)
! #else /* SMAGIC */
    if (magic == ZMAGIC)
! #endif /* SMAGIC */
! #endif /* NMAGIC */
      {
        int text_end = text_size + N_TXTOFF (outheader);
        text_pad = ((text_end + page_size - 1) & (- page_size)) - text_end;
***************
*** 3776,3785 ****
  
    if (! Tdata_flag_specified)
      data_start = N_DATADDR (outheader) + text_start - N_TXTADDR (outheader);
! 
    /* Make sure bss starts out aligned as much as anyone can want.  */
  
    data_size = (data_size + sizeof(double) - 1) & ~(sizeof(double)-1);
  
    /* Set up the set element vector */
  
--- 4057,4070 ----
  
    if (! Tdata_flag_specified)
      data_start = N_DATADDR (outheader) + text_start - N_TXTADDR (outheader);
! #ifdef foobar
    /* Make sure bss starts out aligned as much as anyone can want.  */
  
    data_size = (data_size + sizeof(double) - 1) & ~(sizeof(double)-1);
+ #endif
+ 
+   if (Z_flag_specified)
+       data_start += data_gap;
  
    /* Set up the set element vector */
  
***************
*** 3789,3800 ****
           for each symbol for the length word at the beginning of the
  	 vector, plus a word for each symbol for a zero at the end of
  	 the vector (for incremental linking).  */
!       set_sect_size
! 	= (2 * set_symbol_count + set_vector_count) * sizeof (unsigned long);
        set_sect_start = data_start + data_size;
        data_size += set_sect_size;
        set_vectors = (unsigned long *) xmalloc (set_sect_size);
        setv_fill_count = 0;
      }
  
    /* Compute start addresses of each file's sections and symbols.  */
--- 4074,4087 ----
           for each symbol for the length word at the beginning of the
  	 vector, plus a word for each symbol for a zero at the end of
  	 the vector (for incremental linking).  */
!       set_sect_size =
!         (2 * set_symbol_count + set_vector_count) * sizeof (unsigned long);
        set_sect_start = data_start + data_size;
        data_size += set_sect_size;
        set_vectors = (unsigned long *) xmalloc (set_sect_size);
+ #if 1
        setv_fill_count = 0;
+ #endif      
      }
  
    /* Compute start addresses of each file's sections and symbols.  */
***************
*** 3819,3825 ****
  	{
  	  /* For each symbol */
  	  register struct nlist *p, *next;
! 	  int defs = 0, com = sp->max_common_size, erred = 0;
  	  struct nlist *first_definition;
  	  for (p = sp->refs; p; p = next)
  	    {
--- 4106,4112 ----
  	{
  	  /* For each symbol */
  	  register struct nlist *p, *next;
! 	  int defs = 0, com = sp->max_common_size;
  	  struct nlist *first_definition;
  	  for (p = sp->refs; p; p = next)
  	    {
***************
*** 3901,3913 ****
  	     Reverse the vector itself to put it in file order.  */
  	  if ((sp->defined & ~N_EXT) == N_SETV)
  	    {
! 	      unsigned long length_word_index
! 		= (sp->value - set_sect_start) / sizeof (unsigned long);
  	      unsigned long i, tmp;
  
! 	      set_vectors[length_word_index]
! 		= setv_fill_count - 1 - length_word_index;
! 
  	      /* Reverse the vector.  */
  	      for (i = 1;
  		   i < (setv_fill_count - length_word_index - 1) / 2 + 1;
--- 4188,4199 ----
  	     Reverse the vector itself to put it in file order.  */
  	  if ((sp->defined & ~N_EXT) == N_SETV)
  	    {
! 	      unsigned long length_word_index =
! 	        (sp->value - set_sect_start) / sizeof (unsigned long);
  	      unsigned long i, tmp;
  
! 	      set_vectors[length_word_index] =
! 	        setv_fill_count - 1 - length_word_index;
  	      /* Reverse the vector.  */
  	      for (i = 1;
  		   i < (setv_fill_count - length_word_index - 1) / 2 + 1;
***************
*** 3914,3921 ****
  		   i++)
  		{
  		  tmp = set_vectors[length_word_index + i];
! 		  set_vectors[length_word_index + i]
! 		    = set_vectors[setv_fill_count - i];
  		  set_vectors[setv_fill_count - i] = tmp;
  		}
  
--- 4200,4207 ----
  		   i++)
  		{
  		  tmp = set_vectors[length_word_index + i];
! 		  set_vectors[length_word_index + i] =
! 		    set_vectors[setv_fill_count - i];
  		  set_vectors[setv_fill_count - i] = tmp;
  		}
  
***************
*** 3926,3934 ****
  	}
      }
  
    /* Make sure end of bss is aligned as much as anyone can want.  */
  
    bss_size = (bss_size + sizeof(double) - 1) & ~(sizeof(double)-1);
  
    if (end_symbol)		/* These are null if -r.  */
      {
--- 4212,4222 ----
  	}
      }
  
+ #ifdef foobar
    /* Make sure end of bss is aligned as much as anyone can want.  */
  
    bss_size = (bss_size + sizeof(double) - 1) & ~(sizeof(double)-1);
+ #endif
  
    if (end_symbol)		/* These are null if -r.  */
      {
***************
*** 3942,3950 ****
    if (specified_data_size && specified_data_size > data_size)
      data_pad = specified_data_size - data_size;
  
    if (magic == ZMAGIC)
      data_pad = ((data_pad + data_size + page_size - 1) & (- page_size))
!                - data_size;
  
    bss_size -= data_pad;
    if (bss_size < 0) bss_size = 0;
--- 4230,4242 ----
    if (specified_data_size && specified_data_size > data_size)
      data_pad = specified_data_size - data_size;
  
+ #ifdef SMAGIC
+   if (magic == SMAGIC || magic == ZMAGIC)
+ #else
    if (magic == ZMAGIC)
+ #endif
      data_pad = ((data_pad + data_size + page_size - 1) & (- page_size))
! 	- data_size;
  
    bss_size -= data_pad;
    if (bss_size < 0) bss_size = 0;
***************
*** 4114,4120 ****
  {
    int line;
    char *filename;
!   struct nlist *sym;
  };
  
  void qsort ();
--- 4406,4412 ----
  {
    int line;
    char *filename;
!   struct nlist *Sym;
  };
  
  void qsort ();
***************
*** 4150,4176 ****
      *next = state_pointer + 1,
      /* Used to store source file */
      *source = state_pointer + 2;
!   struct file_entry *entry = (struct file_entry *) source->sym;
  
!   current->sym = next->sym;
    current->line = next->line;
    current->filename = next->filename;
  
!   while (++(next->sym) < (entry->symbols
  			  + entry->header.a_syms/sizeof (struct nlist)))
      {
        /* n_type is a char, and N_SOL, N_EINCL and N_BINCL are > 0x80, so
         * may look negative...therefore, must mask to low bits
         */
!       switch (next->sym->n_type & 0xff) 
  	{
  	case N_SLINE:
  	  if (use_data_symbols) continue;
! 	  next->line = next->sym->n_desc;
  	  return 1;
  	case N_DSLINE:
  	  if (!use_data_symbols) continue;
! 	  next->line = next->sym->n_desc;
  	  return 1;
  #ifdef HAVE_SUN_STABS
  	case N_EINCL:
--- 4442,4468 ----
      *next = state_pointer + 1,
      /* Used to store source file */
      *source = state_pointer + 2;
!   struct file_entry *entry = (struct file_entry *) source->Sym;
  
!   current->Sym = next->Sym;
    current->line = next->line;
    current->filename = next->filename;
  
!   while (++(next->Sym) < (entry->symbols
  			  + entry->header.a_syms/sizeof (struct nlist)))
      {
        /* n_type is a char, and N_SOL, N_EINCL and N_BINCL are > 0x80, so
         * may look negative...therefore, must mask to low bits
         */
!       switch (next->Sym->n_type & 0xff) 
  	{
  	case N_SLINE:
  	  if (use_data_symbols) continue;
! 	  next->line = next->Sym->n_desc;
  	  return 1;
  	case N_DSLINE:
  	  if (!use_data_symbols) continue;
! 	  next->line = next->Sym->n_desc;
  	  return 1;
  #ifdef HAVE_SUN_STABS
  	case N_EINCL:
***************
*** 4178,4196 ****
  	  continue;
  #endif
  	case N_SO:
! 	  source->filename = next->sym->n_un.n_strx + entry->strings;
  	  source->line++;
  #ifdef HAVE_SUN_STABS
  	case N_BINCL:
  #endif
  	case N_SOL:
! 	  next->filename
! 	    = next->sym->n_un.n_strx + entry->strings;
  	default:
  	  continue;
  	}
      }
!   next->sym = (struct nlist *) 0;
    return 0;
  }
  
--- 4470,4488 ----
  	  continue;
  #endif
  	case N_SO:
! 	  source->filename = next->Sym->n_un.n_strx + entry->strings;
  	  source->line++;
  #ifdef HAVE_SUN_STABS
  	case N_BINCL:
  #endif
  	case N_SOL:
! 	  next->filename =
! 	    next->Sym->n_un.n_strx + entry->strings;
  	default:
  	  continue;
  	}
      }
!   next->Sym = (struct nlist *) 0;
    return 0;
  }
  
***************
*** 4205,4213 ****
       struct file_entry *entry;
  {
    struct line_debug_entry
!     *state_pointer
!       = (struct line_debug_entry *)
! 	xmalloc (3 * sizeof (struct line_debug_entry));
    register struct line_debug_entry
      *current = state_pointer,
      *next = state_pointer + 1,
--- 4497,4505 ----
       struct file_entry *entry;
  {
    struct line_debug_entry
!     *state_pointer =
!         (struct line_debug_entry *)
! 	    xmalloc (3 * sizeof (struct line_debug_entry));
    register struct line_debug_entry
      *current = state_pointer,
      *next = state_pointer + 1,
***************
*** 4228,4234 ****
        /* I believe this translates to "We lose" */
        current->filename = next->filename = entry->filename;
        current->line = next->line = -1;
!       current->sym = next->sym = (struct nlist *) 0;
        return state_pointer;
      }
  
--- 4520,4526 ----
        /* I believe this translates to "We lose" */
        current->filename = next->filename = entry->filename;
        current->line = next->line = -1;
!       current->Sym = next->Sym = (struct nlist *) 0;
        return state_pointer;
      }
  
***************
*** 4235,4246 ****
    next->line = source->line = 0;
    next->filename = source->filename
      = (tmp->n_un.n_strx + entry->strings);
!   source->sym = (struct nlist *) entry;
!   next->sym = tmp;
  
    next_debug_entry (use_data_symbols, state_pointer); /* To setup next */
  
!   if (!next->sym)		/* No line numbers for this section; */
  				/* setup output results as appropriate */
      {
        if (source->line)
--- 4527,4538 ----
    next->line = source->line = 0;
    next->filename = source->filename
      = (tmp->n_un.n_strx + entry->strings);
!   source->Sym = (struct nlist *) entry;
!   next->Sym = tmp;
  
    next_debug_entry (use_data_symbols, state_pointer); /* To setup next */
  
!   if (!next->Sym)		/* No line numbers for this section; */
  				/* setup output results as appropriate */
      {
        if (source->line)
***************
*** 4280,4296 ****
  
    int use_data_symbols;
  
!   if (next->sym)
!     use_data_symbols = (next->sym->n_type & N_TYPE) == N_DATA;
    else
      return current->line;
  
    /* Go back to the beginning if we've already passed it.  */
!   if (current->sym->n_value > address)
      {
        tmp_pointer = init_debug_scan (use_data_symbols,
  				     (struct file_entry *)
! 				     ((state_pointer + 2)->sym));
        state_pointer[0] = tmp_pointer[0];
        state_pointer[1] = tmp_pointer[1];
        state_pointer[2] = tmp_pointer[2];
--- 4572,4588 ----
  
    int use_data_symbols;
  
!   if (next->Sym)
!     use_data_symbols = (next->Sym->n_type & N_TYPE) == N_DATA;
    else
      return current->line;
  
    /* Go back to the beginning if we've already passed it.  */
!   if (current->Sym->n_value > address)
      {
        tmp_pointer = init_debug_scan (use_data_symbols,
  				     (struct file_entry *)
! 				     ((state_pointer + 2)->Sym));
        state_pointer[0] = tmp_pointer[0];
        state_pointer[1] = tmp_pointer[1];
        state_pointer[2] = tmp_pointer[2];
***************
*** 4298,4308 ****
      }
  
    /* If we're still in a bad way, return -1, meaning invalid line.  */
!   if (current->sym->n_value > address)
      return -1;
  
!   while (next->sym
! 	 && next->sym->n_value <= address
  	 && next_debug_entry (use_data_symbols, state_pointer))
      ;
    return current->line;
--- 4590,4600 ----
      }
  
    /* If we're still in a bad way, return -1, meaning invalid line.  */
!   if (current->Sym->n_value > address)
      return -1;
  
!   while (next->Sym
! 	 && next->Sym->n_value <= address
  	 && next_debug_entry (use_data_symbols, state_pointer))
      ;
    return current->line;
***************
*** 4332,4349 ****
    struct relocation_info
      *reloc_start = data_segment ? entry->datarel : entry->textrel,
      *reloc;
!   int reloc_size
!     = ((data_segment ? entry->header.a_drsize : entry->header.a_trsize)
!        / sizeof (struct relocation_info));
!   int start_of_segment
!     = (data_segment ? entry->data_start_address : entry->text_start_address);
    struct nlist *start_of_syms = entry->symbols;
!   struct line_debug_entry *state_pointer
!     = init_debug_scan (data_segment != 0, entry);
    register struct line_debug_entry
!     *current = state_pointer,
!     *next = state_pointer + 1,
!     *source = state_pointer + 2;
    /* Assigned to generally static values; should not be written into.  */
    char *errfmt;
    /* Assigned to alloca'd values cand copied into; should be freed
--- 4624,4639 ----
    struct relocation_info
      *reloc_start = data_segment ? entry->datarel : entry->textrel,
      *reloc;
!   int reloc_size =
!     (data_segment ? entry->header.a_drsize : entry->header.a_trsize)
!        / sizeof (struct relocation_info);
!   int start_of_segment =
!     (data_segment ? entry->data_start_address : entry->text_start_address);
    struct nlist *start_of_syms = entry->symbols;
!   struct line_debug_entry *state_pointer =
!     init_debug_scan (data_segment != 0, entry);
    register struct line_debug_entry
!     *current = state_pointer;
    /* Assigned to generally static values; should not be written into.  */
    char *errfmt;
    /* Assigned to alloca'd values cand copied into; should be freed
***************
*** 4421,4428 ****
        /* If errfmt == 0, errmsg has already been defined.  */
        if (errfmt != 0)
  	{
! 	  errmsg = (char *) xmalloc (strlen (errfmt) + strlen (g->name) + 1);
! 	  sprintf (errmsg, errfmt, g->name, data_segment ? "data" : "text");
  	}
  
        address_to_line (RELOC_ADDRESS (reloc) + start_of_segment,
--- 4711,4724 ----
        /* If errfmt == 0, errmsg has already been defined.  */
        if (errfmt != 0)
  	{
! 	  char *nm;
! 
! 	  if (demangler == NULL || (nm = (*demangler)(g->name)) == NULL)
! 	    nm = g->name;
! 	  errmsg = (char *) xmalloc (strlen (errfmt) + strlen (nm) + 1);
! 	  sprintf (errmsg, errfmt, nm, data_segment ? "data" : "text");
! 	  if (nm != g->name)
! 	    free (nm);
  	}
  
        address_to_line (RELOC_ADDRESS (reloc) + start_of_segment,
***************
*** 4451,4458 ****
       FILE *outfile;
  {
    int number_of_syms = entry->header.a_syms / sizeof (struct nlist);
!   unsigned char *nlist_bitvector
!     = (unsigned char *) alloca ((number_of_syms >> 3) + 1);
    struct line_debug_entry *text_scan, *data_scan;
    int i;
    char *errfmt, *file_name;
--- 4747,4754 ----
       FILE *outfile;
  {
    int number_of_syms = entry->header.a_syms / sizeof (struct nlist);
!   unsigned char *nlist_bitvector =
!     (unsigned char *) alloca ((number_of_syms >> 3) + 1);
    struct line_debug_entry *text_scan, *data_scan;
    int i;
    char *errfmt, *file_name;
***************
*** 4530,4536 ****
  	{
  	  if (g->undef_refs >= MAX_UREFS_PRINTED)
  	    continue;
! 	  
  	  if (++(g->undef_refs) == MAX_UREFS_PRINTED)
  	    errfmt = "More undefined \"%s\" refs follow";
  	  else
--- 4826,4832 ----
  	{
  	  if (g->undef_refs >= MAX_UREFS_PRINTED)
  	    continue;
! 
  	  if (++(g->undef_refs) == MAX_UREFS_PRINTED)
  	    errfmt = "More undefined \"%s\" refs follow";
  	  else
***************
*** 4553,4559 ****
  	}
        else
  	continue;
!       
        if (line_number == -1)
  	fprintf (outfile, "%s: ", entry->filename);
        else
--- 4849,4855 ----
  	}
        else
  	continue;
! 
        if (line_number == -1)
  	fprintf (outfile, "%s: ", entry->filename);
        else
***************
*** 4560,4568 ****
  	fprintf (outfile, "%s:%d: ", file_name, line_number);
  
        if (dont_allow_symbol_name)
! 	fprintf (outfile, "%s", errfmt);
        else
! 	fprintf (outfile, errfmt, g->name);
  
        fputc ('\n', outfile);
      }
--- 4856,4872 ----
  	fprintf (outfile, "%s:%d: ", file_name, line_number);
  
        if (dont_allow_symbol_name)
! 	  fprintf (outfile, "%s", errfmt);
        else
!       {
! 	char *nm;
! 	if (demangler != NULL && (nm = (*demangler)(g->name)) != NULL)
! 	  {
! 	    fprintf (outfile, errfmt, nm);
! 	    free (nm);
! 	  } else
! 	    fprintf (outfile, errfmt, g->name);
!       }
  
        fputc ('\n', outfile);
      }
***************
*** 4587,4593 ****
      return;
  
    each_file (do_file_warnings, outfile);
! 
    if (list_unresolved_refs || list_multiple_defs)
      make_executable = 0;
  }
--- 4891,4899 ----
      return;
  
    each_file (do_file_warnings, outfile);
!   if (trace_files)
! 	  printf("undefined_global_sym_count= %d, multiple_def_count= %d\n",
! 		 undefined_global_sym_count, multiple_def_count);
    if (list_unresolved_refs || list_multiple_defs)
      make_executable = 0;
  }
***************
*** 4640,4647 ****
  {
    N_SET_MAGIC (outheader, magic);
    outheader.a_text = text_size;
! #ifdef sequent
    outheader.a_text += N_ADDRADJ (outheader);
  #endif
    outheader.a_data = data_size;
    outheader.a_bss = bss_size;
--- 4946,4957 ----
  {
    N_SET_MAGIC (outheader, magic);
    outheader.a_text = text_size;
!   if (T_flag_specified)
!       outheader.a_text += text_start;
! #if TARGET_MACHINE==TARGET_SEQUENT
    outheader.a_text += N_ADDRADJ (outheader);
+   if (entry_symbol == 0)
+       entry_symbol = getsym("start");
  #endif
    outheader.a_data = data_size;
    outheader.a_bss = bss_size;
***************
*** 4709,4715 ****
        coffheader.data_start = dp->s_vaddr;
      }
  #endif
  
  #ifdef INITIALIZE_HEADER
    INITIALIZE_HEADER;
  #endif
--- 5019,5043 ----
        coffheader.data_start = dp->s_vaddr;
      }
  #endif
+ #if TARGET==TARGET_SEQUENT
+     if (SMAGIC == magic) {
+ 	char *target_ptr; 
+ 	long n; 
  
+ 	outheader.a_gdtbl = gdt_filler; 
+ 	if (sizeof(instr) > sizeof(outheader.a_bootstrap)) {
+ 	    fatal("a_bootstrap too small for code"); 
+ 	} 
+ 	n = outheader.a_entry; 
+ 	target_ptr = &instr[sizeof(instr) - 4];
+ 	target_ptr[0] = n & 0xff; 
+ 	target_ptr[1] = (n >> 8) & 0xff; 
+ 	target_ptr[2] = (n >> 16) & 0xff; 
+ 	target_ptr[3] = (n >> 24) & 0xff; 
+ 	bcopy(instr, (char *)outheader.a_bootstrap, sizeof(instr)); 
+     }
+ #endif
+ 
  #ifdef INITIALIZE_HEADER
    INITIALIZE_HEADER;
  #endif
***************
*** 4749,4755 ****
    if (need_coff_header)
      mywrite (&coffheader, sizeof coffheader, 1, outdesc);
  #endif
    mywrite (&outheader, sizeof (struct exec), 1, outdesc);
  
    /* Output whatever padding is required in the executable file
       between the header and the start of the text.  */
--- 5077,5089 ----
    if (need_coff_header)
      mywrite (&coffheader, sizeof coffheader, 1, outdesc);
  #endif
+ #if HOST_BYTE_ORDER != TARGET_BYTE_ORDER
+   fix_exec_header_byte_order(&outheader);
+ #endif
    mywrite (&outheader, sizeof (struct exec), 1, outdesc);
+ #if HOST_BYTE_ORDER != TARGET_BYTE_ORDER
+   fix_exec_header_byte_order(&outheader);
+ #endif
  
    /* Output whatever padding is required in the executable file
       between the header and the start of the text.  */
***************
*** 4748,4753 ****
  	     L_SET);
        if (entry->header.a_drsize != read (desc, reloc, entry->header.a_drsize))
  	fatal_with_file ("premature eof in data relocation of ", entry);
        entry->datarel = reloc;
      }
  }
--- 5091,5100 ----
  	     L_SET);
        if (entry->header.a_drsize != read (desc, reloc, entry->header.a_drsize))
  	fatal_with_file ("premature eof in data relocation of ", entry);
+ #if HOST_BYTE_ORDER != TARGET_BYTE_ORDER
+       target_to_host_reloc_byte_order(reloc,
+ 	entry->header.a_drsize/sizeof(*reloc));
+ #endif
        entry->datarel = reloc;
      }
  }
***************
*** 4784,4792 ****
    else
      {
        reloc = (struct relocation_info *) alloca (entry->header.a_trsize);
        lseek (desc, text_offset (entry) + entry->header.a_text + entry->header.a_data, 0);
        if (entry->header.a_trsize != read (desc, reloc, entry->header.a_trsize))
  	fatal_with_file ("premature eof in text relocation of ", entry);
      }
  
    /* Read the text section into core.  */
--- 5131,5148 ----
    else
      {
        reloc = (struct relocation_info *) alloca (entry->header.a_trsize);
+       if (trace_files)
+ 	      printf("lseek to 0x%x (t_o= 0x%x, a_t= 0x%x, a_d= 0x%x)\n",
+ 		     text_offset(entry) + entry->header.a_text +
+ 		     entry->header.a_data, text_offset(entry),
+ 		     entry->header.a_text, entry->header.a_data);
        lseek (desc, text_offset (entry) + entry->header.a_text + entry->header.a_data, 0);
        if (entry->header.a_trsize != read (desc, reloc, entry->header.a_trsize))
  	fatal_with_file ("premature eof in text relocation of ", entry);
+ #if HOST_BYTE_ORDER != TARGET_BYTE_ORDER
+       target_to_host_reloc_byte_order(reloc,
+ 	  entry->header.a_trsize/sizeof(*reloc));
+ #endif
      }
  
    /* Read the text section into core.  */
***************
*** 3511,3516 ****
  	     0);
        if (entry->header.a_drsize != read (desc, reloc, entry->header.a_drsize))
  	fatal_with_file ("premature eof in data relocation of ", entry);
      }
  
    lseek (desc, text_offset (entry) + entry->header.a_text, 0);
--- 3876,3885 ----
  	     0);
        if (entry->header.a_drsize != read (desc, reloc, entry->header.a_drsize))
  	fatal_with_file ("premature eof in data relocation of ", entry);
+ #if HOST_BYTE_ORDER != TARGET_BYTE_ORDER
+       target_to_host_reloc_byte_order(reloc,
+ 	  entry->header.a_drsize/sizeof(*reloc));
+ #endif
      }
  
    lseek (desc, text_offset (entry) + entry->header.a_text, 0);
***************
*** 3661,3681 ****
  	  break;
  
  	case 1:
  	  if (RELOC_MEMORY_SUB_P(p))
! 	    relocation -= mask & *(short *) (data + addr);
  	  else if (RELOC_MEMORY_ADD_P(p))
! 	    relocation += mask & *(short *) (data + addr);
! 	  *(short *) (data + addr) &= ~mask;
! 	  *(short *) (data + addr) |= relocation;
  	  break;
  
  	case 2:
! 	  if (RELOC_MEMORY_SUB_P(p))
! 	    relocation -= mask & *(long *) (data + addr);
  	  else if (RELOC_MEMORY_ADD_P(p))
! 	    relocation += mask & *(long *) (data + addr);
! 	  *(long *) (data + addr) &= ~mask;
! 	  *(long *) (data + addr) |= relocation;
  	  break;
  
  	default:
--- 4036,4096 ----
  	  break;
  
  	case 1:
+ #if TARGET_BYTE_ORDER==BIG_ENDIAN
+ 	  x = ((unsigned char *) (data + addr))[1]
+ 	   | (((unsigned char *) (data + addr))[0] << 8);
+ #endif
+ #if TARGET_BYTE_ORDER==LITTLE_ENDIAN
+ 	  x = ((unsigned char *) (data + addr))[0]
+ 	   | (((unsigned char *) (data + addr))[1] << 8);
+ #endif
  	  if (RELOC_MEMORY_SUB_P(p))
! 	    relocation -= mask & x;
  	  else if (RELOC_MEMORY_ADD_P(p))
! 	    relocation += mask & x;
! 	  x &= ~mask;
! 	  x |= relocation;
! #if TARGET_BYTE_ORDER==BIG_ENDIAN
! 	  ((unsigned char *) (data + addr))[1] = x;
! 	  ((unsigned char *) (data + addr))[0] = x >> 8;
! #endif
! #if TARGET_BYTE_ORDER==LITTLE_ENDIAN
! 	  ((unsigned char *) (data + addr))[0] = x;
! 	  ((unsigned char *) (data + addr))[1] = x >> 8;
! #endif
  	  break;
  
  	case 2:
! #if TARGET_BYTE_ORDER==BIG_ENDIAN
! 	  x = ((unsigned char *) (data + addr))[3]
! 	   | (((unsigned char *) (data + addr))[2] << 8)
! 	   | (((unsigned char *) (data + addr))[1] << 16)
! 	   | (((unsigned char *) (data + addr))[0] << 24);
! #endif
! #if TARGET_BYTE_ORDER==LITTLE_ENDIAN
! 	  x = ((unsigned char *) (data + addr))[0]
! 	   | (((unsigned char *) (data + addr))[1] << 8)
! 	   | (((unsigned char *) (data + addr))[2] << 16)
! 	   | (((unsigned char *) (data + addr))[3] << 24);
! #endif
! 		  if (RELOC_MEMORY_SUB_P(p))
! 	    relocation -= mask & x;
  	  else if (RELOC_MEMORY_ADD_P(p))
! 	    relocation += mask & x;
! 	  x &= ~mask;
! 	  x |= relocation;
! #if TARGET_BYTE_ORDER==BIG_ENDIAN
! 	  ((unsigned char *) (data + addr))[3] = x;
! 	  ((unsigned char *) (data + addr))[2] = x >> 8;
! 	  ((unsigned char *) (data + addr))[1] = x >> 16;
! 	  ((unsigned char *) (data + addr))[0] = x >> 24;
! #endif
! #if TARGET_BYTE_ORDER==LITTLE_ENDIAN
! 	  ((unsigned char *) (data + addr))[0] = x;
! 	  ((unsigned char *) (data + addr))[1] = x >> 8;
! 	  ((unsigned char *) (data + addr))[2] = x >> 16;
! 	  ((unsigned char *) (data + addr))[3] = x >> 24;
! #endif
  	  break;
  
  	default:
***************
*** 3790,3795 ****
  	}
        p++;
      }
    mywrite (entry->textrel, 1, entry->header.a_trsize, outdesc);
  }
  
--- 4205,4214 ----
  	}
        p++;
      }
+ #if HOST_BYTE_ORDER != TARGET_BYTE_ORDER
+     host_to_target_reloc_byte_order((struct relocation_info *) entry->textrel,
+ 	entry->header.a_trsize/sizeof(struct relocation_info));
+ #endif
    mywrite (entry->textrel, 1, entry->header.a_trsize, outdesc);
  }
  
***************
*** 3849,3854 ****
  	}
        p++;
      }
    mywrite (entry->datarel, 1, entry->header.a_drsize, outdesc);
  }
  
--- 4268,4277 ----
  	}
        p++;
      }
+ #if HOST_BYTE_ORDER != TARGET_BYTE_ORDER
+     host_to_target_reloc_byte_order((struct relocation_info *) entry->datarel,
+ 	entry->header.a_drsize/sizeof(struct relocation_info));
+ #endif
    mywrite (entry->datarel, 1, entry->header.a_drsize, outdesc);
  }
  
***************
*** 4056,4061 ****
    /* Output the buffer full of `struct nlist's.  */
  
    lseek (outdesc, symbol_table_offset + symbol_table_len, 0);
    mywrite (buf, sizeof (struct nlist), bufp - buf, outdesc);
    symbol_table_len += sizeof (struct nlist) * (bufp - buf);
  
--- 4479,4496 ----
    /* Output the buffer full of `struct nlist's.  */
  
    lseek (outdesc, symbol_table_offset + symbol_table_len, 0);
+ #if HOST_BYTE_ORDER != TARGET_BYTE_ORDER
+   {
+     int i;
+ 
+     for (i = 0; i < bufp - buf; ++i)
+       {
+         fix_byte_order(&buf[i].n_un.n_name, sizeof(buf->n_un.n_name));
+ 	fix_byte_order(&buf[i].n_desc, sizeof(buf->n_desc));
+ 	fix_byte_order(&buf[i].n_value, sizeof(buf->n_value));
+       }
+   }
+ #endif
    mywrite (buf, sizeof (struct nlist), bufp - buf, outdesc);
    symbol_table_len += sizeof (struct nlist) * (bufp - buf);
  
***************
*** 4068,4073 ****
    /* Now the total string table size is known, so write it.
       We are already positioned at the right place in the file.  */
  
    mywrite (&strtab_size, sizeof (int), 1, outdesc);  /* we're at right place */
  
    /* Write the strings for the global symbols.  */
--- 4503,4512 ----
    /* Now the total string table size is known, so write it.
       We are already positioned at the right place in the file.  */
  
+ #if HOST_BYTE_ORDER != TARGET_BYTE_ORDER
+   fix_byte_order(&strtab_size, sizeof(strtab_size));
+ #endif
+ 
    mywrite (&strtab_size, sizeof (int), 1, outdesc);  /* we're at right place */
  
    /* Write the strings for the global symbols.  */
***************
*** 5595,5600 ****
    /* All the symbols are now in BUF; write them.  */
  
    lseek (outdesc, symbol_table_offset + symbol_table_len, 0);
    mywrite (buf, sizeof (struct nlist), bufp - buf, outdesc);
    symbol_table_len += sizeof (struct nlist) * (bufp - buf);
  
--- 6038,6055 ----
    /* All the symbols are now in BUF; write them.  */
  
    lseek (outdesc, symbol_table_offset + symbol_table_len, 0);
+ #if HOST_BYTE_ORDER != TARGET_BYTE_ORDER
+   {
+     int i;
+ 
+     for (i = 0; i < bufp - buf; ++i)
+       {
+ 	fix_byte_order(&buf[i].n_un.n_name, sizeof(buf->n_un.n_name));
+ 	fix_byte_order(&buf[i].n_desc, sizeof(buf->n_desc));
+ 	fix_byte_order(&buf[i].n_value, sizeof(buf->n_value));
+       }
+   }
+ #endif
    mywrite (buf, sizeof (struct nlist), bufp - buf, outdesc);
    symbol_table_len += sizeof (struct nlist) * (bufp - buf);
  
