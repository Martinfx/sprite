Info file bfd.info, produced by Makeinfo, -*- Text -*- from input
file bfd.texinfo.

   This file documents the BFD library.

   Copyright (C) 1991 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, subject to the
terms of the GNU General Public License, which includes the provision
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.



File: bfd.info,  Node: Relocations,  Next: BFD back end,  Prev: BFD front end,  Up: Top

Relocations
===========

   BFD maintains relocations in much the same was as it maintains
symbols; they are left alone until required, then read in en-mass and
traslated into an internal form. There is a common routine
`bfd_perform_relocation' which acts upon the canonical form to to the
actual fixup.

   Note that relocations are maintained on a per section basis,
whilst symbols are maintained on a per BFD basis.

   All a back end has to do to fit the BFD interface is to create as
many `struct reloc_cache_entry' as there are relocations in a
particuar section, and fill in the right bits:

* Menu:

* typedef arelent::
* reloc handling functions::

`bfd_perform_relocation'
........................

   The relocation routine returns as a status an enumerated type:

     typedef enum bfd_reloc_status {

   No errors detected

       bfd_reloc_ok,

   The relocation was performed, but there was an overflow.

       bfd_reloc_overflow,

   The address to relocate was not within the section supplied

       bfd_reloc_outofrange,

   Used by special functions

       bfd_reloc_continue,

   Unused

       bfd_reloc_notsupported,

   Unsupported relocation size requested.

       bfd_reloc_other,

   The symbol to relocate against was undefined.

       bfd_reloc_undefined,

   The relocation was performed, but may not be ok - presently
generated only when linking i960 coff files with i960 b.out symbols.

       bfd_reloc_dangerous
        }
      bfd_reloc_status_enum_type;

     typedef struct reloc_cache_entry 
     {

   A pointer into the canonical table of pointers

       struct symbol_cache_entry **sym_ptr_ptr;

   offset in section

       rawdata_offset address;

   addend for relocation value

       bfd_vma addend;

   if sym is null this is the section

       struct sec *section;

   Pointer to how to perform the required relocation

       CONST struct reloc_howto_struct *howto;
     } arelent;

`sym_ptr_ptr'
     The symbol table pointer points to a pointer to the symbol
     ascociated with the relocation request. This would naturaly be
     the pointer into the table returned by the back end's get_symtab
     action. *Note Symbols::. The symbol is referenced through a
     pointer to a pointer so that tools like the linker can fixup all
     the symbols of the same name by modifying only one pointer. The
     relocation routine looks in the symbol and uses the base of the
     section the symbol is attached to and the value of the symbol as
     the initial relocation offset. If the symbol pointer is zero,
     then the section provided is looked up.

`address'
     The address field gives the offset in bytes from the base of the
     section data which owns the relocation record to the first byte
     of relocatable information. The actual data relocated will be
     relative to this point - for example, a relocation type which
     modifies the bottom two bytes of a four byte word would not
     touch the first byte pointed to in a big endian world.

`addend'
     The addend is a value provided by the back end to be added (!)
     to the relocation offset. It's interpretation is dependent upon
     the howto.  For example, on the 68k the code:

                  char foo[];
                  main()
                          {
                          return foo[0x12345678];
                          }

     Could be compiled into:

                  linkw fp,#-4
                  moveb @#12345678,d0
                  extbl d0
                  unlk fp
                  rts

     This could create a reloc pointing to foo, but leave the offset
     in the data (something like)

          RELOCATION RECORDS FOR [.text]:
          OFFSET   TYPE      VALUE 
          00000006 32        _foo
          
          00000000 4e56 fffc          ; linkw fp,#-4
          00000004 1039 1234 5678     ; moveb @#12345678,d0
          0000000a 49c0               ; extbl d0
          0000000c 4e5e               ; unlk fp
          0000000e 4e75               ; rts

     Using coff and an 88k, some instructions don't have enough space
     in them to represent the full address range, and pointers have
     to be loaded in two parts. So you'd get something like:

                  or.u     r13,r0,hi16(_foo+0x12345678)
                  ld.b     r2,r13,lo16(_foo+0x12345678)
                  jmp      r1

     This whould create two relocs, both pointing to _foo, and with
     0x12340000 in their addend field. The data would consist of:


                    RELOCATION RECORDS FOR [.text]:
          OFFSET   TYPE      VALUE 
          00000002 HVRT16    _foo+0x12340000
          00000006 LVRT16    _foo+0x12340000
          
          00000000 5da05678           ; or.u r13,r0,0x5678
          00000004 1c4d5678           ; ld.b r2,r13,0x5678
          00000008 f400c001           ; jmp r1

     The relocation routine digs out the value from the data, adds it
     to the addend to get the original offset and then adds the value
     of _foo.  Note that all 32 bits have to be kept around
     somewhere, to cope with carry from bit 15 to bit 16.

     On further example is the sparc and the a.out format. The sparc
     has a similar problem to the 88k, in that some instructions
     don't have room for an entire offset, but on the sparc the parts
     are created odd sized lumps. The designers of the a.out format
     chose not to use the data within the section for storing part of
     the offset; all the offset is kept within the reloc. Any thing
     in the data should be ignored.

                  save %sp,-112,%sp
                  sethi %hi(_foo+0x12345678),%g2
                  ldsb [%g2+%lo(_foo+0x12345678)],%i0
                  ret
                  restore

     Both relocs contains a pointer to foo, and the offsets would
     contain junk.

          RELOCATION RECORDS FOR [.text]:
          OFFSET   TYPE      VALUE 
          00000004 HI22      _foo+0x12345678
          00000008 LO10      _foo+0x12345678
          
          00000000 9de3bf90     ; save %sp,-112,%sp
          00000004 05000000     ; sethi %hi(_foo+0),%g2
          00000008 f048a000     ; ldsb [%g2+%lo(_foo+0)],%i0
          0000000c 81c7e008     ; ret
          00000010 81e80000     ; restore

`section'
     The section field is only used when the symbol pointer field is
     null.  It supplies the section into which the data should be
     relocated. The field's main use comes from assemblers which do
     most of the symbol fixups themselves; an assembler may take an
     internal reference to a label, but since it knows where the
     label is, it can turn the relocation request from a symbol
     lookup into a section relative relocation - the relocation
     emitted has no symbol, just a section to relocate against.

     I'm not sure what it means when both a symbol pointer an a
     section pointer are present. Some formats use this sort of
     mechanism to describe PIC relocations, but BFD can't to that
     sort of thing yet.

`howto'
     The howto field can be imagined as a relocation instruction. It
     is a pointer to a struct which contains information on what to
     do with all the other information in the reloc record and data
     section. A back end would normally have a relocation instruction
     set and turn relocations into pointers to the correct structure
     on input - but it would be possible to create each howto field
     on demand.

`reloc_howto_type'
..................

   The `reloc_howto_type' is a structure which contains all the
information that BFD needs to know to tie up a back end's data.

     typedef CONST struct reloc_howto_struct 
     {

   The type field has mainly a documetary use - the back end can to
what it wants with it, though the normally the back end's external
idea of what a reloc number would be would be stored in this field.
For example, the a PC relative word relocation in a coff environment
would have the type 023 - because that's what the outside world calls
a R_PCRWORD reloc.

       unsigned int type;

   The value the final relocation is shifted right by. This drops
unwanted data from the relocation.

       unsigned int rightshift;

   The size of the item to be relocated - 0, is one byte, 1 is 2
bytes, 3 is four bytes.

       unsigned int size;

   Now obsolete

       unsigned int bitsize;

   Notes that the relocation is relative to the location in the data
section of the addend. The relocation function will subtract from the
relocation value the address of the location being relocated.

       boolean pc_relative;

   Now obsolete

       unsigned int bitpos;

   Now obsolete

       boolean absolute;

   Causes the relocation routine to return an error if overflow is
detected when relocating.

       boolean complain_on_overflow;

   If this field is non null, then the supplied function is called
rather than the normal function. This allows really strange
relocation methods to be accomodated (eg, i960 callj instructions).

       bfd_reloc_status_enum_type (*special_function)();

   The textual name of the relocation type.

       char *name;

   When performing a partial link, some formats must modify the
relocations rather than the data - this flag signals this.

       boolean partial_inplace;

   The src_mask is used to select what parts of the read in data are
to be used in the relocation sum. Eg, if this was an 8 bit bit of
data which we read and relocated, this would be 0x000000ff. When we
have relocs which have an addend, such as sun4 extended relocs, the
value in the offset part of a relocating field is garbage so we never
use it. In this case the mask would be 0x00000000.

       bfd_word src_mask;

   The dst_mask is what parts of the instruction are replaced into
the instruction. In most cases src_mask == dst_mask, except in the
above special case, where dst_mask would be 0x000000ff, and src_mask
would be 0x00000000.

       bfd_word dst_mask;

   When some formats create PC relative instructions, they leave the
value of the pc of the place being relocated in the offset slot of
the instruction, so that a PC relative relocation can be made just by
adding in an ordinary offset (eg sun3 a.out). Some formats leave the
displacement part of an instruction empty (eg m88k bcs), this flag
signals the fact.

       boolean pcrel_offset;
     } reloc_howto_type;

`HOWTO'
.......

   The HOWTO define is horrible and will go away.

     #define HOWTO(C, R,S,B, P, BI, ABS, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \
       {(unsigned)C,R,S,B, P, BI, ABS,O,SF,NAME,INPLACE,MASKSRC,MASKDST,PC}

`reloc_chain'
.............

     typedef unsigned char bfd_byte;
     
     typedef struct relent_chain {
       arelent relent;
       struct   relent_chain *next;
     } arelent_chain;

   If an output_bfd is supplied to this function the generated image
will be relocatable, the relocations are copied to the output file
after they have been changed to reflect the new state of the world. 
There are two ways of reflecting the results of partial linkage in an
output file; by modifying the output data in place, and by modifying
the relocation record. Some native formats (eg basic a.out and basic
coff) have no way of specifying an addend in the relocation type, so
the addend has to go in the output data.  This is no big deal since
in these formats the output data slot will always be big enough for
the addend. Complex reloc types with addends were invented to solve
just this problem.

     bfd_reloc_status_enum_type bfd_perform_relocation(bfd * abfd,
                             arelent *reloc_entry,
                             PTR data,
                             asection *input_section,
                             bfd *output_bfd);



File: bfd.info,  Node: Core Files,  Next: BFD back end,  Prev: BFD front end,  Up: Top

Core files
==========

   Buff output this facinating topic

`bfd_core_file_failing_command'
...............................

   Returns a read-only string explaining what program was running
when it failed and produced the core file being read

     CONST char * bfd_core_file_failing_command(bfd *);

`bfd_core_file_failing_signal'
..............................

   Returns the signal number which caused the core dump which
generated the file the BFD is attached to.

     int bfd_core_file_failing_signal(bfd *);

`core_file_matches_executable_p'
................................

   Returns `true' if the core file attached to CORE_BFD was generated
by a run of the executable file attached to EXEC_BFD, or else `false'.

     boolean core_file_matches_executable_p(bfd *core_bfd, bfd *exec_bfd);



File: bfd.info,  Node: Targets,  Next: BFD back end,  Prev: BFD front end,  Up: Top

Targets
=======

   Each port of BFD to a different machine requries the creation of a
target back end. All the back end provides to the root part of BFD is
a structure containing pointers to functions which perform certain
low level operations on files. BFD translates the applications's
requests through a pointer into calls to the back end routines.

   When a file is opened with `bfd_openr', its format and target are
unknown. BFD uses various mechanisms to determine how to interpret
the file. The operatios performed are:

   * First a BFD is created by calling the internal routine
     `new_bfd', then `bfd_find_target' is called with the target
     string supplied to `bfd_openr' and the new BFD pointer.

   * If a null target string was provided to `bfd_find_target', it
     looks up the environment variable `GNUTARGET' and uses that as
     the target string.

   * If the target string is still NULL, or the target string is
     `default', then the first item in the target vector is used as
     the target type. *Note bfd_target::.

   * Otherwise, the elements in the target vector are inspected one
     by one, until a match on target name is found. When found, that
     is used.

   * Otherwise the error `invalid_target' is returned to `bfd_openr'.

   * `bfd_openr' attempts to open the file using `bfd_open_file', and
     returns the BFD.

   Once the BFD has been opened and the target selected, the file
format may be determined. This is done by calling `bfd_check_format'
on the BFD with a suggested format. The routine returns `true' when
the application guesses right.

`bfd_target'
............



File: bfd.info,  Node: bfd_target

bfd_target
----------

   This structure contains everything that BFD knows about a target. 
It includes things like its byte order, name, what routines to call
to do various operations, etc.

   Every BFD points to a target structure with its "xvec" member.

   Shortcut for declaring fields which are prototyped function
pointers, while avoiding anguish on compilers that don't support
protos.

     #define SDEF(ret, name, arglist) \
                     PROTO(ret,(*name),arglist)
     #define SDEF_FMT(ret, name, arglist) \
                     PROTO(ret,(*name[bfd_type_end]),arglist)

   These macros are used to dispatch to functions through the
bfd_target vector. They are used in a number of macros further down
in `bfd.h', and are also used when calling various routines by hand
inside the BFD implementation.  The "arglist" argument must be
parenthesized; it contains all the arguments to the called function.

     #define BFD_SEND(bfd, message, arglist) \
                    ((*((bfd)->xvec->message)) arglist)

   For operations which index on the BFD format

     #define BFD_SEND_FMT(bfd, message, arglist) \
                 (((bfd)->xvec->message[(int)((bfd)->format)]) arglist)

   This is the struct which defines the type of BFD this is.  The
"xvec" member of the struct `bfd' itself points here.  Each module
that implements access to a different target under BFD, defines one
of these.

   FIXME, these names should be rationalised with the names of the
entry points which call them. Too bad we can't have one macro to
define them both!

     typedef struct bfd_target
     {

   identifies the kind of target, eg SunOS4, Ultrix, etc

       char *name;

   The "flavour" of a back end is a general indication about the
contents of a file.

       enum target_flavour_enum {
         bfd_target_aout_flavour_enum,
         bfd_target_coff_flavour_enum,
         bfd_target_ieee_flavour_enum,
         bfd_target_oasys_flavour_enum,
         bfd_target_srec_flavour_enum} flavour;

   The order of bytes within the data area of a file.

       boolean byteorder_big_p;

   The order of bytes within the header parts of a file.

       boolean header_byteorder_big_p;

   This is a mask of all the flags which an executable may have set -
from the set `NO_FLAGS', `HAS_RELOC', ...`D_PAGED'.

       flagword object_flags;

   This is a mask of all the flags which a section may have set -
from the set `SEC_NO_FLAGS', `SEC_ALLOC', ...`SET_NEVER_LOAD'.

       flagword section_flags;

   The pad character for filenames within an archive header.

       char ar_pad_char;

   The maximum number of characters in an archive header.

      unsigned short ar_max_namelen;

   The minimum alignment restriction for any section.

       unsigned int align_power_min;

   Entries for byte swapping for data. These are different to the
other entry points, since they don't take BFD as first arg.  Certain
other handlers could do the same.

       SDEF (bfd_vma,      bfd_getx64, (bfd_byte *));
       SDEF (void,         bfd_putx64, (bfd_vma, bfd_byte *));
       SDEF (bfd_vma, bfd_getx32, (bfd_byte *));
       SDEF (void,         bfd_putx32, (bfd_vma, bfd_byte *));
       SDEF (bfd_vma, bfd_getx16, (bfd_byte *));
       SDEF (void,         bfd_putx16, (bfd_vma, bfd_byte *));

   Byte swapping for the headers

       SDEF (bfd_vma,   bfd_h_getx64, (bfd_byte *));
       SDEF (void,          bfd_h_putx64, (bfd_vma, bfd_byte *));
       SDEF (bfd_vma,  bfd_h_getx32, (bfd_byte *));
       SDEF (void,          bfd_h_putx32, (bfd_vma, bfd_byte *));
       SDEF (bfd_vma,  bfd_h_getx16, (bfd_byte *));
       SDEF (void,          bfd_h_putx16, (bfd_vma, bfd_byte *));

   Format dependent routines, these turn into vectors of entry points
within the target vector structure; one for each format to check.

   Check the format of a file being read.  Return bfd_target * or
zero.

       SDEF_FMT (struct bfd_target *, _bfd_check_format, (bfd *));

   Set the format of a file being written.

       SDEF_FMT (boolean,            _bfd_set_format, (bfd *));

   Write cached information into a file being written, at bfd_close.

       SDEF_FMT (boolean,            _bfd_write_contents, (bfd *));

   The following functions are defined in `JUMP_TABLE'. The idea is
that the back end writer of `foo' names all the routines
`foo_'ENTRY_POINT, `JUMP_TABLE' will built the entries in this
structure in the right order.

   Core file entry points

       SDEF (char *, _core_file_failing_command, (bfd *));
       SDEF (int,    _core_file_failing_signal, (bfd *));
       SDEF (boolean, _core_file_matches_executable_p, (bfd *, bfd *));

   Archive entry points

      SDEF (boolean, _bfd_slurp_armap, (bfd *));
      SDEF (boolean, _bfd_slurp_extended_name_table, (bfd *));
      SDEF (void,   _bfd_truncate_arname, (bfd *, CONST char *, char *));
      SDEF (boolean, write_armap, (bfd *arch, 
                                   unsigned int elength,
                                   struct orl *map,
                                   int orl_count, 
                                   int stridx));

   Standard stuff.

       SDEF (boolean, _close_and_cleanup, (bfd *));
       SDEF (boolean, _bfd_set_section_contents, (bfd *, sec_ptr, PTR,
                                                 file_ptr, bfd_size_type));
       SDEF (boolean, _bfd_get_section_contents, (bfd *, sec_ptr, PTR, 
                                                 file_ptr, bfd_size_type));
       SDEF (boolean, _new_section_hook, (bfd *, sec_ptr));

   Symbols and reloctions

      SDEF (unsigned int, _get_symtab_upper_bound, (bfd *));
       SDEF (unsigned int, _bfd_canonicalize_symtab,
                (bfd *, struct symbol_cache_entry **));
       SDEF (unsigned int, _get_reloc_upper_bound, (bfd *, sec_ptr));
       SDEF (unsigned int, _bfd_canonicalize_reloc, (bfd *, sec_ptr, arelent **,
                                                    struct symbol_cache_entry**));
       SDEF (struct symbol_cache_entry  *, _bfd_make_empty_symbol, (bfd *));
       SDEF (void,     _bfd_print_symbol, (bfd *, PTR, struct symbol_cache_entry  *,
                                           bfd_print_symbol_enum_type));
     #define bfd_print_symbol(b,p,s,e) BFD_SEND(b, _bfd_print_symbol, (b,p,s,e))
       SDEF (alent *,   _get_lineno, (bfd *, struct symbol_cache_entry  *));
     
       SDEF (boolean,   _bfd_set_arch_mach, (bfd *, enum bfd_architecture,
                                            unsigned long));
     
       SDEF (bfd *,  openr_next_archived_file, (bfd *arch, bfd *prev));
       SDEF (boolean, _bfd_find_nearest_line,
             (bfd *abfd, struct sec  *section,
              struct symbol_cache_entry  **symbols,bfd_vma offset,
             CONST char **file, CONST char **func, unsigned int *line));
       SDEF (int,    _bfd_stat_arch_elt, (bfd *, struct stat *));
     
       SDEF (int,    _bfd_sizeof_headers, (bfd *, boolean));
     
       SDEF (void, _bfd_debug_info_start, (bfd *));
       SDEF (void, _bfd_debug_info_end, (bfd *));
       SDEF (void, _bfd_debug_info_accumulate, (bfd *, struct sec  *));

   Special entry points for gdb to swap in coff symbol table parts

       SDEF(void, _bfd_coff_swap_aux_in,(
            bfd            *abfd ,
            PTR             ext,
            int             type,
            int             class ,
            PTR             in));
     
       SDEF(void, _bfd_coff_swap_sym_in,(
            bfd            *abfd ,
            PTR             ext,
            PTR             in));
     
       SDEF(void, _bfd_coff_swap_lineno_in,  (
            bfd            *abfd,
            PTR            ext,
            PTR             in));
     
     } bfd_target;

`bfd_find_target'
.................

   Returns a pointer to the transfer vector for the object target
named target_name.  If target_name is NULL, chooses the one in the
environment variable GNUTARGET; if that is null or not defined then
the first entry in the target list is chosen.  Passing in the string
"default" or setting the environment variable to "default" will cause
the first entry in the target list to be returned, and
"target_defaulted" will be set in the BFD.  This causes
`bfd_check_format' to loop over all the targets to find the one that
matches the file being read.

     bfd_target * bfd_find_target(CONST char *, bfd *);

`bfd_target_list'
.................

   This function returns a freshly malloced NULL-terminated vector of
the names of all the valid BFD targets. Do not modify the names

     CONST char ** bfd_target_list();



File: bfd.info,  Node: Architectures,  Next: BFD back end,  Prev: BFD front end,  Up: Top

Architectures
=============

   BFD's idea of an architecture is implimented in `archures.c'. BFD
keeps two atoms in a BFD describing the architecture of the data
attached to the BFD, the `enum bfd_architecture arch' field and the
`unsigned long machine' field.

`bfd_architecture'
..................

   This enum gives the object file's CPU architecture, in a global
sense.  E.g. what processor family does it belong to   There is
another field, which indicates what processor within the family is in
use.  The machine gives a number which distingushes different
versions of the architecture, containing for example 2 and 3 for
Intel i960 KA and i960 KB, and 68020 and 68030 for Motorola 68020 and
68030.

     enum bfd_architecture 
     {
       bfd_arch_unknown,   /* File arch not known */
       bfd_arch_obscure,   /* Arch known, not one of these */
       bfd_arch_m68k,      /* Motorola 68xxx */
       bfd_arch_vax,       /* DEC Vax */   
       bfd_arch_i960,      /* Intel 960 */
         /* The order of the following is important.
            lower number indicates a machine type that 
            only accepts a subset of the instructions
            available to machines with higher numbers.
            The exception is the "ca", which is
            incompatible with all other machines except 
            "core". */
     
     #define bfd_mach_i960_core      1
     #define bfd_mach_i960_ka_sa     2
     #define bfd_mach_i960_kb_sb     3
     #define bfd_mach_i960_mc        4
     #define bfd_mach_i960_xa        5
     #define bfd_mach_i960_ca        6
     
       bfd_arch_a29k,      /* AMD 29000 */
       bfd_arch_sparc,     /* SPARC */
       bfd_arch_mips,      /* MIPS Rxxxx */
       bfd_arch_i386,      /* Intel 386 */
       bfd_arch_ns32k,     /* National Semiconductor 32xxx */
       bfd_arch_tahoe,     /* CCI/Harris Tahoe */
       bfd_arch_i860,      /* Intel 860 */
       bfd_arch_romp,      /* IBM ROMP RS/6000 */
       bfd_arch_alliant,   /* Alliant */
       bfd_arch_convex,    /* Convex */
       bfd_arch_m88k,      /* Motorola 88xxx */
       bfd_arch_pyramid,   /* Pyramid Technology */
       bfd_arch_h8_300,    /* Hitachi H8/300 */
       bfd_arch_last
       };

   stuff

`bfd_prinable_arch_mach'
........................

   Return a printable string representing the architecture and
machine type. The result is only good until the next call to
`bfd_printable_arch_mach'.

     CONST char * bfd_printable_arch_mach(enum bfd_architecture arch, unsigned long machine);

`bfd_scan_arch_mach'
....................

   Scan a string and attempt to turn it into an archive and machine
type combination.

     boolean bfd_scan_arch_mach(CONST char *, enum bfd_architecture *, unsigned long *);

`bfd_arch_compatible'
.....................

   This routine is used to determine whether two BFDs' architectures
and machine types are compatible.  It calculates the lowest common
denominator between the two architectures and machine types implied
by the BFDs and sets the objects pointed at by ARCHP and MACHINE if
non NULL.

   This routine returns `true' if the BFDs are of compatible type,
otherwise `false'.

     boolean bfd_arch_compatible(bfd *abfd,
          bfd *bbfd,
          enum bfd_architecture *archp,
          unsigned long *machinep);

`bfd_set_arch_mach'
...................

   Set atch mach

     #define bfd_set_arch_mach(abfd, arch, mach) \
          BFD_SEND (abfd, _bfd_set_arch_mach,\
                         (abfd, arch, mach))



File: bfd.info,  Node: Opening and Closing,  Next: BFD back end,  Prev: BFD front end,  Up: Top

Opening and Closing BFDs
========================

`bfd_openr'
...........

   Opens the file supplied (using `fopen') with the target supplied,
it returns a pointer to the created BFD.

   If NULL is returned then an error has occured.  Possible errors
are no_memory, invalid_target or system_call error.

     bfd* bfd_openr(CONST char *filename,CONST char*target);

`bfd_fdopenr'
.............

   bfd_fdopenr is to bfd_fopenr much like  fdopen is to fopen. It
opens a BFD on a file already described by the FD supplied.

   Possible errors are no_memory, invalid_target and system_call error.

     bfd * bfd_fdopenr(CONST char *filename, CONST char *target, int fd);

`bfd_openw'
...........

   Creates a BFD, associated with file FILENAME, using the file
format TARGET, and returns a pointer to it.

   Possible errors are system_call_error, no_memory, invalid_target.

     bfd * bfd_openw(CONST char *filename, CONST char *target);

`bfd_close'
...........

   This function closes a BFD. If the BFD was open for writing, then
pending operations are completed and the file written out and closed.
If the created file is executable, then `chmod' is called to mark it
as such.

   All memory attached to the BFD's obstacks is released.

   `true' is returned if all is ok, otherwise `false'.

     boolean bfd_close(bfd *);

`bfd_create'
............

   This routine creates a new BFD in the manner of `bfd_openw', but
without opening a file. The new BFD takes the target from the target
used by TEMPLATE. The format is always set to `bfd_object'.

     bfd * bfd_create(CONST char *filename, bfd *template);

`bfd_alloc_size'
................

   Return the number of bytes in the obstacks connected to the
supplied BFD.

     bfd_size_type bfd_alloc_size(bfd *abfd);



File: bfd.info,  Node: Internal,  Next: BFD back end,  Prev: BFD front end,  Up: Top

`bfd_put_size'
..............

`bfd_get_size'
..............

   These macros as used for reading and writing raw data in sections;
each access (except for bytes) is vectored through the target format
of the BFD and mangled accordingly. The mangling performs any
necessary endian translations and removes alignment restrictions.

     #define bfd_put_8(abfd, val, ptr) \
                     (*((char *)ptr) = (char)val)
     #define bfd_get_8(abfd, ptr) \
                     (*((char *)ptr))
     #define bfd_put_16(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_putx16, (val,ptr))
     #define bfd_get_16(abfd, ptr) \
                     BFD_SEND(abfd, bfd_getx16, (ptr))
     #define bfd_put_32(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_putx32, (val,ptr))
     #define bfd_get_32(abfd, ptr) \
                     BFD_SEND(abfd, bfd_getx32, (ptr))
     #define bfd_put_64(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_putx64, (val, ptr))
     #define bfd_get_64(abfd, ptr) \
                     BFD_SEND(abfd, bfd_getx64, (ptr))

   *-*/

`bfd_h_put_size'
................

`bfd_h_get_size'
................

   These macros have the same function as their `bfd_get_x'
bretherin, except that they are used for removing information for the
header records of object files. Believe it or not, some object files
keep their header records in big endian order, and their data in
little endan order.

     #define bfd_h_put_8(abfd, val, ptr) \
                     (*((char *)ptr) = (char)val)
     #define bfd_h_get_8(abfd, ptr) \
                     (*((char *)ptr))
     #define bfd_h_put_16(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_h_putx16,(val,ptr))
     #define bfd_h_get_16(abfd, ptr) \
                     BFD_SEND(abfd, bfd_h_getx16,(ptr))
     #define bfd_h_put_32(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_h_putx32,(val,ptr))
     #define bfd_h_get_32(abfd, ptr) \
                     BFD_SEND(abfd, bfd_h_getx32,(ptr))
     #define bfd_h_put_64(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_h_putx64,(val, ptr))
     #define bfd_h_get_64(abfd, ptr) \
                     BFD_SEND(abfd, bfd_h_getx64,(ptr))

   *-*/

`bfd_log2'
..........

   Return the log base 2 of the value supplied, rounded up. eg an arg
of 1025 would return 11.

     bfd_vma bfd_log2(bfd_vma x);



File: bfd.info,  Node: File Caching,  Next: BFD back end,  Prev: BFD front end,  Up: Top

File Caching
============

   The file caching mechanism is embedded within BFD and allows the
application to open as many BFDs as it wants without regard to the
underlying operating system's file descriptor limit (often as low as
20 open files).

   The module in `cache.c' maintains a least recently used list of
`BFD_CACHE_MAX_OPEN' files, and exports the name `bfd_cache_lookup'
which runs around and makes sure that the required BFD is open. If
not, then it chooses a file to close, closes it and opens the one
wanted, returning its file handle.

`BFD_CACHE_MAX_OPEN'
....................

   The maxiumum number of files which the cache will keep open at one
time.

     #define BFD_CACHE_MAX_OPEN 10

`bfd_last_cache'
................

   Zero, or a pointer to the topmost BFD on the chain.  This is used
by the `bfd_cache_lookup' macro in `libbfd.h' to determine when it
can avoid a function call.

     extern bfd *bfd_last_cache;

`bfd_cache_lookup'
..................

   Checks to see if the required BFD is the same as the last one
looked up. If so then it can use the iostream in the BFD with
impunity, since it can't have changed since the last lookup,
otherwise it has to perform the complicated lookup function

     #define bfd_cache_lookup(x) \
          ((x)==bfd_last_cache
      \
             (FILE*)(bfd_last_cache->iostream): \
              bfd_cache_lookup_worker(x))

`bfd_cache_init'
................

   Initialize a BFD by putting it on the cache LRU.

     void bfd_cache_init(bfd *);

`bfd_cache_close'
.................

   Remove the BFD from the cache. If the attached file is open, then
close it too.

     void bfd_cache_close(bfd *);

`bfd_open_file'
...............

   Call the OS to open a file for this BFD.  Returns the FILE *
(possibly null) that results from this operation.  Sets up the BFD so
that future accesses know the file is open. If the FILE * returned is
null, then there is won't have been put in the cache, so it won't
have to be removed from it.

     FILE * bfd_open_file(bfd *);

`bfd_cache_lookup_worker'
.........................

   Called when the macro `bfd_cache_lookup' fails to find a quick
answer. Finds a file descriptor for this BFD.  If necessary, it open
it.  If there are already more than BFD_CACHE_MAX_OPEN files open, it
trys to close one first, to avoid running out of file descriptors.

     FILE * bfd_cache_lookup_worker(bfd *);



File: bfd.info,  Node: BFD back end,  Next: Index,  Prev: BFD front end,  Up: Top

BFD back end
************

* Menu:

* What to put where::
* aout ::	a.out backends
* coff ::	coff backends



File: bfd.info,  Node: What to Put Where,  Next: Index,  Prev: BFD back end,  Up: Top

   All of BFD lives in one directory.



File: bfd.info,  Node: aout,  Next: Index,  Prev: BFD back end,  Up: Top

a.out backends
==============

   BFD supports a number of different flavours of a.out format,
though the major differences are only the sizes of the structures on
disk, and the shape of the relocation information.

   The support is split into a basic support file `aoutx.h' and other
files which derive functions from the base. One derivation file is
`aoutf1.h' (for a.out flavour 1), and adds to the basic a.out
functions support for sun3, sun4, 386 and 29k a.out files, to create
a target jump vector for a specific target.

   This information is further split out into more specific files for
each machine, including `sunos.c' - for sun3 and sun4 and `demo64'
for a demonstration of a 64 bit a.out format.

   The base file `aoutx.h' defines general mechanisms for reading and
writing records to and from disk, and various other methods which BFD
requires. It is included by `aout32.c' and `aout64.c' to form the
names aout_32_swap_exec_header_in, aout_64_swap_exec_header_in, etc.

   As an example, this is what goes on to make the back end for a
sun4, from aout32.c

        #define ARCH_SIZE 32
        #include "aoutx.h"

   Which exports names:

         ...
        aout_32_canonicalize_reloc
        aout_32_find_nearest_line
        aout_32_get_lineno
        aout_32_get_reloc_upper_bound
          ...

    from sunos.c

         #define ARCH 32
         #define TARGET_NAME "a.out-sunos-big"
         #define VECNAME    sunos_big_vec
         #include "aoutf1.h"

   requires all the names from aout32.c, and produces the jump vector

         sunos_big_vec

   The file host-aout.c is a special case.  It is for a large set of
hosts that use "more or less standard" a.out files, and for which
cross-debugging is not interesting.  It uses the standard 32-bit
a.out support routines, but determines the file offsets and addresses
of the text, data, and BSS sections, the machine architecture and
machine type, and the entry point address, in a host-dependent
manner.  Once these values have been determined, generic code is used
to handle the  object file.

   When porting it to run on a new system, you must supply:

   HOST_PAGE_SIZE         HOST_SEGMENT_SIZE         HOST_MACHINE_ARCH
     (optional)         HOST_MACHINE_MACHINE    (optional)        
HOST_TEXT_START_ADDR         HOST_STACK_END_ADDR

   in the file ../include/sys/h-XXX.h (for your host).  These values,
plus the structures and macros defined in <a.out.h> on your host
system, will produce a BFD target that will access ordinary a.out
files on your host.

   To configure a new machine to use host-aout.c, specify:

   TDEFINES = -DDEFAULT_VECTOR=host_aout_big_vec TDEPFILES=
host-aout.o trad-core.o

   in the config/tmake-XXX file, and modify configure.in to use the
tmake-XXX file (by setting "bfd_target=XXX") when your configuration
is selected.

relocations
-----------

   The file `aoutx.h' caters for both the *standard* and *extended*
forms of a.out relocation records.

   The standard records are characterised by containing only an
address, a symbol index and a type field. The extended records (used
on 29ks and sparcs) also have a full integer for an addend.

Internal Entry Points
---------------------

   `aoutx.h' exports several routines for accessing the contents of
an a.out file, which are gathered and exported in turn by various
format specific files (eg sunos.c).

`aout_<size>_swap_exec_header_in'
.................................

   Swaps the information in an executable header taken from a raw
byte stream memory image, into the internal exec_header structure.

     void aout_<size>_swap_exec_header_in(bfd *abfd,
           struct external_exec *raw_bytes,
           struct internal_exec *execp);

`aout_<size>_swap_exec_header_out'
..................................

   Swaps the information in an internal exec header structure into
the supplied buffer ready for writing to disk.

     void aout_<size>_swap_exec_header_out(bfd *abfd,
     	   struct internal_exec *execp,
     	   struct external_exec *raw_bytes);

`aout_<size>_some_aout_object_p'
................................

    Some A.OUT variant thinks that the file whose format we're
checking is an a.out file.  Do some more checking, and set up for
access if it really is.  Call back to the calling environments
"finish up" function just before returning, to handle any last-minute
setup.

     bfd_target * aout_<size>_some_aout_object_p(bfd *abfd,
     	  bfd_target *(*callback_to_real_object_p)());

`aout_<size>_mkobject'
......................

    This routine initializes a BFD for use with a.out files.

     boolean aout_<size>_mkobject(bfd *);

`aout_<size>_machine_type'
..........................

    Keep track of machine architecture and machine type for a.out's. 
Return the machine_type for a particular arch&machine, or M_UNKNOWN
if that exact arch&machine can't be represented in a.out format.

   If the architecture is understood, machine type 0 (default) should
always be understood.

     enum machine_type aout_<size>_machine_type(enum bfd_architecture arch,
     	  unsigned long machine);

`aout_<size>_set_arch_mach'
...........................

    Sets the architecture and the machine of the BFD to those values
supplied. Verifies that the format can support the architecture
required.

     boolean aout_<size>_set_arch_mach(bfd *,
     	  enum bfd_architecture,
     	  unsigned long machine);

`aout_<size>new_section_hook'
.............................

    Called by the BFD in response to a `bfd_make_section' request.

     boolean aout_<size>_new_section_hook(bfd *abfd,
     	  asection *newsect);


