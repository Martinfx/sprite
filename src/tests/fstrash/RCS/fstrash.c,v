head     1.4;
branch   ;
access   ;
symbols  ;
locks    jhh:1.4; strict;
comment  @ * @;


1.4
date     89.06.19.14.19.31;  author jhh;  state Exp;
branches ;
next     1.3;

1.3
date     89.01.06.08.16.54;  author brent;  state Exp;
branches ;
next     1.2;

1.2
date     88.03.31.10.09.00;  author brent;  state Exp;
branches ;
next     1.1;

1.1
date     87.10.20.11.01.23;  author brent;  state Exp;
branches ;
next     ;


desc
@Make a filesystem on a disk
@


1.4
log
@*** empty log message ***
@
text
@/* 
 * fstrash.c --
 *
 *	Format a domain to be a filesystem with lots of errors. This program 
 *	is intended to be a test for fscheck. Refer to fstrash.man for details
 *	on the filesystem created and the actions fscheck should take to 
 *	correct it.
 *	Warning - the trashed filesystem has been constructed by hand, and as
 *	a result this code is very sensitive to changes. If you want to add a
 *	new file you must do the following things:
 *	 - find an available file descriptor (see man page)
 *	 - find available data blocks (see man page)
 *	 - create a routine to fill in the descriptor (SetFooFD)
 *	 - add a call to this routine in WriteFileDesc
 *	 - mark the fd as in use in MakeFileDescBitmap
 *	 - mark the data blocks as in use in WriteBitmap
 *	 - add the file as an entry in a directory (WriteRootDirectory)
 *	 - if the new file is a directory create a new routine to fill in
 *		the directory (WriteFoo) and add a call to this routine in
 *		MakeFilesystem
 *	Since you are creating a trashed file system you may want to skip some
 *	of the above steps. Just make sure that you don't do something 
 *	unexpected by using blocks that are already in use, forgetting to
 *	add the file to a directory, etc. 
 *
 * Copyright 1989 Regents of the University of California
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  The University of California
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#ifndef lint
static char rcsid[] = "$Header: /sprite/src/cmds.ancient/makeFilesystem/RCS/makeFilesystem.c,v 1.3 89/01/06 08:16:54 brent Exp $ SPRITE (Berkeley)";
#endif not lint

#include "sprite.h"
#include "option.h"
#include "diskUtils.h"
#include <stdio.h>
#include <sys/file.h>
#include <stdlib.h>
#include <string.h>

/*
 * Constants settable via the command line.
 */
int kbytesToFileDesc = 4;	/* The ratio of kbytes to
				 * the number of file descriptors */
Boolean printOnly = TRUE;	/* Stop after computing the domain header
				 * and just print it out. No disk writes */
Boolean copySuperBlock = FALSE;	/* Copy the super block from the first
				 * disk partition to the one being formatted */
Boolean makeFile = TRUE;	/* Make a file in the root directory,
				 * this is used when testing the filesystem */
Boolean overlapBlocks = FALSE;	/* Allow filesystem blocks to overlap track
				 * boundaries.  Some disk systems can't deal. */
Boolean rootFree = FALSE;	/* Mark the root as free */
Boolean rootFile = FALSE;	/* Make the root a file */
Boolean noRoot = FALSE;		/* Zero out the root fd and block 0 */
/*
 * The following are used to go from a command line like
 * makeFilesystem -D rsd0 -P b
 * to /dev/rsd0a 	- for the partition that has the disk label
 * and to /dev/rsd0b	- for the partition to format.
 */
char *deviceName;		/* Set to "rsd0" or "rxy1", etc. */
char *partName;			/* Set to "a", "b", "c" ... "g" */
char defaultFirstPartName[] = "a";
char *firstPartName = defaultFirstPartName;
char defaultDevDirectory[] = "/dev/";
char *devDirectory = defaultDevDirectory;

Option optionArray[] = {
    {OPT_STRING, "dev", (Address)&deviceName,
	"Required: Name of device, eg \"rsd0\" or \"rxy1\""},
    {OPT_STRING, "part", (Address)&partName,
	"Required: Partition ID: (a, b, c, d, e, f, g)"},
    {OPT_TRUE, "overlap", (Address)&overlapBlocks,
	"Overlap filesystem blocks across track boundaries (FALSE)"},
    {OPT_TRUE, "copySuper", (Address)&copySuperBlock,
	"Copy the super block to the partition (FALSE)"},
    {OPT_INT, "ratio", (Address)&kbytesToFileDesc,
	"Ratio of Kbytes to file descriptors (4)"},
    {OPT_TRUE, "test", (Address)&printOnly,
	"Print results, don't write disk (TRUE)"},
    {OPT_FALSE, "write", (Address)&printOnly,
	"Write the disk (FALSE)"},
    {OPT_STRING, "dir", (Address)&devDirectory,
	"Name of device directory (\"/dev/\")"},
    {OPT_STRING, "initialPart", (Address)&firstPartName,
	"Name of initial partition (\"a\")"},
    {OPT_TRUE, "freeRoot", (Address)&rootFree,
	"Mark root fd as being free. (FALSE)"},
    {OPT_TRUE, "fileRoot", (Address)&rootFile,
	"Mark root fd as being a file. (FALSE)"},
    {OPT_TRUE, "noRoot", (Address)&noRoot,
	"Zero out root fd and block 0 (FALSE)"},

};
int numOptions = sizeof(optionArray) / sizeof(Option);

/*
 * Forward Declarations.
 */
void SetSummaryInfo();
void SetDomainHeader();
void SetDiskGeometry();
void SetDomainParts();
void SetRootFileDescriptor();
void SetBadBlockFileDescriptor();
void SetLostFoundFileDescriptor();
void SetEmptyFileDescriptor();
void SetTooBigFD();
void SetTooSmallFD();
void SetHoleFileFD();
void SetHoleDirFD();
void SetBadEntryFileFD();
void SetFragFileFD();
void SetCopyFragFileFD();
void SetCopyBlockFileFD();
void SetCopyIndBlockFileFD();
void SetCopyBogusIndBlockFileFD();
void SetDirFD();
ReturnStatus WriteFileDesc();
ReturnStatus WriteFileDescBitmap();
ReturnStatus WriteBitmap();
char *MakeFileDescBitmap();


/*
 *----------------------------------------------------------------------
 *
 * main --
 *
 *	Create the required file names from the command line
 *	arguments.  Then open the first partition on the disk
 *	because it contains the disk label, and open the partition
 *	that is to be formatted.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Calls MakeFilesystem
 *
 *----------------------------------------------------------------------
 */
main(argc, argv)
    int argc;
    char *argv[];
{
    ReturnStatus status;	/* status of system calls */
    int firstPartFID;		/* File ID for first parition on the disk */
    int partFID;		/* File ID for partiton to format */
    char firstPartitionName[64];
    char partitionName[64];
    int partition;		/* Index of partition derived from the
				 * partition name */
    int spriteID;		/* Host ID of the machine with the disks */
    Fs_Attributes attrs;
    char 	answer[100];

    (void)Opt_Parse(argc, argv,optionArray, numOptions, 0);

    status = SUCCESS;
    if (deviceName == (char *)0) {
	fprintf(stderr,"Specify device name with -dev option\n");
	status = FAILURE;
    }
    if (partName == (char *)0) {
	fprintf(stderr,"Specify partition with -part option\n");
	status = FAILURE;
    }
    if (status != SUCCESS) {
	exit(status);
    }
    if (!printOnly) {
	printf("The \"-write\" option will cause fstrash to overwrite the current filesystem.\nDo you really want to do this?[y/n] ");
	if (scanf("%10s",answer) != 1) {
	    exit(SUCCESS);
	}
	if ((*answer != 'y') && (*answer != 'Y')) {
	    exit(SUCCESS);
	}
    }


    /*
     * Gen up the name of the first partition on the disk,
     * and the name of the parition that needs to be formatted.
     */
    (void) strcpy(firstPartitionName, devDirectory);	/* eg. /dev/ */
    (void) strcpy(partitionName, devDirectory);
    (void) strcat(firstPartitionName, deviceName);	/* eg. /dev/rxy0 */
    (void) strcat(partitionName, deviceName);
    (void) strcat(firstPartitionName, firstPartName);	/* eg. /dev/rxy0a */
    (void) strcat(partitionName, partName);		/* eg. /dev/rxy0b */


    firstPartFID = open(firstPartitionName, O_RDONLY);
    if (firstPartFID < 0 ) {
	perror("Can't open first partition");
	exit(FAILURE);
    }
    partFID = open(partitionName, O_RDWR);
    if (partFID < 0) {
	perror("Can't open partition to format");
	exit(FAILURE);
    }

    partition = partName[0] - 'a';
    if (partition < 0 || partition > 7) {
	fprintf(stderr,
	       "Can't determine partition index from the partition name\n");
	exit(FAILURE);
    }

    /*
     * Determine where the disk is located so we can set the
     * spriteID in the header correctly.
     */
    Fs_GetAttributesID(firstPartFID, &attrs);
    if (attrs.devServerID == FS_LOCALHOST_ID) {
	Sys_GetMachineInfo(NULL, NULL, &spriteID);
	printf("Making filesystem for local host, ID = 0x%x\n", spriteID);
    } else {
	spriteID = attrs.devServerID;
	printf("Making filesystem for remote host 0x%x\n", spriteID);
    }
    printf("MakeFilesystem based on 4K filesystem blocks\n");
    status = MakeFilesystem(firstPartFID, partFID, partition, spriteID);

    fflush(stderr);
    fflush(stdout);
    (void)close(firstPartFID);
    (void)close(partFID);
    exit(status);
}

/*
 *----------------------------------------------------------------------
 *
 * MakeFilesystem --
 *
 *	Format a disk partition, or domain.
 *
 * Results:
 *	An error code.
 *
 * Side effects:
 *	Write all over the disk partition.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
MakeFilesystem(firstPartFID, partFID, partition, spriteID)
    int firstPartFID;	/* Handle on the first partition of the disk */
    int partFID;	/* Handle on the partition of the disk to format */
    int partition;	/* Index of parition that is to be formatted */
    int spriteID;	/* Host ID of the machine with the disks, this
			 * gets written on the disk and used at boot time */
{
    ReturnStatus status;
    Disk_Info *diskInfoPtr;
    FsDomainHeader *headerPtr;
    FsSummaryInfo *summaryPtr;

    /*
     * Read the copy of the super block at the beginning of the partition
     * to find out basic disk geometry and where to write the domain header.
     */
    diskInfoPtr = Disk_ReadDiskInfo(firstPartFID, partition);
    if (diskInfoPtr == (Disk_Info *)0) {
	fprintf(stderr,"MakeFilesystem: Unable to read super block.\n");
	return(FAILURE);
    }

    headerPtr = (FsDomainHeader *)
	malloc((unsigned) diskInfoPtr->numDomainSectors * DEV_BYTES_PER_SECTOR);
    SetDomainHeader(diskInfoPtr, headerPtr, spriteID, partition);
    Disk_PrintDomainHeader(headerPtr);

    if (!printOnly) {
	if (copySuperBlock && partition != 0) {
	    status = CopySuperBlock(firstPartFID, partFID);
	    if (status != SUCCESS) {
		perror("CopySuperBlock failed"); 
		return(status);
	    }
	}
	status = Disk_SectorWrite(partFID, diskInfoPtr->domainSector,
			    diskInfoPtr->numDomainSectors, (Address)headerPtr);
	if (status != SUCCESS) {
	    perror("DomainHeader write failed");
	    return(status);
	}
    }
    summaryPtr = (FsSummaryInfo *) malloc(DEV_BYTES_PER_SECTOR);
    SetSummaryInfo(diskInfoPtr, headerPtr, summaryPtr);
    Disk_PrintSummaryInfo(summaryPtr);
    if (!printOnly) {
	status = Disk_SectorWrite(partFID, diskInfoPtr->summarySector, 1,
			    (Address)summaryPtr);
	if (status != SUCCESS) {
	    perror("Summary sector  write failed");
	    return(status);
	}
    }

    status = WriteFileDesc(headerPtr, partFID);
    if (status != SUCCESS) {
	perror("WriteFileDesc failed");
	return(status);
    }
    status = WriteBitmap(headerPtr, partFID);
    if (status != SUCCESS) {
	perror("WriteBitmap failed");
	return(status);
    }
    status = WriteRootDirectory(headerPtr, partFID);
    if (status != SUCCESS) {
	perror("WriteRootDirectory failed");
	return(status);
    }
    status = WriteLostFoundDirectory(headerPtr, partFID);
    if (status != SUCCESS) {
	perror("WriteLostFoundDirectory failed");
	return(status);
    }
    status = WriteEmptyDirectory(headerPtr, partFID, 17, 16, 64);
    if (status != SUCCESS) {
	perror("WriteEmptyDirectory failed");
	return(status);
    }
    status = WriteEmptyDirectory(headerPtr, partFID, 9, 2, 32);
    if (status != SUCCESS) {
	perror("WriteEmptyDirectory failed");
	return(status);
    }
    return(SUCCESS);
}

/*
 *----------------------------------------------------------------------
 *
 * CopySuperBlock --
 *
 *	Copy the super block from the first sector of the disk to
 *	the first sector of the partition being formatted.
 *
 * Results:
 *	A return code from the I/O.
 *
 * Side effects:
 *	Writes on the zero'th sector of the partition.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
CopySuperBlock(firstPartFID, partFID)
    int firstPartFID;
    int partFID;
{
    ReturnStatus status;
    char *block;

    block = (char *)malloc(DEV_BYTES_PER_SECTOR);

    status = Disk_SectorRead(firstPartFID, 0, 1, block);
    if (status != SUCCESS) {
	return(status);
    }
    status = Disk_SectorWrite(partFID, 0, 1, block);
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * SetDomainHeader --
 *
 *	Compute the domain header based on the partition size and
 *	other basic disk parameters.
 *
 * Results:
 *	A return code.
 *
 * Side effects:
 *	Fill in the domain header.
 *
 *----------------------------------------------------------------------
 */
void
SetDomainHeader(diskInfoPtr, headerPtr, spriteID, partition)
    Disk_Info *diskInfoPtr;	/* Information from the super block */
    FsDomainHeader *headerPtr;	/* Reference to domain header to fill in */
    int spriteID;		/* Host ID of machine with the disks */
    int partition;		/* Index of partition to format */
{
    register FsGeometry *geoPtr;/* The layout information for the disk */

    headerPtr->magic = FS_DOMAIN_MAGIC;
    headerPtr->firstCylinder = diskInfoPtr->firstCylinder;
    headerPtr->numCylinders = diskInfoPtr->numCylinders;
    /*
     * The device.serverID from the disk is used during boot to discover
     * the host"s spriteID if reverse arp couldn't find a host ID.  The
     * unit number of disk indicates what partition of the disk this
     * domain header applies to.  For example, both the "a" and "c" partitions
     * typically start at sector zero, but only one is valid.  During boot
     * time the unit number is used to decide which partition should be
     * attached.
     */
    headerPtr->device.serverID = spriteID;
    headerPtr->device.type = -1;
    headerPtr->device.unit = partition;
    headerPtr->device.data = (ClientData)-1;

    geoPtr = &headerPtr->geometry;
    SetDiskGeometry(diskInfoPtr, geoPtr);

    SetDomainParts(diskInfoPtr, headerPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * SetDiskGeometry --
 *
 *	This computes the rotational set arrangment depending on the
 *	disk geometry.  The basic rules for this are that filesystem blocks
 *	are skewed on successive tracks, and that the skewing pattern
 *	repeats in either 2 or 4 tracks.  This is specific to the fact that
 *	filesystem blocks are 4Kbytes.  This means that one disk track
 *	contains N/4 filesystem blocks and that one sector per track
 *	is wasted if there are an odd number of sectors per track.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Fill in the geometry struct.
 *
 *----------------------------------------------------------------------
 */
void
SetDiskGeometry(diskInfoPtr, geoPtr)
    register Disk_Info *diskInfoPtr;/* Basic geometry information */
    register FsGeometry *geoPtr;	/* Fancy geometry information */
{
    register int index;		/* Array index */
    int numBlocks;		/* The number of blocks in a rotational set */
    int tracksPerSet;		/* Total number of tracks in a rotational set */
    int numTracks;		/* The number of tracks in the set so far */
    int extraSectors;		/* The number of leftover sectors in a track */
    int offset;			/* The sector offset within a track */
    int startingOffset;		/* The offset of the first block in a track */
    int offsetIncrement;	/* The skew of the starting offset on each
				 * successive track of the rotational set */
    Boolean overlap;		/* TRUE if filesystem blocks overlap tracks */

    geoPtr->numHeads = diskInfoPtr->numHeads;
    geoPtr->sectorsPerTrack = diskInfoPtr->numSectors;

    /*
     * Figure out some basic parameters of the rotational set.  The number
     * of tracks in the set is either 2 or 4.  If 2, then the blocks on
     * successive tracks are skewed by 1/2 a filesystem block.  If 4,
     * blocks are skewed by 1/4 block.  A 4 track rotational set is best
     * becasue there are more rotational positions.  If, however, it
     * causes 2 or 3 wasted tracks at the end, or if blocks naturally
     * overlap by 1/2 block, then only 2 tracks per rotational set are
     * used.
     */
    switch(geoPtr->numHeads % 4) {
	case 0:
	case 1: {
	    extraSectors = geoPtr->sectorsPerTrack % DISK_SECTORS_PER_BLOCK;
	    if (extraSectors < DISK_SECTORS_PER_BLOCK/4) {
		/*
		 * Not enough extra sectors to overlap blocks onto the
		 * next track.  The blocks will fit evenly on a track,
		 * but the blocks on the following tracks will be skewed.
		 */
		tracksPerSet = 4;
		overlap = FALSE;
		offsetIncrement = DISK_SECTORS_PER_BLOCK/4;
	    } else if (extraSectors < DISK_SECTORS_PER_BLOCK/2) {
		/*
		 * Enough to overlap the first 1/4 block onto the next track.
		 */
		tracksPerSet = 4;
		overlap = TRUE;
		offsetIncrement = DISK_SECTORS_PER_BLOCK * 3/4;
	    } else if (extraSectors < DISK_SECTORS_PER_BLOCK * 3/4) {
		/*
		 * Enough to overlap 1/2 block.
		 */
		tracksPerSet = 2;
		overlap = TRUE;
		offsetIncrement = DISK_SECTORS_PER_BLOCK/2;
	    } else {
		/*
		 * Enough to overlap 3/4 block.
		 */
		tracksPerSet = 4;
		overlap = TRUE;
		offsetIncrement = DISK_SECTORS_PER_BLOCK/4;
	    }
	    break;
	}
	case 2:
	case 3: {
	    /*
	     * Instead of wasting 2 or 3 tracks to have a 4 track rotational
	     * set, the rotational set is only 2 tracks long.  Also see if
	     * the blocks naturally overlap by 1/2 block.
	     */
	    tracksPerSet = 2;
	    offsetIncrement = DISK_SECTORS_PER_BLOCK/2;
	    if ((geoPtr->sectorsPerTrack % DISK_SECTORS_PER_BLOCK) <
		      DISK_SECTORS_PER_BLOCK/2) {
		overlap = FALSE;
	    } else {
		overlap = TRUE;
	    }
	}
    }
    if (!overlapBlocks) {
	overlap = FALSE;
	offsetIncrement = 0;
    }
    printf("overlap %s, offsetIncrement %d\n", (overlap ? "TRUE" : "FALSE"),
		      offsetIncrement);
    /*
     * Determine rotational position of the blocks in the rotational set.
     */
    extraSectors = geoPtr->sectorsPerTrack;
    startingOffset = 0;
    offset = startingOffset;
    for (numBlocks = 0, numTracks = 0 ; ; ) {
	if (extraSectors >= DISK_SECTORS_PER_BLOCK) {
	    /*
	     * Ok to fit in another filesystem block on this track.
	     */
	    geoPtr->blockOffset[numBlocks] = offset;
	    numBlocks++;	
	    offset += DISK_SECTORS_PER_BLOCK;
	    extraSectors -= DISK_SECTORS_PER_BLOCK;
	} else {
	    /*
	     * The current block has to take up room on the next track.
	     */
	    numTracks++;
	    if (numTracks < tracksPerSet) {
		/*
		 * Ok to go to the next track.
		 */
		startingOffset += offsetIncrement;
		if (overlap) {
		    /*
		     * If the current block can overlap to the next track,
		     * use the current offset.  Because of the overlap
		     * there are fewer sectors available for blocks on
		     * the next track.
		     */
		    geoPtr->blockOffset[numBlocks] = offset;
		    numBlocks++;
		    extraSectors = geoPtr->sectorsPerTrack - startingOffset;
		}
		offset = startingOffset + numTracks * geoPtr->sectorsPerTrack;
		if (!overlap) {
		    /*
		     * If no overlap the whole next track is available.
		     */
		    extraSectors = geoPtr->sectorsPerTrack;
		}
	    } else {
		/*
		 * Done.
		 */
		for (index = numBlocks; index < FS_MAX_ROT_POSITIONS; index++){
		    geoPtr->blockOffset[index] = -1;
		}
		break;
	    }
	}
    }
    geoPtr->blocksPerRotSet = numBlocks;
    geoPtr->tracksPerRotSet = tracksPerSet;
    geoPtr->rotSetsPerCyl = geoPtr->numHeads / tracksPerSet;
    geoPtr->blocksPerCylinder = numBlocks * geoPtr->rotSetsPerCyl;

    /*
     * Now the rotational positions have to be sorted so that rotationally
     * optimal blocks can be found.  The array sortedOffsets is set so
     * that the I'th element has the index into blockOffset which contains
     * the I'th rotational position, eg.
     *	blockOffset	sortedOffsets
     *	    0 (+0)		0
     *	    8 (+0)		2
     *	    4 (+17)		1
     *	   12 (+17)		3
     */

    offsetIncrement = DISK_SECTORS_PER_BLOCK / tracksPerSet;
    for (index = 0 ; index < FS_MAX_ROT_POSITIONS ; index++) {
	geoPtr->sortedOffsets[index] = -1;
    }
    for (index = 0 ; index < numBlocks ; index++) {
	offset = geoPtr->blockOffset[index] % geoPtr->sectorsPerTrack;
	geoPtr->sortedOffsets[offset/offsetIncrement] = index;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * SetDomainParts --
 *
 *	Set up the way the domain is divided into 4 areas:  the bitmap
 *	for the file descriptors, the file descriptors, the bitmap for
 *	the data blocks, and the data blocks.
 *
 * Results:
 *	The geometry information is completed.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
SetDomainParts(diskInfoPtr, headerPtr)
    register Disk_Info *diskInfoPtr;
    register FsDomainHeader *headerPtr;
{
    register FsGeometry *geoPtr;
    int numFiles;		/* Number of files computed from the size */
    int numBlocks;		/* Number of blocks in the partition.  This
				 * is computed and then dolled out to the
				 * different things stored in the partition */
    int offset;			/* Block offset within partition */
    int numSectors;		/* Sectors per rotational set */
    int numSets;		/* Number of reserved rotational sets */
    int bitmapBytes;		/* Number of bytes taken up by a bitmap */
    /*
     * Set aside a number of blocks at the begining of the partition for
     * things like the super block, the boot program, and the domain header.
     * It is easiest to do this by reserving one or more rotational sets.
     */
    geoPtr = &headerPtr->geometry;
    numSectors = geoPtr->tracksPerRotSet * geoPtr->sectorsPerTrack;
    for ( numSets = 1; ; numSets++ ) {
	if (numSets * numSectors >
	    diskInfoPtr->domainSector + diskInfoPtr->numDomainSectors) {
	    break;
	}
    }
    printf("Reserving %d blocks for domain header, etc.\n",
		    numSets*geoPtr->blocksPerRotSet);
    /*
     * Determine the number of filesystem blocks available and compute a
     * first guess at the number of file descriptors.  If at the end of
     * the computation things don't fit nicely, then the number of files
     * is changed and the computation is repeated.
     */
    numFiles = 0;
    do {
	numBlocks = geoPtr->blocksPerCylinder * diskInfoPtr->numCylinders -
		    numSets * geoPtr->blocksPerRotSet;
	if (numFiles == 0) {
	    numFiles = numBlocks * DISK_KBYTES_PER_BLOCK / kbytesToFileDesc;
	}
	numFiles		  &= ~(FS_FILE_DESC_PER_BLOCK-1);
	offset			  = numSets * geoPtr->blocksPerRotSet;

	headerPtr->fdBitmapOffset = offset;
	bitmapBytes		  = (numFiles - 1) / BITS_PER_BYTE + 1;
	headerPtr->fdBitmapBlocks = (bitmapBytes - 1) / FS_BLOCK_SIZE + 1;
	numBlocks		  -= headerPtr->fdBitmapBlocks;
	offset			  += headerPtr->fdBitmapBlocks;

	headerPtr->fileDescOffset = offset;
	headerPtr->numFileDesc	  = numFiles;
	numBlocks		  -= numFiles / FS_FILE_DESC_PER_BLOCK;
	offset			  += numFiles / FS_FILE_DESC_PER_BLOCK;
	/*
	 * The data blocks will start on a cylinder.  Try the next
	 * cylinder boundary after the start of the bitmap.
	 */
	headerPtr->bitmapOffset	  = offset;
	headerPtr->dataOffset	  = ((offset-1) / geoPtr->blocksPerCylinder + 1)
				     * geoPtr->blocksPerCylinder;
	headerPtr->dataBlocks	  = headerPtr->numCylinders *
				      geoPtr->blocksPerCylinder -
				      headerPtr->dataOffset;
	bitmapBytes		  = (headerPtr->dataBlocks * DISK_KBYTES_PER_BLOCK -
				       1) / BITS_PER_BYTE + 1;
	headerPtr->bitmapBlocks	  = (bitmapBytes - 1) / FS_BLOCK_SIZE + 1;
	/*
	 * Check the size of the bit map against space available for it
	 * between the end of the file descriptors and the start of the
	 * data blocks.
	 */
	if (headerPtr->dataOffset - headerPtr->bitmapOffset <
	    headerPtr->bitmapBlocks) {
	    int numBlocksNeeded;
	    /*
	     * Need more blocks to hold the bitmap.  Reduce the number
	     * of file descriptors to get the blocks and re-iterate.
	     */
	    numBlocksNeeded = headerPtr->bitmapBlocks -
		(headerPtr->dataOffset - headerPtr->bitmapOffset);
	    numFiles -= numBlocksNeeded * FS_FILE_DESC_PER_BLOCK;
	} else if (headerPtr->dataOffset - headerPtr->bitmapOffset >
		    headerPtr->bitmapBlocks) {
	    int extraBlocks;
	    /*
	     * There are extra blocks between the end of the file descriptors
	     * and the start of the bitmap.  Increase the number of
	     * file descriptors and re-iterate.
	     */
	    extraBlocks = headerPtr->dataOffset - headerPtr->bitmapOffset -
		    headerPtr->bitmapBlocks;
	    numFiles += extraBlocks * FS_FILE_DESC_PER_BLOCK;
	}
    } while (headerPtr->dataOffset - headerPtr->bitmapOffset !=
		headerPtr->bitmapBlocks);
    headerPtr->dataCylinders	= headerPtr->dataBlocks /
				  geoPtr->blocksPerCylinder ;
}

/*
 *----------------------------------------------------------------------
 *
 * SetSummaryInfo --
 *
 *	This routine is out of date and writes bogus info to the disk.
 *	Fscheck should fix the data anyway.
 *
 * Results:
 *	A return code.
 *
 * Side effects:
 *	Fill in the summary info.
 *
 *----------------------------------------------------------------------
 */
void
SetSummaryInfo(diskInfoPtr, headerPtr, summaryPtr)
    Disk_Info *diskInfoPtr;	/* Information from the super block */
    FsDomainHeader *headerPtr;	/* Domain header to summarize */
    FsSummaryInfo *summaryPtr;	/* Reference to summary info to fill in */
{

    bzero((Address)summaryPtr, DEV_BYTES_PER_SECTOR);

    strcpy(summaryPtr->domainPrefix, "(new domain)");
    /*
     * 9 blocks are already allocated, one for the root directory,
     * and 8 more for lost+found.
     */
    summaryPtr->numFreeKbytes = headerPtr->dataBlocks * (FS_BLOCK_SIZE / 1024)
				- 9;
    /*
     * 4 file descriptors are already used, 0 and 1 are reserved,
     * 2 is for the root, and 3 is for lost+found.
     */
    summaryPtr->numFreeFileDesc = headerPtr->numFileDesc - 5;
    if (makeFile) {
	summaryPtr->numFreeFileDesc--;
    }
    /*
     * The summary state field is unused.
     */
    summaryPtr->state = 0;
    /*
     * The domain number under which this disk partition is mounted is
     * recorded on disk so servers re-attach disks under the same "name".
     * We set it to the special value so it gets a new number assigned
     * when it is first attached.
     */
    summaryPtr->domainNumber = -1;
    /*
     * The flags field is used to record whether or not the disk has been
     * safely "sync"ed to disk upon shutdown.
     */
    summaryPtr->flags = 0;
    summaryPtr->fixCount = 0;
}

/*
 *----------------------------------------------------------------------
 *
 * WriteFileDesc --
 *
 *	Write out the file descriptor array to disk.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
WriteFileDesc(headerPtr, partFID)
    register FsDomainHeader *headerPtr;
    int partFID;	/* File handle for partition to format */
{
    ReturnStatus status;
    char *bitmap;
    char *block;
    register FsFileDescriptor *fileDescPtr;
    register int index;

    bitmap = MakeFileDescBitmap(headerPtr);
    if (!printOnly) {
	status = Disk_BlockWrite(partFID, headerPtr, headerPtr->fdBitmapOffset,
				headerPtr->fdBitmapBlocks, (Address)bitmap);
	if (status != SUCCESS) {
	    return(status);
	}
    }
    /*
     * Make the first block of file descriptors.  This contains some
     * canned file descriptors for the root, bad block file, and the
     * lost and found directory.  For (early system) testing an empty file
     * can also be created.
     */
    block = (char *)malloc(FS_BLOCK_SIZE);
    bzero(block, FS_BLOCK_SIZE);
    for (index = 0;
         index < FS_FILE_DESC_PER_BLOCK;
	 index++ ) {
	fileDescPtr = (FsFileDescriptor *)((int)block +
					   index * FS_MAX_FILE_DESC_SIZE);
	fileDescPtr->magic = FS_FD_MAGIC;
	if (index < FS_BAD_BLOCK_FILE_NUMBER) {
	    fileDescPtr->flags = FS_FD_RESERVED;
	} else if (index == FS_BAD_BLOCK_FILE_NUMBER) {
	    SetBadBlockFileDescriptor(fileDescPtr);
	} else if (index == FS_ROOT_FILE_NUMBER) {
	    SetRootFileDescriptor(fileDescPtr);
	} else if (index == FS_LOST_FOUND_FILE_NUMBER) {
	    SetLostFoundFileDescriptor(fileDescPtr);
	} else if ((index == 4) && makeFile) {
	    SetEmptyFileDescriptor(fileDescPtr);
	} else if ((index == 5)) {
	    SetEmptyFileDescriptor(fileDescPtr);
	} else if ((index == 6)) {
	    SetTooBigFD(fileDescPtr);
	} else if ((index == 7)) {
	    SetTooSmallFD(fileDescPtr);
	} else if ((index == 8)) {
	    SetHoleFileFD(headerPtr, partFID, fileDescPtr);
	} else if ((index == 9)) {
	    SetHoleDirFD(headerPtr, partFID, fileDescPtr);
	} else if ((index == 10)) {
	    SetBadEntryFileFD(headerPtr, partFID, fileDescPtr);
	} else if ((index == 11)) {
	    SetFragFileFD(fileDescPtr);	
	} else if ((index == 12)) {
	    SetCopyFragFileFD(fileDescPtr);	
	} else if ((index == 13)) {
	    SetCopyBlockFileFD(fileDescPtr);	
	} else if ((index == 14)) {
	    SetCopyIndBlockFileFD(headerPtr, partFID, fileDescPtr);	
	} else if ((index == 15)) {
	    SetCopyBogusIndBlockFileFD(headerPtr, partFID, fileDescPtr);	
	} else if ((index == 16)) {
	    fileDescPtr->magic = ~FS_FD_MAGIC;
	} else if ((index == 17)) {
	    SetDirFD(fileDescPtr);
	} else if ((index == 18)) {
	    SetOutputFD(fileDescPtr);
	} else {
	    fileDescPtr->flags = FS_FD_FREE;
	}
    }
    if (!printOnly) {
	/*
	 * Write out the first, specially hand crafted, block of file
	 * descriptors.
	 */
	status = Disk_BlockWrite(partFID, headerPtr, headerPtr->fileDescOffset,
				    1, (Address)block);
	if (status != SUCCESS) {
	    return(status);
	}
	/*
	 * Redo the block for the remaining file descriptors
	 */
	bzero(block, FS_BLOCK_SIZE);
	for (index = 0;
	     index < FS_FILE_DESC_PER_BLOCK;
	     index++ ) {
	    fileDescPtr = (FsFileDescriptor *)((int)block + index *
					       FS_MAX_FILE_DESC_SIZE);
	    fileDescPtr->magic = FS_FD_MAGIC;
	    fileDescPtr->flags = FS_FD_FREE;
	}
	/*
	 * Write out the remaining file descriptors.
	 */
	for (index = FS_FILE_DESC_PER_BLOCK;
	     index < headerPtr->numFileDesc;
	     index += FS_FILE_DESC_PER_BLOCK) {
	    status = Disk_BlockWrite(partFID, headerPtr,
		     headerPtr->fileDescOffset + (index/FS_FILE_DESC_PER_BLOCK),
		     1, (Address)block);
	    if (status != SUCCESS) {
		return(status);
	    }
	}
    } else {
	status = SUCCESS;
    }
    return(status);
}

/*
 * This macro makes setting bits in the fd and data block bitmap easier.
 */

#define SET(num)  {   bitmap[(num) >> 3] |=(1 << (7 - ((num) & 0x7))); }


/*
 *----------------------------------------------------------------------
 *
 * 
 * MakeFileDescBitmap --
 *
 *	Compute out the bitmap for file descriptor array to disk.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
char *
MakeFileDescBitmap(headerPtr)
    register FsDomainHeader *headerPtr;
{
    register char *bitmap;
    register int index;

    /*
     * Allocate and initialize the bitmap to all 0"s to mean all free.
     */
    bitmap = (char *)malloc((unsigned) headerPtr->fdBitmapBlocks *
				 FS_BLOCK_SIZE);
    bzero((Address)bitmap, headerPtr->fdBitmapBlocks * FS_BLOCK_SIZE);

    SET(0);
    SET(1);
    if (!noRoot) {
	SET(2);
    }
    SET(3);
    SET(4);
    SET(6);
    SET(7);
    SET(8);
    SET(9);
    SET(10);
    SET(11);
    SET(12);
    SET(13);
    SET(14);
    SET(15);
    /*
     * 16 is allocated but not marked in the bitmap.
     */
    SET(17);
    SET(18);
    /*
     * 20 is marked in the bitmap but not used.
     */
    SET(20);
    /*
     * Set the bits in the map at the end that don't correspond to
     * any existing file descriptors.
     */
    index = headerPtr->numFileDesc / BITS_PER_BYTE;
    if (headerPtr->numFileDesc % BITS_PER_BYTE) {
	register int bitIndex;
	/*
	 * Take care the last byte that only has part of its bits set.
	 */
	for (bitIndex = headerPtr->numFileDesc % BITS_PER_BYTE;
	     bitIndex < BITS_PER_BYTE;
	     bitIndex++) {
	    bitmap[index] |= 1 << ((BITS_PER_BYTE - 1) - bitIndex);
	}
	index++;
    }
    for ( ; index < headerPtr->fdBitmapBlocks * FS_BLOCK_SIZE; index++) {
	bitmap[index] = 0xff;
    }

    if (printOnly) {
	Disk_PrintFileDescBitmap(headerPtr, bitmap);
    }
    return(bitmap);
}

/* 
 * This macro makes setting an entire block (4 fragments) easier. The block
 * to set must be on a block boundary.
 */

#define SET4K(num)  {   bitmap[(num) >> 3] |=(0xf << (4 - ((num) & 0x7))); }


/*
 *----------------------------------------------------------------------
 *
 * WriteBitmap --
 *
 *	Write out the bitmap for the data blocks.  This knows that the
 *	first 1K fragment is allocated to the root directory and 8K is
 *	allocated to lost and found, plus lots of other blocks are allocated
 *	to the rest of the files.
 *
 * Results:
 *	A return code from the writes.
 *
 * Side effects:
 *	Write the bitmap.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
WriteBitmap(headerPtr, partFID)
    register FsDomainHeader *headerPtr;
    int partFID;
{
    ReturnStatus status;
    char *bitmap;
    int kbytesPerCyl;
    int bitmapBytesPerCyl;
    int index;

    bitmap = (char *)malloc((unsigned) headerPtr->bitmapBlocks * FS_BLOCK_SIZE);
    bzero(bitmap, headerPtr->bitmapBlocks * FS_BLOCK_SIZE);
    /*
     * Set the bit corresponding to the kbyte used for the root directory
     * and the next 8K reserved for lost and found.
     *   ________
     *	|0______7|	Bits are numbered like this in a byte.
     *
     * See fstrash.man for info on how these blocks are used
     */
    if (!noRoot) {
	SET(0);
    }
    SET(1);
    SET4K(4);
    SET(8);
    SET(9);

    SET(11);
    SET4K(12);
    SET(16);
    SET(17);

    SET4K(32);
    SET4K(36);

    SET4K(44);
    SET4K(48);
    SET4K(52);
    SET4K(56);

    SET(61);
    SET(62);

    SET(64);

    SET4K(68);
    SET4K(72);

    /*
     * The bitmap is organized by cylinder.  There are whole number of
     * bytes in the bitmap for each cylinder.  Each bit in the bitmap
     * corresponds to 1 kbyte on the disk.
     */
    kbytesPerCyl = headerPtr->geometry.blocksPerCylinder * DISK_KBYTES_PER_BLOCK;
    bitmapBytesPerCyl = (kbytesPerCyl - 1) / BITS_PER_BYTE + 1;
    if ((kbytesPerCyl % BITS_PER_BYTE) != 0) {
	/*
	 * There are bits in the last byte of the bitmap for each cylinder
	 * that don't have kbytes behind them.  Set those bits here so
	 * the blocks don't get allocated.
	 */
	register int extraBits;
	register int mask;

	extraBits = kbytesPerCyl % BITS_PER_BYTE;
	/*
	 * Set up a mask that has the right part filled with 1"s.
	 */
	mask = 0x0;
	for ( ; extraBits < BITS_PER_BYTE ; extraBits++) {
	    mask |= 1 << ((BITS_PER_BYTE - 1) - extraBits);
	}
	for (index = 0;
	     index < headerPtr->dataBlocks * DISK_KBYTES_PER_BLOCK / BITS_PER_BYTE;
	     index += bitmapBytesPerCyl) {
	    bitmap[index + bitmapBytesPerCyl - 1] |= mask;
	}
    }
    /*
     * Set the bits in the bitmap that correspond to non-existent cylinders;
     * the bitmap is allocated a whole number of blocks on the disk
     * so there are bytes at its end that don't have blocks behind them.
     */
 
    for (index = headerPtr->dataCylinders * bitmapBytesPerCyl;
	 index < headerPtr->bitmapBlocks * FS_BLOCK_SIZE;
	 index++) {
	bitmap[index] = 0xff;
    }
    if (printOnly) {
	Disk_PrintDataBlockBitmap(headerPtr, bitmap);
	status = SUCCESS;
    } else {
	status = Disk_BlockWrite(partFID, headerPtr, headerPtr->bitmapOffset,
			    headerPtr->bitmapBlocks, (Address)bitmap);
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * WriteRootDirectory --
 *
 *	Write the data blocks of the root directory.
 *
 * Results:
 *	A return code from the writes.
 *
 * Side effects:
 *	Write the root directory"s data block.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
WriteRootDirectory(headerPtr, partFID)
    register FsDomainHeader *headerPtr;
    int partFID;
{
    ReturnStatus status;
    char block[FS_BLOCK_SIZE];
    FsDirEntry *dirEntryPtr;
    int offset;
    int i;

    bzero((Address) block, FS_BLOCK_SIZE);

    if (!noRoot) {

	dirEntryPtr = (FsDirEntry *)block;
    
	offset = FillDirEntry(dirEntryPtr,".",FS_ROOT_FILE_NUMBER);

	dirEntryPtr = (FsDirEntry *)((int)block + offset);
	offset += FillDirEntry(dirEntryPtr,"..",FS_ROOT_FILE_NUMBER);
    
	/*
	 * Add lost and found.
	 */
    
	dirEntryPtr = (FsDirEntry *) ((int)block + offset);
	offset += FillDirEntry(dirEntryPtr,"lost+found",
			       FS_LOST_FOUND_FILE_NUMBER);
    
	dirEntryPtr = (FsDirEntry *) ((int)block + offset);
	offset += FillDirEntry(dirEntryPtr,"testFile",4);
    
	/*
	 * file 5 is an unreferenced file
	 */
    
	dirEntryPtr = (FsDirEntry *) ((int)block + offset);
	offset += FillDirEntry(dirEntryPtr,"tooBig",6);
    
	dirEntryPtr = (FsDirEntry *) ((int)block + offset);
	offset += FillDirEntry(dirEntryPtr,"tooSmall",7);
    
	dirEntryPtr = (FsDirEntry *) ((int)block + offset);
	offset += FillDirEntry(dirEntryPtr,"holeFile",8);
    
	dirEntryPtr = (FsDirEntry *) ((int)block + offset);
	offset += FillDirEntry(dirEntryPtr,"holeDir",9);
    
	dirEntryPtr = (FsDirEntry *) ((int)block + offset);
	offset += FillDirEntry(dirEntryPtr,"badIndexFile",10);
    
	dirEntryPtr = (FsDirEntry *) ((int)block + offset);
	offset += FillDirEntry(dirEntryPtr,"illegalFrag",11);
    
	dirEntryPtr = (FsDirEntry *) ((int)block + offset);
	offset += FillDirEntry(dirEntryPtr,"copyBadFrag",12);
    
	dirEntryPtr = (FsDirEntry *) ((int)block + offset);
	offset += FillDirEntry(dirEntryPtr,"copyBlock",13);
    
	dirEntryPtr = (FsDirEntry *) ((int)block + offset);
	offset += FillDirEntry(dirEntryPtr,"copyIndBlock",14);
    
	dirEntryPtr = (FsDirEntry *) ((int)block + offset);
	offset += FillDirEntry(dirEntryPtr,"copyBogusInd",15);
	/*
	 * 16 and 17 are unreferenced.
	 */
    
	dirEntryPtr = (FsDirEntry *) ((int)block + offset);
	offset += FillDirEntry(dirEntryPtr,"output",18);

	dirEntryPtr->recordLength = FS_DIR_BLOCK_SIZE - offset +
				    dirEntryPtr->recordLength;

    for (dirEntryPtr = (FsDirEntry *)&block[FS_DIR_BLOCK_SIZE], i = 1; 
	 i < FS_BLOCK_SIZE / FS_DIR_BLOCK_SIZE;
	 i++,dirEntryPtr=(FsDirEntry *)((int)dirEntryPtr + FS_DIR_BLOCK_SIZE)) {
	 dirEntryPtr->fileNumber = 0;
	 dirEntryPtr->recordLength = FS_DIR_BLOCK_SIZE;
	 dirEntryPtr->nameLength = 0;
    }

    }
    if (printOnly) {
	printf("Root Directory\n");
	offset = 0;
	dirEntryPtr = (FsDirEntry *)block;
	while (offset + dirEntryPtr->recordLength != FS_DIR_BLOCK_SIZE) {
	    Disk_PrintDirEntry(dirEntryPtr);
	    offset += dirEntryPtr->recordLength;
	    dirEntryPtr = (FsDirEntry *)((int)block + offset);
	}
	status = SUCCESS;
    } else {
	/*
	 * This write trounces the data beyond the stuff allocated to
	 * the root directory.  Currently this is ok and is done because
	 * BlockWrite writes whole numbers of filesystem blocks.
	 */
	status = Disk_BlockWrite(partFID, headerPtr, headerPtr->dataOffset, 1,
				       block);
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * WriteLostFoundDirectory --
 *
 *	Write the data blocks of the lost and found directory.
 *
 * Results:
 *	A return code from the writes.
 *
 * Side effects:
 *	Write the root directory"s data block.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
WriteLostFoundDirectory(headerPtr, partFID)
    register FsDomainHeader *headerPtr;
    int partFID;
{
    ReturnStatus status;
    char *block;
    FsDirEntry *dirEntryPtr;
    char *fileName;
    int length;
    int offset;
    int	i;

    block = (char *)malloc(FS_NUM_LOST_FOUND_BLOCKS * FS_BLOCK_SIZE);
    dirEntryPtr = (FsDirEntry *)block;

    fileName = ".";
    length = strlen(fileName);
    dirEntryPtr->fileNumber = FS_LOST_FOUND_FILE_NUMBER;
    dirEntryPtr->recordLength = FsDirRecLength(length);
    dirEntryPtr->nameLength = length;
    strcpy(dirEntryPtr->fileName, fileName);
    offset = dirEntryPtr->recordLength;

    dirEntryPtr = (FsDirEntry *)((int)block + offset);
    fileName = "..";
    length = strlen(fileName);
    dirEntryPtr->fileNumber = FS_ROOT_FILE_NUMBER;
    dirEntryPtr->recordLength = FS_DIR_BLOCK_SIZE - offset;
    dirEntryPtr->nameLength = length;
    strcpy(dirEntryPtr->fileName, fileName);

    /*
     * Fill out the rest of the directory with empty blocks.
     */

    for (dirEntryPtr = (FsDirEntry *)&block[FS_DIR_BLOCK_SIZE], i = 1; 
	 i < FS_NUM_LOST_FOUND_BLOCKS * FS_BLOCK_SIZE / FS_DIR_BLOCK_SIZE;
	 i++,dirEntryPtr=(FsDirEntry *)((int)dirEntryPtr + FS_DIR_BLOCK_SIZE)) {
	 dirEntryPtr->fileNumber = 0;
	 dirEntryPtr->recordLength = FS_DIR_BLOCK_SIZE;
	 dirEntryPtr->nameLength = 0;
    }
    if (printOnly) {
	printf("Lost+found Directory\n");
	offset = 0;
	dirEntryPtr = (FsDirEntry *)block;
	Disk_PrintDirEntry(dirEntryPtr);
	offset += dirEntryPtr->recordLength;
	dirEntryPtr = (FsDirEntry *)((int)block + offset);
	Disk_PrintDirEntry(dirEntryPtr);
	status = SUCCESS;
    } else {
	status = Disk_BlockWrite(partFID, headerPtr, headerPtr->dataOffset + 1,
			    FS_NUM_LOST_FOUND_BLOCKS, block);
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 * WriteEmptyDirectory --
 *
 *	Write the data blocks of the empty directory (file 17).
 *
 * Results:
 *	A return code from the writes.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
ReturnStatus
WriteEmptyDirectory(headerPtr, partFID, selfFdNum, parentFdNum, blockNum)
    register FsDomainHeader *headerPtr;
    int partFID;
    int selfFdNum;
    int parentFdNum;
    int blockNum;
{
    ReturnStatus status;
    char *block;
    FsDirEntry *dirEntryPtr;
    char *fileName;
    int length;
    int offset;
    int	i;

    block = (char *)malloc(FS_BLOCK_SIZE);
    dirEntryPtr = (FsDirEntry *)block;

    fileName = ".";
    length = strlen(fileName);
    dirEntryPtr->fileNumber = selfFdNum;
    dirEntryPtr->recordLength = FsDirRecLength(length);
    dirEntryPtr->nameLength = length;
    strcpy(dirEntryPtr->fileName, fileName);
    offset = dirEntryPtr->recordLength;

    dirEntryPtr = (FsDirEntry *)((int)block + offset);
    fileName = "..";
    length = strlen(fileName);
    dirEntryPtr->fileNumber = parentFdNum;
    dirEntryPtr->recordLength = FS_DIR_BLOCK_SIZE - offset;
    dirEntryPtr->nameLength = length;
    strcpy(dirEntryPtr->fileName, fileName);

    /*
     * Fill out the rest of the directory with empty blocks.
     */

    for (dirEntryPtr = (FsDirEntry *)&block[FS_DIR_BLOCK_SIZE], i = 1; 
	 i < FS_BLOCK_SIZE / FS_DIR_BLOCK_SIZE;
	 i++,dirEntryPtr=(FsDirEntry *)((int)dirEntryPtr + FS_DIR_BLOCK_SIZE)) {
	 dirEntryPtr->fileNumber = 0;
	 dirEntryPtr->recordLength = FS_DIR_BLOCK_SIZE;
	 dirEntryPtr->nameLength = 0;
    }
    if (printOnly) {
	printf("empty Directory\n");
	offset = 0;
	dirEntryPtr = (FsDirEntry *)block;
	Disk_PrintDirEntry(dirEntryPtr);
	offset += dirEntryPtr->recordLength;
	dirEntryPtr = (FsDirEntry *)((int)block + offset);
	Disk_PrintDirEntry(dirEntryPtr);
	status = SUCCESS;
    } else {
	status = Disk_BlockWrite(partFID, headerPtr, headerPtr->dataOffset + 
				(blockNum / FS_FRAGMENTS_PER_BLOCK),
				1, block);
    }
    return(status);
}

/*
 *----------------------------------------------------------------------
 *
 *  FillDirEntry--
 *
 *	Fills in the directory entry.
 *
 * Results:
 *	None
 *
 * Side effects:
 *	None
 *
 *----------------------------------------------------------------------
 */
int
FillDirEntry(dirEntryPtr, fileName, fileNum)
    FsDirEntry *dirEntryPtr;
    char *fileName;
    int fileNum;
{
    int length;

    length = strlen(fileName);
    dirEntryPtr->fileNumber = fileNum;
    dirEntryPtr->recordLength = FsDirRecLength(length);
    dirEntryPtr->nameLength = length;
    strcpy(dirEntryPtr->fileName, fileName);
    return dirEntryPtr->recordLength;
}
@


1.3
log
@Fixed include
@
text
@d2 1
a2 1
 * makeFilesystem.c --
d4 30
a33 4
 *	Format a domain to be an empty domain.
 *
 * Copyright (C) 1986 Regents of the University of California
 * All rights reserved.
d37 1
a37 1
static char rcsid[] = "$Header: makeFilesystem.c,v 1.2 88/03/31 10:09:00 brent Exp $ SPRITE (Berkeley)";
a41 1
#include "io.h"
d43 4
d57 1
a57 1
Boolean makeFile = FALSE;	/* Make a file in the root directory,
d61 3
d78 1
a78 1
    {OPT_STRING, 'D', (Address)&deviceName,
d80 1
a80 1
    {OPT_STRING, 'P', (Address)&partName,
d82 3
a84 5
    {OPT_TRUE, 'f', (Address)&makeFile,
	"Make a file in the root directory (FALSE)"},
    {OPT_TRUE, 'O', (Address)&overlapBlocks,
	"Overlap filesystem blocks accross track boundaries (FALSE)"},
    {OPT_TRUE, 'c', (Address)&copySuperBlock,
d86 1
a86 1
    {OPT_INT, 'r', (Address)&kbytesToFileDesc,
d88 3
a90 3
    {OPT_TRUE, 't', (Address)&printOnly,
	"Test: print results, don't write disk (TRUE)"},
    {OPT_FALSE, 'W', (Address)&printOnly,
d92 1
a92 1
    {OPT_STRING, 'd', (Address)&devDirectory,
d94 1
a94 1
    {OPT_STRING, 'p', (Address)&firstPartName,
d96 7
d117 11
d165 1
d167 1
a167 1
    (void)Opt_Parse(&argc, argv, numOptions, optionArray);
d169 1
d171 1
a171 1
	Io_Print("Specify device name with -D option\n");
d175 1
a175 1
	Io_Print("Specify partition with -P option\n");
d179 10
a188 1
	Proc_Exit(status);
d191 1
d196 17
a212 18
    String_Copy(devDirectory, firstPartitionName);	/* eg. /dev/ */
    String_Copy(devDirectory, partitionName);
    String_Cat(deviceName, firstPartitionName);		/* eg. /dev/rxy0 */
    String_Cat(deviceName, partitionName);
    String_Cat(firstPartName, firstPartitionName);	/* eg. /dev/rxy0a */
    String_Cat(partName, partitionName);		/* eg. /dev/rxy0b */

    status = Fs_Open(firstPartitionName, FS_READ, 0, &firstPartFID);
    if (status != SUCCESS) {
	Io_PrintStream(io_StdErr, "Can't open first partition \"%s\" <%x>\n",
				  firstPartitionName, status);
	Proc_Exit(status);
    }
    status = Fs_Open(partitionName, FS_READ|FS_WRITE, 0, &partFID);
    if (status != SUCCESS) {
	Io_PrintStream(io_StdErr,"Can't open partition to format \"%s\" <%x>\n",
				  partitionName, status);
	Proc_Exit(status);
d217 1
a217 1
	Io_PrintStream(io_StdErr,
d219 1
a219 1
	Proc_Exit(FAILURE);
d229 1
a229 1
	Io_Print("Making filesystem for local host, ID = 0x%x\n", spriteID);
d232 1
a232 1
	Io_Print("Making filesystem for remote host 0x%x\n", spriteID);
d234 1
a234 1
    Io_Print("MakeFilesystem based on 4K filesystem blocks\n");
d237 5
a241 5
    Io_Flush(io_StdErr);
    Io_Flush(io_StdOut);
    (void)Fs_Close(firstPartFID);
    (void)Fs_Close(partFID);
    Proc_Exit(status);
d249 1
a249 1
 *	Format a disk partition, or domain, to be an empty filesystem.
d268 1
a268 2
    register int numBlocks;
    BasicDiskInfo *diskInfoPtr;
d276 3
a278 2
    diskInfoPtr = ReadBasicDiskInfo(firstPartFID, partition);
    if (diskInfoPtr == (BasicDiskInfo *)0) {
d282 2
a283 2
    headerPtr = (FsDomainHeader *) Mem_Alloc(diskInfoPtr->numDomainSectors *
					     DEV_BYTES_PER_SECTOR);
d285 1
a285 1
    PrintDomainHeader(headerPtr);
d291 1
a291 2
		Io_PrintStream(io_StdErr, "CopySuperBlock failed <%x>\n",
					  status);
d295 1
a295 1
	status = SectorWrite(partFID, diskInfoPtr->domainSector,
d298 1
a298 2
	    Io_PrintStream(io_StdErr, "DomainHeader write failed <%x>\n",
				      status);
d302 1
a302 1
    summaryPtr = (FsSummaryInfo *) Mem_Alloc(DEV_BYTES_PER_SECTOR);
d304 1
a304 1
    PrintSummaryInfo(summaryPtr);
d306 1
a306 1
	status = SectorWrite(partFID, diskInfoPtr->summarySector, 1,
d309 1
a309 2
	    Io_PrintStream(io_StdErr, "DomainHeader write failed <%x>\n",
				      status);
d316 1
a316 1
	Io_PrintStream(io_StdErr, "WriteFileDesc failed <%x>\n", status);
d321 1
a321 1
	Io_PrintStream(io_StdErr, "WriteBitmap failed <%x>\n", status);
d326 1
a326 1
	Io_PrintStream(io_StdErr, "WriteRootDirectory failed <%x>\n", status);
d331 11
a341 2
	Io_PrintStream(io_StdErr, "WriteLostFoundDirectory failed <%x>\n", 
			status);
d371 1
a371 1
    block = (char *)Mem_Alloc(DEV_BYTES_PER_SECTOR);
d373 1
a373 1
    status = SectorRead(firstPartFID, 0, 1, block);
d377 1
a377 1
    status = SectorWrite(partFID, 0, 1, block);
d399 1
a399 1
    BasicDiskInfo *diskInfoPtr;	/* Information from the super block */
a403 1
    ReturnStatus status;	/* General return code. */
d411 1
a411 1
     * the host's spriteID if reverse arp couldn't find a host ID.  The
d413 1
a413 1
     * domain header applies to.  For example, both the 'a' and 'c' partitions
d452 1
a452 1
    register BasicDiskInfo *diskInfoPtr;/* Basic geometry information */
d482 2
a483 2
	    extraSectors = geoPtr->sectorsPerTrack % SECTORS_PER_BLOCK;
	    if (extraSectors < SECTORS_PER_BLOCK/4) {
d491 2
a492 2
		offsetIncrement = SECTORS_PER_BLOCK/4;
	    } else if (extraSectors < SECTORS_PER_BLOCK/2) {
d498 2
a499 2
		offsetIncrement = SECTORS_PER_BLOCK * 3/4;
	    } else if (extraSectors < SECTORS_PER_BLOCK * 3/4) {
d505 1
a505 1
		offsetIncrement = SECTORS_PER_BLOCK/2;
d512 1
a512 1
		offsetIncrement = SECTORS_PER_BLOCK/4;
d524 3
a526 3
	    offsetIncrement = SECTORS_PER_BLOCK/2;
	    if ((geoPtr->sectorsPerTrack % SECTORS_PER_BLOCK) <
		      SECTORS_PER_BLOCK/2) {
d537 1
a537 1
    Io_Print("overlap %s, offsetIncrement %d\n", (overlap ? "TRUE" : "FALSE"),
d546 1
a546 1
	if (extraSectors >= SECTORS_PER_BLOCK) {
d552 2
a553 2
	    offset += SECTORS_PER_BLOCK;
	    extraSectors -= SECTORS_PER_BLOCK;
d610 1
a610 1
    offsetIncrement = SECTORS_PER_BLOCK / tracksPerSet;
d639 1
a639 1
    register BasicDiskInfo *diskInfoPtr;
a650 1
    int index;			/* Array index */
d664 1
a664 1
    Io_Print("Reserving %d blocks for domain header, etc.\n",
d677 1
a677 1
	    numFiles = numBlocks * KBYTES_PER_BLOCK / kbytesToFileDesc;
d679 1
a679 1
	numFiles		  &= ~(FILE_DESC_PER_BLOCK-1);
d690 2
a691 2
	numBlocks		  -= numFiles / FILE_DESC_PER_BLOCK;
	offset			  += numFiles / FILE_DESC_PER_BLOCK;
d702 1
a702 1
	bitmapBytes		  = (headerPtr->dataBlocks * KBYTES_PER_BLOCK -
d719 1
a719 1
	    numFiles -= numBlocksNeeded * FILE_DESC_PER_BLOCK;
d730 1
a730 1
	    numFiles += extraBlocks * FILE_DESC_PER_BLOCK;
d743 2
a744 2
 *	Initialize the summary information for the domain.  It is well
 *	known that this occupies one sector.
d756 1
a756 1
    BasicDiskInfo *diskInfoPtr;	/* Information from the super block */
a759 1
    ReturnStatus status;	/* General return code. */
d761 1
a761 1
    Byte_Zero(DEV_BYTES_PER_SECTOR, (Address)summaryPtr);
d763 1
a763 1
    String_Copy("(new domain)", summaryPtr->domainPrefix);
d774 1
a774 1
    summaryPtr->numFreeFileDesc = headerPtr->numFileDesc - 4;
d784 1
a784 1
     * recorded on disk so servers re-attach disks under the same 'name'.
d791 1
a791 1
     * safely 'sync'ed to disk upon shutdown.
d794 1
d825 1
a825 1
	status = BlockWrite(partFID, headerPtr, headerPtr->fdBitmapOffset,
d837 2
a838 2
    block = (char *)Mem_Alloc(FS_BLOCK_SIZE);
    Byte_Zero(FS_BLOCK_SIZE, block);
d840 1
a840 1
         index < FILE_DESC_PER_BLOCK;
d853 3
a855 1
	} else if ((index == FS_LOST_FOUND_FILE_NUMBER+1) && makeFile) {
d857 26
d892 1
a892 1
	status = BlockWrite(partFID, headerPtr, headerPtr->fileDescOffset,
d900 1
a900 1
	Byte_Zero(FS_BLOCK_SIZE, block);
d902 1
a902 1
	     index < FILE_DESC_PER_BLOCK;
d912 1
a912 1
	for (index = FILE_DESC_PER_BLOCK;
d914 3
a916 3
	     index += FILE_DESC_PER_BLOCK) {
	    status = BlockWrite(partFID, headerPtr,
		     headerPtr->fileDescOffset + (index/FILE_DESC_PER_BLOCK),
d927 1
a927 1

d929 1
a929 75
 *----------------------------------------------------------------------
 *
 * SetRootFileDescriptor --
 *
 *	Set up the file descriptor for the root directory.
 *
 * Results:
 *	Fill in the file descriptor.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
SetRootFileDescriptor(fileDescPtr)
    register FsFileDescriptor *fileDescPtr;
{
    Time time;
    int index;

    fileDescPtr->flags = FS_FD_ALLOC;
    fileDescPtr->fileType = FS_DIRECTORY;
    fileDescPtr->permissions = 0755;
    fileDescPtr->uid = 0;
    fileDescPtr->gid = 0;
    fileDescPtr->lastByte = FS_DIR_BLOCK_SIZE-1;
    fileDescPtr->firstByte = -1;
    fileDescPtr->numLinks = 3;
    /*
     * Can't know device information because that depends on
     * the way the system is configured.
     */
    fileDescPtr->devServerID = -1;
    fileDescPtr->devType = -1;
    fileDescPtr->devUnit = -1;

    /*
     * Set the time stamps.  This assumes that universal time, not local
     * time, is used for time stamps.
     */
    Sys_GetTimeOfDay(&time, NULL, NULL);
    fileDescPtr->createTime = time.seconds;
    fileDescPtr->accessTime = 0;
    fileDescPtr->descModifyTime = time.seconds;
    fileDescPtr->dataModifyTime = time.seconds;

    /*
     * Place the data in the first filesystem block.
     */
    fileDescPtr->direct[0] = 0;
    for (index = 1; index < FS_NUM_DIRECT_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FS_NIL_INDEX;
    }
    for (index = 0; index < FS_NUM_INDIRECT_BLOCKS ; index++) {
	fileDescPtr->indirect[index] = FS_NIL_INDEX;
    }
    fileDescPtr->numKbytes = 1;
    fileDescPtr->version = 1;
}

/*
 *----------------------------------------------------------------------
 *
 * SetBadBlockFileDescriptor --
 *
 *	Set up the file descriptor for the bad block file.
 *
 * Results:
 *	Fill in the file descriptor.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
a930 67
void
SetBadBlockFileDescriptor(fileDescPtr)
    register FsFileDescriptor *fileDescPtr;
{
    Time time;
    int index;

    fileDescPtr->flags = FS_FD_ALLOC;
    fileDescPtr->fileType = FS_FILE;
    fileDescPtr->permissions = 0000;
    fileDescPtr->uid = 0;
    fileDescPtr->gid = 0;
    fileDescPtr->lastByte = -1;
    fileDescPtr->firstByte = -1;
    fileDescPtr->numLinks = 0;		/* Intentionally unreferenced */
    /*
     * Can't know device information because that depends on
     * the way the system is configured.
     */
    fileDescPtr->devServerID = -1;
    fileDescPtr->devType = -1;
    fileDescPtr->devUnit = -1;

    /*
     * Set the time stamps.  This assumes that universal time, not local
     * time, is used for time stamps.
     */
    Sys_GetTimeOfDay(&time, NULL, NULL);
    fileDescPtr->createTime = time.seconds;
    fileDescPtr->accessTime = 0;
    fileDescPtr->descModifyTime = time.seconds;
    fileDescPtr->dataModifyTime = time.seconds;

    /*
     * Place the data in the first filesystem block.
     */
    for (index = 0; index < FS_NUM_DIRECT_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FS_NIL_INDEX;
    }
    for (index = 0; index < FS_NUM_INDIRECT_BLOCKS ; index++) {
	fileDescPtr->indirect[index] = FS_NIL_INDEX;
    }
    fileDescPtr->numKbytes = 0;
    fileDescPtr->version = 1;
}

/*
 *----------------------------------------------------------------------
 *
 * SetLostFoundFileDescriptor --
 *
 *	Set up the file descriptor for the lost and found directory.
 *
 * Results:
 *	Fill in the file descriptor.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
SetLostFoundFileDescriptor(fileDescPtr)
    register FsFileDescriptor *fileDescPtr;
{
    Time time;
    int index;
d932 1
a932 60
    fileDescPtr->flags = FS_FD_ALLOC;
    fileDescPtr->fileType = FS_DIRECTORY;
    fileDescPtr->permissions = 0755;
    fileDescPtr->uid = 0;
    fileDescPtr->gid = 0;
    fileDescPtr->lastByte = FS_NUM_LOST_FOUND_BLOCKS * FS_BLOCK_SIZE - 1;
    fileDescPtr->firstByte = -1;
    fileDescPtr->numLinks = 2;
    /*
     * Can't know device information because that depends on
     * the way the system is configured.
     */
    fileDescPtr->devServerID = -1;
    fileDescPtr->devType = -1;
    fileDescPtr->devUnit = -1;

    /*
     * Set the time stamps.  This assumes that universal time, not local
     * time, is used for time stamps.
     */
    Sys_GetTimeOfDay(&time, NULL, NULL);
    fileDescPtr->createTime = time.seconds;
    fileDescPtr->accessTime = 0;
    fileDescPtr->descModifyTime = time.seconds;
    fileDescPtr->dataModifyTime = time.seconds;

    for (index = 0; index < FS_NUM_LOST_FOUND_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FS_FRAGMENTS_PER_BLOCK * (index + 1);
    }
    for (; index < FS_NUM_DIRECT_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FS_NIL_INDEX;
    }
    for (index = 0; index < FS_NUM_INDIRECT_BLOCKS ; index++) {
	fileDescPtr->indirect[index] = FS_NIL_INDEX;
    }
    fileDescPtr->numKbytes = 8;
    fileDescPtr->version = 1;
}

/*
 *----------------------------------------------------------------------
 *
 * SetEmptyFileDescriptor --
 *
 *	Set up a file descriptor for an empty file.
 *
 * Results:
 *	Fill in the file descriptor.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
SetEmptyFileDescriptor(fileDescPtr)
    register FsFileDescriptor *fileDescPtr;
{
    Time time;
    int index;
a933 35
    fileDescPtr->flags = FS_FD_ALLOC;
    fileDescPtr->fileType = FS_FILE;
    fileDescPtr->permissions = 0666;
    fileDescPtr->uid = 0;
    fileDescPtr->gid = 0;
    fileDescPtr->lastByte = -1;
    fileDescPtr->firstByte = -1;
    fileDescPtr->numLinks = 1;
    /*
     * Can't know device information because that depends on
     * the way the system is configured.
     */
    fileDescPtr->devServerID = -1;
    fileDescPtr->devType = -1;
    fileDescPtr->devUnit = -1;

    /*
     * Set the time stamps.  This assumes that universal time, not local
     * time, is used for time stamps.
     */
    Sys_GetTimeOfDay(&time, NULL, NULL);
    fileDescPtr->createTime = time.seconds;
    fileDescPtr->accessTime = 0;
    fileDescPtr->descModifyTime = time.seconds;
    fileDescPtr->dataModifyTime = time.seconds;

    for (index = 0; index < FS_NUM_DIRECT_BLOCKS ; index++) {
	fileDescPtr->direct[index] = FS_NIL_INDEX;
    }
    for (index = 0; index < FS_NUM_INDIRECT_BLOCKS ; index++) {
	fileDescPtr->indirect[index] = FS_NIL_INDEX;
    }
    fileDescPtr->numKbytes = 0;
    fileDescPtr->version = 1;
}
d938 1
a954 1
    ReturnStatus status;
d959 1
a959 1
     * Allocate and initialize the bitmap to all 0's to mean all free.
d961 1
a961 1
    bitmap = (char *)Mem_Alloc(headerPtr->fdBitmapBlocks *
d963 1
a963 12
    Byte_Zero(headerPtr->fdBitmapBlocks * FS_BLOCK_SIZE, (Address)bitmap);

    /*
     * Reserve file descriptors 0, 1, 2, and 3.  File number 0 is not used at 
     * all in the filesystem.  File number 1 is for the file with bad blocks.
     * File number 2 (FS_ROOT_FILE_NUMBER) is the root directory of the domain.
     * File number 3 (FS_LOST_FOUND_NUMBER) is the directory where lost
     * files are stored.
     *
     * IF THIS CHANGES remember to fix SetSummaryInfo
     */
    bitmap[0] |= 0xf0;
d965 22
d988 1
a988 1
     * Reserve file descriptor # 4 for an empty file.
d990 1
a990 3
    if (makeFile) {
	bitmap[0] |= 0x08;
    }
d1013 1
a1013 1
	PrintFileDescBitmap(headerPtr, bitmap);
d1017 8
d1033 2
a1034 1
 *	allocated to lost and found.
d1055 2
a1056 2
    bitmap = (char *)Mem_Alloc(headerPtr->bitmapBlocks * FS_BLOCK_SIZE);
    Byte_Zero(headerPtr->bitmapBlocks * FS_BLOCK_SIZE, bitmap);
d1063 1
a1063 1
     * IF THIS CHANGES remember to fix SetSummaryInfo()
d1065 29
a1093 2
    bitmap[0] |= 0x8f;
    bitmap[1] |= 0xf0;
d1099 1
a1099 1
    kbytesPerCyl = headerPtr->geometry.blocksPerCylinder * KBYTES_PER_BLOCK;
d1112 1
a1112 1
	 * Set up a mask that has the right part filled with 1's.
d1119 1
a1119 1
	     index < headerPtr->dataBlocks * KBYTES_PER_BLOCK / BITS_PER_BYTE;
d1136 1
a1136 1
	PrintDataBlockBitmap(headerPtr, bitmap);
d1139 1
a1139 1
	status = BlockWrite(partFID, headerPtr, headerPtr->bitmapOffset,
d1156 1
a1156 1
 *	Write the root directory's data block.
d1166 1
a1166 1
    char *block;
a1167 2
    char *fileName;
    int length;
d1169 1
d1171 1
a1171 2
    block = (char *)Mem_Alloc(FS_BLOCK_SIZE);
    dirEntryPtr = (FsDirEntry *)block;
d1173 1
a1173 7
    fileName = ".";
    length = String_Length(fileName);
    dirEntryPtr->fileNumber = FS_ROOT_FILE_NUMBER;
    dirEntryPtr->recordLength = FsDirRecLength(length);
    dirEntryPtr->nameLength = length;
    String_Copy(fileName, dirEntryPtr->fileName);
    offset = dirEntryPtr->recordLength;
d1175 3
a1177 8
    dirEntryPtr = (FsDirEntry *)((int)block + offset);
    fileName = "..";
    length = String_Length(fileName);
    dirEntryPtr->fileNumber = FS_ROOT_FILE_NUMBER;
    dirEntryPtr->recordLength = FsDirRecLength(length);
    dirEntryPtr->nameLength = length;
    String_Copy(fileName, dirEntryPtr->fileName);
    offset += dirEntryPtr->recordLength;
d1179 53
a1231 3
    /*
     * Add lost and found.
     */
d1233 2
a1234 6
    dirEntryPtr = (FsDirEntry *) ((int)block + offset);
    fileName = "lost+found";
    length = String_Length(fileName);
    dirEntryPtr->fileNumber = FS_LOST_FOUND_FILE_NUMBER;
    dirEntryPtr->nameLength = length;
    String_Copy(fileName, dirEntryPtr->fileName);
d1236 6
a1241 12
    if (!makeFile) {
	dirEntryPtr->recordLength = FS_DIR_BLOCK_SIZE - offset;
    } else {
	dirEntryPtr->recordLength = FsDirRecLength(length);
	offset += dirEntryPtr->recordLength;
	dirEntryPtr = (FsDirEntry *)((int)block + offset);
	fileName = "testFile";
	length = String_Length(fileName);
	dirEntryPtr->fileNumber = FS_LOST_FOUND_FILE_NUMBER + 1;
	dirEntryPtr->nameLength = length;
	String_Copy(fileName, dirEntryPtr->fileName);
	dirEntryPtr->recordLength = FS_DIR_BLOCK_SIZE - offset;
d1244 1
d1246 1
a1246 1
	Io_Print("Root Directory\n");
d1249 2
a1250 5
	PrintDirEntry(dirEntryPtr);
	offset += dirEntryPtr->recordLength;
	dirEntryPtr = (FsDirEntry *)((int)block + offset);
	PrintDirEntry(dirEntryPtr);
	if (makeFile) {
a1252 1
	    PrintDirEntry(dirEntryPtr);
d1261 1
a1261 1
	status = BlockWrite(partFID, headerPtr, headerPtr->dataOffset, 1,
d1278 1
a1278 1
 *	Write the root directory's data block.
d1295 1
a1295 1
    block = (char *)Mem_Alloc(FS_NUM_LOST_FOUND_BLOCKS * FS_BLOCK_SIZE);
d1299 1
a1299 1
    length = String_Length(fileName);
d1303 1
a1303 1
    String_Copy(fileName, dirEntryPtr->fileName);
d1308 1
a1308 1
    length = String_Length(fileName);
d1312 1
a1312 1
    String_Copy(fileName, dirEntryPtr->fileName);
d1326 1
a1326 1
	Io_Print("Lost+found Directory\n");
d1329 1
a1329 1
	PrintDirEntry(dirEntryPtr);
d1332 1
a1332 1
	PrintDirEntry(dirEntryPtr);
d1335 1
a1335 1
	status = BlockWrite(partFID, headerPtr, headerPtr->dataOffset + 1,
d1339 109
@


1.2
log
@Added bad block file descriptor and summary sector
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: makeFilesystem.c,v 1.1 87/10/20 11:01:23 brent Exp $ SPRITE (Berkeley)";
d17 1
a17 1
#include "fsDisk.h"
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
static char rcsid[] = "$Header: makeFilesystem.c,v 1.7 87/07/14 11:43:34 brent Exp $ SPRITE (Berkeley)";
d77 1
d225 1
a225 1
    SetDomainHeader(diskInfoPtr, headerPtr, spriteID);
d333 1
a333 1
SetDomainHeader(diskInfoPtr, headerPtr, spriteID)
d337 1
d346 7
a352 3
     * Only the device.serverID from the disk is used.  It is examined
     * during boot to discover the host's spriteID if reverse arp
     * couldn't find a host ID.
d356 1
a356 1
    headerPtr->device.unit = -1;
d717 1
a717 1
     * The summary state is unused.
d720 12
d769 4
a772 1
     * Make the first block of file descriptors.
d782 1
a782 1
	if (index < ROOT_FILE_NUMBER) {
d784 3
a786 1
	} else if (index == ROOT_FILE_NUMBER) {
d902 61
d1112 1
a1112 1
     * File number 2 (ROOT_FILE_NUMBER) is the root directory of the domain.
d1276 1
a1276 1
    dirEntryPtr->fileNumber = ROOT_FILE_NUMBER;
d1285 1
a1285 1
    dirEntryPtr->fileNumber = ROOT_FILE_NUMBER;
@
