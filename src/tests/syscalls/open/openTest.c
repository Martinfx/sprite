/*
 * openTest.c --
 *	Test of the open system call. 
 *
 *
 *
 */

#include <sprite.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/file.h>

#define SHOULD_SUCCEED      0
#define SHOULD_FAIL         1

static int errors;
static char *progname;

#ifdef __STDC__
static void openTest(void);
static void checkOpen(char *pathname, int flags, int mode, int succeed, 
                      int error, char *string);
#else
static void openTest();
static void checkOpen();
#endif

void
main(argc, argv)
    int argc;
    char **argv;
{

    progname = argv[0];
    openTest();
    exit((errors == 0) ? EXIT_SUCCESS : EXIT_FAILURE);
}

static void
checkOpen(pathname, flags, mode, succeed, err, string)
    char *pathname;
    int flags;
    int mode;
    int succeed;
    int err;
    char *string;
{
    int fd;

    if ((fd = open(pathname, flags, mode)) == -1) {
	if (succeed == SHOULD_SUCCEED) {
	    (void) fprintf(stderr, "%s: %s\n", progname, string);
	    (void) fprintf(stderr, "Open failed: %s\n", strerror(errno));
	    ++errors;
	    return;
	}
	if (errno != err) {
	    (void) fprintf(stderr, "%s: %s\n", progname, string);
	    (void) fprintf(stderr, "Wrong errno (%d): %s\n",
		errno, strerror(errno));
	    (void) fprintf(stderr, "Should be (%d): %s\n",
		err, strerror(err));
	}
	return;
    }
    if (succeed == SHOULD_FAIL) {
	(void) fprintf(stderr, "%s: %s\n", progname, string);
	(void) fprintf(stderr, "Open succeeded, should have failed\n");
	++errors;
    }
    if (close(fd)) {
	(void) fprintf(stderr, "%s: close failed: %s\n",
	    progname, strerror(errno));
	++errors;
    }
    return;
}

static void
openTest()
{
    char tempfile[MAXPATHLEN];
    char longname[2 * MAXPATHLEN];
    int fd, fd2;

    /*
     *      Test bad pathname argument.
     */
    checkOpen((char *) -1, 0, 0, SHOULD_FAIL, EFAULT, "open(-1, 0, 0)");
    checkOpen((char *) NULL, 0, 0, SHOULD_FAIL, EFAULT, "open(NULL, 0, 0)");

    /*
     *      Check long filename
     */
    memset(longname, 'x', sizeof(longname));
    checkOpen(longname, O_RDWR|O_CREAT, 0666, SHOULD_FAIL, ENAMETOOLONG,
	"pathname too long");

    /*
     *      Create and open a temporary file.
     */
    if (tmpnam(tempfile) != tempfile) {
	(void) fprintf(stderr, "tmpnam() returned an incorrect value.\n");
	++errors;
	return;
    }
    checkOpen(tempfile, O_CREAT, 0, SHOULD_SUCCEED, 0,
	"Create and open a temporary file");

    /*
     *      Try to do an exclusive open of an existing file.
     */
    checkOpen(tempfile, O_CREAT|O_EXCL, 0, SHOULD_FAIL, EEXIST,
	"Exclusive open of existing file");

    /*
     *      Open a file for reading, without read permission.
     */
    checkOpen(tempfile, O_RDONLY, 0, SHOULD_FAIL, EACCES,
              "Open file for reading with no read permission");

    if (chmod(tempfile, 0444)) {
	(void) fprintf(stderr, "chmod 0444 of %s failed: %s\n",
	    tempfile, strerror(errno));
	++errors;
    }

    /*
     *      Open a file for reading.
     */
    checkOpen(tempfile, O_RDONLY, 0, SHOULD_SUCCEED, 0,
	"Open file for reading");

    /*
     *      Open a file for writing without write permission.
     */
    checkOpen(tempfile, O_WRONLY, 0, SHOULD_FAIL, EACCES,
              "Open file for writing");

    if (chmod(tempfile, 0666)) {
	(void) fprintf(stderr, "chmod 0666 of %s failed: %s\n",
	    tempfile, strerror(errno));
	++errors;
    }

    /*
     *      Open a file for writing with write permission.
     */
    checkOpen(tempfile, O_WRONLY, 0, SHOULD_SUCCEED, 0,
              "Open file for writing");


    /*
     *      Open a busy executable for writing
     */
    checkOpen("/bin/csh", O_WRONLY, 0, SHOULD_FAIL, ETXTBSY,
	      "Open of /bin/csh for writing");

    /*
     *      open a  directory for writing
     */
    checkOpen(".", O_WRONLY, 0, SHOULD_FAIL, EISDIR,
	"open a  directory for writing!\n");

    if (unlink(tempfile)) {
	(void) fprintf(stderr, "Can't unlink %s: %s\n",
	    tempfile, strerror(errno));
	++errors;
    }
    return;
}

