/* 
 * rpcRecovery.c --
 *
 *	The routines here monitor other hosts on behalf interested parties.
 *	Regular message	traffic plus explicit pings are used to determine
 *	the state of other hosts.  RpcHostAlive is the main internal
 *	entry point.  It is called when a message arrives from another host.
 *	Rpc_RebootNotify is used to arrange a call-back when a host reboots.
 *	Rpc_WaitForHost is used to block a process until a host comes back up.
 *	Rpc_HostIdDown is a boolean function that's TRUE if the host is down.
 *
 *	The impact of these recovery hooks on the RPC system is that service
 *	requests from a client that is just rebooting are blocked until
 *	the recovery actions complete.
 *
 * Copyright 1987 Regents of the University of California
 * All rights reserved.
 */

#ifndef lint
static char rcsid[] = "$Header$ SPRITE (Berkeley)";
#endif not lint


#include "sprite.h"
#include "rpc.h"
#include "rpcInt.h"
#include "sync.h"
#include "hash.h"
#include "trace.h"

/*
 * The state of other hosts is kept in a hash table keyed on SpriteID.
 * The host state records if the host is up or down, keeps a boot time stamp
 * so you can watch for reboots, and includes a
 * condition variable to notify when the host's state changes.
 */
static Hash_Table	recoveryHashTableStruct;
static Hash_Table	*recovHashTable = &recoveryHashTableStruct;

typedef struct RecovHostState {
    int			state;		/* flags defined below */
    int			clientState;	/* flags defined in rpc.h */
    int			spriteID;	/* Sprite Host ID */
    int			bootID;		/* Timestamp from RPC header */
    Time		time;		/* Time of last message */
    Sync_Condition	alive;		/* Notified when host comes up */
    Sync_Condition	recovery;	/* Notified when recovery is complete */
} RecovHostState;

/*
 * Access to the hash table is monitored.
 */
Sync_Lock rpcRecoveryLock;
#define LOCKPTR (&rpcRecoveryLock)

/*
 * Host state:
 *	RECOV_STATE_UNKNOWN	Initial state.
 *	RECOV_HOST_ALIVE	Set when we receive a message from the host
 *	RECOV_HOST_DEAD		Set when an RPC times out.
 *	RECOV_STATE_RECOVERING	Set when the boot time stamp of a peer host
 *				changes, or the host appears down.  Reset
 *				when the recovery actions have completed.
 *	RECOV_WAITING		artificial state to trace Rpc_WaitForHost
 *	RECOV_CRASH		artificial state to trace RpcCrashCallBacks
 *	RECOV_REBOOT		artificial state to trace RpcRebootCallBacks
 */
#define RECOV_STATE_UNKNOWN	0x0
#define RECOV_HOST_ALIVE	0x1
#define RECOV_HOST_DEAD		0x2

#define RECOV_STATE_RECOVERING	0x0100

#define RECOV_WAITING		0x4
#define RECOV_CRASH		0x8
#define RECOV_REBOOT		0x10

/*
 * A host is "pinged" when it goes down, at an interval determined by
 * rpcPingSeconds.
 */
int rpcPingSeconds = 30;

/*
 * Other kernel modules can arrange call-backs when a host reboots.
 * The following list structure is used to keep these.
 */

typedef struct {
    List_Links	links;
    void	(*proc)();
    int		flags;		/* RPC_WHEN_HOST_DOWN, RPC_WHEN_HOST_REBOOTS */
    ClientData	clientData;
} NotifyElement;

List_Links	rpcNotifyList;

/*
 * A trace is kept for debugging/understanding the host state transisions.
 */
typedef struct RpcRecovTraceRecord {
    int		spriteID;		/* Host ID whose state changed */
    int		state;			/* Their new state */
} RpcRecovTraceRecord;

/*
 * Tracing events, these describe the trace record.
 *	RECOV_CUZ_WAIT		Wait in Rpc_WaitForHost
 *	RECOV_CUZ_WAKEUP	Wakeup in Rpc_WaitForHost
 *	RECOV_CUZ_INIT		First time we were interested in the host
 *	RECOV_CUZ_REBOOT	We detected a reboot
 *	RECOV_CUZ_CRASH		We detected a crash
 *	RECOV_CUZ_DONE		Recovery actions completed
 *	RECOV_CUZ_PING		We are pinging the host
 */
#define RECOV_CUZ_WAIT		0x1
#define RECOV_CUZ_WAKEUP	0x2
#define RECOV_CUZ_INIT		0x4
#define RECOV_CUZ_REBOOT	0x8
#define RECOV_CUZ_CRASH		0x10
#define RECOV_CUZ_DONE		0x20
#define RECOV_CUZ_PING		0x40

Trace_Header rpcRecovTraceHdr;
Trace_Header *rpcRecovTraceHdrPtr = &rpcRecovTraceHdr;
int rpcRecovTraceLength = 50;
Boolean rpcRecovTracing = TRUE;

#ifndef CLEAN

#define RECOV_TRACE(zspriteID, zstate, event) \
    if (rpcRecovTracing) {\
	RpcRecovTraceRecord rec;\
	rec.spriteID = zspriteID;\
	rec.state = zstate;\
	Trace_Insert(rpcRecovTraceHdrPtr, event, &rec);\
    }
#else

#define RECOV_TRACE(zspriteID, zstate, event)

#endif not CLEAN
/*
 * Forward declarations.
 */
void RpcHostCheck();
void RpcRebootCallBacks();
void RpcCrashCallBacks();
void MarkHostDead();
void MarkRecoveryComplete();


/*
 *----------------------------------------------------------------------
 *
 * RpcInitRecovery --
 *
 *	Set up the data structures used by the RpcRecovery module.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
RpcInitRecovery()
{
    Hash_Init(recovHashTable, 8, HASH_ONE_WORD_KEYS);
    List_Init(&rpcNotifyList);
    Trace_Init(rpcRecovTraceHdrPtr, rpcRecovTraceLength,
		sizeof(RpcRecovTraceRecord), 0);
}

/*
 *----------------------------------------------------------------------
 *
 * Rpc_HostNotify --
 *
 *	Add a call-back for other modules to use when a host crashes/reboots.
 *	The 'when' parameter specifies when to callback the client procedure.
 *	If RPC_WHEN_HOST_DOWN then the procedure is called when the RPC
 *	module has gotten a timeout trying to reach the host.  If it is
 *	RPC_WHEN_HOST_REBOOTS then the call-back is made when the RPC
 *	module detects a reboot due to the bootID changing.  If both
 *	are specified then the call-back is made at both times.
 *	
 * Results:
 *	None.
 *
 * Side effects:
 *	Entry added to notify list.
 *
 *----------------------------------------------------------------------
 */
void
Rpc_HostNotify(proc, clientData, when)
    void	(*proc)();
    ClientData	clientData;
    int		when;		/* RPC_WHEN_HOST_DOWN, RPC_WHEN_HOST_REBOOTS */
{
    register	NotifyElement	*notifyPtr;

    notifyPtr = (NotifyElement *) Mem_Alloc(sizeof(NotifyElement));
    notifyPtr->proc = proc;
    notifyPtr->clientData = clientData;
    notifyPtr->flags = when;
    List_InitElement((List_Links *) notifyPtr);
    List_Insert((List_Links *) notifyPtr, LIST_ATREAR(&rpcNotifyList));
}

/*
 *----------------------------------------------------------------------
 *
 * Rpc_WaitForHost --
 *
 *	Block the current process (at an interruptable priority) until
 *	the given host comes back up.  This is used when retrying
 *	filesystem operations when a fileserver goes down, for example.
 *
 * Results:
 *	TRUE if the wait was interrupted.
 *
 * Side effects:
 *	The current process is blocked
 *	until messages from the host indicate it is up.
 *
 *----------------------------------------------------------------------
 */
Boolean
Rpc_WaitForHost(spriteID)
    int spriteID;			/* Host to monitor */
{
    /*
     * Set up the hosts state (dead or alive) by pinging it.
     * If it's down we drop into a monitored routine to do 
     * the actual waiting.  It will check again to make sure
     * we don't sleep on an alive host.
     */
    if (Rpc_HostIsDown(spriteID)) {
	RECOV_TRACE(spriteID, RECOV_STATE_UNKNOWN, RECOV_CUZ_WAIT);
	return(RpcWaitForHostInt(spriteID));
    } else {
	return(FALSE);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * RpcWaitForHostInt --
 *
 *	Block the current process (at an interruptable priority) until
 *	the given host comes back up.  This is used when retrying
 *	filesystem operations when a fileserver goes down, for example.
 *
 * Results:
 *	TRUE is the wait was interrupted by a signal.
 *
 * Side effects:
 *	If the host is thought down, the current process is blocked
 *	until messages from the host indicate it is up.
 *
 *----------------------------------------------------------------------
 */
ENTRY Boolean
RpcWaitForHostInt(spriteID)
    int spriteID;			/* Host to monitor */
{
    Hash_Entry *hashPtr;
    RecovHostState *hostPtr;
    Boolean sigPending = FALSE;

    LOCK_MONITOR;

    if (spriteID <= 0 || spriteID == rpc_SpriteID) {
	Sys_Panic(SYS_FATAL, "RpcWaitForHostInt, bad hostID %d\n", spriteID);
	UNLOCK_MONITOR;
	return(FALSE);
    }

    /*
     * Make sure the host table entry exists, then mark the host down.
     * That triggers a backgound pinging to detect when the host comes up.
     */
    hashPtr = Hash_Find(recovHashTable, spriteID);
    if (hashPtr->value == (Address)NIL) {
	hashPtr->value = (Address)Mem_Alloc(sizeof(RecovHostState));
	hostPtr = (RecovHostState *)hashPtr->value;
	hostPtr->state = RECOV_STATE_UNKNOWN;
	hostPtr->spriteID = spriteID;
	hostPtr->bootID = 0;
    } else {
	hostPtr = (RecovHostState *)hashPtr->value;
    }
    while (!sigPending && (hostPtr->state & RECOV_HOST_DEAD)) {
	sigPending = Sync_Wait(&hostPtr->alive, TRUE);
    }
    RECOV_TRACE(hostPtr->spriteID, hostPtr->state, RECOV_CUZ_WAKEUP);

    UNLOCK_MONITOR;
    return(sigPending);
}

/*
 *----------------------------------------------------------------------
 *
 * RpcHostAlive --
 *
 *	Mark the host as being alive.  This is called when we've received
 *	a message from the host.  It uses state from the host table and
 *	the bootID parameter to detect reboots.  If a reboot is detected
 *	but we though the host was up then the Crash call-backs are invoked.
 *	Otherwise a reboot just invokes the Reboot call-backs.  All call-backs
 *	are installed with Rpc_RebootNotify.
 *
 *	RPC Server processes are blocked in this procedure if they
 *	trigger the Crash call-backs, or if the Crash call-backs are
 *	in progress.  This prevents servicing requests from clients
 *	until the crash recovery actions have completed.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Updates the boot timestamp of the other host.  Procedures installed
 *	with Rpc_RebootNotify are called when the bootID changes.
 *
 *----------------------------------------------------------------------
 */

ENTRY void
RpcHostAlive(spriteID, bootID, asyncRecovery)
    int spriteID;		/* Host ID of the message sender */
    int bootID;			/* Boot time stamp from message header */
    Boolean asyncRecovery;	/* TRUE means do recovery call-backs in
				 * the background. FALSE causes the process
				 * to wait until the recovery is complete. */
{
    register Hash_Entry *hashPtr;
    register RecovHostState *hostPtr;
    char *name;
    Boolean reboot = FALSE;

    LOCK_MONITOR;
    if (spriteID == NET_BROADCAST_HOSTID ||
	bootID == 0) {
	/*
	 * Don't track the broadcast address.  Also ignore zero valued
	 * bootIDs.  These come from hosts at early boot time, or
	 * in certain error conditions like trying to send too much
	 * data in a single RPC.
	 */
	UNLOCK_MONITOR;
	return;
    }

    hashPtr = Hash_Find(recovHashTable, spriteID);
    if (hashPtr->value == (Address)NIL) {
	/*
	 * Initialize the host's state.
	 * This is the first time we've talked to it since we've been up,
	 * so take no action.
	 */

	hashPtr->value = (Address)Mem_Alloc(sizeof(RecovHostState));
	hostPtr = (RecovHostState *)hashPtr->value;
	hostPtr->state = RECOV_HOST_ALIVE;
	hostPtr->spriteID = spriteID;
	hostPtr->bootID = bootID;
	Net_SpriteIDToName(spriteID, &name);
	if (name == (char *)NIL) {
	    Sys_Printf("Sprite Host <%d> is up\n", spriteID);
	} else {
	    Sys_Printf("Sprite Host %s (%d) is up\n", name, spriteID);
	}
	RECOV_TRACE(spriteID, RECOV_HOST_ALIVE, RECOV_CUZ_INIT);
    } else {
	hostPtr = (RecovHostState *)hashPtr->value;
    }
    if (hostPtr != (RecovHostState *)NIL) {
	/*
	 * Have to read the clock in order to suppress repeated pings,
	 * see Rpc_HostIsDown.
	 */
	Timer_GetTimeOfDay(&hostPtr->time, (int *)NIL, (Boolean *)NIL);

	/*
	 * Check for a rebooted peer by comparing boot time stamps.
	 * The first process to detect this initiates recovery actions.
	 * Subsequent (server) processes are blocked during this time unless
	 * they (clients) specify asynchronous recovery.
	 */

	if (hostPtr->bootID != bootID) {
	    Net_SpriteIDToName(spriteID, &name);
	    if (name == (char *)NIL) {
		Sys_Printf("Sprite Host <%d> rebooted %d->%d\n", spriteID,
			hostPtr->bootID, bootID);
	    } else {
		Sys_Printf("Sprite Host %s (%d) rebooted %d->%d\n", name,
			hostPtr->spriteID, hostPtr->bootID, bootID);
	    }
	    hostPtr->bootID = bootID;
	    reboot = TRUE;
	    RECOV_TRACE(spriteID, hostPtr->state, RECOV_CUZ_REBOOT);
	    if (hostPtr->state & RECOV_HOST_ALIVE) {
		/*
		 * A crash occured un-detected.  We do the crash call-backs
		 * first, and block server processes in the meantime.
		 * RECOV_STATE_RECOVERING flag is reset by RpcCrashCallBacks.
		 * The host is marked dead here so we fall into the
		 * switch below and call the reboot callbacks.
		 */
		RECOV_TRACE(spriteID, RECOV_CRASH, RECOV_CUZ_REBOOT);
		hostPtr->state = RECOV_HOST_DEAD | RECOV_STATE_RECOVERING;
		Proc_CallFunc(RpcCrashCallBacks, spriteID, 0);
	    }
	}

	/*
	 * Block servers until crash recovery actions complete.
	 * Servers are synchronous with respect to reboot recovery.
	 * This blocks requests from clients until after the
	 * recovery actions complete.
	 */
	if (! asyncRecovery) {
	    while (hostPtr->state & RECOV_STATE_RECOVERING) {
		Sync_Wait(&hostPtr->recovery, FALSE);
		if (sys_ShuttingDown) {
		    Sys_Printf("Warning, Server exiting from RpcHostAlive\n");
		    Proc_Exit(1);
		}
	    }
	}
	/*
	 * Now that we've taken care of reboot recovery,
	 * we see if the host is newly up.  If so, invoke the reboot
	 * call-backs and then notify waiting processes.
	 * This means clientA (us) may start
	 * re-opening files from serverB (the other guy) at the same time
	 * as clientA is closing files that serverB had had open.
	 */
	switch(hostPtr->state & ~RECOV_STATE_RECOVERING) {
	    case RECOV_HOST_ALIVE:
		/*
		 * Host already alive.
		 */
		break;
	    case RECOV_HOST_DEAD: {
		/*
		 * Notify interested parties that the host is up.
		 */
		char *name;
		Net_SpriteIDToName(spriteID, &name);
		if (name == (char *)NIL) {
		    Sys_Printf("Sprite Host <%d> is now up\n", spriteID);
		} else {
		    Sys_Printf("Sprite Host %s (%d) is now up\n", name,
				spriteID);
		}
		hostPtr->state = RECOV_HOST_ALIVE;
		Sync_Broadcast(&hostPtr->alive)
		Proc_CallFunc(RpcRebootCallBacks, spriteID, 0);
		break;
	    default:
		Sys_Panic(SYS_WARNING, "Unexpected state <%x> for host %d\n",
			hostPtr->state, spriteID);
		break;
	    }
	}
    }
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * RpcRebootCallBacks --
 *
 *	This calls the call-back procedures installed by other modules
 *	via Rpc_RebootNotify.  It is invoked asynchronously from RpcHostAlive
 *	when that procedure detects a reboot.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Invoke the call-backs.
 *
 *----------------------------------------------------------------------
 */

void
RpcRebootCallBacks(data, callInfoPtr)
    ClientData data;
    Proc_CallInfo *callInfoPtr;
{
    register NotifyElement *notifyPtr;
    register int spriteID = (int)data;

    LIST_FORALL(&rpcNotifyList, (List_Links *)notifyPtr) {
	if (notifyPtr->flags & RPC_WHEN_HOST_REBOOTS) {
	    (*notifyPtr->proc)(spriteID, notifyPtr->clientData,
					 RPC_WHEN_HOST_REBOOTS);
	 }
    }
    RECOV_TRACE(spriteID, RECOV_REBOOT, RECOV_CUZ_DONE);
    callInfoPtr->interval = 0;	/* Don't call again */
}

/*
 *----------------------------------------------------------------------
 *
 * RpcCrashCallBacks --
 *
 *	Invoked asynchronously from RpcHostDead so that other modules
 *	can clean up behind the crashed host.  When done the host
 *	is marked as having recovery complete.  This unblock server
 *	processes stalled in RpcHostAlive.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Invoke the call-backs with the RPC_WHEN_HOST_DOWN flag.
 *	Clears the recovery in progress flag checked in RpcHostAlive.
 *
 *----------------------------------------------------------------------
 */

void
RpcCrashCallBacks(data, callInfoPtr)
    ClientData data;
    Proc_CallInfo *callInfoPtr;
{
    register NotifyElement *notifyPtr;
    register int spriteID = (int)data;

    LIST_FORALL(&rpcNotifyList, (List_Links *)notifyPtr) {
	if (notifyPtr->flags & RPC_WHEN_HOST_DOWN) {
	    (*notifyPtr->proc)(spriteID, notifyPtr->clientData,
					 RPC_WHEN_HOST_DOWN);
	 }
    }
    MarkRecoveryComplete(spriteID);
    RECOV_TRACE(spriteID, RECOV_CRASH, RECOV_CUZ_DONE);
    callInfoPtr->interval = 0;	/* Don't call again */
}

/*
 *----------------------------------------------------------------------
 *
 * MarkRecoveryComplete --
 *
 *	The recovery call-backs have completed, and this procedure's
 *	job is to mark that fact in the host hash table and to notify
 *	any processes that are blocked in RpcHostAlive waiting for this.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sets the state, if any, in the host state table.
 *	Notifies the hostPtr->recovery condition
 *
 *----------------------------------------------------------------------
 */

ENTRY static void
MarkRecoveryComplete(spriteID)
{
    register Hash_Entry *hashPtr;
    register RecovHostState *hostPtr;

    LOCK_MONITOR;

    hashPtr = Hash_LookOnly(recovHashTable, spriteID);
    if (hashPtr != (Hash_Entry *)NIL) {
	hostPtr = (RecovHostState *)hashPtr->value;
	if (hostPtr != (RecovHostState *)NIL) {
	    hostPtr->state &= ~RECOV_STATE_RECOVERING;
	    Sync_Broadcast(&hostPtr->recovery);
	}
    }
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * RpcHostDead --
 *
 *	Change the host's state to "dead".
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sets the state, if any, in the host state table.
 *
 *----------------------------------------------------------------------
 */

ENTRY void
RpcHostDead(spriteID)
    int spriteID;
{
    register Hash_Entry *hashPtr;
    register RecovHostState *hostPtr;

    LOCK_MONITOR;
    if (spriteID == NET_BROADCAST_HOSTID) {
	UNLOCK_MONITOR;
	return;
    }

    hashPtr = Hash_LookOnly(recovHashTable, spriteID);
    if (hashPtr != (Hash_Entry *)NIL) {
	hostPtr = (RecovHostState *)hashPtr->value;
	if (hostPtr != (RecovHostState *)NIL) {
	    MarkHostDead(hostPtr);
	}
    }
    UNLOCK_MONITOR;
}

/*
 *----------------------------------------------------------------------
 *
 * MarkHostDead --
 *
 *	Mark the host as down and call-back to other modules.  This
 *	also set up a background pinging process to detect reboot.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sets the state in the host state table, starts RpcHostCheck callback.
 *
 *----------------------------------------------------------------------
 */

INTERNAL static void
MarkHostDead(hostPtr)
    RecovHostState *hostPtr;
{
    char *name;
    switch(hostPtr->state) {
	case RECOV_HOST_DEAD:
	    /*
	     * Host already dead.
	     */
	    break;
	case RECOV_STATE_UNKNOWN:
	case RECOV_HOST_ALIVE:
	    hostPtr->state = RECOV_HOST_DEAD;
	    Net_SpriteIDToName(hostPtr->spriteID, &name);
	    if (name == (char *)NIL) {
		Sys_Printf("Sprite Host <%d> is down\n", hostPtr->spriteID);
	    } else {
		Sys_Printf("Sprite Host %s (%d) is down\n", name,
			    hostPtr->spriteID);
	    }
	    RECOV_TRACE(hostPtr->spriteID, hostPtr->state, RECOV_CUZ_CRASH);
	    Proc_CallFunc(RpcHostCheck, hostPtr->spriteID, 0);
	    hostPtr->state |= RECOV_STATE_RECOVERING;
	    Proc_CallFunc(RpcCrashCallBacks, hostPtr->spriteID, 0);
	    break;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * RpcHostCheck --
 *
 *	This is the call back setup when a process blocks on a down host.
 *	This simply pings the remote host and lets the RpcHostAlive
 *	call from Rpc_Call take care of triggering the wakeups of
 *	processes blocked on the host.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	This will ping the host.
 *
 *----------------------------------------------------------------------
 */

void
RpcHostCheck(data, callInfoPtr)
    ClientData data;
    Proc_CallInfo *callInfoPtr;
{
    register int spriteID = (int)data;
    ReturnStatus status;

    RECOV_TRACE(spriteID, RECOV_STATE_UNKNOWN, RECOV_CUZ_PING);
    if (Rpc_Ping(spriteID) != SUCCESS) {
	/*
	 * Try again later if the host is still down.
	 */
	callInfoPtr->interval = rpcPingSeconds * timer_IntOneSecond;
    } else {
	callInfoPtr->interval = 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Rpc_HostIsDown --
 *
 *	This decides if the specified host is down.  It will look into
 *	the host table to see if there aren't already processes waiting
 *	for the host to reboot.  If that is not the case and explicit
 *	ping is done to see if the host is still up.
 *
 * Results:
 *	TRUE is the host is apparently down.
 *
 * Side effects:
 *	May do a ping.
 *
 *----------------------------------------------------------------------
 */

ENTRY Boolean
Rpc_HostIsDown(spriteID)
    int spriteID;
{
    register Boolean down = FALSE;
    register ReturnStatus status;

    if (spriteID == NET_BROADCAST_HOSTID) {
	Sys_Panic(SYS_WARNING, "Rpc_HostIsDown, got broadcast address\n");
	return(FALSE);
    }
    switch (GetHostState(spriteID)) {
	case RECOV_STATE_UNKNOWN:
	    status = Rpc_Ping(spriteID);
	    if (status != SUCCESS) {
		down = TRUE;
	    }
	    break;
	case RECOV_HOST_ALIVE:
	    break;
	case RECOV_HOST_DEAD:
	    down = TRUE;
	    break;
    }
    return(down);
}

/*
 *----------------------------------------------------------------------
 *
 * GetHostState --
 *
 *	This looks into	the host table to see and provides a guess
 *	as to the host's current state.  It uses a timestamp kept in
 *	the host state to see if there's been recent message traffic.
 *	If so, RECOV_HOST_ALIVE is returned.  If not, RECOV_STATE_UNKNOWN
 *	is returned and the caller should ping to make sure.  Finally,
 *	if it is known that the host is down already, then RECOV_HOST_DEAD
 *	is returned.
 *
 * Results:
 *	RECOV_STATE_UNKNOWN if the caller should ping to make sure.
 *	RECOV_HOST_ALIVE if the host is up (recent message traffic).
 *	RECOV_HOST_DEAD if the host is down (recent timeouts).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ENTRY int
GetHostState(spriteID)
    int spriteID;
{
    register Hash_Entry *hashPtr;
    register RecovHostState *hostPtr;
    register int state = RECOV_STATE_UNKNOWN;
    Time time;

    LOCK_MONITOR;

    hashPtr = Hash_LookOnly(recovHashTable, spriteID);
    if (hashPtr != (Hash_Entry *)NIL) {
	hostPtr = (RecovHostState *)hashPtr->value;
	if (hostPtr != (RecovHostState *)NIL) {
	    state = hostPtr->state & ~RECOV_STATE_RECOVERING;
	    if (state == RECOV_HOST_ALIVE) {
		/*
		 * Check for recent message traffic before admitting
		 * that the other machine is up.
		 */
		Timer_GetTimeOfDay(&time, (int *)NIL, (Boolean *)NIL);
		Time_Subtract(time, hostPtr->time, &time);
		if (Time_GT(time, time_TenSeconds)) {
		    state = RECOV_STATE_UNKNOWN;
		}
	    }
	}
    }
    UNLOCK_MONITOR;
    return(state);
}

/*
 *----------------------------------------------------------------------
 *
 * Rpc_PrintRecovTraceRecord --
 *
 *	Format and print the client data part of a recovery trace record.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sys_Printf to the display.
 *
 *----------------------------------------------------------------------
 */
int
Rpc_PrintRecovTraceRecord(clientData, event, printHeaderFlag)
    ClientData clientData;	/* Client data in the trace record */
    int event;			/* Type, or event, from the trace record */
    Boolean printHeaderFlag;	/* If TRUE, a header line is printed */
{
    RpcRecovTraceRecord *recPtr = (RpcRecovTraceRecord *)clientData;
    char *name;
    if (printHeaderFlag) {
	/*
	 * Print column headers and a newline.
	 */
	Sys_Printf("%10s %10s %17s\n", "Host", "State", "Event ");
    }
    if (clientData != (ClientData)NIL) {
	Net_SpriteIDToName(recPtr->spriteID, &name);
	if (name == (char *)NIL) {
	    Sys_Printf("%10d ", recPtr->spriteID);
	} else {
	    Sys_Printf("%10s ", name);
	}
	switch(recPtr->state & ~RECOV_STATE_RECOVERING) {
	    case RECOV_STATE_UNKNOWN:
		Sys_Printf("%-8s", "Unknown");
		break;
	    case RECOV_HOST_ALIVE:
		Sys_Printf("%-8s ", "Alive");
		break;
	    case RECOV_HOST_DEAD:
		Sys_Printf("%-8s ", "Dead");
		break;
	    case RECOV_WAITING:
		Sys_Printf("%-8s ", "Waiting");
		break;
	    case RECOV_CRASH:
		Sys_Printf("%-8s ", "Crash callbacks");
		break;
	    case RECOV_REBOOT:
		Sys_Printf("%-8s ", "Reboot callbacks");
		break;
	}
	Sys_Printf("%3s", (recPtr->state & RECOV_STATE_RECOVERING) ?
			    " R " : "   ");
	switch(event) {
	    case RECOV_CUZ_WAIT:
		Sys_Printf("waiting");
		break;
	    case RECOV_CUZ_WAKEUP:
		Sys_Printf("wakeup");
		break;
	    case RECOV_CUZ_INIT:
		Sys_Printf("init");
		break;
	    case RECOV_CUZ_REBOOT:
		Sys_Printf("reboot");
		break;
	    case RECOV_CUZ_CRASH:
		Sys_Printf("crash");
		break;
	    case RECOV_CUZ_DONE:
		Sys_Printf("done");
		break;
	    case RECOV_CUZ_PING:
		Sys_Printf("ping");
		break;
	    default:
		Sys_Printf("(%x)", event);
		break;
	}
	/* Our caller prints a newline */
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Rpc_PrintRecovTrace --
 *
 *	Dump out the recovery trace.  Called via a console L1 keystroke.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Prints to the console.
 *
 *----------------------------------------------------------------------
 */

void
Rpc_PrintRecovTrace(numRecs)
    int numRecs;
{
    if (numRecs <= 0 || numRecs > rpcRecovTraceLength) {
	numRecs = rpcRecovTraceLength;
    }
    Sys_Printf("RECOVERY TRACE\n");
    Trace_Print(rpcRecovTraceHdrPtr, numRecs, Rpc_PrintRecovTraceRecord);
}


